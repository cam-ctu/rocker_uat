
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[16:01:39.673] plan(): Setting new future strategy stack:
[16:01:39.673] List of future strategies:
[16:01:39.673] 1. sequential:
[16:01:39.673]    - args: function (..., envir = parent.frame())
[16:01:39.673]    - tweaked: FALSE
[16:01:39.673]    - call: future::plan("sequential")
[16:01:39.688] plan(): nbrOfWorkers() = 1
> 
> message("*** future_apply() ...")
*** future_apply() ...
> 
> z0 <- NULL
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+ 
+   message("- From example(apply) ...")
+   X <- matrix(c(1:4, 1, 6:8), nrow = 2L)
+   
+   Y0 <- apply(X, MARGIN = 1L, FUN = table)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = table)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0, check.attributes = FALSE)) ## FIXME
+ 
+   Y2 <- future_apply(X, MARGIN = 1L, FUN = "table")
+   print(Y2)
+   stopifnot(identical(Y2, Y1))
+ 
+   Y0 <- apply(X, MARGIN = 1L, FUN = stats::quantile)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = stats::quantile)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0))
+ 
+   x <- cbind(x1 = 3, x2 = c(4:1, 2:5))
+   names(dimnames(x)) <- c("row", "col")
+   x3 <- array(x, dim = c(dim(x), 3),
+               dimnames = c(dimnames(x), list(C = paste0("cop.", 1:3))))
+   
+   y0 <- apply(x, MARGIN = 2L, FUN = identity)
+   stopifnot(identical(y0, x))
+   y1 <- future_apply(x, MARGIN = 2L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+   
+   y0 <- apply(x3, MARGIN = 2:3, FUN = identity)
+   stopifnot(identical(y0, x3))
+   y1 <- future_apply(x3, MARGIN = 2:3, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   z <- array(1:24, dim = 2:4)
+   y0 <- apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   y1 <- future_apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, MARGIN = <character>, ...) ...")
+   X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
+   y0 <- apply(X, MARGIN = "rows", FUN = identity)
+   y1 <- future_apply(X, MARGIN = "rows", FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - dim(X) > 2 ...")
+   X <- array(1:12, dim = c(2, 2, 3))
+   y0 <- apply(X, MARGIN = 1L, FUN = identity)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - not all same names ...")
+   FUN <- function(x) {
+     if (x[1] == 1L) names(x) <- letters[seq_along(x)]
+     x
+   }
+   X <- matrix(1:4, nrow = 2L, ncol = 2L)
+   y0 <- apply(X, MARGIN = 1L, FUN = FUN)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = FUN)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- example(future_apply) - reproducible RNG ...")
+   z1 <- future_apply(X, MARGIN = 1L, FUN = sample,
+           future.seed = 0xBEEF,
+           ## Test also all other 'future.*' arguments
+           future.stdout     = TRUE,
+           future.conditions = NULL,
+           future.globals    = TRUE,
+           future.packages   = NULL,
+           future.scheduling = 1.0,
+           future.chunk.size = NULL,
+           future.label      = "future_apply-%d"
+         )
+   print(z1)
+   if (is.null(z0)) {
+     z0 <- z1
+   } else {
+     stopifnot(identical(z1, z0))
+   }
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[16:01:39.747] plan(): Setting new future strategy stack:
[16:01:39.747] List of future strategies:
[16:01:39.747] 1. sequential:
[16:01:39.747]    - args: function (..., envir = parent.frame())
[16:01:39.747]    - tweaked: FALSE
[16:01:39.747]    - call: plan(strategy)
[16:01:39.758] plan(): nbrOfWorkers() = 1
- From example(apply) ...
[16:01:39.759] getGlobalsAndPackagesXApply() ...
[16:01:39.759]  - future.globals: TRUE
[16:01:39.760] getGlobalsAndPackages() ...
[16:01:39.760] Searching for globals...
[16:01:39.802] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[16:01:39.803] Searching for globals ... DONE
[16:01:39.803] Resolving globals: FALSE
[16:01:39.805] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[16:01:39.806] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[16:01:39.806] - globals: [1] ‘FUN’
[16:01:39.806] 
[16:01:39.806] getGlobalsAndPackages() ... DONE
[16:01:39.806]  - globals found/used: [n=1] ‘FUN’
[16:01:39.806]  - needed namespaces: [n=0] 
[16:01:39.806] Finding globals ... DONE
[16:01:39.807]  - use_args: TRUE
[16:01:39.807]  - Getting '...' globals ...
[16:01:39.808] resolve() on list ...
[16:01:39.808]  recursive: 0
[16:01:39.808]  length: 1
[16:01:39.808]  elements: ‘...’
[16:01:39.808]  length: 0 (resolved future 1)
[16:01:39.808] resolve() on list ... DONE
[16:01:39.808]    - '...' content: [n=0] 
[16:01:39.808] List of 1
[16:01:39.808]  $ ...: list()
[16:01:39.808]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:39.808]  - attr(*, "where")=List of 1
[16:01:39.808]   ..$ ...:<environment: 0x55fb645838c0> 
[16:01:39.808]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:39.808]  - attr(*, "resolved")= logi TRUE
[16:01:39.808]  - attr(*, "total_size")= num NA
[16:01:39.813]  - Getting '...' globals ... DONE
[16:01:39.814] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:39.814] List of 2
[16:01:39.814]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:01:39.814]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:01:39.814]  $ ...          : list()
[16:01:39.814]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:39.814]  - attr(*, "where")=List of 2
[16:01:39.814]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:39.814]   ..$ ...          :<environment: 0x55fb645838c0> 
[16:01:39.814]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:39.814]  - attr(*, "resolved")= logi FALSE
[16:01:39.814]  - attr(*, "total_size")= num 354224
[16:01:39.816] Packages to be attached in all futures: [n=0] 
[16:01:39.817] getGlobalsAndPackagesXApply() ... DONE
[16:01:39.817] future_lapply() ...
[16:01:39.851] Number of chunks: 1
[16:01:39.851] getGlobalsAndPackagesXApply() ...
[16:01:39.852]  - future.globals: <name-value list> with names ‘list()’
[16:01:39.852]  - use_args: TRUE
[16:01:39.852] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:01:39.852] List of 2
[16:01:39.852]  $ ...          : list()
[16:01:39.852]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:39.852]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:01:39.852]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:01:39.852]  - attr(*, "where")=List of 2
[16:01:39.852]   ..$ ...          :<environment: 0x55fb645838c0> 
[16:01:39.852]   ..$ ...future.FUN:<environment: namespace:base> 
[16:01:39.852]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:39.852]  - attr(*, "resolved")= logi FALSE
[16:01:39.852]  - attr(*, "total_size")= num NA
[16:01:39.855] Packages to be attached in all futures: [n=0] 
[16:01:39.856] getGlobalsAndPackagesXApply() ... DONE
[16:01:39.856] Number of futures (= number of chunks): 1
[16:01:39.856] Launching 1 futures (chunks) ...
[16:01:39.856] Chunk #1 of 1 ...
[16:01:39.856]  - seeds: <none>
[16:01:39.857]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:39.857] getGlobalsAndPackages() ...
[16:01:39.857] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:39.857] Resolving globals: FALSE
[16:01:39.857] Tweak future expression to call with '...' arguments ...
[16:01:39.857] {
[16:01:39.857]     do.call(function(...) {
[16:01:39.857]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:39.857]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:39.857]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:39.857]             on.exit(options(oopts), add = TRUE)
[16:01:39.857]         }
[16:01:39.857]         {
[16:01:39.857]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:39.857]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:39.857]                 ...future.FUN(...future.X_jj, ...)
[16:01:39.857]             })
[16:01:39.857]         }
[16:01:39.857]     }, args = future.call.arguments)
[16:01:39.857] }
[16:01:39.857] Tweak future expression to call with '...' arguments ... DONE
[16:01:39.858] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:39.858] 
[16:01:39.858] getGlobalsAndPackages() ... DONE
[16:01:39.859] run() for ‘Future’ ...
[16:01:39.859] - state: ‘created’
[16:01:39.859] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:01:39.860] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:39.860] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:39.860]   - Field: ‘label’
[16:01:39.860]   - Field: ‘local’
[16:01:39.860]   - Field: ‘owner’
[16:01:39.860]   - Field: ‘envir’
[16:01:39.860]   - Field: ‘packages’
[16:01:39.860]   - Field: ‘gc’
[16:01:39.860]   - Field: ‘conditions’
[16:01:39.860]   - Field: ‘expr’
[16:01:39.861]   - Field: ‘uuid’
[16:01:39.861]   - Field: ‘seed’
[16:01:39.861]   - Field: ‘version’
[16:01:39.861]   - Field: ‘result’
[16:01:39.861]   - Field: ‘asynchronous’
[16:01:39.861]   - Field: ‘calls’
[16:01:39.861]   - Field: ‘globals’
[16:01:39.861]   - Field: ‘stdout’
[16:01:39.861]   - Field: ‘earlySignal’
[16:01:39.861]   - Field: ‘lazy’
[16:01:39.861]   - Field: ‘state’
[16:01:39.862] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:39.862] - Launch lazy future ...
[16:01:39.863] Packages needed by the future expression (n = 0): <none>
[16:01:39.863] Packages needed by future strategies (n = 0): <none>
[16:01:39.863] {
[16:01:39.863]     {
[16:01:39.863]         {
[16:01:39.863]             ...future.startTime <- base::Sys.time()
[16:01:39.863]             {
[16:01:39.863]                 {
[16:01:39.863]                   {
[16:01:39.863]                     base::local({
[16:01:39.863]                       has_future <- base::requireNamespace("future", 
[16:01:39.863]                         quietly = TRUE)
[16:01:39.863]                       if (has_future) {
[16:01:39.863]                         ns <- base::getNamespace("future")
[16:01:39.863]                         version <- ns[[".package"]][["version"]]
[16:01:39.863]                         if (is.null(version)) 
[16:01:39.863]                           version <- utils::packageVersion("future")
[16:01:39.863]                       }
[16:01:39.863]                       else {
[16:01:39.863]                         version <- NULL
[16:01:39.863]                       }
[16:01:39.863]                       if (!has_future || version < "1.8.0") {
[16:01:39.863]                         info <- base::c(r_version = base::gsub("R version ", 
[16:01:39.863]                           "", base::R.version$version.string), 
[16:01:39.863]                           platform = base::sprintf("%s (%s-bit)", 
[16:01:39.863]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:39.863]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:39.863]                             "release", "version")], collapse = " "), 
[16:01:39.863]                           hostname = base::Sys.info()[["nodename"]])
[16:01:39.863]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:01:39.863]                           info)
[16:01:39.863]                         info <- base::paste(info, collapse = "; ")
[16:01:39.863]                         if (!has_future) {
[16:01:39.863]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:39.863]                             info)
[16:01:39.863]                         }
[16:01:39.863]                         else {
[16:01:39.863]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:39.863]                             info, version)
[16:01:39.863]                         }
[16:01:39.863]                         base::stop(msg)
[16:01:39.863]                       }
[16:01:39.863]                     })
[16:01:39.863]                   }
[16:01:39.863]                   options(future.plan = NULL)
[16:01:39.863]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:39.863]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:39.863]                 }
[16:01:39.863]                 ...future.workdir <- getwd()
[16:01:39.863]             }
[16:01:39.863]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:39.863]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:39.863]         }
[16:01:39.863]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:39.863]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:39.863]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:39.863]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:39.863]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:39.863]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:39.863]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:39.863]             base::names(...future.oldOptions))
[16:01:39.863]     }
[16:01:39.863]     if (FALSE) {
[16:01:39.863]     }
[16:01:39.863]     else {
[16:01:39.863]         if (TRUE) {
[16:01:39.863]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:39.863]                 open = "w")
[16:01:39.863]         }
[16:01:39.863]         else {
[16:01:39.863]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:39.863]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:39.863]         }
[16:01:39.863]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:39.863]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:39.863]             base::sink(type = "output", split = FALSE)
[16:01:39.863]             base::close(...future.stdout)
[16:01:39.863]         }, add = TRUE)
[16:01:39.863]     }
[16:01:39.863]     ...future.frame <- base::sys.nframe()
[16:01:39.863]     ...future.conditions <- base::list()
[16:01:39.863]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:39.863]     if (FALSE) {
[16:01:39.863]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:39.863]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:39.863]     }
[16:01:39.863]     ...future.result <- base::tryCatch({
[16:01:39.863]         base::withCallingHandlers({
[16:01:39.863]             ...future.value <- base::withVisible(base::local({
[16:01:39.863]                 do.call(function(...) {
[16:01:39.863]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:39.863]                   if (!identical(...future.globals.maxSize.org, 
[16:01:39.863]                     ...future.globals.maxSize)) {
[16:01:39.863]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:39.863]                     on.exit(options(oopts), add = TRUE)
[16:01:39.863]                   }
[16:01:39.863]                   {
[16:01:39.863]                     lapply(seq_along(...future.elements_ii), 
[16:01:39.863]                       FUN = function(jj) {
[16:01:39.863]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:39.863]                         ...future.FUN(...future.X_jj, ...)
[16:01:39.863]                       })
[16:01:39.863]                   }
[16:01:39.863]                 }, args = future.call.arguments)
[16:01:39.863]             }))
[16:01:39.863]             future::FutureResult(value = ...future.value$value, 
[16:01:39.863]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:39.863]                   ...future.rng), globalenv = if (FALSE) 
[16:01:39.863]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:39.863]                     ...future.globalenv.names))
[16:01:39.863]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:39.863]         }, condition = base::local({
[16:01:39.863]             c <- base::c
[16:01:39.863]             inherits <- base::inherits
[16:01:39.863]             invokeRestart <- base::invokeRestart
[16:01:39.863]             length <- base::length
[16:01:39.863]             list <- base::list
[16:01:39.863]             seq.int <- base::seq.int
[16:01:39.863]             signalCondition <- base::signalCondition
[16:01:39.863]             sys.calls <- base::sys.calls
[16:01:39.863]             `[[` <- base::`[[`
[16:01:39.863]             `+` <- base::`+`
[16:01:39.863]             `<<-` <- base::`<<-`
[16:01:39.863]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:39.863]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:39.863]                   3L)]
[16:01:39.863]             }
[16:01:39.863]             function(cond) {
[16:01:39.863]                 is_error <- inherits(cond, "error")
[16:01:39.863]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:39.863]                   NULL)
[16:01:39.863]                 if (is_error) {
[16:01:39.863]                   sessionInformation <- function() {
[16:01:39.863]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:39.863]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:39.863]                       search = base::search(), system = base::Sys.info())
[16:01:39.863]                   }
[16:01:39.863]                   ...future.conditions[[length(...future.conditions) + 
[16:01:39.863]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:39.863]                     cond$call), session = sessionInformation(), 
[16:01:39.863]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:39.863]                   signalCondition(cond)
[16:01:39.863]                 }
[16:01:39.863]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:39.863]                 "immediateCondition"))) {
[16:01:39.863]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:39.863]                   ...future.conditions[[length(...future.conditions) + 
[16:01:39.863]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:39.863]                   if (TRUE && !signal) {
[16:01:39.863]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:39.863]                     {
[16:01:39.863]                       inherits <- base::inherits
[16:01:39.863]                       invokeRestart <- base::invokeRestart
[16:01:39.863]                       is.null <- base::is.null
[16:01:39.863]                       muffled <- FALSE
[16:01:39.863]                       if (inherits(cond, "message")) {
[16:01:39.863]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:39.863]                         if (muffled) 
[16:01:39.863]                           invokeRestart("muffleMessage")
[16:01:39.863]                       }
[16:01:39.863]                       else if (inherits(cond, "warning")) {
[16:01:39.863]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:39.863]                         if (muffled) 
[16:01:39.863]                           invokeRestart("muffleWarning")
[16:01:39.863]                       }
[16:01:39.863]                       else if (inherits(cond, "condition")) {
[16:01:39.863]                         if (!is.null(pattern)) {
[16:01:39.863]                           computeRestarts <- base::computeRestarts
[16:01:39.863]                           grepl <- base::grepl
[16:01:39.863]                           restarts <- computeRestarts(cond)
[16:01:39.863]                           for (restart in restarts) {
[16:01:39.863]                             name <- restart$name
[16:01:39.863]                             if (is.null(name)) 
[16:01:39.863]                               next
[16:01:39.863]                             if (!grepl(pattern, name)) 
[16:01:39.863]                               next
[16:01:39.863]                             invokeRestart(restart)
[16:01:39.863]                             muffled <- TRUE
[16:01:39.863]                             break
[16:01:39.863]                           }
[16:01:39.863]                         }
[16:01:39.863]                       }
[16:01:39.863]                       invisible(muffled)
[16:01:39.863]                     }
[16:01:39.863]                     muffleCondition(cond, pattern = "^muffle")
[16:01:39.863]                   }
[16:01:39.863]                 }
[16:01:39.863]                 else {
[16:01:39.863]                   if (TRUE) {
[16:01:39.863]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:39.863]                     {
[16:01:39.863]                       inherits <- base::inherits
[16:01:39.863]                       invokeRestart <- base::invokeRestart
[16:01:39.863]                       is.null <- base::is.null
[16:01:39.863]                       muffled <- FALSE
[16:01:39.863]                       if (inherits(cond, "message")) {
[16:01:39.863]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:39.863]                         if (muffled) 
[16:01:39.863]                           invokeRestart("muffleMessage")
[16:01:39.863]                       }
[16:01:39.863]                       else if (inherits(cond, "warning")) {
[16:01:39.863]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:39.863]                         if (muffled) 
[16:01:39.863]                           invokeRestart("muffleWarning")
[16:01:39.863]                       }
[16:01:39.863]                       else if (inherits(cond, "condition")) {
[16:01:39.863]                         if (!is.null(pattern)) {
[16:01:39.863]                           computeRestarts <- base::computeRestarts
[16:01:39.863]                           grepl <- base::grepl
[16:01:39.863]                           restarts <- computeRestarts(cond)
[16:01:39.863]                           for (restart in restarts) {
[16:01:39.863]                             name <- restart$name
[16:01:39.863]                             if (is.null(name)) 
[16:01:39.863]                               next
[16:01:39.863]                             if (!grepl(pattern, name)) 
[16:01:39.863]                               next
[16:01:39.863]                             invokeRestart(restart)
[16:01:39.863]                             muffled <- TRUE
[16:01:39.863]                             break
[16:01:39.863]                           }
[16:01:39.863]                         }
[16:01:39.863]                       }
[16:01:39.863]                       invisible(muffled)
[16:01:39.863]                     }
[16:01:39.863]                     muffleCondition(cond, pattern = "^muffle")
[16:01:39.863]                   }
[16:01:39.863]                 }
[16:01:39.863]             }
[16:01:39.863]         }))
[16:01:39.863]     }, error = function(ex) {
[16:01:39.863]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:39.863]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:39.863]                 ...future.rng), started = ...future.startTime, 
[16:01:39.863]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:39.863]             version = "1.8"), class = "FutureResult")
[16:01:39.863]     }, finally = {
[16:01:39.863]         if (!identical(...future.workdir, getwd())) 
[16:01:39.863]             setwd(...future.workdir)
[16:01:39.863]         {
[16:01:39.863]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:39.863]                 ...future.oldOptions$nwarnings <- NULL
[16:01:39.863]             }
[16:01:39.863]             base::options(...future.oldOptions)
[16:01:39.863]             if (.Platform$OS.type == "windows") {
[16:01:39.863]                 old_names <- names(...future.oldEnvVars)
[16:01:39.863]                 envs <- base::Sys.getenv()
[16:01:39.863]                 names <- names(envs)
[16:01:39.863]                 common <- intersect(names, old_names)
[16:01:39.863]                 added <- setdiff(names, old_names)
[16:01:39.863]                 removed <- setdiff(old_names, names)
[16:01:39.863]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:39.863]                   envs[common]]
[16:01:39.863]                 NAMES <- toupper(changed)
[16:01:39.863]                 args <- list()
[16:01:39.863]                 for (kk in seq_along(NAMES)) {
[16:01:39.863]                   name <- changed[[kk]]
[16:01:39.863]                   NAME <- NAMES[[kk]]
[16:01:39.863]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:39.863]                     next
[16:01:39.863]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:39.863]                 }
[16:01:39.863]                 NAMES <- toupper(added)
[16:01:39.863]                 for (kk in seq_along(NAMES)) {
[16:01:39.863]                   name <- added[[kk]]
[16:01:39.863]                   NAME <- NAMES[[kk]]
[16:01:39.863]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:39.863]                     next
[16:01:39.863]                   args[[name]] <- ""
[16:01:39.863]                 }
[16:01:39.863]                 NAMES <- toupper(removed)
[16:01:39.863]                 for (kk in seq_along(NAMES)) {
[16:01:39.863]                   name <- removed[[kk]]
[16:01:39.863]                   NAME <- NAMES[[kk]]
[16:01:39.863]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:39.863]                     next
[16:01:39.863]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:39.863]                 }
[16:01:39.863]                 if (length(args) > 0) 
[16:01:39.863]                   base::do.call(base::Sys.setenv, args = args)
[16:01:39.863]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:39.863]             }
[16:01:39.863]             else {
[16:01:39.863]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:39.863]             }
[16:01:39.863]             {
[16:01:39.863]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:39.863]                   0L) {
[16:01:39.863]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:39.863]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:39.863]                   base::options(opts)
[16:01:39.863]                 }
[16:01:39.863]                 {
[16:01:39.863]                   {
[16:01:39.863]                     NULL
[16:01:39.863]                     RNGkind("Mersenne-Twister")
[16:01:39.863]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:39.863]                       inherits = FALSE)
[16:01:39.863]                   }
[16:01:39.863]                   options(future.plan = NULL)
[16:01:39.863]                   if (is.na(NA_character_)) 
[16:01:39.863]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:39.863]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:39.863]                   future::plan(list(function (..., envir = parent.frame()) 
[16:01:39.863]                   {
[16:01:39.863]                     future <- SequentialFuture(..., envir = envir)
[16:01:39.863]                     if (!future$lazy) 
[16:01:39.863]                       future <- run(future)
[16:01:39.863]                     invisible(future)
[16:01:39.863]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:39.863]                 }
[16:01:39.863]             }
[16:01:39.863]         }
[16:01:39.863]     })
[16:01:39.863]     if (TRUE) {
[16:01:39.863]         base::sink(type = "output", split = FALSE)
[16:01:39.863]         if (TRUE) {
[16:01:39.863]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:39.863]         }
[16:01:39.863]         else {
[16:01:39.863]             ...future.result["stdout"] <- base::list(NULL)
[16:01:39.863]         }
[16:01:39.863]         base::close(...future.stdout)
[16:01:39.863]         ...future.stdout <- NULL
[16:01:39.863]     }
[16:01:39.863]     ...future.result$conditions <- ...future.conditions
[16:01:39.863]     ...future.result$finished <- base::Sys.time()
[16:01:39.863]     ...future.result
[16:01:39.863] }
[16:01:39.865] assign_globals() ...
[16:01:39.865] List of 5
[16:01:39.865]  $ future.call.arguments    : list()
[16:01:39.865]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:39.865]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:01:39.865]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:01:39.865]  $ ...future.elements_ii    :List of 2
[16:01:39.865]   ..$ : num [1:4] 1 3 1 7
[16:01:39.865]   ..$ : num [1:4] 2 4 6 8
[16:01:39.865]  $ ...future.seeds_ii       : NULL
[16:01:39.865]  $ ...future.globals.maxSize: num Inf
[16:01:39.865]  - attr(*, "resolved")= logi FALSE
[16:01:39.865]  - attr(*, "total_size")= num NA
[16:01:39.865]  - attr(*, "where")=List of 5
[16:01:39.865]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:39.865]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:39.865]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:39.865]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:39.865]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:39.865]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:39.865]  - attr(*, "already-done")= logi TRUE
[16:01:39.870] - copied ‘future.call.arguments’ to environment
[16:01:39.871] - copied ‘...future.FUN’ to environment
[16:01:39.871] - copied ‘...future.elements_ii’ to environment
[16:01:39.871] - copied ‘...future.seeds_ii’ to environment
[16:01:39.871] - copied ‘...future.globals.maxSize’ to environment
[16:01:39.871] assign_globals() ... done
[16:01:39.871] plan(): Setting new future strategy stack:
[16:01:39.871] List of future strategies:
[16:01:39.871] 1. sequential:
[16:01:39.871]    - args: function (..., envir = parent.frame())
[16:01:39.871]    - tweaked: FALSE
[16:01:39.871]    - call: NULL
[16:01:39.872] plan(): nbrOfWorkers() = 1
[16:01:39.873] plan(): Setting new future strategy stack:
[16:01:39.873] List of future strategies:
[16:01:39.873] 1. sequential:
[16:01:39.873]    - args: function (..., envir = parent.frame())
[16:01:39.873]    - tweaked: FALSE
[16:01:39.873]    - call: plan(strategy)
[16:01:39.874] plan(): nbrOfWorkers() = 1
[16:01:39.874] SequentialFuture started (and completed)
[16:01:39.874] - Launch lazy future ... done
[16:01:39.874] run() for ‘SequentialFuture’ ... done
[16:01:39.875] Created future:
[16:01:39.875] SequentialFuture:
[16:01:39.875] Label: ‘future_apply-1’
[16:01:39.875] Expression:
[16:01:39.875] {
[16:01:39.875]     do.call(function(...) {
[16:01:39.875]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:39.875]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:39.875]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:39.875]             on.exit(options(oopts), add = TRUE)
[16:01:39.875]         }
[16:01:39.875]         {
[16:01:39.875]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:39.875]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:39.875]                 ...future.FUN(...future.X_jj, ...)
[16:01:39.875]             })
[16:01:39.875]         }
[16:01:39.875]     }, args = future.call.arguments)
[16:01:39.875] }
[16:01:39.875] Lazy evaluation: FALSE
[16:01:39.875] Asynchronous evaluation: FALSE
[16:01:39.875] Local evaluation: TRUE
[16:01:39.875] Environment: R_GlobalEnv
[16:01:39.875] Capture standard output: TRUE
[16:01:39.875] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:39.875] Globals: 5 objects totaling 346.13 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:39.875] Packages: <none>
[16:01:39.875] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:39.875] Resolved: TRUE
[16:01:39.875] Value: 2.21 KiB of class ‘list’
[16:01:39.875] Early signaling: FALSE
[16:01:39.875] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:39.875] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:39.878] Chunk #1 of 1 ... DONE
[16:01:39.878] Launching 1 futures (chunks) ... DONE
[16:01:39.878] Resolving 1 futures (chunks) ...
[16:01:39.879] resolve() on list ...
[16:01:39.879]  recursive: 0
[16:01:39.879]  length: 1
[16:01:39.879] 
[16:01:39.879] resolved() for ‘SequentialFuture’ ...
[16:01:39.879] - state: ‘finished’
[16:01:39.879] - run: TRUE
[16:01:39.879] - result: ‘FutureResult’
[16:01:39.880] resolved() for ‘SequentialFuture’ ... done
[16:01:39.880] Future #1
[16:01:39.880] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:39.880] - nx: 1
[16:01:39.880] - relay: TRUE
[16:01:39.880] - stdout: TRUE
[16:01:39.880] - signal: TRUE
[16:01:39.881] - resignal: FALSE
[16:01:39.881] - force: TRUE
[16:01:39.881] - relayed: [n=1] FALSE
[16:01:39.881] - queued futures: [n=1] FALSE
[16:01:39.881]  - until=1
[16:01:39.881]  - relaying element #1
[16:01:39.881] - relayed: [n=1] TRUE
[16:01:39.881] - queued futures: [n=1] TRUE
[16:01:39.881] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:39.882]  length: 0 (resolved future 1)
[16:01:39.882] Relaying remaining futures
[16:01:39.882] signalConditionsASAP(NULL, pos=0) ...
[16:01:39.882] - nx: 1
[16:01:39.882] - relay: TRUE
[16:01:39.882] - stdout: TRUE
[16:01:39.882] - signal: TRUE
[16:01:39.882] - resignal: FALSE
[16:01:39.882] - force: TRUE
[16:01:39.882] - relayed: [n=1] TRUE
[16:01:39.882] - queued futures: [n=1] TRUE
 - flush all
[16:01:39.883] - relayed: [n=1] TRUE
[16:01:39.883] - queued futures: [n=1] TRUE
[16:01:39.883] signalConditionsASAP(NULL, pos=0) ... done
[16:01:39.883] resolve() on list ... DONE
[16:01:39.883]  - Number of value chunks collected: 1
[16:01:39.883] Resolving 1 futures (chunks) ... DONE
[16:01:39.883] Reducing values from 1 chunks ...
[16:01:39.883]  - Number of values collected after concatenation: 2
[16:01:39.883]  - Number of values expected: 2
[16:01:39.884] Reducing values from 1 chunks ... DONE
[16:01:39.884] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[16:01:39.885] getGlobalsAndPackagesXApply() ...
[16:01:39.885]  - future.globals: TRUE
[16:01:39.885] getGlobalsAndPackages() ...
[16:01:39.885] Searching for globals...
[16:01:39.920] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[16:01:39.921] Searching for globals ... DONE
[16:01:39.921] Resolving globals: FALSE
[16:01:39.922] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[16:01:39.923] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[16:01:39.923] - globals: [1] ‘FUN’
[16:01:39.923] 
[16:01:39.923] getGlobalsAndPackages() ... DONE
[16:01:39.923]  - globals found/used: [n=1] ‘FUN’
[16:01:39.923]  - needed namespaces: [n=0] 
[16:01:39.923] Finding globals ... DONE
[16:01:39.923]  - use_args: TRUE
[16:01:39.924]  - Getting '...' globals ...
[16:01:39.924] resolve() on list ...
[16:01:39.924]  recursive: 0
[16:01:39.924]  length: 1
[16:01:39.924]  elements: ‘...’
[16:01:39.924]  length: 0 (resolved future 1)
[16:01:39.924] resolve() on list ... DONE
[16:01:39.924]    - '...' content: [n=0] 
[16:01:39.925] List of 1
[16:01:39.925]  $ ...: list()
[16:01:39.925]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:39.925]  - attr(*, "where")=List of 1
[16:01:39.925]   ..$ ...:<environment: 0x55fb623d64f0> 
[16:01:39.925]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:39.925]  - attr(*, "resolved")= logi TRUE
[16:01:39.925]  - attr(*, "total_size")= num NA
[16:01:39.927]  - Getting '...' globals ... DONE
[16:01:39.927] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:39.927] List of 2
[16:01:39.927]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:01:39.927]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:01:39.927]  $ ...          : list()
[16:01:39.927]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:39.927]  - attr(*, "where")=List of 2
[16:01:39.927]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:39.927]   ..$ ...          :<environment: 0x55fb623d64f0> 
[16:01:39.927]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:39.927]  - attr(*, "resolved")= logi FALSE
[16:01:39.927]  - attr(*, "total_size")= num 354224
[16:01:39.930] Packages to be attached in all futures: [n=0] 
[16:01:39.930] getGlobalsAndPackagesXApply() ... DONE
[16:01:39.930] future_lapply() ...
[16:01:39.964] Number of chunks: 1
[16:01:39.964] getGlobalsAndPackagesXApply() ...
[16:01:39.964]  - future.globals: <name-value list> with names ‘list()’
[16:01:39.965]  - use_args: TRUE
[16:01:39.965] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:01:39.965] List of 2
[16:01:39.965]  $ ...          : list()
[16:01:39.965]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:39.965]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:01:39.965]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:01:39.965]  - attr(*, "where")=List of 2
[16:01:39.965]   ..$ ...          :<environment: 0x55fb623d64f0> 
[16:01:39.965]   ..$ ...future.FUN:<environment: namespace:base> 
[16:01:39.965]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:39.965]  - attr(*, "resolved")= logi FALSE
[16:01:39.965]  - attr(*, "total_size")= num NA
[16:01:39.968] Packages to be attached in all futures: [n=0] 
[16:01:39.968] getGlobalsAndPackagesXApply() ... DONE
[16:01:39.969] Number of futures (= number of chunks): 1
[16:01:39.969] Launching 1 futures (chunks) ...
[16:01:39.969] Chunk #1 of 1 ...
[16:01:39.969]  - seeds: <none>
[16:01:39.969]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:39.969] getGlobalsAndPackages() ...
[16:01:39.969] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:39.969] Resolving globals: FALSE
[16:01:39.969] Tweak future expression to call with '...' arguments ...
[16:01:39.970] {
[16:01:39.970]     do.call(function(...) {
[16:01:39.970]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:39.970]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:39.970]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:39.970]             on.exit(options(oopts), add = TRUE)
[16:01:39.970]         }
[16:01:39.970]         {
[16:01:39.970]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:39.970]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:39.970]                 ...future.FUN(...future.X_jj, ...)
[16:01:39.970]             })
[16:01:39.970]         }
[16:01:39.970]     }, args = future.call.arguments)
[16:01:39.970] }
[16:01:39.970] Tweak future expression to call with '...' arguments ... DONE
[16:01:39.970] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:39.970] 
[16:01:39.970] getGlobalsAndPackages() ... DONE
[16:01:39.971] run() for ‘Future’ ...
[16:01:39.971] - state: ‘created’
[16:01:39.971] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:01:39.971] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:39.971] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:39.971]   - Field: ‘label’
[16:01:39.972]   - Field: ‘local’
[16:01:39.972]   - Field: ‘owner’
[16:01:39.972]   - Field: ‘envir’
[16:01:39.972]   - Field: ‘packages’
[16:01:39.972]   - Field: ‘gc’
[16:01:39.972]   - Field: ‘conditions’
[16:01:39.972]   - Field: ‘expr’
[16:01:39.972]   - Field: ‘uuid’
[16:01:39.972]   - Field: ‘seed’
[16:01:39.972]   - Field: ‘version’
[16:01:39.973]   - Field: ‘result’
[16:01:39.973]   - Field: ‘asynchronous’
[16:01:39.973]   - Field: ‘calls’
[16:01:39.973]   - Field: ‘globals’
[16:01:39.973]   - Field: ‘stdout’
[16:01:39.973]   - Field: ‘earlySignal’
[16:01:39.973]   - Field: ‘lazy’
[16:01:39.973]   - Field: ‘state’
[16:01:39.973] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:39.973] - Launch lazy future ...
[16:01:39.974] Packages needed by the future expression (n = 0): <none>
[16:01:39.974] Packages needed by future strategies (n = 0): <none>
[16:01:39.974] {
[16:01:39.974]     {
[16:01:39.974]         {
[16:01:39.974]             ...future.startTime <- base::Sys.time()
[16:01:39.974]             {
[16:01:39.974]                 {
[16:01:39.974]                   {
[16:01:39.974]                     base::local({
[16:01:39.974]                       has_future <- base::requireNamespace("future", 
[16:01:39.974]                         quietly = TRUE)
[16:01:39.974]                       if (has_future) {
[16:01:39.974]                         ns <- base::getNamespace("future")
[16:01:39.974]                         version <- ns[[".package"]][["version"]]
[16:01:39.974]                         if (is.null(version)) 
[16:01:39.974]                           version <- utils::packageVersion("future")
[16:01:39.974]                       }
[16:01:39.974]                       else {
[16:01:39.974]                         version <- NULL
[16:01:39.974]                       }
[16:01:39.974]                       if (!has_future || version < "1.8.0") {
[16:01:39.974]                         info <- base::c(r_version = base::gsub("R version ", 
[16:01:39.974]                           "", base::R.version$version.string), 
[16:01:39.974]                           platform = base::sprintf("%s (%s-bit)", 
[16:01:39.974]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:39.974]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:39.974]                             "release", "version")], collapse = " "), 
[16:01:39.974]                           hostname = base::Sys.info()[["nodename"]])
[16:01:39.974]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:01:39.974]                           info)
[16:01:39.974]                         info <- base::paste(info, collapse = "; ")
[16:01:39.974]                         if (!has_future) {
[16:01:39.974]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:39.974]                             info)
[16:01:39.974]                         }
[16:01:39.974]                         else {
[16:01:39.974]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:39.974]                             info, version)
[16:01:39.974]                         }
[16:01:39.974]                         base::stop(msg)
[16:01:39.974]                       }
[16:01:39.974]                     })
[16:01:39.974]                   }
[16:01:39.974]                   options(future.plan = NULL)
[16:01:39.974]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:39.974]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:39.974]                 }
[16:01:39.974]                 ...future.workdir <- getwd()
[16:01:39.974]             }
[16:01:39.974]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:39.974]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:39.974]         }
[16:01:39.974]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:39.974]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:39.974]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:39.974]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:39.974]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:39.974]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:39.974]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:39.974]             base::names(...future.oldOptions))
[16:01:39.974]     }
[16:01:39.974]     if (FALSE) {
[16:01:39.974]     }
[16:01:39.974]     else {
[16:01:39.974]         if (TRUE) {
[16:01:39.974]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:39.974]                 open = "w")
[16:01:39.974]         }
[16:01:39.974]         else {
[16:01:39.974]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:39.974]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:39.974]         }
[16:01:39.974]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:39.974]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:39.974]             base::sink(type = "output", split = FALSE)
[16:01:39.974]             base::close(...future.stdout)
[16:01:39.974]         }, add = TRUE)
[16:01:39.974]     }
[16:01:39.974]     ...future.frame <- base::sys.nframe()
[16:01:39.974]     ...future.conditions <- base::list()
[16:01:39.974]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:39.974]     if (FALSE) {
[16:01:39.974]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:39.974]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:39.974]     }
[16:01:39.974]     ...future.result <- base::tryCatch({
[16:01:39.974]         base::withCallingHandlers({
[16:01:39.974]             ...future.value <- base::withVisible(base::local({
[16:01:39.974]                 do.call(function(...) {
[16:01:39.974]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:39.974]                   if (!identical(...future.globals.maxSize.org, 
[16:01:39.974]                     ...future.globals.maxSize)) {
[16:01:39.974]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:39.974]                     on.exit(options(oopts), add = TRUE)
[16:01:39.974]                   }
[16:01:39.974]                   {
[16:01:39.974]                     lapply(seq_along(...future.elements_ii), 
[16:01:39.974]                       FUN = function(jj) {
[16:01:39.974]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:39.974]                         ...future.FUN(...future.X_jj, ...)
[16:01:39.974]                       })
[16:01:39.974]                   }
[16:01:39.974]                 }, args = future.call.arguments)
[16:01:39.974]             }))
[16:01:39.974]             future::FutureResult(value = ...future.value$value, 
[16:01:39.974]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:39.974]                   ...future.rng), globalenv = if (FALSE) 
[16:01:39.974]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:39.974]                     ...future.globalenv.names))
[16:01:39.974]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:39.974]         }, condition = base::local({
[16:01:39.974]             c <- base::c
[16:01:39.974]             inherits <- base::inherits
[16:01:39.974]             invokeRestart <- base::invokeRestart
[16:01:39.974]             length <- base::length
[16:01:39.974]             list <- base::list
[16:01:39.974]             seq.int <- base::seq.int
[16:01:39.974]             signalCondition <- base::signalCondition
[16:01:39.974]             sys.calls <- base::sys.calls
[16:01:39.974]             `[[` <- base::`[[`
[16:01:39.974]             `+` <- base::`+`
[16:01:39.974]             `<<-` <- base::`<<-`
[16:01:39.974]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:39.974]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:39.974]                   3L)]
[16:01:39.974]             }
[16:01:39.974]             function(cond) {
[16:01:39.974]                 is_error <- inherits(cond, "error")
[16:01:39.974]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:39.974]                   NULL)
[16:01:39.974]                 if (is_error) {
[16:01:39.974]                   sessionInformation <- function() {
[16:01:39.974]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:39.974]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:39.974]                       search = base::search(), system = base::Sys.info())
[16:01:39.974]                   }
[16:01:39.974]                   ...future.conditions[[length(...future.conditions) + 
[16:01:39.974]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:39.974]                     cond$call), session = sessionInformation(), 
[16:01:39.974]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:39.974]                   signalCondition(cond)
[16:01:39.974]                 }
[16:01:39.974]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:39.974]                 "immediateCondition"))) {
[16:01:39.974]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:39.974]                   ...future.conditions[[length(...future.conditions) + 
[16:01:39.974]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:39.974]                   if (TRUE && !signal) {
[16:01:39.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:39.974]                     {
[16:01:39.974]                       inherits <- base::inherits
[16:01:39.974]                       invokeRestart <- base::invokeRestart
[16:01:39.974]                       is.null <- base::is.null
[16:01:39.974]                       muffled <- FALSE
[16:01:39.974]                       if (inherits(cond, "message")) {
[16:01:39.974]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:39.974]                         if (muffled) 
[16:01:39.974]                           invokeRestart("muffleMessage")
[16:01:39.974]                       }
[16:01:39.974]                       else if (inherits(cond, "warning")) {
[16:01:39.974]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:39.974]                         if (muffled) 
[16:01:39.974]                           invokeRestart("muffleWarning")
[16:01:39.974]                       }
[16:01:39.974]                       else if (inherits(cond, "condition")) {
[16:01:39.974]                         if (!is.null(pattern)) {
[16:01:39.974]                           computeRestarts <- base::computeRestarts
[16:01:39.974]                           grepl <- base::grepl
[16:01:39.974]                           restarts <- computeRestarts(cond)
[16:01:39.974]                           for (restart in restarts) {
[16:01:39.974]                             name <- restart$name
[16:01:39.974]                             if (is.null(name)) 
[16:01:39.974]                               next
[16:01:39.974]                             if (!grepl(pattern, name)) 
[16:01:39.974]                               next
[16:01:39.974]                             invokeRestart(restart)
[16:01:39.974]                             muffled <- TRUE
[16:01:39.974]                             break
[16:01:39.974]                           }
[16:01:39.974]                         }
[16:01:39.974]                       }
[16:01:39.974]                       invisible(muffled)
[16:01:39.974]                     }
[16:01:39.974]                     muffleCondition(cond, pattern = "^muffle")
[16:01:39.974]                   }
[16:01:39.974]                 }
[16:01:39.974]                 else {
[16:01:39.974]                   if (TRUE) {
[16:01:39.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:39.974]                     {
[16:01:39.974]                       inherits <- base::inherits
[16:01:39.974]                       invokeRestart <- base::invokeRestart
[16:01:39.974]                       is.null <- base::is.null
[16:01:39.974]                       muffled <- FALSE
[16:01:39.974]                       if (inherits(cond, "message")) {
[16:01:39.974]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:39.974]                         if (muffled) 
[16:01:39.974]                           invokeRestart("muffleMessage")
[16:01:39.974]                       }
[16:01:39.974]                       else if (inherits(cond, "warning")) {
[16:01:39.974]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:39.974]                         if (muffled) 
[16:01:39.974]                           invokeRestart("muffleWarning")
[16:01:39.974]                       }
[16:01:39.974]                       else if (inherits(cond, "condition")) {
[16:01:39.974]                         if (!is.null(pattern)) {
[16:01:39.974]                           computeRestarts <- base::computeRestarts
[16:01:39.974]                           grepl <- base::grepl
[16:01:39.974]                           restarts <- computeRestarts(cond)
[16:01:39.974]                           for (restart in restarts) {
[16:01:39.974]                             name <- restart$name
[16:01:39.974]                             if (is.null(name)) 
[16:01:39.974]                               next
[16:01:39.974]                             if (!grepl(pattern, name)) 
[16:01:39.974]                               next
[16:01:39.974]                             invokeRestart(restart)
[16:01:39.974]                             muffled <- TRUE
[16:01:39.974]                             break
[16:01:39.974]                           }
[16:01:39.974]                         }
[16:01:39.974]                       }
[16:01:39.974]                       invisible(muffled)
[16:01:39.974]                     }
[16:01:39.974]                     muffleCondition(cond, pattern = "^muffle")
[16:01:39.974]                   }
[16:01:39.974]                 }
[16:01:39.974]             }
[16:01:39.974]         }))
[16:01:39.974]     }, error = function(ex) {
[16:01:39.974]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:39.974]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:39.974]                 ...future.rng), started = ...future.startTime, 
[16:01:39.974]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:39.974]             version = "1.8"), class = "FutureResult")
[16:01:39.974]     }, finally = {
[16:01:39.974]         if (!identical(...future.workdir, getwd())) 
[16:01:39.974]             setwd(...future.workdir)
[16:01:39.974]         {
[16:01:39.974]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:39.974]                 ...future.oldOptions$nwarnings <- NULL
[16:01:39.974]             }
[16:01:39.974]             base::options(...future.oldOptions)
[16:01:39.974]             if (.Platform$OS.type == "windows") {
[16:01:39.974]                 old_names <- names(...future.oldEnvVars)
[16:01:39.974]                 envs <- base::Sys.getenv()
[16:01:39.974]                 names <- names(envs)
[16:01:39.974]                 common <- intersect(names, old_names)
[16:01:39.974]                 added <- setdiff(names, old_names)
[16:01:39.974]                 removed <- setdiff(old_names, names)
[16:01:39.974]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:39.974]                   envs[common]]
[16:01:39.974]                 NAMES <- toupper(changed)
[16:01:39.974]                 args <- list()
[16:01:39.974]                 for (kk in seq_along(NAMES)) {
[16:01:39.974]                   name <- changed[[kk]]
[16:01:39.974]                   NAME <- NAMES[[kk]]
[16:01:39.974]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:39.974]                     next
[16:01:39.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:39.974]                 }
[16:01:39.974]                 NAMES <- toupper(added)
[16:01:39.974]                 for (kk in seq_along(NAMES)) {
[16:01:39.974]                   name <- added[[kk]]
[16:01:39.974]                   NAME <- NAMES[[kk]]
[16:01:39.974]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:39.974]                     next
[16:01:39.974]                   args[[name]] <- ""
[16:01:39.974]                 }
[16:01:39.974]                 NAMES <- toupper(removed)
[16:01:39.974]                 for (kk in seq_along(NAMES)) {
[16:01:39.974]                   name <- removed[[kk]]
[16:01:39.974]                   NAME <- NAMES[[kk]]
[16:01:39.974]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:39.974]                     next
[16:01:39.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:39.974]                 }
[16:01:39.974]                 if (length(args) > 0) 
[16:01:39.974]                   base::do.call(base::Sys.setenv, args = args)
[16:01:39.974]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:39.974]             }
[16:01:39.974]             else {
[16:01:39.974]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:39.974]             }
[16:01:39.974]             {
[16:01:39.974]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:39.974]                   0L) {
[16:01:39.974]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:39.974]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:39.974]                   base::options(opts)
[16:01:39.974]                 }
[16:01:39.974]                 {
[16:01:39.974]                   {
[16:01:39.974]                     NULL
[16:01:39.974]                     RNGkind("Mersenne-Twister")
[16:01:39.974]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:39.974]                       inherits = FALSE)
[16:01:39.974]                   }
[16:01:39.974]                   options(future.plan = NULL)
[16:01:39.974]                   if (is.na(NA_character_)) 
[16:01:39.974]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:39.974]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:39.974]                   future::plan(list(function (..., envir = parent.frame()) 
[16:01:39.974]                   {
[16:01:39.974]                     future <- SequentialFuture(..., envir = envir)
[16:01:39.974]                     if (!future$lazy) 
[16:01:39.974]                       future <- run(future)
[16:01:39.974]                     invisible(future)
[16:01:39.974]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:39.974]                 }
[16:01:39.974]             }
[16:01:39.974]         }
[16:01:39.974]     })
[16:01:39.974]     if (TRUE) {
[16:01:39.974]         base::sink(type = "output", split = FALSE)
[16:01:39.974]         if (TRUE) {
[16:01:39.974]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:39.974]         }
[16:01:39.974]         else {
[16:01:39.974]             ...future.result["stdout"] <- base::list(NULL)
[16:01:39.974]         }
[16:01:39.974]         base::close(...future.stdout)
[16:01:39.974]         ...future.stdout <- NULL
[16:01:39.974]     }
[16:01:39.974]     ...future.result$conditions <- ...future.conditions
[16:01:39.974]     ...future.result$finished <- base::Sys.time()
[16:01:39.974]     ...future.result
[16:01:39.974] }
[16:01:39.976] assign_globals() ...
[16:01:39.976] List of 5
[16:01:39.976]  $ future.call.arguments    : list()
[16:01:39.976]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:39.976]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:01:39.976]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:01:39.976]  $ ...future.elements_ii    :List of 2
[16:01:39.976]   ..$ : num [1:4] 1 3 1 7
[16:01:39.976]   ..$ : num [1:4] 2 4 6 8
[16:01:39.976]  $ ...future.seeds_ii       : NULL
[16:01:39.976]  $ ...future.globals.maxSize: num Inf
[16:01:39.976]  - attr(*, "resolved")= logi FALSE
[16:01:39.976]  - attr(*, "total_size")= num NA
[16:01:39.976]  - attr(*, "where")=List of 5
[16:01:39.976]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:39.976]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:39.976]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:39.976]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:39.976]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:39.976]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:39.976]  - attr(*, "already-done")= logi TRUE
[16:01:39.983] - copied ‘future.call.arguments’ to environment
[16:01:39.983] - copied ‘...future.FUN’ to environment
[16:01:39.983] - copied ‘...future.elements_ii’ to environment
[16:01:39.983] - copied ‘...future.seeds_ii’ to environment
[16:01:39.983] - copied ‘...future.globals.maxSize’ to environment
[16:01:39.983] assign_globals() ... done
[16:01:39.983] plan(): Setting new future strategy stack:
[16:01:39.983] List of future strategies:
[16:01:39.983] 1. sequential:
[16:01:39.983]    - args: function (..., envir = parent.frame())
[16:01:39.983]    - tweaked: FALSE
[16:01:39.983]    - call: NULL
[16:01:39.984] plan(): nbrOfWorkers() = 1
[16:01:39.985] plan(): Setting new future strategy stack:
[16:01:39.985] List of future strategies:
[16:01:39.985] 1. sequential:
[16:01:39.985]    - args: function (..., envir = parent.frame())
[16:01:39.985]    - tweaked: FALSE
[16:01:39.985]    - call: plan(strategy)
[16:01:39.985] plan(): nbrOfWorkers() = 1
[16:01:39.985] SequentialFuture started (and completed)
[16:01:39.985] - Launch lazy future ... done
[16:01:39.986] run() for ‘SequentialFuture’ ... done
[16:01:39.986] Created future:
[16:01:39.986] SequentialFuture:
[16:01:39.986] Label: ‘future_apply-1’
[16:01:39.986] Expression:
[16:01:39.986] {
[16:01:39.986]     do.call(function(...) {
[16:01:39.986]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:39.986]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:39.986]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:39.986]             on.exit(options(oopts), add = TRUE)
[16:01:39.986]         }
[16:01:39.986]         {
[16:01:39.986]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:39.986]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:39.986]                 ...future.FUN(...future.X_jj, ...)
[16:01:39.986]             })
[16:01:39.986]         }
[16:01:39.986]     }, args = future.call.arguments)
[16:01:39.986] }
[16:01:39.986] Lazy evaluation: FALSE
[16:01:39.986] Asynchronous evaluation: FALSE
[16:01:39.986] Local evaluation: TRUE
[16:01:39.986] Environment: R_GlobalEnv
[16:01:39.986] Capture standard output: TRUE
[16:01:39.986] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:39.986] Globals: 5 objects totaling 346.13 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:39.986] Packages: <none>
[16:01:39.986] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:39.986] Resolved: TRUE
[16:01:39.986] Value: 2.21 KiB of class ‘list’
[16:01:39.986] Early signaling: FALSE
[16:01:39.986] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:39.986] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:39.987] Chunk #1 of 1 ... DONE
[16:01:39.987] Launching 1 futures (chunks) ... DONE
[16:01:39.987] Resolving 1 futures (chunks) ...
[16:01:39.987] resolve() on list ...
[16:01:39.987]  recursive: 0
[16:01:39.987]  length: 1
[16:01:39.988] 
[16:01:39.988] resolved() for ‘SequentialFuture’ ...
[16:01:39.988] - state: ‘finished’
[16:01:39.988] - run: TRUE
[16:01:39.988] - result: ‘FutureResult’
[16:01:39.988] resolved() for ‘SequentialFuture’ ... done
[16:01:39.988] Future #1
[16:01:39.988] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:39.988] - nx: 1
[16:01:39.988] - relay: TRUE
[16:01:39.989] - stdout: TRUE
[16:01:39.989] - signal: TRUE
[16:01:39.989] - resignal: FALSE
[16:01:39.989] - force: TRUE
[16:01:39.989] - relayed: [n=1] FALSE
[16:01:39.989] - queued futures: [n=1] FALSE
[16:01:39.989]  - until=1
[16:01:39.989]  - relaying element #1
[16:01:39.989] - relayed: [n=1] TRUE
[16:01:39.989] - queued futures: [n=1] TRUE
[16:01:39.990] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:39.990]  length: 0 (resolved future 1)
[16:01:39.990] Relaying remaining futures
[16:01:39.990] signalConditionsASAP(NULL, pos=0) ...
[16:01:39.990] - nx: 1
[16:01:39.990] - relay: TRUE
[16:01:39.990] - stdout: TRUE
[16:01:39.990] - signal: TRUE
[16:01:39.990] - resignal: FALSE
[16:01:39.990] - force: TRUE
[16:01:39.990] - relayed: [n=1] TRUE
[16:01:39.990] - queued futures: [n=1] TRUE
 - flush all
[16:01:39.991] - relayed: [n=1] TRUE
[16:01:39.991] - queued futures: [n=1] TRUE
[16:01:39.991] signalConditionsASAP(NULL, pos=0) ... done
[16:01:39.991] resolve() on list ... DONE
[16:01:39.991]  - Number of value chunks collected: 1
[16:01:39.991] Resolving 1 futures (chunks) ... DONE
[16:01:39.991] Reducing values from 1 chunks ...
[16:01:39.991]  - Number of values collected after concatenation: 2
[16:01:39.991]  - Number of values expected: 2
[16:01:39.992] Reducing values from 1 chunks ... DONE
[16:01:39.992] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[16:01:39.994] getGlobalsAndPackagesXApply() ...
[16:01:39.994]  - future.globals: TRUE
[16:01:39.994] getGlobalsAndPackages() ...
[16:01:39.994] Searching for globals...
[16:01:39.995] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:39.996] Searching for globals ... DONE
[16:01:39.996] Resolving globals: FALSE
[16:01:39.996] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:01:39.996] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:01:39.997] - globals: [1] ‘FUN’
[16:01:39.997] - packages: [1] ‘stats’
[16:01:39.997] getGlobalsAndPackages() ... DONE
[16:01:39.997]  - globals found/used: [n=1] ‘FUN’
[16:01:39.997]  - needed namespaces: [n=1] ‘stats’
[16:01:39.997] Finding globals ... DONE
[16:01:39.997]  - use_args: TRUE
[16:01:39.997]  - Getting '...' globals ...
[16:01:39.997] resolve() on list ...
[16:01:39.998]  recursive: 0
[16:01:39.998]  length: 1
[16:01:39.998]  elements: ‘...’
[16:01:39.998]  length: 0 (resolved future 1)
[16:01:39.998] resolve() on list ... DONE
[16:01:39.998]    - '...' content: [n=0] 
[16:01:39.998] List of 1
[16:01:39.998]  $ ...: list()
[16:01:39.998]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:39.998]  - attr(*, "where")=List of 1
[16:01:39.998]   ..$ ...:<environment: 0x55fb6405a0a0> 
[16:01:39.998]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:39.998]  - attr(*, "resolved")= logi TRUE
[16:01:39.998]  - attr(*, "total_size")= num NA
[16:01:40.001]  - Getting '...' globals ... DONE
[16:01:40.001] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:40.001] List of 2
[16:01:40.001]  $ ...future.FUN:function (x, ...)  
[16:01:40.001]  $ ...          : list()
[16:01:40.001]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.001]  - attr(*, "where")=List of 2
[16:01:40.001]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:40.001]   ..$ ...          :<environment: 0x55fb6405a0a0> 
[16:01:40.001]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.001]  - attr(*, "resolved")= logi FALSE
[16:01:40.001]  - attr(*, "total_size")= num 1248
[16:01:40.004] Packages to be attached in all futures: [n=1] ‘stats’
[16:01:40.004] getGlobalsAndPackagesXApply() ... DONE
[16:01:40.004] future_lapply() ...
[16:01:40.004] Number of chunks: 1
[16:01:40.004] getGlobalsAndPackagesXApply() ...
[16:01:40.005]  - future.globals: <name-value list> with names ‘list()’
[16:01:40.005]  - use_args: TRUE
[16:01:40.006] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:01:40.007] List of 2
[16:01:40.007]  $ ...          : list()
[16:01:40.007]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.007]  $ ...future.FUN:function (x, ...)  
[16:01:40.007]  - attr(*, "where")=List of 2
[16:01:40.007]   ..$ ...          :<environment: 0x55fb6405a0a0> 
[16:01:40.007]   ..$ ...future.FUN:<environment: namespace:stats> 
[16:01:40.007]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.007]  - attr(*, "resolved")= logi FALSE
[16:01:40.007]  - attr(*, "total_size")= num NA
[16:01:40.009] Packages to be attached in all futures: [n=1] ‘stats’
[16:01:40.009] getGlobalsAndPackagesXApply() ... DONE
[16:01:40.010] Number of futures (= number of chunks): 1
[16:01:40.010] Launching 1 futures (chunks) ...
[16:01:40.010] Chunk #1 of 1 ...
[16:01:40.010]  - seeds: <none>
[16:01:40.010]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.010] getGlobalsAndPackages() ...
[16:01:40.010] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.010] Resolving globals: FALSE
[16:01:40.010] Tweak future expression to call with '...' arguments ...
[16:01:40.011] {
[16:01:40.011]     do.call(function(...) {
[16:01:40.011]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.011]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.011]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.011]             on.exit(options(oopts), add = TRUE)
[16:01:40.011]         }
[16:01:40.011]         {
[16:01:40.011]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.011]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.011]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.011]             })
[16:01:40.011]         }
[16:01:40.011]     }, args = future.call.arguments)
[16:01:40.011] }
[16:01:40.011] Tweak future expression to call with '...' arguments ... DONE
[16:01:40.011] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.011] - packages: [1] ‘stats’
[16:01:40.011] getGlobalsAndPackages() ... DONE
[16:01:40.012] run() for ‘Future’ ...
[16:01:40.012] - state: ‘created’
[16:01:40.012] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:01:40.012] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:40.012] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:40.012]   - Field: ‘label’
[16:01:40.013]   - Field: ‘local’
[16:01:40.013]   - Field: ‘owner’
[16:01:40.013]   - Field: ‘envir’
[16:01:40.013]   - Field: ‘packages’
[16:01:40.013]   - Field: ‘gc’
[16:01:40.013]   - Field: ‘conditions’
[16:01:40.013]   - Field: ‘expr’
[16:01:40.013]   - Field: ‘uuid’
[16:01:40.013]   - Field: ‘seed’
[16:01:40.013]   - Field: ‘version’
[16:01:40.013]   - Field: ‘result’
[16:01:40.014]   - Field: ‘asynchronous’
[16:01:40.014]   - Field: ‘calls’
[16:01:40.014]   - Field: ‘globals’
[16:01:40.014]   - Field: ‘stdout’
[16:01:40.014]   - Field: ‘earlySignal’
[16:01:40.014]   - Field: ‘lazy’
[16:01:40.014]   - Field: ‘state’
[16:01:40.014] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:40.014] - Launch lazy future ...
[16:01:40.014] Packages needed by the future expression (n = 1): ‘stats’
[16:01:40.015] Packages needed by future strategies (n = 0): <none>
[16:01:40.015] {
[16:01:40.015]     {
[16:01:40.015]         {
[16:01:40.015]             ...future.startTime <- base::Sys.time()
[16:01:40.015]             {
[16:01:40.015]                 {
[16:01:40.015]                   {
[16:01:40.015]                     {
[16:01:40.015]                       base::local({
[16:01:40.015]                         has_future <- base::requireNamespace("future", 
[16:01:40.015]                           quietly = TRUE)
[16:01:40.015]                         if (has_future) {
[16:01:40.015]                           ns <- base::getNamespace("future")
[16:01:40.015]                           version <- ns[[".package"]][["version"]]
[16:01:40.015]                           if (is.null(version)) 
[16:01:40.015]                             version <- utils::packageVersion("future")
[16:01:40.015]                         }
[16:01:40.015]                         else {
[16:01:40.015]                           version <- NULL
[16:01:40.015]                         }
[16:01:40.015]                         if (!has_future || version < "1.8.0") {
[16:01:40.015]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:40.015]                             "", base::R.version$version.string), 
[16:01:40.015]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:40.015]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:40.015]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:40.015]                               "release", "version")], collapse = " "), 
[16:01:40.015]                             hostname = base::Sys.info()[["nodename"]])
[16:01:40.015]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:40.015]                             info)
[16:01:40.015]                           info <- base::paste(info, collapse = "; ")
[16:01:40.015]                           if (!has_future) {
[16:01:40.015]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:40.015]                               info)
[16:01:40.015]                           }
[16:01:40.015]                           else {
[16:01:40.015]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:40.015]                               info, version)
[16:01:40.015]                           }
[16:01:40.015]                           base::stop(msg)
[16:01:40.015]                         }
[16:01:40.015]                       })
[16:01:40.015]                     }
[16:01:40.015]                     base::local({
[16:01:40.015]                       for (pkg in "stats") {
[16:01:40.015]                         base::loadNamespace(pkg)
[16:01:40.015]                         base::library(pkg, character.only = TRUE)
[16:01:40.015]                       }
[16:01:40.015]                     })
[16:01:40.015]                   }
[16:01:40.015]                   options(future.plan = NULL)
[16:01:40.015]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:40.015]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:40.015]                 }
[16:01:40.015]                 ...future.workdir <- getwd()
[16:01:40.015]             }
[16:01:40.015]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:40.015]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:40.015]         }
[16:01:40.015]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:40.015]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:40.015]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:40.015]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:40.015]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:40.015]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:40.015]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:40.015]             base::names(...future.oldOptions))
[16:01:40.015]     }
[16:01:40.015]     if (FALSE) {
[16:01:40.015]     }
[16:01:40.015]     else {
[16:01:40.015]         if (TRUE) {
[16:01:40.015]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:40.015]                 open = "w")
[16:01:40.015]         }
[16:01:40.015]         else {
[16:01:40.015]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:40.015]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:40.015]         }
[16:01:40.015]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:40.015]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:40.015]             base::sink(type = "output", split = FALSE)
[16:01:40.015]             base::close(...future.stdout)
[16:01:40.015]         }, add = TRUE)
[16:01:40.015]     }
[16:01:40.015]     ...future.frame <- base::sys.nframe()
[16:01:40.015]     ...future.conditions <- base::list()
[16:01:40.015]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:40.015]     if (FALSE) {
[16:01:40.015]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:40.015]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:40.015]     }
[16:01:40.015]     ...future.result <- base::tryCatch({
[16:01:40.015]         base::withCallingHandlers({
[16:01:40.015]             ...future.value <- base::withVisible(base::local({
[16:01:40.015]                 do.call(function(...) {
[16:01:40.015]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.015]                   if (!identical(...future.globals.maxSize.org, 
[16:01:40.015]                     ...future.globals.maxSize)) {
[16:01:40.015]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.015]                     on.exit(options(oopts), add = TRUE)
[16:01:40.015]                   }
[16:01:40.015]                   {
[16:01:40.015]                     lapply(seq_along(...future.elements_ii), 
[16:01:40.015]                       FUN = function(jj) {
[16:01:40.015]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.015]                         ...future.FUN(...future.X_jj, ...)
[16:01:40.015]                       })
[16:01:40.015]                   }
[16:01:40.015]                 }, args = future.call.arguments)
[16:01:40.015]             }))
[16:01:40.015]             future::FutureResult(value = ...future.value$value, 
[16:01:40.015]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:40.015]                   ...future.rng), globalenv = if (FALSE) 
[16:01:40.015]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:40.015]                     ...future.globalenv.names))
[16:01:40.015]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:40.015]         }, condition = base::local({
[16:01:40.015]             c <- base::c
[16:01:40.015]             inherits <- base::inherits
[16:01:40.015]             invokeRestart <- base::invokeRestart
[16:01:40.015]             length <- base::length
[16:01:40.015]             list <- base::list
[16:01:40.015]             seq.int <- base::seq.int
[16:01:40.015]             signalCondition <- base::signalCondition
[16:01:40.015]             sys.calls <- base::sys.calls
[16:01:40.015]             `[[` <- base::`[[`
[16:01:40.015]             `+` <- base::`+`
[16:01:40.015]             `<<-` <- base::`<<-`
[16:01:40.015]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:40.015]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:40.015]                   3L)]
[16:01:40.015]             }
[16:01:40.015]             function(cond) {
[16:01:40.015]                 is_error <- inherits(cond, "error")
[16:01:40.015]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:40.015]                   NULL)
[16:01:40.015]                 if (is_error) {
[16:01:40.015]                   sessionInformation <- function() {
[16:01:40.015]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:40.015]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:40.015]                       search = base::search(), system = base::Sys.info())
[16:01:40.015]                   }
[16:01:40.015]                   ...future.conditions[[length(...future.conditions) + 
[16:01:40.015]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:40.015]                     cond$call), session = sessionInformation(), 
[16:01:40.015]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:40.015]                   signalCondition(cond)
[16:01:40.015]                 }
[16:01:40.015]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:40.015]                 "immediateCondition"))) {
[16:01:40.015]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:40.015]                   ...future.conditions[[length(...future.conditions) + 
[16:01:40.015]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:40.015]                   if (TRUE && !signal) {
[16:01:40.015]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.015]                     {
[16:01:40.015]                       inherits <- base::inherits
[16:01:40.015]                       invokeRestart <- base::invokeRestart
[16:01:40.015]                       is.null <- base::is.null
[16:01:40.015]                       muffled <- FALSE
[16:01:40.015]                       if (inherits(cond, "message")) {
[16:01:40.015]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:40.015]                         if (muffled) 
[16:01:40.015]                           invokeRestart("muffleMessage")
[16:01:40.015]                       }
[16:01:40.015]                       else if (inherits(cond, "warning")) {
[16:01:40.015]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:40.015]                         if (muffled) 
[16:01:40.015]                           invokeRestart("muffleWarning")
[16:01:40.015]                       }
[16:01:40.015]                       else if (inherits(cond, "condition")) {
[16:01:40.015]                         if (!is.null(pattern)) {
[16:01:40.015]                           computeRestarts <- base::computeRestarts
[16:01:40.015]                           grepl <- base::grepl
[16:01:40.015]                           restarts <- computeRestarts(cond)
[16:01:40.015]                           for (restart in restarts) {
[16:01:40.015]                             name <- restart$name
[16:01:40.015]                             if (is.null(name)) 
[16:01:40.015]                               next
[16:01:40.015]                             if (!grepl(pattern, name)) 
[16:01:40.015]                               next
[16:01:40.015]                             invokeRestart(restart)
[16:01:40.015]                             muffled <- TRUE
[16:01:40.015]                             break
[16:01:40.015]                           }
[16:01:40.015]                         }
[16:01:40.015]                       }
[16:01:40.015]                       invisible(muffled)
[16:01:40.015]                     }
[16:01:40.015]                     muffleCondition(cond, pattern = "^muffle")
[16:01:40.015]                   }
[16:01:40.015]                 }
[16:01:40.015]                 else {
[16:01:40.015]                   if (TRUE) {
[16:01:40.015]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.015]                     {
[16:01:40.015]                       inherits <- base::inherits
[16:01:40.015]                       invokeRestart <- base::invokeRestart
[16:01:40.015]                       is.null <- base::is.null
[16:01:40.015]                       muffled <- FALSE
[16:01:40.015]                       if (inherits(cond, "message")) {
[16:01:40.015]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:40.015]                         if (muffled) 
[16:01:40.015]                           invokeRestart("muffleMessage")
[16:01:40.015]                       }
[16:01:40.015]                       else if (inherits(cond, "warning")) {
[16:01:40.015]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:40.015]                         if (muffled) 
[16:01:40.015]                           invokeRestart("muffleWarning")
[16:01:40.015]                       }
[16:01:40.015]                       else if (inherits(cond, "condition")) {
[16:01:40.015]                         if (!is.null(pattern)) {
[16:01:40.015]                           computeRestarts <- base::computeRestarts
[16:01:40.015]                           grepl <- base::grepl
[16:01:40.015]                           restarts <- computeRestarts(cond)
[16:01:40.015]                           for (restart in restarts) {
[16:01:40.015]                             name <- restart$name
[16:01:40.015]                             if (is.null(name)) 
[16:01:40.015]                               next
[16:01:40.015]                             if (!grepl(pattern, name)) 
[16:01:40.015]                               next
[16:01:40.015]                             invokeRestart(restart)
[16:01:40.015]                             muffled <- TRUE
[16:01:40.015]                             break
[16:01:40.015]                           }
[16:01:40.015]                         }
[16:01:40.015]                       }
[16:01:40.015]                       invisible(muffled)
[16:01:40.015]                     }
[16:01:40.015]                     muffleCondition(cond, pattern = "^muffle")
[16:01:40.015]                   }
[16:01:40.015]                 }
[16:01:40.015]             }
[16:01:40.015]         }))
[16:01:40.015]     }, error = function(ex) {
[16:01:40.015]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:40.015]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:40.015]                 ...future.rng), started = ...future.startTime, 
[16:01:40.015]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:40.015]             version = "1.8"), class = "FutureResult")
[16:01:40.015]     }, finally = {
[16:01:40.015]         if (!identical(...future.workdir, getwd())) 
[16:01:40.015]             setwd(...future.workdir)
[16:01:40.015]         {
[16:01:40.015]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:40.015]                 ...future.oldOptions$nwarnings <- NULL
[16:01:40.015]             }
[16:01:40.015]             base::options(...future.oldOptions)
[16:01:40.015]             if (.Platform$OS.type == "windows") {
[16:01:40.015]                 old_names <- names(...future.oldEnvVars)
[16:01:40.015]                 envs <- base::Sys.getenv()
[16:01:40.015]                 names <- names(envs)
[16:01:40.015]                 common <- intersect(names, old_names)
[16:01:40.015]                 added <- setdiff(names, old_names)
[16:01:40.015]                 removed <- setdiff(old_names, names)
[16:01:40.015]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:40.015]                   envs[common]]
[16:01:40.015]                 NAMES <- toupper(changed)
[16:01:40.015]                 args <- list()
[16:01:40.015]                 for (kk in seq_along(NAMES)) {
[16:01:40.015]                   name <- changed[[kk]]
[16:01:40.015]                   NAME <- NAMES[[kk]]
[16:01:40.015]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.015]                     next
[16:01:40.015]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:40.015]                 }
[16:01:40.015]                 NAMES <- toupper(added)
[16:01:40.015]                 for (kk in seq_along(NAMES)) {
[16:01:40.015]                   name <- added[[kk]]
[16:01:40.015]                   NAME <- NAMES[[kk]]
[16:01:40.015]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.015]                     next
[16:01:40.015]                   args[[name]] <- ""
[16:01:40.015]                 }
[16:01:40.015]                 NAMES <- toupper(removed)
[16:01:40.015]                 for (kk in seq_along(NAMES)) {
[16:01:40.015]                   name <- removed[[kk]]
[16:01:40.015]                   NAME <- NAMES[[kk]]
[16:01:40.015]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.015]                     next
[16:01:40.015]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:40.015]                 }
[16:01:40.015]                 if (length(args) > 0) 
[16:01:40.015]                   base::do.call(base::Sys.setenv, args = args)
[16:01:40.015]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:40.015]             }
[16:01:40.015]             else {
[16:01:40.015]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:40.015]             }
[16:01:40.015]             {
[16:01:40.015]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:40.015]                   0L) {
[16:01:40.015]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:40.015]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:40.015]                   base::options(opts)
[16:01:40.015]                 }
[16:01:40.015]                 {
[16:01:40.015]                   {
[16:01:40.015]                     NULL
[16:01:40.015]                     RNGkind("Mersenne-Twister")
[16:01:40.015]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:40.015]                       inherits = FALSE)
[16:01:40.015]                   }
[16:01:40.015]                   options(future.plan = NULL)
[16:01:40.015]                   if (is.na(NA_character_)) 
[16:01:40.015]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:40.015]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:40.015]                   future::plan(list(function (..., envir = parent.frame()) 
[16:01:40.015]                   {
[16:01:40.015]                     future <- SequentialFuture(..., envir = envir)
[16:01:40.015]                     if (!future$lazy) 
[16:01:40.015]                       future <- run(future)
[16:01:40.015]                     invisible(future)
[16:01:40.015]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:40.015]                 }
[16:01:40.015]             }
[16:01:40.015]         }
[16:01:40.015]     })
[16:01:40.015]     if (TRUE) {
[16:01:40.015]         base::sink(type = "output", split = FALSE)
[16:01:40.015]         if (TRUE) {
[16:01:40.015]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:40.015]         }
[16:01:40.015]         else {
[16:01:40.015]             ...future.result["stdout"] <- base::list(NULL)
[16:01:40.015]         }
[16:01:40.015]         base::close(...future.stdout)
[16:01:40.015]         ...future.stdout <- NULL
[16:01:40.015]     }
[16:01:40.015]     ...future.result$conditions <- ...future.conditions
[16:01:40.015]     ...future.result$finished <- base::Sys.time()
[16:01:40.015]     ...future.result
[16:01:40.015] }
[16:01:40.017] assign_globals() ...
[16:01:40.017] List of 5
[16:01:40.017]  $ future.call.arguments    : list()
[16:01:40.017]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.017]  $ ...future.FUN            :function (x, ...)  
[16:01:40.017]  $ ...future.elements_ii    :List of 2
[16:01:40.017]   ..$ : num [1:4] 1 3 1 7
[16:01:40.017]   ..$ : num [1:4] 2 4 6 8
[16:01:40.017]  $ ...future.seeds_ii       : NULL
[16:01:40.017]  $ ...future.globals.maxSize: num Inf
[16:01:40.017]  - attr(*, "resolved")= logi FALSE
[16:01:40.017]  - attr(*, "total_size")= num NA
[16:01:40.017]  - attr(*, "where")=List of 5
[16:01:40.017]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:40.017]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:40.017]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:40.017]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:40.017]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:40.017]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.017]  - attr(*, "already-done")= logi TRUE
[16:01:40.022] - copied ‘future.call.arguments’ to environment
[16:01:40.022] - copied ‘...future.FUN’ to environment
[16:01:40.022] - copied ‘...future.elements_ii’ to environment
[16:01:40.022] - copied ‘...future.seeds_ii’ to environment
[16:01:40.022] - copied ‘...future.globals.maxSize’ to environment
[16:01:40.022] assign_globals() ... done
[16:01:40.023] plan(): Setting new future strategy stack:
[16:01:40.023] List of future strategies:
[16:01:40.023] 1. sequential:
[16:01:40.023]    - args: function (..., envir = parent.frame())
[16:01:40.023]    - tweaked: FALSE
[16:01:40.023]    - call: NULL
[16:01:40.023] plan(): nbrOfWorkers() = 1
[16:01:40.024] plan(): Setting new future strategy stack:
[16:01:40.024] List of future strategies:
[16:01:40.024] 1. sequential:
[16:01:40.024]    - args: function (..., envir = parent.frame())
[16:01:40.024]    - tweaked: FALSE
[16:01:40.024]    - call: plan(strategy)
[16:01:40.025] plan(): nbrOfWorkers() = 1
[16:01:40.025] SequentialFuture started (and completed)
[16:01:40.025] - Launch lazy future ... done
[16:01:40.025] run() for ‘SequentialFuture’ ... done
[16:01:40.025] Created future:
[16:01:40.025] SequentialFuture:
[16:01:40.025] Label: ‘future_apply-1’
[16:01:40.025] Expression:
[16:01:40.025] {
[16:01:40.025]     do.call(function(...) {
[16:01:40.025]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.025]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.025]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.025]             on.exit(options(oopts), add = TRUE)
[16:01:40.025]         }
[16:01:40.025]         {
[16:01:40.025]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.025]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.025]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.025]             })
[16:01:40.025]         }
[16:01:40.025]     }, args = future.call.arguments)
[16:01:40.025] }
[16:01:40.025] Lazy evaluation: FALSE
[16:01:40.025] Asynchronous evaluation: FALSE
[16:01:40.025] Local evaluation: TRUE
[16:01:40.025] Environment: R_GlobalEnv
[16:01:40.025] Capture standard output: TRUE
[16:01:40.025] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:40.025] Globals: 5 objects totaling 1.43 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:40.025] Packages: 1 packages (‘stats’)
[16:01:40.025] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:40.025] Resolved: TRUE
[16:01:40.025] Value: 1.14 KiB of class ‘list’
[16:01:40.025] Early signaling: FALSE
[16:01:40.025] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:40.025] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:40.026] Chunk #1 of 1 ... DONE
[16:01:40.026] Launching 1 futures (chunks) ... DONE
[16:01:40.026] Resolving 1 futures (chunks) ...
[16:01:40.026] resolve() on list ...
[16:01:40.027]  recursive: 0
[16:01:40.027]  length: 1
[16:01:40.027] 
[16:01:40.027] resolved() for ‘SequentialFuture’ ...
[16:01:40.027] - state: ‘finished’
[16:01:40.027] - run: TRUE
[16:01:40.027] - result: ‘FutureResult’
[16:01:40.027] resolved() for ‘SequentialFuture’ ... done
[16:01:40.027] Future #1
[16:01:40.027] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:40.028] - nx: 1
[16:01:40.028] - relay: TRUE
[16:01:40.028] - stdout: TRUE
[16:01:40.028] - signal: TRUE
[16:01:40.028] - resignal: FALSE
[16:01:40.028] - force: TRUE
[16:01:40.028] - relayed: [n=1] FALSE
[16:01:40.028] - queued futures: [n=1] FALSE
[16:01:40.028]  - until=1
[16:01:40.028]  - relaying element #1
[16:01:40.030] - relayed: [n=1] TRUE
[16:01:40.030] - queued futures: [n=1] TRUE
[16:01:40.030] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:40.030]  length: 0 (resolved future 1)
[16:01:40.030] Relaying remaining futures
[16:01:40.030] signalConditionsASAP(NULL, pos=0) ...
[16:01:40.030] - nx: 1
[16:01:40.030] - relay: TRUE
[16:01:40.031] - stdout: TRUE
[16:01:40.031] - signal: TRUE
[16:01:40.031] - resignal: FALSE
[16:01:40.031] - force: TRUE
[16:01:40.031] - relayed: [n=1] TRUE
[16:01:40.031] - queued futures: [n=1] TRUE
 - flush all
[16:01:40.031] - relayed: [n=1] TRUE
[16:01:40.031] - queued futures: [n=1] TRUE
[16:01:40.031] signalConditionsASAP(NULL, pos=0) ... done
[16:01:40.031] resolve() on list ... DONE
[16:01:40.032]  - Number of value chunks collected: 1
[16:01:40.032] Resolving 1 futures (chunks) ... DONE
[16:01:40.032] Reducing values from 1 chunks ...
[16:01:40.032]  - Number of values collected after concatenation: 2
[16:01:40.032]  - Number of values expected: 2
[16:01:40.032] Reducing values from 1 chunks ... DONE
[16:01:40.032] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[16:01:40.033] getGlobalsAndPackagesXApply() ...
[16:01:40.033]  - future.globals: TRUE
[16:01:40.033] getGlobalsAndPackages() ...
[16:01:40.033] Searching for globals...
[16:01:40.034] - globals found: [1] ‘FUN’
[16:01:40.034] Searching for globals ... DONE
[16:01:40.034] Resolving globals: FALSE
[16:01:40.035] The total size of the 1 globals is 848 bytes (848 bytes)
[16:01:40.035] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:01:40.035] - globals: [1] ‘FUN’
[16:01:40.035] 
[16:01:40.035] getGlobalsAndPackages() ... DONE
[16:01:40.035]  - globals found/used: [n=1] ‘FUN’
[16:01:40.035]  - needed namespaces: [n=0] 
[16:01:40.036] Finding globals ... DONE
[16:01:40.036]  - use_args: TRUE
[16:01:40.036]  - Getting '...' globals ...
[16:01:40.036] resolve() on list ...
[16:01:40.036]  recursive: 0
[16:01:40.036]  length: 1
[16:01:40.036]  elements: ‘...’
[16:01:40.036]  length: 0 (resolved future 1)
[16:01:40.036] resolve() on list ... DONE
[16:01:40.037]    - '...' content: [n=0] 
[16:01:40.037] List of 1
[16:01:40.037]  $ ...: list()
[16:01:40.037]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.037]  - attr(*, "where")=List of 1
[16:01:40.037]   ..$ ...:<environment: 0x55fb62fcef68> 
[16:01:40.037]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.037]  - attr(*, "resolved")= logi TRUE
[16:01:40.037]  - attr(*, "total_size")= num NA
[16:01:40.039]  - Getting '...' globals ... DONE
[16:01:40.039] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:40.039] List of 2
[16:01:40.039]  $ ...future.FUN:function (x)  
[16:01:40.039]  $ ...          : list()
[16:01:40.039]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.039]  - attr(*, "where")=List of 2
[16:01:40.039]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:40.039]   ..$ ...          :<environment: 0x55fb62fcef68> 
[16:01:40.039]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.039]  - attr(*, "resolved")= logi FALSE
[16:01:40.039]  - attr(*, "total_size")= num 848
[16:01:40.042] Packages to be attached in all futures: [n=0] 
[16:01:40.042] getGlobalsAndPackagesXApply() ... DONE
[16:01:40.042] future_lapply() ...
[16:01:40.043] Number of chunks: 1
[16:01:40.043] getGlobalsAndPackagesXApply() ...
[16:01:40.043]  - future.globals: <name-value list> with names ‘list()’
[16:01:40.043]  - use_args: TRUE
[16:01:40.043] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:01:40.043] List of 2
[16:01:40.043]  $ ...          : list()
[16:01:40.043]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.043]  $ ...future.FUN:function (x)  
[16:01:40.043]  - attr(*, "where")=List of 2
[16:01:40.043]   ..$ ...          :<environment: 0x55fb62fcef68> 
[16:01:40.043]   ..$ ...future.FUN:<environment: namespace:base> 
[16:01:40.043]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.043]  - attr(*, "resolved")= logi FALSE
[16:01:40.043]  - attr(*, "total_size")= num NA
[16:01:40.046] Packages to be attached in all futures: [n=0] 
[16:01:40.046] getGlobalsAndPackagesXApply() ... DONE
[16:01:40.047] Number of futures (= number of chunks): 1
[16:01:40.047] Launching 1 futures (chunks) ...
[16:01:40.047] Chunk #1 of 1 ...
[16:01:40.047]  - seeds: <none>
[16:01:40.047]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.047] getGlobalsAndPackages() ...
[16:01:40.047] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.047] Resolving globals: FALSE
[16:01:40.047] Tweak future expression to call with '...' arguments ...
[16:01:40.048] {
[16:01:40.048]     do.call(function(...) {
[16:01:40.048]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.048]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.048]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.048]             on.exit(options(oopts), add = TRUE)
[16:01:40.048]         }
[16:01:40.048]         {
[16:01:40.048]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.048]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.048]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.048]             })
[16:01:40.048]         }
[16:01:40.048]     }, args = future.call.arguments)
[16:01:40.048] }
[16:01:40.048] Tweak future expression to call with '...' arguments ... DONE
[16:01:40.048] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.048] 
[16:01:40.048] getGlobalsAndPackages() ... DONE
[16:01:40.049] run() for ‘Future’ ...
[16:01:40.049] - state: ‘created’
[16:01:40.049] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:01:40.049] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:40.049] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:40.049]   - Field: ‘label’
[16:01:40.049]   - Field: ‘local’
[16:01:40.050]   - Field: ‘owner’
[16:01:40.050]   - Field: ‘envir’
[16:01:40.050]   - Field: ‘packages’
[16:01:40.050]   - Field: ‘gc’
[16:01:40.050]   - Field: ‘conditions’
[16:01:40.050]   - Field: ‘expr’
[16:01:40.050]   - Field: ‘uuid’
[16:01:40.050]   - Field: ‘seed’
[16:01:40.050]   - Field: ‘version’
[16:01:40.052]   - Field: ‘result’
[16:01:40.052]   - Field: ‘asynchronous’
[16:01:40.052]   - Field: ‘calls’
[16:01:40.052]   - Field: ‘globals’
[16:01:40.052]   - Field: ‘stdout’
[16:01:40.052]   - Field: ‘earlySignal’
[16:01:40.052]   - Field: ‘lazy’
[16:01:40.052]   - Field: ‘state’
[16:01:40.052] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:40.052] - Launch lazy future ...
[16:01:40.053] Packages needed by the future expression (n = 0): <none>
[16:01:40.053] Packages needed by future strategies (n = 0): <none>
[16:01:40.053] {
[16:01:40.053]     {
[16:01:40.053]         {
[16:01:40.053]             ...future.startTime <- base::Sys.time()
[16:01:40.053]             {
[16:01:40.053]                 {
[16:01:40.053]                   {
[16:01:40.053]                     base::local({
[16:01:40.053]                       has_future <- base::requireNamespace("future", 
[16:01:40.053]                         quietly = TRUE)
[16:01:40.053]                       if (has_future) {
[16:01:40.053]                         ns <- base::getNamespace("future")
[16:01:40.053]                         version <- ns[[".package"]][["version"]]
[16:01:40.053]                         if (is.null(version)) 
[16:01:40.053]                           version <- utils::packageVersion("future")
[16:01:40.053]                       }
[16:01:40.053]                       else {
[16:01:40.053]                         version <- NULL
[16:01:40.053]                       }
[16:01:40.053]                       if (!has_future || version < "1.8.0") {
[16:01:40.053]                         info <- base::c(r_version = base::gsub("R version ", 
[16:01:40.053]                           "", base::R.version$version.string), 
[16:01:40.053]                           platform = base::sprintf("%s (%s-bit)", 
[16:01:40.053]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:40.053]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:40.053]                             "release", "version")], collapse = " "), 
[16:01:40.053]                           hostname = base::Sys.info()[["nodename"]])
[16:01:40.053]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:01:40.053]                           info)
[16:01:40.053]                         info <- base::paste(info, collapse = "; ")
[16:01:40.053]                         if (!has_future) {
[16:01:40.053]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:40.053]                             info)
[16:01:40.053]                         }
[16:01:40.053]                         else {
[16:01:40.053]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:40.053]                             info, version)
[16:01:40.053]                         }
[16:01:40.053]                         base::stop(msg)
[16:01:40.053]                       }
[16:01:40.053]                     })
[16:01:40.053]                   }
[16:01:40.053]                   options(future.plan = NULL)
[16:01:40.053]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:40.053]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:40.053]                 }
[16:01:40.053]                 ...future.workdir <- getwd()
[16:01:40.053]             }
[16:01:40.053]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:40.053]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:40.053]         }
[16:01:40.053]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:40.053]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:40.053]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:40.053]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:40.053]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:40.053]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:40.053]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:40.053]             base::names(...future.oldOptions))
[16:01:40.053]     }
[16:01:40.053]     if (FALSE) {
[16:01:40.053]     }
[16:01:40.053]     else {
[16:01:40.053]         if (TRUE) {
[16:01:40.053]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:40.053]                 open = "w")
[16:01:40.053]         }
[16:01:40.053]         else {
[16:01:40.053]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:40.053]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:40.053]         }
[16:01:40.053]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:40.053]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:40.053]             base::sink(type = "output", split = FALSE)
[16:01:40.053]             base::close(...future.stdout)
[16:01:40.053]         }, add = TRUE)
[16:01:40.053]     }
[16:01:40.053]     ...future.frame <- base::sys.nframe()
[16:01:40.053]     ...future.conditions <- base::list()
[16:01:40.053]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:40.053]     if (FALSE) {
[16:01:40.053]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:40.053]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:40.053]     }
[16:01:40.053]     ...future.result <- base::tryCatch({
[16:01:40.053]         base::withCallingHandlers({
[16:01:40.053]             ...future.value <- base::withVisible(base::local({
[16:01:40.053]                 do.call(function(...) {
[16:01:40.053]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.053]                   if (!identical(...future.globals.maxSize.org, 
[16:01:40.053]                     ...future.globals.maxSize)) {
[16:01:40.053]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.053]                     on.exit(options(oopts), add = TRUE)
[16:01:40.053]                   }
[16:01:40.053]                   {
[16:01:40.053]                     lapply(seq_along(...future.elements_ii), 
[16:01:40.053]                       FUN = function(jj) {
[16:01:40.053]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.053]                         ...future.FUN(...future.X_jj, ...)
[16:01:40.053]                       })
[16:01:40.053]                   }
[16:01:40.053]                 }, args = future.call.arguments)
[16:01:40.053]             }))
[16:01:40.053]             future::FutureResult(value = ...future.value$value, 
[16:01:40.053]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:40.053]                   ...future.rng), globalenv = if (FALSE) 
[16:01:40.053]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:40.053]                     ...future.globalenv.names))
[16:01:40.053]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:40.053]         }, condition = base::local({
[16:01:40.053]             c <- base::c
[16:01:40.053]             inherits <- base::inherits
[16:01:40.053]             invokeRestart <- base::invokeRestart
[16:01:40.053]             length <- base::length
[16:01:40.053]             list <- base::list
[16:01:40.053]             seq.int <- base::seq.int
[16:01:40.053]             signalCondition <- base::signalCondition
[16:01:40.053]             sys.calls <- base::sys.calls
[16:01:40.053]             `[[` <- base::`[[`
[16:01:40.053]             `+` <- base::`+`
[16:01:40.053]             `<<-` <- base::`<<-`
[16:01:40.053]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:40.053]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:40.053]                   3L)]
[16:01:40.053]             }
[16:01:40.053]             function(cond) {
[16:01:40.053]                 is_error <- inherits(cond, "error")
[16:01:40.053]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:40.053]                   NULL)
[16:01:40.053]                 if (is_error) {
[16:01:40.053]                   sessionInformation <- function() {
[16:01:40.053]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:40.053]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:40.053]                       search = base::search(), system = base::Sys.info())
[16:01:40.053]                   }
[16:01:40.053]                   ...future.conditions[[length(...future.conditions) + 
[16:01:40.053]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:40.053]                     cond$call), session = sessionInformation(), 
[16:01:40.053]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:40.053]                   signalCondition(cond)
[16:01:40.053]                 }
[16:01:40.053]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:40.053]                 "immediateCondition"))) {
[16:01:40.053]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:40.053]                   ...future.conditions[[length(...future.conditions) + 
[16:01:40.053]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:40.053]                   if (TRUE && !signal) {
[16:01:40.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.053]                     {
[16:01:40.053]                       inherits <- base::inherits
[16:01:40.053]                       invokeRestart <- base::invokeRestart
[16:01:40.053]                       is.null <- base::is.null
[16:01:40.053]                       muffled <- FALSE
[16:01:40.053]                       if (inherits(cond, "message")) {
[16:01:40.053]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:40.053]                         if (muffled) 
[16:01:40.053]                           invokeRestart("muffleMessage")
[16:01:40.053]                       }
[16:01:40.053]                       else if (inherits(cond, "warning")) {
[16:01:40.053]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:40.053]                         if (muffled) 
[16:01:40.053]                           invokeRestart("muffleWarning")
[16:01:40.053]                       }
[16:01:40.053]                       else if (inherits(cond, "condition")) {
[16:01:40.053]                         if (!is.null(pattern)) {
[16:01:40.053]                           computeRestarts <- base::computeRestarts
[16:01:40.053]                           grepl <- base::grepl
[16:01:40.053]                           restarts <- computeRestarts(cond)
[16:01:40.053]                           for (restart in restarts) {
[16:01:40.053]                             name <- restart$name
[16:01:40.053]                             if (is.null(name)) 
[16:01:40.053]                               next
[16:01:40.053]                             if (!grepl(pattern, name)) 
[16:01:40.053]                               next
[16:01:40.053]                             invokeRestart(restart)
[16:01:40.053]                             muffled <- TRUE
[16:01:40.053]                             break
[16:01:40.053]                           }
[16:01:40.053]                         }
[16:01:40.053]                       }
[16:01:40.053]                       invisible(muffled)
[16:01:40.053]                     }
[16:01:40.053]                     muffleCondition(cond, pattern = "^muffle")
[16:01:40.053]                   }
[16:01:40.053]                 }
[16:01:40.053]                 else {
[16:01:40.053]                   if (TRUE) {
[16:01:40.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.053]                     {
[16:01:40.053]                       inherits <- base::inherits
[16:01:40.053]                       invokeRestart <- base::invokeRestart
[16:01:40.053]                       is.null <- base::is.null
[16:01:40.053]                       muffled <- FALSE
[16:01:40.053]                       if (inherits(cond, "message")) {
[16:01:40.053]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:40.053]                         if (muffled) 
[16:01:40.053]                           invokeRestart("muffleMessage")
[16:01:40.053]                       }
[16:01:40.053]                       else if (inherits(cond, "warning")) {
[16:01:40.053]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:40.053]                         if (muffled) 
[16:01:40.053]                           invokeRestart("muffleWarning")
[16:01:40.053]                       }
[16:01:40.053]                       else if (inherits(cond, "condition")) {
[16:01:40.053]                         if (!is.null(pattern)) {
[16:01:40.053]                           computeRestarts <- base::computeRestarts
[16:01:40.053]                           grepl <- base::grepl
[16:01:40.053]                           restarts <- computeRestarts(cond)
[16:01:40.053]                           for (restart in restarts) {
[16:01:40.053]                             name <- restart$name
[16:01:40.053]                             if (is.null(name)) 
[16:01:40.053]                               next
[16:01:40.053]                             if (!grepl(pattern, name)) 
[16:01:40.053]                               next
[16:01:40.053]                             invokeRestart(restart)
[16:01:40.053]                             muffled <- TRUE
[16:01:40.053]                             break
[16:01:40.053]                           }
[16:01:40.053]                         }
[16:01:40.053]                       }
[16:01:40.053]                       invisible(muffled)
[16:01:40.053]                     }
[16:01:40.053]                     muffleCondition(cond, pattern = "^muffle")
[16:01:40.053]                   }
[16:01:40.053]                 }
[16:01:40.053]             }
[16:01:40.053]         }))
[16:01:40.053]     }, error = function(ex) {
[16:01:40.053]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:40.053]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:40.053]                 ...future.rng), started = ...future.startTime, 
[16:01:40.053]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:40.053]             version = "1.8"), class = "FutureResult")
[16:01:40.053]     }, finally = {
[16:01:40.053]         if (!identical(...future.workdir, getwd())) 
[16:01:40.053]             setwd(...future.workdir)
[16:01:40.053]         {
[16:01:40.053]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:40.053]                 ...future.oldOptions$nwarnings <- NULL
[16:01:40.053]             }
[16:01:40.053]             base::options(...future.oldOptions)
[16:01:40.053]             if (.Platform$OS.type == "windows") {
[16:01:40.053]                 old_names <- names(...future.oldEnvVars)
[16:01:40.053]                 envs <- base::Sys.getenv()
[16:01:40.053]                 names <- names(envs)
[16:01:40.053]                 common <- intersect(names, old_names)
[16:01:40.053]                 added <- setdiff(names, old_names)
[16:01:40.053]                 removed <- setdiff(old_names, names)
[16:01:40.053]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:40.053]                   envs[common]]
[16:01:40.053]                 NAMES <- toupper(changed)
[16:01:40.053]                 args <- list()
[16:01:40.053]                 for (kk in seq_along(NAMES)) {
[16:01:40.053]                   name <- changed[[kk]]
[16:01:40.053]                   NAME <- NAMES[[kk]]
[16:01:40.053]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.053]                     next
[16:01:40.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:40.053]                 }
[16:01:40.053]                 NAMES <- toupper(added)
[16:01:40.053]                 for (kk in seq_along(NAMES)) {
[16:01:40.053]                   name <- added[[kk]]
[16:01:40.053]                   NAME <- NAMES[[kk]]
[16:01:40.053]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.053]                     next
[16:01:40.053]                   args[[name]] <- ""
[16:01:40.053]                 }
[16:01:40.053]                 NAMES <- toupper(removed)
[16:01:40.053]                 for (kk in seq_along(NAMES)) {
[16:01:40.053]                   name <- removed[[kk]]
[16:01:40.053]                   NAME <- NAMES[[kk]]
[16:01:40.053]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.053]                     next
[16:01:40.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:40.053]                 }
[16:01:40.053]                 if (length(args) > 0) 
[16:01:40.053]                   base::do.call(base::Sys.setenv, args = args)
[16:01:40.053]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:40.053]             }
[16:01:40.053]             else {
[16:01:40.053]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:40.053]             }
[16:01:40.053]             {
[16:01:40.053]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:40.053]                   0L) {
[16:01:40.053]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:40.053]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:40.053]                   base::options(opts)
[16:01:40.053]                 }
[16:01:40.053]                 {
[16:01:40.053]                   {
[16:01:40.053]                     NULL
[16:01:40.053]                     RNGkind("Mersenne-Twister")
[16:01:40.053]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:40.053]                       inherits = FALSE)
[16:01:40.053]                   }
[16:01:40.053]                   options(future.plan = NULL)
[16:01:40.053]                   if (is.na(NA_character_)) 
[16:01:40.053]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:40.053]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:40.053]                   future::plan(list(function (..., envir = parent.frame()) 
[16:01:40.053]                   {
[16:01:40.053]                     future <- SequentialFuture(..., envir = envir)
[16:01:40.053]                     if (!future$lazy) 
[16:01:40.053]                       future <- run(future)
[16:01:40.053]                     invisible(future)
[16:01:40.053]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:40.053]                 }
[16:01:40.053]             }
[16:01:40.053]         }
[16:01:40.053]     })
[16:01:40.053]     if (TRUE) {
[16:01:40.053]         base::sink(type = "output", split = FALSE)
[16:01:40.053]         if (TRUE) {
[16:01:40.053]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:40.053]         }
[16:01:40.053]         else {
[16:01:40.053]             ...future.result["stdout"] <- base::list(NULL)
[16:01:40.053]         }
[16:01:40.053]         base::close(...future.stdout)
[16:01:40.053]         ...future.stdout <- NULL
[16:01:40.053]     }
[16:01:40.053]     ...future.result$conditions <- ...future.conditions
[16:01:40.053]     ...future.result$finished <- base::Sys.time()
[16:01:40.053]     ...future.result
[16:01:40.053] }
[16:01:40.055] assign_globals() ...
[16:01:40.055] List of 5
[16:01:40.055]  $ future.call.arguments    : list()
[16:01:40.055]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.055]  $ ...future.FUN            :function (x)  
[16:01:40.055]  $ ...future.elements_ii    :List of 2
[16:01:40.055]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[16:01:40.055]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[16:01:40.055]  $ ...future.seeds_ii       : NULL
[16:01:40.055]  $ ...future.globals.maxSize: num Inf
[16:01:40.055]  - attr(*, "resolved")= logi FALSE
[16:01:40.055]  - attr(*, "total_size")= num NA
[16:01:40.055]  - attr(*, "where")=List of 5
[16:01:40.055]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:40.055]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:40.055]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:40.055]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:40.055]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:40.055]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.055]  - attr(*, "already-done")= logi TRUE
[16:01:40.060] - copied ‘future.call.arguments’ to environment
[16:01:40.060] - copied ‘...future.FUN’ to environment
[16:01:40.060] - copied ‘...future.elements_ii’ to environment
[16:01:40.060] - copied ‘...future.seeds_ii’ to environment
[16:01:40.060] - copied ‘...future.globals.maxSize’ to environment
[16:01:40.061] assign_globals() ... done
[16:01:40.061] plan(): Setting new future strategy stack:
[16:01:40.061] List of future strategies:
[16:01:40.061] 1. sequential:
[16:01:40.061]    - args: function (..., envir = parent.frame())
[16:01:40.061]    - tweaked: FALSE
[16:01:40.061]    - call: NULL
[16:01:40.061] plan(): nbrOfWorkers() = 1
[16:01:40.062] plan(): Setting new future strategy stack:
[16:01:40.062] List of future strategies:
[16:01:40.062] 1. sequential:
[16:01:40.062]    - args: function (..., envir = parent.frame())
[16:01:40.062]    - tweaked: FALSE
[16:01:40.062]    - call: plan(strategy)
[16:01:40.062] plan(): nbrOfWorkers() = 1
[16:01:40.063] SequentialFuture started (and completed)
[16:01:40.063] - Launch lazy future ... done
[16:01:40.063] run() for ‘SequentialFuture’ ... done
[16:01:40.063] Created future:
[16:01:40.063] SequentialFuture:
[16:01:40.063] Label: ‘future_apply-1’
[16:01:40.063] Expression:
[16:01:40.063] {
[16:01:40.063]     do.call(function(...) {
[16:01:40.063]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.063]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.063]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.063]             on.exit(options(oopts), add = TRUE)
[16:01:40.063]         }
[16:01:40.063]         {
[16:01:40.063]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.063]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.063]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.063]             })
[16:01:40.063]         }
[16:01:40.063]     }, args = future.call.arguments)
[16:01:40.063] }
[16:01:40.063] Lazy evaluation: FALSE
[16:01:40.063] Asynchronous evaluation: FALSE
[16:01:40.063] Local evaluation: TRUE
[16:01:40.063] Environment: R_GlobalEnv
[16:01:40.063] Capture standard output: TRUE
[16:01:40.063] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:40.063] Globals: 5 objects totaling 1.10 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:40.063] Packages: <none>
[16:01:40.063] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:40.063] Resolved: TRUE
[16:01:40.063] Value: 224 bytes of class ‘list’
[16:01:40.063] Early signaling: FALSE
[16:01:40.063] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:40.063] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:40.064] Chunk #1 of 1 ... DONE
[16:01:40.064] Launching 1 futures (chunks) ... DONE
[16:01:40.064] Resolving 1 futures (chunks) ...
[16:01:40.064] resolve() on list ...
[16:01:40.064]  recursive: 0
[16:01:40.064]  length: 1
[16:01:40.065] 
[16:01:40.065] resolved() for ‘SequentialFuture’ ...
[16:01:40.065] - state: ‘finished’
[16:01:40.065] - run: TRUE
[16:01:40.065] - result: ‘FutureResult’
[16:01:40.065] resolved() for ‘SequentialFuture’ ... done
[16:01:40.065] Future #1
[16:01:40.065] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:40.065] - nx: 1
[16:01:40.065] - relay: TRUE
[16:01:40.066] - stdout: TRUE
[16:01:40.066] - signal: TRUE
[16:01:40.066] - resignal: FALSE
[16:01:40.066] - force: TRUE
[16:01:40.066] - relayed: [n=1] FALSE
[16:01:40.066] - queued futures: [n=1] FALSE
[16:01:40.066]  - until=1
[16:01:40.066]  - relaying element #1
[16:01:40.066] - relayed: [n=1] TRUE
[16:01:40.066] - queued futures: [n=1] TRUE
[16:01:40.066] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:40.067]  length: 0 (resolved future 1)
[16:01:40.067] Relaying remaining futures
[16:01:40.067] signalConditionsASAP(NULL, pos=0) ...
[16:01:40.067] - nx: 1
[16:01:40.067] - relay: TRUE
[16:01:40.067] - stdout: TRUE
[16:01:40.067] - signal: TRUE
[16:01:40.067] - resignal: FALSE
[16:01:40.067] - force: TRUE
[16:01:40.067] - relayed: [n=1] TRUE
[16:01:40.067] - queued futures: [n=1] TRUE
 - flush all
[16:01:40.068] - relayed: [n=1] TRUE
[16:01:40.068] - queued futures: [n=1] TRUE
[16:01:40.068] signalConditionsASAP(NULL, pos=0) ... done
[16:01:40.068] resolve() on list ... DONE
[16:01:40.068]  - Number of value chunks collected: 1
[16:01:40.068] Resolving 1 futures (chunks) ... DONE
[16:01:40.068] Reducing values from 1 chunks ...
[16:01:40.068]  - Number of values collected after concatenation: 2
[16:01:40.068]  - Number of values expected: 2
[16:01:40.068] Reducing values from 1 chunks ... DONE
[16:01:40.069] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[16:01:40.069] getGlobalsAndPackagesXApply() ...
[16:01:40.069]  - future.globals: TRUE
[16:01:40.069] getGlobalsAndPackages() ...
[16:01:40.069] Searching for globals...
[16:01:40.070] - globals found: [1] ‘FUN’
[16:01:40.070] Searching for globals ... DONE
[16:01:40.070] Resolving globals: FALSE
[16:01:40.071] The total size of the 1 globals is 848 bytes (848 bytes)
[16:01:40.071] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:01:40.071] - globals: [1] ‘FUN’
[16:01:40.071] 
[16:01:40.071] getGlobalsAndPackages() ... DONE
[16:01:40.071]  - globals found/used: [n=1] ‘FUN’
[16:01:40.072]  - needed namespaces: [n=0] 
[16:01:40.072] Finding globals ... DONE
[16:01:40.072]  - use_args: TRUE
[16:01:40.072]  - Getting '...' globals ...
[16:01:40.072] resolve() on list ...
[16:01:40.072]  recursive: 0
[16:01:40.072]  length: 1
[16:01:40.072]  elements: ‘...’
[16:01:40.072]  length: 0 (resolved future 1)
[16:01:40.073] resolve() on list ... DONE
[16:01:40.073]    - '...' content: [n=0] 
[16:01:40.073] List of 1
[16:01:40.073]  $ ...: list()
[16:01:40.073]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.073]  - attr(*, "where")=List of 1
[16:01:40.073]   ..$ ...:<environment: 0x55fb649d1570> 
[16:01:40.073]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.073]  - attr(*, "resolved")= logi TRUE
[16:01:40.073]  - attr(*, "total_size")= num NA
[16:01:40.077]  - Getting '...' globals ... DONE
[16:01:40.077] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:40.077] List of 2
[16:01:40.077]  $ ...future.FUN:function (x)  
[16:01:40.077]  $ ...          : list()
[16:01:40.077]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.077]  - attr(*, "where")=List of 2
[16:01:40.077]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:40.077]   ..$ ...          :<environment: 0x55fb649d1570> 
[16:01:40.077]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.077]  - attr(*, "resolved")= logi FALSE
[16:01:40.077]  - attr(*, "total_size")= num 848
[16:01:40.080] Packages to be attached in all futures: [n=0] 
[16:01:40.080] getGlobalsAndPackagesXApply() ... DONE
[16:01:40.080] future_lapply() ...
[16:01:40.081] Number of chunks: 1
[16:01:40.081] getGlobalsAndPackagesXApply() ...
[16:01:40.081]  - future.globals: <name-value list> with names ‘list()’
[16:01:40.081]  - use_args: TRUE
[16:01:40.081] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:01:40.081] List of 2
[16:01:40.081]  $ ...          : list()
[16:01:40.081]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.081]  $ ...future.FUN:function (x)  
[16:01:40.081]  - attr(*, "where")=List of 2
[16:01:40.081]   ..$ ...          :<environment: 0x55fb649d1570> 
[16:01:40.081]   ..$ ...future.FUN:<environment: namespace:base> 
[16:01:40.081]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.081]  - attr(*, "resolved")= logi FALSE
[16:01:40.081]  - attr(*, "total_size")= num NA
[16:01:40.085] Packages to be attached in all futures: [n=0] 
[16:01:40.085] getGlobalsAndPackagesXApply() ... DONE
[16:01:40.085] Number of futures (= number of chunks): 1
[16:01:40.085] Launching 1 futures (chunks) ...
[16:01:40.085] Chunk #1 of 1 ...
[16:01:40.085]  - seeds: <none>
[16:01:40.085]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.085] getGlobalsAndPackages() ...
[16:01:40.086] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.086] Resolving globals: FALSE
[16:01:40.086] Tweak future expression to call with '...' arguments ...
[16:01:40.086] {
[16:01:40.086]     do.call(function(...) {
[16:01:40.086]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.086]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.086]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.086]             on.exit(options(oopts), add = TRUE)
[16:01:40.086]         }
[16:01:40.086]         {
[16:01:40.086]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.086]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.086]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.086]             })
[16:01:40.086]         }
[16:01:40.086]     }, args = future.call.arguments)
[16:01:40.086] }
[16:01:40.086] Tweak future expression to call with '...' arguments ... DONE
[16:01:40.087] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.087] 
[16:01:40.087] getGlobalsAndPackages() ... DONE
[16:01:40.087] run() for ‘Future’ ...
[16:01:40.087] - state: ‘created’
[16:01:40.087] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:01:40.088] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:40.088] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:40.088]   - Field: ‘label’
[16:01:40.088]   - Field: ‘local’
[16:01:40.088]   - Field: ‘owner’
[16:01:40.088]   - Field: ‘envir’
[16:01:40.088]   - Field: ‘packages’
[16:01:40.088]   - Field: ‘gc’
[16:01:40.088]   - Field: ‘conditions’
[16:01:40.088]   - Field: ‘expr’
[16:01:40.089]   - Field: ‘uuid’
[16:01:40.089]   - Field: ‘seed’
[16:01:40.089]   - Field: ‘version’
[16:01:40.089]   - Field: ‘result’
[16:01:40.089]   - Field: ‘asynchronous’
[16:01:40.089]   - Field: ‘calls’
[16:01:40.089]   - Field: ‘globals’
[16:01:40.089]   - Field: ‘stdout’
[16:01:40.089]   - Field: ‘earlySignal’
[16:01:40.089]   - Field: ‘lazy’
[16:01:40.089]   - Field: ‘state’
[16:01:40.090] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:40.090] - Launch lazy future ...
[16:01:40.090] Packages needed by the future expression (n = 0): <none>
[16:01:40.090] Packages needed by future strategies (n = 0): <none>
[16:01:40.090] {
[16:01:40.090]     {
[16:01:40.090]         {
[16:01:40.090]             ...future.startTime <- base::Sys.time()
[16:01:40.090]             {
[16:01:40.090]                 {
[16:01:40.090]                   {
[16:01:40.090]                     base::local({
[16:01:40.090]                       has_future <- base::requireNamespace("future", 
[16:01:40.090]                         quietly = TRUE)
[16:01:40.090]                       if (has_future) {
[16:01:40.090]                         ns <- base::getNamespace("future")
[16:01:40.090]                         version <- ns[[".package"]][["version"]]
[16:01:40.090]                         if (is.null(version)) 
[16:01:40.090]                           version <- utils::packageVersion("future")
[16:01:40.090]                       }
[16:01:40.090]                       else {
[16:01:40.090]                         version <- NULL
[16:01:40.090]                       }
[16:01:40.090]                       if (!has_future || version < "1.8.0") {
[16:01:40.090]                         info <- base::c(r_version = base::gsub("R version ", 
[16:01:40.090]                           "", base::R.version$version.string), 
[16:01:40.090]                           platform = base::sprintf("%s (%s-bit)", 
[16:01:40.090]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:40.090]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:40.090]                             "release", "version")], collapse = " "), 
[16:01:40.090]                           hostname = base::Sys.info()[["nodename"]])
[16:01:40.090]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:01:40.090]                           info)
[16:01:40.090]                         info <- base::paste(info, collapse = "; ")
[16:01:40.090]                         if (!has_future) {
[16:01:40.090]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:40.090]                             info)
[16:01:40.090]                         }
[16:01:40.090]                         else {
[16:01:40.090]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:40.090]                             info, version)
[16:01:40.090]                         }
[16:01:40.090]                         base::stop(msg)
[16:01:40.090]                       }
[16:01:40.090]                     })
[16:01:40.090]                   }
[16:01:40.090]                   options(future.plan = NULL)
[16:01:40.090]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:40.090]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:40.090]                 }
[16:01:40.090]                 ...future.workdir <- getwd()
[16:01:40.090]             }
[16:01:40.090]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:40.090]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:40.090]         }
[16:01:40.090]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:40.090]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:40.090]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:40.090]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:40.090]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:40.090]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:40.090]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:40.090]             base::names(...future.oldOptions))
[16:01:40.090]     }
[16:01:40.090]     if (FALSE) {
[16:01:40.090]     }
[16:01:40.090]     else {
[16:01:40.090]         if (TRUE) {
[16:01:40.090]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:40.090]                 open = "w")
[16:01:40.090]         }
[16:01:40.090]         else {
[16:01:40.090]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:40.090]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:40.090]         }
[16:01:40.090]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:40.090]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:40.090]             base::sink(type = "output", split = FALSE)
[16:01:40.090]             base::close(...future.stdout)
[16:01:40.090]         }, add = TRUE)
[16:01:40.090]     }
[16:01:40.090]     ...future.frame <- base::sys.nframe()
[16:01:40.090]     ...future.conditions <- base::list()
[16:01:40.090]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:40.090]     if (FALSE) {
[16:01:40.090]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:40.090]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:40.090]     }
[16:01:40.090]     ...future.result <- base::tryCatch({
[16:01:40.090]         base::withCallingHandlers({
[16:01:40.090]             ...future.value <- base::withVisible(base::local({
[16:01:40.090]                 do.call(function(...) {
[16:01:40.090]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.090]                   if (!identical(...future.globals.maxSize.org, 
[16:01:40.090]                     ...future.globals.maxSize)) {
[16:01:40.090]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.090]                     on.exit(options(oopts), add = TRUE)
[16:01:40.090]                   }
[16:01:40.090]                   {
[16:01:40.090]                     lapply(seq_along(...future.elements_ii), 
[16:01:40.090]                       FUN = function(jj) {
[16:01:40.090]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.090]                         ...future.FUN(...future.X_jj, ...)
[16:01:40.090]                       })
[16:01:40.090]                   }
[16:01:40.090]                 }, args = future.call.arguments)
[16:01:40.090]             }))
[16:01:40.090]             future::FutureResult(value = ...future.value$value, 
[16:01:40.090]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:40.090]                   ...future.rng), globalenv = if (FALSE) 
[16:01:40.090]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:40.090]                     ...future.globalenv.names))
[16:01:40.090]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:40.090]         }, condition = base::local({
[16:01:40.090]             c <- base::c
[16:01:40.090]             inherits <- base::inherits
[16:01:40.090]             invokeRestart <- base::invokeRestart
[16:01:40.090]             length <- base::length
[16:01:40.090]             list <- base::list
[16:01:40.090]             seq.int <- base::seq.int
[16:01:40.090]             signalCondition <- base::signalCondition
[16:01:40.090]             sys.calls <- base::sys.calls
[16:01:40.090]             `[[` <- base::`[[`
[16:01:40.090]             `+` <- base::`+`
[16:01:40.090]             `<<-` <- base::`<<-`
[16:01:40.090]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:40.090]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:40.090]                   3L)]
[16:01:40.090]             }
[16:01:40.090]             function(cond) {
[16:01:40.090]                 is_error <- inherits(cond, "error")
[16:01:40.090]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:40.090]                   NULL)
[16:01:40.090]                 if (is_error) {
[16:01:40.090]                   sessionInformation <- function() {
[16:01:40.090]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:40.090]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:40.090]                       search = base::search(), system = base::Sys.info())
[16:01:40.090]                   }
[16:01:40.090]                   ...future.conditions[[length(...future.conditions) + 
[16:01:40.090]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:40.090]                     cond$call), session = sessionInformation(), 
[16:01:40.090]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:40.090]                   signalCondition(cond)
[16:01:40.090]                 }
[16:01:40.090]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:40.090]                 "immediateCondition"))) {
[16:01:40.090]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:40.090]                   ...future.conditions[[length(...future.conditions) + 
[16:01:40.090]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:40.090]                   if (TRUE && !signal) {
[16:01:40.090]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.090]                     {
[16:01:40.090]                       inherits <- base::inherits
[16:01:40.090]                       invokeRestart <- base::invokeRestart
[16:01:40.090]                       is.null <- base::is.null
[16:01:40.090]                       muffled <- FALSE
[16:01:40.090]                       if (inherits(cond, "message")) {
[16:01:40.090]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:40.090]                         if (muffled) 
[16:01:40.090]                           invokeRestart("muffleMessage")
[16:01:40.090]                       }
[16:01:40.090]                       else if (inherits(cond, "warning")) {
[16:01:40.090]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:40.090]                         if (muffled) 
[16:01:40.090]                           invokeRestart("muffleWarning")
[16:01:40.090]                       }
[16:01:40.090]                       else if (inherits(cond, "condition")) {
[16:01:40.090]                         if (!is.null(pattern)) {
[16:01:40.090]                           computeRestarts <- base::computeRestarts
[16:01:40.090]                           grepl <- base::grepl
[16:01:40.090]                           restarts <- computeRestarts(cond)
[16:01:40.090]                           for (restart in restarts) {
[16:01:40.090]                             name <- restart$name
[16:01:40.090]                             if (is.null(name)) 
[16:01:40.090]                               next
[16:01:40.090]                             if (!grepl(pattern, name)) 
[16:01:40.090]                               next
[16:01:40.090]                             invokeRestart(restart)
[16:01:40.090]                             muffled <- TRUE
[16:01:40.090]                             break
[16:01:40.090]                           }
[16:01:40.090]                         }
[16:01:40.090]                       }
[16:01:40.090]                       invisible(muffled)
[16:01:40.090]                     }
[16:01:40.090]                     muffleCondition(cond, pattern = "^muffle")
[16:01:40.090]                   }
[16:01:40.090]                 }
[16:01:40.090]                 else {
[16:01:40.090]                   if (TRUE) {
[16:01:40.090]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.090]                     {
[16:01:40.090]                       inherits <- base::inherits
[16:01:40.090]                       invokeRestart <- base::invokeRestart
[16:01:40.090]                       is.null <- base::is.null
[16:01:40.090]                       muffled <- FALSE
[16:01:40.090]                       if (inherits(cond, "message")) {
[16:01:40.090]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:40.090]                         if (muffled) 
[16:01:40.090]                           invokeRestart("muffleMessage")
[16:01:40.090]                       }
[16:01:40.090]                       else if (inherits(cond, "warning")) {
[16:01:40.090]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:40.090]                         if (muffled) 
[16:01:40.090]                           invokeRestart("muffleWarning")
[16:01:40.090]                       }
[16:01:40.090]                       else if (inherits(cond, "condition")) {
[16:01:40.090]                         if (!is.null(pattern)) {
[16:01:40.090]                           computeRestarts <- base::computeRestarts
[16:01:40.090]                           grepl <- base::grepl
[16:01:40.090]                           restarts <- computeRestarts(cond)
[16:01:40.090]                           for (restart in restarts) {
[16:01:40.090]                             name <- restart$name
[16:01:40.090]                             if (is.null(name)) 
[16:01:40.090]                               next
[16:01:40.090]                             if (!grepl(pattern, name)) 
[16:01:40.090]                               next
[16:01:40.090]                             invokeRestart(restart)
[16:01:40.090]                             muffled <- TRUE
[16:01:40.090]                             break
[16:01:40.090]                           }
[16:01:40.090]                         }
[16:01:40.090]                       }
[16:01:40.090]                       invisible(muffled)
[16:01:40.090]                     }
[16:01:40.090]                     muffleCondition(cond, pattern = "^muffle")
[16:01:40.090]                   }
[16:01:40.090]                 }
[16:01:40.090]             }
[16:01:40.090]         }))
[16:01:40.090]     }, error = function(ex) {
[16:01:40.090]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:40.090]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:40.090]                 ...future.rng), started = ...future.startTime, 
[16:01:40.090]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:40.090]             version = "1.8"), class = "FutureResult")
[16:01:40.090]     }, finally = {
[16:01:40.090]         if (!identical(...future.workdir, getwd())) 
[16:01:40.090]             setwd(...future.workdir)
[16:01:40.090]         {
[16:01:40.090]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:40.090]                 ...future.oldOptions$nwarnings <- NULL
[16:01:40.090]             }
[16:01:40.090]             base::options(...future.oldOptions)
[16:01:40.090]             if (.Platform$OS.type == "windows") {
[16:01:40.090]                 old_names <- names(...future.oldEnvVars)
[16:01:40.090]                 envs <- base::Sys.getenv()
[16:01:40.090]                 names <- names(envs)
[16:01:40.090]                 common <- intersect(names, old_names)
[16:01:40.090]                 added <- setdiff(names, old_names)
[16:01:40.090]                 removed <- setdiff(old_names, names)
[16:01:40.090]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:40.090]                   envs[common]]
[16:01:40.090]                 NAMES <- toupper(changed)
[16:01:40.090]                 args <- list()
[16:01:40.090]                 for (kk in seq_along(NAMES)) {
[16:01:40.090]                   name <- changed[[kk]]
[16:01:40.090]                   NAME <- NAMES[[kk]]
[16:01:40.090]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.090]                     next
[16:01:40.090]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:40.090]                 }
[16:01:40.090]                 NAMES <- toupper(added)
[16:01:40.090]                 for (kk in seq_along(NAMES)) {
[16:01:40.090]                   name <- added[[kk]]
[16:01:40.090]                   NAME <- NAMES[[kk]]
[16:01:40.090]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.090]                     next
[16:01:40.090]                   args[[name]] <- ""
[16:01:40.090]                 }
[16:01:40.090]                 NAMES <- toupper(removed)
[16:01:40.090]                 for (kk in seq_along(NAMES)) {
[16:01:40.090]                   name <- removed[[kk]]
[16:01:40.090]                   NAME <- NAMES[[kk]]
[16:01:40.090]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.090]                     next
[16:01:40.090]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:40.090]                 }
[16:01:40.090]                 if (length(args) > 0) 
[16:01:40.090]                   base::do.call(base::Sys.setenv, args = args)
[16:01:40.090]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:40.090]             }
[16:01:40.090]             else {
[16:01:40.090]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:40.090]             }
[16:01:40.090]             {
[16:01:40.090]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:40.090]                   0L) {
[16:01:40.090]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:40.090]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:40.090]                   base::options(opts)
[16:01:40.090]                 }
[16:01:40.090]                 {
[16:01:40.090]                   {
[16:01:40.090]                     NULL
[16:01:40.090]                     RNGkind("Mersenne-Twister")
[16:01:40.090]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:40.090]                       inherits = FALSE)
[16:01:40.090]                   }
[16:01:40.090]                   options(future.plan = NULL)
[16:01:40.090]                   if (is.na(NA_character_)) 
[16:01:40.090]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:40.090]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:40.090]                   future::plan(list(function (..., envir = parent.frame()) 
[16:01:40.090]                   {
[16:01:40.090]                     future <- SequentialFuture(..., envir = envir)
[16:01:40.090]                     if (!future$lazy) 
[16:01:40.090]                       future <- run(future)
[16:01:40.090]                     invisible(future)
[16:01:40.090]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:40.090]                 }
[16:01:40.090]             }
[16:01:40.090]         }
[16:01:40.090]     })
[16:01:40.090]     if (TRUE) {
[16:01:40.090]         base::sink(type = "output", split = FALSE)
[16:01:40.090]         if (TRUE) {
[16:01:40.090]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:40.090]         }
[16:01:40.090]         else {
[16:01:40.090]             ...future.result["stdout"] <- base::list(NULL)
[16:01:40.090]         }
[16:01:40.090]         base::close(...future.stdout)
[16:01:40.090]         ...future.stdout <- NULL
[16:01:40.090]     }
[16:01:40.090]     ...future.result$conditions <- ...future.conditions
[16:01:40.090]     ...future.result$finished <- base::Sys.time()
[16:01:40.090]     ...future.result
[16:01:40.090] }
[16:01:40.092] assign_globals() ...
[16:01:40.092] List of 5
[16:01:40.092]  $ future.call.arguments    : list()
[16:01:40.092]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.092]  $ ...future.FUN            :function (x)  
[16:01:40.092]  $ ...future.elements_ii    :List of 6
[16:01:40.092]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[16:01:40.092]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[16:01:40.092]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[16:01:40.092]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[16:01:40.092]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[16:01:40.092]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[16:01:40.092]  $ ...future.seeds_ii       : NULL
[16:01:40.092]  $ ...future.globals.maxSize: num Inf
[16:01:40.092]  - attr(*, "resolved")= logi FALSE
[16:01:40.092]  - attr(*, "total_size")= num NA
[16:01:40.092]  - attr(*, "where")=List of 5
[16:01:40.092]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:40.092]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:40.092]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:40.092]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:40.092]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:40.092]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.092]  - attr(*, "already-done")= logi TRUE
[16:01:40.100] - copied ‘future.call.arguments’ to environment
[16:01:40.100] - copied ‘...future.FUN’ to environment
[16:01:40.101] - copied ‘...future.elements_ii’ to environment
[16:01:40.101] - copied ‘...future.seeds_ii’ to environment
[16:01:40.101] - copied ‘...future.globals.maxSize’ to environment
[16:01:40.101] assign_globals() ... done
[16:01:40.101] plan(): Setting new future strategy stack:
[16:01:40.101] List of future strategies:
[16:01:40.101] 1. sequential:
[16:01:40.101]    - args: function (..., envir = parent.frame())
[16:01:40.101]    - tweaked: FALSE
[16:01:40.101]    - call: NULL
[16:01:40.102] plan(): nbrOfWorkers() = 1
[16:01:40.102] plan(): Setting new future strategy stack:
[16:01:40.102] List of future strategies:
[16:01:40.102] 1. sequential:
[16:01:40.102]    - args: function (..., envir = parent.frame())
[16:01:40.102]    - tweaked: FALSE
[16:01:40.102]    - call: plan(strategy)
[16:01:40.103] plan(): nbrOfWorkers() = 1
[16:01:40.103] SequentialFuture started (and completed)
[16:01:40.103] - Launch lazy future ... done
[16:01:40.103] run() for ‘SequentialFuture’ ... done
[16:01:40.103] Created future:
[16:01:40.103] SequentialFuture:
[16:01:40.103] Label: ‘future_apply-1’
[16:01:40.103] Expression:
[16:01:40.103] {
[16:01:40.103]     do.call(function(...) {
[16:01:40.103]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.103]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.103]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.103]             on.exit(options(oopts), add = TRUE)
[16:01:40.103]         }
[16:01:40.103]         {
[16:01:40.103]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.103]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.103]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.103]             })
[16:01:40.103]         }
[16:01:40.103]     }, args = future.call.arguments)
[16:01:40.103] }
[16:01:40.103] Lazy evaluation: FALSE
[16:01:40.103] Asynchronous evaluation: FALSE
[16:01:40.103] Local evaluation: TRUE
[16:01:40.103] Environment: R_GlobalEnv
[16:01:40.103] Capture standard output: TRUE
[16:01:40.103] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:40.103] Globals: 5 objects totaling 1.54 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 672 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:40.103] Packages: <none>
[16:01:40.103] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:40.103] Resolved: TRUE
[16:01:40.103] Value: 672 bytes of class ‘list’
[16:01:40.103] Early signaling: FALSE
[16:01:40.103] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:40.103] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:40.104] Chunk #1 of 1 ... DONE
[16:01:40.105] Launching 1 futures (chunks) ... DONE
[16:01:40.105] Resolving 1 futures (chunks) ...
[16:01:40.105] resolve() on list ...
[16:01:40.105]  recursive: 0
[16:01:40.105]  length: 1
[16:01:40.105] 
[16:01:40.105] resolved() for ‘SequentialFuture’ ...
[16:01:40.105] - state: ‘finished’
[16:01:40.105] - run: TRUE
[16:01:40.105] - result: ‘FutureResult’
[16:01:40.106] resolved() for ‘SequentialFuture’ ... done
[16:01:40.106] Future #1
[16:01:40.106] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:40.106] - nx: 1
[16:01:40.106] - relay: TRUE
[16:01:40.106] - stdout: TRUE
[16:01:40.106] - signal: TRUE
[16:01:40.106] - resignal: FALSE
[16:01:40.106] - force: TRUE
[16:01:40.106] - relayed: [n=1] FALSE
[16:01:40.106] - queued futures: [n=1] FALSE
[16:01:40.107]  - until=1
[16:01:40.107]  - relaying element #1
[16:01:40.107] - relayed: [n=1] TRUE
[16:01:40.107] - queued futures: [n=1] TRUE
[16:01:40.107] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:40.107]  length: 0 (resolved future 1)
[16:01:40.107] Relaying remaining futures
[16:01:40.107] signalConditionsASAP(NULL, pos=0) ...
[16:01:40.107] - nx: 1
[16:01:40.107] - relay: TRUE
[16:01:40.108] - stdout: TRUE
[16:01:40.108] - signal: TRUE
[16:01:40.108] - resignal: FALSE
[16:01:40.108] - force: TRUE
[16:01:40.108] - relayed: [n=1] TRUE
[16:01:40.108] - queued futures: [n=1] TRUE
 - flush all
[16:01:40.108] - relayed: [n=1] TRUE
[16:01:40.108] - queued futures: [n=1] TRUE
[16:01:40.108] signalConditionsASAP(NULL, pos=0) ... done
[16:01:40.108] resolve() on list ... DONE
[16:01:40.109]  - Number of value chunks collected: 1
[16:01:40.109] Resolving 1 futures (chunks) ... DONE
[16:01:40.109] Reducing values from 1 chunks ...
[16:01:40.109]  - Number of values collected after concatenation: 6
[16:01:40.109]  - Number of values expected: 6
[16:01:40.109] Reducing values from 1 chunks ... DONE
[16:01:40.109] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[16:01:40.110] getGlobalsAndPackagesXApply() ...
[16:01:40.110]  - future.globals: TRUE
[16:01:40.110] getGlobalsAndPackages() ...
[16:01:40.110] Searching for globals...
[16:01:40.111] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[16:01:40.111] Searching for globals ... DONE
[16:01:40.111] Resolving globals: FALSE
[16:01:40.112] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[16:01:40.112] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[16:01:40.112] - globals: [1] ‘FUN’
[16:01:40.112] 
[16:01:40.112] getGlobalsAndPackages() ... DONE
[16:01:40.112]  - globals found/used: [n=1] ‘FUN’
[16:01:40.113]  - needed namespaces: [n=0] 
[16:01:40.113] Finding globals ... DONE
[16:01:40.113]  - use_args: TRUE
[16:01:40.113]  - Getting '...' globals ...
[16:01:40.113] resolve() on list ...
[16:01:40.113]  recursive: 0
[16:01:40.113]  length: 1
[16:01:40.113]  elements: ‘...’
[16:01:40.114]  length: 0 (resolved future 1)
[16:01:40.114] resolve() on list ... DONE
[16:01:40.114]    - '...' content: [n=0] 
[16:01:40.114] List of 1
[16:01:40.114]  $ ...: list()
[16:01:40.114]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.114]  - attr(*, "where")=List of 1
[16:01:40.114]   ..$ ...:<environment: 0x55fb644bb990> 
[16:01:40.114]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.114]  - attr(*, "resolved")= logi TRUE
[16:01:40.114]  - attr(*, "total_size")= num NA
[16:01:40.116]  - Getting '...' globals ... DONE
[16:01:40.116] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:40.117] List of 2
[16:01:40.117]  $ ...future.FUN:function (x)  
[16:01:40.117]  $ ...          : list()
[16:01:40.117]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.117]  - attr(*, "where")=List of 2
[16:01:40.117]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:40.117]   ..$ ...          :<environment: 0x55fb644bb990> 
[16:01:40.117]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.117]  - attr(*, "resolved")= logi FALSE
[16:01:40.117]  - attr(*, "total_size")= num 1768
[16:01:40.121] Packages to be attached in all futures: [n=0] 
[16:01:40.121] getGlobalsAndPackagesXApply() ... DONE
[16:01:40.121] future_lapply() ...
[16:01:40.122] Number of chunks: 1
[16:01:40.122] getGlobalsAndPackagesXApply() ...
[16:01:40.122]  - future.globals: <name-value list> with names ‘list()’
[16:01:40.122]  - use_args: TRUE
[16:01:40.122] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:01:40.122] List of 2
[16:01:40.122]  $ ...          : list()
[16:01:40.122]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.122]  $ ...future.FUN:function (x)  
[16:01:40.122]  - attr(*, "where")=List of 2
[16:01:40.122]   ..$ ...          :<environment: 0x55fb644bb990> 
[16:01:40.122]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[16:01:40.122]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.122]  - attr(*, "resolved")= logi FALSE
[16:01:40.122]  - attr(*, "total_size")= num NA
[16:01:40.125] Packages to be attached in all futures: [n=0] 
[16:01:40.125] getGlobalsAndPackagesXApply() ... DONE
[16:01:40.125] Number of futures (= number of chunks): 1
[16:01:40.125] Launching 1 futures (chunks) ...
[16:01:40.126] Chunk #1 of 1 ...
[16:01:40.126]  - seeds: <none>
[16:01:40.126]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.126] getGlobalsAndPackages() ...
[16:01:40.126] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.126] Resolving globals: FALSE
[16:01:40.126] Tweak future expression to call with '...' arguments ...
[16:01:40.126] {
[16:01:40.126]     do.call(function(...) {
[16:01:40.126]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.126]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.126]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.126]             on.exit(options(oopts), add = TRUE)
[16:01:40.126]         }
[16:01:40.126]         {
[16:01:40.126]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.126]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.126]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.126]             })
[16:01:40.126]         }
[16:01:40.126]     }, args = future.call.arguments)
[16:01:40.126] }
[16:01:40.127] Tweak future expression to call with '...' arguments ... DONE
[16:01:40.127] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.127] 
[16:01:40.127] getGlobalsAndPackages() ... DONE
[16:01:40.128] run() for ‘Future’ ...
[16:01:40.128] - state: ‘created’
[16:01:40.128] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:01:40.128] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:40.128] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:40.128]   - Field: ‘label’
[16:01:40.128]   - Field: ‘local’
[16:01:40.128]   - Field: ‘owner’
[16:01:40.129]   - Field: ‘envir’
[16:01:40.129]   - Field: ‘packages’
[16:01:40.129]   - Field: ‘gc’
[16:01:40.129]   - Field: ‘conditions’
[16:01:40.129]   - Field: ‘expr’
[16:01:40.129]   - Field: ‘uuid’
[16:01:40.129]   - Field: ‘seed’
[16:01:40.129]   - Field: ‘version’
[16:01:40.129]   - Field: ‘result’
[16:01:40.129]   - Field: ‘asynchronous’
[16:01:40.129]   - Field: ‘calls’
[16:01:40.130]   - Field: ‘globals’
[16:01:40.130]   - Field: ‘stdout’
[16:01:40.130]   - Field: ‘earlySignal’
[16:01:40.130]   - Field: ‘lazy’
[16:01:40.130]   - Field: ‘state’
[16:01:40.130] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:40.130] - Launch lazy future ...
[16:01:40.130] Packages needed by the future expression (n = 0): <none>
[16:01:40.130] Packages needed by future strategies (n = 0): <none>
[16:01:40.131] {
[16:01:40.131]     {
[16:01:40.131]         {
[16:01:40.131]             ...future.startTime <- base::Sys.time()
[16:01:40.131]             {
[16:01:40.131]                 {
[16:01:40.131]                   {
[16:01:40.131]                     base::local({
[16:01:40.131]                       has_future <- base::requireNamespace("future", 
[16:01:40.131]                         quietly = TRUE)
[16:01:40.131]                       if (has_future) {
[16:01:40.131]                         ns <- base::getNamespace("future")
[16:01:40.131]                         version <- ns[[".package"]][["version"]]
[16:01:40.131]                         if (is.null(version)) 
[16:01:40.131]                           version <- utils::packageVersion("future")
[16:01:40.131]                       }
[16:01:40.131]                       else {
[16:01:40.131]                         version <- NULL
[16:01:40.131]                       }
[16:01:40.131]                       if (!has_future || version < "1.8.0") {
[16:01:40.131]                         info <- base::c(r_version = base::gsub("R version ", 
[16:01:40.131]                           "", base::R.version$version.string), 
[16:01:40.131]                           platform = base::sprintf("%s (%s-bit)", 
[16:01:40.131]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:40.131]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:40.131]                             "release", "version")], collapse = " "), 
[16:01:40.131]                           hostname = base::Sys.info()[["nodename"]])
[16:01:40.131]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:01:40.131]                           info)
[16:01:40.131]                         info <- base::paste(info, collapse = "; ")
[16:01:40.131]                         if (!has_future) {
[16:01:40.131]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:40.131]                             info)
[16:01:40.131]                         }
[16:01:40.131]                         else {
[16:01:40.131]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:40.131]                             info, version)
[16:01:40.131]                         }
[16:01:40.131]                         base::stop(msg)
[16:01:40.131]                       }
[16:01:40.131]                     })
[16:01:40.131]                   }
[16:01:40.131]                   options(future.plan = NULL)
[16:01:40.131]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:40.131]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:40.131]                 }
[16:01:40.131]                 ...future.workdir <- getwd()
[16:01:40.131]             }
[16:01:40.131]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:40.131]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:40.131]         }
[16:01:40.131]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:40.131]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:40.131]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:40.131]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:40.131]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:40.131]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:40.131]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:40.131]             base::names(...future.oldOptions))
[16:01:40.131]     }
[16:01:40.131]     if (FALSE) {
[16:01:40.131]     }
[16:01:40.131]     else {
[16:01:40.131]         if (TRUE) {
[16:01:40.131]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:40.131]                 open = "w")
[16:01:40.131]         }
[16:01:40.131]         else {
[16:01:40.131]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:40.131]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:40.131]         }
[16:01:40.131]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:40.131]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:40.131]             base::sink(type = "output", split = FALSE)
[16:01:40.131]             base::close(...future.stdout)
[16:01:40.131]         }, add = TRUE)
[16:01:40.131]     }
[16:01:40.131]     ...future.frame <- base::sys.nframe()
[16:01:40.131]     ...future.conditions <- base::list()
[16:01:40.131]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:40.131]     if (FALSE) {
[16:01:40.131]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:40.131]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:40.131]     }
[16:01:40.131]     ...future.result <- base::tryCatch({
[16:01:40.131]         base::withCallingHandlers({
[16:01:40.131]             ...future.value <- base::withVisible(base::local({
[16:01:40.131]                 do.call(function(...) {
[16:01:40.131]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.131]                   if (!identical(...future.globals.maxSize.org, 
[16:01:40.131]                     ...future.globals.maxSize)) {
[16:01:40.131]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.131]                     on.exit(options(oopts), add = TRUE)
[16:01:40.131]                   }
[16:01:40.131]                   {
[16:01:40.131]                     lapply(seq_along(...future.elements_ii), 
[16:01:40.131]                       FUN = function(jj) {
[16:01:40.131]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.131]                         ...future.FUN(...future.X_jj, ...)
[16:01:40.131]                       })
[16:01:40.131]                   }
[16:01:40.131]                 }, args = future.call.arguments)
[16:01:40.131]             }))
[16:01:40.131]             future::FutureResult(value = ...future.value$value, 
[16:01:40.131]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:40.131]                   ...future.rng), globalenv = if (FALSE) 
[16:01:40.131]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:40.131]                     ...future.globalenv.names))
[16:01:40.131]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:40.131]         }, condition = base::local({
[16:01:40.131]             c <- base::c
[16:01:40.131]             inherits <- base::inherits
[16:01:40.131]             invokeRestart <- base::invokeRestart
[16:01:40.131]             length <- base::length
[16:01:40.131]             list <- base::list
[16:01:40.131]             seq.int <- base::seq.int
[16:01:40.131]             signalCondition <- base::signalCondition
[16:01:40.131]             sys.calls <- base::sys.calls
[16:01:40.131]             `[[` <- base::`[[`
[16:01:40.131]             `+` <- base::`+`
[16:01:40.131]             `<<-` <- base::`<<-`
[16:01:40.131]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:40.131]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:40.131]                   3L)]
[16:01:40.131]             }
[16:01:40.131]             function(cond) {
[16:01:40.131]                 is_error <- inherits(cond, "error")
[16:01:40.131]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:40.131]                   NULL)
[16:01:40.131]                 if (is_error) {
[16:01:40.131]                   sessionInformation <- function() {
[16:01:40.131]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:40.131]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:40.131]                       search = base::search(), system = base::Sys.info())
[16:01:40.131]                   }
[16:01:40.131]                   ...future.conditions[[length(...future.conditions) + 
[16:01:40.131]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:40.131]                     cond$call), session = sessionInformation(), 
[16:01:40.131]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:40.131]                   signalCondition(cond)
[16:01:40.131]                 }
[16:01:40.131]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:40.131]                 "immediateCondition"))) {
[16:01:40.131]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:40.131]                   ...future.conditions[[length(...future.conditions) + 
[16:01:40.131]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:40.131]                   if (TRUE && !signal) {
[16:01:40.131]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.131]                     {
[16:01:40.131]                       inherits <- base::inherits
[16:01:40.131]                       invokeRestart <- base::invokeRestart
[16:01:40.131]                       is.null <- base::is.null
[16:01:40.131]                       muffled <- FALSE
[16:01:40.131]                       if (inherits(cond, "message")) {
[16:01:40.131]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:40.131]                         if (muffled) 
[16:01:40.131]                           invokeRestart("muffleMessage")
[16:01:40.131]                       }
[16:01:40.131]                       else if (inherits(cond, "warning")) {
[16:01:40.131]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:40.131]                         if (muffled) 
[16:01:40.131]                           invokeRestart("muffleWarning")
[16:01:40.131]                       }
[16:01:40.131]                       else if (inherits(cond, "condition")) {
[16:01:40.131]                         if (!is.null(pattern)) {
[16:01:40.131]                           computeRestarts <- base::computeRestarts
[16:01:40.131]                           grepl <- base::grepl
[16:01:40.131]                           restarts <- computeRestarts(cond)
[16:01:40.131]                           for (restart in restarts) {
[16:01:40.131]                             name <- restart$name
[16:01:40.131]                             if (is.null(name)) 
[16:01:40.131]                               next
[16:01:40.131]                             if (!grepl(pattern, name)) 
[16:01:40.131]                               next
[16:01:40.131]                             invokeRestart(restart)
[16:01:40.131]                             muffled <- TRUE
[16:01:40.131]                             break
[16:01:40.131]                           }
[16:01:40.131]                         }
[16:01:40.131]                       }
[16:01:40.131]                       invisible(muffled)
[16:01:40.131]                     }
[16:01:40.131]                     muffleCondition(cond, pattern = "^muffle")
[16:01:40.131]                   }
[16:01:40.131]                 }
[16:01:40.131]                 else {
[16:01:40.131]                   if (TRUE) {
[16:01:40.131]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.131]                     {
[16:01:40.131]                       inherits <- base::inherits
[16:01:40.131]                       invokeRestart <- base::invokeRestart
[16:01:40.131]                       is.null <- base::is.null
[16:01:40.131]                       muffled <- FALSE
[16:01:40.131]                       if (inherits(cond, "message")) {
[16:01:40.131]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:40.131]                         if (muffled) 
[16:01:40.131]                           invokeRestart("muffleMessage")
[16:01:40.131]                       }
[16:01:40.131]                       else if (inherits(cond, "warning")) {
[16:01:40.131]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:40.131]                         if (muffled) 
[16:01:40.131]                           invokeRestart("muffleWarning")
[16:01:40.131]                       }
[16:01:40.131]                       else if (inherits(cond, "condition")) {
[16:01:40.131]                         if (!is.null(pattern)) {
[16:01:40.131]                           computeRestarts <- base::computeRestarts
[16:01:40.131]                           grepl <- base::grepl
[16:01:40.131]                           restarts <- computeRestarts(cond)
[16:01:40.131]                           for (restart in restarts) {
[16:01:40.131]                             name <- restart$name
[16:01:40.131]                             if (is.null(name)) 
[16:01:40.131]                               next
[16:01:40.131]                             if (!grepl(pattern, name)) 
[16:01:40.131]                               next
[16:01:40.131]                             invokeRestart(restart)
[16:01:40.131]                             muffled <- TRUE
[16:01:40.131]                             break
[16:01:40.131]                           }
[16:01:40.131]                         }
[16:01:40.131]                       }
[16:01:40.131]                       invisible(muffled)
[16:01:40.131]                     }
[16:01:40.131]                     muffleCondition(cond, pattern = "^muffle")
[16:01:40.131]                   }
[16:01:40.131]                 }
[16:01:40.131]             }
[16:01:40.131]         }))
[16:01:40.131]     }, error = function(ex) {
[16:01:40.131]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:40.131]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:40.131]                 ...future.rng), started = ...future.startTime, 
[16:01:40.131]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:40.131]             version = "1.8"), class = "FutureResult")
[16:01:40.131]     }, finally = {
[16:01:40.131]         if (!identical(...future.workdir, getwd())) 
[16:01:40.131]             setwd(...future.workdir)
[16:01:40.131]         {
[16:01:40.131]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:40.131]                 ...future.oldOptions$nwarnings <- NULL
[16:01:40.131]             }
[16:01:40.131]             base::options(...future.oldOptions)
[16:01:40.131]             if (.Platform$OS.type == "windows") {
[16:01:40.131]                 old_names <- names(...future.oldEnvVars)
[16:01:40.131]                 envs <- base::Sys.getenv()
[16:01:40.131]                 names <- names(envs)
[16:01:40.131]                 common <- intersect(names, old_names)
[16:01:40.131]                 added <- setdiff(names, old_names)
[16:01:40.131]                 removed <- setdiff(old_names, names)
[16:01:40.131]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:40.131]                   envs[common]]
[16:01:40.131]                 NAMES <- toupper(changed)
[16:01:40.131]                 args <- list()
[16:01:40.131]                 for (kk in seq_along(NAMES)) {
[16:01:40.131]                   name <- changed[[kk]]
[16:01:40.131]                   NAME <- NAMES[[kk]]
[16:01:40.131]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.131]                     next
[16:01:40.131]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:40.131]                 }
[16:01:40.131]                 NAMES <- toupper(added)
[16:01:40.131]                 for (kk in seq_along(NAMES)) {
[16:01:40.131]                   name <- added[[kk]]
[16:01:40.131]                   NAME <- NAMES[[kk]]
[16:01:40.131]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.131]                     next
[16:01:40.131]                   args[[name]] <- ""
[16:01:40.131]                 }
[16:01:40.131]                 NAMES <- toupper(removed)
[16:01:40.131]                 for (kk in seq_along(NAMES)) {
[16:01:40.131]                   name <- removed[[kk]]
[16:01:40.131]                   NAME <- NAMES[[kk]]
[16:01:40.131]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.131]                     next
[16:01:40.131]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:40.131]                 }
[16:01:40.131]                 if (length(args) > 0) 
[16:01:40.131]                   base::do.call(base::Sys.setenv, args = args)
[16:01:40.131]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:40.131]             }
[16:01:40.131]             else {
[16:01:40.131]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:40.131]             }
[16:01:40.131]             {
[16:01:40.131]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:40.131]                   0L) {
[16:01:40.131]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:40.131]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:40.131]                   base::options(opts)
[16:01:40.131]                 }
[16:01:40.131]                 {
[16:01:40.131]                   {
[16:01:40.131]                     NULL
[16:01:40.131]                     RNGkind("Mersenne-Twister")
[16:01:40.131]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:40.131]                       inherits = FALSE)
[16:01:40.131]                   }
[16:01:40.131]                   options(future.plan = NULL)
[16:01:40.131]                   if (is.na(NA_character_)) 
[16:01:40.131]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:40.131]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:40.131]                   future::plan(list(function (..., envir = parent.frame()) 
[16:01:40.131]                   {
[16:01:40.131]                     future <- SequentialFuture(..., envir = envir)
[16:01:40.131]                     if (!future$lazy) 
[16:01:40.131]                       future <- run(future)
[16:01:40.131]                     invisible(future)
[16:01:40.131]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:40.131]                 }
[16:01:40.131]             }
[16:01:40.131]         }
[16:01:40.131]     })
[16:01:40.131]     if (TRUE) {
[16:01:40.131]         base::sink(type = "output", split = FALSE)
[16:01:40.131]         if (TRUE) {
[16:01:40.131]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:40.131]         }
[16:01:40.131]         else {
[16:01:40.131]             ...future.result["stdout"] <- base::list(NULL)
[16:01:40.131]         }
[16:01:40.131]         base::close(...future.stdout)
[16:01:40.131]         ...future.stdout <- NULL
[16:01:40.131]     }
[16:01:40.131]     ...future.result$conditions <- ...future.conditions
[16:01:40.131]     ...future.result$finished <- base::Sys.time()
[16:01:40.131]     ...future.result
[16:01:40.131] }
[16:01:40.133] assign_globals() ...
[16:01:40.133] List of 5
[16:01:40.133]  $ future.call.arguments    : list()
[16:01:40.133]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.133]  $ ...future.FUN            :function (x)  
[16:01:40.133]  $ ...future.elements_ii    :List of 6
[16:01:40.133]   ..$ : int [1:4] 1 7 13 19
[16:01:40.133]   ..$ : int [1:4] 2 8 14 20
[16:01:40.133]   ..$ : int [1:4] 3 9 15 21
[16:01:40.133]   ..$ : int [1:4] 4 10 16 22
[16:01:40.133]   ..$ : int [1:4] 5 11 17 23
[16:01:40.133]   ..$ : int [1:4] 6 12 18 24
[16:01:40.133]  $ ...future.seeds_ii       : NULL
[16:01:40.133]  $ ...future.globals.maxSize: num Inf
[16:01:40.133]  - attr(*, "resolved")= logi FALSE
[16:01:40.133]  - attr(*, "total_size")= num NA
[16:01:40.133]  - attr(*, "where")=List of 5
[16:01:40.133]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:40.133]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:40.133]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:40.133]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:40.133]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:40.133]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.133]  - attr(*, "already-done")= logi TRUE
[16:01:40.139] - copied ‘future.call.arguments’ to environment
[16:01:40.139] - reassign environment for ‘...future.FUN’
[16:01:40.139] - copied ‘...future.FUN’ to environment
[16:01:40.139] - copied ‘...future.elements_ii’ to environment
[16:01:40.139] - copied ‘...future.seeds_ii’ to environment
[16:01:40.139] - copied ‘...future.globals.maxSize’ to environment
[16:01:40.139] assign_globals() ... done
[16:01:40.140] plan(): Setting new future strategy stack:
[16:01:40.140] List of future strategies:
[16:01:40.140] 1. sequential:
[16:01:40.140]    - args: function (..., envir = parent.frame())
[16:01:40.140]    - tweaked: FALSE
[16:01:40.140]    - call: NULL
[16:01:40.140] plan(): nbrOfWorkers() = 1
[16:01:40.141] plan(): Setting new future strategy stack:
[16:01:40.141] List of future strategies:
[16:01:40.141] 1. sequential:
[16:01:40.141]    - args: function (..., envir = parent.frame())
[16:01:40.141]    - tweaked: FALSE
[16:01:40.141]    - call: plan(strategy)
[16:01:40.141] plan(): nbrOfWorkers() = 1
[16:01:40.141] SequentialFuture started (and completed)
[16:01:40.142] - Launch lazy future ... done
[16:01:40.142] run() for ‘SequentialFuture’ ... done
[16:01:40.142] Created future:
[16:01:40.168] SequentialFuture:
[16:01:40.168] Label: ‘future_apply-1’
[16:01:40.168] Expression:
[16:01:40.168] {
[16:01:40.168]     do.call(function(...) {
[16:01:40.168]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.168]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.168]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.168]             on.exit(options(oopts), add = TRUE)
[16:01:40.168]         }
[16:01:40.168]         {
[16:01:40.168]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.168]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.168]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.168]             })
[16:01:40.168]         }
[16:01:40.168]     }, args = future.call.arguments)
[16:01:40.168] }
[16:01:40.168] Lazy evaluation: FALSE
[16:01:40.168] Asynchronous evaluation: FALSE
[16:01:40.168] Local evaluation: TRUE
[16:01:40.168] Environment: R_GlobalEnv
[16:01:40.168] Capture standard output: TRUE
[16:01:40.168] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:40.168] Globals: 5 objects totaling 2.16 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 384 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:40.168] Packages: <none>
[16:01:40.168] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:40.168] Resolved: TRUE
[16:01:40.168] Value: 1.03 KiB of class ‘list’
[16:01:40.168] Early signaling: FALSE
[16:01:40.168] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:40.168] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:40.170] Chunk #1 of 1 ... DONE
[16:01:40.170] Launching 1 futures (chunks) ... DONE
[16:01:40.170] Resolving 1 futures (chunks) ...
[16:01:40.170] resolve() on list ...
[16:01:40.170]  recursive: 0
[16:01:40.170]  length: 1
[16:01:40.170] 
[16:01:40.171] resolved() for ‘SequentialFuture’ ...
[16:01:40.171] - state: ‘finished’
[16:01:40.171] - run: TRUE
[16:01:40.171] - result: ‘FutureResult’
[16:01:40.171] resolved() for ‘SequentialFuture’ ... done
[16:01:40.171] Future #1
[16:01:40.171] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:40.171] - nx: 1
[16:01:40.172] - relay: TRUE
[16:01:40.172] - stdout: TRUE
[16:01:40.172] - signal: TRUE
[16:01:40.172] - resignal: FALSE
[16:01:40.172] - force: TRUE
[16:01:40.172] - relayed: [n=1] FALSE
[16:01:40.172] - queued futures: [n=1] FALSE
[16:01:40.172]  - until=1
[16:01:40.172]  - relaying element #1
[16:01:40.172] - relayed: [n=1] TRUE
[16:01:40.172] - queued futures: [n=1] TRUE
[16:01:40.173] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:40.173]  length: 0 (resolved future 1)
[16:01:40.173] Relaying remaining futures
[16:01:40.173] signalConditionsASAP(NULL, pos=0) ...
[16:01:40.173] - nx: 1
[16:01:40.173] - relay: TRUE
[16:01:40.173] - stdout: TRUE
[16:01:40.173] - signal: TRUE
[16:01:40.173] - resignal: FALSE
[16:01:40.173] - force: TRUE
[16:01:40.173] - relayed: [n=1] TRUE
[16:01:40.173] - queued futures: [n=1] TRUE
 - flush all
[16:01:40.174] - relayed: [n=1] TRUE
[16:01:40.174] - queued futures: [n=1] TRUE
[16:01:40.174] signalConditionsASAP(NULL, pos=0) ... done
[16:01:40.174] resolve() on list ... DONE
[16:01:40.174]  - Number of value chunks collected: 1
[16:01:40.174] Resolving 1 futures (chunks) ... DONE
[16:01:40.174] Reducing values from 1 chunks ...
[16:01:40.174]  - Number of values collected after concatenation: 6
[16:01:40.174]  - Number of values expected: 6
[16:01:40.174] Reducing values from 1 chunks ... DONE
[16:01:40.175] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[16:01:40.175] getGlobalsAndPackagesXApply() ...
[16:01:40.175]  - future.globals: TRUE
[16:01:40.175] getGlobalsAndPackages() ...
[16:01:40.175] Searching for globals...
[16:01:40.176] - globals found: [1] ‘FUN’
[16:01:40.176] Searching for globals ... DONE
[16:01:40.176] Resolving globals: FALSE
[16:01:40.177] The total size of the 1 globals is 848 bytes (848 bytes)
[16:01:40.177] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:01:40.177] - globals: [1] ‘FUN’
[16:01:40.177] 
[16:01:40.177] getGlobalsAndPackages() ... DONE
[16:01:40.177]  - globals found/used: [n=1] ‘FUN’
[16:01:40.178]  - needed namespaces: [n=0] 
[16:01:40.178] Finding globals ... DONE
[16:01:40.178]  - use_args: TRUE
[16:01:40.178]  - Getting '...' globals ...
[16:01:40.178] resolve() on list ...
[16:01:40.178]  recursive: 0
[16:01:40.178]  length: 1
[16:01:40.178]  elements: ‘...’
[16:01:40.179]  length: 0 (resolved future 1)
[16:01:40.179] resolve() on list ... DONE
[16:01:40.179]    - '...' content: [n=0] 
[16:01:40.179] List of 1
[16:01:40.179]  $ ...: list()
[16:01:40.179]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.179]  - attr(*, "where")=List of 1
[16:01:40.179]   ..$ ...:<environment: 0x55fb62856fa8> 
[16:01:40.179]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.179]  - attr(*, "resolved")= logi TRUE
[16:01:40.179]  - attr(*, "total_size")= num NA
[16:01:40.181]  - Getting '...' globals ... DONE
[16:01:40.182] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:40.182] List of 2
[16:01:40.182]  $ ...future.FUN:function (x)  
[16:01:40.182]  $ ...          : list()
[16:01:40.182]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.182]  - attr(*, "where")=List of 2
[16:01:40.182]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:40.182]   ..$ ...          :<environment: 0x55fb62856fa8> 
[16:01:40.182]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.182]  - attr(*, "resolved")= logi FALSE
[16:01:40.182]  - attr(*, "total_size")= num 848
[16:01:40.184] Packages to be attached in all futures: [n=0] 
[16:01:40.184] getGlobalsAndPackagesXApply() ... DONE
[16:01:40.185] future_lapply() ...
[16:01:40.185] Number of chunks: 1
[16:01:40.185] getGlobalsAndPackagesXApply() ...
[16:01:40.185]  - future.globals: <name-value list> with names ‘list()’
[16:01:40.185]  - use_args: TRUE
[16:01:40.186] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:01:40.186] List of 2
[16:01:40.186]  $ ...          : list()
[16:01:40.186]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.186]  $ ...future.FUN:function (x)  
[16:01:40.186]  - attr(*, "where")=List of 2
[16:01:40.186]   ..$ ...          :<environment: 0x55fb62856fa8> 
[16:01:40.186]   ..$ ...future.FUN:<environment: namespace:base> 
[16:01:40.186]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.186]  - attr(*, "resolved")= logi FALSE
[16:01:40.186]  - attr(*, "total_size")= num NA
[16:01:40.189] Packages to be attached in all futures: [n=0] 
[16:01:40.189] getGlobalsAndPackagesXApply() ... DONE
[16:01:40.189] Number of futures (= number of chunks): 1
[16:01:40.189] Launching 1 futures (chunks) ...
[16:01:40.190] Chunk #1 of 1 ...
[16:01:40.190]  - seeds: <none>
[16:01:40.190]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.190] getGlobalsAndPackages() ...
[16:01:40.190] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.190] Resolving globals: FALSE
[16:01:40.190] Tweak future expression to call with '...' arguments ...
[16:01:40.190] {
[16:01:40.190]     do.call(function(...) {
[16:01:40.190]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.190]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.190]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.190]             on.exit(options(oopts), add = TRUE)
[16:01:40.190]         }
[16:01:40.190]         {
[16:01:40.190]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.190]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.190]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.190]             })
[16:01:40.190]         }
[16:01:40.190]     }, args = future.call.arguments)
[16:01:40.190] }
[16:01:40.191] Tweak future expression to call with '...' arguments ... DONE
[16:01:40.191] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.191] 
[16:01:40.191] getGlobalsAndPackages() ... DONE
[16:01:40.192] run() for ‘Future’ ...
[16:01:40.192] - state: ‘created’
[16:01:40.192] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:01:40.192] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:40.193] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:40.193]   - Field: ‘label’
[16:01:40.194]   - Field: ‘local’
[16:01:40.194]   - Field: ‘owner’
[16:01:40.194]   - Field: ‘envir’
[16:01:40.194]   - Field: ‘packages’
[16:01:40.194]   - Field: ‘gc’
[16:01:40.194]   - Field: ‘conditions’
[16:01:40.194]   - Field: ‘expr’
[16:01:40.194]   - Field: ‘uuid’
[16:01:40.194]   - Field: ‘seed’
[16:01:40.195]   - Field: ‘version’
[16:01:40.195]   - Field: ‘result’
[16:01:40.195]   - Field: ‘asynchronous’
[16:01:40.195]   - Field: ‘calls’
[16:01:40.195]   - Field: ‘globals’
[16:01:40.195]   - Field: ‘stdout’
[16:01:40.195]   - Field: ‘earlySignal’
[16:01:40.195]   - Field: ‘lazy’
[16:01:40.195]   - Field: ‘state’
[16:01:40.196] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:40.196] - Launch lazy future ...
[16:01:40.196] Packages needed by the future expression (n = 0): <none>
[16:01:40.196] Packages needed by future strategies (n = 0): <none>
[16:01:40.196] {
[16:01:40.196]     {
[16:01:40.196]         {
[16:01:40.196]             ...future.startTime <- base::Sys.time()
[16:01:40.196]             {
[16:01:40.196]                 {
[16:01:40.196]                   {
[16:01:40.196]                     base::local({
[16:01:40.196]                       has_future <- base::requireNamespace("future", 
[16:01:40.196]                         quietly = TRUE)
[16:01:40.196]                       if (has_future) {
[16:01:40.196]                         ns <- base::getNamespace("future")
[16:01:40.196]                         version <- ns[[".package"]][["version"]]
[16:01:40.196]                         if (is.null(version)) 
[16:01:40.196]                           version <- utils::packageVersion("future")
[16:01:40.196]                       }
[16:01:40.196]                       else {
[16:01:40.196]                         version <- NULL
[16:01:40.196]                       }
[16:01:40.196]                       if (!has_future || version < "1.8.0") {
[16:01:40.196]                         info <- base::c(r_version = base::gsub("R version ", 
[16:01:40.196]                           "", base::R.version$version.string), 
[16:01:40.196]                           platform = base::sprintf("%s (%s-bit)", 
[16:01:40.196]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:40.196]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:40.196]                             "release", "version")], collapse = " "), 
[16:01:40.196]                           hostname = base::Sys.info()[["nodename"]])
[16:01:40.196]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:01:40.196]                           info)
[16:01:40.196]                         info <- base::paste(info, collapse = "; ")
[16:01:40.196]                         if (!has_future) {
[16:01:40.196]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:40.196]                             info)
[16:01:40.196]                         }
[16:01:40.196]                         else {
[16:01:40.196]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:40.196]                             info, version)
[16:01:40.196]                         }
[16:01:40.196]                         base::stop(msg)
[16:01:40.196]                       }
[16:01:40.196]                     })
[16:01:40.196]                   }
[16:01:40.196]                   options(future.plan = NULL)
[16:01:40.196]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:40.196]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:40.196]                 }
[16:01:40.196]                 ...future.workdir <- getwd()
[16:01:40.196]             }
[16:01:40.196]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:40.196]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:40.196]         }
[16:01:40.196]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:40.196]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:40.196]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:40.196]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:40.196]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:40.196]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:40.196]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:40.196]             base::names(...future.oldOptions))
[16:01:40.196]     }
[16:01:40.196]     if (FALSE) {
[16:01:40.196]     }
[16:01:40.196]     else {
[16:01:40.196]         if (TRUE) {
[16:01:40.196]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:40.196]                 open = "w")
[16:01:40.196]         }
[16:01:40.196]         else {
[16:01:40.196]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:40.196]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:40.196]         }
[16:01:40.196]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:40.196]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:40.196]             base::sink(type = "output", split = FALSE)
[16:01:40.196]             base::close(...future.stdout)
[16:01:40.196]         }, add = TRUE)
[16:01:40.196]     }
[16:01:40.196]     ...future.frame <- base::sys.nframe()
[16:01:40.196]     ...future.conditions <- base::list()
[16:01:40.196]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:40.196]     if (FALSE) {
[16:01:40.196]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:40.196]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:40.196]     }
[16:01:40.196]     ...future.result <- base::tryCatch({
[16:01:40.196]         base::withCallingHandlers({
[16:01:40.196]             ...future.value <- base::withVisible(base::local({
[16:01:40.196]                 do.call(function(...) {
[16:01:40.196]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.196]                   if (!identical(...future.globals.maxSize.org, 
[16:01:40.196]                     ...future.globals.maxSize)) {
[16:01:40.196]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.196]                     on.exit(options(oopts), add = TRUE)
[16:01:40.196]                   }
[16:01:40.196]                   {
[16:01:40.196]                     lapply(seq_along(...future.elements_ii), 
[16:01:40.196]                       FUN = function(jj) {
[16:01:40.196]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.196]                         ...future.FUN(...future.X_jj, ...)
[16:01:40.196]                       })
[16:01:40.196]                   }
[16:01:40.196]                 }, args = future.call.arguments)
[16:01:40.196]             }))
[16:01:40.196]             future::FutureResult(value = ...future.value$value, 
[16:01:40.196]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:40.196]                   ...future.rng), globalenv = if (FALSE) 
[16:01:40.196]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:40.196]                     ...future.globalenv.names))
[16:01:40.196]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:40.196]         }, condition = base::local({
[16:01:40.196]             c <- base::c
[16:01:40.196]             inherits <- base::inherits
[16:01:40.196]             invokeRestart <- base::invokeRestart
[16:01:40.196]             length <- base::length
[16:01:40.196]             list <- base::list
[16:01:40.196]             seq.int <- base::seq.int
[16:01:40.196]             signalCondition <- base::signalCondition
[16:01:40.196]             sys.calls <- base::sys.calls
[16:01:40.196]             `[[` <- base::`[[`
[16:01:40.196]             `+` <- base::`+`
[16:01:40.196]             `<<-` <- base::`<<-`
[16:01:40.196]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:40.196]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:40.196]                   3L)]
[16:01:40.196]             }
[16:01:40.196]             function(cond) {
[16:01:40.196]                 is_error <- inherits(cond, "error")
[16:01:40.196]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:40.196]                   NULL)
[16:01:40.196]                 if (is_error) {
[16:01:40.196]                   sessionInformation <- function() {
[16:01:40.196]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:40.196]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:40.196]                       search = base::search(), system = base::Sys.info())
[16:01:40.196]                   }
[16:01:40.196]                   ...future.conditions[[length(...future.conditions) + 
[16:01:40.196]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:40.196]                     cond$call), session = sessionInformation(), 
[16:01:40.196]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:40.196]                   signalCondition(cond)
[16:01:40.196]                 }
[16:01:40.196]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:40.196]                 "immediateCondition"))) {
[16:01:40.196]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:40.196]                   ...future.conditions[[length(...future.conditions) + 
[16:01:40.196]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:40.196]                   if (TRUE && !signal) {
[16:01:40.196]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.196]                     {
[16:01:40.196]                       inherits <- base::inherits
[16:01:40.196]                       invokeRestart <- base::invokeRestart
[16:01:40.196]                       is.null <- base::is.null
[16:01:40.196]                       muffled <- FALSE
[16:01:40.196]                       if (inherits(cond, "message")) {
[16:01:40.196]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:40.196]                         if (muffled) 
[16:01:40.196]                           invokeRestart("muffleMessage")
[16:01:40.196]                       }
[16:01:40.196]                       else if (inherits(cond, "warning")) {
[16:01:40.196]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:40.196]                         if (muffled) 
[16:01:40.196]                           invokeRestart("muffleWarning")
[16:01:40.196]                       }
[16:01:40.196]                       else if (inherits(cond, "condition")) {
[16:01:40.196]                         if (!is.null(pattern)) {
[16:01:40.196]                           computeRestarts <- base::computeRestarts
[16:01:40.196]                           grepl <- base::grepl
[16:01:40.196]                           restarts <- computeRestarts(cond)
[16:01:40.196]                           for (restart in restarts) {
[16:01:40.196]                             name <- restart$name
[16:01:40.196]                             if (is.null(name)) 
[16:01:40.196]                               next
[16:01:40.196]                             if (!grepl(pattern, name)) 
[16:01:40.196]                               next
[16:01:40.196]                             invokeRestart(restart)
[16:01:40.196]                             muffled <- TRUE
[16:01:40.196]                             break
[16:01:40.196]                           }
[16:01:40.196]                         }
[16:01:40.196]                       }
[16:01:40.196]                       invisible(muffled)
[16:01:40.196]                     }
[16:01:40.196]                     muffleCondition(cond, pattern = "^muffle")
[16:01:40.196]                   }
[16:01:40.196]                 }
[16:01:40.196]                 else {
[16:01:40.196]                   if (TRUE) {
[16:01:40.196]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.196]                     {
[16:01:40.196]                       inherits <- base::inherits
[16:01:40.196]                       invokeRestart <- base::invokeRestart
[16:01:40.196]                       is.null <- base::is.null
[16:01:40.196]                       muffled <- FALSE
[16:01:40.196]                       if (inherits(cond, "message")) {
[16:01:40.196]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:40.196]                         if (muffled) 
[16:01:40.196]                           invokeRestart("muffleMessage")
[16:01:40.196]                       }
[16:01:40.196]                       else if (inherits(cond, "warning")) {
[16:01:40.196]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:40.196]                         if (muffled) 
[16:01:40.196]                           invokeRestart("muffleWarning")
[16:01:40.196]                       }
[16:01:40.196]                       else if (inherits(cond, "condition")) {
[16:01:40.196]                         if (!is.null(pattern)) {
[16:01:40.196]                           computeRestarts <- base::computeRestarts
[16:01:40.196]                           grepl <- base::grepl
[16:01:40.196]                           restarts <- computeRestarts(cond)
[16:01:40.196]                           for (restart in restarts) {
[16:01:40.196]                             name <- restart$name
[16:01:40.196]                             if (is.null(name)) 
[16:01:40.196]                               next
[16:01:40.196]                             if (!grepl(pattern, name)) 
[16:01:40.196]                               next
[16:01:40.196]                             invokeRestart(restart)
[16:01:40.196]                             muffled <- TRUE
[16:01:40.196]                             break
[16:01:40.196]                           }
[16:01:40.196]                         }
[16:01:40.196]                       }
[16:01:40.196]                       invisible(muffled)
[16:01:40.196]                     }
[16:01:40.196]                     muffleCondition(cond, pattern = "^muffle")
[16:01:40.196]                   }
[16:01:40.196]                 }
[16:01:40.196]             }
[16:01:40.196]         }))
[16:01:40.196]     }, error = function(ex) {
[16:01:40.196]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:40.196]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:40.196]                 ...future.rng), started = ...future.startTime, 
[16:01:40.196]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:40.196]             version = "1.8"), class = "FutureResult")
[16:01:40.196]     }, finally = {
[16:01:40.196]         if (!identical(...future.workdir, getwd())) 
[16:01:40.196]             setwd(...future.workdir)
[16:01:40.196]         {
[16:01:40.196]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:40.196]                 ...future.oldOptions$nwarnings <- NULL
[16:01:40.196]             }
[16:01:40.196]             base::options(...future.oldOptions)
[16:01:40.196]             if (.Platform$OS.type == "windows") {
[16:01:40.196]                 old_names <- names(...future.oldEnvVars)
[16:01:40.196]                 envs <- base::Sys.getenv()
[16:01:40.196]                 names <- names(envs)
[16:01:40.196]                 common <- intersect(names, old_names)
[16:01:40.196]                 added <- setdiff(names, old_names)
[16:01:40.196]                 removed <- setdiff(old_names, names)
[16:01:40.196]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:40.196]                   envs[common]]
[16:01:40.196]                 NAMES <- toupper(changed)
[16:01:40.196]                 args <- list()
[16:01:40.196]                 for (kk in seq_along(NAMES)) {
[16:01:40.196]                   name <- changed[[kk]]
[16:01:40.196]                   NAME <- NAMES[[kk]]
[16:01:40.196]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.196]                     next
[16:01:40.196]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:40.196]                 }
[16:01:40.196]                 NAMES <- toupper(added)
[16:01:40.196]                 for (kk in seq_along(NAMES)) {
[16:01:40.196]                   name <- added[[kk]]
[16:01:40.196]                   NAME <- NAMES[[kk]]
[16:01:40.196]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.196]                     next
[16:01:40.196]                   args[[name]] <- ""
[16:01:40.196]                 }
[16:01:40.196]                 NAMES <- toupper(removed)
[16:01:40.196]                 for (kk in seq_along(NAMES)) {
[16:01:40.196]                   name <- removed[[kk]]
[16:01:40.196]                   NAME <- NAMES[[kk]]
[16:01:40.196]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.196]                     next
[16:01:40.196]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:40.196]                 }
[16:01:40.196]                 if (length(args) > 0) 
[16:01:40.196]                   base::do.call(base::Sys.setenv, args = args)
[16:01:40.196]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:40.196]             }
[16:01:40.196]             else {
[16:01:40.196]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:40.196]             }
[16:01:40.196]             {
[16:01:40.196]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:40.196]                   0L) {
[16:01:40.196]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:40.196]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:40.196]                   base::options(opts)
[16:01:40.196]                 }
[16:01:40.196]                 {
[16:01:40.196]                   {
[16:01:40.196]                     NULL
[16:01:40.196]                     RNGkind("Mersenne-Twister")
[16:01:40.196]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:40.196]                       inherits = FALSE)
[16:01:40.196]                   }
[16:01:40.196]                   options(future.plan = NULL)
[16:01:40.196]                   if (is.na(NA_character_)) 
[16:01:40.196]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:40.196]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:40.196]                   future::plan(list(function (..., envir = parent.frame()) 
[16:01:40.196]                   {
[16:01:40.196]                     future <- SequentialFuture(..., envir = envir)
[16:01:40.196]                     if (!future$lazy) 
[16:01:40.196]                       future <- run(future)
[16:01:40.196]                     invisible(future)
[16:01:40.196]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:40.196]                 }
[16:01:40.196]             }
[16:01:40.196]         }
[16:01:40.196]     })
[16:01:40.196]     if (TRUE) {
[16:01:40.196]         base::sink(type = "output", split = FALSE)
[16:01:40.196]         if (TRUE) {
[16:01:40.196]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:40.196]         }
[16:01:40.196]         else {
[16:01:40.196]             ...future.result["stdout"] <- base::list(NULL)
[16:01:40.196]         }
[16:01:40.196]         base::close(...future.stdout)
[16:01:40.196]         ...future.stdout <- NULL
[16:01:40.196]     }
[16:01:40.196]     ...future.result$conditions <- ...future.conditions
[16:01:40.196]     ...future.result$finished <- base::Sys.time()
[16:01:40.196]     ...future.result
[16:01:40.196] }
[16:01:40.198] assign_globals() ...
[16:01:40.198] List of 5
[16:01:40.198]  $ future.call.arguments    : list()
[16:01:40.198]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.198]  $ ...future.FUN            :function (x)  
[16:01:40.198]  $ ...future.elements_ii    :List of 2
[16:01:40.198]   ..$ : int 1
[16:01:40.198]   ..$ : int 2
[16:01:40.198]  $ ...future.seeds_ii       : NULL
[16:01:40.198]  $ ...future.globals.maxSize: num Inf
[16:01:40.198]  - attr(*, "resolved")= logi FALSE
[16:01:40.198]  - attr(*, "total_size")= num NA
[16:01:40.198]  - attr(*, "where")=List of 5
[16:01:40.198]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:40.198]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:40.198]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:40.198]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:40.198]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:40.198]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.198]  - attr(*, "already-done")= logi TRUE
[16:01:40.203] - copied ‘future.call.arguments’ to environment
[16:01:40.203] - copied ‘...future.FUN’ to environment
[16:01:40.203] - copied ‘...future.elements_ii’ to environment
[16:01:40.204] - copied ‘...future.seeds_ii’ to environment
[16:01:40.204] - copied ‘...future.globals.maxSize’ to environment
[16:01:40.204] assign_globals() ... done
[16:01:40.204] plan(): Setting new future strategy stack:
[16:01:40.204] List of future strategies:
[16:01:40.204] 1. sequential:
[16:01:40.204]    - args: function (..., envir = parent.frame())
[16:01:40.204]    - tweaked: FALSE
[16:01:40.204]    - call: NULL
[16:01:40.204] plan(): nbrOfWorkers() = 1
[16:01:40.205] plan(): Setting new future strategy stack:
[16:01:40.205] List of future strategies:
[16:01:40.205] 1. sequential:
[16:01:40.205]    - args: function (..., envir = parent.frame())
[16:01:40.205]    - tweaked: FALSE
[16:01:40.205]    - call: plan(strategy)
[16:01:40.206] plan(): nbrOfWorkers() = 1
[16:01:40.206] SequentialFuture started (and completed)
[16:01:40.206] - Launch lazy future ... done
[16:01:40.206] run() for ‘SequentialFuture’ ... done
[16:01:40.206] Created future:
[16:01:40.206] SequentialFuture:
[16:01:40.206] Label: ‘future_apply-1’
[16:01:40.206] Expression:
[16:01:40.206] {
[16:01:40.206]     do.call(function(...) {
[16:01:40.206]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.206]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.206]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.206]             on.exit(options(oopts), add = TRUE)
[16:01:40.206]         }
[16:01:40.206]         {
[16:01:40.206]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.206]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.206]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.206]             })
[16:01:40.206]         }
[16:01:40.206]     }, args = future.call.arguments)
[16:01:40.206] }
[16:01:40.206] Lazy evaluation: FALSE
[16:01:40.206] Asynchronous evaluation: FALSE
[16:01:40.206] Local evaluation: TRUE
[16:01:40.206] Environment: R_GlobalEnv
[16:01:40.206] Capture standard output: TRUE
[16:01:40.206] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:40.206] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:40.206] Packages: <none>
[16:01:40.206] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:40.206] Resolved: TRUE
[16:01:40.206] Value: 112 bytes of class ‘list’
[16:01:40.206] Early signaling: FALSE
[16:01:40.206] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:40.206] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:40.207] Chunk #1 of 1 ... DONE
[16:01:40.207] Launching 1 futures (chunks) ... DONE
[16:01:40.207] Resolving 1 futures (chunks) ...
[16:01:40.208] resolve() on list ...
[16:01:40.208]  recursive: 0
[16:01:40.208]  length: 1
[16:01:40.208] 
[16:01:40.208] resolved() for ‘SequentialFuture’ ...
[16:01:40.208] - state: ‘finished’
[16:01:40.208] - run: TRUE
[16:01:40.208] - result: ‘FutureResult’
[16:01:40.208] resolved() for ‘SequentialFuture’ ... done
[16:01:40.208] Future #1
[16:01:40.209] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:40.209] - nx: 1
[16:01:40.209] - relay: TRUE
[16:01:40.209] - stdout: TRUE
[16:01:40.209] - signal: TRUE
[16:01:40.209] - resignal: FALSE
[16:01:40.209] - force: TRUE
[16:01:40.209] - relayed: [n=1] FALSE
[16:01:40.209] - queued futures: [n=1] FALSE
[16:01:40.209]  - until=1
[16:01:40.209]  - relaying element #1
[16:01:40.210] - relayed: [n=1] TRUE
[16:01:40.210] - queued futures: [n=1] TRUE
[16:01:40.210] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:40.210]  length: 0 (resolved future 1)
[16:01:40.210] Relaying remaining futures
[16:01:40.210] signalConditionsASAP(NULL, pos=0) ...
[16:01:40.210] - nx: 1
[16:01:40.210] - relay: TRUE
[16:01:40.210] - stdout: TRUE
[16:01:40.210] - signal: TRUE
[16:01:40.210] - resignal: FALSE
[16:01:40.211] - force: TRUE
[16:01:40.211] - relayed: [n=1] TRUE
[16:01:40.211] - queued futures: [n=1] TRUE
 - flush all
[16:01:40.211] - relayed: [n=1] TRUE
[16:01:40.211] - queued futures: [n=1] TRUE
[16:01:40.211] signalConditionsASAP(NULL, pos=0) ... done
[16:01:40.211] resolve() on list ... DONE
[16:01:40.211]  - Number of value chunks collected: 1
[16:01:40.211] Resolving 1 futures (chunks) ... DONE
[16:01:40.211] Reducing values from 1 chunks ...
[16:01:40.212]  - Number of values collected after concatenation: 2
[16:01:40.212]  - Number of values expected: 2
[16:01:40.212] Reducing values from 1 chunks ... DONE
[16:01:40.212] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[16:01:40.212] getGlobalsAndPackagesXApply() ...
[16:01:40.212]  - future.globals: TRUE
[16:01:40.212] getGlobalsAndPackages() ...
[16:01:40.212] Searching for globals...
[16:01:40.213] - globals found: [1] ‘FUN’
[16:01:40.213] Searching for globals ... DONE
[16:01:40.214] Resolving globals: FALSE
[16:01:40.214] The total size of the 1 globals is 848 bytes (848 bytes)
[16:01:40.214] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:01:40.214] - globals: [1] ‘FUN’
[16:01:40.214] 
[16:01:40.214] getGlobalsAndPackages() ... DONE
[16:01:40.215]  - globals found/used: [n=1] ‘FUN’
[16:01:40.215]  - needed namespaces: [n=0] 
[16:01:40.215] Finding globals ... DONE
[16:01:40.215]  - use_args: TRUE
[16:01:40.215]  - Getting '...' globals ...
[16:01:40.215] resolve() on list ...
[16:01:40.215]  recursive: 0
[16:01:40.215]  length: 1
[16:01:40.215]  elements: ‘...’
[16:01:40.216]  length: 0 (resolved future 1)
[16:01:40.216] resolve() on list ... DONE
[16:01:40.216]    - '...' content: [n=0] 
[16:01:40.216] List of 1
[16:01:40.216]  $ ...: list()
[16:01:40.216]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.216]  - attr(*, "where")=List of 1
[16:01:40.216]   ..$ ...:<environment: 0x55fb6499afc0> 
[16:01:40.216]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.216]  - attr(*, "resolved")= logi TRUE
[16:01:40.216]  - attr(*, "total_size")= num NA
[16:01:40.220]  - Getting '...' globals ... DONE
[16:01:40.220] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:40.221] List of 2
[16:01:40.221]  $ ...future.FUN:function (x)  
[16:01:40.221]  $ ...          : list()
[16:01:40.221]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.221]  - attr(*, "where")=List of 2
[16:01:40.221]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:40.221]   ..$ ...          :<environment: 0x55fb6499afc0> 
[16:01:40.221]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.221]  - attr(*, "resolved")= logi FALSE
[16:01:40.221]  - attr(*, "total_size")= num 848
[16:01:40.223] Packages to be attached in all futures: [n=0] 
[16:01:40.223] getGlobalsAndPackagesXApply() ... DONE
[16:01:40.224] future_lapply() ...
[16:01:40.224] Number of chunks: 1
[16:01:40.224] getGlobalsAndPackagesXApply() ...
[16:01:40.224]  - future.globals: <name-value list> with names ‘list()’
[16:01:40.224]  - use_args: TRUE
[16:01:40.225] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:01:40.225] List of 2
[16:01:40.225]  $ ...          : list()
[16:01:40.225]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.225]  $ ...future.FUN:function (x)  
[16:01:40.225]  - attr(*, "where")=List of 2
[16:01:40.225]   ..$ ...          :<environment: 0x55fb6499afc0> 
[16:01:40.225]   ..$ ...future.FUN:<environment: namespace:base> 
[16:01:40.225]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.225]  - attr(*, "resolved")= logi FALSE
[16:01:40.225]  - attr(*, "total_size")= num NA
[16:01:40.228] Packages to be attached in all futures: [n=0] 
[16:01:40.228] getGlobalsAndPackagesXApply() ... DONE
[16:01:40.228] Number of futures (= number of chunks): 1
[16:01:40.228] Launching 1 futures (chunks) ...
[16:01:40.228] Chunk #1 of 1 ...
[16:01:40.229]  - seeds: <none>
[16:01:40.229]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.229] getGlobalsAndPackages() ...
[16:01:40.229] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.229] Resolving globals: FALSE
[16:01:40.229] Tweak future expression to call with '...' arguments ...
[16:01:40.229] {
[16:01:40.229]     do.call(function(...) {
[16:01:40.229]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.229]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.229]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.229]             on.exit(options(oopts), add = TRUE)
[16:01:40.229]         }
[16:01:40.229]         {
[16:01:40.229]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.229]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.229]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.229]             })
[16:01:40.229]         }
[16:01:40.229]     }, args = future.call.arguments)
[16:01:40.229] }
[16:01:40.229] Tweak future expression to call with '...' arguments ... DONE
[16:01:40.230] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.230] 
[16:01:40.230] getGlobalsAndPackages() ... DONE
[16:01:40.230] run() for ‘Future’ ...
[16:01:40.230] - state: ‘created’
[16:01:40.231] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:01:40.231] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:40.231] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:40.231]   - Field: ‘label’
[16:01:40.231]   - Field: ‘local’
[16:01:40.231]   - Field: ‘owner’
[16:01:40.231]   - Field: ‘envir’
[16:01:40.231]   - Field: ‘packages’
[16:01:40.232]   - Field: ‘gc’
[16:01:40.232]   - Field: ‘conditions’
[16:01:40.232]   - Field: ‘expr’
[16:01:40.232]   - Field: ‘uuid’
[16:01:40.232]   - Field: ‘seed’
[16:01:40.232]   - Field: ‘version’
[16:01:40.232]   - Field: ‘result’
[16:01:40.232]   - Field: ‘asynchronous’
[16:01:40.232]   - Field: ‘calls’
[16:01:40.232]   - Field: ‘globals’
[16:01:40.232]   - Field: ‘stdout’
[16:01:40.233]   - Field: ‘earlySignal’
[16:01:40.233]   - Field: ‘lazy’
[16:01:40.233]   - Field: ‘state’
[16:01:40.233] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:40.233] - Launch lazy future ...
[16:01:40.233] Packages needed by the future expression (n = 0): <none>
[16:01:40.233] Packages needed by future strategies (n = 0): <none>
[16:01:40.234] {
[16:01:40.234]     {
[16:01:40.234]         {
[16:01:40.234]             ...future.startTime <- base::Sys.time()
[16:01:40.234]             {
[16:01:40.234]                 {
[16:01:40.234]                   {
[16:01:40.234]                     base::local({
[16:01:40.234]                       has_future <- base::requireNamespace("future", 
[16:01:40.234]                         quietly = TRUE)
[16:01:40.234]                       if (has_future) {
[16:01:40.234]                         ns <- base::getNamespace("future")
[16:01:40.234]                         version <- ns[[".package"]][["version"]]
[16:01:40.234]                         if (is.null(version)) 
[16:01:40.234]                           version <- utils::packageVersion("future")
[16:01:40.234]                       }
[16:01:40.234]                       else {
[16:01:40.234]                         version <- NULL
[16:01:40.234]                       }
[16:01:40.234]                       if (!has_future || version < "1.8.0") {
[16:01:40.234]                         info <- base::c(r_version = base::gsub("R version ", 
[16:01:40.234]                           "", base::R.version$version.string), 
[16:01:40.234]                           platform = base::sprintf("%s (%s-bit)", 
[16:01:40.234]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:40.234]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:40.234]                             "release", "version")], collapse = " "), 
[16:01:40.234]                           hostname = base::Sys.info()[["nodename"]])
[16:01:40.234]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:01:40.234]                           info)
[16:01:40.234]                         info <- base::paste(info, collapse = "; ")
[16:01:40.234]                         if (!has_future) {
[16:01:40.234]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:40.234]                             info)
[16:01:40.234]                         }
[16:01:40.234]                         else {
[16:01:40.234]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:40.234]                             info, version)
[16:01:40.234]                         }
[16:01:40.234]                         base::stop(msg)
[16:01:40.234]                       }
[16:01:40.234]                     })
[16:01:40.234]                   }
[16:01:40.234]                   options(future.plan = NULL)
[16:01:40.234]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:40.234]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:40.234]                 }
[16:01:40.234]                 ...future.workdir <- getwd()
[16:01:40.234]             }
[16:01:40.234]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:40.234]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:40.234]         }
[16:01:40.234]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:40.234]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:40.234]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:40.234]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:40.234]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:40.234]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:40.234]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:40.234]             base::names(...future.oldOptions))
[16:01:40.234]     }
[16:01:40.234]     if (FALSE) {
[16:01:40.234]     }
[16:01:40.234]     else {
[16:01:40.234]         if (TRUE) {
[16:01:40.234]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:40.234]                 open = "w")
[16:01:40.234]         }
[16:01:40.234]         else {
[16:01:40.234]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:40.234]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:40.234]         }
[16:01:40.234]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:40.234]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:40.234]             base::sink(type = "output", split = FALSE)
[16:01:40.234]             base::close(...future.stdout)
[16:01:40.234]         }, add = TRUE)
[16:01:40.234]     }
[16:01:40.234]     ...future.frame <- base::sys.nframe()
[16:01:40.234]     ...future.conditions <- base::list()
[16:01:40.234]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:40.234]     if (FALSE) {
[16:01:40.234]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:40.234]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:40.234]     }
[16:01:40.234]     ...future.result <- base::tryCatch({
[16:01:40.234]         base::withCallingHandlers({
[16:01:40.234]             ...future.value <- base::withVisible(base::local({
[16:01:40.234]                 do.call(function(...) {
[16:01:40.234]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.234]                   if (!identical(...future.globals.maxSize.org, 
[16:01:40.234]                     ...future.globals.maxSize)) {
[16:01:40.234]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.234]                     on.exit(options(oopts), add = TRUE)
[16:01:40.234]                   }
[16:01:40.234]                   {
[16:01:40.234]                     lapply(seq_along(...future.elements_ii), 
[16:01:40.234]                       FUN = function(jj) {
[16:01:40.234]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.234]                         ...future.FUN(...future.X_jj, ...)
[16:01:40.234]                       })
[16:01:40.234]                   }
[16:01:40.234]                 }, args = future.call.arguments)
[16:01:40.234]             }))
[16:01:40.234]             future::FutureResult(value = ...future.value$value, 
[16:01:40.234]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:40.234]                   ...future.rng), globalenv = if (FALSE) 
[16:01:40.234]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:40.234]                     ...future.globalenv.names))
[16:01:40.234]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:40.234]         }, condition = base::local({
[16:01:40.234]             c <- base::c
[16:01:40.234]             inherits <- base::inherits
[16:01:40.234]             invokeRestart <- base::invokeRestart
[16:01:40.234]             length <- base::length
[16:01:40.234]             list <- base::list
[16:01:40.234]             seq.int <- base::seq.int
[16:01:40.234]             signalCondition <- base::signalCondition
[16:01:40.234]             sys.calls <- base::sys.calls
[16:01:40.234]             `[[` <- base::`[[`
[16:01:40.234]             `+` <- base::`+`
[16:01:40.234]             `<<-` <- base::`<<-`
[16:01:40.234]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:40.234]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:40.234]                   3L)]
[16:01:40.234]             }
[16:01:40.234]             function(cond) {
[16:01:40.234]                 is_error <- inherits(cond, "error")
[16:01:40.234]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:40.234]                   NULL)
[16:01:40.234]                 if (is_error) {
[16:01:40.234]                   sessionInformation <- function() {
[16:01:40.234]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:40.234]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:40.234]                       search = base::search(), system = base::Sys.info())
[16:01:40.234]                   }
[16:01:40.234]                   ...future.conditions[[length(...future.conditions) + 
[16:01:40.234]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:40.234]                     cond$call), session = sessionInformation(), 
[16:01:40.234]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:40.234]                   signalCondition(cond)
[16:01:40.234]                 }
[16:01:40.234]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:40.234]                 "immediateCondition"))) {
[16:01:40.234]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:40.234]                   ...future.conditions[[length(...future.conditions) + 
[16:01:40.234]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:40.234]                   if (TRUE && !signal) {
[16:01:40.234]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.234]                     {
[16:01:40.234]                       inherits <- base::inherits
[16:01:40.234]                       invokeRestart <- base::invokeRestart
[16:01:40.234]                       is.null <- base::is.null
[16:01:40.234]                       muffled <- FALSE
[16:01:40.234]                       if (inherits(cond, "message")) {
[16:01:40.234]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:40.234]                         if (muffled) 
[16:01:40.234]                           invokeRestart("muffleMessage")
[16:01:40.234]                       }
[16:01:40.234]                       else if (inherits(cond, "warning")) {
[16:01:40.234]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:40.234]                         if (muffled) 
[16:01:40.234]                           invokeRestart("muffleWarning")
[16:01:40.234]                       }
[16:01:40.234]                       else if (inherits(cond, "condition")) {
[16:01:40.234]                         if (!is.null(pattern)) {
[16:01:40.234]                           computeRestarts <- base::computeRestarts
[16:01:40.234]                           grepl <- base::grepl
[16:01:40.234]                           restarts <- computeRestarts(cond)
[16:01:40.234]                           for (restart in restarts) {
[16:01:40.234]                             name <- restart$name
[16:01:40.234]                             if (is.null(name)) 
[16:01:40.234]                               next
[16:01:40.234]                             if (!grepl(pattern, name)) 
[16:01:40.234]                               next
[16:01:40.234]                             invokeRestart(restart)
[16:01:40.234]                             muffled <- TRUE
[16:01:40.234]                             break
[16:01:40.234]                           }
[16:01:40.234]                         }
[16:01:40.234]                       }
[16:01:40.234]                       invisible(muffled)
[16:01:40.234]                     }
[16:01:40.234]                     muffleCondition(cond, pattern = "^muffle")
[16:01:40.234]                   }
[16:01:40.234]                 }
[16:01:40.234]                 else {
[16:01:40.234]                   if (TRUE) {
[16:01:40.234]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.234]                     {
[16:01:40.234]                       inherits <- base::inherits
[16:01:40.234]                       invokeRestart <- base::invokeRestart
[16:01:40.234]                       is.null <- base::is.null
[16:01:40.234]                       muffled <- FALSE
[16:01:40.234]                       if (inherits(cond, "message")) {
[16:01:40.234]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:40.234]                         if (muffled) 
[16:01:40.234]                           invokeRestart("muffleMessage")
[16:01:40.234]                       }
[16:01:40.234]                       else if (inherits(cond, "warning")) {
[16:01:40.234]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:40.234]                         if (muffled) 
[16:01:40.234]                           invokeRestart("muffleWarning")
[16:01:40.234]                       }
[16:01:40.234]                       else if (inherits(cond, "condition")) {
[16:01:40.234]                         if (!is.null(pattern)) {
[16:01:40.234]                           computeRestarts <- base::computeRestarts
[16:01:40.234]                           grepl <- base::grepl
[16:01:40.234]                           restarts <- computeRestarts(cond)
[16:01:40.234]                           for (restart in restarts) {
[16:01:40.234]                             name <- restart$name
[16:01:40.234]                             if (is.null(name)) 
[16:01:40.234]                               next
[16:01:40.234]                             if (!grepl(pattern, name)) 
[16:01:40.234]                               next
[16:01:40.234]                             invokeRestart(restart)
[16:01:40.234]                             muffled <- TRUE
[16:01:40.234]                             break
[16:01:40.234]                           }
[16:01:40.234]                         }
[16:01:40.234]                       }
[16:01:40.234]                       invisible(muffled)
[16:01:40.234]                     }
[16:01:40.234]                     muffleCondition(cond, pattern = "^muffle")
[16:01:40.234]                   }
[16:01:40.234]                 }
[16:01:40.234]             }
[16:01:40.234]         }))
[16:01:40.234]     }, error = function(ex) {
[16:01:40.234]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:40.234]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:40.234]                 ...future.rng), started = ...future.startTime, 
[16:01:40.234]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:40.234]             version = "1.8"), class = "FutureResult")
[16:01:40.234]     }, finally = {
[16:01:40.234]         if (!identical(...future.workdir, getwd())) 
[16:01:40.234]             setwd(...future.workdir)
[16:01:40.234]         {
[16:01:40.234]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:40.234]                 ...future.oldOptions$nwarnings <- NULL
[16:01:40.234]             }
[16:01:40.234]             base::options(...future.oldOptions)
[16:01:40.234]             if (.Platform$OS.type == "windows") {
[16:01:40.234]                 old_names <- names(...future.oldEnvVars)
[16:01:40.234]                 envs <- base::Sys.getenv()
[16:01:40.234]                 names <- names(envs)
[16:01:40.234]                 common <- intersect(names, old_names)
[16:01:40.234]                 added <- setdiff(names, old_names)
[16:01:40.234]                 removed <- setdiff(old_names, names)
[16:01:40.234]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:40.234]                   envs[common]]
[16:01:40.234]                 NAMES <- toupper(changed)
[16:01:40.234]                 args <- list()
[16:01:40.234]                 for (kk in seq_along(NAMES)) {
[16:01:40.234]                   name <- changed[[kk]]
[16:01:40.234]                   NAME <- NAMES[[kk]]
[16:01:40.234]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.234]                     next
[16:01:40.234]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:40.234]                 }
[16:01:40.234]                 NAMES <- toupper(added)
[16:01:40.234]                 for (kk in seq_along(NAMES)) {
[16:01:40.234]                   name <- added[[kk]]
[16:01:40.234]                   NAME <- NAMES[[kk]]
[16:01:40.234]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.234]                     next
[16:01:40.234]                   args[[name]] <- ""
[16:01:40.234]                 }
[16:01:40.234]                 NAMES <- toupper(removed)
[16:01:40.234]                 for (kk in seq_along(NAMES)) {
[16:01:40.234]                   name <- removed[[kk]]
[16:01:40.234]                   NAME <- NAMES[[kk]]
[16:01:40.234]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.234]                     next
[16:01:40.234]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:40.234]                 }
[16:01:40.234]                 if (length(args) > 0) 
[16:01:40.234]                   base::do.call(base::Sys.setenv, args = args)
[16:01:40.234]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:40.234]             }
[16:01:40.234]             else {
[16:01:40.234]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:40.234]             }
[16:01:40.234]             {
[16:01:40.234]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:40.234]                   0L) {
[16:01:40.234]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:40.234]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:40.234]                   base::options(opts)
[16:01:40.234]                 }
[16:01:40.234]                 {
[16:01:40.234]                   {
[16:01:40.234]                     NULL
[16:01:40.234]                     RNGkind("Mersenne-Twister")
[16:01:40.234]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:40.234]                       inherits = FALSE)
[16:01:40.234]                   }
[16:01:40.234]                   options(future.plan = NULL)
[16:01:40.234]                   if (is.na(NA_character_)) 
[16:01:40.234]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:40.234]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:40.234]                   future::plan(list(function (..., envir = parent.frame()) 
[16:01:40.234]                   {
[16:01:40.234]                     future <- SequentialFuture(..., envir = envir)
[16:01:40.234]                     if (!future$lazy) 
[16:01:40.234]                       future <- run(future)
[16:01:40.234]                     invisible(future)
[16:01:40.234]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:40.234]                 }
[16:01:40.234]             }
[16:01:40.234]         }
[16:01:40.234]     })
[16:01:40.234]     if (TRUE) {
[16:01:40.234]         base::sink(type = "output", split = FALSE)
[16:01:40.234]         if (TRUE) {
[16:01:40.234]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:40.234]         }
[16:01:40.234]         else {
[16:01:40.234]             ...future.result["stdout"] <- base::list(NULL)
[16:01:40.234]         }
[16:01:40.234]         base::close(...future.stdout)
[16:01:40.234]         ...future.stdout <- NULL
[16:01:40.234]     }
[16:01:40.234]     ...future.result$conditions <- ...future.conditions
[16:01:40.234]     ...future.result$finished <- base::Sys.time()
[16:01:40.234]     ...future.result
[16:01:40.234] }
[16:01:40.236] assign_globals() ...
[16:01:40.236] List of 5
[16:01:40.236]  $ future.call.arguments    : list()
[16:01:40.236]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.236]  $ ...future.FUN            :function (x)  
[16:01:40.236]  $ ...future.elements_ii    :List of 2
[16:01:40.236]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[16:01:40.236]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[16:01:40.236]  $ ...future.seeds_ii       : NULL
[16:01:40.236]  $ ...future.globals.maxSize: num Inf
[16:01:40.236]  - attr(*, "resolved")= logi FALSE
[16:01:40.236]  - attr(*, "total_size")= num NA
[16:01:40.236]  - attr(*, "where")=List of 5
[16:01:40.236]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:40.236]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:40.236]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:40.236]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:40.236]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:40.236]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.236]  - attr(*, "already-done")= logi TRUE
[16:01:40.241] - copied ‘future.call.arguments’ to environment
[16:01:40.241] - copied ‘...future.FUN’ to environment
[16:01:40.241] - copied ‘...future.elements_ii’ to environment
[16:01:40.241] - copied ‘...future.seeds_ii’ to environment
[16:01:40.241] - copied ‘...future.globals.maxSize’ to environment
[16:01:40.241] assign_globals() ... done
[16:01:40.242] plan(): Setting new future strategy stack:
[16:01:40.242] List of future strategies:
[16:01:40.242] 1. sequential:
[16:01:40.242]    - args: function (..., envir = parent.frame())
[16:01:40.242]    - tweaked: FALSE
[16:01:40.242]    - call: NULL
[16:01:40.242] plan(): nbrOfWorkers() = 1
[16:01:40.243] plan(): Setting new future strategy stack:
[16:01:40.243] List of future strategies:
[16:01:40.243] 1. sequential:
[16:01:40.243]    - args: function (..., envir = parent.frame())
[16:01:40.243]    - tweaked: FALSE
[16:01:40.243]    - call: plan(strategy)
[16:01:40.245] plan(): nbrOfWorkers() = 1
[16:01:40.245] SequentialFuture started (and completed)
[16:01:40.245] - Launch lazy future ... done
[16:01:40.245] run() for ‘SequentialFuture’ ... done
[16:01:40.245] Created future:
[16:01:40.245] SequentialFuture:
[16:01:40.245] Label: ‘future_apply-1’
[16:01:40.245] Expression:
[16:01:40.245] {
[16:01:40.245]     do.call(function(...) {
[16:01:40.245]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.245]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.245]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.245]             on.exit(options(oopts), add = TRUE)
[16:01:40.245]         }
[16:01:40.245]         {
[16:01:40.245]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.245]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.245]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.245]             })
[16:01:40.245]         }
[16:01:40.245]     }, args = future.call.arguments)
[16:01:40.245] }
[16:01:40.245] Lazy evaluation: FALSE
[16:01:40.245] Asynchronous evaluation: FALSE
[16:01:40.245] Local evaluation: TRUE
[16:01:40.245] Environment: R_GlobalEnv
[16:01:40.245] Capture standard output: TRUE
[16:01:40.245] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:40.245] Globals: 5 objects totaling 1.37 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 496 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:40.245] Packages: <none>
[16:01:40.245] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:40.245] Resolved: TRUE
[16:01:40.245] Value: 496 bytes of class ‘list’
[16:01:40.245] Early signaling: FALSE
[16:01:40.245] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:40.245] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:40.247] Chunk #1 of 1 ... DONE
[16:01:40.247] Launching 1 futures (chunks) ... DONE
[16:01:40.247] Resolving 1 futures (chunks) ...
[16:01:40.247] resolve() on list ...
[16:01:40.247]  recursive: 0
[16:01:40.247]  length: 1
[16:01:40.247] 
[16:01:40.247] resolved() for ‘SequentialFuture’ ...
[16:01:40.247] - state: ‘finished’
[16:01:40.247] - run: TRUE
[16:01:40.248] - result: ‘FutureResult’
[16:01:40.248] resolved() for ‘SequentialFuture’ ... done
[16:01:40.248] Future #1
[16:01:40.248] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:40.248] - nx: 1
[16:01:40.248] - relay: TRUE
[16:01:40.248] - stdout: TRUE
[16:01:40.248] - signal: TRUE
[16:01:40.248] - resignal: FALSE
[16:01:40.248] - force: TRUE
[16:01:40.249] - relayed: [n=1] FALSE
[16:01:40.249] - queued futures: [n=1] FALSE
[16:01:40.249]  - until=1
[16:01:40.249]  - relaying element #1
[16:01:40.249] - relayed: [n=1] TRUE
[16:01:40.249] - queued futures: [n=1] TRUE
[16:01:40.249] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:40.249]  length: 0 (resolved future 1)
[16:01:40.249] Relaying remaining futures
[16:01:40.249] signalConditionsASAP(NULL, pos=0) ...
[16:01:40.250] - nx: 1
[16:01:40.250] - relay: TRUE
[16:01:40.250] - stdout: TRUE
[16:01:40.250] - signal: TRUE
[16:01:40.250] - resignal: FALSE
[16:01:40.250] - force: TRUE
[16:01:40.250] - relayed: [n=1] TRUE
[16:01:40.250] - queued futures: [n=1] TRUE
 - flush all
[16:01:40.250] - relayed: [n=1] TRUE
[16:01:40.250] - queued futures: [n=1] TRUE
[16:01:40.250] signalConditionsASAP(NULL, pos=0) ... done
[16:01:40.251] resolve() on list ... DONE
[16:01:40.251]  - Number of value chunks collected: 1
[16:01:40.251] Resolving 1 futures (chunks) ... DONE
[16:01:40.251] Reducing values from 1 chunks ...
[16:01:40.251]  - Number of values collected after concatenation: 2
[16:01:40.251]  - Number of values expected: 2
[16:01:40.251] Reducing values from 1 chunks ... DONE
[16:01:40.251] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[16:01:40.252] getGlobalsAndPackagesXApply() ...
[16:01:40.252]  - future.globals: TRUE
[16:01:40.252] getGlobalsAndPackages() ...
[16:01:40.252] Searching for globals...
[16:01:40.254] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[16:01:40.254] Searching for globals ... DONE
[16:01:40.255] Resolving globals: FALSE
[16:01:40.255] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[16:01:40.255] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[16:01:40.256] - globals: [1] ‘FUN’
[16:01:40.256] 
[16:01:40.256] getGlobalsAndPackages() ... DONE
[16:01:40.256]  - globals found/used: [n=1] ‘FUN’
[16:01:40.256]  - needed namespaces: [n=0] 
[16:01:40.256] Finding globals ... DONE
[16:01:40.256]  - use_args: TRUE
[16:01:40.256]  - Getting '...' globals ...
[16:01:40.257] resolve() on list ...
[16:01:40.257]  recursive: 0
[16:01:40.257]  length: 1
[16:01:40.257]  elements: ‘...’
[16:01:40.257]  length: 0 (resolved future 1)
[16:01:40.257] resolve() on list ... DONE
[16:01:40.257]    - '...' content: [n=0] 
[16:01:40.257] List of 1
[16:01:40.257]  $ ...: list()
[16:01:40.257]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.257]  - attr(*, "where")=List of 1
[16:01:40.257]   ..$ ...:<environment: 0x55fb6253db38> 
[16:01:40.257]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.257]  - attr(*, "resolved")= logi TRUE
[16:01:40.257]  - attr(*, "total_size")= num NA
[16:01:40.260]  - Getting '...' globals ... DONE
[16:01:40.260] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:40.260] List of 2
[16:01:40.260]  $ ...future.FUN:function (x)  
[16:01:40.260]  $ ...          : list()
[16:01:40.260]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.260]  - attr(*, "where")=List of 2
[16:01:40.260]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:40.260]   ..$ ...          :<environment: 0x55fb6253db38> 
[16:01:40.260]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.260]  - attr(*, "resolved")= logi FALSE
[16:01:40.260]  - attr(*, "total_size")= num 9888
[16:01:40.263] Packages to be attached in all futures: [n=0] 
[16:01:40.263] getGlobalsAndPackagesXApply() ... DONE
[16:01:40.263] future_lapply() ...
[16:01:40.264] Number of chunks: 1
[16:01:40.265] getGlobalsAndPackagesXApply() ...
[16:01:40.265]  - future.globals: <name-value list> with names ‘list()’
[16:01:40.265]  - use_args: TRUE
[16:01:40.265] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:01:40.265] List of 2
[16:01:40.265]  $ ...          : list()
[16:01:40.265]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.265]  $ ...future.FUN:function (x)  
[16:01:40.265]  - attr(*, "where")=List of 2
[16:01:40.265]   ..$ ...          :<environment: 0x55fb6253db38> 
[16:01:40.265]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[16:01:40.265]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.265]  - attr(*, "resolved")= logi FALSE
[16:01:40.265]  - attr(*, "total_size")= num NA
[16:01:40.270] Packages to be attached in all futures: [n=0] 
[16:01:40.270] getGlobalsAndPackagesXApply() ... DONE
[16:01:40.270] Number of futures (= number of chunks): 1
[16:01:40.270] Launching 1 futures (chunks) ...
[16:01:40.270] Chunk #1 of 1 ...
[16:01:40.270]  - seeds: <none>
[16:01:40.270]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.270] getGlobalsAndPackages() ...
[16:01:40.271] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.271] Resolving globals: FALSE
[16:01:40.271] Tweak future expression to call with '...' arguments ...
[16:01:40.271] {
[16:01:40.271]     do.call(function(...) {
[16:01:40.271]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.271]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.271]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.271]             on.exit(options(oopts), add = TRUE)
[16:01:40.271]         }
[16:01:40.271]         {
[16:01:40.271]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.271]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.271]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.271]             })
[16:01:40.271]         }
[16:01:40.271]     }, args = future.call.arguments)
[16:01:40.271] }
[16:01:40.271] Tweak future expression to call with '...' arguments ... DONE
[16:01:40.272] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.272] 
[16:01:40.272] getGlobalsAndPackages() ... DONE
[16:01:40.272] run() for ‘Future’ ...
[16:01:40.272] - state: ‘created’
[16:01:40.272] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:01:40.273] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:40.273] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:40.273]   - Field: ‘label’
[16:01:40.273]   - Field: ‘local’
[16:01:40.273]   - Field: ‘owner’
[16:01:40.273]   - Field: ‘envir’
[16:01:40.273]   - Field: ‘packages’
[16:01:40.273]   - Field: ‘gc’
[16:01:40.273]   - Field: ‘conditions’
[16:01:40.273]   - Field: ‘expr’
[16:01:40.274]   - Field: ‘uuid’
[16:01:40.274]   - Field: ‘seed’
[16:01:40.274]   - Field: ‘version’
[16:01:40.274]   - Field: ‘result’
[16:01:40.274]   - Field: ‘asynchronous’
[16:01:40.274]   - Field: ‘calls’
[16:01:40.274]   - Field: ‘globals’
[16:01:40.274]   - Field: ‘stdout’
[16:01:40.274]   - Field: ‘earlySignal’
[16:01:40.274]   - Field: ‘lazy’
[16:01:40.274]   - Field: ‘state’
[16:01:40.275] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:40.275] - Launch lazy future ...
[16:01:40.275] Packages needed by the future expression (n = 0): <none>
[16:01:40.275] Packages needed by future strategies (n = 0): <none>
[16:01:40.275] {
[16:01:40.275]     {
[16:01:40.275]         {
[16:01:40.275]             ...future.startTime <- base::Sys.time()
[16:01:40.275]             {
[16:01:40.275]                 {
[16:01:40.275]                   {
[16:01:40.275]                     base::local({
[16:01:40.275]                       has_future <- base::requireNamespace("future", 
[16:01:40.275]                         quietly = TRUE)
[16:01:40.275]                       if (has_future) {
[16:01:40.275]                         ns <- base::getNamespace("future")
[16:01:40.275]                         version <- ns[[".package"]][["version"]]
[16:01:40.275]                         if (is.null(version)) 
[16:01:40.275]                           version <- utils::packageVersion("future")
[16:01:40.275]                       }
[16:01:40.275]                       else {
[16:01:40.275]                         version <- NULL
[16:01:40.275]                       }
[16:01:40.275]                       if (!has_future || version < "1.8.0") {
[16:01:40.275]                         info <- base::c(r_version = base::gsub("R version ", 
[16:01:40.275]                           "", base::R.version$version.string), 
[16:01:40.275]                           platform = base::sprintf("%s (%s-bit)", 
[16:01:40.275]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:40.275]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:40.275]                             "release", "version")], collapse = " "), 
[16:01:40.275]                           hostname = base::Sys.info()[["nodename"]])
[16:01:40.275]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:01:40.275]                           info)
[16:01:40.275]                         info <- base::paste(info, collapse = "; ")
[16:01:40.275]                         if (!has_future) {
[16:01:40.275]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:40.275]                             info)
[16:01:40.275]                         }
[16:01:40.275]                         else {
[16:01:40.275]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:40.275]                             info, version)
[16:01:40.275]                         }
[16:01:40.275]                         base::stop(msg)
[16:01:40.275]                       }
[16:01:40.275]                     })
[16:01:40.275]                   }
[16:01:40.275]                   options(future.plan = NULL)
[16:01:40.275]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:40.275]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:40.275]                 }
[16:01:40.275]                 ...future.workdir <- getwd()
[16:01:40.275]             }
[16:01:40.275]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:40.275]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:40.275]         }
[16:01:40.275]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:40.275]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:40.275]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:40.275]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:40.275]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:40.275]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:40.275]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:40.275]             base::names(...future.oldOptions))
[16:01:40.275]     }
[16:01:40.275]     if (FALSE) {
[16:01:40.275]     }
[16:01:40.275]     else {
[16:01:40.275]         if (TRUE) {
[16:01:40.275]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:40.275]                 open = "w")
[16:01:40.275]         }
[16:01:40.275]         else {
[16:01:40.275]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:40.275]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:40.275]         }
[16:01:40.275]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:40.275]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:40.275]             base::sink(type = "output", split = FALSE)
[16:01:40.275]             base::close(...future.stdout)
[16:01:40.275]         }, add = TRUE)
[16:01:40.275]     }
[16:01:40.275]     ...future.frame <- base::sys.nframe()
[16:01:40.275]     ...future.conditions <- base::list()
[16:01:40.275]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:40.275]     if (FALSE) {
[16:01:40.275]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:40.275]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:40.275]     }
[16:01:40.275]     ...future.result <- base::tryCatch({
[16:01:40.275]         base::withCallingHandlers({
[16:01:40.275]             ...future.value <- base::withVisible(base::local({
[16:01:40.275]                 do.call(function(...) {
[16:01:40.275]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.275]                   if (!identical(...future.globals.maxSize.org, 
[16:01:40.275]                     ...future.globals.maxSize)) {
[16:01:40.275]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.275]                     on.exit(options(oopts), add = TRUE)
[16:01:40.275]                   }
[16:01:40.275]                   {
[16:01:40.275]                     lapply(seq_along(...future.elements_ii), 
[16:01:40.275]                       FUN = function(jj) {
[16:01:40.275]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.275]                         ...future.FUN(...future.X_jj, ...)
[16:01:40.275]                       })
[16:01:40.275]                   }
[16:01:40.275]                 }, args = future.call.arguments)
[16:01:40.275]             }))
[16:01:40.275]             future::FutureResult(value = ...future.value$value, 
[16:01:40.275]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:40.275]                   ...future.rng), globalenv = if (FALSE) 
[16:01:40.275]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:40.275]                     ...future.globalenv.names))
[16:01:40.275]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:40.275]         }, condition = base::local({
[16:01:40.275]             c <- base::c
[16:01:40.275]             inherits <- base::inherits
[16:01:40.275]             invokeRestart <- base::invokeRestart
[16:01:40.275]             length <- base::length
[16:01:40.275]             list <- base::list
[16:01:40.275]             seq.int <- base::seq.int
[16:01:40.275]             signalCondition <- base::signalCondition
[16:01:40.275]             sys.calls <- base::sys.calls
[16:01:40.275]             `[[` <- base::`[[`
[16:01:40.275]             `+` <- base::`+`
[16:01:40.275]             `<<-` <- base::`<<-`
[16:01:40.275]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:40.275]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:40.275]                   3L)]
[16:01:40.275]             }
[16:01:40.275]             function(cond) {
[16:01:40.275]                 is_error <- inherits(cond, "error")
[16:01:40.275]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:40.275]                   NULL)
[16:01:40.275]                 if (is_error) {
[16:01:40.275]                   sessionInformation <- function() {
[16:01:40.275]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:40.275]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:40.275]                       search = base::search(), system = base::Sys.info())
[16:01:40.275]                   }
[16:01:40.275]                   ...future.conditions[[length(...future.conditions) + 
[16:01:40.275]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:40.275]                     cond$call), session = sessionInformation(), 
[16:01:40.275]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:40.275]                   signalCondition(cond)
[16:01:40.275]                 }
[16:01:40.275]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:40.275]                 "immediateCondition"))) {
[16:01:40.275]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:40.275]                   ...future.conditions[[length(...future.conditions) + 
[16:01:40.275]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:40.275]                   if (TRUE && !signal) {
[16:01:40.275]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.275]                     {
[16:01:40.275]                       inherits <- base::inherits
[16:01:40.275]                       invokeRestart <- base::invokeRestart
[16:01:40.275]                       is.null <- base::is.null
[16:01:40.275]                       muffled <- FALSE
[16:01:40.275]                       if (inherits(cond, "message")) {
[16:01:40.275]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:40.275]                         if (muffled) 
[16:01:40.275]                           invokeRestart("muffleMessage")
[16:01:40.275]                       }
[16:01:40.275]                       else if (inherits(cond, "warning")) {
[16:01:40.275]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:40.275]                         if (muffled) 
[16:01:40.275]                           invokeRestart("muffleWarning")
[16:01:40.275]                       }
[16:01:40.275]                       else if (inherits(cond, "condition")) {
[16:01:40.275]                         if (!is.null(pattern)) {
[16:01:40.275]                           computeRestarts <- base::computeRestarts
[16:01:40.275]                           grepl <- base::grepl
[16:01:40.275]                           restarts <- computeRestarts(cond)
[16:01:40.275]                           for (restart in restarts) {
[16:01:40.275]                             name <- restart$name
[16:01:40.275]                             if (is.null(name)) 
[16:01:40.275]                               next
[16:01:40.275]                             if (!grepl(pattern, name)) 
[16:01:40.275]                               next
[16:01:40.275]                             invokeRestart(restart)
[16:01:40.275]                             muffled <- TRUE
[16:01:40.275]                             break
[16:01:40.275]                           }
[16:01:40.275]                         }
[16:01:40.275]                       }
[16:01:40.275]                       invisible(muffled)
[16:01:40.275]                     }
[16:01:40.275]                     muffleCondition(cond, pattern = "^muffle")
[16:01:40.275]                   }
[16:01:40.275]                 }
[16:01:40.275]                 else {
[16:01:40.275]                   if (TRUE) {
[16:01:40.275]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.275]                     {
[16:01:40.275]                       inherits <- base::inherits
[16:01:40.275]                       invokeRestart <- base::invokeRestart
[16:01:40.275]                       is.null <- base::is.null
[16:01:40.275]                       muffled <- FALSE
[16:01:40.275]                       if (inherits(cond, "message")) {
[16:01:40.275]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:40.275]                         if (muffled) 
[16:01:40.275]                           invokeRestart("muffleMessage")
[16:01:40.275]                       }
[16:01:40.275]                       else if (inherits(cond, "warning")) {
[16:01:40.275]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:40.275]                         if (muffled) 
[16:01:40.275]                           invokeRestart("muffleWarning")
[16:01:40.275]                       }
[16:01:40.275]                       else if (inherits(cond, "condition")) {
[16:01:40.275]                         if (!is.null(pattern)) {
[16:01:40.275]                           computeRestarts <- base::computeRestarts
[16:01:40.275]                           grepl <- base::grepl
[16:01:40.275]                           restarts <- computeRestarts(cond)
[16:01:40.275]                           for (restart in restarts) {
[16:01:40.275]                             name <- restart$name
[16:01:40.275]                             if (is.null(name)) 
[16:01:40.275]                               next
[16:01:40.275]                             if (!grepl(pattern, name)) 
[16:01:40.275]                               next
[16:01:40.275]                             invokeRestart(restart)
[16:01:40.275]                             muffled <- TRUE
[16:01:40.275]                             break
[16:01:40.275]                           }
[16:01:40.275]                         }
[16:01:40.275]                       }
[16:01:40.275]                       invisible(muffled)
[16:01:40.275]                     }
[16:01:40.275]                     muffleCondition(cond, pattern = "^muffle")
[16:01:40.275]                   }
[16:01:40.275]                 }
[16:01:40.275]             }
[16:01:40.275]         }))
[16:01:40.275]     }, error = function(ex) {
[16:01:40.275]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:40.275]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:40.275]                 ...future.rng), started = ...future.startTime, 
[16:01:40.275]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:40.275]             version = "1.8"), class = "FutureResult")
[16:01:40.275]     }, finally = {
[16:01:40.275]         if (!identical(...future.workdir, getwd())) 
[16:01:40.275]             setwd(...future.workdir)
[16:01:40.275]         {
[16:01:40.275]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:40.275]                 ...future.oldOptions$nwarnings <- NULL
[16:01:40.275]             }
[16:01:40.275]             base::options(...future.oldOptions)
[16:01:40.275]             if (.Platform$OS.type == "windows") {
[16:01:40.275]                 old_names <- names(...future.oldEnvVars)
[16:01:40.275]                 envs <- base::Sys.getenv()
[16:01:40.275]                 names <- names(envs)
[16:01:40.275]                 common <- intersect(names, old_names)
[16:01:40.275]                 added <- setdiff(names, old_names)
[16:01:40.275]                 removed <- setdiff(old_names, names)
[16:01:40.275]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:40.275]                   envs[common]]
[16:01:40.275]                 NAMES <- toupper(changed)
[16:01:40.275]                 args <- list()
[16:01:40.275]                 for (kk in seq_along(NAMES)) {
[16:01:40.275]                   name <- changed[[kk]]
[16:01:40.275]                   NAME <- NAMES[[kk]]
[16:01:40.275]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.275]                     next
[16:01:40.275]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:40.275]                 }
[16:01:40.275]                 NAMES <- toupper(added)
[16:01:40.275]                 for (kk in seq_along(NAMES)) {
[16:01:40.275]                   name <- added[[kk]]
[16:01:40.275]                   NAME <- NAMES[[kk]]
[16:01:40.275]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.275]                     next
[16:01:40.275]                   args[[name]] <- ""
[16:01:40.275]                 }
[16:01:40.275]                 NAMES <- toupper(removed)
[16:01:40.275]                 for (kk in seq_along(NAMES)) {
[16:01:40.275]                   name <- removed[[kk]]
[16:01:40.275]                   NAME <- NAMES[[kk]]
[16:01:40.275]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.275]                     next
[16:01:40.275]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:40.275]                 }
[16:01:40.275]                 if (length(args) > 0) 
[16:01:40.275]                   base::do.call(base::Sys.setenv, args = args)
[16:01:40.275]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:40.275]             }
[16:01:40.275]             else {
[16:01:40.275]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:40.275]             }
[16:01:40.275]             {
[16:01:40.275]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:40.275]                   0L) {
[16:01:40.275]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:40.275]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:40.275]                   base::options(opts)
[16:01:40.275]                 }
[16:01:40.275]                 {
[16:01:40.275]                   {
[16:01:40.275]                     NULL
[16:01:40.275]                     RNGkind("Mersenne-Twister")
[16:01:40.275]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:01:40.275]                       inherits = FALSE)
[16:01:40.275]                   }
[16:01:40.275]                   options(future.plan = NULL)
[16:01:40.275]                   if (is.na(NA_character_)) 
[16:01:40.275]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:40.275]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:40.275]                   future::plan(list(function (..., envir = parent.frame()) 
[16:01:40.275]                   {
[16:01:40.275]                     future <- SequentialFuture(..., envir = envir)
[16:01:40.275]                     if (!future$lazy) 
[16:01:40.275]                       future <- run(future)
[16:01:40.275]                     invisible(future)
[16:01:40.275]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:40.275]                 }
[16:01:40.275]             }
[16:01:40.275]         }
[16:01:40.275]     })
[16:01:40.275]     if (TRUE) {
[16:01:40.275]         base::sink(type = "output", split = FALSE)
[16:01:40.275]         if (TRUE) {
[16:01:40.275]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:40.275]         }
[16:01:40.275]         else {
[16:01:40.275]             ...future.result["stdout"] <- base::list(NULL)
[16:01:40.275]         }
[16:01:40.275]         base::close(...future.stdout)
[16:01:40.275]         ...future.stdout <- NULL
[16:01:40.275]     }
[16:01:40.275]     ...future.result$conditions <- ...future.conditions
[16:01:40.275]     ...future.result$finished <- base::Sys.time()
[16:01:40.275]     ...future.result
[16:01:40.275] }
[16:01:40.277] assign_globals() ...
[16:01:40.277] List of 5
[16:01:40.277]  $ future.call.arguments    : list()
[16:01:40.277]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.277]  $ ...future.FUN            :function (x)  
[16:01:40.277]  $ ...future.elements_ii    :List of 2
[16:01:40.277]   ..$ : int [1:2] 1 3
[16:01:40.277]   ..$ : int [1:2] 2 4
[16:01:40.277]  $ ...future.seeds_ii       : NULL
[16:01:40.277]  $ ...future.globals.maxSize: num Inf
[16:01:40.277]  - attr(*, "resolved")= logi FALSE
[16:01:40.277]  - attr(*, "total_size")= num NA
[16:01:40.277]  - attr(*, "where")=List of 5
[16:01:40.277]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:40.277]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:40.277]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:40.277]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:40.277]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:40.277]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.277]  - attr(*, "already-done")= logi TRUE
[16:01:40.282] - copied ‘future.call.arguments’ to environment
[16:01:40.282] - reassign environment for ‘...future.FUN’
[16:01:40.282] - copied ‘...future.FUN’ to environment
[16:01:40.283] - copied ‘...future.elements_ii’ to environment
[16:01:40.283] - copied ‘...future.seeds_ii’ to environment
[16:01:40.283] - copied ‘...future.globals.maxSize’ to environment
[16:01:40.283] assign_globals() ... done
[16:01:40.283] plan(): Setting new future strategy stack:
[16:01:40.283] List of future strategies:
[16:01:40.283] 1. sequential:
[16:01:40.283]    - args: function (..., envir = parent.frame())
[16:01:40.283]    - tweaked: FALSE
[16:01:40.283]    - call: NULL
[16:01:40.284] plan(): nbrOfWorkers() = 1
[16:01:40.284] plan(): Setting new future strategy stack:
[16:01:40.284] List of future strategies:
[16:01:40.284] 1. sequential:
[16:01:40.284]    - args: function (..., envir = parent.frame())
[16:01:40.284]    - tweaked: FALSE
[16:01:40.284]    - call: plan(strategy)
[16:01:40.285] plan(): nbrOfWorkers() = 1
[16:01:40.285] SequentialFuture started (and completed)
[16:01:40.285] - Launch lazy future ... done
[16:01:40.285] run() for ‘SequentialFuture’ ... done
[16:01:40.285] Created future:
[16:01:40.285] SequentialFuture:
[16:01:40.285] Label: ‘future_apply-1’
[16:01:40.285] Expression:
[16:01:40.285] {
[16:01:40.285]     do.call(function(...) {
[16:01:40.285]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.285]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.285]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.285]             on.exit(options(oopts), add = TRUE)
[16:01:40.285]         }
[16:01:40.285]         {
[16:01:40.285]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.285]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.285]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.285]             })
[16:01:40.285]         }
[16:01:40.285]     }, args = future.call.arguments)
[16:01:40.285] }
[16:01:40.285] Lazy evaluation: FALSE
[16:01:40.285] Asynchronous evaluation: FALSE
[16:01:40.285] Local evaluation: TRUE
[16:01:40.285] Environment: R_GlobalEnv
[16:01:40.285] Capture standard output: TRUE
[16:01:40.285] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:40.285] Globals: 5 objects totaling 9.82 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:40.285] Packages: <none>
[16:01:40.285] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:40.285] Resolved: TRUE
[16:01:40.285] Value: 400 bytes of class ‘list’
[16:01:40.285] Early signaling: FALSE
[16:01:40.285] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:40.285] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:40.286] Chunk #1 of 1 ... DONE
[16:01:40.287] Launching 1 futures (chunks) ... DONE
[16:01:40.287] Resolving 1 futures (chunks) ...
[16:01:40.287] resolve() on list ...
[16:01:40.287]  recursive: 0
[16:01:40.287]  length: 1
[16:01:40.287] 
[16:01:40.287] resolved() for ‘SequentialFuture’ ...
[16:01:40.287] - state: ‘finished’
[16:01:40.287] - run: TRUE
[16:01:40.287] - result: ‘FutureResult’
[16:01:40.288] resolved() for ‘SequentialFuture’ ... done
[16:01:40.288] Future #1
[16:01:40.288] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:40.288] - nx: 1
[16:01:40.288] - relay: TRUE
[16:01:40.288] - stdout: TRUE
[16:01:40.288] - signal: TRUE
[16:01:40.288] - resignal: FALSE
[16:01:40.288] - force: TRUE
[16:01:40.288] - relayed: [n=1] FALSE
[16:01:40.288] - queued futures: [n=1] FALSE
[16:01:40.289]  - until=1
[16:01:40.289]  - relaying element #1
[16:01:40.289] - relayed: [n=1] TRUE
[16:01:40.289] - queued futures: [n=1] TRUE
[16:01:40.289] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:40.289]  length: 0 (resolved future 1)
[16:01:40.289] Relaying remaining futures
[16:01:40.289] signalConditionsASAP(NULL, pos=0) ...
[16:01:40.289] - nx: 1
[16:01:40.289] - relay: TRUE
[16:01:40.290] - stdout: TRUE
[16:01:40.290] - signal: TRUE
[16:01:40.290] - resignal: FALSE
[16:01:40.290] - force: TRUE
[16:01:40.290] - relayed: [n=1] TRUE
[16:01:40.290] - queued futures: [n=1] TRUE
 - flush all
[16:01:40.290] - relayed: [n=1] TRUE
[16:01:40.290] - queued futures: [n=1] TRUE
[16:01:40.290] signalConditionsASAP(NULL, pos=0) ... done
[16:01:40.290] resolve() on list ... DONE
[16:01:40.290]  - Number of value chunks collected: 1
[16:01:40.291] Resolving 1 futures (chunks) ... DONE
[16:01:40.291] Reducing values from 1 chunks ...
[16:01:40.291]  - Number of values collected after concatenation: 2
[16:01:40.291]  - Number of values expected: 2
[16:01:40.291] Reducing values from 1 chunks ... DONE
[16:01:40.291] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[16:01:40.293] getGlobalsAndPackagesXApply() ...
[16:01:40.293]  - future.globals: TRUE
[16:01:40.293] getGlobalsAndPackages() ...
[16:01:40.293] Searching for globals...
[16:01:40.296] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[16:01:40.297] Searching for globals ... DONE
[16:01:40.297] Resolving globals: FALSE
[16:01:40.297] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[16:01:40.298] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[16:01:40.298] - globals: [1] ‘FUN’
[16:01:40.298] 
[16:01:40.298] getGlobalsAndPackages() ... DONE
[16:01:40.298]  - globals found/used: [n=1] ‘FUN’
[16:01:40.298]  - needed namespaces: [n=0] 
[16:01:40.298] Finding globals ... DONE
[16:01:40.298]  - use_args: TRUE
[16:01:40.298]  - Getting '...' globals ...
[16:01:40.299] resolve() on list ...
[16:01:40.299]  recursive: 0
[16:01:40.299]  length: 1
[16:01:40.299]  elements: ‘...’
[16:01:40.299]  length: 0 (resolved future 1)
[16:01:40.299] resolve() on list ... DONE
[16:01:40.299]    - '...' content: [n=0] 
[16:01:40.299] List of 1
[16:01:40.299]  $ ...: list()
[16:01:40.299]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.299]  - attr(*, "where")=List of 1
[16:01:40.299]   ..$ ...:<environment: 0x55fb64430d18> 
[16:01:40.299]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.299]  - attr(*, "resolved")= logi TRUE
[16:01:40.299]  - attr(*, "total_size")= num NA
[16:01:40.302]  - Getting '...' globals ... DONE
[16:01:40.302] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:40.302] List of 2
[16:01:40.302]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[16:01:40.302]  $ ...          : list()
[16:01:40.302]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.302]  - attr(*, "where")=List of 2
[16:01:40.302]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:40.302]   ..$ ...          :<environment: 0x55fb64430d18> 
[16:01:40.302]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.302]  - attr(*, "resolved")= logi FALSE
[16:01:40.302]  - attr(*, "total_size")= num 36296
[16:01:40.305] Packages to be attached in all futures: [n=0] 
[16:01:40.305] getGlobalsAndPackagesXApply() ... DONE
[16:01:40.305] future_lapply() ...
[16:01:40.307] Generating random seeds ...
[16:01:40.307] Generating random seed streams for 2 elements ...
[16:01:40.308] Generating random seed streams for 2 elements ... DONE
[16:01:40.308] Generating random seeds ... DONE
[16:01:40.308] Will set RNG state on exit: 10407, 446300033, -1260965711, -1984911120, 329338188, 724448249, -369701816
[16:01:40.308] Number of chunks: 1
[16:01:40.308] getGlobalsAndPackagesXApply() ...
[16:01:40.308]  - future.globals: <name-value list> with names ‘list()’
[16:01:40.308]  - use_args: TRUE
[16:01:40.308] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:01:40.309] List of 2
[16:01:40.309]  $ ...          : list()
[16:01:40.309]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.309]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[16:01:40.309]  - attr(*, "where")=List of 2
[16:01:40.309]   ..$ ...          :<environment: 0x55fb64430d18> 
[16:01:40.309]   ..$ ...future.FUN:<environment: namespace:base> 
[16:01:40.309]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.309]  - attr(*, "resolved")= logi FALSE
[16:01:40.309]  - attr(*, "total_size")= num NA
[16:01:40.312] Packages to be attached in all futures: [n=0] 
[16:01:40.312] getGlobalsAndPackagesXApply() ... DONE
[16:01:40.312] Number of futures (= number of chunks): 1
[16:01:40.312] Launching 1 futures (chunks) ...
[16:01:40.312] Chunk #1 of 1 ...
[16:01:40.312]  - seeds: [2] <seeds>
[16:01:40.313]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.313] getGlobalsAndPackages() ...
[16:01:40.313] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.313] Resolving globals: FALSE
[16:01:40.313] Tweak future expression to call with '...' arguments ...
[16:01:40.313] {
[16:01:40.313]     do.call(function(...) {
[16:01:40.313]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.313]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.313]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.313]             on.exit(options(oopts), add = TRUE)
[16:01:40.313]         }
[16:01:40.313]         {
[16:01:40.313]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.313]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.313]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:01:40.313]                   envir = globalenv(), inherits = FALSE)
[16:01:40.313]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.313]             })
[16:01:40.313]         }
[16:01:40.313]     }, args = future.call.arguments)
[16:01:40.313] }
[16:01:40.313] Tweak future expression to call with '...' arguments ... DONE
[16:01:40.314] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.314] 
[16:01:40.314] getGlobalsAndPackages() ... DONE
[16:01:40.314] run() for ‘Future’ ...
[16:01:40.314] - state: ‘created’
[16:01:40.315] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:01:40.316] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:40.316] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:01:40.316]   - Field: ‘label’
[16:01:40.317]   - Field: ‘local’
[16:01:40.317]   - Field: ‘owner’
[16:01:40.317]   - Field: ‘envir’
[16:01:40.317]   - Field: ‘packages’
[16:01:40.317]   - Field: ‘gc’
[16:01:40.317]   - Field: ‘conditions’
[16:01:40.317]   - Field: ‘expr’
[16:01:40.317]   - Field: ‘uuid’
[16:01:40.317]   - Field: ‘seed’
[16:01:40.318]   - Field: ‘version’
[16:01:40.318]   - Field: ‘result’
[16:01:40.318]   - Field: ‘asynchronous’
[16:01:40.318]   - Field: ‘calls’
[16:01:40.318]   - Field: ‘globals’
[16:01:40.318]   - Field: ‘stdout’
[16:01:40.318]   - Field: ‘earlySignal’
[16:01:40.318]   - Field: ‘lazy’
[16:01:40.318]   - Field: ‘state’
[16:01:40.318] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:01:40.319] - Launch lazy future ...
[16:01:40.319] Packages needed by the future expression (n = 0): <none>
[16:01:40.319] Packages needed by future strategies (n = 0): <none>
[16:01:40.319] {
[16:01:40.319]     {
[16:01:40.319]         {
[16:01:40.319]             ...future.startTime <- base::Sys.time()
[16:01:40.319]             {
[16:01:40.319]                 {
[16:01:40.319]                   {
[16:01:40.319]                     base::local({
[16:01:40.319]                       has_future <- base::requireNamespace("future", 
[16:01:40.319]                         quietly = TRUE)
[16:01:40.319]                       if (has_future) {
[16:01:40.319]                         ns <- base::getNamespace("future")
[16:01:40.319]                         version <- ns[[".package"]][["version"]]
[16:01:40.319]                         if (is.null(version)) 
[16:01:40.319]                           version <- utils::packageVersion("future")
[16:01:40.319]                       }
[16:01:40.319]                       else {
[16:01:40.319]                         version <- NULL
[16:01:40.319]                       }
[16:01:40.319]                       if (!has_future || version < "1.8.0") {
[16:01:40.319]                         info <- base::c(r_version = base::gsub("R version ", 
[16:01:40.319]                           "", base::R.version$version.string), 
[16:01:40.319]                           platform = base::sprintf("%s (%s-bit)", 
[16:01:40.319]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:40.319]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:40.319]                             "release", "version")], collapse = " "), 
[16:01:40.319]                           hostname = base::Sys.info()[["nodename"]])
[16:01:40.319]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:01:40.319]                           info)
[16:01:40.319]                         info <- base::paste(info, collapse = "; ")
[16:01:40.319]                         if (!has_future) {
[16:01:40.319]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:40.319]                             info)
[16:01:40.319]                         }
[16:01:40.319]                         else {
[16:01:40.319]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:40.319]                             info, version)
[16:01:40.319]                         }
[16:01:40.319]                         base::stop(msg)
[16:01:40.319]                       }
[16:01:40.319]                     })
[16:01:40.319]                   }
[16:01:40.319]                   options(future.plan = NULL)
[16:01:40.319]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:40.319]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:40.319]                 }
[16:01:40.319]                 ...future.workdir <- getwd()
[16:01:40.319]             }
[16:01:40.319]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:40.319]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:40.319]         }
[16:01:40.319]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:40.319]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:40.319]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:40.319]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:40.319]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:40.319]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:40.319]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:40.319]             base::names(...future.oldOptions))
[16:01:40.319]     }
[16:01:40.319]     if (FALSE) {
[16:01:40.319]     }
[16:01:40.319]     else {
[16:01:40.319]         if (TRUE) {
[16:01:40.319]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:40.319]                 open = "w")
[16:01:40.319]         }
[16:01:40.319]         else {
[16:01:40.319]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:40.319]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:40.319]         }
[16:01:40.319]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:40.319]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:40.319]             base::sink(type = "output", split = FALSE)
[16:01:40.319]             base::close(...future.stdout)
[16:01:40.319]         }, add = TRUE)
[16:01:40.319]     }
[16:01:40.319]     ...future.frame <- base::sys.nframe()
[16:01:40.319]     ...future.conditions <- base::list()
[16:01:40.319]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:40.319]     if (FALSE) {
[16:01:40.319]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:40.319]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:40.319]     }
[16:01:40.319]     ...future.result <- base::tryCatch({
[16:01:40.319]         base::withCallingHandlers({
[16:01:40.319]             ...future.value <- base::withVisible(base::local({
[16:01:40.319]                 do.call(function(...) {
[16:01:40.319]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.319]                   if (!identical(...future.globals.maxSize.org, 
[16:01:40.319]                     ...future.globals.maxSize)) {
[16:01:40.319]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.319]                     on.exit(options(oopts), add = TRUE)
[16:01:40.319]                   }
[16:01:40.319]                   {
[16:01:40.319]                     lapply(seq_along(...future.elements_ii), 
[16:01:40.319]                       FUN = function(jj) {
[16:01:40.319]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.319]                         assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:01:40.319]                           envir = globalenv(), inherits = FALSE)
[16:01:40.319]                         ...future.FUN(...future.X_jj, ...)
[16:01:40.319]                       })
[16:01:40.319]                   }
[16:01:40.319]                 }, args = future.call.arguments)
[16:01:40.319]             }))
[16:01:40.319]             future::FutureResult(value = ...future.value$value, 
[16:01:40.319]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:40.319]                   ...future.rng), globalenv = if (FALSE) 
[16:01:40.319]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:40.319]                     ...future.globalenv.names))
[16:01:40.319]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:40.319]         }, condition = base::local({
[16:01:40.319]             c <- base::c
[16:01:40.319]             inherits <- base::inherits
[16:01:40.319]             invokeRestart <- base::invokeRestart
[16:01:40.319]             length <- base::length
[16:01:40.319]             list <- base::list
[16:01:40.319]             seq.int <- base::seq.int
[16:01:40.319]             signalCondition <- base::signalCondition
[16:01:40.319]             sys.calls <- base::sys.calls
[16:01:40.319]             `[[` <- base::`[[`
[16:01:40.319]             `+` <- base::`+`
[16:01:40.319]             `<<-` <- base::`<<-`
[16:01:40.319]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:40.319]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:40.319]                   3L)]
[16:01:40.319]             }
[16:01:40.319]             function(cond) {
[16:01:40.319]                 is_error <- inherits(cond, "error")
[16:01:40.319]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:40.319]                   NULL)
[16:01:40.319]                 if (is_error) {
[16:01:40.319]                   sessionInformation <- function() {
[16:01:40.319]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:40.319]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:40.319]                       search = base::search(), system = base::Sys.info())
[16:01:40.319]                   }
[16:01:40.319]                   ...future.conditions[[length(...future.conditions) + 
[16:01:40.319]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:40.319]                     cond$call), session = sessionInformation(), 
[16:01:40.319]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:40.319]                   signalCondition(cond)
[16:01:40.319]                 }
[16:01:40.319]                 else if (!ignore && FALSE && inherits(cond, NULL)) {
[16:01:40.319]                   signal <- TRUE && inherits(cond, character(0))
[16:01:40.319]                   ...future.conditions[[length(...future.conditions) + 
[16:01:40.319]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:40.319]                   if (TRUE && !signal) {
[16:01:40.319]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.319]                     {
[16:01:40.319]                       inherits <- base::inherits
[16:01:40.319]                       invokeRestart <- base::invokeRestart
[16:01:40.319]                       is.null <- base::is.null
[16:01:40.319]                       muffled <- FALSE
[16:01:40.319]                       if (inherits(cond, "message")) {
[16:01:40.319]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:40.319]                         if (muffled) 
[16:01:40.319]                           invokeRestart("muffleMessage")
[16:01:40.319]                       }
[16:01:40.319]                       else if (inherits(cond, "warning")) {
[16:01:40.319]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:40.319]                         if (muffled) 
[16:01:40.319]                           invokeRestart("muffleWarning")
[16:01:40.319]                       }
[16:01:40.319]                       else if (inherits(cond, "condition")) {
[16:01:40.319]                         if (!is.null(pattern)) {
[16:01:40.319]                           computeRestarts <- base::computeRestarts
[16:01:40.319]                           grepl <- base::grepl
[16:01:40.319]                           restarts <- computeRestarts(cond)
[16:01:40.319]                           for (restart in restarts) {
[16:01:40.319]                             name <- restart$name
[16:01:40.319]                             if (is.null(name)) 
[16:01:40.319]                               next
[16:01:40.319]                             if (!grepl(pattern, name)) 
[16:01:40.319]                               next
[16:01:40.319]                             invokeRestart(restart)
[16:01:40.319]                             muffled <- TRUE
[16:01:40.319]                             break
[16:01:40.319]                           }
[16:01:40.319]                         }
[16:01:40.319]                       }
[16:01:40.319]                       invisible(muffled)
[16:01:40.319]                     }
[16:01:40.319]                     muffleCondition(cond, pattern = "^muffle")
[16:01:40.319]                   }
[16:01:40.319]                 }
[16:01:40.319]                 else {
[16:01:40.319]                   if (FALSE) {
[16:01:40.319]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.319]                     {
[16:01:40.319]                       inherits <- base::inherits
[16:01:40.319]                       invokeRestart <- base::invokeRestart
[16:01:40.319]                       is.null <- base::is.null
[16:01:40.319]                       muffled <- FALSE
[16:01:40.319]                       if (inherits(cond, "message")) {
[16:01:40.319]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:40.319]                         if (muffled) 
[16:01:40.319]                           invokeRestart("muffleMessage")
[16:01:40.319]                       }
[16:01:40.319]                       else if (inherits(cond, "warning")) {
[16:01:40.319]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:40.319]                         if (muffled) 
[16:01:40.319]                           invokeRestart("muffleWarning")
[16:01:40.319]                       }
[16:01:40.319]                       else if (inherits(cond, "condition")) {
[16:01:40.319]                         if (!is.null(pattern)) {
[16:01:40.319]                           computeRestarts <- base::computeRestarts
[16:01:40.319]                           grepl <- base::grepl
[16:01:40.319]                           restarts <- computeRestarts(cond)
[16:01:40.319]                           for (restart in restarts) {
[16:01:40.319]                             name <- restart$name
[16:01:40.319]                             if (is.null(name)) 
[16:01:40.319]                               next
[16:01:40.319]                             if (!grepl(pattern, name)) 
[16:01:40.319]                               next
[16:01:40.319]                             invokeRestart(restart)
[16:01:40.319]                             muffled <- TRUE
[16:01:40.319]                             break
[16:01:40.319]                           }
[16:01:40.319]                         }
[16:01:40.319]                       }
[16:01:40.319]                       invisible(muffled)
[16:01:40.319]                     }
[16:01:40.319]                     muffleCondition(cond, pattern = "^muffle")
[16:01:40.319]                   }
[16:01:40.319]                 }
[16:01:40.319]             }
[16:01:40.319]         }))
[16:01:40.319]     }, error = function(ex) {
[16:01:40.319]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:40.319]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:40.319]                 ...future.rng), started = ...future.startTime, 
[16:01:40.319]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:40.319]             version = "1.8"), class = "FutureResult")
[16:01:40.319]     }, finally = {
[16:01:40.319]         if (!identical(...future.workdir, getwd())) 
[16:01:40.319]             setwd(...future.workdir)
[16:01:40.319]         {
[16:01:40.319]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:40.319]                 ...future.oldOptions$nwarnings <- NULL
[16:01:40.319]             }
[16:01:40.319]             base::options(...future.oldOptions)
[16:01:40.319]             if (.Platform$OS.type == "windows") {
[16:01:40.319]                 old_names <- names(...future.oldEnvVars)
[16:01:40.319]                 envs <- base::Sys.getenv()
[16:01:40.319]                 names <- names(envs)
[16:01:40.319]                 common <- intersect(names, old_names)
[16:01:40.319]                 added <- setdiff(names, old_names)
[16:01:40.319]                 removed <- setdiff(old_names, names)
[16:01:40.319]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:40.319]                   envs[common]]
[16:01:40.319]                 NAMES <- toupper(changed)
[16:01:40.319]                 args <- list()
[16:01:40.319]                 for (kk in seq_along(NAMES)) {
[16:01:40.319]                   name <- changed[[kk]]
[16:01:40.319]                   NAME <- NAMES[[kk]]
[16:01:40.319]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.319]                     next
[16:01:40.319]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:40.319]                 }
[16:01:40.319]                 NAMES <- toupper(added)
[16:01:40.319]                 for (kk in seq_along(NAMES)) {
[16:01:40.319]                   name <- added[[kk]]
[16:01:40.319]                   NAME <- NAMES[[kk]]
[16:01:40.319]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.319]                     next
[16:01:40.319]                   args[[name]] <- ""
[16:01:40.319]                 }
[16:01:40.319]                 NAMES <- toupper(removed)
[16:01:40.319]                 for (kk in seq_along(NAMES)) {
[16:01:40.319]                   name <- removed[[kk]]
[16:01:40.319]                   NAME <- NAMES[[kk]]
[16:01:40.319]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.319]                     next
[16:01:40.319]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:40.319]                 }
[16:01:40.319]                 if (length(args) > 0) 
[16:01:40.319]                   base::do.call(base::Sys.setenv, args = args)
[16:01:40.319]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:40.319]             }
[16:01:40.319]             else {
[16:01:40.319]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:40.319]             }
[16:01:40.319]             {
[16:01:40.319]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:40.319]                   0L) {
[16:01:40.319]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:40.319]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:40.319]                   base::options(opts)
[16:01:40.319]                 }
[16:01:40.319]                 {
[16:01:40.319]                   {
[16:01:40.319]                     base::assign(".Random.seed", c(10407L, 446300033L, 
[16:01:40.319]                     -1260965711L, -1984911120L, 329338188L, 724448249L, 
[16:01:40.319]                     -369701816L), envir = base::globalenv(), 
[16:01:40.319]                       inherits = FALSE)
[16:01:40.319]                     NULL
[16:01:40.319]                   }
[16:01:40.319]                   options(future.plan = NULL)
[16:01:40.319]                   if (is.na(NA_character_)) 
[16:01:40.319]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:40.319]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:40.319]                   future::plan(list(function (..., envir = parent.frame()) 
[16:01:40.319]                   {
[16:01:40.319]                     future <- SequentialFuture(..., envir = envir)
[16:01:40.319]                     if (!future$lazy) 
[16:01:40.319]                       future <- run(future)
[16:01:40.319]                     invisible(future)
[16:01:40.319]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:40.319]                 }
[16:01:40.319]             }
[16:01:40.319]         }
[16:01:40.319]     })
[16:01:40.319]     if (TRUE) {
[16:01:40.319]         base::sink(type = "output", split = FALSE)
[16:01:40.319]         if (TRUE) {
[16:01:40.319]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:40.319]         }
[16:01:40.319]         else {
[16:01:40.319]             ...future.result["stdout"] <- base::list(NULL)
[16:01:40.319]         }
[16:01:40.319]         base::close(...future.stdout)
[16:01:40.319]         ...future.stdout <- NULL
[16:01:40.319]     }
[16:01:40.319]     ...future.result$conditions <- ...future.conditions
[16:01:40.319]     ...future.result$finished <- base::Sys.time()
[16:01:40.319]     ...future.result
[16:01:40.319] }
[16:01:40.321] assign_globals() ...
[16:01:40.321] List of 5
[16:01:40.321]  $ future.call.arguments    : list()
[16:01:40.321]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.321]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[16:01:40.321]  $ ...future.elements_ii    :List of 2
[16:01:40.321]   ..$ : int [1:2] 1 3
[16:01:40.321]   ..$ : int [1:2] 2 4
[16:01:40.321]  $ ...future.seeds_ii       :List of 2
[16:01:40.321]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[16:01:40.321]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[16:01:40.321]  $ ...future.globals.maxSize: num Inf
[16:01:40.321]  - attr(*, "resolved")= logi FALSE
[16:01:40.321]  - attr(*, "total_size")= num NA
[16:01:40.321]  - attr(*, "where")=List of 5
[16:01:40.321]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:40.321]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:40.321]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:40.321]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:40.321]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:40.321]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.321]  - attr(*, "already-done")= logi TRUE
[16:01:40.327] - copied ‘future.call.arguments’ to environment
[16:01:40.327] - copied ‘...future.FUN’ to environment
[16:01:40.327] - copied ‘...future.elements_ii’ to environment
[16:01:40.327] - copied ‘...future.seeds_ii’ to environment
[16:01:40.327] - copied ‘...future.globals.maxSize’ to environment
[16:01:40.327] assign_globals() ... done
[16:01:40.328] plan(): Setting new future strategy stack:
[16:01:40.328] List of future strategies:
[16:01:40.328] 1. sequential:
[16:01:40.328]    - args: function (..., envir = parent.frame())
[16:01:40.328]    - tweaked: FALSE
[16:01:40.328]    - call: NULL
[16:01:40.328] plan(): nbrOfWorkers() = 1
[16:01:40.329] plan(): Setting new future strategy stack:
[16:01:40.329] List of future strategies:
[16:01:40.329] 1. sequential:
[16:01:40.329]    - args: function (..., envir = parent.frame())
[16:01:40.329]    - tweaked: FALSE
[16:01:40.329]    - call: plan(strategy)
[16:01:40.329] plan(): nbrOfWorkers() = 1
[16:01:40.329] SequentialFuture started (and completed)
[16:01:40.330] - Launch lazy future ... done
[16:01:40.330] run() for ‘SequentialFuture’ ... done
[16:01:40.330] Created future:
[16:01:40.330] SequentialFuture:
[16:01:40.330] Label: ‘future_apply-1’
[16:01:40.330] Expression:
[16:01:40.330] {
[16:01:40.330]     do.call(function(...) {
[16:01:40.330]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.330]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.330]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.330]             on.exit(options(oopts), add = TRUE)
[16:01:40.330]         }
[16:01:40.330]         {
[16:01:40.330]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.330]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.330]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:01:40.330]                   envir = globalenv(), inherits = FALSE)
[16:01:40.330]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.330]             })
[16:01:40.330]         }
[16:01:40.330]     }, args = future.call.arguments)
[16:01:40.330] }
[16:01:40.330] Lazy evaluation: FALSE
[16:01:40.330] Asynchronous evaluation: FALSE
[16:01:40.330] Local evaluation: TRUE
[16:01:40.330] Environment: R_GlobalEnv
[16:01:40.330] Capture standard output: TRUE
[16:01:40.330] Capture condition classes: <none>
[16:01:40.330] Globals: 5 objects totaling 35.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 112 bytes, list ‘...future.seeds_ii’ of 160 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:40.330] Packages: <none>
[16:01:40.330] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[16:01:40.330] Resolved: TRUE
[16:01:40.330] Value: 112 bytes of class ‘list’
[16:01:40.330] Early signaling: FALSE
[16:01:40.330] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:40.330] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:01:40.331] Chunk #1 of 1 ... DONE
[16:01:40.331] Launching 1 futures (chunks) ... DONE
[16:01:40.331] Resolving 1 futures (chunks) ...
[16:01:40.331] resolve() on list ...
[16:01:40.331]  recursive: 0
[16:01:40.331]  length: 1
[16:01:40.331] 
[16:01:40.332] resolved() for ‘SequentialFuture’ ...
[16:01:40.332] - state: ‘finished’
[16:01:40.332] - run: TRUE
[16:01:40.332] - result: ‘FutureResult’
[16:01:40.332] resolved() for ‘SequentialFuture’ ... done
[16:01:40.332] Future #1
[16:01:40.332] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:01:40.332] - nx: 1
[16:01:40.332] - relay: TRUE
[16:01:40.332] - stdout: TRUE
[16:01:40.333] - signal: TRUE
[16:01:40.333] - resignal: FALSE
[16:01:40.333] - force: TRUE
[16:01:40.333] - relayed: [n=1] FALSE
[16:01:40.333] - queued futures: [n=1] FALSE
[16:01:40.333]  - until=1
[16:01:40.333]  - relaying element #1
[16:01:40.333] - relayed: [n=1] TRUE
[16:01:40.333] - queued futures: [n=1] TRUE
[16:01:40.333] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:01:40.334]  length: 0 (resolved future 1)
[16:01:40.334] Relaying remaining futures
[16:01:40.334] signalConditionsASAP(NULL, pos=0) ...
[16:01:40.334] - nx: 1
[16:01:40.334] - relay: TRUE
[16:01:40.334] - stdout: TRUE
[16:01:40.334] - signal: TRUE
[16:01:40.334] - resignal: FALSE
[16:01:40.334] - force: TRUE
[16:01:40.334] - relayed: [n=1] TRUE
[16:01:40.334] - queued futures: [n=1] TRUE
 - flush all
[16:01:40.334] - relayed: [n=1] TRUE
[16:01:40.335] - queued futures: [n=1] TRUE
[16:01:40.335] signalConditionsASAP(NULL, pos=0) ... done
[16:01:40.335] resolve() on list ... DONE
[16:01:40.335]  - Number of value chunks collected: 1
[16:01:40.335] Resolving 1 futures (chunks) ... DONE
[16:01:40.335] Reducing values from 1 chunks ...
[16:01:40.335]  - Number of values collected after concatenation: 2
[16:01:40.335]  - Number of values expected: 2
[16:01:40.335] Reducing values from 1 chunks ... DONE
[16:01:40.335] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[16:01:40.336] plan(): Setting new future strategy stack:
[16:01:40.336] List of future strategies:
[16:01:40.336] 1. sequential:
[16:01:40.336]    - args: function (..., envir = parent.frame())
[16:01:40.336]    - tweaked: FALSE
[16:01:40.336]    - call: plan(sequential)
[16:01:40.336] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[16:01:40.337] plan(): Setting new future strategy stack:
[16:01:40.337] List of future strategies:
[16:01:40.337] 1. multicore:
[16:01:40.337]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:40.337]    - tweaked: FALSE
[16:01:40.337]    - call: plan(strategy)
[16:01:40.341] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[16:01:40.341] getGlobalsAndPackagesXApply() ...
[16:01:40.341]  - future.globals: TRUE
[16:01:40.341] getGlobalsAndPackages() ...
[16:01:40.341] Searching for globals...
[16:01:40.376] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[16:01:40.376] Searching for globals ... DONE
[16:01:40.377] Resolving globals: FALSE
[16:01:40.379] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[16:01:40.380] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[16:01:40.380] - globals: [1] ‘FUN’
[16:01:40.380] 
[16:01:40.380] getGlobalsAndPackages() ... DONE
[16:01:40.380]  - globals found/used: [n=1] ‘FUN’
[16:01:40.380]  - needed namespaces: [n=0] 
[16:01:40.381] Finding globals ... DONE
[16:01:40.381]  - use_args: TRUE
[16:01:40.381]  - Getting '...' globals ...
[16:01:40.381] resolve() on list ...
[16:01:40.381]  recursive: 0
[16:01:40.381]  length: 1
[16:01:40.381]  elements: ‘...’
[16:01:40.381]  length: 0 (resolved future 1)
[16:01:40.382] resolve() on list ... DONE
[16:01:40.382]    - '...' content: [n=0] 
[16:01:40.382] List of 1
[16:01:40.382]  $ ...: list()
[16:01:40.382]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.382]  - attr(*, "where")=List of 1
[16:01:40.382]   ..$ ...:<environment: 0x55fb64c86f50> 
[16:01:40.382]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.382]  - attr(*, "resolved")= logi TRUE
[16:01:40.382]  - attr(*, "total_size")= num NA
[16:01:40.384]  - Getting '...' globals ... DONE
[16:01:40.384] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:40.385] List of 2
[16:01:40.385]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:01:40.385]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:01:40.385]  $ ...          : list()
[16:01:40.385]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.385]  - attr(*, "where")=List of 2
[16:01:40.385]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:40.385]   ..$ ...          :<environment: 0x55fb64c86f50> 
[16:01:40.385]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.385]  - attr(*, "resolved")= logi FALSE
[16:01:40.385]  - attr(*, "total_size")= num 354224
[16:01:40.387] Packages to be attached in all futures: [n=0] 
[16:01:40.387] getGlobalsAndPackagesXApply() ... DONE
[16:01:40.391] future_lapply() ...
[16:01:40.428] Number of chunks: 2
[16:01:40.428] getGlobalsAndPackagesXApply() ...
[16:01:40.428]  - future.globals: <name-value list> with names ‘list()’
[16:01:40.428]  - use_args: TRUE
[16:01:40.428] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:01:40.428] List of 2
[16:01:40.428]  $ ...          : list()
[16:01:40.428]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.428]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:01:40.428]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:01:40.428]  - attr(*, "where")=List of 2
[16:01:40.428]   ..$ ...          :<environment: 0x55fb64c86f50> 
[16:01:40.428]   ..$ ...future.FUN:<environment: namespace:base> 
[16:01:40.428]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.428]  - attr(*, "resolved")= logi FALSE
[16:01:40.428]  - attr(*, "total_size")= num NA
[16:01:40.432] Packages to be attached in all futures: [n=0] 
[16:01:40.432] getGlobalsAndPackagesXApply() ... DONE
[16:01:40.432] Number of futures (= number of chunks): 2
[16:01:40.433] Launching 2 futures (chunks) ...
[16:01:40.433] Chunk #1 of 2 ...
[16:01:40.433]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:40.433]  - seeds: <none>
[16:01:40.433]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.433] getGlobalsAndPackages() ...
[16:01:40.433] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.433] Resolving globals: FALSE
[16:01:40.433] Tweak future expression to call with '...' arguments ...
[16:01:40.434] {
[16:01:40.434]     do.call(function(...) {
[16:01:40.434]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.434]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.434]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.434]             on.exit(options(oopts), add = TRUE)
[16:01:40.434]         }
[16:01:40.434]         {
[16:01:40.434]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.434]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.434]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.434]             })
[16:01:40.434]         }
[16:01:40.434]     }, args = future.call.arguments)
[16:01:40.434] }
[16:01:40.434] Tweak future expression to call with '...' arguments ... DONE
[16:01:40.434] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.434] 
[16:01:40.434] getGlobalsAndPackages() ... DONE
[16:01:40.435] run() for ‘Future’ ...
[16:01:40.435] - state: ‘created’
[16:01:40.435] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:40.439] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:40.439] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:40.439]   - Field: ‘label’
[16:01:40.439]   - Field: ‘local’
[16:01:40.439]   - Field: ‘owner’
[16:01:40.439]   - Field: ‘envir’
[16:01:40.439]   - Field: ‘workers’
[16:01:40.440]   - Field: ‘packages’
[16:01:40.440]   - Field: ‘gc’
[16:01:40.440]   - Field: ‘job’
[16:01:40.440]   - Field: ‘conditions’
[16:01:40.440]   - Field: ‘expr’
[16:01:40.440]   - Field: ‘uuid’
[16:01:40.440]   - Field: ‘seed’
[16:01:40.440]   - Field: ‘version’
[16:01:40.440]   - Field: ‘result’
[16:01:40.440]   - Field: ‘asynchronous’
[16:01:40.440]   - Field: ‘calls’
[16:01:40.441]   - Field: ‘globals’
[16:01:40.441]   - Field: ‘stdout’
[16:01:40.441]   - Field: ‘earlySignal’
[16:01:40.441]   - Field: ‘lazy’
[16:01:40.441]   - Field: ‘state’
[16:01:40.441] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:40.441] - Launch lazy future ...
[16:01:40.442] Packages needed by the future expression (n = 0): <none>
[16:01:40.442] Packages needed by future strategies (n = 0): <none>
[16:01:40.443] {
[16:01:40.443]     {
[16:01:40.443]         {
[16:01:40.443]             ...future.startTime <- base::Sys.time()
[16:01:40.443]             {
[16:01:40.443]                 {
[16:01:40.443]                   {
[16:01:40.443]                     {
[16:01:40.443]                       base::local({
[16:01:40.443]                         has_future <- base::requireNamespace("future", 
[16:01:40.443]                           quietly = TRUE)
[16:01:40.443]                         if (has_future) {
[16:01:40.443]                           ns <- base::getNamespace("future")
[16:01:40.443]                           version <- ns[[".package"]][["version"]]
[16:01:40.443]                           if (is.null(version)) 
[16:01:40.443]                             version <- utils::packageVersion("future")
[16:01:40.443]                         }
[16:01:40.443]                         else {
[16:01:40.443]                           version <- NULL
[16:01:40.443]                         }
[16:01:40.443]                         if (!has_future || version < "1.8.0") {
[16:01:40.443]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:40.443]                             "", base::R.version$version.string), 
[16:01:40.443]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:40.443]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:40.443]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:40.443]                               "release", "version")], collapse = " "), 
[16:01:40.443]                             hostname = base::Sys.info()[["nodename"]])
[16:01:40.443]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:40.443]                             info)
[16:01:40.443]                           info <- base::paste(info, collapse = "; ")
[16:01:40.443]                           if (!has_future) {
[16:01:40.443]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:40.443]                               info)
[16:01:40.443]                           }
[16:01:40.443]                           else {
[16:01:40.443]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:40.443]                               info, version)
[16:01:40.443]                           }
[16:01:40.443]                           base::stop(msg)
[16:01:40.443]                         }
[16:01:40.443]                       })
[16:01:40.443]                     }
[16:01:40.443]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:40.443]                     base::options(mc.cores = 1L)
[16:01:40.443]                   }
[16:01:40.443]                   options(future.plan = NULL)
[16:01:40.443]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:40.443]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:40.443]                 }
[16:01:40.443]                 ...future.workdir <- getwd()
[16:01:40.443]             }
[16:01:40.443]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:40.443]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:40.443]         }
[16:01:40.443]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:40.443]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:40.443]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:40.443]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:40.443]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:40.443]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:40.443]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:40.443]             base::names(...future.oldOptions))
[16:01:40.443]     }
[16:01:40.443]     if (FALSE) {
[16:01:40.443]     }
[16:01:40.443]     else {
[16:01:40.443]         if (TRUE) {
[16:01:40.443]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:40.443]                 open = "w")
[16:01:40.443]         }
[16:01:40.443]         else {
[16:01:40.443]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:40.443]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:40.443]         }
[16:01:40.443]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:40.443]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:40.443]             base::sink(type = "output", split = FALSE)
[16:01:40.443]             base::close(...future.stdout)
[16:01:40.443]         }, add = TRUE)
[16:01:40.443]     }
[16:01:40.443]     ...future.frame <- base::sys.nframe()
[16:01:40.443]     ...future.conditions <- base::list()
[16:01:40.443]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:40.443]     if (FALSE) {
[16:01:40.443]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:40.443]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:40.443]     }
[16:01:40.443]     ...future.result <- base::tryCatch({
[16:01:40.443]         base::withCallingHandlers({
[16:01:40.443]             ...future.value <- base::withVisible(base::local({
[16:01:40.443]                 withCallingHandlers({
[16:01:40.443]                   {
[16:01:40.443]                     do.call(function(...) {
[16:01:40.443]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.443]                       if (!identical(...future.globals.maxSize.org, 
[16:01:40.443]                         ...future.globals.maxSize)) {
[16:01:40.443]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.443]                         on.exit(options(oopts), add = TRUE)
[16:01:40.443]                       }
[16:01:40.443]                       {
[16:01:40.443]                         lapply(seq_along(...future.elements_ii), 
[16:01:40.443]                           FUN = function(jj) {
[16:01:40.443]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.443]                             ...future.FUN(...future.X_jj, ...)
[16:01:40.443]                           })
[16:01:40.443]                       }
[16:01:40.443]                     }, args = future.call.arguments)
[16:01:40.443]                   }
[16:01:40.443]                 }, immediateCondition = function(cond) {
[16:01:40.443]                   save_rds <- function (object, pathname, ...) 
[16:01:40.443]                   {
[16:01:40.443]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:40.443]                     if (file_test("-f", pathname_tmp)) {
[16:01:40.443]                       fi_tmp <- file.info(pathname_tmp)
[16:01:40.443]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:40.443]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:40.443]                         fi_tmp[["mtime"]])
[16:01:40.443]                     }
[16:01:40.443]                     tryCatch({
[16:01:40.443]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:40.443]                     }, error = function(ex) {
[16:01:40.443]                       msg <- conditionMessage(ex)
[16:01:40.443]                       fi_tmp <- file.info(pathname_tmp)
[16:01:40.443]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:40.443]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:40.443]                         fi_tmp[["mtime"]], msg)
[16:01:40.443]                       ex$message <- msg
[16:01:40.443]                       stop(ex)
[16:01:40.443]                     })
[16:01:40.443]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:40.443]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:40.443]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:40.443]                       fi_tmp <- file.info(pathname_tmp)
[16:01:40.443]                       fi <- file.info(pathname)
[16:01:40.443]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:40.443]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:40.443]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:40.443]                         fi[["size"]], fi[["mtime"]])
[16:01:40.443]                       stop(msg)
[16:01:40.443]                     }
[16:01:40.443]                     invisible(pathname)
[16:01:40.443]                   }
[16:01:40.443]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:40.443]                     rootPath = tempdir()) 
[16:01:40.443]                   {
[16:01:40.443]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:40.443]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:40.443]                       tmpdir = path, fileext = ".rds")
[16:01:40.443]                     save_rds(obj, file)
[16:01:40.443]                   }
[16:01:40.443]                   saveImmediateCondition(cond, path = "/tmp/RtmplAoKyr/.future/immediateConditions")
[16:01:40.443]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.443]                   {
[16:01:40.443]                     inherits <- base::inherits
[16:01:40.443]                     invokeRestart <- base::invokeRestart
[16:01:40.443]                     is.null <- base::is.null
[16:01:40.443]                     muffled <- FALSE
[16:01:40.443]                     if (inherits(cond, "message")) {
[16:01:40.443]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:40.443]                       if (muffled) 
[16:01:40.443]                         invokeRestart("muffleMessage")
[16:01:40.443]                     }
[16:01:40.443]                     else if (inherits(cond, "warning")) {
[16:01:40.443]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:40.443]                       if (muffled) 
[16:01:40.443]                         invokeRestart("muffleWarning")
[16:01:40.443]                     }
[16:01:40.443]                     else if (inherits(cond, "condition")) {
[16:01:40.443]                       if (!is.null(pattern)) {
[16:01:40.443]                         computeRestarts <- base::computeRestarts
[16:01:40.443]                         grepl <- base::grepl
[16:01:40.443]                         restarts <- computeRestarts(cond)
[16:01:40.443]                         for (restart in restarts) {
[16:01:40.443]                           name <- restart$name
[16:01:40.443]                           if (is.null(name)) 
[16:01:40.443]                             next
[16:01:40.443]                           if (!grepl(pattern, name)) 
[16:01:40.443]                             next
[16:01:40.443]                           invokeRestart(restart)
[16:01:40.443]                           muffled <- TRUE
[16:01:40.443]                           break
[16:01:40.443]                         }
[16:01:40.443]                       }
[16:01:40.443]                     }
[16:01:40.443]                     invisible(muffled)
[16:01:40.443]                   }
[16:01:40.443]                   muffleCondition(cond)
[16:01:40.443]                 })
[16:01:40.443]             }))
[16:01:40.443]             future::FutureResult(value = ...future.value$value, 
[16:01:40.443]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:40.443]                   ...future.rng), globalenv = if (FALSE) 
[16:01:40.443]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:40.443]                     ...future.globalenv.names))
[16:01:40.443]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:40.443]         }, condition = base::local({
[16:01:40.443]             c <- base::c
[16:01:40.443]             inherits <- base::inherits
[16:01:40.443]             invokeRestart <- base::invokeRestart
[16:01:40.443]             length <- base::length
[16:01:40.443]             list <- base::list
[16:01:40.443]             seq.int <- base::seq.int
[16:01:40.443]             signalCondition <- base::signalCondition
[16:01:40.443]             sys.calls <- base::sys.calls
[16:01:40.443]             `[[` <- base::`[[`
[16:01:40.443]             `+` <- base::`+`
[16:01:40.443]             `<<-` <- base::`<<-`
[16:01:40.443]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:40.443]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:40.443]                   3L)]
[16:01:40.443]             }
[16:01:40.443]             function(cond) {
[16:01:40.443]                 is_error <- inherits(cond, "error")
[16:01:40.443]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:40.443]                   NULL)
[16:01:40.443]                 if (is_error) {
[16:01:40.443]                   sessionInformation <- function() {
[16:01:40.443]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:40.443]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:40.443]                       search = base::search(), system = base::Sys.info())
[16:01:40.443]                   }
[16:01:40.443]                   ...future.conditions[[length(...future.conditions) + 
[16:01:40.443]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:40.443]                     cond$call), session = sessionInformation(), 
[16:01:40.443]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:40.443]                   signalCondition(cond)
[16:01:40.443]                 }
[16:01:40.443]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:40.443]                 "immediateCondition"))) {
[16:01:40.443]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:40.443]                   ...future.conditions[[length(...future.conditions) + 
[16:01:40.443]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:40.443]                   if (TRUE && !signal) {
[16:01:40.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.443]                     {
[16:01:40.443]                       inherits <- base::inherits
[16:01:40.443]                       invokeRestart <- base::invokeRestart
[16:01:40.443]                       is.null <- base::is.null
[16:01:40.443]                       muffled <- FALSE
[16:01:40.443]                       if (inherits(cond, "message")) {
[16:01:40.443]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:40.443]                         if (muffled) 
[16:01:40.443]                           invokeRestart("muffleMessage")
[16:01:40.443]                       }
[16:01:40.443]                       else if (inherits(cond, "warning")) {
[16:01:40.443]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:40.443]                         if (muffled) 
[16:01:40.443]                           invokeRestart("muffleWarning")
[16:01:40.443]                       }
[16:01:40.443]                       else if (inherits(cond, "condition")) {
[16:01:40.443]                         if (!is.null(pattern)) {
[16:01:40.443]                           computeRestarts <- base::computeRestarts
[16:01:40.443]                           grepl <- base::grepl
[16:01:40.443]                           restarts <- computeRestarts(cond)
[16:01:40.443]                           for (restart in restarts) {
[16:01:40.443]                             name <- restart$name
[16:01:40.443]                             if (is.null(name)) 
[16:01:40.443]                               next
[16:01:40.443]                             if (!grepl(pattern, name)) 
[16:01:40.443]                               next
[16:01:40.443]                             invokeRestart(restart)
[16:01:40.443]                             muffled <- TRUE
[16:01:40.443]                             break
[16:01:40.443]                           }
[16:01:40.443]                         }
[16:01:40.443]                       }
[16:01:40.443]                       invisible(muffled)
[16:01:40.443]                     }
[16:01:40.443]                     muffleCondition(cond, pattern = "^muffle")
[16:01:40.443]                   }
[16:01:40.443]                 }
[16:01:40.443]                 else {
[16:01:40.443]                   if (TRUE) {
[16:01:40.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.443]                     {
[16:01:40.443]                       inherits <- base::inherits
[16:01:40.443]                       invokeRestart <- base::invokeRestart
[16:01:40.443]                       is.null <- base::is.null
[16:01:40.443]                       muffled <- FALSE
[16:01:40.443]                       if (inherits(cond, "message")) {
[16:01:40.443]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:40.443]                         if (muffled) 
[16:01:40.443]                           invokeRestart("muffleMessage")
[16:01:40.443]                       }
[16:01:40.443]                       else if (inherits(cond, "warning")) {
[16:01:40.443]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:40.443]                         if (muffled) 
[16:01:40.443]                           invokeRestart("muffleWarning")
[16:01:40.443]                       }
[16:01:40.443]                       else if (inherits(cond, "condition")) {
[16:01:40.443]                         if (!is.null(pattern)) {
[16:01:40.443]                           computeRestarts <- base::computeRestarts
[16:01:40.443]                           grepl <- base::grepl
[16:01:40.443]                           restarts <- computeRestarts(cond)
[16:01:40.443]                           for (restart in restarts) {
[16:01:40.443]                             name <- restart$name
[16:01:40.443]                             if (is.null(name)) 
[16:01:40.443]                               next
[16:01:40.443]                             if (!grepl(pattern, name)) 
[16:01:40.443]                               next
[16:01:40.443]                             invokeRestart(restart)
[16:01:40.443]                             muffled <- TRUE
[16:01:40.443]                             break
[16:01:40.443]                           }
[16:01:40.443]                         }
[16:01:40.443]                       }
[16:01:40.443]                       invisible(muffled)
[16:01:40.443]                     }
[16:01:40.443]                     muffleCondition(cond, pattern = "^muffle")
[16:01:40.443]                   }
[16:01:40.443]                 }
[16:01:40.443]             }
[16:01:40.443]         }))
[16:01:40.443]     }, error = function(ex) {
[16:01:40.443]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:40.443]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:40.443]                 ...future.rng), started = ...future.startTime, 
[16:01:40.443]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:40.443]             version = "1.8"), class = "FutureResult")
[16:01:40.443]     }, finally = {
[16:01:40.443]         if (!identical(...future.workdir, getwd())) 
[16:01:40.443]             setwd(...future.workdir)
[16:01:40.443]         {
[16:01:40.443]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:40.443]                 ...future.oldOptions$nwarnings <- NULL
[16:01:40.443]             }
[16:01:40.443]             base::options(...future.oldOptions)
[16:01:40.443]             if (.Platform$OS.type == "windows") {
[16:01:40.443]                 old_names <- names(...future.oldEnvVars)
[16:01:40.443]                 envs <- base::Sys.getenv()
[16:01:40.443]                 names <- names(envs)
[16:01:40.443]                 common <- intersect(names, old_names)
[16:01:40.443]                 added <- setdiff(names, old_names)
[16:01:40.443]                 removed <- setdiff(old_names, names)
[16:01:40.443]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:40.443]                   envs[common]]
[16:01:40.443]                 NAMES <- toupper(changed)
[16:01:40.443]                 args <- list()
[16:01:40.443]                 for (kk in seq_along(NAMES)) {
[16:01:40.443]                   name <- changed[[kk]]
[16:01:40.443]                   NAME <- NAMES[[kk]]
[16:01:40.443]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.443]                     next
[16:01:40.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:40.443]                 }
[16:01:40.443]                 NAMES <- toupper(added)
[16:01:40.443]                 for (kk in seq_along(NAMES)) {
[16:01:40.443]                   name <- added[[kk]]
[16:01:40.443]                   NAME <- NAMES[[kk]]
[16:01:40.443]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.443]                     next
[16:01:40.443]                   args[[name]] <- ""
[16:01:40.443]                 }
[16:01:40.443]                 NAMES <- toupper(removed)
[16:01:40.443]                 for (kk in seq_along(NAMES)) {
[16:01:40.443]                   name <- removed[[kk]]
[16:01:40.443]                   NAME <- NAMES[[kk]]
[16:01:40.443]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.443]                     next
[16:01:40.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:40.443]                 }
[16:01:40.443]                 if (length(args) > 0) 
[16:01:40.443]                   base::do.call(base::Sys.setenv, args = args)
[16:01:40.443]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:40.443]             }
[16:01:40.443]             else {
[16:01:40.443]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:40.443]             }
[16:01:40.443]             {
[16:01:40.443]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:40.443]                   0L) {
[16:01:40.443]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:40.443]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:40.443]                   base::options(opts)
[16:01:40.443]                 }
[16:01:40.443]                 {
[16:01:40.443]                   {
[16:01:40.443]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:40.443]                     NULL
[16:01:40.443]                   }
[16:01:40.443]                   options(future.plan = NULL)
[16:01:40.443]                   if (is.na(NA_character_)) 
[16:01:40.443]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:40.443]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:40.443]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:40.443]                     envir = parent.frame()) 
[16:01:40.443]                   {
[16:01:40.443]                     default_workers <- missing(workers)
[16:01:40.443]                     if (is.function(workers)) 
[16:01:40.443]                       workers <- workers()
[16:01:40.443]                     workers <- structure(as.integer(workers), 
[16:01:40.443]                       class = class(workers))
[16:01:40.443]                     stop_if_not(is.finite(workers), workers >= 
[16:01:40.443]                       1L)
[16:01:40.443]                     if ((workers == 1L && !inherits(workers, 
[16:01:40.443]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:40.443]                       if (default_workers) 
[16:01:40.443]                         supportsMulticore(warn = TRUE)
[16:01:40.443]                       return(sequential(..., envir = envir))
[16:01:40.443]                     }
[16:01:40.443]                     oopts <- options(mc.cores = workers)
[16:01:40.443]                     on.exit(options(oopts))
[16:01:40.443]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:40.443]                       envir = envir)
[16:01:40.443]                     if (!future$lazy) 
[16:01:40.443]                       future <- run(future)
[16:01:40.443]                     invisible(future)
[16:01:40.443]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:40.443]                 }
[16:01:40.443]             }
[16:01:40.443]         }
[16:01:40.443]     })
[16:01:40.443]     if (TRUE) {
[16:01:40.443]         base::sink(type = "output", split = FALSE)
[16:01:40.443]         if (TRUE) {
[16:01:40.443]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:40.443]         }
[16:01:40.443]         else {
[16:01:40.443]             ...future.result["stdout"] <- base::list(NULL)
[16:01:40.443]         }
[16:01:40.443]         base::close(...future.stdout)
[16:01:40.443]         ...future.stdout <- NULL
[16:01:40.443]     }
[16:01:40.443]     ...future.result$conditions <- ...future.conditions
[16:01:40.443]     ...future.result$finished <- base::Sys.time()
[16:01:40.443]     ...future.result
[16:01:40.443] }
[16:01:40.445] assign_globals() ...
[16:01:40.445] List of 5
[16:01:40.445]  $ future.call.arguments    : list()
[16:01:40.445]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.445]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:01:40.445]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:01:40.445]  $ ...future.elements_ii    :List of 1
[16:01:40.445]   ..$ : num [1:4] 1 3 1 7
[16:01:40.445]  $ ...future.seeds_ii       : NULL
[16:01:40.445]  $ ...future.globals.maxSize: num Inf
[16:01:40.445]  - attr(*, "resolved")= logi FALSE
[16:01:40.445]  - attr(*, "total_size")= num NA
[16:01:40.445]  - attr(*, "where")=List of 5
[16:01:40.445]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:40.445]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:40.445]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:40.445]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:40.445]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:40.445]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.445]  - attr(*, "already-done")= logi TRUE
[16:01:40.452] - copied ‘future.call.arguments’ to environment
[16:01:40.453] - copied ‘...future.FUN’ to environment
[16:01:40.453] - copied ‘...future.elements_ii’ to environment
[16:01:40.453] - copied ‘...future.seeds_ii’ to environment
[16:01:40.453] - copied ‘...future.globals.maxSize’ to environment
[16:01:40.453] assign_globals() ... done
[16:01:40.453] requestCore(): workers = 2
[16:01:40.456] MulticoreFuture started
[16:01:40.457] - Launch lazy future ... done
[16:01:40.457] plan(): Setting new future strategy stack:
[16:01:40.457] run() for ‘MulticoreFuture’ ... done
[16:01:40.458] Created future:
[16:01:40.457] List of future strategies:
[16:01:40.457] 1. sequential:
[16:01:40.457]    - args: function (..., envir = parent.frame())
[16:01:40.457]    - tweaked: FALSE
[16:01:40.457]    - call: NULL
[16:01:40.459] plan(): nbrOfWorkers() = 1
[16:01:40.461] plan(): Setting new future strategy stack:
[16:01:40.461] List of future strategies:
[16:01:40.461] 1. multicore:
[16:01:40.461]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:40.461]    - tweaked: FALSE
[16:01:40.461]    - call: plan(strategy)
[16:01:40.467] plan(): nbrOfWorkers() = 2
[16:01:40.458] MulticoreFuture:
[16:01:40.458] Label: ‘future_apply-1’
[16:01:40.458] Expression:
[16:01:40.458] {
[16:01:40.458]     do.call(function(...) {
[16:01:40.458]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.458]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.458]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.458]             on.exit(options(oopts), add = TRUE)
[16:01:40.458]         }
[16:01:40.458]         {
[16:01:40.458]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.458]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.458]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.458]             })
[16:01:40.458]         }
[16:01:40.458]     }, args = future.call.arguments)
[16:01:40.458] }
[16:01:40.458] Lazy evaluation: FALSE
[16:01:40.458] Asynchronous evaluation: TRUE
[16:01:40.458] Local evaluation: TRUE
[16:01:40.458] Environment: R_GlobalEnv
[16:01:40.458] Capture standard output: TRUE
[16:01:40.458] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:40.458] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:40.458] Packages: <none>
[16:01:40.458] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:40.458] Resolved: TRUE
[16:01:40.458] Value: <not collected>
[16:01:40.458] Conditions captured: <none>
[16:01:40.458] Early signaling: FALSE
[16:01:40.458] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:40.458] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:40.468] Chunk #1 of 2 ... DONE
[16:01:40.468] Chunk #2 of 2 ...
[16:01:40.468]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:40.469]  - seeds: <none>
[16:01:40.469]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.469] getGlobalsAndPackages() ...
[16:01:40.469] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.469] Resolving globals: FALSE
[16:01:40.469] Tweak future expression to call with '...' arguments ...
[16:01:40.470] {
[16:01:40.470]     do.call(function(...) {
[16:01:40.470]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.470]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.470]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.470]             on.exit(options(oopts), add = TRUE)
[16:01:40.470]         }
[16:01:40.470]         {
[16:01:40.470]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.470]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.470]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.470]             })
[16:01:40.470]         }
[16:01:40.470]     }, args = future.call.arguments)
[16:01:40.470] }
[16:01:40.470] Tweak future expression to call with '...' arguments ... DONE
[16:01:40.471] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.471] 
[16:01:40.471] getGlobalsAndPackages() ... DONE
[16:01:40.472] run() for ‘Future’ ...
[16:01:40.472] - state: ‘created’
[16:01:40.472] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:40.476] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:40.477] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:40.477]   - Field: ‘label’
[16:01:40.477]   - Field: ‘local’
[16:01:40.477]   - Field: ‘owner’
[16:01:40.477]   - Field: ‘envir’
[16:01:40.477]   - Field: ‘workers’
[16:01:40.478]   - Field: ‘packages’
[16:01:40.478]   - Field: ‘gc’
[16:01:40.478]   - Field: ‘job’
[16:01:40.478]   - Field: ‘conditions’
[16:01:40.478]   - Field: ‘expr’
[16:01:40.478]   - Field: ‘uuid’
[16:01:40.478]   - Field: ‘seed’
[16:01:40.479]   - Field: ‘version’
[16:01:40.479]   - Field: ‘result’
[16:01:40.479]   - Field: ‘asynchronous’
[16:01:40.479]   - Field: ‘calls’
[16:01:40.479]   - Field: ‘globals’
[16:01:40.479]   - Field: ‘stdout’
[16:01:40.480]   - Field: ‘earlySignal’
[16:01:40.480]   - Field: ‘lazy’
[16:01:40.480]   - Field: ‘state’
[16:01:40.480] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:40.480] - Launch lazy future ...
[16:01:40.481] Packages needed by the future expression (n = 0): <none>
[16:01:40.481] Packages needed by future strategies (n = 0): <none>
[16:01:40.481] {
[16:01:40.481]     {
[16:01:40.481]         {
[16:01:40.481]             ...future.startTime <- base::Sys.time()
[16:01:40.481]             {
[16:01:40.481]                 {
[16:01:40.481]                   {
[16:01:40.481]                     {
[16:01:40.481]                       base::local({
[16:01:40.481]                         has_future <- base::requireNamespace("future", 
[16:01:40.481]                           quietly = TRUE)
[16:01:40.481]                         if (has_future) {
[16:01:40.481]                           ns <- base::getNamespace("future")
[16:01:40.481]                           version <- ns[[".package"]][["version"]]
[16:01:40.481]                           if (is.null(version)) 
[16:01:40.481]                             version <- utils::packageVersion("future")
[16:01:40.481]                         }
[16:01:40.481]                         else {
[16:01:40.481]                           version <- NULL
[16:01:40.481]                         }
[16:01:40.481]                         if (!has_future || version < "1.8.0") {
[16:01:40.481]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:40.481]                             "", base::R.version$version.string), 
[16:01:40.481]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:40.481]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:40.481]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:40.481]                               "release", "version")], collapse = " "), 
[16:01:40.481]                             hostname = base::Sys.info()[["nodename"]])
[16:01:40.481]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:40.481]                             info)
[16:01:40.481]                           info <- base::paste(info, collapse = "; ")
[16:01:40.481]                           if (!has_future) {
[16:01:40.481]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:40.481]                               info)
[16:01:40.481]                           }
[16:01:40.481]                           else {
[16:01:40.481]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:40.481]                               info, version)
[16:01:40.481]                           }
[16:01:40.481]                           base::stop(msg)
[16:01:40.481]                         }
[16:01:40.481]                       })
[16:01:40.481]                     }
[16:01:40.481]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:40.481]                     base::options(mc.cores = 1L)
[16:01:40.481]                   }
[16:01:40.481]                   options(future.plan = NULL)
[16:01:40.481]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:40.481]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:40.481]                 }
[16:01:40.481]                 ...future.workdir <- getwd()
[16:01:40.481]             }
[16:01:40.481]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:40.481]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:40.481]         }
[16:01:40.481]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:40.481]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:40.481]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:40.481]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:40.481]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:40.481]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:40.481]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:40.481]             base::names(...future.oldOptions))
[16:01:40.481]     }
[16:01:40.481]     if (FALSE) {
[16:01:40.481]     }
[16:01:40.481]     else {
[16:01:40.481]         if (TRUE) {
[16:01:40.481]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:40.481]                 open = "w")
[16:01:40.481]         }
[16:01:40.481]         else {
[16:01:40.481]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:40.481]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:40.481]         }
[16:01:40.481]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:40.481]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:40.481]             base::sink(type = "output", split = FALSE)
[16:01:40.481]             base::close(...future.stdout)
[16:01:40.481]         }, add = TRUE)
[16:01:40.481]     }
[16:01:40.481]     ...future.frame <- base::sys.nframe()
[16:01:40.481]     ...future.conditions <- base::list()
[16:01:40.481]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:40.481]     if (FALSE) {
[16:01:40.481]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:40.481]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:40.481]     }
[16:01:40.481]     ...future.result <- base::tryCatch({
[16:01:40.481]         base::withCallingHandlers({
[16:01:40.481]             ...future.value <- base::withVisible(base::local({
[16:01:40.481]                 withCallingHandlers({
[16:01:40.481]                   {
[16:01:40.481]                     do.call(function(...) {
[16:01:40.481]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.481]                       if (!identical(...future.globals.maxSize.org, 
[16:01:40.481]                         ...future.globals.maxSize)) {
[16:01:40.481]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.481]                         on.exit(options(oopts), add = TRUE)
[16:01:40.481]                       }
[16:01:40.481]                       {
[16:01:40.481]                         lapply(seq_along(...future.elements_ii), 
[16:01:40.481]                           FUN = function(jj) {
[16:01:40.481]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.481]                             ...future.FUN(...future.X_jj, ...)
[16:01:40.481]                           })
[16:01:40.481]                       }
[16:01:40.481]                     }, args = future.call.arguments)
[16:01:40.481]                   }
[16:01:40.481]                 }, immediateCondition = function(cond) {
[16:01:40.481]                   save_rds <- function (object, pathname, ...) 
[16:01:40.481]                   {
[16:01:40.481]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:40.481]                     if (file_test("-f", pathname_tmp)) {
[16:01:40.481]                       fi_tmp <- file.info(pathname_tmp)
[16:01:40.481]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:40.481]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:40.481]                         fi_tmp[["mtime"]])
[16:01:40.481]                     }
[16:01:40.481]                     tryCatch({
[16:01:40.481]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:40.481]                     }, error = function(ex) {
[16:01:40.481]                       msg <- conditionMessage(ex)
[16:01:40.481]                       fi_tmp <- file.info(pathname_tmp)
[16:01:40.481]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:40.481]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:40.481]                         fi_tmp[["mtime"]], msg)
[16:01:40.481]                       ex$message <- msg
[16:01:40.481]                       stop(ex)
[16:01:40.481]                     })
[16:01:40.481]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:40.481]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:40.481]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:40.481]                       fi_tmp <- file.info(pathname_tmp)
[16:01:40.481]                       fi <- file.info(pathname)
[16:01:40.481]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:40.481]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:40.481]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:40.481]                         fi[["size"]], fi[["mtime"]])
[16:01:40.481]                       stop(msg)
[16:01:40.481]                     }
[16:01:40.481]                     invisible(pathname)
[16:01:40.481]                   }
[16:01:40.481]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:40.481]                     rootPath = tempdir()) 
[16:01:40.481]                   {
[16:01:40.481]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:40.481]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:40.481]                       tmpdir = path, fileext = ".rds")
[16:01:40.481]                     save_rds(obj, file)
[16:01:40.481]                   }
[16:01:40.481]                   saveImmediateCondition(cond, path = "/tmp/RtmplAoKyr/.future/immediateConditions")
[16:01:40.481]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.481]                   {
[16:01:40.481]                     inherits <- base::inherits
[16:01:40.481]                     invokeRestart <- base::invokeRestart
[16:01:40.481]                     is.null <- base::is.null
[16:01:40.481]                     muffled <- FALSE
[16:01:40.481]                     if (inherits(cond, "message")) {
[16:01:40.481]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:40.481]                       if (muffled) 
[16:01:40.481]                         invokeRestart("muffleMessage")
[16:01:40.481]                     }
[16:01:40.481]                     else if (inherits(cond, "warning")) {
[16:01:40.481]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:40.481]                       if (muffled) 
[16:01:40.481]                         invokeRestart("muffleWarning")
[16:01:40.481]                     }
[16:01:40.481]                     else if (inherits(cond, "condition")) {
[16:01:40.481]                       if (!is.null(pattern)) {
[16:01:40.481]                         computeRestarts <- base::computeRestarts
[16:01:40.481]                         grepl <- base::grepl
[16:01:40.481]                         restarts <- computeRestarts(cond)
[16:01:40.481]                         for (restart in restarts) {
[16:01:40.481]                           name <- restart$name
[16:01:40.481]                           if (is.null(name)) 
[16:01:40.481]                             next
[16:01:40.481]                           if (!grepl(pattern, name)) 
[16:01:40.481]                             next
[16:01:40.481]                           invokeRestart(restart)
[16:01:40.481]                           muffled <- TRUE
[16:01:40.481]                           break
[16:01:40.481]                         }
[16:01:40.481]                       }
[16:01:40.481]                     }
[16:01:40.481]                     invisible(muffled)
[16:01:40.481]                   }
[16:01:40.481]                   muffleCondition(cond)
[16:01:40.481]                 })
[16:01:40.481]             }))
[16:01:40.481]             future::FutureResult(value = ...future.value$value, 
[16:01:40.481]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:40.481]                   ...future.rng), globalenv = if (FALSE) 
[16:01:40.481]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:40.481]                     ...future.globalenv.names))
[16:01:40.481]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:40.481]         }, condition = base::local({
[16:01:40.481]             c <- base::c
[16:01:40.481]             inherits <- base::inherits
[16:01:40.481]             invokeRestart <- base::invokeRestart
[16:01:40.481]             length <- base::length
[16:01:40.481]             list <- base::list
[16:01:40.481]             seq.int <- base::seq.int
[16:01:40.481]             signalCondition <- base::signalCondition
[16:01:40.481]             sys.calls <- base::sys.calls
[16:01:40.481]             `[[` <- base::`[[`
[16:01:40.481]             `+` <- base::`+`
[16:01:40.481]             `<<-` <- base::`<<-`
[16:01:40.481]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:40.481]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:40.481]                   3L)]
[16:01:40.481]             }
[16:01:40.481]             function(cond) {
[16:01:40.481]                 is_error <- inherits(cond, "error")
[16:01:40.481]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:40.481]                   NULL)
[16:01:40.481]                 if (is_error) {
[16:01:40.481]                   sessionInformation <- function() {
[16:01:40.481]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:40.481]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:40.481]                       search = base::search(), system = base::Sys.info())
[16:01:40.481]                   }
[16:01:40.481]                   ...future.conditions[[length(...future.conditions) + 
[16:01:40.481]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:40.481]                     cond$call), session = sessionInformation(), 
[16:01:40.481]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:40.481]                   signalCondition(cond)
[16:01:40.481]                 }
[16:01:40.481]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:40.481]                 "immediateCondition"))) {
[16:01:40.481]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:40.481]                   ...future.conditions[[length(...future.conditions) + 
[16:01:40.481]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:40.481]                   if (TRUE && !signal) {
[16:01:40.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.481]                     {
[16:01:40.481]                       inherits <- base::inherits
[16:01:40.481]                       invokeRestart <- base::invokeRestart
[16:01:40.481]                       is.null <- base::is.null
[16:01:40.481]                       muffled <- FALSE
[16:01:40.481]                       if (inherits(cond, "message")) {
[16:01:40.481]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:40.481]                         if (muffled) 
[16:01:40.481]                           invokeRestart("muffleMessage")
[16:01:40.481]                       }
[16:01:40.481]                       else if (inherits(cond, "warning")) {
[16:01:40.481]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:40.481]                         if (muffled) 
[16:01:40.481]                           invokeRestart("muffleWarning")
[16:01:40.481]                       }
[16:01:40.481]                       else if (inherits(cond, "condition")) {
[16:01:40.481]                         if (!is.null(pattern)) {
[16:01:40.481]                           computeRestarts <- base::computeRestarts
[16:01:40.481]                           grepl <- base::grepl
[16:01:40.481]                           restarts <- computeRestarts(cond)
[16:01:40.481]                           for (restart in restarts) {
[16:01:40.481]                             name <- restart$name
[16:01:40.481]                             if (is.null(name)) 
[16:01:40.481]                               next
[16:01:40.481]                             if (!grepl(pattern, name)) 
[16:01:40.481]                               next
[16:01:40.481]                             invokeRestart(restart)
[16:01:40.481]                             muffled <- TRUE
[16:01:40.481]                             break
[16:01:40.481]                           }
[16:01:40.481]                         }
[16:01:40.481]                       }
[16:01:40.481]                       invisible(muffled)
[16:01:40.481]                     }
[16:01:40.481]                     muffleCondition(cond, pattern = "^muffle")
[16:01:40.481]                   }
[16:01:40.481]                 }
[16:01:40.481]                 else {
[16:01:40.481]                   if (TRUE) {
[16:01:40.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.481]                     {
[16:01:40.481]                       inherits <- base::inherits
[16:01:40.481]                       invokeRestart <- base::invokeRestart
[16:01:40.481]                       is.null <- base::is.null
[16:01:40.481]                       muffled <- FALSE
[16:01:40.481]                       if (inherits(cond, "message")) {
[16:01:40.481]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:40.481]                         if (muffled) 
[16:01:40.481]                           invokeRestart("muffleMessage")
[16:01:40.481]                       }
[16:01:40.481]                       else if (inherits(cond, "warning")) {
[16:01:40.481]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:40.481]                         if (muffled) 
[16:01:40.481]                           invokeRestart("muffleWarning")
[16:01:40.481]                       }
[16:01:40.481]                       else if (inherits(cond, "condition")) {
[16:01:40.481]                         if (!is.null(pattern)) {
[16:01:40.481]                           computeRestarts <- base::computeRestarts
[16:01:40.481]                           grepl <- base::grepl
[16:01:40.481]                           restarts <- computeRestarts(cond)
[16:01:40.481]                           for (restart in restarts) {
[16:01:40.481]                             name <- restart$name
[16:01:40.481]                             if (is.null(name)) 
[16:01:40.481]                               next
[16:01:40.481]                             if (!grepl(pattern, name)) 
[16:01:40.481]                               next
[16:01:40.481]                             invokeRestart(restart)
[16:01:40.481]                             muffled <- TRUE
[16:01:40.481]                             break
[16:01:40.481]                           }
[16:01:40.481]                         }
[16:01:40.481]                       }
[16:01:40.481]                       invisible(muffled)
[16:01:40.481]                     }
[16:01:40.481]                     muffleCondition(cond, pattern = "^muffle")
[16:01:40.481]                   }
[16:01:40.481]                 }
[16:01:40.481]             }
[16:01:40.481]         }))
[16:01:40.481]     }, error = function(ex) {
[16:01:40.481]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:40.481]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:40.481]                 ...future.rng), started = ...future.startTime, 
[16:01:40.481]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:40.481]             version = "1.8"), class = "FutureResult")
[16:01:40.481]     }, finally = {
[16:01:40.481]         if (!identical(...future.workdir, getwd())) 
[16:01:40.481]             setwd(...future.workdir)
[16:01:40.481]         {
[16:01:40.481]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:40.481]                 ...future.oldOptions$nwarnings <- NULL
[16:01:40.481]             }
[16:01:40.481]             base::options(...future.oldOptions)
[16:01:40.481]             if (.Platform$OS.type == "windows") {
[16:01:40.481]                 old_names <- names(...future.oldEnvVars)
[16:01:40.481]                 envs <- base::Sys.getenv()
[16:01:40.481]                 names <- names(envs)
[16:01:40.481]                 common <- intersect(names, old_names)
[16:01:40.481]                 added <- setdiff(names, old_names)
[16:01:40.481]                 removed <- setdiff(old_names, names)
[16:01:40.481]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:40.481]                   envs[common]]
[16:01:40.481]                 NAMES <- toupper(changed)
[16:01:40.481]                 args <- list()
[16:01:40.481]                 for (kk in seq_along(NAMES)) {
[16:01:40.481]                   name <- changed[[kk]]
[16:01:40.481]                   NAME <- NAMES[[kk]]
[16:01:40.481]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.481]                     next
[16:01:40.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:40.481]                 }
[16:01:40.481]                 NAMES <- toupper(added)
[16:01:40.481]                 for (kk in seq_along(NAMES)) {
[16:01:40.481]                   name <- added[[kk]]
[16:01:40.481]                   NAME <- NAMES[[kk]]
[16:01:40.481]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.481]                     next
[16:01:40.481]                   args[[name]] <- ""
[16:01:40.481]                 }
[16:01:40.481]                 NAMES <- toupper(removed)
[16:01:40.481]                 for (kk in seq_along(NAMES)) {
[16:01:40.481]                   name <- removed[[kk]]
[16:01:40.481]                   NAME <- NAMES[[kk]]
[16:01:40.481]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.481]                     next
[16:01:40.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:40.481]                 }
[16:01:40.481]                 if (length(args) > 0) 
[16:01:40.481]                   base::do.call(base::Sys.setenv, args = args)
[16:01:40.481]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:40.481]             }
[16:01:40.481]             else {
[16:01:40.481]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:40.481]             }
[16:01:40.481]             {
[16:01:40.481]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:40.481]                   0L) {
[16:01:40.481]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:40.481]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:40.481]                   base::options(opts)
[16:01:40.481]                 }
[16:01:40.481]                 {
[16:01:40.481]                   {
[16:01:40.481]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:40.481]                     NULL
[16:01:40.481]                   }
[16:01:40.481]                   options(future.plan = NULL)
[16:01:40.481]                   if (is.na(NA_character_)) 
[16:01:40.481]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:40.481]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:40.481]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:40.481]                     envir = parent.frame()) 
[16:01:40.481]                   {
[16:01:40.481]                     default_workers <- missing(workers)
[16:01:40.481]                     if (is.function(workers)) 
[16:01:40.481]                       workers <- workers()
[16:01:40.481]                     workers <- structure(as.integer(workers), 
[16:01:40.481]                       class = class(workers))
[16:01:40.481]                     stop_if_not(is.finite(workers), workers >= 
[16:01:40.481]                       1L)
[16:01:40.481]                     if ((workers == 1L && !inherits(workers, 
[16:01:40.481]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:40.481]                       if (default_workers) 
[16:01:40.481]                         supportsMulticore(warn = TRUE)
[16:01:40.481]                       return(sequential(..., envir = envir))
[16:01:40.481]                     }
[16:01:40.481]                     oopts <- options(mc.cores = workers)
[16:01:40.481]                     on.exit(options(oopts))
[16:01:40.481]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:40.481]                       envir = envir)
[16:01:40.481]                     if (!future$lazy) 
[16:01:40.481]                       future <- run(future)
[16:01:40.481]                     invisible(future)
[16:01:40.481]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:40.481]                 }
[16:01:40.481]             }
[16:01:40.481]         }
[16:01:40.481]     })
[16:01:40.481]     if (TRUE) {
[16:01:40.481]         base::sink(type = "output", split = FALSE)
[16:01:40.481]         if (TRUE) {
[16:01:40.481]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:40.481]         }
[16:01:40.481]         else {
[16:01:40.481]             ...future.result["stdout"] <- base::list(NULL)
[16:01:40.481]         }
[16:01:40.481]         base::close(...future.stdout)
[16:01:40.481]         ...future.stdout <- NULL
[16:01:40.481]     }
[16:01:40.481]     ...future.result$conditions <- ...future.conditions
[16:01:40.481]     ...future.result$finished <- base::Sys.time()
[16:01:40.481]     ...future.result
[16:01:40.481] }
[16:01:40.485] assign_globals() ...
[16:01:40.485] List of 5
[16:01:40.485]  $ future.call.arguments    : list()
[16:01:40.485]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.485]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:01:40.485]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:01:40.485]  $ ...future.elements_ii    :List of 1
[16:01:40.485]   ..$ : num [1:4] 2 4 6 8
[16:01:40.485]  $ ...future.seeds_ii       : NULL
[16:01:40.485]  $ ...future.globals.maxSize: num Inf
[16:01:40.485]  - attr(*, "resolved")= logi FALSE
[16:01:40.485]  - attr(*, "total_size")= num NA
[16:01:40.485]  - attr(*, "where")=List of 5
[16:01:40.485]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:40.485]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:40.485]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:40.485]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:40.485]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:40.485]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.485]  - attr(*, "already-done")= logi TRUE
[16:01:40.492] - copied ‘future.call.arguments’ to environment
[16:01:40.492] - copied ‘...future.FUN’ to environment
[16:01:40.492] - copied ‘...future.elements_ii’ to environment
[16:01:40.493] - copied ‘...future.seeds_ii’ to environment
[16:01:40.493] - copied ‘...future.globals.maxSize’ to environment
[16:01:40.493] assign_globals() ... done
[16:01:40.493] requestCore(): workers = 2
[16:01:40.502] MulticoreFuture started
[16:01:40.503] - Launch lazy future ... done
[16:01:40.503] plan(): Setting new future strategy stack:
[16:01:40.503] run() for ‘MulticoreFuture’ ... done
[16:01:40.504] Created future:
[16:01:40.504] List of future strategies:
[16:01:40.504] 1. sequential:
[16:01:40.504]    - args: function (..., envir = parent.frame())
[16:01:40.504]    - tweaked: FALSE
[16:01:40.504]    - call: NULL
[16:01:40.505] plan(): nbrOfWorkers() = 1
[16:01:40.508] plan(): Setting new future strategy stack:
[16:01:40.508] List of future strategies:
[16:01:40.508] 1. multicore:
[16:01:40.508]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:40.508]    - tweaked: FALSE
[16:01:40.508]    - call: plan(strategy)
[16:01:40.514] plan(): nbrOfWorkers() = 2
[16:01:40.504] MulticoreFuture:
[16:01:40.504] Label: ‘future_apply-2’
[16:01:40.504] Expression:
[16:01:40.504] {
[16:01:40.504]     do.call(function(...) {
[16:01:40.504]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.504]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.504]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.504]             on.exit(options(oopts), add = TRUE)
[16:01:40.504]         }
[16:01:40.504]         {
[16:01:40.504]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.504]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.504]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.504]             })
[16:01:40.504]         }
[16:01:40.504]     }, args = future.call.arguments)
[16:01:40.504] }
[16:01:40.504] Lazy evaluation: FALSE
[16:01:40.504] Asynchronous evaluation: TRUE
[16:01:40.504] Local evaluation: TRUE
[16:01:40.504] Environment: R_GlobalEnv
[16:01:40.504] Capture standard output: TRUE
[16:01:40.504] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:40.504] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:40.504] Packages: <none>
[16:01:40.504] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:40.504] Resolved: TRUE
[16:01:40.504] Value: <not collected>
[16:01:40.504] Conditions captured: <none>
[16:01:40.504] Early signaling: FALSE
[16:01:40.504] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:40.504] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:40.515] Chunk #2 of 2 ... DONE
[16:01:40.515] Launching 2 futures (chunks) ... DONE
[16:01:40.515] Resolving 2 futures (chunks) ...
[16:01:40.516] resolve() on list ...
[16:01:40.516]  recursive: 0
[16:01:40.516]  length: 2
[16:01:40.516] 
[16:01:40.517] Future #1
[16:01:40.517] result() for MulticoreFuture ...
[16:01:40.519] result() for MulticoreFuture ...
[16:01:40.519] result() for MulticoreFuture ... done
[16:01:40.520] result() for MulticoreFuture ... done
[16:01:40.520] result() for MulticoreFuture ...
[16:01:40.520] result() for MulticoreFuture ... done
[16:01:40.520] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:01:40.520] - nx: 2
[16:01:40.521] - relay: TRUE
[16:01:40.521] - stdout: TRUE
[16:01:40.521] - signal: TRUE
[16:01:40.521] - resignal: FALSE
[16:01:40.521] - force: TRUE
[16:01:40.521] - relayed: [n=2] FALSE, FALSE
[16:01:40.521] - queued futures: [n=2] FALSE, FALSE
[16:01:40.522]  - until=1
[16:01:40.522]  - relaying element #1
[16:01:40.522] result() for MulticoreFuture ...
[16:01:40.522] result() for MulticoreFuture ... done
[16:01:40.522] result() for MulticoreFuture ...
[16:01:40.523] result() for MulticoreFuture ... done
[16:01:40.523] result() for MulticoreFuture ...
[16:01:40.523] result() for MulticoreFuture ... done
[16:01:40.523] result() for MulticoreFuture ...
[16:01:40.523] result() for MulticoreFuture ... done
[16:01:40.523] - relayed: [n=2] TRUE, FALSE
[16:01:40.524] - queued futures: [n=2] TRUE, FALSE
[16:01:40.524] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:01:40.524]  length: 1 (resolved future 1)
[16:01:40.524] Future #2
[16:01:40.524] result() for MulticoreFuture ...
[16:01:40.525] result() for MulticoreFuture ...
[16:01:40.525] result() for MulticoreFuture ... done
[16:01:40.525] result() for MulticoreFuture ... done
[16:01:40.525] result() for MulticoreFuture ...
[16:01:40.526] result() for MulticoreFuture ... done
[16:01:40.526] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:01:40.526] - nx: 2
[16:01:40.526] - relay: TRUE
[16:01:40.526] - stdout: TRUE
[16:01:40.526] - signal: TRUE
[16:01:40.526] - resignal: FALSE
[16:01:40.526] - force: TRUE
[16:01:40.526] - relayed: [n=2] TRUE, FALSE
[16:01:40.527] - queued futures: [n=2] TRUE, FALSE
[16:01:40.527]  - until=2
[16:01:40.527]  - relaying element #2
[16:01:40.527] result() for MulticoreFuture ...
[16:01:40.527] result() for MulticoreFuture ... done
[16:01:40.527] result() for MulticoreFuture ...
[16:01:40.527] result() for MulticoreFuture ... done
[16:01:40.527] result() for MulticoreFuture ...
[16:01:40.528] result() for MulticoreFuture ... done
[16:01:40.528] result() for MulticoreFuture ...
[16:01:40.528] result() for MulticoreFuture ... done
[16:01:40.528] - relayed: [n=2] TRUE, TRUE
[16:01:40.528] - queued futures: [n=2] TRUE, TRUE
[16:01:40.528] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:01:40.528]  length: 0 (resolved future 2)
[16:01:40.528] Relaying remaining futures
[16:01:40.528] signalConditionsASAP(NULL, pos=0) ...
[16:01:40.529] - nx: 2
[16:01:40.529] - relay: TRUE
[16:01:40.529] - stdout: TRUE
[16:01:40.529] - signal: TRUE
[16:01:40.529] - resignal: FALSE
[16:01:40.529] - force: TRUE
[16:01:40.529] - relayed: [n=2] TRUE, TRUE
[16:01:40.529] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:40.529] - relayed: [n=2] TRUE, TRUE
[16:01:40.530] - queued futures: [n=2] TRUE, TRUE
[16:01:40.530] signalConditionsASAP(NULL, pos=0) ... done
[16:01:40.530] resolve() on list ... DONE
[16:01:40.530] result() for MulticoreFuture ...
[16:01:40.530] result() for MulticoreFuture ... done
[16:01:40.530] result() for MulticoreFuture ...
[16:01:40.530] result() for MulticoreFuture ... done
[16:01:40.530] result() for MulticoreFuture ...
[16:01:40.530] result() for MulticoreFuture ... done
[16:01:40.531] result() for MulticoreFuture ...
[16:01:40.531] result() for MulticoreFuture ... done
[16:01:40.531]  - Number of value chunks collected: 2
[16:01:40.531] Resolving 2 futures (chunks) ... DONE
[16:01:40.531] Reducing values from 2 chunks ...
[16:01:40.531]  - Number of values collected after concatenation: 2
[16:01:40.531]  - Number of values expected: 2
[16:01:40.531] Reducing values from 2 chunks ... DONE
[16:01:40.531] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[16:01:40.532] getGlobalsAndPackagesXApply() ...
[16:01:40.532]  - future.globals: TRUE
[16:01:40.532] getGlobalsAndPackages() ...
[16:01:40.532] Searching for globals...
[16:01:40.570] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[16:01:40.570] Searching for globals ... DONE
[16:01:40.570] Resolving globals: FALSE
[16:01:40.572] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[16:01:40.572] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[16:01:40.572] - globals: [1] ‘FUN’
[16:01:40.573] 
[16:01:40.573] getGlobalsAndPackages() ... DONE
[16:01:40.573]  - globals found/used: [n=1] ‘FUN’
[16:01:40.573]  - needed namespaces: [n=0] 
[16:01:40.573] Finding globals ... DONE
[16:01:40.573]  - use_args: TRUE
[16:01:40.573]  - Getting '...' globals ...
[16:01:40.573] resolve() on list ...
[16:01:40.574]  recursive: 0
[16:01:40.574]  length: 1
[16:01:40.574]  elements: ‘...’
[16:01:40.574]  length: 0 (resolved future 1)
[16:01:40.574] resolve() on list ... DONE
[16:01:40.575]    - '...' content: [n=0] 
[16:01:40.575] List of 1
[16:01:40.575]  $ ...: list()
[16:01:40.575]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.575]  - attr(*, "where")=List of 1
[16:01:40.575]   ..$ ...:<environment: 0x55fb64740858> 
[16:01:40.575]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.575]  - attr(*, "resolved")= logi TRUE
[16:01:40.575]  - attr(*, "total_size")= num NA
[16:01:40.578]  - Getting '...' globals ... DONE
[16:01:40.578] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:40.578] List of 2
[16:01:40.578]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:01:40.578]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:01:40.578]  $ ...          : list()
[16:01:40.578]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.578]  - attr(*, "where")=List of 2
[16:01:40.578]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:40.578]   ..$ ...          :<environment: 0x55fb64740858> 
[16:01:40.578]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.578]  - attr(*, "resolved")= logi FALSE
[16:01:40.578]  - attr(*, "total_size")= num 354224
[16:01:40.581] Packages to be attached in all futures: [n=0] 
[16:01:40.581] getGlobalsAndPackagesXApply() ... DONE
[16:01:40.585] future_lapply() ...
[16:01:40.622] Number of chunks: 2
[16:01:40.623] getGlobalsAndPackagesXApply() ...
[16:01:40.623]  - future.globals: <name-value list> with names ‘list()’
[16:01:40.623]  - use_args: TRUE
[16:01:40.623] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:01:40.623] List of 2
[16:01:40.623]  $ ...          : list()
[16:01:40.623]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.623]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:01:40.623]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:01:40.623]  - attr(*, "where")=List of 2
[16:01:40.623]   ..$ ...          :<environment: 0x55fb64740858> 
[16:01:40.623]   ..$ ...future.FUN:<environment: namespace:base> 
[16:01:40.623]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.623]  - attr(*, "resolved")= logi FALSE
[16:01:40.623]  - attr(*, "total_size")= num NA
[16:01:40.627] Packages to be attached in all futures: [n=0] 
[16:01:40.627] getGlobalsAndPackagesXApply() ... DONE
[16:01:40.627] Number of futures (= number of chunks): 2
[16:01:40.627] Launching 2 futures (chunks) ...
[16:01:40.627] Chunk #1 of 2 ...
[16:01:40.627]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:40.627]  - seeds: <none>
[16:01:40.627]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.628] getGlobalsAndPackages() ...
[16:01:40.628] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.628] Resolving globals: FALSE
[16:01:40.628] Tweak future expression to call with '...' arguments ...
[16:01:40.628] {
[16:01:40.628]     do.call(function(...) {
[16:01:40.628]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.628]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.628]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.628]             on.exit(options(oopts), add = TRUE)
[16:01:40.628]         }
[16:01:40.628]         {
[16:01:40.628]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.628]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.628]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.628]             })
[16:01:40.628]         }
[16:01:40.628]     }, args = future.call.arguments)
[16:01:40.628] }
[16:01:40.628] Tweak future expression to call with '...' arguments ... DONE
[16:01:40.629] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.629] 
[16:01:40.629] getGlobalsAndPackages() ... DONE
[16:01:40.629] run() for ‘Future’ ...
[16:01:40.629] - state: ‘created’
[16:01:40.629] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:40.633] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:40.633] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:40.633]   - Field: ‘label’
[16:01:40.633]   - Field: ‘local’
[16:01:40.633]   - Field: ‘owner’
[16:01:40.633]   - Field: ‘envir’
[16:01:40.634]   - Field: ‘workers’
[16:01:40.634]   - Field: ‘packages’
[16:01:40.634]   - Field: ‘gc’
[16:01:40.634]   - Field: ‘job’
[16:01:40.634]   - Field: ‘conditions’
[16:01:40.634]   - Field: ‘expr’
[16:01:40.634]   - Field: ‘uuid’
[16:01:40.634]   - Field: ‘seed’
[16:01:40.634]   - Field: ‘version’
[16:01:40.635]   - Field: ‘result’
[16:01:40.635]   - Field: ‘asynchronous’
[16:01:40.635]   - Field: ‘calls’
[16:01:40.635]   - Field: ‘globals’
[16:01:40.635]   - Field: ‘stdout’
[16:01:40.635]   - Field: ‘earlySignal’
[16:01:40.635]   - Field: ‘lazy’
[16:01:40.635]   - Field: ‘state’
[16:01:40.635] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:40.635] - Launch lazy future ...
[16:01:40.636] Packages needed by the future expression (n = 0): <none>
[16:01:40.636] Packages needed by future strategies (n = 0): <none>
[16:01:40.636] {
[16:01:40.636]     {
[16:01:40.636]         {
[16:01:40.636]             ...future.startTime <- base::Sys.time()
[16:01:40.636]             {
[16:01:40.636]                 {
[16:01:40.636]                   {
[16:01:40.636]                     {
[16:01:40.636]                       base::local({
[16:01:40.636]                         has_future <- base::requireNamespace("future", 
[16:01:40.636]                           quietly = TRUE)
[16:01:40.636]                         if (has_future) {
[16:01:40.636]                           ns <- base::getNamespace("future")
[16:01:40.636]                           version <- ns[[".package"]][["version"]]
[16:01:40.636]                           if (is.null(version)) 
[16:01:40.636]                             version <- utils::packageVersion("future")
[16:01:40.636]                         }
[16:01:40.636]                         else {
[16:01:40.636]                           version <- NULL
[16:01:40.636]                         }
[16:01:40.636]                         if (!has_future || version < "1.8.0") {
[16:01:40.636]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:40.636]                             "", base::R.version$version.string), 
[16:01:40.636]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:40.636]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:40.636]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:40.636]                               "release", "version")], collapse = " "), 
[16:01:40.636]                             hostname = base::Sys.info()[["nodename"]])
[16:01:40.636]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:40.636]                             info)
[16:01:40.636]                           info <- base::paste(info, collapse = "; ")
[16:01:40.636]                           if (!has_future) {
[16:01:40.636]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:40.636]                               info)
[16:01:40.636]                           }
[16:01:40.636]                           else {
[16:01:40.636]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:40.636]                               info, version)
[16:01:40.636]                           }
[16:01:40.636]                           base::stop(msg)
[16:01:40.636]                         }
[16:01:40.636]                       })
[16:01:40.636]                     }
[16:01:40.636]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:40.636]                     base::options(mc.cores = 1L)
[16:01:40.636]                   }
[16:01:40.636]                   options(future.plan = NULL)
[16:01:40.636]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:40.636]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:40.636]                 }
[16:01:40.636]                 ...future.workdir <- getwd()
[16:01:40.636]             }
[16:01:40.636]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:40.636]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:40.636]         }
[16:01:40.636]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:40.636]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:40.636]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:40.636]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:40.636]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:40.636]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:40.636]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:40.636]             base::names(...future.oldOptions))
[16:01:40.636]     }
[16:01:40.636]     if (FALSE) {
[16:01:40.636]     }
[16:01:40.636]     else {
[16:01:40.636]         if (TRUE) {
[16:01:40.636]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:40.636]                 open = "w")
[16:01:40.636]         }
[16:01:40.636]         else {
[16:01:40.636]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:40.636]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:40.636]         }
[16:01:40.636]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:40.636]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:40.636]             base::sink(type = "output", split = FALSE)
[16:01:40.636]             base::close(...future.stdout)
[16:01:40.636]         }, add = TRUE)
[16:01:40.636]     }
[16:01:40.636]     ...future.frame <- base::sys.nframe()
[16:01:40.636]     ...future.conditions <- base::list()
[16:01:40.636]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:40.636]     if (FALSE) {
[16:01:40.636]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:40.636]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:40.636]     }
[16:01:40.636]     ...future.result <- base::tryCatch({
[16:01:40.636]         base::withCallingHandlers({
[16:01:40.636]             ...future.value <- base::withVisible(base::local({
[16:01:40.636]                 withCallingHandlers({
[16:01:40.636]                   {
[16:01:40.636]                     do.call(function(...) {
[16:01:40.636]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.636]                       if (!identical(...future.globals.maxSize.org, 
[16:01:40.636]                         ...future.globals.maxSize)) {
[16:01:40.636]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.636]                         on.exit(options(oopts), add = TRUE)
[16:01:40.636]                       }
[16:01:40.636]                       {
[16:01:40.636]                         lapply(seq_along(...future.elements_ii), 
[16:01:40.636]                           FUN = function(jj) {
[16:01:40.636]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.636]                             ...future.FUN(...future.X_jj, ...)
[16:01:40.636]                           })
[16:01:40.636]                       }
[16:01:40.636]                     }, args = future.call.arguments)
[16:01:40.636]                   }
[16:01:40.636]                 }, immediateCondition = function(cond) {
[16:01:40.636]                   save_rds <- function (object, pathname, ...) 
[16:01:40.636]                   {
[16:01:40.636]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:40.636]                     if (file_test("-f", pathname_tmp)) {
[16:01:40.636]                       fi_tmp <- file.info(pathname_tmp)
[16:01:40.636]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:40.636]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:40.636]                         fi_tmp[["mtime"]])
[16:01:40.636]                     }
[16:01:40.636]                     tryCatch({
[16:01:40.636]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:40.636]                     }, error = function(ex) {
[16:01:40.636]                       msg <- conditionMessage(ex)
[16:01:40.636]                       fi_tmp <- file.info(pathname_tmp)
[16:01:40.636]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:40.636]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:40.636]                         fi_tmp[["mtime"]], msg)
[16:01:40.636]                       ex$message <- msg
[16:01:40.636]                       stop(ex)
[16:01:40.636]                     })
[16:01:40.636]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:40.636]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:40.636]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:40.636]                       fi_tmp <- file.info(pathname_tmp)
[16:01:40.636]                       fi <- file.info(pathname)
[16:01:40.636]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:40.636]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:40.636]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:40.636]                         fi[["size"]], fi[["mtime"]])
[16:01:40.636]                       stop(msg)
[16:01:40.636]                     }
[16:01:40.636]                     invisible(pathname)
[16:01:40.636]                   }
[16:01:40.636]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:40.636]                     rootPath = tempdir()) 
[16:01:40.636]                   {
[16:01:40.636]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:40.636]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:40.636]                       tmpdir = path, fileext = ".rds")
[16:01:40.636]                     save_rds(obj, file)
[16:01:40.636]                   }
[16:01:40.636]                   saveImmediateCondition(cond, path = "/tmp/RtmplAoKyr/.future/immediateConditions")
[16:01:40.636]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.636]                   {
[16:01:40.636]                     inherits <- base::inherits
[16:01:40.636]                     invokeRestart <- base::invokeRestart
[16:01:40.636]                     is.null <- base::is.null
[16:01:40.636]                     muffled <- FALSE
[16:01:40.636]                     if (inherits(cond, "message")) {
[16:01:40.636]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:40.636]                       if (muffled) 
[16:01:40.636]                         invokeRestart("muffleMessage")
[16:01:40.636]                     }
[16:01:40.636]                     else if (inherits(cond, "warning")) {
[16:01:40.636]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:40.636]                       if (muffled) 
[16:01:40.636]                         invokeRestart("muffleWarning")
[16:01:40.636]                     }
[16:01:40.636]                     else if (inherits(cond, "condition")) {
[16:01:40.636]                       if (!is.null(pattern)) {
[16:01:40.636]                         computeRestarts <- base::computeRestarts
[16:01:40.636]                         grepl <- base::grepl
[16:01:40.636]                         restarts <- computeRestarts(cond)
[16:01:40.636]                         for (restart in restarts) {
[16:01:40.636]                           name <- restart$name
[16:01:40.636]                           if (is.null(name)) 
[16:01:40.636]                             next
[16:01:40.636]                           if (!grepl(pattern, name)) 
[16:01:40.636]                             next
[16:01:40.636]                           invokeRestart(restart)
[16:01:40.636]                           muffled <- TRUE
[16:01:40.636]                           break
[16:01:40.636]                         }
[16:01:40.636]                       }
[16:01:40.636]                     }
[16:01:40.636]                     invisible(muffled)
[16:01:40.636]                   }
[16:01:40.636]                   muffleCondition(cond)
[16:01:40.636]                 })
[16:01:40.636]             }))
[16:01:40.636]             future::FutureResult(value = ...future.value$value, 
[16:01:40.636]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:40.636]                   ...future.rng), globalenv = if (FALSE) 
[16:01:40.636]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:40.636]                     ...future.globalenv.names))
[16:01:40.636]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:40.636]         }, condition = base::local({
[16:01:40.636]             c <- base::c
[16:01:40.636]             inherits <- base::inherits
[16:01:40.636]             invokeRestart <- base::invokeRestart
[16:01:40.636]             length <- base::length
[16:01:40.636]             list <- base::list
[16:01:40.636]             seq.int <- base::seq.int
[16:01:40.636]             signalCondition <- base::signalCondition
[16:01:40.636]             sys.calls <- base::sys.calls
[16:01:40.636]             `[[` <- base::`[[`
[16:01:40.636]             `+` <- base::`+`
[16:01:40.636]             `<<-` <- base::`<<-`
[16:01:40.636]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:40.636]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:40.636]                   3L)]
[16:01:40.636]             }
[16:01:40.636]             function(cond) {
[16:01:40.636]                 is_error <- inherits(cond, "error")
[16:01:40.636]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:40.636]                   NULL)
[16:01:40.636]                 if (is_error) {
[16:01:40.636]                   sessionInformation <- function() {
[16:01:40.636]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:40.636]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:40.636]                       search = base::search(), system = base::Sys.info())
[16:01:40.636]                   }
[16:01:40.636]                   ...future.conditions[[length(...future.conditions) + 
[16:01:40.636]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:40.636]                     cond$call), session = sessionInformation(), 
[16:01:40.636]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:40.636]                   signalCondition(cond)
[16:01:40.636]                 }
[16:01:40.636]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:40.636]                 "immediateCondition"))) {
[16:01:40.636]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:40.636]                   ...future.conditions[[length(...future.conditions) + 
[16:01:40.636]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:40.636]                   if (TRUE && !signal) {
[16:01:40.636]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.636]                     {
[16:01:40.636]                       inherits <- base::inherits
[16:01:40.636]                       invokeRestart <- base::invokeRestart
[16:01:40.636]                       is.null <- base::is.null
[16:01:40.636]                       muffled <- FALSE
[16:01:40.636]                       if (inherits(cond, "message")) {
[16:01:40.636]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:40.636]                         if (muffled) 
[16:01:40.636]                           invokeRestart("muffleMessage")
[16:01:40.636]                       }
[16:01:40.636]                       else if (inherits(cond, "warning")) {
[16:01:40.636]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:40.636]                         if (muffled) 
[16:01:40.636]                           invokeRestart("muffleWarning")
[16:01:40.636]                       }
[16:01:40.636]                       else if (inherits(cond, "condition")) {
[16:01:40.636]                         if (!is.null(pattern)) {
[16:01:40.636]                           computeRestarts <- base::computeRestarts
[16:01:40.636]                           grepl <- base::grepl
[16:01:40.636]                           restarts <- computeRestarts(cond)
[16:01:40.636]                           for (restart in restarts) {
[16:01:40.636]                             name <- restart$name
[16:01:40.636]                             if (is.null(name)) 
[16:01:40.636]                               next
[16:01:40.636]                             if (!grepl(pattern, name)) 
[16:01:40.636]                               next
[16:01:40.636]                             invokeRestart(restart)
[16:01:40.636]                             muffled <- TRUE
[16:01:40.636]                             break
[16:01:40.636]                           }
[16:01:40.636]                         }
[16:01:40.636]                       }
[16:01:40.636]                       invisible(muffled)
[16:01:40.636]                     }
[16:01:40.636]                     muffleCondition(cond, pattern = "^muffle")
[16:01:40.636]                   }
[16:01:40.636]                 }
[16:01:40.636]                 else {
[16:01:40.636]                   if (TRUE) {
[16:01:40.636]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.636]                     {
[16:01:40.636]                       inherits <- base::inherits
[16:01:40.636]                       invokeRestart <- base::invokeRestart
[16:01:40.636]                       is.null <- base::is.null
[16:01:40.636]                       muffled <- FALSE
[16:01:40.636]                       if (inherits(cond, "message")) {
[16:01:40.636]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:40.636]                         if (muffled) 
[16:01:40.636]                           invokeRestart("muffleMessage")
[16:01:40.636]                       }
[16:01:40.636]                       else if (inherits(cond, "warning")) {
[16:01:40.636]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:40.636]                         if (muffled) 
[16:01:40.636]                           invokeRestart("muffleWarning")
[16:01:40.636]                       }
[16:01:40.636]                       else if (inherits(cond, "condition")) {
[16:01:40.636]                         if (!is.null(pattern)) {
[16:01:40.636]                           computeRestarts <- base::computeRestarts
[16:01:40.636]                           grepl <- base::grepl
[16:01:40.636]                           restarts <- computeRestarts(cond)
[16:01:40.636]                           for (restart in restarts) {
[16:01:40.636]                             name <- restart$name
[16:01:40.636]                             if (is.null(name)) 
[16:01:40.636]                               next
[16:01:40.636]                             if (!grepl(pattern, name)) 
[16:01:40.636]                               next
[16:01:40.636]                             invokeRestart(restart)
[16:01:40.636]                             muffled <- TRUE
[16:01:40.636]                             break
[16:01:40.636]                           }
[16:01:40.636]                         }
[16:01:40.636]                       }
[16:01:40.636]                       invisible(muffled)
[16:01:40.636]                     }
[16:01:40.636]                     muffleCondition(cond, pattern = "^muffle")
[16:01:40.636]                   }
[16:01:40.636]                 }
[16:01:40.636]             }
[16:01:40.636]         }))
[16:01:40.636]     }, error = function(ex) {
[16:01:40.636]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:40.636]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:40.636]                 ...future.rng), started = ...future.startTime, 
[16:01:40.636]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:40.636]             version = "1.8"), class = "FutureResult")
[16:01:40.636]     }, finally = {
[16:01:40.636]         if (!identical(...future.workdir, getwd())) 
[16:01:40.636]             setwd(...future.workdir)
[16:01:40.636]         {
[16:01:40.636]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:40.636]                 ...future.oldOptions$nwarnings <- NULL
[16:01:40.636]             }
[16:01:40.636]             base::options(...future.oldOptions)
[16:01:40.636]             if (.Platform$OS.type == "windows") {
[16:01:40.636]                 old_names <- names(...future.oldEnvVars)
[16:01:40.636]                 envs <- base::Sys.getenv()
[16:01:40.636]                 names <- names(envs)
[16:01:40.636]                 common <- intersect(names, old_names)
[16:01:40.636]                 added <- setdiff(names, old_names)
[16:01:40.636]                 removed <- setdiff(old_names, names)
[16:01:40.636]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:40.636]                   envs[common]]
[16:01:40.636]                 NAMES <- toupper(changed)
[16:01:40.636]                 args <- list()
[16:01:40.636]                 for (kk in seq_along(NAMES)) {
[16:01:40.636]                   name <- changed[[kk]]
[16:01:40.636]                   NAME <- NAMES[[kk]]
[16:01:40.636]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.636]                     next
[16:01:40.636]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:40.636]                 }
[16:01:40.636]                 NAMES <- toupper(added)
[16:01:40.636]                 for (kk in seq_along(NAMES)) {
[16:01:40.636]                   name <- added[[kk]]
[16:01:40.636]                   NAME <- NAMES[[kk]]
[16:01:40.636]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.636]                     next
[16:01:40.636]                   args[[name]] <- ""
[16:01:40.636]                 }
[16:01:40.636]                 NAMES <- toupper(removed)
[16:01:40.636]                 for (kk in seq_along(NAMES)) {
[16:01:40.636]                   name <- removed[[kk]]
[16:01:40.636]                   NAME <- NAMES[[kk]]
[16:01:40.636]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.636]                     next
[16:01:40.636]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:40.636]                 }
[16:01:40.636]                 if (length(args) > 0) 
[16:01:40.636]                   base::do.call(base::Sys.setenv, args = args)
[16:01:40.636]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:40.636]             }
[16:01:40.636]             else {
[16:01:40.636]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:40.636]             }
[16:01:40.636]             {
[16:01:40.636]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:40.636]                   0L) {
[16:01:40.636]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:40.636]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:40.636]                   base::options(opts)
[16:01:40.636]                 }
[16:01:40.636]                 {
[16:01:40.636]                   {
[16:01:40.636]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:40.636]                     NULL
[16:01:40.636]                   }
[16:01:40.636]                   options(future.plan = NULL)
[16:01:40.636]                   if (is.na(NA_character_)) 
[16:01:40.636]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:40.636]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:40.636]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:40.636]                     envir = parent.frame()) 
[16:01:40.636]                   {
[16:01:40.636]                     default_workers <- missing(workers)
[16:01:40.636]                     if (is.function(workers)) 
[16:01:40.636]                       workers <- workers()
[16:01:40.636]                     workers <- structure(as.integer(workers), 
[16:01:40.636]                       class = class(workers))
[16:01:40.636]                     stop_if_not(is.finite(workers), workers >= 
[16:01:40.636]                       1L)
[16:01:40.636]                     if ((workers == 1L && !inherits(workers, 
[16:01:40.636]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:40.636]                       if (default_workers) 
[16:01:40.636]                         supportsMulticore(warn = TRUE)
[16:01:40.636]                       return(sequential(..., envir = envir))
[16:01:40.636]                     }
[16:01:40.636]                     oopts <- options(mc.cores = workers)
[16:01:40.636]                     on.exit(options(oopts))
[16:01:40.636]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:40.636]                       envir = envir)
[16:01:40.636]                     if (!future$lazy) 
[16:01:40.636]                       future <- run(future)
[16:01:40.636]                     invisible(future)
[16:01:40.636]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:40.636]                 }
[16:01:40.636]             }
[16:01:40.636]         }
[16:01:40.636]     })
[16:01:40.636]     if (TRUE) {
[16:01:40.636]         base::sink(type = "output", split = FALSE)
[16:01:40.636]         if (TRUE) {
[16:01:40.636]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:40.636]         }
[16:01:40.636]         else {
[16:01:40.636]             ...future.result["stdout"] <- base::list(NULL)
[16:01:40.636]         }
[16:01:40.636]         base::close(...future.stdout)
[16:01:40.636]         ...future.stdout <- NULL
[16:01:40.636]     }
[16:01:40.636]     ...future.result$conditions <- ...future.conditions
[16:01:40.636]     ...future.result$finished <- base::Sys.time()
[16:01:40.636]     ...future.result
[16:01:40.636] }
[16:01:40.640] assign_globals() ...
[16:01:40.640] List of 5
[16:01:40.640]  $ future.call.arguments    : list()
[16:01:40.640]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.640]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:01:40.640]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:01:40.640]  $ ...future.elements_ii    :List of 1
[16:01:40.640]   ..$ : num [1:4] 1 3 1 7
[16:01:40.640]  $ ...future.seeds_ii       : NULL
[16:01:40.640]  $ ...future.globals.maxSize: num Inf
[16:01:40.640]  - attr(*, "resolved")= logi FALSE
[16:01:40.640]  - attr(*, "total_size")= num NA
[16:01:40.640]  - attr(*, "where")=List of 5
[16:01:40.640]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:40.640]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:40.640]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:40.640]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:40.640]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:40.640]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.640]  - attr(*, "already-done")= logi TRUE
[16:01:40.645] - copied ‘future.call.arguments’ to environment
[16:01:40.645] - copied ‘...future.FUN’ to environment
[16:01:40.646] - copied ‘...future.elements_ii’ to environment
[16:01:40.646] - copied ‘...future.seeds_ii’ to environment
[16:01:40.646] - copied ‘...future.globals.maxSize’ to environment
[16:01:40.646] assign_globals() ... done
[16:01:40.646] requestCore(): workers = 2
[16:01:40.648] MulticoreFuture started
[16:01:40.649] - Launch lazy future ... done
[16:01:40.649] run() for ‘MulticoreFuture’ ... done
[16:01:40.649] Created future:
[16:01:40.649] plan(): Setting new future strategy stack:
[16:01:40.650] List of future strategies:
[16:01:40.650] 1. sequential:
[16:01:40.650]    - args: function (..., envir = parent.frame())
[16:01:40.650]    - tweaked: FALSE
[16:01:40.650]    - call: NULL
[16:01:40.650] plan(): nbrOfWorkers() = 1
[16:01:40.652] plan(): Setting new future strategy stack:
[16:01:40.653] List of future strategies:
[16:01:40.653] 1. multicore:
[16:01:40.653]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:40.653]    - tweaked: FALSE
[16:01:40.653]    - call: plan(strategy)
[16:01:40.658] plan(): nbrOfWorkers() = 2
[16:01:40.649] MulticoreFuture:
[16:01:40.649] Label: ‘future_apply-1’
[16:01:40.649] Expression:
[16:01:40.649] {
[16:01:40.649]     do.call(function(...) {
[16:01:40.649]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.649]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.649]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.649]             on.exit(options(oopts), add = TRUE)
[16:01:40.649]         }
[16:01:40.649]         {
[16:01:40.649]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.649]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.649]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.649]             })
[16:01:40.649]         }
[16:01:40.649]     }, args = future.call.arguments)
[16:01:40.649] }
[16:01:40.649] Lazy evaluation: FALSE
[16:01:40.649] Asynchronous evaluation: TRUE
[16:01:40.649] Local evaluation: TRUE
[16:01:40.649] Environment: R_GlobalEnv
[16:01:40.649] Capture standard output: TRUE
[16:01:40.649] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:40.649] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:40.649] Packages: <none>
[16:01:40.649] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:40.649] Resolved: TRUE
[16:01:40.649] Value: <not collected>
[16:01:40.649] Conditions captured: <none>
[16:01:40.649] Early signaling: FALSE
[16:01:40.649] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:40.649] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:40.659] Chunk #1 of 2 ... DONE
[16:01:40.659] Chunk #2 of 2 ...
[16:01:40.659]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:40.660]  - seeds: <none>
[16:01:40.660]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.660] getGlobalsAndPackages() ...
[16:01:40.660] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.660] Resolving globals: FALSE
[16:01:40.660] Tweak future expression to call with '...' arguments ...
[16:01:40.660] {
[16:01:40.660]     do.call(function(...) {
[16:01:40.660]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.660]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.660]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.660]             on.exit(options(oopts), add = TRUE)
[16:01:40.660]         }
[16:01:40.660]         {
[16:01:40.660]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.660]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.660]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.660]             })
[16:01:40.660]         }
[16:01:40.660]     }, args = future.call.arguments)
[16:01:40.660] }
[16:01:40.661] Tweak future expression to call with '...' arguments ... DONE
[16:01:40.662] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.662] 
[16:01:40.662] getGlobalsAndPackages() ... DONE
[16:01:40.662] run() for ‘Future’ ...
[16:01:40.663] - state: ‘created’
[16:01:40.663] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:40.667] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:40.668] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:40.668]   - Field: ‘label’
[16:01:40.668]   - Field: ‘local’
[16:01:40.668]   - Field: ‘owner’
[16:01:40.668]   - Field: ‘envir’
[16:01:40.668]   - Field: ‘workers’
[16:01:40.668]   - Field: ‘packages’
[16:01:40.669]   - Field: ‘gc’
[16:01:40.669]   - Field: ‘job’
[16:01:40.669]   - Field: ‘conditions’
[16:01:40.669]   - Field: ‘expr’
[16:01:40.669]   - Field: ‘uuid’
[16:01:40.670]   - Field: ‘seed’
[16:01:40.670]   - Field: ‘version’
[16:01:40.670]   - Field: ‘result’
[16:01:40.670]   - Field: ‘asynchronous’
[16:01:40.670]   - Field: ‘calls’
[16:01:40.670]   - Field: ‘globals’
[16:01:40.670]   - Field: ‘stdout’
[16:01:40.671]   - Field: ‘earlySignal’
[16:01:40.671]   - Field: ‘lazy’
[16:01:40.671]   - Field: ‘state’
[16:01:40.671] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:40.671] - Launch lazy future ...
[16:01:40.672] Packages needed by the future expression (n = 0): <none>
[16:01:40.672] Packages needed by future strategies (n = 0): <none>
[16:01:40.672] {
[16:01:40.672]     {
[16:01:40.672]         {
[16:01:40.672]             ...future.startTime <- base::Sys.time()
[16:01:40.672]             {
[16:01:40.672]                 {
[16:01:40.672]                   {
[16:01:40.672]                     {
[16:01:40.672]                       base::local({
[16:01:40.672]                         has_future <- base::requireNamespace("future", 
[16:01:40.672]                           quietly = TRUE)
[16:01:40.672]                         if (has_future) {
[16:01:40.672]                           ns <- base::getNamespace("future")
[16:01:40.672]                           version <- ns[[".package"]][["version"]]
[16:01:40.672]                           if (is.null(version)) 
[16:01:40.672]                             version <- utils::packageVersion("future")
[16:01:40.672]                         }
[16:01:40.672]                         else {
[16:01:40.672]                           version <- NULL
[16:01:40.672]                         }
[16:01:40.672]                         if (!has_future || version < "1.8.0") {
[16:01:40.672]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:40.672]                             "", base::R.version$version.string), 
[16:01:40.672]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:40.672]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:40.672]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:40.672]                               "release", "version")], collapse = " "), 
[16:01:40.672]                             hostname = base::Sys.info()[["nodename"]])
[16:01:40.672]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:40.672]                             info)
[16:01:40.672]                           info <- base::paste(info, collapse = "; ")
[16:01:40.672]                           if (!has_future) {
[16:01:40.672]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:40.672]                               info)
[16:01:40.672]                           }
[16:01:40.672]                           else {
[16:01:40.672]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:40.672]                               info, version)
[16:01:40.672]                           }
[16:01:40.672]                           base::stop(msg)
[16:01:40.672]                         }
[16:01:40.672]                       })
[16:01:40.672]                     }
[16:01:40.672]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:40.672]                     base::options(mc.cores = 1L)
[16:01:40.672]                   }
[16:01:40.672]                   options(future.plan = NULL)
[16:01:40.672]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:40.672]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:40.672]                 }
[16:01:40.672]                 ...future.workdir <- getwd()
[16:01:40.672]             }
[16:01:40.672]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:40.672]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:40.672]         }
[16:01:40.672]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:40.672]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:40.672]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:40.672]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:40.672]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:40.672]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:40.672]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:40.672]             base::names(...future.oldOptions))
[16:01:40.672]     }
[16:01:40.672]     if (FALSE) {
[16:01:40.672]     }
[16:01:40.672]     else {
[16:01:40.672]         if (TRUE) {
[16:01:40.672]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:40.672]                 open = "w")
[16:01:40.672]         }
[16:01:40.672]         else {
[16:01:40.672]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:40.672]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:40.672]         }
[16:01:40.672]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:40.672]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:40.672]             base::sink(type = "output", split = FALSE)
[16:01:40.672]             base::close(...future.stdout)
[16:01:40.672]         }, add = TRUE)
[16:01:40.672]     }
[16:01:40.672]     ...future.frame <- base::sys.nframe()
[16:01:40.672]     ...future.conditions <- base::list()
[16:01:40.672]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:40.672]     if (FALSE) {
[16:01:40.672]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:40.672]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:40.672]     }
[16:01:40.672]     ...future.result <- base::tryCatch({
[16:01:40.672]         base::withCallingHandlers({
[16:01:40.672]             ...future.value <- base::withVisible(base::local({
[16:01:40.672]                 withCallingHandlers({
[16:01:40.672]                   {
[16:01:40.672]                     do.call(function(...) {
[16:01:40.672]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.672]                       if (!identical(...future.globals.maxSize.org, 
[16:01:40.672]                         ...future.globals.maxSize)) {
[16:01:40.672]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.672]                         on.exit(options(oopts), add = TRUE)
[16:01:40.672]                       }
[16:01:40.672]                       {
[16:01:40.672]                         lapply(seq_along(...future.elements_ii), 
[16:01:40.672]                           FUN = function(jj) {
[16:01:40.672]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.672]                             ...future.FUN(...future.X_jj, ...)
[16:01:40.672]                           })
[16:01:40.672]                       }
[16:01:40.672]                     }, args = future.call.arguments)
[16:01:40.672]                   }
[16:01:40.672]                 }, immediateCondition = function(cond) {
[16:01:40.672]                   save_rds <- function (object, pathname, ...) 
[16:01:40.672]                   {
[16:01:40.672]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:40.672]                     if (file_test("-f", pathname_tmp)) {
[16:01:40.672]                       fi_tmp <- file.info(pathname_tmp)
[16:01:40.672]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:40.672]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:40.672]                         fi_tmp[["mtime"]])
[16:01:40.672]                     }
[16:01:40.672]                     tryCatch({
[16:01:40.672]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:40.672]                     }, error = function(ex) {
[16:01:40.672]                       msg <- conditionMessage(ex)
[16:01:40.672]                       fi_tmp <- file.info(pathname_tmp)
[16:01:40.672]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:40.672]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:40.672]                         fi_tmp[["mtime"]], msg)
[16:01:40.672]                       ex$message <- msg
[16:01:40.672]                       stop(ex)
[16:01:40.672]                     })
[16:01:40.672]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:40.672]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:40.672]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:40.672]                       fi_tmp <- file.info(pathname_tmp)
[16:01:40.672]                       fi <- file.info(pathname)
[16:01:40.672]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:40.672]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:40.672]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:40.672]                         fi[["size"]], fi[["mtime"]])
[16:01:40.672]                       stop(msg)
[16:01:40.672]                     }
[16:01:40.672]                     invisible(pathname)
[16:01:40.672]                   }
[16:01:40.672]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:40.672]                     rootPath = tempdir()) 
[16:01:40.672]                   {
[16:01:40.672]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:40.672]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:40.672]                       tmpdir = path, fileext = ".rds")
[16:01:40.672]                     save_rds(obj, file)
[16:01:40.672]                   }
[16:01:40.672]                   saveImmediateCondition(cond, path = "/tmp/RtmplAoKyr/.future/immediateConditions")
[16:01:40.672]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.672]                   {
[16:01:40.672]                     inherits <- base::inherits
[16:01:40.672]                     invokeRestart <- base::invokeRestart
[16:01:40.672]                     is.null <- base::is.null
[16:01:40.672]                     muffled <- FALSE
[16:01:40.672]                     if (inherits(cond, "message")) {
[16:01:40.672]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:40.672]                       if (muffled) 
[16:01:40.672]                         invokeRestart("muffleMessage")
[16:01:40.672]                     }
[16:01:40.672]                     else if (inherits(cond, "warning")) {
[16:01:40.672]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:40.672]                       if (muffled) 
[16:01:40.672]                         invokeRestart("muffleWarning")
[16:01:40.672]                     }
[16:01:40.672]                     else if (inherits(cond, "condition")) {
[16:01:40.672]                       if (!is.null(pattern)) {
[16:01:40.672]                         computeRestarts <- base::computeRestarts
[16:01:40.672]                         grepl <- base::grepl
[16:01:40.672]                         restarts <- computeRestarts(cond)
[16:01:40.672]                         for (restart in restarts) {
[16:01:40.672]                           name <- restart$name
[16:01:40.672]                           if (is.null(name)) 
[16:01:40.672]                             next
[16:01:40.672]                           if (!grepl(pattern, name)) 
[16:01:40.672]                             next
[16:01:40.672]                           invokeRestart(restart)
[16:01:40.672]                           muffled <- TRUE
[16:01:40.672]                           break
[16:01:40.672]                         }
[16:01:40.672]                       }
[16:01:40.672]                     }
[16:01:40.672]                     invisible(muffled)
[16:01:40.672]                   }
[16:01:40.672]                   muffleCondition(cond)
[16:01:40.672]                 })
[16:01:40.672]             }))
[16:01:40.672]             future::FutureResult(value = ...future.value$value, 
[16:01:40.672]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:40.672]                   ...future.rng), globalenv = if (FALSE) 
[16:01:40.672]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:40.672]                     ...future.globalenv.names))
[16:01:40.672]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:40.672]         }, condition = base::local({
[16:01:40.672]             c <- base::c
[16:01:40.672]             inherits <- base::inherits
[16:01:40.672]             invokeRestart <- base::invokeRestart
[16:01:40.672]             length <- base::length
[16:01:40.672]             list <- base::list
[16:01:40.672]             seq.int <- base::seq.int
[16:01:40.672]             signalCondition <- base::signalCondition
[16:01:40.672]             sys.calls <- base::sys.calls
[16:01:40.672]             `[[` <- base::`[[`
[16:01:40.672]             `+` <- base::`+`
[16:01:40.672]             `<<-` <- base::`<<-`
[16:01:40.672]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:40.672]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:40.672]                   3L)]
[16:01:40.672]             }
[16:01:40.672]             function(cond) {
[16:01:40.672]                 is_error <- inherits(cond, "error")
[16:01:40.672]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:40.672]                   NULL)
[16:01:40.672]                 if (is_error) {
[16:01:40.672]                   sessionInformation <- function() {
[16:01:40.672]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:40.672]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:40.672]                       search = base::search(), system = base::Sys.info())
[16:01:40.672]                   }
[16:01:40.672]                   ...future.conditions[[length(...future.conditions) + 
[16:01:40.672]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:40.672]                     cond$call), session = sessionInformation(), 
[16:01:40.672]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:40.672]                   signalCondition(cond)
[16:01:40.672]                 }
[16:01:40.672]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:40.672]                 "immediateCondition"))) {
[16:01:40.672]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:40.672]                   ...future.conditions[[length(...future.conditions) + 
[16:01:40.672]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:40.672]                   if (TRUE && !signal) {
[16:01:40.672]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.672]                     {
[16:01:40.672]                       inherits <- base::inherits
[16:01:40.672]                       invokeRestart <- base::invokeRestart
[16:01:40.672]                       is.null <- base::is.null
[16:01:40.672]                       muffled <- FALSE
[16:01:40.672]                       if (inherits(cond, "message")) {
[16:01:40.672]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:40.672]                         if (muffled) 
[16:01:40.672]                           invokeRestart("muffleMessage")
[16:01:40.672]                       }
[16:01:40.672]                       else if (inherits(cond, "warning")) {
[16:01:40.672]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:40.672]                         if (muffled) 
[16:01:40.672]                           invokeRestart("muffleWarning")
[16:01:40.672]                       }
[16:01:40.672]                       else if (inherits(cond, "condition")) {
[16:01:40.672]                         if (!is.null(pattern)) {
[16:01:40.672]                           computeRestarts <- base::computeRestarts
[16:01:40.672]                           grepl <- base::grepl
[16:01:40.672]                           restarts <- computeRestarts(cond)
[16:01:40.672]                           for (restart in restarts) {
[16:01:40.672]                             name <- restart$name
[16:01:40.672]                             if (is.null(name)) 
[16:01:40.672]                               next
[16:01:40.672]                             if (!grepl(pattern, name)) 
[16:01:40.672]                               next
[16:01:40.672]                             invokeRestart(restart)
[16:01:40.672]                             muffled <- TRUE
[16:01:40.672]                             break
[16:01:40.672]                           }
[16:01:40.672]                         }
[16:01:40.672]                       }
[16:01:40.672]                       invisible(muffled)
[16:01:40.672]                     }
[16:01:40.672]                     muffleCondition(cond, pattern = "^muffle")
[16:01:40.672]                   }
[16:01:40.672]                 }
[16:01:40.672]                 else {
[16:01:40.672]                   if (TRUE) {
[16:01:40.672]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.672]                     {
[16:01:40.672]                       inherits <- base::inherits
[16:01:40.672]                       invokeRestart <- base::invokeRestart
[16:01:40.672]                       is.null <- base::is.null
[16:01:40.672]                       muffled <- FALSE
[16:01:40.672]                       if (inherits(cond, "message")) {
[16:01:40.672]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:40.672]                         if (muffled) 
[16:01:40.672]                           invokeRestart("muffleMessage")
[16:01:40.672]                       }
[16:01:40.672]                       else if (inherits(cond, "warning")) {
[16:01:40.672]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:40.672]                         if (muffled) 
[16:01:40.672]                           invokeRestart("muffleWarning")
[16:01:40.672]                       }
[16:01:40.672]                       else if (inherits(cond, "condition")) {
[16:01:40.672]                         if (!is.null(pattern)) {
[16:01:40.672]                           computeRestarts <- base::computeRestarts
[16:01:40.672]                           grepl <- base::grepl
[16:01:40.672]                           restarts <- computeRestarts(cond)
[16:01:40.672]                           for (restart in restarts) {
[16:01:40.672]                             name <- restart$name
[16:01:40.672]                             if (is.null(name)) 
[16:01:40.672]                               next
[16:01:40.672]                             if (!grepl(pattern, name)) 
[16:01:40.672]                               next
[16:01:40.672]                             invokeRestart(restart)
[16:01:40.672]                             muffled <- TRUE
[16:01:40.672]                             break
[16:01:40.672]                           }
[16:01:40.672]                         }
[16:01:40.672]                       }
[16:01:40.672]                       invisible(muffled)
[16:01:40.672]                     }
[16:01:40.672]                     muffleCondition(cond, pattern = "^muffle")
[16:01:40.672]                   }
[16:01:40.672]                 }
[16:01:40.672]             }
[16:01:40.672]         }))
[16:01:40.672]     }, error = function(ex) {
[16:01:40.672]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:40.672]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:40.672]                 ...future.rng), started = ...future.startTime, 
[16:01:40.672]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:40.672]             version = "1.8"), class = "FutureResult")
[16:01:40.672]     }, finally = {
[16:01:40.672]         if (!identical(...future.workdir, getwd())) 
[16:01:40.672]             setwd(...future.workdir)
[16:01:40.672]         {
[16:01:40.672]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:40.672]                 ...future.oldOptions$nwarnings <- NULL
[16:01:40.672]             }
[16:01:40.672]             base::options(...future.oldOptions)
[16:01:40.672]             if (.Platform$OS.type == "windows") {
[16:01:40.672]                 old_names <- names(...future.oldEnvVars)
[16:01:40.672]                 envs <- base::Sys.getenv()
[16:01:40.672]                 names <- names(envs)
[16:01:40.672]                 common <- intersect(names, old_names)
[16:01:40.672]                 added <- setdiff(names, old_names)
[16:01:40.672]                 removed <- setdiff(old_names, names)
[16:01:40.672]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:40.672]                   envs[common]]
[16:01:40.672]                 NAMES <- toupper(changed)
[16:01:40.672]                 args <- list()
[16:01:40.672]                 for (kk in seq_along(NAMES)) {
[16:01:40.672]                   name <- changed[[kk]]
[16:01:40.672]                   NAME <- NAMES[[kk]]
[16:01:40.672]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.672]                     next
[16:01:40.672]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:40.672]                 }
[16:01:40.672]                 NAMES <- toupper(added)
[16:01:40.672]                 for (kk in seq_along(NAMES)) {
[16:01:40.672]                   name <- added[[kk]]
[16:01:40.672]                   NAME <- NAMES[[kk]]
[16:01:40.672]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.672]                     next
[16:01:40.672]                   args[[name]] <- ""
[16:01:40.672]                 }
[16:01:40.672]                 NAMES <- toupper(removed)
[16:01:40.672]                 for (kk in seq_along(NAMES)) {
[16:01:40.672]                   name <- removed[[kk]]
[16:01:40.672]                   NAME <- NAMES[[kk]]
[16:01:40.672]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.672]                     next
[16:01:40.672]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:40.672]                 }
[16:01:40.672]                 if (length(args) > 0) 
[16:01:40.672]                   base::do.call(base::Sys.setenv, args = args)
[16:01:40.672]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:40.672]             }
[16:01:40.672]             else {
[16:01:40.672]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:40.672]             }
[16:01:40.672]             {
[16:01:40.672]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:40.672]                   0L) {
[16:01:40.672]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:40.672]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:40.672]                   base::options(opts)
[16:01:40.672]                 }
[16:01:40.672]                 {
[16:01:40.672]                   {
[16:01:40.672]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:40.672]                     NULL
[16:01:40.672]                   }
[16:01:40.672]                   options(future.plan = NULL)
[16:01:40.672]                   if (is.na(NA_character_)) 
[16:01:40.672]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:40.672]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:40.672]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:40.672]                     envir = parent.frame()) 
[16:01:40.672]                   {
[16:01:40.672]                     default_workers <- missing(workers)
[16:01:40.672]                     if (is.function(workers)) 
[16:01:40.672]                       workers <- workers()
[16:01:40.672]                     workers <- structure(as.integer(workers), 
[16:01:40.672]                       class = class(workers))
[16:01:40.672]                     stop_if_not(is.finite(workers), workers >= 
[16:01:40.672]                       1L)
[16:01:40.672]                     if ((workers == 1L && !inherits(workers, 
[16:01:40.672]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:40.672]                       if (default_workers) 
[16:01:40.672]                         supportsMulticore(warn = TRUE)
[16:01:40.672]                       return(sequential(..., envir = envir))
[16:01:40.672]                     }
[16:01:40.672]                     oopts <- options(mc.cores = workers)
[16:01:40.672]                     on.exit(options(oopts))
[16:01:40.672]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:40.672]                       envir = envir)
[16:01:40.672]                     if (!future$lazy) 
[16:01:40.672]                       future <- run(future)
[16:01:40.672]                     invisible(future)
[16:01:40.672]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:40.672]                 }
[16:01:40.672]             }
[16:01:40.672]         }
[16:01:40.672]     })
[16:01:40.672]     if (TRUE) {
[16:01:40.672]         base::sink(type = "output", split = FALSE)
[16:01:40.672]         if (TRUE) {
[16:01:40.672]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:40.672]         }
[16:01:40.672]         else {
[16:01:40.672]             ...future.result["stdout"] <- base::list(NULL)
[16:01:40.672]         }
[16:01:40.672]         base::close(...future.stdout)
[16:01:40.672]         ...future.stdout <- NULL
[16:01:40.672]     }
[16:01:40.672]     ...future.result$conditions <- ...future.conditions
[16:01:40.672]     ...future.result$finished <- base::Sys.time()
[16:01:40.672]     ...future.result
[16:01:40.672] }
[16:01:40.676] assign_globals() ...
[16:01:40.676] List of 5
[16:01:40.676]  $ future.call.arguments    : list()
[16:01:40.676]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.676]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:01:40.676]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:01:40.676]  $ ...future.elements_ii    :List of 1
[16:01:40.676]   ..$ : num [1:4] 2 4 6 8
[16:01:40.676]  $ ...future.seeds_ii       : NULL
[16:01:40.676]  $ ...future.globals.maxSize: num Inf
[16:01:40.676]  - attr(*, "resolved")= logi FALSE
[16:01:40.676]  - attr(*, "total_size")= num NA
[16:01:40.676]  - attr(*, "where")=List of 5
[16:01:40.676]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:40.676]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:40.676]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:40.676]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:40.676]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:40.676]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.676]  - attr(*, "already-done")= logi TRUE
[16:01:40.687] - copied ‘future.call.arguments’ to environment
[16:01:40.688] - copied ‘...future.FUN’ to environment
[16:01:40.688] - copied ‘...future.elements_ii’ to environment
[16:01:40.688] - copied ‘...future.seeds_ii’ to environment
[16:01:40.688] - copied ‘...future.globals.maxSize’ to environment
[16:01:40.689] assign_globals() ... done
[16:01:40.689] requestCore(): workers = 2
[16:01:40.691] MulticoreFuture started
[16:01:40.692] - Launch lazy future ... done
[16:01:40.693] run() for ‘MulticoreFuture’ ... done
[16:01:40.693] plan(): Setting new future strategy stack:
[16:01:40.693] Created future:
[16:01:40.693] List of future strategies:
[16:01:40.693] 1. sequential:
[16:01:40.693]    - args: function (..., envir = parent.frame())
[16:01:40.693]    - tweaked: FALSE
[16:01:40.693]    - call: NULL
[16:01:40.694] plan(): nbrOfWorkers() = 1
[16:01:40.696] plan(): Setting new future strategy stack:
[16:01:40.697] List of future strategies:
[16:01:40.697] 1. multicore:
[16:01:40.697]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:40.697]    - tweaked: FALSE
[16:01:40.697]    - call: plan(strategy)
[16:01:40.702] plan(): nbrOfWorkers() = 2
[16:01:40.693] MulticoreFuture:
[16:01:40.693] Label: ‘future_apply-2’
[16:01:40.693] Expression:
[16:01:40.693] {
[16:01:40.693]     do.call(function(...) {
[16:01:40.693]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.693]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.693]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.693]             on.exit(options(oopts), add = TRUE)
[16:01:40.693]         }
[16:01:40.693]         {
[16:01:40.693]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.693]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.693]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.693]             })
[16:01:40.693]         }
[16:01:40.693]     }, args = future.call.arguments)
[16:01:40.693] }
[16:01:40.693] Lazy evaluation: FALSE
[16:01:40.693] Asynchronous evaluation: TRUE
[16:01:40.693] Local evaluation: TRUE
[16:01:40.693] Environment: R_GlobalEnv
[16:01:40.693] Capture standard output: TRUE
[16:01:40.693] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:40.693] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:40.693] Packages: <none>
[16:01:40.693] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:40.693] Resolved: TRUE
[16:01:40.693] Value: <not collected>
[16:01:40.693] Conditions captured: <none>
[16:01:40.693] Early signaling: FALSE
[16:01:40.693] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:40.693] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:40.703] Chunk #2 of 2 ... DONE
[16:01:40.704] Launching 2 futures (chunks) ... DONE
[16:01:40.704] Resolving 2 futures (chunks) ...
[16:01:40.704] resolve() on list ...
[16:01:40.704]  recursive: 0
[16:01:40.704]  length: 2
[16:01:40.705] 
[16:01:40.705] Future #1
[16:01:40.705] result() for MulticoreFuture ...
[16:01:40.706] result() for MulticoreFuture ...
[16:01:40.707] result() for MulticoreFuture ... done
[16:01:40.707] result() for MulticoreFuture ... done
[16:01:40.707] result() for MulticoreFuture ...
[16:01:40.707] result() for MulticoreFuture ... done
[16:01:40.708] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:01:40.708] - nx: 2
[16:01:40.708] - relay: TRUE
[16:01:40.708] - stdout: TRUE
[16:01:40.708] - signal: TRUE
[16:01:40.709] - resignal: FALSE
[16:01:40.709] - force: TRUE
[16:01:40.709] - relayed: [n=2] FALSE, FALSE
[16:01:40.709] - queued futures: [n=2] FALSE, FALSE
[16:01:40.709]  - until=1
[16:01:40.710]  - relaying element #1
[16:01:40.710] result() for MulticoreFuture ...
[16:01:40.710] result() for MulticoreFuture ... done
[16:01:40.710] result() for MulticoreFuture ...
[16:01:40.710] result() for MulticoreFuture ... done
[16:01:40.711] result() for MulticoreFuture ...
[16:01:40.711] result() for MulticoreFuture ... done
[16:01:40.711] result() for MulticoreFuture ...
[16:01:40.711] result() for MulticoreFuture ... done
[16:01:40.711] - relayed: [n=2] TRUE, FALSE
[16:01:40.711] - queued futures: [n=2] TRUE, FALSE
[16:01:40.712] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:01:40.712]  length: 1 (resolved future 1)
[16:01:40.712] Future #2
[16:01:40.712] result() for MulticoreFuture ...
[16:01:40.713] result() for MulticoreFuture ...
[16:01:40.713] result() for MulticoreFuture ... done
[16:01:40.713] result() for MulticoreFuture ... done
[16:01:40.713] result() for MulticoreFuture ...
[16:01:40.714] result() for MulticoreFuture ... done
[16:01:40.714] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:01:40.714] - nx: 2
[16:01:40.714] - relay: TRUE
[16:01:40.714] - stdout: TRUE
[16:01:40.714] - signal: TRUE
[16:01:40.714] - resignal: FALSE
[16:01:40.714] - force: TRUE
[16:01:40.714] - relayed: [n=2] TRUE, FALSE
[16:01:40.715] - queued futures: [n=2] TRUE, FALSE
[16:01:40.715]  - until=2
[16:01:40.715]  - relaying element #2
[16:01:40.715] result() for MulticoreFuture ...
[16:01:40.715] result() for MulticoreFuture ... done
[16:01:40.715] result() for MulticoreFuture ...
[16:01:40.715] result() for MulticoreFuture ... done
[16:01:40.716] result() for MulticoreFuture ...
[16:01:40.716] result() for MulticoreFuture ... done
[16:01:40.716] result() for MulticoreFuture ...
[16:01:40.716] result() for MulticoreFuture ... done
[16:01:40.716] - relayed: [n=2] TRUE, TRUE
[16:01:40.716] - queued futures: [n=2] TRUE, TRUE
[16:01:40.716] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:01:40.716]  length: 0 (resolved future 2)
[16:01:40.716] Relaying remaining futures
[16:01:40.717] signalConditionsASAP(NULL, pos=0) ...
[16:01:40.717] - nx: 2
[16:01:40.717] - relay: TRUE
[16:01:40.717] - stdout: TRUE
[16:01:40.717] - signal: TRUE
[16:01:40.717] - resignal: FALSE
[16:01:40.717] - force: TRUE
[16:01:40.717] - relayed: [n=2] TRUE, TRUE
[16:01:40.717] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:40.718] - relayed: [n=2] TRUE, TRUE
[16:01:40.718] - queued futures: [n=2] TRUE, TRUE
[16:01:40.718] signalConditionsASAP(NULL, pos=0) ... done
[16:01:40.718] resolve() on list ... DONE
[16:01:40.718] result() for MulticoreFuture ...
[16:01:40.718] result() for MulticoreFuture ... done
[16:01:40.718] result() for MulticoreFuture ...
[16:01:40.718] result() for MulticoreFuture ... done
[16:01:40.718] result() for MulticoreFuture ...
[16:01:40.719] result() for MulticoreFuture ... done
[16:01:40.719] result() for MulticoreFuture ...
[16:01:40.719] result() for MulticoreFuture ... done
[16:01:40.719]  - Number of value chunks collected: 2
[16:01:40.719] Resolving 2 futures (chunks) ... DONE
[16:01:40.719] Reducing values from 2 chunks ...
[16:01:40.719]  - Number of values collected after concatenation: 2
[16:01:40.719]  - Number of values expected: 2
[16:01:40.720] Reducing values from 2 chunks ... DONE
[16:01:40.720] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[16:01:40.721] getGlobalsAndPackagesXApply() ...
[16:01:40.721]  - future.globals: TRUE
[16:01:40.721] getGlobalsAndPackages() ...
[16:01:40.721] Searching for globals...
[16:01:40.722] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:40.722] Searching for globals ... DONE
[16:01:40.723] Resolving globals: FALSE
[16:01:40.723] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:01:40.724] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:01:40.724] - globals: [1] ‘FUN’
[16:01:40.724] - packages: [1] ‘stats’
[16:01:40.724] getGlobalsAndPackages() ... DONE
[16:01:40.724]  - globals found/used: [n=1] ‘FUN’
[16:01:40.724]  - needed namespaces: [n=1] ‘stats’
[16:01:40.724] Finding globals ... DONE
[16:01:40.724]  - use_args: TRUE
[16:01:40.725]  - Getting '...' globals ...
[16:01:40.725] resolve() on list ...
[16:01:40.725]  recursive: 0
[16:01:40.725]  length: 1
[16:01:40.725]  elements: ‘...’
[16:01:40.725]  length: 0 (resolved future 1)
[16:01:40.725] resolve() on list ... DONE
[16:01:40.726]    - '...' content: [n=0] 
[16:01:40.726] List of 1
[16:01:40.726]  $ ...: list()
[16:01:40.726]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.726]  - attr(*, "where")=List of 1
[16:01:40.726]   ..$ ...:<environment: 0x55fb64803250> 
[16:01:40.726]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.726]  - attr(*, "resolved")= logi TRUE
[16:01:40.726]  - attr(*, "total_size")= num NA
[16:01:40.733]  - Getting '...' globals ... DONE
[16:01:40.733] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:40.733] List of 2
[16:01:40.733]  $ ...future.FUN:function (x, ...)  
[16:01:40.733]  $ ...          : list()
[16:01:40.733]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.733]  - attr(*, "where")=List of 2
[16:01:40.733]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:40.733]   ..$ ...          :<environment: 0x55fb64803250> 
[16:01:40.733]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.733]  - attr(*, "resolved")= logi FALSE
[16:01:40.733]  - attr(*, "total_size")= num 1248
[16:01:40.737] Packages to be attached in all futures: [n=1] ‘stats’
[16:01:40.737] getGlobalsAndPackagesXApply() ... DONE
[16:01:40.741] future_lapply() ...
[16:01:40.744] Number of chunks: 2
[16:01:40.745] getGlobalsAndPackagesXApply() ...
[16:01:40.745]  - future.globals: <name-value list> with names ‘list()’
[16:01:40.745]  - use_args: TRUE
[16:01:40.745] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:01:40.745] List of 2
[16:01:40.745]  $ ...          : list()
[16:01:40.745]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.745]  $ ...future.FUN:function (x, ...)  
[16:01:40.745]  - attr(*, "where")=List of 2
[16:01:40.745]   ..$ ...          :<environment: 0x55fb64803250> 
[16:01:40.745]   ..$ ...future.FUN:<environment: namespace:stats> 
[16:01:40.745]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.745]  - attr(*, "resolved")= logi FALSE
[16:01:40.745]  - attr(*, "total_size")= num NA
[16:01:40.748] Packages to be attached in all futures: [n=1] ‘stats’
[16:01:40.748] getGlobalsAndPackagesXApply() ... DONE
[16:01:40.748] Number of futures (= number of chunks): 2
[16:01:40.748] Launching 2 futures (chunks) ...
[16:01:40.748] Chunk #1 of 2 ...
[16:01:40.749]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:40.749]  - seeds: <none>
[16:01:40.749]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.749] getGlobalsAndPackages() ...
[16:01:40.749] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.749] Resolving globals: FALSE
[16:01:40.749] Tweak future expression to call with '...' arguments ...
[16:01:40.749] {
[16:01:40.749]     do.call(function(...) {
[16:01:40.749]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.749]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.749]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.749]             on.exit(options(oopts), add = TRUE)
[16:01:40.749]         }
[16:01:40.749]         {
[16:01:40.749]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.749]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.749]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.749]             })
[16:01:40.749]         }
[16:01:40.749]     }, args = future.call.arguments)
[16:01:40.749] }
[16:01:40.750] Tweak future expression to call with '...' arguments ... DONE
[16:01:40.750] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.750] - packages: [1] ‘stats’
[16:01:40.750] getGlobalsAndPackages() ... DONE
[16:01:40.751] run() for ‘Future’ ...
[16:01:40.751] - state: ‘created’
[16:01:40.751] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:40.754] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:40.754] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:40.754]   - Field: ‘label’
[16:01:40.755]   - Field: ‘local’
[16:01:40.755]   - Field: ‘owner’
[16:01:40.755]   - Field: ‘envir’
[16:01:40.755]   - Field: ‘workers’
[16:01:40.755]   - Field: ‘packages’
[16:01:40.755]   - Field: ‘gc’
[16:01:40.755]   - Field: ‘job’
[16:01:40.755]   - Field: ‘conditions’
[16:01:40.755]   - Field: ‘expr’
[16:01:40.755]   - Field: ‘uuid’
[16:01:40.756]   - Field: ‘seed’
[16:01:40.756]   - Field: ‘version’
[16:01:40.756]   - Field: ‘result’
[16:01:40.756]   - Field: ‘asynchronous’
[16:01:40.756]   - Field: ‘calls’
[16:01:40.756]   - Field: ‘globals’
[16:01:40.756]   - Field: ‘stdout’
[16:01:40.756]   - Field: ‘earlySignal’
[16:01:40.756]   - Field: ‘lazy’
[16:01:40.756]   - Field: ‘state’
[16:01:40.756] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:40.757] - Launch lazy future ...
[16:01:40.757] Packages needed by the future expression (n = 1): ‘stats’
[16:01:40.757] Packages needed by future strategies (n = 0): <none>
[16:01:40.758] {
[16:01:40.758]     {
[16:01:40.758]         {
[16:01:40.758]             ...future.startTime <- base::Sys.time()
[16:01:40.758]             {
[16:01:40.758]                 {
[16:01:40.758]                   {
[16:01:40.758]                     {
[16:01:40.758]                       {
[16:01:40.758]                         base::local({
[16:01:40.758]                           has_future <- base::requireNamespace("future", 
[16:01:40.758]                             quietly = TRUE)
[16:01:40.758]                           if (has_future) {
[16:01:40.758]                             ns <- base::getNamespace("future")
[16:01:40.758]                             version <- ns[[".package"]][["version"]]
[16:01:40.758]                             if (is.null(version)) 
[16:01:40.758]                               version <- utils::packageVersion("future")
[16:01:40.758]                           }
[16:01:40.758]                           else {
[16:01:40.758]                             version <- NULL
[16:01:40.758]                           }
[16:01:40.758]                           if (!has_future || version < "1.8.0") {
[16:01:40.758]                             info <- base::c(r_version = base::gsub("R version ", 
[16:01:40.758]                               "", base::R.version$version.string), 
[16:01:40.758]                               platform = base::sprintf("%s (%s-bit)", 
[16:01:40.758]                                 base::R.version$platform, 8 * 
[16:01:40.758]                                   base::.Machine$sizeof.pointer), 
[16:01:40.758]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:40.758]                                 "release", "version")], collapse = " "), 
[16:01:40.758]                               hostname = base::Sys.info()[["nodename"]])
[16:01:40.758]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:01:40.758]                               info)
[16:01:40.758]                             info <- base::paste(info, collapse = "; ")
[16:01:40.758]                             if (!has_future) {
[16:01:40.758]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:40.758]                                 info)
[16:01:40.758]                             }
[16:01:40.758]                             else {
[16:01:40.758]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:40.758]                                 info, version)
[16:01:40.758]                             }
[16:01:40.758]                             base::stop(msg)
[16:01:40.758]                           }
[16:01:40.758]                         })
[16:01:40.758]                       }
[16:01:40.758]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:40.758]                       base::options(mc.cores = 1L)
[16:01:40.758]                     }
[16:01:40.758]                     base::local({
[16:01:40.758]                       for (pkg in "stats") {
[16:01:40.758]                         base::loadNamespace(pkg)
[16:01:40.758]                         base::library(pkg, character.only = TRUE)
[16:01:40.758]                       }
[16:01:40.758]                     })
[16:01:40.758]                   }
[16:01:40.758]                   options(future.plan = NULL)
[16:01:40.758]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:40.758]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:40.758]                 }
[16:01:40.758]                 ...future.workdir <- getwd()
[16:01:40.758]             }
[16:01:40.758]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:40.758]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:40.758]         }
[16:01:40.758]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:40.758]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:40.758]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:40.758]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:40.758]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:40.758]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:40.758]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:40.758]             base::names(...future.oldOptions))
[16:01:40.758]     }
[16:01:40.758]     if (FALSE) {
[16:01:40.758]     }
[16:01:40.758]     else {
[16:01:40.758]         if (TRUE) {
[16:01:40.758]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:40.758]                 open = "w")
[16:01:40.758]         }
[16:01:40.758]         else {
[16:01:40.758]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:40.758]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:40.758]         }
[16:01:40.758]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:40.758]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:40.758]             base::sink(type = "output", split = FALSE)
[16:01:40.758]             base::close(...future.stdout)
[16:01:40.758]         }, add = TRUE)
[16:01:40.758]     }
[16:01:40.758]     ...future.frame <- base::sys.nframe()
[16:01:40.758]     ...future.conditions <- base::list()
[16:01:40.758]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:40.758]     if (FALSE) {
[16:01:40.758]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:40.758]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:40.758]     }
[16:01:40.758]     ...future.result <- base::tryCatch({
[16:01:40.758]         base::withCallingHandlers({
[16:01:40.758]             ...future.value <- base::withVisible(base::local({
[16:01:40.758]                 withCallingHandlers({
[16:01:40.758]                   {
[16:01:40.758]                     do.call(function(...) {
[16:01:40.758]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.758]                       if (!identical(...future.globals.maxSize.org, 
[16:01:40.758]                         ...future.globals.maxSize)) {
[16:01:40.758]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.758]                         on.exit(options(oopts), add = TRUE)
[16:01:40.758]                       }
[16:01:40.758]                       {
[16:01:40.758]                         lapply(seq_along(...future.elements_ii), 
[16:01:40.758]                           FUN = function(jj) {
[16:01:40.758]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.758]                             ...future.FUN(...future.X_jj, ...)
[16:01:40.758]                           })
[16:01:40.758]                       }
[16:01:40.758]                     }, args = future.call.arguments)
[16:01:40.758]                   }
[16:01:40.758]                 }, immediateCondition = function(cond) {
[16:01:40.758]                   save_rds <- function (object, pathname, ...) 
[16:01:40.758]                   {
[16:01:40.758]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:40.758]                     if (file_test("-f", pathname_tmp)) {
[16:01:40.758]                       fi_tmp <- file.info(pathname_tmp)
[16:01:40.758]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:40.758]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:40.758]                         fi_tmp[["mtime"]])
[16:01:40.758]                     }
[16:01:40.758]                     tryCatch({
[16:01:40.758]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:40.758]                     }, error = function(ex) {
[16:01:40.758]                       msg <- conditionMessage(ex)
[16:01:40.758]                       fi_tmp <- file.info(pathname_tmp)
[16:01:40.758]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:40.758]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:40.758]                         fi_tmp[["mtime"]], msg)
[16:01:40.758]                       ex$message <- msg
[16:01:40.758]                       stop(ex)
[16:01:40.758]                     })
[16:01:40.758]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:40.758]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:40.758]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:40.758]                       fi_tmp <- file.info(pathname_tmp)
[16:01:40.758]                       fi <- file.info(pathname)
[16:01:40.758]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:40.758]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:40.758]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:40.758]                         fi[["size"]], fi[["mtime"]])
[16:01:40.758]                       stop(msg)
[16:01:40.758]                     }
[16:01:40.758]                     invisible(pathname)
[16:01:40.758]                   }
[16:01:40.758]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:40.758]                     rootPath = tempdir()) 
[16:01:40.758]                   {
[16:01:40.758]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:40.758]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:40.758]                       tmpdir = path, fileext = ".rds")
[16:01:40.758]                     save_rds(obj, file)
[16:01:40.758]                   }
[16:01:40.758]                   saveImmediateCondition(cond, path = "/tmp/RtmplAoKyr/.future/immediateConditions")
[16:01:40.758]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.758]                   {
[16:01:40.758]                     inherits <- base::inherits
[16:01:40.758]                     invokeRestart <- base::invokeRestart
[16:01:40.758]                     is.null <- base::is.null
[16:01:40.758]                     muffled <- FALSE
[16:01:40.758]                     if (inherits(cond, "message")) {
[16:01:40.758]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:40.758]                       if (muffled) 
[16:01:40.758]                         invokeRestart("muffleMessage")
[16:01:40.758]                     }
[16:01:40.758]                     else if (inherits(cond, "warning")) {
[16:01:40.758]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:40.758]                       if (muffled) 
[16:01:40.758]                         invokeRestart("muffleWarning")
[16:01:40.758]                     }
[16:01:40.758]                     else if (inherits(cond, "condition")) {
[16:01:40.758]                       if (!is.null(pattern)) {
[16:01:40.758]                         computeRestarts <- base::computeRestarts
[16:01:40.758]                         grepl <- base::grepl
[16:01:40.758]                         restarts <- computeRestarts(cond)
[16:01:40.758]                         for (restart in restarts) {
[16:01:40.758]                           name <- restart$name
[16:01:40.758]                           if (is.null(name)) 
[16:01:40.758]                             next
[16:01:40.758]                           if (!grepl(pattern, name)) 
[16:01:40.758]                             next
[16:01:40.758]                           invokeRestart(restart)
[16:01:40.758]                           muffled <- TRUE
[16:01:40.758]                           break
[16:01:40.758]                         }
[16:01:40.758]                       }
[16:01:40.758]                     }
[16:01:40.758]                     invisible(muffled)
[16:01:40.758]                   }
[16:01:40.758]                   muffleCondition(cond)
[16:01:40.758]                 })
[16:01:40.758]             }))
[16:01:40.758]             future::FutureResult(value = ...future.value$value, 
[16:01:40.758]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:40.758]                   ...future.rng), globalenv = if (FALSE) 
[16:01:40.758]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:40.758]                     ...future.globalenv.names))
[16:01:40.758]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:40.758]         }, condition = base::local({
[16:01:40.758]             c <- base::c
[16:01:40.758]             inherits <- base::inherits
[16:01:40.758]             invokeRestart <- base::invokeRestart
[16:01:40.758]             length <- base::length
[16:01:40.758]             list <- base::list
[16:01:40.758]             seq.int <- base::seq.int
[16:01:40.758]             signalCondition <- base::signalCondition
[16:01:40.758]             sys.calls <- base::sys.calls
[16:01:40.758]             `[[` <- base::`[[`
[16:01:40.758]             `+` <- base::`+`
[16:01:40.758]             `<<-` <- base::`<<-`
[16:01:40.758]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:40.758]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:40.758]                   3L)]
[16:01:40.758]             }
[16:01:40.758]             function(cond) {
[16:01:40.758]                 is_error <- inherits(cond, "error")
[16:01:40.758]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:40.758]                   NULL)
[16:01:40.758]                 if (is_error) {
[16:01:40.758]                   sessionInformation <- function() {
[16:01:40.758]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:40.758]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:40.758]                       search = base::search(), system = base::Sys.info())
[16:01:40.758]                   }
[16:01:40.758]                   ...future.conditions[[length(...future.conditions) + 
[16:01:40.758]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:40.758]                     cond$call), session = sessionInformation(), 
[16:01:40.758]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:40.758]                   signalCondition(cond)
[16:01:40.758]                 }
[16:01:40.758]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:40.758]                 "immediateCondition"))) {
[16:01:40.758]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:40.758]                   ...future.conditions[[length(...future.conditions) + 
[16:01:40.758]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:40.758]                   if (TRUE && !signal) {
[16:01:40.758]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.758]                     {
[16:01:40.758]                       inherits <- base::inherits
[16:01:40.758]                       invokeRestart <- base::invokeRestart
[16:01:40.758]                       is.null <- base::is.null
[16:01:40.758]                       muffled <- FALSE
[16:01:40.758]                       if (inherits(cond, "message")) {
[16:01:40.758]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:40.758]                         if (muffled) 
[16:01:40.758]                           invokeRestart("muffleMessage")
[16:01:40.758]                       }
[16:01:40.758]                       else if (inherits(cond, "warning")) {
[16:01:40.758]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:40.758]                         if (muffled) 
[16:01:40.758]                           invokeRestart("muffleWarning")
[16:01:40.758]                       }
[16:01:40.758]                       else if (inherits(cond, "condition")) {
[16:01:40.758]                         if (!is.null(pattern)) {
[16:01:40.758]                           computeRestarts <- base::computeRestarts
[16:01:40.758]                           grepl <- base::grepl
[16:01:40.758]                           restarts <- computeRestarts(cond)
[16:01:40.758]                           for (restart in restarts) {
[16:01:40.758]                             name <- restart$name
[16:01:40.758]                             if (is.null(name)) 
[16:01:40.758]                               next
[16:01:40.758]                             if (!grepl(pattern, name)) 
[16:01:40.758]                               next
[16:01:40.758]                             invokeRestart(restart)
[16:01:40.758]                             muffled <- TRUE
[16:01:40.758]                             break
[16:01:40.758]                           }
[16:01:40.758]                         }
[16:01:40.758]                       }
[16:01:40.758]                       invisible(muffled)
[16:01:40.758]                     }
[16:01:40.758]                     muffleCondition(cond, pattern = "^muffle")
[16:01:40.758]                   }
[16:01:40.758]                 }
[16:01:40.758]                 else {
[16:01:40.758]                   if (TRUE) {
[16:01:40.758]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.758]                     {
[16:01:40.758]                       inherits <- base::inherits
[16:01:40.758]                       invokeRestart <- base::invokeRestart
[16:01:40.758]                       is.null <- base::is.null
[16:01:40.758]                       muffled <- FALSE
[16:01:40.758]                       if (inherits(cond, "message")) {
[16:01:40.758]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:40.758]                         if (muffled) 
[16:01:40.758]                           invokeRestart("muffleMessage")
[16:01:40.758]                       }
[16:01:40.758]                       else if (inherits(cond, "warning")) {
[16:01:40.758]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:40.758]                         if (muffled) 
[16:01:40.758]                           invokeRestart("muffleWarning")
[16:01:40.758]                       }
[16:01:40.758]                       else if (inherits(cond, "condition")) {
[16:01:40.758]                         if (!is.null(pattern)) {
[16:01:40.758]                           computeRestarts <- base::computeRestarts
[16:01:40.758]                           grepl <- base::grepl
[16:01:40.758]                           restarts <- computeRestarts(cond)
[16:01:40.758]                           for (restart in restarts) {
[16:01:40.758]                             name <- restart$name
[16:01:40.758]                             if (is.null(name)) 
[16:01:40.758]                               next
[16:01:40.758]                             if (!grepl(pattern, name)) 
[16:01:40.758]                               next
[16:01:40.758]                             invokeRestart(restart)
[16:01:40.758]                             muffled <- TRUE
[16:01:40.758]                             break
[16:01:40.758]                           }
[16:01:40.758]                         }
[16:01:40.758]                       }
[16:01:40.758]                       invisible(muffled)
[16:01:40.758]                     }
[16:01:40.758]                     muffleCondition(cond, pattern = "^muffle")
[16:01:40.758]                   }
[16:01:40.758]                 }
[16:01:40.758]             }
[16:01:40.758]         }))
[16:01:40.758]     }, error = function(ex) {
[16:01:40.758]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:40.758]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:40.758]                 ...future.rng), started = ...future.startTime, 
[16:01:40.758]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:40.758]             version = "1.8"), class = "FutureResult")
[16:01:40.758]     }, finally = {
[16:01:40.758]         if (!identical(...future.workdir, getwd())) 
[16:01:40.758]             setwd(...future.workdir)
[16:01:40.758]         {
[16:01:40.758]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:40.758]                 ...future.oldOptions$nwarnings <- NULL
[16:01:40.758]             }
[16:01:40.758]             base::options(...future.oldOptions)
[16:01:40.758]             if (.Platform$OS.type == "windows") {
[16:01:40.758]                 old_names <- names(...future.oldEnvVars)
[16:01:40.758]                 envs <- base::Sys.getenv()
[16:01:40.758]                 names <- names(envs)
[16:01:40.758]                 common <- intersect(names, old_names)
[16:01:40.758]                 added <- setdiff(names, old_names)
[16:01:40.758]                 removed <- setdiff(old_names, names)
[16:01:40.758]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:40.758]                   envs[common]]
[16:01:40.758]                 NAMES <- toupper(changed)
[16:01:40.758]                 args <- list()
[16:01:40.758]                 for (kk in seq_along(NAMES)) {
[16:01:40.758]                   name <- changed[[kk]]
[16:01:40.758]                   NAME <- NAMES[[kk]]
[16:01:40.758]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.758]                     next
[16:01:40.758]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:40.758]                 }
[16:01:40.758]                 NAMES <- toupper(added)
[16:01:40.758]                 for (kk in seq_along(NAMES)) {
[16:01:40.758]                   name <- added[[kk]]
[16:01:40.758]                   NAME <- NAMES[[kk]]
[16:01:40.758]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.758]                     next
[16:01:40.758]                   args[[name]] <- ""
[16:01:40.758]                 }
[16:01:40.758]                 NAMES <- toupper(removed)
[16:01:40.758]                 for (kk in seq_along(NAMES)) {
[16:01:40.758]                   name <- removed[[kk]]
[16:01:40.758]                   NAME <- NAMES[[kk]]
[16:01:40.758]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.758]                     next
[16:01:40.758]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:40.758]                 }
[16:01:40.758]                 if (length(args) > 0) 
[16:01:40.758]                   base::do.call(base::Sys.setenv, args = args)
[16:01:40.758]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:40.758]             }
[16:01:40.758]             else {
[16:01:40.758]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:40.758]             }
[16:01:40.758]             {
[16:01:40.758]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:40.758]                   0L) {
[16:01:40.758]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:40.758]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:40.758]                   base::options(opts)
[16:01:40.758]                 }
[16:01:40.758]                 {
[16:01:40.758]                   {
[16:01:40.758]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:40.758]                     NULL
[16:01:40.758]                   }
[16:01:40.758]                   options(future.plan = NULL)
[16:01:40.758]                   if (is.na(NA_character_)) 
[16:01:40.758]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:40.758]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:40.758]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:40.758]                     envir = parent.frame()) 
[16:01:40.758]                   {
[16:01:40.758]                     default_workers <- missing(workers)
[16:01:40.758]                     if (is.function(workers)) 
[16:01:40.758]                       workers <- workers()
[16:01:40.758]                     workers <- structure(as.integer(workers), 
[16:01:40.758]                       class = class(workers))
[16:01:40.758]                     stop_if_not(is.finite(workers), workers >= 
[16:01:40.758]                       1L)
[16:01:40.758]                     if ((workers == 1L && !inherits(workers, 
[16:01:40.758]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:40.758]                       if (default_workers) 
[16:01:40.758]                         supportsMulticore(warn = TRUE)
[16:01:40.758]                       return(sequential(..., envir = envir))
[16:01:40.758]                     }
[16:01:40.758]                     oopts <- options(mc.cores = workers)
[16:01:40.758]                     on.exit(options(oopts))
[16:01:40.758]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:40.758]                       envir = envir)
[16:01:40.758]                     if (!future$lazy) 
[16:01:40.758]                       future <- run(future)
[16:01:40.758]                     invisible(future)
[16:01:40.758]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:40.758]                 }
[16:01:40.758]             }
[16:01:40.758]         }
[16:01:40.758]     })
[16:01:40.758]     if (TRUE) {
[16:01:40.758]         base::sink(type = "output", split = FALSE)
[16:01:40.758]         if (TRUE) {
[16:01:40.758]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:40.758]         }
[16:01:40.758]         else {
[16:01:40.758]             ...future.result["stdout"] <- base::list(NULL)
[16:01:40.758]         }
[16:01:40.758]         base::close(...future.stdout)
[16:01:40.758]         ...future.stdout <- NULL
[16:01:40.758]     }
[16:01:40.758]     ...future.result$conditions <- ...future.conditions
[16:01:40.758]     ...future.result$finished <- base::Sys.time()
[16:01:40.758]     ...future.result
[16:01:40.758] }
[16:01:40.760] assign_globals() ...
[16:01:40.760] List of 5
[16:01:40.760]  $ future.call.arguments    : list()
[16:01:40.760]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.760]  $ ...future.FUN            :function (x, ...)  
[16:01:40.760]  $ ...future.elements_ii    :List of 1
[16:01:40.760]   ..$ : num [1:4] 1 3 1 7
[16:01:40.760]  $ ...future.seeds_ii       : NULL
[16:01:40.760]  $ ...future.globals.maxSize: num Inf
[16:01:40.760]  - attr(*, "resolved")= logi FALSE
[16:01:40.760]  - attr(*, "total_size")= num NA
[16:01:40.760]  - attr(*, "where")=List of 5
[16:01:40.760]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:40.760]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:40.760]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:40.760]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:40.760]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:40.760]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.760]  - attr(*, "already-done")= logi TRUE
[16:01:40.767] - copied ‘future.call.arguments’ to environment
[16:01:40.767] - copied ‘...future.FUN’ to environment
[16:01:40.767] - copied ‘...future.elements_ii’ to environment
[16:01:40.767] - copied ‘...future.seeds_ii’ to environment
[16:01:40.767] - copied ‘...future.globals.maxSize’ to environment
[16:01:40.767] assign_globals() ... done
[16:01:40.768] requestCore(): workers = 2
[16:01:40.770] MulticoreFuture started
[16:01:40.770] - Launch lazy future ... done
[16:01:40.771] run() for ‘MulticoreFuture’ ... done
[16:01:40.771] Created future:
[16:01:40.771] plan(): Setting new future strategy stack:
[16:01:40.772] List of future strategies:
[16:01:40.772] 1. sequential:
[16:01:40.772]    - args: function (..., envir = parent.frame())
[16:01:40.772]    - tweaked: FALSE
[16:01:40.772]    - call: NULL
[16:01:40.773] plan(): nbrOfWorkers() = 1
[16:01:40.775] plan(): Setting new future strategy stack:
[16:01:40.776] List of future strategies:
[16:01:40.776] 1. multicore:
[16:01:40.776]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:40.776]    - tweaked: FALSE
[16:01:40.776]    - call: plan(strategy)
[16:01:40.781] plan(): nbrOfWorkers() = 2
[16:01:40.771] MulticoreFuture:
[16:01:40.771] Label: ‘future_apply-1’
[16:01:40.771] Expression:
[16:01:40.771] {
[16:01:40.771]     do.call(function(...) {
[16:01:40.771]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.771]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.771]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.771]             on.exit(options(oopts), add = TRUE)
[16:01:40.771]         }
[16:01:40.771]         {
[16:01:40.771]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.771]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.771]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.771]             })
[16:01:40.771]         }
[16:01:40.771]     }, args = future.call.arguments)
[16:01:40.771] }
[16:01:40.771] Lazy evaluation: FALSE
[16:01:40.771] Asynchronous evaluation: TRUE
[16:01:40.771] Local evaluation: TRUE
[16:01:40.771] Environment: R_GlobalEnv
[16:01:40.771] Capture standard output: TRUE
[16:01:40.771] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:40.771] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:40.771] Packages: 1 packages (‘stats’)
[16:01:40.771] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:40.771] Resolved: TRUE
[16:01:40.771] Value: <not collected>
[16:01:40.771] Conditions captured: <none>
[16:01:40.771] Early signaling: FALSE
[16:01:40.771] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:40.771] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:40.782] Chunk #1 of 2 ... DONE
[16:01:40.783] Chunk #2 of 2 ...
[16:01:40.783]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:40.783]  - seeds: <none>
[16:01:40.783]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.783] getGlobalsAndPackages() ...
[16:01:40.784] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.784] Resolving globals: FALSE
[16:01:40.784] Tweak future expression to call with '...' arguments ...
[16:01:40.784] {
[16:01:40.784]     do.call(function(...) {
[16:01:40.784]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.784]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.784]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.784]             on.exit(options(oopts), add = TRUE)
[16:01:40.784]         }
[16:01:40.784]         {
[16:01:40.784]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.784]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.784]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.784]             })
[16:01:40.784]         }
[16:01:40.784]     }, args = future.call.arguments)
[16:01:40.784] }
[16:01:40.785] Tweak future expression to call with '...' arguments ... DONE
[16:01:40.785] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.785] - packages: [1] ‘stats’
[16:01:40.786] getGlobalsAndPackages() ... DONE
[16:01:40.786] run() for ‘Future’ ...
[16:01:40.786] - state: ‘created’
[16:01:40.787] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:40.791] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:40.791] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:40.792]   - Field: ‘label’
[16:01:40.792]   - Field: ‘local’
[16:01:40.792]   - Field: ‘owner’
[16:01:40.792]   - Field: ‘envir’
[16:01:40.792]   - Field: ‘workers’
[16:01:40.792]   - Field: ‘packages’
[16:01:40.793]   - Field: ‘gc’
[16:01:40.793]   - Field: ‘job’
[16:01:40.793]   - Field: ‘conditions’
[16:01:40.793]   - Field: ‘expr’
[16:01:40.793]   - Field: ‘uuid’
[16:01:40.793]   - Field: ‘seed’
[16:01:40.793]   - Field: ‘version’
[16:01:40.794]   - Field: ‘result’
[16:01:40.794]   - Field: ‘asynchronous’
[16:01:40.794]   - Field: ‘calls’
[16:01:40.794]   - Field: ‘globals’
[16:01:40.794]   - Field: ‘stdout’
[16:01:40.794]   - Field: ‘earlySignal’
[16:01:40.794]   - Field: ‘lazy’
[16:01:40.794]   - Field: ‘state’
[16:01:40.795] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:40.795] - Launch lazy future ...
[16:01:40.795] Packages needed by the future expression (n = 1): ‘stats’
[16:01:40.796] Packages needed by future strategies (n = 0): <none>
[16:01:40.796] {
[16:01:40.796]     {
[16:01:40.796]         {
[16:01:40.796]             ...future.startTime <- base::Sys.time()
[16:01:40.796]             {
[16:01:40.796]                 {
[16:01:40.796]                   {
[16:01:40.796]                     {
[16:01:40.796]                       {
[16:01:40.796]                         base::local({
[16:01:40.796]                           has_future <- base::requireNamespace("future", 
[16:01:40.796]                             quietly = TRUE)
[16:01:40.796]                           if (has_future) {
[16:01:40.796]                             ns <- base::getNamespace("future")
[16:01:40.796]                             version <- ns[[".package"]][["version"]]
[16:01:40.796]                             if (is.null(version)) 
[16:01:40.796]                               version <- utils::packageVersion("future")
[16:01:40.796]                           }
[16:01:40.796]                           else {
[16:01:40.796]                             version <- NULL
[16:01:40.796]                           }
[16:01:40.796]                           if (!has_future || version < "1.8.0") {
[16:01:40.796]                             info <- base::c(r_version = base::gsub("R version ", 
[16:01:40.796]                               "", base::R.version$version.string), 
[16:01:40.796]                               platform = base::sprintf("%s (%s-bit)", 
[16:01:40.796]                                 base::R.version$platform, 8 * 
[16:01:40.796]                                   base::.Machine$sizeof.pointer), 
[16:01:40.796]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:40.796]                                 "release", "version")], collapse = " "), 
[16:01:40.796]                               hostname = base::Sys.info()[["nodename"]])
[16:01:40.796]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:01:40.796]                               info)
[16:01:40.796]                             info <- base::paste(info, collapse = "; ")
[16:01:40.796]                             if (!has_future) {
[16:01:40.796]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:40.796]                                 info)
[16:01:40.796]                             }
[16:01:40.796]                             else {
[16:01:40.796]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:40.796]                                 info, version)
[16:01:40.796]                             }
[16:01:40.796]                             base::stop(msg)
[16:01:40.796]                           }
[16:01:40.796]                         })
[16:01:40.796]                       }
[16:01:40.796]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:40.796]                       base::options(mc.cores = 1L)
[16:01:40.796]                     }
[16:01:40.796]                     base::local({
[16:01:40.796]                       for (pkg in "stats") {
[16:01:40.796]                         base::loadNamespace(pkg)
[16:01:40.796]                         base::library(pkg, character.only = TRUE)
[16:01:40.796]                       }
[16:01:40.796]                     })
[16:01:40.796]                   }
[16:01:40.796]                   options(future.plan = NULL)
[16:01:40.796]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:40.796]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:40.796]                 }
[16:01:40.796]                 ...future.workdir <- getwd()
[16:01:40.796]             }
[16:01:40.796]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:40.796]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:40.796]         }
[16:01:40.796]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:40.796]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:40.796]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:40.796]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:40.796]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:40.796]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:40.796]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:40.796]             base::names(...future.oldOptions))
[16:01:40.796]     }
[16:01:40.796]     if (FALSE) {
[16:01:40.796]     }
[16:01:40.796]     else {
[16:01:40.796]         if (TRUE) {
[16:01:40.796]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:40.796]                 open = "w")
[16:01:40.796]         }
[16:01:40.796]         else {
[16:01:40.796]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:40.796]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:40.796]         }
[16:01:40.796]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:40.796]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:40.796]             base::sink(type = "output", split = FALSE)
[16:01:40.796]             base::close(...future.stdout)
[16:01:40.796]         }, add = TRUE)
[16:01:40.796]     }
[16:01:40.796]     ...future.frame <- base::sys.nframe()
[16:01:40.796]     ...future.conditions <- base::list()
[16:01:40.796]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:40.796]     if (FALSE) {
[16:01:40.796]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:40.796]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:40.796]     }
[16:01:40.796]     ...future.result <- base::tryCatch({
[16:01:40.796]         base::withCallingHandlers({
[16:01:40.796]             ...future.value <- base::withVisible(base::local({
[16:01:40.796]                 withCallingHandlers({
[16:01:40.796]                   {
[16:01:40.796]                     do.call(function(...) {
[16:01:40.796]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.796]                       if (!identical(...future.globals.maxSize.org, 
[16:01:40.796]                         ...future.globals.maxSize)) {
[16:01:40.796]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.796]                         on.exit(options(oopts), add = TRUE)
[16:01:40.796]                       }
[16:01:40.796]                       {
[16:01:40.796]                         lapply(seq_along(...future.elements_ii), 
[16:01:40.796]                           FUN = function(jj) {
[16:01:40.796]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.796]                             ...future.FUN(...future.X_jj, ...)
[16:01:40.796]                           })
[16:01:40.796]                       }
[16:01:40.796]                     }, args = future.call.arguments)
[16:01:40.796]                   }
[16:01:40.796]                 }, immediateCondition = function(cond) {
[16:01:40.796]                   save_rds <- function (object, pathname, ...) 
[16:01:40.796]                   {
[16:01:40.796]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:40.796]                     if (file_test("-f", pathname_tmp)) {
[16:01:40.796]                       fi_tmp <- file.info(pathname_tmp)
[16:01:40.796]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:40.796]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:40.796]                         fi_tmp[["mtime"]])
[16:01:40.796]                     }
[16:01:40.796]                     tryCatch({
[16:01:40.796]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:40.796]                     }, error = function(ex) {
[16:01:40.796]                       msg <- conditionMessage(ex)
[16:01:40.796]                       fi_tmp <- file.info(pathname_tmp)
[16:01:40.796]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:40.796]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:40.796]                         fi_tmp[["mtime"]], msg)
[16:01:40.796]                       ex$message <- msg
[16:01:40.796]                       stop(ex)
[16:01:40.796]                     })
[16:01:40.796]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:40.796]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:40.796]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:40.796]                       fi_tmp <- file.info(pathname_tmp)
[16:01:40.796]                       fi <- file.info(pathname)
[16:01:40.796]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:40.796]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:40.796]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:40.796]                         fi[["size"]], fi[["mtime"]])
[16:01:40.796]                       stop(msg)
[16:01:40.796]                     }
[16:01:40.796]                     invisible(pathname)
[16:01:40.796]                   }
[16:01:40.796]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:40.796]                     rootPath = tempdir()) 
[16:01:40.796]                   {
[16:01:40.796]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:40.796]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:40.796]                       tmpdir = path, fileext = ".rds")
[16:01:40.796]                     save_rds(obj, file)
[16:01:40.796]                   }
[16:01:40.796]                   saveImmediateCondition(cond, path = "/tmp/RtmplAoKyr/.future/immediateConditions")
[16:01:40.796]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.796]                   {
[16:01:40.796]                     inherits <- base::inherits
[16:01:40.796]                     invokeRestart <- base::invokeRestart
[16:01:40.796]                     is.null <- base::is.null
[16:01:40.796]                     muffled <- FALSE
[16:01:40.796]                     if (inherits(cond, "message")) {
[16:01:40.796]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:40.796]                       if (muffled) 
[16:01:40.796]                         invokeRestart("muffleMessage")
[16:01:40.796]                     }
[16:01:40.796]                     else if (inherits(cond, "warning")) {
[16:01:40.796]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:40.796]                       if (muffled) 
[16:01:40.796]                         invokeRestart("muffleWarning")
[16:01:40.796]                     }
[16:01:40.796]                     else if (inherits(cond, "condition")) {
[16:01:40.796]                       if (!is.null(pattern)) {
[16:01:40.796]                         computeRestarts <- base::computeRestarts
[16:01:40.796]                         grepl <- base::grepl
[16:01:40.796]                         restarts <- computeRestarts(cond)
[16:01:40.796]                         for (restart in restarts) {
[16:01:40.796]                           name <- restart$name
[16:01:40.796]                           if (is.null(name)) 
[16:01:40.796]                             next
[16:01:40.796]                           if (!grepl(pattern, name)) 
[16:01:40.796]                             next
[16:01:40.796]                           invokeRestart(restart)
[16:01:40.796]                           muffled <- TRUE
[16:01:40.796]                           break
[16:01:40.796]                         }
[16:01:40.796]                       }
[16:01:40.796]                     }
[16:01:40.796]                     invisible(muffled)
[16:01:40.796]                   }
[16:01:40.796]                   muffleCondition(cond)
[16:01:40.796]                 })
[16:01:40.796]             }))
[16:01:40.796]             future::FutureResult(value = ...future.value$value, 
[16:01:40.796]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:40.796]                   ...future.rng), globalenv = if (FALSE) 
[16:01:40.796]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:40.796]                     ...future.globalenv.names))
[16:01:40.796]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:40.796]         }, condition = base::local({
[16:01:40.796]             c <- base::c
[16:01:40.796]             inherits <- base::inherits
[16:01:40.796]             invokeRestart <- base::invokeRestart
[16:01:40.796]             length <- base::length
[16:01:40.796]             list <- base::list
[16:01:40.796]             seq.int <- base::seq.int
[16:01:40.796]             signalCondition <- base::signalCondition
[16:01:40.796]             sys.calls <- base::sys.calls
[16:01:40.796]             `[[` <- base::`[[`
[16:01:40.796]             `+` <- base::`+`
[16:01:40.796]             `<<-` <- base::`<<-`
[16:01:40.796]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:40.796]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:40.796]                   3L)]
[16:01:40.796]             }
[16:01:40.796]             function(cond) {
[16:01:40.796]                 is_error <- inherits(cond, "error")
[16:01:40.796]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:40.796]                   NULL)
[16:01:40.796]                 if (is_error) {
[16:01:40.796]                   sessionInformation <- function() {
[16:01:40.796]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:40.796]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:40.796]                       search = base::search(), system = base::Sys.info())
[16:01:40.796]                   }
[16:01:40.796]                   ...future.conditions[[length(...future.conditions) + 
[16:01:40.796]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:40.796]                     cond$call), session = sessionInformation(), 
[16:01:40.796]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:40.796]                   signalCondition(cond)
[16:01:40.796]                 }
[16:01:40.796]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:40.796]                 "immediateCondition"))) {
[16:01:40.796]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:40.796]                   ...future.conditions[[length(...future.conditions) + 
[16:01:40.796]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:40.796]                   if (TRUE && !signal) {
[16:01:40.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.796]                     {
[16:01:40.796]                       inherits <- base::inherits
[16:01:40.796]                       invokeRestart <- base::invokeRestart
[16:01:40.796]                       is.null <- base::is.null
[16:01:40.796]                       muffled <- FALSE
[16:01:40.796]                       if (inherits(cond, "message")) {
[16:01:40.796]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:40.796]                         if (muffled) 
[16:01:40.796]                           invokeRestart("muffleMessage")
[16:01:40.796]                       }
[16:01:40.796]                       else if (inherits(cond, "warning")) {
[16:01:40.796]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:40.796]                         if (muffled) 
[16:01:40.796]                           invokeRestart("muffleWarning")
[16:01:40.796]                       }
[16:01:40.796]                       else if (inherits(cond, "condition")) {
[16:01:40.796]                         if (!is.null(pattern)) {
[16:01:40.796]                           computeRestarts <- base::computeRestarts
[16:01:40.796]                           grepl <- base::grepl
[16:01:40.796]                           restarts <- computeRestarts(cond)
[16:01:40.796]                           for (restart in restarts) {
[16:01:40.796]                             name <- restart$name
[16:01:40.796]                             if (is.null(name)) 
[16:01:40.796]                               next
[16:01:40.796]                             if (!grepl(pattern, name)) 
[16:01:40.796]                               next
[16:01:40.796]                             invokeRestart(restart)
[16:01:40.796]                             muffled <- TRUE
[16:01:40.796]                             break
[16:01:40.796]                           }
[16:01:40.796]                         }
[16:01:40.796]                       }
[16:01:40.796]                       invisible(muffled)
[16:01:40.796]                     }
[16:01:40.796]                     muffleCondition(cond, pattern = "^muffle")
[16:01:40.796]                   }
[16:01:40.796]                 }
[16:01:40.796]                 else {
[16:01:40.796]                   if (TRUE) {
[16:01:40.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.796]                     {
[16:01:40.796]                       inherits <- base::inherits
[16:01:40.796]                       invokeRestart <- base::invokeRestart
[16:01:40.796]                       is.null <- base::is.null
[16:01:40.796]                       muffled <- FALSE
[16:01:40.796]                       if (inherits(cond, "message")) {
[16:01:40.796]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:40.796]                         if (muffled) 
[16:01:40.796]                           invokeRestart("muffleMessage")
[16:01:40.796]                       }
[16:01:40.796]                       else if (inherits(cond, "warning")) {
[16:01:40.796]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:40.796]                         if (muffled) 
[16:01:40.796]                           invokeRestart("muffleWarning")
[16:01:40.796]                       }
[16:01:40.796]                       else if (inherits(cond, "condition")) {
[16:01:40.796]                         if (!is.null(pattern)) {
[16:01:40.796]                           computeRestarts <- base::computeRestarts
[16:01:40.796]                           grepl <- base::grepl
[16:01:40.796]                           restarts <- computeRestarts(cond)
[16:01:40.796]                           for (restart in restarts) {
[16:01:40.796]                             name <- restart$name
[16:01:40.796]                             if (is.null(name)) 
[16:01:40.796]                               next
[16:01:40.796]                             if (!grepl(pattern, name)) 
[16:01:40.796]                               next
[16:01:40.796]                             invokeRestart(restart)
[16:01:40.796]                             muffled <- TRUE
[16:01:40.796]                             break
[16:01:40.796]                           }
[16:01:40.796]                         }
[16:01:40.796]                       }
[16:01:40.796]                       invisible(muffled)
[16:01:40.796]                     }
[16:01:40.796]                     muffleCondition(cond, pattern = "^muffle")
[16:01:40.796]                   }
[16:01:40.796]                 }
[16:01:40.796]             }
[16:01:40.796]         }))
[16:01:40.796]     }, error = function(ex) {
[16:01:40.796]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:40.796]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:40.796]                 ...future.rng), started = ...future.startTime, 
[16:01:40.796]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:40.796]             version = "1.8"), class = "FutureResult")
[16:01:40.796]     }, finally = {
[16:01:40.796]         if (!identical(...future.workdir, getwd())) 
[16:01:40.796]             setwd(...future.workdir)
[16:01:40.796]         {
[16:01:40.796]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:40.796]                 ...future.oldOptions$nwarnings <- NULL
[16:01:40.796]             }
[16:01:40.796]             base::options(...future.oldOptions)
[16:01:40.796]             if (.Platform$OS.type == "windows") {
[16:01:40.796]                 old_names <- names(...future.oldEnvVars)
[16:01:40.796]                 envs <- base::Sys.getenv()
[16:01:40.796]                 names <- names(envs)
[16:01:40.796]                 common <- intersect(names, old_names)
[16:01:40.796]                 added <- setdiff(names, old_names)
[16:01:40.796]                 removed <- setdiff(old_names, names)
[16:01:40.796]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:40.796]                   envs[common]]
[16:01:40.796]                 NAMES <- toupper(changed)
[16:01:40.796]                 args <- list()
[16:01:40.796]                 for (kk in seq_along(NAMES)) {
[16:01:40.796]                   name <- changed[[kk]]
[16:01:40.796]                   NAME <- NAMES[[kk]]
[16:01:40.796]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.796]                     next
[16:01:40.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:40.796]                 }
[16:01:40.796]                 NAMES <- toupper(added)
[16:01:40.796]                 for (kk in seq_along(NAMES)) {
[16:01:40.796]                   name <- added[[kk]]
[16:01:40.796]                   NAME <- NAMES[[kk]]
[16:01:40.796]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.796]                     next
[16:01:40.796]                   args[[name]] <- ""
[16:01:40.796]                 }
[16:01:40.796]                 NAMES <- toupper(removed)
[16:01:40.796]                 for (kk in seq_along(NAMES)) {
[16:01:40.796]                   name <- removed[[kk]]
[16:01:40.796]                   NAME <- NAMES[[kk]]
[16:01:40.796]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.796]                     next
[16:01:40.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:40.796]                 }
[16:01:40.796]                 if (length(args) > 0) 
[16:01:40.796]                   base::do.call(base::Sys.setenv, args = args)
[16:01:40.796]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:40.796]             }
[16:01:40.796]             else {
[16:01:40.796]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:40.796]             }
[16:01:40.796]             {
[16:01:40.796]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:40.796]                   0L) {
[16:01:40.796]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:40.796]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:40.796]                   base::options(opts)
[16:01:40.796]                 }
[16:01:40.796]                 {
[16:01:40.796]                   {
[16:01:40.796]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:40.796]                     NULL
[16:01:40.796]                   }
[16:01:40.796]                   options(future.plan = NULL)
[16:01:40.796]                   if (is.na(NA_character_)) 
[16:01:40.796]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:40.796]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:40.796]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:40.796]                     envir = parent.frame()) 
[16:01:40.796]                   {
[16:01:40.796]                     default_workers <- missing(workers)
[16:01:40.796]                     if (is.function(workers)) 
[16:01:40.796]                       workers <- workers()
[16:01:40.796]                     workers <- structure(as.integer(workers), 
[16:01:40.796]                       class = class(workers))
[16:01:40.796]                     stop_if_not(is.finite(workers), workers >= 
[16:01:40.796]                       1L)
[16:01:40.796]                     if ((workers == 1L && !inherits(workers, 
[16:01:40.796]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:40.796]                       if (default_workers) 
[16:01:40.796]                         supportsMulticore(warn = TRUE)
[16:01:40.796]                       return(sequential(..., envir = envir))
[16:01:40.796]                     }
[16:01:40.796]                     oopts <- options(mc.cores = workers)
[16:01:40.796]                     on.exit(options(oopts))
[16:01:40.796]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:40.796]                       envir = envir)
[16:01:40.796]                     if (!future$lazy) 
[16:01:40.796]                       future <- run(future)
[16:01:40.796]                     invisible(future)
[16:01:40.796]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:40.796]                 }
[16:01:40.796]             }
[16:01:40.796]         }
[16:01:40.796]     })
[16:01:40.796]     if (TRUE) {
[16:01:40.796]         base::sink(type = "output", split = FALSE)
[16:01:40.796]         if (TRUE) {
[16:01:40.796]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:40.796]         }
[16:01:40.796]         else {
[16:01:40.796]             ...future.result["stdout"] <- base::list(NULL)
[16:01:40.796]         }
[16:01:40.796]         base::close(...future.stdout)
[16:01:40.796]         ...future.stdout <- NULL
[16:01:40.796]     }
[16:01:40.796]     ...future.result$conditions <- ...future.conditions
[16:01:40.796]     ...future.result$finished <- base::Sys.time()
[16:01:40.796]     ...future.result
[16:01:40.796] }
[16:01:40.800] assign_globals() ...
[16:01:40.800] List of 5
[16:01:40.800]  $ future.call.arguments    : list()
[16:01:40.800]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.800]  $ ...future.FUN            :function (x, ...)  
[16:01:40.800]  $ ...future.elements_ii    :List of 1
[16:01:40.800]   ..$ : num [1:4] 2 4 6 8
[16:01:40.800]  $ ...future.seeds_ii       : NULL
[16:01:40.800]  $ ...future.globals.maxSize: num Inf
[16:01:40.800]  - attr(*, "resolved")= logi FALSE
[16:01:40.800]  - attr(*, "total_size")= num NA
[16:01:40.800]  - attr(*, "where")=List of 5
[16:01:40.800]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:40.800]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:40.800]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:40.800]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:40.800]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:40.800]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.800]  - attr(*, "already-done")= logi TRUE
[16:01:40.807] - copied ‘future.call.arguments’ to environment
[16:01:40.808] - copied ‘...future.FUN’ to environment
[16:01:40.808] - copied ‘...future.elements_ii’ to environment
[16:01:40.808] - copied ‘...future.seeds_ii’ to environment
[16:01:40.808] - copied ‘...future.globals.maxSize’ to environment
[16:01:40.808] assign_globals() ... done
[16:01:40.808] requestCore(): workers = 2
[16:01:40.811] MulticoreFuture started
[16:01:40.811] - Launch lazy future ... done
[16:01:40.811] run() for ‘MulticoreFuture’ ... done
[16:01:40.811] Created future:
[16:01:40.812] plan(): Setting new future strategy stack:
[16:01:40.812] List of future strategies:
[16:01:40.812] 1. sequential:
[16:01:40.812]    - args: function (..., envir = parent.frame())
[16:01:40.812]    - tweaked: FALSE
[16:01:40.812]    - call: NULL
[16:01:40.813] plan(): nbrOfWorkers() = 1
[16:01:40.816] plan(): Setting new future strategy stack:
[16:01:40.816] List of future strategies:
[16:01:40.816] 1. multicore:
[16:01:40.816]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:40.816]    - tweaked: FALSE
[16:01:40.816]    - call: plan(strategy)
[16:01:40.812] MulticoreFuture:
[16:01:40.812] Label: ‘future_apply-2’
[16:01:40.812] Expression:
[16:01:40.812] {
[16:01:40.812]     do.call(function(...) {
[16:01:40.812]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.812]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.812]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.812]             on.exit(options(oopts), add = TRUE)
[16:01:40.812]         }
[16:01:40.812]         {
[16:01:40.812]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.812]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.812]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.812]             })
[16:01:40.812]         }
[16:01:40.812]     }, args = future.call.arguments)
[16:01:40.812] }
[16:01:40.812] Lazy evaluation: FALSE
[16:01:40.812] Asynchronous evaluation: TRUE
[16:01:40.812] Local evaluation: TRUE
[16:01:40.812] Environment: R_GlobalEnv
[16:01:40.812] Capture standard output: TRUE
[16:01:40.812] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:40.812] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:40.812] Packages: 1 packages (‘stats’)
[16:01:40.812] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:40.812] Resolved: FALSE
[16:01:40.812] Value: <not collected>
[16:01:40.812] Conditions captured: <none>
[16:01:40.812] Early signaling: FALSE
[16:01:40.812] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:40.812] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:40.824] Chunk #2 of 2 ... DONE
[16:01:40.824] Launching 2 futures (chunks) ... DONE
[16:01:40.825] Resolving 2 futures (chunks) ...
[16:01:40.825] resolve() on list ...
[16:01:40.825]  recursive: 0
[16:01:40.825]  length: 2
[16:01:40.825] 
[16:01:40.825] plan(): nbrOfWorkers() = 2
[16:01:40.826] Future #1
[16:01:40.826] result() for MulticoreFuture ...
[16:01:40.829] result() for MulticoreFuture ...
[16:01:40.830] result() for MulticoreFuture ... done
[16:01:40.830] result() for MulticoreFuture ... done
[16:01:40.830] result() for MulticoreFuture ...
[16:01:40.831] result() for MulticoreFuture ... done
[16:01:40.831] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:01:40.832] - nx: 2
[16:01:40.832] - relay: TRUE
[16:01:40.832] - stdout: TRUE
[16:01:40.833] - signal: TRUE
[16:01:40.833] - resignal: FALSE
[16:01:40.833] - force: TRUE
[16:01:40.834] - relayed: [n=2] FALSE, FALSE
[16:01:40.834] - queued futures: [n=2] FALSE, FALSE
[16:01:40.834]  - until=1
[16:01:40.834]  - relaying element #1
[16:01:40.835] result() for MulticoreFuture ...
[16:01:40.835] result() for MulticoreFuture ... done
[16:01:40.835] result() for MulticoreFuture ...
[16:01:40.836] result() for MulticoreFuture ... done
[16:01:40.836] result() for MulticoreFuture ...
[16:01:40.836] result() for MulticoreFuture ... done
[16:01:40.836] result() for MulticoreFuture ...
[16:01:40.837] result() for MulticoreFuture ... done
[16:01:40.837] - relayed: [n=2] TRUE, FALSE
[16:01:40.837] - queued futures: [n=2] TRUE, FALSE
[16:01:40.837] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:01:40.838]  length: 1 (resolved future 1)
[16:01:40.838] Future #2
[16:01:40.838] result() for MulticoreFuture ...
[16:01:40.839] result() for MulticoreFuture ...
[16:01:40.839] result() for MulticoreFuture ... done
[16:01:40.839] result() for MulticoreFuture ... done
[16:01:40.840] result() for MulticoreFuture ...
[16:01:40.840] result() for MulticoreFuture ... done
[16:01:40.840] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:01:40.840] - nx: 2
[16:01:40.840] - relay: TRUE
[16:01:40.840] - stdout: TRUE
[16:01:40.840] - signal: TRUE
[16:01:40.840] - resignal: FALSE
[16:01:40.840] - force: TRUE
[16:01:40.841] - relayed: [n=2] TRUE, FALSE
[16:01:40.841] - queued futures: [n=2] TRUE, FALSE
[16:01:40.841]  - until=2
[16:01:40.841]  - relaying element #2
[16:01:40.841] result() for MulticoreFuture ...
[16:01:40.841] result() for MulticoreFuture ... done
[16:01:40.841] result() for MulticoreFuture ...
[16:01:40.841] result() for MulticoreFuture ... done
[16:01:40.842] result() for MulticoreFuture ...
[16:01:40.842] result() for MulticoreFuture ... done
[16:01:40.842] result() for MulticoreFuture ...
[16:01:40.842] result() for MulticoreFuture ... done
[16:01:40.842] - relayed: [n=2] TRUE, TRUE
[16:01:40.842] - queued futures: [n=2] TRUE, TRUE
[16:01:40.842] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:01:40.842]  length: 0 (resolved future 2)
[16:01:40.843] Relaying remaining futures
[16:01:40.843] signalConditionsASAP(NULL, pos=0) ...
[16:01:40.843] - nx: 2
[16:01:40.843] - relay: TRUE
[16:01:40.843] - stdout: TRUE
[16:01:40.843] - signal: TRUE
[16:01:40.843] - resignal: FALSE
[16:01:40.843] - force: TRUE
[16:01:40.843] - relayed: [n=2] TRUE, TRUE
[16:01:40.844] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:40.844] - relayed: [n=2] TRUE, TRUE
[16:01:40.844] - queued futures: [n=2] TRUE, TRUE
[16:01:40.844] signalConditionsASAP(NULL, pos=0) ... done
[16:01:40.844] resolve() on list ... DONE
[16:01:40.844] result() for MulticoreFuture ...
[16:01:40.844] result() for MulticoreFuture ... done
[16:01:40.844] result() for MulticoreFuture ...
[16:01:40.844] result() for MulticoreFuture ... done
[16:01:40.845] result() for MulticoreFuture ...
[16:01:40.845] result() for MulticoreFuture ... done
[16:01:40.845] result() for MulticoreFuture ...
[16:01:40.845] result() for MulticoreFuture ... done
[16:01:40.845]  - Number of value chunks collected: 2
[16:01:40.845] Resolving 2 futures (chunks) ... DONE
[16:01:40.845] Reducing values from 2 chunks ...
[16:01:40.845]  - Number of values collected after concatenation: 2
[16:01:40.845]  - Number of values expected: 2
[16:01:40.846] Reducing values from 2 chunks ... DONE
[16:01:40.846] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[16:01:40.846] getGlobalsAndPackagesXApply() ...
[16:01:40.846]  - future.globals: TRUE
[16:01:40.846] getGlobalsAndPackages() ...
[16:01:40.847] Searching for globals...
[16:01:40.848] - globals found: [1] ‘FUN’
[16:01:40.848] Searching for globals ... DONE
[16:01:40.848] Resolving globals: FALSE
[16:01:40.848] The total size of the 1 globals is 848 bytes (848 bytes)
[16:01:40.849] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:01:40.849] - globals: [1] ‘FUN’
[16:01:40.849] 
[16:01:40.849] getGlobalsAndPackages() ... DONE
[16:01:40.849]  - globals found/used: [n=1] ‘FUN’
[16:01:40.849]  - needed namespaces: [n=0] 
[16:01:40.849] Finding globals ... DONE
[16:01:40.850]  - use_args: TRUE
[16:01:40.850]  - Getting '...' globals ...
[16:01:40.850] resolve() on list ...
[16:01:40.850]  recursive: 0
[16:01:40.850]  length: 1
[16:01:40.850]  elements: ‘...’
[16:01:40.850]  length: 0 (resolved future 1)
[16:01:40.851] resolve() on list ... DONE
[16:01:40.851]    - '...' content: [n=0] 
[16:01:40.851] List of 1
[16:01:40.851]  $ ...: list()
[16:01:40.851]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.851]  - attr(*, "where")=List of 1
[16:01:40.851]   ..$ ...:<environment: 0x55fb62f3d460> 
[16:01:40.851]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.851]  - attr(*, "resolved")= logi TRUE
[16:01:40.851]  - attr(*, "total_size")= num NA
[16:01:40.854]  - Getting '...' globals ... DONE
[16:01:40.854] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:40.854] List of 2
[16:01:40.854]  $ ...future.FUN:function (x)  
[16:01:40.854]  $ ...          : list()
[16:01:40.854]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.854]  - attr(*, "where")=List of 2
[16:01:40.854]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:40.854]   ..$ ...          :<environment: 0x55fb62f3d460> 
[16:01:40.854]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.854]  - attr(*, "resolved")= logi FALSE
[16:01:40.854]  - attr(*, "total_size")= num 848
[16:01:40.857] Packages to be attached in all futures: [n=0] 
[16:01:40.857] getGlobalsAndPackagesXApply() ... DONE
[16:01:40.861] future_lapply() ...
[16:01:40.866] Number of chunks: 2
[16:01:40.867] getGlobalsAndPackagesXApply() ...
[16:01:40.867]  - future.globals: <name-value list> with names ‘list()’
[16:01:40.867]  - use_args: TRUE
[16:01:40.867] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:01:40.867] List of 2
[16:01:40.867]  $ ...          : list()
[16:01:40.867]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.867]  $ ...future.FUN:function (x)  
[16:01:40.867]  - attr(*, "where")=List of 2
[16:01:40.867]   ..$ ...          :<environment: 0x55fb62f3d460> 
[16:01:40.867]   ..$ ...future.FUN:<environment: namespace:base> 
[16:01:40.867]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.867]  - attr(*, "resolved")= logi FALSE
[16:01:40.867]  - attr(*, "total_size")= num NA
[16:01:40.871] Packages to be attached in all futures: [n=0] 
[16:01:40.871] getGlobalsAndPackagesXApply() ... DONE
[16:01:40.871] Number of futures (= number of chunks): 2
[16:01:40.871] Launching 2 futures (chunks) ...
[16:01:40.871] Chunk #1 of 2 ...
[16:01:40.872]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:40.872]  - seeds: <none>
[16:01:40.872]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.872] getGlobalsAndPackages() ...
[16:01:40.872] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.872] Resolving globals: FALSE
[16:01:40.872] Tweak future expression to call with '...' arguments ...
[16:01:40.872] {
[16:01:40.872]     do.call(function(...) {
[16:01:40.872]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.872]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.872]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.872]             on.exit(options(oopts), add = TRUE)
[16:01:40.872]         }
[16:01:40.872]         {
[16:01:40.872]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.872]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.872]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.872]             })
[16:01:40.872]         }
[16:01:40.872]     }, args = future.call.arguments)
[16:01:40.872] }
[16:01:40.873] Tweak future expression to call with '...' arguments ... DONE
[16:01:40.873] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.873] 
[16:01:40.873] getGlobalsAndPackages() ... DONE
[16:01:40.874] run() for ‘Future’ ...
[16:01:40.874] - state: ‘created’
[16:01:40.874] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:40.878] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:40.878] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:40.878]   - Field: ‘label’
[16:01:40.878]   - Field: ‘local’
[16:01:40.878]   - Field: ‘owner’
[16:01:40.878]   - Field: ‘envir’
[16:01:40.878]   - Field: ‘workers’
[16:01:40.878]   - Field: ‘packages’
[16:01:40.878]   - Field: ‘gc’
[16:01:40.879]   - Field: ‘job’
[16:01:40.879]   - Field: ‘conditions’
[16:01:40.879]   - Field: ‘expr’
[16:01:40.879]   - Field: ‘uuid’
[16:01:40.879]   - Field: ‘seed’
[16:01:40.879]   - Field: ‘version’
[16:01:40.879]   - Field: ‘result’
[16:01:40.879]   - Field: ‘asynchronous’
[16:01:40.879]   - Field: ‘calls’
[16:01:40.880]   - Field: ‘globals’
[16:01:40.880]   - Field: ‘stdout’
[16:01:40.880]   - Field: ‘earlySignal’
[16:01:40.880]   - Field: ‘lazy’
[16:01:40.880]   - Field: ‘state’
[16:01:40.880] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:40.880] - Launch lazy future ...
[16:01:40.880] Packages needed by the future expression (n = 0): <none>
[16:01:40.881] Packages needed by future strategies (n = 0): <none>
[16:01:40.881] {
[16:01:40.881]     {
[16:01:40.881]         {
[16:01:40.881]             ...future.startTime <- base::Sys.time()
[16:01:40.881]             {
[16:01:40.881]                 {
[16:01:40.881]                   {
[16:01:40.881]                     {
[16:01:40.881]                       base::local({
[16:01:40.881]                         has_future <- base::requireNamespace("future", 
[16:01:40.881]                           quietly = TRUE)
[16:01:40.881]                         if (has_future) {
[16:01:40.881]                           ns <- base::getNamespace("future")
[16:01:40.881]                           version <- ns[[".package"]][["version"]]
[16:01:40.881]                           if (is.null(version)) 
[16:01:40.881]                             version <- utils::packageVersion("future")
[16:01:40.881]                         }
[16:01:40.881]                         else {
[16:01:40.881]                           version <- NULL
[16:01:40.881]                         }
[16:01:40.881]                         if (!has_future || version < "1.8.0") {
[16:01:40.881]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:40.881]                             "", base::R.version$version.string), 
[16:01:40.881]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:40.881]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:40.881]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:40.881]                               "release", "version")], collapse = " "), 
[16:01:40.881]                             hostname = base::Sys.info()[["nodename"]])
[16:01:40.881]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:40.881]                             info)
[16:01:40.881]                           info <- base::paste(info, collapse = "; ")
[16:01:40.881]                           if (!has_future) {
[16:01:40.881]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:40.881]                               info)
[16:01:40.881]                           }
[16:01:40.881]                           else {
[16:01:40.881]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:40.881]                               info, version)
[16:01:40.881]                           }
[16:01:40.881]                           base::stop(msg)
[16:01:40.881]                         }
[16:01:40.881]                       })
[16:01:40.881]                     }
[16:01:40.881]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:40.881]                     base::options(mc.cores = 1L)
[16:01:40.881]                   }
[16:01:40.881]                   options(future.plan = NULL)
[16:01:40.881]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:40.881]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:40.881]                 }
[16:01:40.881]                 ...future.workdir <- getwd()
[16:01:40.881]             }
[16:01:40.881]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:40.881]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:40.881]         }
[16:01:40.881]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:40.881]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:40.881]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:40.881]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:40.881]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:40.881]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:40.881]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:40.881]             base::names(...future.oldOptions))
[16:01:40.881]     }
[16:01:40.881]     if (FALSE) {
[16:01:40.881]     }
[16:01:40.881]     else {
[16:01:40.881]         if (TRUE) {
[16:01:40.881]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:40.881]                 open = "w")
[16:01:40.881]         }
[16:01:40.881]         else {
[16:01:40.881]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:40.881]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:40.881]         }
[16:01:40.881]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:40.881]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:40.881]             base::sink(type = "output", split = FALSE)
[16:01:40.881]             base::close(...future.stdout)
[16:01:40.881]         }, add = TRUE)
[16:01:40.881]     }
[16:01:40.881]     ...future.frame <- base::sys.nframe()
[16:01:40.881]     ...future.conditions <- base::list()
[16:01:40.881]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:40.881]     if (FALSE) {
[16:01:40.881]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:40.881]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:40.881]     }
[16:01:40.881]     ...future.result <- base::tryCatch({
[16:01:40.881]         base::withCallingHandlers({
[16:01:40.881]             ...future.value <- base::withVisible(base::local({
[16:01:40.881]                 withCallingHandlers({
[16:01:40.881]                   {
[16:01:40.881]                     do.call(function(...) {
[16:01:40.881]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.881]                       if (!identical(...future.globals.maxSize.org, 
[16:01:40.881]                         ...future.globals.maxSize)) {
[16:01:40.881]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.881]                         on.exit(options(oopts), add = TRUE)
[16:01:40.881]                       }
[16:01:40.881]                       {
[16:01:40.881]                         lapply(seq_along(...future.elements_ii), 
[16:01:40.881]                           FUN = function(jj) {
[16:01:40.881]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.881]                             ...future.FUN(...future.X_jj, ...)
[16:01:40.881]                           })
[16:01:40.881]                       }
[16:01:40.881]                     }, args = future.call.arguments)
[16:01:40.881]                   }
[16:01:40.881]                 }, immediateCondition = function(cond) {
[16:01:40.881]                   save_rds <- function (object, pathname, ...) 
[16:01:40.881]                   {
[16:01:40.881]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:40.881]                     if (file_test("-f", pathname_tmp)) {
[16:01:40.881]                       fi_tmp <- file.info(pathname_tmp)
[16:01:40.881]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:40.881]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:40.881]                         fi_tmp[["mtime"]])
[16:01:40.881]                     }
[16:01:40.881]                     tryCatch({
[16:01:40.881]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:40.881]                     }, error = function(ex) {
[16:01:40.881]                       msg <- conditionMessage(ex)
[16:01:40.881]                       fi_tmp <- file.info(pathname_tmp)
[16:01:40.881]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:40.881]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:40.881]                         fi_tmp[["mtime"]], msg)
[16:01:40.881]                       ex$message <- msg
[16:01:40.881]                       stop(ex)
[16:01:40.881]                     })
[16:01:40.881]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:40.881]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:40.881]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:40.881]                       fi_tmp <- file.info(pathname_tmp)
[16:01:40.881]                       fi <- file.info(pathname)
[16:01:40.881]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:40.881]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:40.881]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:40.881]                         fi[["size"]], fi[["mtime"]])
[16:01:40.881]                       stop(msg)
[16:01:40.881]                     }
[16:01:40.881]                     invisible(pathname)
[16:01:40.881]                   }
[16:01:40.881]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:40.881]                     rootPath = tempdir()) 
[16:01:40.881]                   {
[16:01:40.881]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:40.881]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:40.881]                       tmpdir = path, fileext = ".rds")
[16:01:40.881]                     save_rds(obj, file)
[16:01:40.881]                   }
[16:01:40.881]                   saveImmediateCondition(cond, path = "/tmp/RtmplAoKyr/.future/immediateConditions")
[16:01:40.881]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.881]                   {
[16:01:40.881]                     inherits <- base::inherits
[16:01:40.881]                     invokeRestart <- base::invokeRestart
[16:01:40.881]                     is.null <- base::is.null
[16:01:40.881]                     muffled <- FALSE
[16:01:40.881]                     if (inherits(cond, "message")) {
[16:01:40.881]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:40.881]                       if (muffled) 
[16:01:40.881]                         invokeRestart("muffleMessage")
[16:01:40.881]                     }
[16:01:40.881]                     else if (inherits(cond, "warning")) {
[16:01:40.881]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:40.881]                       if (muffled) 
[16:01:40.881]                         invokeRestart("muffleWarning")
[16:01:40.881]                     }
[16:01:40.881]                     else if (inherits(cond, "condition")) {
[16:01:40.881]                       if (!is.null(pattern)) {
[16:01:40.881]                         computeRestarts <- base::computeRestarts
[16:01:40.881]                         grepl <- base::grepl
[16:01:40.881]                         restarts <- computeRestarts(cond)
[16:01:40.881]                         for (restart in restarts) {
[16:01:40.881]                           name <- restart$name
[16:01:40.881]                           if (is.null(name)) 
[16:01:40.881]                             next
[16:01:40.881]                           if (!grepl(pattern, name)) 
[16:01:40.881]                             next
[16:01:40.881]                           invokeRestart(restart)
[16:01:40.881]                           muffled <- TRUE
[16:01:40.881]                           break
[16:01:40.881]                         }
[16:01:40.881]                       }
[16:01:40.881]                     }
[16:01:40.881]                     invisible(muffled)
[16:01:40.881]                   }
[16:01:40.881]                   muffleCondition(cond)
[16:01:40.881]                 })
[16:01:40.881]             }))
[16:01:40.881]             future::FutureResult(value = ...future.value$value, 
[16:01:40.881]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:40.881]                   ...future.rng), globalenv = if (FALSE) 
[16:01:40.881]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:40.881]                     ...future.globalenv.names))
[16:01:40.881]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:40.881]         }, condition = base::local({
[16:01:40.881]             c <- base::c
[16:01:40.881]             inherits <- base::inherits
[16:01:40.881]             invokeRestart <- base::invokeRestart
[16:01:40.881]             length <- base::length
[16:01:40.881]             list <- base::list
[16:01:40.881]             seq.int <- base::seq.int
[16:01:40.881]             signalCondition <- base::signalCondition
[16:01:40.881]             sys.calls <- base::sys.calls
[16:01:40.881]             `[[` <- base::`[[`
[16:01:40.881]             `+` <- base::`+`
[16:01:40.881]             `<<-` <- base::`<<-`
[16:01:40.881]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:40.881]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:40.881]                   3L)]
[16:01:40.881]             }
[16:01:40.881]             function(cond) {
[16:01:40.881]                 is_error <- inherits(cond, "error")
[16:01:40.881]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:40.881]                   NULL)
[16:01:40.881]                 if (is_error) {
[16:01:40.881]                   sessionInformation <- function() {
[16:01:40.881]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:40.881]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:40.881]                       search = base::search(), system = base::Sys.info())
[16:01:40.881]                   }
[16:01:40.881]                   ...future.conditions[[length(...future.conditions) + 
[16:01:40.881]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:40.881]                     cond$call), session = sessionInformation(), 
[16:01:40.881]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:40.881]                   signalCondition(cond)
[16:01:40.881]                 }
[16:01:40.881]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:40.881]                 "immediateCondition"))) {
[16:01:40.881]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:40.881]                   ...future.conditions[[length(...future.conditions) + 
[16:01:40.881]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:40.881]                   if (TRUE && !signal) {
[16:01:40.881]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.881]                     {
[16:01:40.881]                       inherits <- base::inherits
[16:01:40.881]                       invokeRestart <- base::invokeRestart
[16:01:40.881]                       is.null <- base::is.null
[16:01:40.881]                       muffled <- FALSE
[16:01:40.881]                       if (inherits(cond, "message")) {
[16:01:40.881]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:40.881]                         if (muffled) 
[16:01:40.881]                           invokeRestart("muffleMessage")
[16:01:40.881]                       }
[16:01:40.881]                       else if (inherits(cond, "warning")) {
[16:01:40.881]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:40.881]                         if (muffled) 
[16:01:40.881]                           invokeRestart("muffleWarning")
[16:01:40.881]                       }
[16:01:40.881]                       else if (inherits(cond, "condition")) {
[16:01:40.881]                         if (!is.null(pattern)) {
[16:01:40.881]                           computeRestarts <- base::computeRestarts
[16:01:40.881]                           grepl <- base::grepl
[16:01:40.881]                           restarts <- computeRestarts(cond)
[16:01:40.881]                           for (restart in restarts) {
[16:01:40.881]                             name <- restart$name
[16:01:40.881]                             if (is.null(name)) 
[16:01:40.881]                               next
[16:01:40.881]                             if (!grepl(pattern, name)) 
[16:01:40.881]                               next
[16:01:40.881]                             invokeRestart(restart)
[16:01:40.881]                             muffled <- TRUE
[16:01:40.881]                             break
[16:01:40.881]                           }
[16:01:40.881]                         }
[16:01:40.881]                       }
[16:01:40.881]                       invisible(muffled)
[16:01:40.881]                     }
[16:01:40.881]                     muffleCondition(cond, pattern = "^muffle")
[16:01:40.881]                   }
[16:01:40.881]                 }
[16:01:40.881]                 else {
[16:01:40.881]                   if (TRUE) {
[16:01:40.881]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.881]                     {
[16:01:40.881]                       inherits <- base::inherits
[16:01:40.881]                       invokeRestart <- base::invokeRestart
[16:01:40.881]                       is.null <- base::is.null
[16:01:40.881]                       muffled <- FALSE
[16:01:40.881]                       if (inherits(cond, "message")) {
[16:01:40.881]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:40.881]                         if (muffled) 
[16:01:40.881]                           invokeRestart("muffleMessage")
[16:01:40.881]                       }
[16:01:40.881]                       else if (inherits(cond, "warning")) {
[16:01:40.881]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:40.881]                         if (muffled) 
[16:01:40.881]                           invokeRestart("muffleWarning")
[16:01:40.881]                       }
[16:01:40.881]                       else if (inherits(cond, "condition")) {
[16:01:40.881]                         if (!is.null(pattern)) {
[16:01:40.881]                           computeRestarts <- base::computeRestarts
[16:01:40.881]                           grepl <- base::grepl
[16:01:40.881]                           restarts <- computeRestarts(cond)
[16:01:40.881]                           for (restart in restarts) {
[16:01:40.881]                             name <- restart$name
[16:01:40.881]                             if (is.null(name)) 
[16:01:40.881]                               next
[16:01:40.881]                             if (!grepl(pattern, name)) 
[16:01:40.881]                               next
[16:01:40.881]                             invokeRestart(restart)
[16:01:40.881]                             muffled <- TRUE
[16:01:40.881]                             break
[16:01:40.881]                           }
[16:01:40.881]                         }
[16:01:40.881]                       }
[16:01:40.881]                       invisible(muffled)
[16:01:40.881]                     }
[16:01:40.881]                     muffleCondition(cond, pattern = "^muffle")
[16:01:40.881]                   }
[16:01:40.881]                 }
[16:01:40.881]             }
[16:01:40.881]         }))
[16:01:40.881]     }, error = function(ex) {
[16:01:40.881]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:40.881]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:40.881]                 ...future.rng), started = ...future.startTime, 
[16:01:40.881]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:40.881]             version = "1.8"), class = "FutureResult")
[16:01:40.881]     }, finally = {
[16:01:40.881]         if (!identical(...future.workdir, getwd())) 
[16:01:40.881]             setwd(...future.workdir)
[16:01:40.881]         {
[16:01:40.881]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:40.881]                 ...future.oldOptions$nwarnings <- NULL
[16:01:40.881]             }
[16:01:40.881]             base::options(...future.oldOptions)
[16:01:40.881]             if (.Platform$OS.type == "windows") {
[16:01:40.881]                 old_names <- names(...future.oldEnvVars)
[16:01:40.881]                 envs <- base::Sys.getenv()
[16:01:40.881]                 names <- names(envs)
[16:01:40.881]                 common <- intersect(names, old_names)
[16:01:40.881]                 added <- setdiff(names, old_names)
[16:01:40.881]                 removed <- setdiff(old_names, names)
[16:01:40.881]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:40.881]                   envs[common]]
[16:01:40.881]                 NAMES <- toupper(changed)
[16:01:40.881]                 args <- list()
[16:01:40.881]                 for (kk in seq_along(NAMES)) {
[16:01:40.881]                   name <- changed[[kk]]
[16:01:40.881]                   NAME <- NAMES[[kk]]
[16:01:40.881]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.881]                     next
[16:01:40.881]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:40.881]                 }
[16:01:40.881]                 NAMES <- toupper(added)
[16:01:40.881]                 for (kk in seq_along(NAMES)) {
[16:01:40.881]                   name <- added[[kk]]
[16:01:40.881]                   NAME <- NAMES[[kk]]
[16:01:40.881]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.881]                     next
[16:01:40.881]                   args[[name]] <- ""
[16:01:40.881]                 }
[16:01:40.881]                 NAMES <- toupper(removed)
[16:01:40.881]                 for (kk in seq_along(NAMES)) {
[16:01:40.881]                   name <- removed[[kk]]
[16:01:40.881]                   NAME <- NAMES[[kk]]
[16:01:40.881]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.881]                     next
[16:01:40.881]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:40.881]                 }
[16:01:40.881]                 if (length(args) > 0) 
[16:01:40.881]                   base::do.call(base::Sys.setenv, args = args)
[16:01:40.881]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:40.881]             }
[16:01:40.881]             else {
[16:01:40.881]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:40.881]             }
[16:01:40.881]             {
[16:01:40.881]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:40.881]                   0L) {
[16:01:40.881]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:40.881]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:40.881]                   base::options(opts)
[16:01:40.881]                 }
[16:01:40.881]                 {
[16:01:40.881]                   {
[16:01:40.881]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:40.881]                     NULL
[16:01:40.881]                   }
[16:01:40.881]                   options(future.plan = NULL)
[16:01:40.881]                   if (is.na(NA_character_)) 
[16:01:40.881]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:40.881]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:40.881]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:40.881]                     envir = parent.frame()) 
[16:01:40.881]                   {
[16:01:40.881]                     default_workers <- missing(workers)
[16:01:40.881]                     if (is.function(workers)) 
[16:01:40.881]                       workers <- workers()
[16:01:40.881]                     workers <- structure(as.integer(workers), 
[16:01:40.881]                       class = class(workers))
[16:01:40.881]                     stop_if_not(is.finite(workers), workers >= 
[16:01:40.881]                       1L)
[16:01:40.881]                     if ((workers == 1L && !inherits(workers, 
[16:01:40.881]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:40.881]                       if (default_workers) 
[16:01:40.881]                         supportsMulticore(warn = TRUE)
[16:01:40.881]                       return(sequential(..., envir = envir))
[16:01:40.881]                     }
[16:01:40.881]                     oopts <- options(mc.cores = workers)
[16:01:40.881]                     on.exit(options(oopts))
[16:01:40.881]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:40.881]                       envir = envir)
[16:01:40.881]                     if (!future$lazy) 
[16:01:40.881]                       future <- run(future)
[16:01:40.881]                     invisible(future)
[16:01:40.881]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:40.881]                 }
[16:01:40.881]             }
[16:01:40.881]         }
[16:01:40.881]     })
[16:01:40.881]     if (TRUE) {
[16:01:40.881]         base::sink(type = "output", split = FALSE)
[16:01:40.881]         if (TRUE) {
[16:01:40.881]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:40.881]         }
[16:01:40.881]         else {
[16:01:40.881]             ...future.result["stdout"] <- base::list(NULL)
[16:01:40.881]         }
[16:01:40.881]         base::close(...future.stdout)
[16:01:40.881]         ...future.stdout <- NULL
[16:01:40.881]     }
[16:01:40.881]     ...future.result$conditions <- ...future.conditions
[16:01:40.881]     ...future.result$finished <- base::Sys.time()
[16:01:40.881]     ...future.result
[16:01:40.881] }
[16:01:40.883] assign_globals() ...
[16:01:40.884] List of 5
[16:01:40.884]  $ future.call.arguments    : list()
[16:01:40.884]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.884]  $ ...future.FUN            :function (x)  
[16:01:40.884]  $ ...future.elements_ii    :List of 1
[16:01:40.884]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[16:01:40.884]  $ ...future.seeds_ii       : NULL
[16:01:40.884]  $ ...future.globals.maxSize: num Inf
[16:01:40.884]  - attr(*, "resolved")= logi FALSE
[16:01:40.884]  - attr(*, "total_size")= num NA
[16:01:40.884]  - attr(*, "where")=List of 5
[16:01:40.884]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:40.884]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:40.884]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:40.884]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:40.884]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:40.884]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.884]  - attr(*, "already-done")= logi TRUE
[16:01:40.888] - copied ‘future.call.arguments’ to environment
[16:01:40.888] - copied ‘...future.FUN’ to environment
[16:01:40.889] - copied ‘...future.elements_ii’ to environment
[16:01:40.889] - copied ‘...future.seeds_ii’ to environment
[16:01:40.889] - copied ‘...future.globals.maxSize’ to environment
[16:01:40.889] assign_globals() ... done
[16:01:40.889] requestCore(): workers = 2
[16:01:40.891] MulticoreFuture started
[16:01:40.892] - Launch lazy future ... done
[16:01:40.892] run() for ‘MulticoreFuture’ ... done
[16:01:40.892] Created future:
[16:01:40.892] plan(): Setting new future strategy stack:
[16:01:40.893] List of future strategies:
[16:01:40.893] 1. sequential:
[16:01:40.893]    - args: function (..., envir = parent.frame())
[16:01:40.893]    - tweaked: FALSE
[16:01:40.893]    - call: NULL
[16:01:40.893] plan(): nbrOfWorkers() = 1
[16:01:40.895] plan(): Setting new future strategy stack:
[16:01:40.896] List of future strategies:
[16:01:40.896] 1. multicore:
[16:01:40.896]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:40.896]    - tweaked: FALSE
[16:01:40.896]    - call: plan(strategy)
[16:01:40.892] MulticoreFuture:
[16:01:40.892] Label: ‘future_apply-1’
[16:01:40.892] Expression:
[16:01:40.892] {
[16:01:40.892]     do.call(function(...) {
[16:01:40.892]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.892]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.892]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.892]             on.exit(options(oopts), add = TRUE)
[16:01:40.892]         }
[16:01:40.892]         {
[16:01:40.892]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.892]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.892]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.892]             })
[16:01:40.892]         }
[16:01:40.892]     }, args = future.call.arguments)
[16:01:40.892] }
[16:01:40.892] Lazy evaluation: FALSE
[16:01:40.892] Asynchronous evaluation: TRUE
[16:01:40.892] Local evaluation: TRUE
[16:01:40.892] Environment: R_GlobalEnv
[16:01:40.892] Capture standard output: TRUE
[16:01:40.892] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:40.892] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:40.892] Packages: <none>
[16:01:40.892] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:40.892] Resolved: FALSE
[16:01:40.892] Value: <not collected>
[16:01:40.892] Conditions captured: <none>
[16:01:40.892] Early signaling: FALSE
[16:01:40.892] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:40.892] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:40.905] Chunk #1 of 2 ... DONE
[16:01:40.905] Chunk #2 of 2 ...
[16:01:40.906]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:40.906]  - seeds: <none>
[16:01:40.907] plan(): nbrOfWorkers() = 2
[16:01:40.908]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.909] getGlobalsAndPackages() ...
[16:01:40.909] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.909] Resolving globals: FALSE
[16:01:40.909] Tweak future expression to call with '...' arguments ...
[16:01:40.910] {
[16:01:40.910]     do.call(function(...) {
[16:01:40.910]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.910]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.910]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.910]             on.exit(options(oopts), add = TRUE)
[16:01:40.910]         }
[16:01:40.910]         {
[16:01:40.910]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.910]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.910]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.910]             })
[16:01:40.910]         }
[16:01:40.910]     }, args = future.call.arguments)
[16:01:40.910] }
[16:01:40.910] Tweak future expression to call with '...' arguments ... DONE
[16:01:40.911] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.912] 
[16:01:40.912] getGlobalsAndPackages() ... DONE
[16:01:40.913] run() for ‘Future’ ...
[16:01:40.913] - state: ‘created’
[16:01:40.913] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:40.919] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:40.920] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:40.920]   - Field: ‘label’
[16:01:40.920]   - Field: ‘local’
[16:01:40.920]   - Field: ‘owner’
[16:01:40.920]   - Field: ‘envir’
[16:01:40.920]   - Field: ‘workers’
[16:01:40.921]   - Field: ‘packages’
[16:01:40.921]   - Field: ‘gc’
[16:01:40.921]   - Field: ‘job’
[16:01:40.921]   - Field: ‘conditions’
[16:01:40.921]   - Field: ‘expr’
[16:01:40.921]   - Field: ‘uuid’
[16:01:40.921]   - Field: ‘seed’
[16:01:40.922]   - Field: ‘version’
[16:01:40.922]   - Field: ‘result’
[16:01:40.922]   - Field: ‘asynchronous’
[16:01:40.922]   - Field: ‘calls’
[16:01:40.923]   - Field: ‘globals’
[16:01:40.923]   - Field: ‘stdout’
[16:01:40.923]   - Field: ‘earlySignal’
[16:01:40.923]   - Field: ‘lazy’
[16:01:40.923]   - Field: ‘state’
[16:01:40.923] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:40.923] - Launch lazy future ...
[16:01:40.924] Packages needed by the future expression (n = 0): <none>
[16:01:40.924] Packages needed by future strategies (n = 0): <none>
[16:01:40.925] {
[16:01:40.925]     {
[16:01:40.925]         {
[16:01:40.925]             ...future.startTime <- base::Sys.time()
[16:01:40.925]             {
[16:01:40.925]                 {
[16:01:40.925]                   {
[16:01:40.925]                     {
[16:01:40.925]                       base::local({
[16:01:40.925]                         has_future <- base::requireNamespace("future", 
[16:01:40.925]                           quietly = TRUE)
[16:01:40.925]                         if (has_future) {
[16:01:40.925]                           ns <- base::getNamespace("future")
[16:01:40.925]                           version <- ns[[".package"]][["version"]]
[16:01:40.925]                           if (is.null(version)) 
[16:01:40.925]                             version <- utils::packageVersion("future")
[16:01:40.925]                         }
[16:01:40.925]                         else {
[16:01:40.925]                           version <- NULL
[16:01:40.925]                         }
[16:01:40.925]                         if (!has_future || version < "1.8.0") {
[16:01:40.925]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:40.925]                             "", base::R.version$version.string), 
[16:01:40.925]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:40.925]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:40.925]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:40.925]                               "release", "version")], collapse = " "), 
[16:01:40.925]                             hostname = base::Sys.info()[["nodename"]])
[16:01:40.925]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:40.925]                             info)
[16:01:40.925]                           info <- base::paste(info, collapse = "; ")
[16:01:40.925]                           if (!has_future) {
[16:01:40.925]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:40.925]                               info)
[16:01:40.925]                           }
[16:01:40.925]                           else {
[16:01:40.925]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:40.925]                               info, version)
[16:01:40.925]                           }
[16:01:40.925]                           base::stop(msg)
[16:01:40.925]                         }
[16:01:40.925]                       })
[16:01:40.925]                     }
[16:01:40.925]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:40.925]                     base::options(mc.cores = 1L)
[16:01:40.925]                   }
[16:01:40.925]                   options(future.plan = NULL)
[16:01:40.925]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:40.925]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:40.925]                 }
[16:01:40.925]                 ...future.workdir <- getwd()
[16:01:40.925]             }
[16:01:40.925]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:40.925]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:40.925]         }
[16:01:40.925]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:40.925]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:40.925]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:40.925]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:40.925]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:40.925]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:40.925]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:40.925]             base::names(...future.oldOptions))
[16:01:40.925]     }
[16:01:40.925]     if (FALSE) {
[16:01:40.925]     }
[16:01:40.925]     else {
[16:01:40.925]         if (TRUE) {
[16:01:40.925]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:40.925]                 open = "w")
[16:01:40.925]         }
[16:01:40.925]         else {
[16:01:40.925]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:40.925]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:40.925]         }
[16:01:40.925]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:40.925]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:40.925]             base::sink(type = "output", split = FALSE)
[16:01:40.925]             base::close(...future.stdout)
[16:01:40.925]         }, add = TRUE)
[16:01:40.925]     }
[16:01:40.925]     ...future.frame <- base::sys.nframe()
[16:01:40.925]     ...future.conditions <- base::list()
[16:01:40.925]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:40.925]     if (FALSE) {
[16:01:40.925]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:40.925]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:40.925]     }
[16:01:40.925]     ...future.result <- base::tryCatch({
[16:01:40.925]         base::withCallingHandlers({
[16:01:40.925]             ...future.value <- base::withVisible(base::local({
[16:01:40.925]                 withCallingHandlers({
[16:01:40.925]                   {
[16:01:40.925]                     do.call(function(...) {
[16:01:40.925]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.925]                       if (!identical(...future.globals.maxSize.org, 
[16:01:40.925]                         ...future.globals.maxSize)) {
[16:01:40.925]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.925]                         on.exit(options(oopts), add = TRUE)
[16:01:40.925]                       }
[16:01:40.925]                       {
[16:01:40.925]                         lapply(seq_along(...future.elements_ii), 
[16:01:40.925]                           FUN = function(jj) {
[16:01:40.925]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.925]                             ...future.FUN(...future.X_jj, ...)
[16:01:40.925]                           })
[16:01:40.925]                       }
[16:01:40.925]                     }, args = future.call.arguments)
[16:01:40.925]                   }
[16:01:40.925]                 }, immediateCondition = function(cond) {
[16:01:40.925]                   save_rds <- function (object, pathname, ...) 
[16:01:40.925]                   {
[16:01:40.925]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:40.925]                     if (file_test("-f", pathname_tmp)) {
[16:01:40.925]                       fi_tmp <- file.info(pathname_tmp)
[16:01:40.925]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:40.925]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:40.925]                         fi_tmp[["mtime"]])
[16:01:40.925]                     }
[16:01:40.925]                     tryCatch({
[16:01:40.925]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:40.925]                     }, error = function(ex) {
[16:01:40.925]                       msg <- conditionMessage(ex)
[16:01:40.925]                       fi_tmp <- file.info(pathname_tmp)
[16:01:40.925]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:40.925]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:40.925]                         fi_tmp[["mtime"]], msg)
[16:01:40.925]                       ex$message <- msg
[16:01:40.925]                       stop(ex)
[16:01:40.925]                     })
[16:01:40.925]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:40.925]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:40.925]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:40.925]                       fi_tmp <- file.info(pathname_tmp)
[16:01:40.925]                       fi <- file.info(pathname)
[16:01:40.925]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:40.925]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:40.925]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:40.925]                         fi[["size"]], fi[["mtime"]])
[16:01:40.925]                       stop(msg)
[16:01:40.925]                     }
[16:01:40.925]                     invisible(pathname)
[16:01:40.925]                   }
[16:01:40.925]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:40.925]                     rootPath = tempdir()) 
[16:01:40.925]                   {
[16:01:40.925]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:40.925]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:40.925]                       tmpdir = path, fileext = ".rds")
[16:01:40.925]                     save_rds(obj, file)
[16:01:40.925]                   }
[16:01:40.925]                   saveImmediateCondition(cond, path = "/tmp/RtmplAoKyr/.future/immediateConditions")
[16:01:40.925]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.925]                   {
[16:01:40.925]                     inherits <- base::inherits
[16:01:40.925]                     invokeRestart <- base::invokeRestart
[16:01:40.925]                     is.null <- base::is.null
[16:01:40.925]                     muffled <- FALSE
[16:01:40.925]                     if (inherits(cond, "message")) {
[16:01:40.925]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:40.925]                       if (muffled) 
[16:01:40.925]                         invokeRestart("muffleMessage")
[16:01:40.925]                     }
[16:01:40.925]                     else if (inherits(cond, "warning")) {
[16:01:40.925]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:40.925]                       if (muffled) 
[16:01:40.925]                         invokeRestart("muffleWarning")
[16:01:40.925]                     }
[16:01:40.925]                     else if (inherits(cond, "condition")) {
[16:01:40.925]                       if (!is.null(pattern)) {
[16:01:40.925]                         computeRestarts <- base::computeRestarts
[16:01:40.925]                         grepl <- base::grepl
[16:01:40.925]                         restarts <- computeRestarts(cond)
[16:01:40.925]                         for (restart in restarts) {
[16:01:40.925]                           name <- restart$name
[16:01:40.925]                           if (is.null(name)) 
[16:01:40.925]                             next
[16:01:40.925]                           if (!grepl(pattern, name)) 
[16:01:40.925]                             next
[16:01:40.925]                           invokeRestart(restart)
[16:01:40.925]                           muffled <- TRUE
[16:01:40.925]                           break
[16:01:40.925]                         }
[16:01:40.925]                       }
[16:01:40.925]                     }
[16:01:40.925]                     invisible(muffled)
[16:01:40.925]                   }
[16:01:40.925]                   muffleCondition(cond)
[16:01:40.925]                 })
[16:01:40.925]             }))
[16:01:40.925]             future::FutureResult(value = ...future.value$value, 
[16:01:40.925]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:40.925]                   ...future.rng), globalenv = if (FALSE) 
[16:01:40.925]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:40.925]                     ...future.globalenv.names))
[16:01:40.925]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:40.925]         }, condition = base::local({
[16:01:40.925]             c <- base::c
[16:01:40.925]             inherits <- base::inherits
[16:01:40.925]             invokeRestart <- base::invokeRestart
[16:01:40.925]             length <- base::length
[16:01:40.925]             list <- base::list
[16:01:40.925]             seq.int <- base::seq.int
[16:01:40.925]             signalCondition <- base::signalCondition
[16:01:40.925]             sys.calls <- base::sys.calls
[16:01:40.925]             `[[` <- base::`[[`
[16:01:40.925]             `+` <- base::`+`
[16:01:40.925]             `<<-` <- base::`<<-`
[16:01:40.925]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:40.925]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:40.925]                   3L)]
[16:01:40.925]             }
[16:01:40.925]             function(cond) {
[16:01:40.925]                 is_error <- inherits(cond, "error")
[16:01:40.925]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:40.925]                   NULL)
[16:01:40.925]                 if (is_error) {
[16:01:40.925]                   sessionInformation <- function() {
[16:01:40.925]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:40.925]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:40.925]                       search = base::search(), system = base::Sys.info())
[16:01:40.925]                   }
[16:01:40.925]                   ...future.conditions[[length(...future.conditions) + 
[16:01:40.925]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:40.925]                     cond$call), session = sessionInformation(), 
[16:01:40.925]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:40.925]                   signalCondition(cond)
[16:01:40.925]                 }
[16:01:40.925]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:40.925]                 "immediateCondition"))) {
[16:01:40.925]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:40.925]                   ...future.conditions[[length(...future.conditions) + 
[16:01:40.925]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:40.925]                   if (TRUE && !signal) {
[16:01:40.925]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.925]                     {
[16:01:40.925]                       inherits <- base::inherits
[16:01:40.925]                       invokeRestart <- base::invokeRestart
[16:01:40.925]                       is.null <- base::is.null
[16:01:40.925]                       muffled <- FALSE
[16:01:40.925]                       if (inherits(cond, "message")) {
[16:01:40.925]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:40.925]                         if (muffled) 
[16:01:40.925]                           invokeRestart("muffleMessage")
[16:01:40.925]                       }
[16:01:40.925]                       else if (inherits(cond, "warning")) {
[16:01:40.925]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:40.925]                         if (muffled) 
[16:01:40.925]                           invokeRestart("muffleWarning")
[16:01:40.925]                       }
[16:01:40.925]                       else if (inherits(cond, "condition")) {
[16:01:40.925]                         if (!is.null(pattern)) {
[16:01:40.925]                           computeRestarts <- base::computeRestarts
[16:01:40.925]                           grepl <- base::grepl
[16:01:40.925]                           restarts <- computeRestarts(cond)
[16:01:40.925]                           for (restart in restarts) {
[16:01:40.925]                             name <- restart$name
[16:01:40.925]                             if (is.null(name)) 
[16:01:40.925]                               next
[16:01:40.925]                             if (!grepl(pattern, name)) 
[16:01:40.925]                               next
[16:01:40.925]                             invokeRestart(restart)
[16:01:40.925]                             muffled <- TRUE
[16:01:40.925]                             break
[16:01:40.925]                           }
[16:01:40.925]                         }
[16:01:40.925]                       }
[16:01:40.925]                       invisible(muffled)
[16:01:40.925]                     }
[16:01:40.925]                     muffleCondition(cond, pattern = "^muffle")
[16:01:40.925]                   }
[16:01:40.925]                 }
[16:01:40.925]                 else {
[16:01:40.925]                   if (TRUE) {
[16:01:40.925]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:40.925]                     {
[16:01:40.925]                       inherits <- base::inherits
[16:01:40.925]                       invokeRestart <- base::invokeRestart
[16:01:40.925]                       is.null <- base::is.null
[16:01:40.925]                       muffled <- FALSE
[16:01:40.925]                       if (inherits(cond, "message")) {
[16:01:40.925]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:40.925]                         if (muffled) 
[16:01:40.925]                           invokeRestart("muffleMessage")
[16:01:40.925]                       }
[16:01:40.925]                       else if (inherits(cond, "warning")) {
[16:01:40.925]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:40.925]                         if (muffled) 
[16:01:40.925]                           invokeRestart("muffleWarning")
[16:01:40.925]                       }
[16:01:40.925]                       else if (inherits(cond, "condition")) {
[16:01:40.925]                         if (!is.null(pattern)) {
[16:01:40.925]                           computeRestarts <- base::computeRestarts
[16:01:40.925]                           grepl <- base::grepl
[16:01:40.925]                           restarts <- computeRestarts(cond)
[16:01:40.925]                           for (restart in restarts) {
[16:01:40.925]                             name <- restart$name
[16:01:40.925]                             if (is.null(name)) 
[16:01:40.925]                               next
[16:01:40.925]                             if (!grepl(pattern, name)) 
[16:01:40.925]                               next
[16:01:40.925]                             invokeRestart(restart)
[16:01:40.925]                             muffled <- TRUE
[16:01:40.925]                             break
[16:01:40.925]                           }
[16:01:40.925]                         }
[16:01:40.925]                       }
[16:01:40.925]                       invisible(muffled)
[16:01:40.925]                     }
[16:01:40.925]                     muffleCondition(cond, pattern = "^muffle")
[16:01:40.925]                   }
[16:01:40.925]                 }
[16:01:40.925]             }
[16:01:40.925]         }))
[16:01:40.925]     }, error = function(ex) {
[16:01:40.925]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:40.925]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:40.925]                 ...future.rng), started = ...future.startTime, 
[16:01:40.925]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:40.925]             version = "1.8"), class = "FutureResult")
[16:01:40.925]     }, finally = {
[16:01:40.925]         if (!identical(...future.workdir, getwd())) 
[16:01:40.925]             setwd(...future.workdir)
[16:01:40.925]         {
[16:01:40.925]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:40.925]                 ...future.oldOptions$nwarnings <- NULL
[16:01:40.925]             }
[16:01:40.925]             base::options(...future.oldOptions)
[16:01:40.925]             if (.Platform$OS.type == "windows") {
[16:01:40.925]                 old_names <- names(...future.oldEnvVars)
[16:01:40.925]                 envs <- base::Sys.getenv()
[16:01:40.925]                 names <- names(envs)
[16:01:40.925]                 common <- intersect(names, old_names)
[16:01:40.925]                 added <- setdiff(names, old_names)
[16:01:40.925]                 removed <- setdiff(old_names, names)
[16:01:40.925]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:40.925]                   envs[common]]
[16:01:40.925]                 NAMES <- toupper(changed)
[16:01:40.925]                 args <- list()
[16:01:40.925]                 for (kk in seq_along(NAMES)) {
[16:01:40.925]                   name <- changed[[kk]]
[16:01:40.925]                   NAME <- NAMES[[kk]]
[16:01:40.925]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.925]                     next
[16:01:40.925]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:40.925]                 }
[16:01:40.925]                 NAMES <- toupper(added)
[16:01:40.925]                 for (kk in seq_along(NAMES)) {
[16:01:40.925]                   name <- added[[kk]]
[16:01:40.925]                   NAME <- NAMES[[kk]]
[16:01:40.925]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.925]                     next
[16:01:40.925]                   args[[name]] <- ""
[16:01:40.925]                 }
[16:01:40.925]                 NAMES <- toupper(removed)
[16:01:40.925]                 for (kk in seq_along(NAMES)) {
[16:01:40.925]                   name <- removed[[kk]]
[16:01:40.925]                   NAME <- NAMES[[kk]]
[16:01:40.925]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:40.925]                     next
[16:01:40.925]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:40.925]                 }
[16:01:40.925]                 if (length(args) > 0) 
[16:01:40.925]                   base::do.call(base::Sys.setenv, args = args)
[16:01:40.925]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:40.925]             }
[16:01:40.925]             else {
[16:01:40.925]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:40.925]             }
[16:01:40.925]             {
[16:01:40.925]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:40.925]                   0L) {
[16:01:40.925]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:40.925]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:40.925]                   base::options(opts)
[16:01:40.925]                 }
[16:01:40.925]                 {
[16:01:40.925]                   {
[16:01:40.925]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:40.925]                     NULL
[16:01:40.925]                   }
[16:01:40.925]                   options(future.plan = NULL)
[16:01:40.925]                   if (is.na(NA_character_)) 
[16:01:40.925]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:40.925]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:40.925]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:40.925]                     envir = parent.frame()) 
[16:01:40.925]                   {
[16:01:40.925]                     default_workers <- missing(workers)
[16:01:40.925]                     if (is.function(workers)) 
[16:01:40.925]                       workers <- workers()
[16:01:40.925]                     workers <- structure(as.integer(workers), 
[16:01:40.925]                       class = class(workers))
[16:01:40.925]                     stop_if_not(is.finite(workers), workers >= 
[16:01:40.925]                       1L)
[16:01:40.925]                     if ((workers == 1L && !inherits(workers, 
[16:01:40.925]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:40.925]                       if (default_workers) 
[16:01:40.925]                         supportsMulticore(warn = TRUE)
[16:01:40.925]                       return(sequential(..., envir = envir))
[16:01:40.925]                     }
[16:01:40.925]                     oopts <- options(mc.cores = workers)
[16:01:40.925]                     on.exit(options(oopts))
[16:01:40.925]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:40.925]                       envir = envir)
[16:01:40.925]                     if (!future$lazy) 
[16:01:40.925]                       future <- run(future)
[16:01:40.925]                     invisible(future)
[16:01:40.925]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:40.925]                 }
[16:01:40.925]             }
[16:01:40.925]         }
[16:01:40.925]     })
[16:01:40.925]     if (TRUE) {
[16:01:40.925]         base::sink(type = "output", split = FALSE)
[16:01:40.925]         if (TRUE) {
[16:01:40.925]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:40.925]         }
[16:01:40.925]         else {
[16:01:40.925]             ...future.result["stdout"] <- base::list(NULL)
[16:01:40.925]         }
[16:01:40.925]         base::close(...future.stdout)
[16:01:40.925]         ...future.stdout <- NULL
[16:01:40.925]     }
[16:01:40.925]     ...future.result$conditions <- ...future.conditions
[16:01:40.925]     ...future.result$finished <- base::Sys.time()
[16:01:40.925]     ...future.result
[16:01:40.925] }
[16:01:40.928] assign_globals() ...
[16:01:40.928] List of 5
[16:01:40.928]  $ future.call.arguments    : list()
[16:01:40.928]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.928]  $ ...future.FUN            :function (x)  
[16:01:40.928]  $ ...future.elements_ii    :List of 1
[16:01:40.928]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[16:01:40.928]  $ ...future.seeds_ii       : NULL
[16:01:40.928]  $ ...future.globals.maxSize: num Inf
[16:01:40.928]  - attr(*, "resolved")= logi FALSE
[16:01:40.928]  - attr(*, "total_size")= num NA
[16:01:40.928]  - attr(*, "where")=List of 5
[16:01:40.928]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:40.928]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:40.928]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:40.928]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:40.928]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:40.928]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.928]  - attr(*, "already-done")= logi TRUE
[16:01:40.934] - copied ‘future.call.arguments’ to environment
[16:01:40.934] - copied ‘...future.FUN’ to environment
[16:01:40.934] - copied ‘...future.elements_ii’ to environment
[16:01:40.935] - copied ‘...future.seeds_ii’ to environment
[16:01:40.935] - copied ‘...future.globals.maxSize’ to environment
[16:01:40.935] assign_globals() ... done
[16:01:40.935] requestCore(): workers = 2
[16:01:40.937] MulticoreFuture started
[16:01:40.938] - Launch lazy future ... done
[16:01:40.938] run() for ‘MulticoreFuture’ ... done
[16:01:40.938] Created future:
[16:01:40.938] plan(): Setting new future strategy stack:
[16:01:40.939] List of future strategies:
[16:01:40.939] 1. sequential:
[16:01:40.939]    - args: function (..., envir = parent.frame())
[16:01:40.939]    - tweaked: FALSE
[16:01:40.939]    - call: NULL
[16:01:40.939] plan(): nbrOfWorkers() = 1
[16:01:40.942] plan(): Setting new future strategy stack:
[16:01:40.942] List of future strategies:
[16:01:40.942] 1. multicore:
[16:01:40.942]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:40.942]    - tweaked: FALSE
[16:01:40.942]    - call: plan(strategy)
[16:01:40.947] plan(): nbrOfWorkers() = 2
[16:01:40.938] MulticoreFuture:
[16:01:40.938] Label: ‘future_apply-2’
[16:01:40.938] Expression:
[16:01:40.938] {
[16:01:40.938]     do.call(function(...) {
[16:01:40.938]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.938]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.938]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.938]             on.exit(options(oopts), add = TRUE)
[16:01:40.938]         }
[16:01:40.938]         {
[16:01:40.938]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.938]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.938]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.938]             })
[16:01:40.938]         }
[16:01:40.938]     }, args = future.call.arguments)
[16:01:40.938] }
[16:01:40.938] Lazy evaluation: FALSE
[16:01:40.938] Asynchronous evaluation: TRUE
[16:01:40.938] Local evaluation: TRUE
[16:01:40.938] Environment: R_GlobalEnv
[16:01:40.938] Capture standard output: TRUE
[16:01:40.938] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:40.938] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:40.938] Packages: <none>
[16:01:40.938] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:40.938] Resolved: TRUE
[16:01:40.938] Value: <not collected>
[16:01:40.938] Conditions captured: <none>
[16:01:40.938] Early signaling: FALSE
[16:01:40.938] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:40.938] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:40.948] Chunk #2 of 2 ... DONE
[16:01:40.948] Launching 2 futures (chunks) ... DONE
[16:01:40.948] Resolving 2 futures (chunks) ...
[16:01:40.949] resolve() on list ...
[16:01:40.949]  recursive: 0
[16:01:40.949]  length: 2
[16:01:40.949] 
[16:01:40.949] Future #1
[16:01:40.950] result() for MulticoreFuture ...
[16:01:40.951] result() for MulticoreFuture ...
[16:01:40.951] result() for MulticoreFuture ... done
[16:01:40.951] result() for MulticoreFuture ... done
[16:01:40.951] result() for MulticoreFuture ...
[16:01:40.951] result() for MulticoreFuture ... done
[16:01:40.951] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:01:40.952] - nx: 2
[16:01:40.952] - relay: TRUE
[16:01:40.952] - stdout: TRUE
[16:01:40.952] - signal: TRUE
[16:01:40.952] - resignal: FALSE
[16:01:40.952] - force: TRUE
[16:01:40.952] - relayed: [n=2] FALSE, FALSE
[16:01:40.952] - queued futures: [n=2] FALSE, FALSE
[16:01:40.953]  - until=1
[16:01:40.953]  - relaying element #1
[16:01:40.953] result() for MulticoreFuture ...
[16:01:40.953] result() for MulticoreFuture ... done
[16:01:40.953] result() for MulticoreFuture ...
[16:01:40.953] result() for MulticoreFuture ... done
[16:01:40.954] result() for MulticoreFuture ...
[16:01:40.954] result() for MulticoreFuture ... done
[16:01:40.954] result() for MulticoreFuture ...
[16:01:40.954] result() for MulticoreFuture ... done
[16:01:40.954] - relayed: [n=2] TRUE, FALSE
[16:01:40.954] - queued futures: [n=2] TRUE, FALSE
[16:01:40.954] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:01:40.955]  length: 1 (resolved future 1)
[16:01:40.955] Future #2
[16:01:40.955] result() for MulticoreFuture ...
[16:01:40.956] result() for MulticoreFuture ...
[16:01:40.956] result() for MulticoreFuture ... done
[16:01:40.956] result() for MulticoreFuture ... done
[16:01:40.956] result() for MulticoreFuture ...
[16:01:40.956] result() for MulticoreFuture ... done
[16:01:40.957] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:01:40.957] - nx: 2
[16:01:40.957] - relay: TRUE
[16:01:40.957] - stdout: TRUE
[16:01:40.957] - signal: TRUE
[16:01:40.957] - resignal: FALSE
[16:01:40.957] - force: TRUE
[16:01:40.957] - relayed: [n=2] TRUE, FALSE
[16:01:40.957] - queued futures: [n=2] TRUE, FALSE
[16:01:40.958]  - until=2
[16:01:40.958]  - relaying element #2
[16:01:40.958] result() for MulticoreFuture ...
[16:01:40.958] result() for MulticoreFuture ... done
[16:01:40.960] result() for MulticoreFuture ...
[16:01:40.961] result() for MulticoreFuture ... done
[16:01:40.961] result() for MulticoreFuture ...
[16:01:40.961] result() for MulticoreFuture ... done
[16:01:40.961] result() for MulticoreFuture ...
[16:01:40.961] result() for MulticoreFuture ... done
[16:01:40.962] - relayed: [n=2] TRUE, TRUE
[16:01:40.962] - queued futures: [n=2] TRUE, TRUE
[16:01:40.962] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:01:40.962]  length: 0 (resolved future 2)
[16:01:40.962] Relaying remaining futures
[16:01:40.962] signalConditionsASAP(NULL, pos=0) ...
[16:01:40.963] - nx: 2
[16:01:40.963] - relay: TRUE
[16:01:40.963] - stdout: TRUE
[16:01:40.963] - signal: TRUE
[16:01:40.963] - resignal: FALSE
[16:01:40.963] - force: TRUE
[16:01:40.963] - relayed: [n=2] TRUE, TRUE
[16:01:40.964] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:40.964] - relayed: [n=2] TRUE, TRUE
[16:01:40.964] - queued futures: [n=2] TRUE, TRUE
[16:01:40.964] signalConditionsASAP(NULL, pos=0) ... done
[16:01:40.964] resolve() on list ... DONE
[16:01:40.965] result() for MulticoreFuture ...
[16:01:40.965] result() for MulticoreFuture ... done
[16:01:40.965] result() for MulticoreFuture ...
[16:01:40.965] result() for MulticoreFuture ... done
[16:01:40.965] result() for MulticoreFuture ...
[16:01:40.965] result() for MulticoreFuture ... done
[16:01:40.965] result() for MulticoreFuture ...
[16:01:40.966] result() for MulticoreFuture ... done
[16:01:40.966]  - Number of value chunks collected: 2
[16:01:40.966] Resolving 2 futures (chunks) ... DONE
[16:01:40.966] Reducing values from 2 chunks ...
[16:01:40.966]  - Number of values collected after concatenation: 2
[16:01:40.966]  - Number of values expected: 2
[16:01:40.966] Reducing values from 2 chunks ... DONE
[16:01:40.966] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[16:01:40.967] getGlobalsAndPackagesXApply() ...
[16:01:40.967]  - future.globals: TRUE
[16:01:40.967] getGlobalsAndPackages() ...
[16:01:40.967] Searching for globals...
[16:01:40.969] - globals found: [1] ‘FUN’
[16:01:40.969] Searching for globals ... DONE
[16:01:40.969] Resolving globals: FALSE
[16:01:40.969] The total size of the 1 globals is 848 bytes (848 bytes)
[16:01:40.970] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:01:40.970] - globals: [1] ‘FUN’
[16:01:40.970] 
[16:01:40.970] getGlobalsAndPackages() ... DONE
[16:01:40.970]  - globals found/used: [n=1] ‘FUN’
[16:01:40.970]  - needed namespaces: [n=0] 
[16:01:40.971] Finding globals ... DONE
[16:01:40.971]  - use_args: TRUE
[16:01:40.971]  - Getting '...' globals ...
[16:01:40.971] resolve() on list ...
[16:01:40.972]  recursive: 0
[16:01:40.972]  length: 1
[16:01:40.972]  elements: ‘...’
[16:01:40.972]  length: 0 (resolved future 1)
[16:01:40.972] resolve() on list ... DONE
[16:01:40.972]    - '...' content: [n=0] 
[16:01:40.972] List of 1
[16:01:40.972]  $ ...: list()
[16:01:40.972]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.972]  - attr(*, "where")=List of 1
[16:01:40.972]   ..$ ...:<environment: 0x55fb63bdb5d0> 
[16:01:40.972]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.972]  - attr(*, "resolved")= logi TRUE
[16:01:40.972]  - attr(*, "total_size")= num NA
[16:01:40.976]  - Getting '...' globals ... DONE
[16:01:40.976] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:40.976] List of 2
[16:01:40.976]  $ ...future.FUN:function (x)  
[16:01:40.976]  $ ...          : list()
[16:01:40.976]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.976]  - attr(*, "where")=List of 2
[16:01:40.976]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:40.976]   ..$ ...          :<environment: 0x55fb63bdb5d0> 
[16:01:40.976]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.976]  - attr(*, "resolved")= logi FALSE
[16:01:40.976]  - attr(*, "total_size")= num 848
[16:01:40.979] Packages to be attached in all futures: [n=0] 
[16:01:40.979] getGlobalsAndPackagesXApply() ... DONE
[16:01:40.983] future_lapply() ...
[16:01:40.988] Number of chunks: 2
[16:01:40.988] getGlobalsAndPackagesXApply() ...
[16:01:40.988]  - future.globals: <name-value list> with names ‘list()’
[16:01:40.989]  - use_args: TRUE
[16:01:40.989] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:01:40.989] List of 2
[16:01:40.989]  $ ...          : list()
[16:01:40.989]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:40.989]  $ ...future.FUN:function (x)  
[16:01:40.989]  - attr(*, "where")=List of 2
[16:01:40.989]   ..$ ...          :<environment: 0x55fb63bdb5d0> 
[16:01:40.989]   ..$ ...future.FUN:<environment: namespace:base> 
[16:01:40.989]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:40.989]  - attr(*, "resolved")= logi FALSE
[16:01:40.989]  - attr(*, "total_size")= num NA
[16:01:40.995] Packages to be attached in all futures: [n=0] 
[16:01:40.995] getGlobalsAndPackagesXApply() ... DONE
[16:01:40.996] Number of futures (= number of chunks): 2
[16:01:40.996] Launching 2 futures (chunks) ...
[16:01:40.996] Chunk #1 of 2 ...
[16:01:40.996]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:40.996]  - seeds: <none>
[16:01:40.997]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.997] getGlobalsAndPackages() ...
[16:01:40.997] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.997] Resolving globals: FALSE
[16:01:40.997] Tweak future expression to call with '...' arguments ...
[16:01:40.997] {
[16:01:40.997]     do.call(function(...) {
[16:01:40.997]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:40.997]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:40.997]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:40.997]             on.exit(options(oopts), add = TRUE)
[16:01:40.997]         }
[16:01:40.997]         {
[16:01:40.997]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:40.997]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:40.997]                 ...future.FUN(...future.X_jj, ...)
[16:01:40.997]             })
[16:01:40.997]         }
[16:01:40.997]     }, args = future.call.arguments)
[16:01:40.997] }
[16:01:40.998] Tweak future expression to call with '...' arguments ... DONE
[16:01:40.999] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:40.999] 
[16:01:40.999] getGlobalsAndPackages() ... DONE
[16:01:40.999] run() for ‘Future’ ...
[16:01:41.000] - state: ‘created’
[16:01:41.000] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:41.005] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:41.005] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:41.005]   - Field: ‘label’
[16:01:41.005]   - Field: ‘local’
[16:01:41.006]   - Field: ‘owner’
[16:01:41.006]   - Field: ‘envir’
[16:01:41.006]   - Field: ‘workers’
[16:01:41.006]   - Field: ‘packages’
[16:01:41.006]   - Field: ‘gc’
[16:01:41.007]   - Field: ‘job’
[16:01:41.007]   - Field: ‘conditions’
[16:01:41.007]   - Field: ‘expr’
[16:01:41.007]   - Field: ‘uuid’
[16:01:41.007]   - Field: ‘seed’
[16:01:41.007]   - Field: ‘version’
[16:01:41.008]   - Field: ‘result’
[16:01:41.008]   - Field: ‘asynchronous’
[16:01:41.008]   - Field: ‘calls’
[16:01:41.008]   - Field: ‘globals’
[16:01:41.008]   - Field: ‘stdout’
[16:01:41.009]   - Field: ‘earlySignal’
[16:01:41.009]   - Field: ‘lazy’
[16:01:41.009]   - Field: ‘state’
[16:01:41.009] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:41.009] - Launch lazy future ...
[16:01:41.010] Packages needed by the future expression (n = 0): <none>
[16:01:41.010] Packages needed by future strategies (n = 0): <none>
[16:01:41.011] {
[16:01:41.011]     {
[16:01:41.011]         {
[16:01:41.011]             ...future.startTime <- base::Sys.time()
[16:01:41.011]             {
[16:01:41.011]                 {
[16:01:41.011]                   {
[16:01:41.011]                     {
[16:01:41.011]                       base::local({
[16:01:41.011]                         has_future <- base::requireNamespace("future", 
[16:01:41.011]                           quietly = TRUE)
[16:01:41.011]                         if (has_future) {
[16:01:41.011]                           ns <- base::getNamespace("future")
[16:01:41.011]                           version <- ns[[".package"]][["version"]]
[16:01:41.011]                           if (is.null(version)) 
[16:01:41.011]                             version <- utils::packageVersion("future")
[16:01:41.011]                         }
[16:01:41.011]                         else {
[16:01:41.011]                           version <- NULL
[16:01:41.011]                         }
[16:01:41.011]                         if (!has_future || version < "1.8.0") {
[16:01:41.011]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:41.011]                             "", base::R.version$version.string), 
[16:01:41.011]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:41.011]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:41.011]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:41.011]                               "release", "version")], collapse = " "), 
[16:01:41.011]                             hostname = base::Sys.info()[["nodename"]])
[16:01:41.011]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:41.011]                             info)
[16:01:41.011]                           info <- base::paste(info, collapse = "; ")
[16:01:41.011]                           if (!has_future) {
[16:01:41.011]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:41.011]                               info)
[16:01:41.011]                           }
[16:01:41.011]                           else {
[16:01:41.011]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:41.011]                               info, version)
[16:01:41.011]                           }
[16:01:41.011]                           base::stop(msg)
[16:01:41.011]                         }
[16:01:41.011]                       })
[16:01:41.011]                     }
[16:01:41.011]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:41.011]                     base::options(mc.cores = 1L)
[16:01:41.011]                   }
[16:01:41.011]                   options(future.plan = NULL)
[16:01:41.011]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:41.011]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:41.011]                 }
[16:01:41.011]                 ...future.workdir <- getwd()
[16:01:41.011]             }
[16:01:41.011]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:41.011]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:41.011]         }
[16:01:41.011]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:41.011]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:41.011]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:41.011]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:41.011]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:41.011]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:41.011]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:41.011]             base::names(...future.oldOptions))
[16:01:41.011]     }
[16:01:41.011]     if (FALSE) {
[16:01:41.011]     }
[16:01:41.011]     else {
[16:01:41.011]         if (TRUE) {
[16:01:41.011]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:41.011]                 open = "w")
[16:01:41.011]         }
[16:01:41.011]         else {
[16:01:41.011]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:41.011]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:41.011]         }
[16:01:41.011]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:41.011]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:41.011]             base::sink(type = "output", split = FALSE)
[16:01:41.011]             base::close(...future.stdout)
[16:01:41.011]         }, add = TRUE)
[16:01:41.011]     }
[16:01:41.011]     ...future.frame <- base::sys.nframe()
[16:01:41.011]     ...future.conditions <- base::list()
[16:01:41.011]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:41.011]     if (FALSE) {
[16:01:41.011]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:41.011]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:41.011]     }
[16:01:41.011]     ...future.result <- base::tryCatch({
[16:01:41.011]         base::withCallingHandlers({
[16:01:41.011]             ...future.value <- base::withVisible(base::local({
[16:01:41.011]                 withCallingHandlers({
[16:01:41.011]                   {
[16:01:41.011]                     do.call(function(...) {
[16:01:41.011]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.011]                       if (!identical(...future.globals.maxSize.org, 
[16:01:41.011]                         ...future.globals.maxSize)) {
[16:01:41.011]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.011]                         on.exit(options(oopts), add = TRUE)
[16:01:41.011]                       }
[16:01:41.011]                       {
[16:01:41.011]                         lapply(seq_along(...future.elements_ii), 
[16:01:41.011]                           FUN = function(jj) {
[16:01:41.011]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.011]                             ...future.FUN(...future.X_jj, ...)
[16:01:41.011]                           })
[16:01:41.011]                       }
[16:01:41.011]                     }, args = future.call.arguments)
[16:01:41.011]                   }
[16:01:41.011]                 }, immediateCondition = function(cond) {
[16:01:41.011]                   save_rds <- function (object, pathname, ...) 
[16:01:41.011]                   {
[16:01:41.011]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:41.011]                     if (file_test("-f", pathname_tmp)) {
[16:01:41.011]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.011]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:41.011]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.011]                         fi_tmp[["mtime"]])
[16:01:41.011]                     }
[16:01:41.011]                     tryCatch({
[16:01:41.011]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:41.011]                     }, error = function(ex) {
[16:01:41.011]                       msg <- conditionMessage(ex)
[16:01:41.011]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.011]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:41.011]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.011]                         fi_tmp[["mtime"]], msg)
[16:01:41.011]                       ex$message <- msg
[16:01:41.011]                       stop(ex)
[16:01:41.011]                     })
[16:01:41.011]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:41.011]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:41.011]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:41.011]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.011]                       fi <- file.info(pathname)
[16:01:41.011]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:41.011]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.011]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:41.011]                         fi[["size"]], fi[["mtime"]])
[16:01:41.011]                       stop(msg)
[16:01:41.011]                     }
[16:01:41.011]                     invisible(pathname)
[16:01:41.011]                   }
[16:01:41.011]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:41.011]                     rootPath = tempdir()) 
[16:01:41.011]                   {
[16:01:41.011]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:41.011]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:41.011]                       tmpdir = path, fileext = ".rds")
[16:01:41.011]                     save_rds(obj, file)
[16:01:41.011]                   }
[16:01:41.011]                   saveImmediateCondition(cond, path = "/tmp/RtmplAoKyr/.future/immediateConditions")
[16:01:41.011]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.011]                   {
[16:01:41.011]                     inherits <- base::inherits
[16:01:41.011]                     invokeRestart <- base::invokeRestart
[16:01:41.011]                     is.null <- base::is.null
[16:01:41.011]                     muffled <- FALSE
[16:01:41.011]                     if (inherits(cond, "message")) {
[16:01:41.011]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:41.011]                       if (muffled) 
[16:01:41.011]                         invokeRestart("muffleMessage")
[16:01:41.011]                     }
[16:01:41.011]                     else if (inherits(cond, "warning")) {
[16:01:41.011]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:41.011]                       if (muffled) 
[16:01:41.011]                         invokeRestart("muffleWarning")
[16:01:41.011]                     }
[16:01:41.011]                     else if (inherits(cond, "condition")) {
[16:01:41.011]                       if (!is.null(pattern)) {
[16:01:41.011]                         computeRestarts <- base::computeRestarts
[16:01:41.011]                         grepl <- base::grepl
[16:01:41.011]                         restarts <- computeRestarts(cond)
[16:01:41.011]                         for (restart in restarts) {
[16:01:41.011]                           name <- restart$name
[16:01:41.011]                           if (is.null(name)) 
[16:01:41.011]                             next
[16:01:41.011]                           if (!grepl(pattern, name)) 
[16:01:41.011]                             next
[16:01:41.011]                           invokeRestart(restart)
[16:01:41.011]                           muffled <- TRUE
[16:01:41.011]                           break
[16:01:41.011]                         }
[16:01:41.011]                       }
[16:01:41.011]                     }
[16:01:41.011]                     invisible(muffled)
[16:01:41.011]                   }
[16:01:41.011]                   muffleCondition(cond)
[16:01:41.011]                 })
[16:01:41.011]             }))
[16:01:41.011]             future::FutureResult(value = ...future.value$value, 
[16:01:41.011]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:41.011]                   ...future.rng), globalenv = if (FALSE) 
[16:01:41.011]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:41.011]                     ...future.globalenv.names))
[16:01:41.011]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:41.011]         }, condition = base::local({
[16:01:41.011]             c <- base::c
[16:01:41.011]             inherits <- base::inherits
[16:01:41.011]             invokeRestart <- base::invokeRestart
[16:01:41.011]             length <- base::length
[16:01:41.011]             list <- base::list
[16:01:41.011]             seq.int <- base::seq.int
[16:01:41.011]             signalCondition <- base::signalCondition
[16:01:41.011]             sys.calls <- base::sys.calls
[16:01:41.011]             `[[` <- base::`[[`
[16:01:41.011]             `+` <- base::`+`
[16:01:41.011]             `<<-` <- base::`<<-`
[16:01:41.011]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:41.011]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:41.011]                   3L)]
[16:01:41.011]             }
[16:01:41.011]             function(cond) {
[16:01:41.011]                 is_error <- inherits(cond, "error")
[16:01:41.011]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:41.011]                   NULL)
[16:01:41.011]                 if (is_error) {
[16:01:41.011]                   sessionInformation <- function() {
[16:01:41.011]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:41.011]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:41.011]                       search = base::search(), system = base::Sys.info())
[16:01:41.011]                   }
[16:01:41.011]                   ...future.conditions[[length(...future.conditions) + 
[16:01:41.011]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:41.011]                     cond$call), session = sessionInformation(), 
[16:01:41.011]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:41.011]                   signalCondition(cond)
[16:01:41.011]                 }
[16:01:41.011]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:41.011]                 "immediateCondition"))) {
[16:01:41.011]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:41.011]                   ...future.conditions[[length(...future.conditions) + 
[16:01:41.011]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:41.011]                   if (TRUE && !signal) {
[16:01:41.011]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.011]                     {
[16:01:41.011]                       inherits <- base::inherits
[16:01:41.011]                       invokeRestart <- base::invokeRestart
[16:01:41.011]                       is.null <- base::is.null
[16:01:41.011]                       muffled <- FALSE
[16:01:41.011]                       if (inherits(cond, "message")) {
[16:01:41.011]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:41.011]                         if (muffled) 
[16:01:41.011]                           invokeRestart("muffleMessage")
[16:01:41.011]                       }
[16:01:41.011]                       else if (inherits(cond, "warning")) {
[16:01:41.011]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:41.011]                         if (muffled) 
[16:01:41.011]                           invokeRestart("muffleWarning")
[16:01:41.011]                       }
[16:01:41.011]                       else if (inherits(cond, "condition")) {
[16:01:41.011]                         if (!is.null(pattern)) {
[16:01:41.011]                           computeRestarts <- base::computeRestarts
[16:01:41.011]                           grepl <- base::grepl
[16:01:41.011]                           restarts <- computeRestarts(cond)
[16:01:41.011]                           for (restart in restarts) {
[16:01:41.011]                             name <- restart$name
[16:01:41.011]                             if (is.null(name)) 
[16:01:41.011]                               next
[16:01:41.011]                             if (!grepl(pattern, name)) 
[16:01:41.011]                               next
[16:01:41.011]                             invokeRestart(restart)
[16:01:41.011]                             muffled <- TRUE
[16:01:41.011]                             break
[16:01:41.011]                           }
[16:01:41.011]                         }
[16:01:41.011]                       }
[16:01:41.011]                       invisible(muffled)
[16:01:41.011]                     }
[16:01:41.011]                     muffleCondition(cond, pattern = "^muffle")
[16:01:41.011]                   }
[16:01:41.011]                 }
[16:01:41.011]                 else {
[16:01:41.011]                   if (TRUE) {
[16:01:41.011]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.011]                     {
[16:01:41.011]                       inherits <- base::inherits
[16:01:41.011]                       invokeRestart <- base::invokeRestart
[16:01:41.011]                       is.null <- base::is.null
[16:01:41.011]                       muffled <- FALSE
[16:01:41.011]                       if (inherits(cond, "message")) {
[16:01:41.011]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:41.011]                         if (muffled) 
[16:01:41.011]                           invokeRestart("muffleMessage")
[16:01:41.011]                       }
[16:01:41.011]                       else if (inherits(cond, "warning")) {
[16:01:41.011]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:41.011]                         if (muffled) 
[16:01:41.011]                           invokeRestart("muffleWarning")
[16:01:41.011]                       }
[16:01:41.011]                       else if (inherits(cond, "condition")) {
[16:01:41.011]                         if (!is.null(pattern)) {
[16:01:41.011]                           computeRestarts <- base::computeRestarts
[16:01:41.011]                           grepl <- base::grepl
[16:01:41.011]                           restarts <- computeRestarts(cond)
[16:01:41.011]                           for (restart in restarts) {
[16:01:41.011]                             name <- restart$name
[16:01:41.011]                             if (is.null(name)) 
[16:01:41.011]                               next
[16:01:41.011]                             if (!grepl(pattern, name)) 
[16:01:41.011]                               next
[16:01:41.011]                             invokeRestart(restart)
[16:01:41.011]                             muffled <- TRUE
[16:01:41.011]                             break
[16:01:41.011]                           }
[16:01:41.011]                         }
[16:01:41.011]                       }
[16:01:41.011]                       invisible(muffled)
[16:01:41.011]                     }
[16:01:41.011]                     muffleCondition(cond, pattern = "^muffle")
[16:01:41.011]                   }
[16:01:41.011]                 }
[16:01:41.011]             }
[16:01:41.011]         }))
[16:01:41.011]     }, error = function(ex) {
[16:01:41.011]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:41.011]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:41.011]                 ...future.rng), started = ...future.startTime, 
[16:01:41.011]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:41.011]             version = "1.8"), class = "FutureResult")
[16:01:41.011]     }, finally = {
[16:01:41.011]         if (!identical(...future.workdir, getwd())) 
[16:01:41.011]             setwd(...future.workdir)
[16:01:41.011]         {
[16:01:41.011]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:41.011]                 ...future.oldOptions$nwarnings <- NULL
[16:01:41.011]             }
[16:01:41.011]             base::options(...future.oldOptions)
[16:01:41.011]             if (.Platform$OS.type == "windows") {
[16:01:41.011]                 old_names <- names(...future.oldEnvVars)
[16:01:41.011]                 envs <- base::Sys.getenv()
[16:01:41.011]                 names <- names(envs)
[16:01:41.011]                 common <- intersect(names, old_names)
[16:01:41.011]                 added <- setdiff(names, old_names)
[16:01:41.011]                 removed <- setdiff(old_names, names)
[16:01:41.011]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:41.011]                   envs[common]]
[16:01:41.011]                 NAMES <- toupper(changed)
[16:01:41.011]                 args <- list()
[16:01:41.011]                 for (kk in seq_along(NAMES)) {
[16:01:41.011]                   name <- changed[[kk]]
[16:01:41.011]                   NAME <- NAMES[[kk]]
[16:01:41.011]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.011]                     next
[16:01:41.011]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:41.011]                 }
[16:01:41.011]                 NAMES <- toupper(added)
[16:01:41.011]                 for (kk in seq_along(NAMES)) {
[16:01:41.011]                   name <- added[[kk]]
[16:01:41.011]                   NAME <- NAMES[[kk]]
[16:01:41.011]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.011]                     next
[16:01:41.011]                   args[[name]] <- ""
[16:01:41.011]                 }
[16:01:41.011]                 NAMES <- toupper(removed)
[16:01:41.011]                 for (kk in seq_along(NAMES)) {
[16:01:41.011]                   name <- removed[[kk]]
[16:01:41.011]                   NAME <- NAMES[[kk]]
[16:01:41.011]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.011]                     next
[16:01:41.011]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:41.011]                 }
[16:01:41.011]                 if (length(args) > 0) 
[16:01:41.011]                   base::do.call(base::Sys.setenv, args = args)
[16:01:41.011]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:41.011]             }
[16:01:41.011]             else {
[16:01:41.011]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:41.011]             }
[16:01:41.011]             {
[16:01:41.011]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:41.011]                   0L) {
[16:01:41.011]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:41.011]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:41.011]                   base::options(opts)
[16:01:41.011]                 }
[16:01:41.011]                 {
[16:01:41.011]                   {
[16:01:41.011]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:41.011]                     NULL
[16:01:41.011]                   }
[16:01:41.011]                   options(future.plan = NULL)
[16:01:41.011]                   if (is.na(NA_character_)) 
[16:01:41.011]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:41.011]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:41.011]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:41.011]                     envir = parent.frame()) 
[16:01:41.011]                   {
[16:01:41.011]                     default_workers <- missing(workers)
[16:01:41.011]                     if (is.function(workers)) 
[16:01:41.011]                       workers <- workers()
[16:01:41.011]                     workers <- structure(as.integer(workers), 
[16:01:41.011]                       class = class(workers))
[16:01:41.011]                     stop_if_not(is.finite(workers), workers >= 
[16:01:41.011]                       1L)
[16:01:41.011]                     if ((workers == 1L && !inherits(workers, 
[16:01:41.011]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:41.011]                       if (default_workers) 
[16:01:41.011]                         supportsMulticore(warn = TRUE)
[16:01:41.011]                       return(sequential(..., envir = envir))
[16:01:41.011]                     }
[16:01:41.011]                     oopts <- options(mc.cores = workers)
[16:01:41.011]                     on.exit(options(oopts))
[16:01:41.011]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:41.011]                       envir = envir)
[16:01:41.011]                     if (!future$lazy) 
[16:01:41.011]                       future <- run(future)
[16:01:41.011]                     invisible(future)
[16:01:41.011]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:41.011]                 }
[16:01:41.011]             }
[16:01:41.011]         }
[16:01:41.011]     })
[16:01:41.011]     if (TRUE) {
[16:01:41.011]         base::sink(type = "output", split = FALSE)
[16:01:41.011]         if (TRUE) {
[16:01:41.011]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:41.011]         }
[16:01:41.011]         else {
[16:01:41.011]             ...future.result["stdout"] <- base::list(NULL)
[16:01:41.011]         }
[16:01:41.011]         base::close(...future.stdout)
[16:01:41.011]         ...future.stdout <- NULL
[16:01:41.011]     }
[16:01:41.011]     ...future.result$conditions <- ...future.conditions
[16:01:41.011]     ...future.result$finished <- base::Sys.time()
[16:01:41.011]     ...future.result
[16:01:41.011] }
[16:01:41.015] assign_globals() ...
[16:01:41.015] List of 5
[16:01:41.015]  $ future.call.arguments    : list()
[16:01:41.015]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:41.015]  $ ...future.FUN            :function (x)  
[16:01:41.015]  $ ...future.elements_ii    :List of 3
[16:01:41.015]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[16:01:41.015]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[16:01:41.015]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[16:01:41.015]  $ ...future.seeds_ii       : NULL
[16:01:41.015]  $ ...future.globals.maxSize: num Inf
[16:01:41.015]  - attr(*, "resolved")= logi FALSE
[16:01:41.015]  - attr(*, "total_size")= num NA
[16:01:41.015]  - attr(*, "where")=List of 5
[16:01:41.015]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:41.015]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:41.015]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:41.015]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:41.015]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:41.015]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:41.015]  - attr(*, "already-done")= logi TRUE
[16:01:41.026] - copied ‘future.call.arguments’ to environment
[16:01:41.026] - copied ‘...future.FUN’ to environment
[16:01:41.026] - copied ‘...future.elements_ii’ to environment
[16:01:41.026] - copied ‘...future.seeds_ii’ to environment
[16:01:41.026] - copied ‘...future.globals.maxSize’ to environment
[16:01:41.026] assign_globals() ... done
[16:01:41.027] requestCore(): workers = 2
[16:01:41.030] MulticoreFuture started
[16:01:41.031] - Launch lazy future ... done
[16:01:41.031] run() for ‘MulticoreFuture’ ... done
[16:01:41.031] Created future:
[16:01:41.031] plan(): Setting new future strategy stack:
[16:01:41.031] List of future strategies:
[16:01:41.031] 1. sequential:
[16:01:41.031]    - args: function (..., envir = parent.frame())
[16:01:41.031]    - tweaked: FALSE
[16:01:41.031]    - call: NULL
[16:01:41.032] plan(): nbrOfWorkers() = 1
[16:01:41.034] plan(): Setting new future strategy stack:
[16:01:41.034] List of future strategies:
[16:01:41.034] 1. multicore:
[16:01:41.034]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:41.034]    - tweaked: FALSE
[16:01:41.034]    - call: plan(strategy)
[16:01:41.040] plan(): nbrOfWorkers() = 2
[16:01:41.031] MulticoreFuture:
[16:01:41.031] Label: ‘future_apply-1’
[16:01:41.031] Expression:
[16:01:41.031] {
[16:01:41.031]     do.call(function(...) {
[16:01:41.031]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.031]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:41.031]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.031]             on.exit(options(oopts), add = TRUE)
[16:01:41.031]         }
[16:01:41.031]         {
[16:01:41.031]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:41.031]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.031]                 ...future.FUN(...future.X_jj, ...)
[16:01:41.031]             })
[16:01:41.031]         }
[16:01:41.031]     }, args = future.call.arguments)
[16:01:41.031] }
[16:01:41.031] Lazy evaluation: FALSE
[16:01:41.031] Asynchronous evaluation: TRUE
[16:01:41.031] Local evaluation: TRUE
[16:01:41.031] Environment: R_GlobalEnv
[16:01:41.031] Capture standard output: TRUE
[16:01:41.031] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:41.031] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:41.031] Packages: <none>
[16:01:41.031] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:41.031] Resolved: TRUE
[16:01:41.031] Value: <not collected>
[16:01:41.031] Conditions captured: <none>
[16:01:41.031] Early signaling: FALSE
[16:01:41.031] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:41.031] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:41.041] Chunk #1 of 2 ... DONE
[16:01:41.041] Chunk #2 of 2 ...
[16:01:41.041]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:41.041]  - seeds: <none>
[16:01:41.042]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.042] getGlobalsAndPackages() ...
[16:01:41.042] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.042] Resolving globals: FALSE
[16:01:41.042] Tweak future expression to call with '...' arguments ...
[16:01:41.042] {
[16:01:41.042]     do.call(function(...) {
[16:01:41.042]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.042]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:41.042]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.042]             on.exit(options(oopts), add = TRUE)
[16:01:41.042]         }
[16:01:41.042]         {
[16:01:41.042]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:41.042]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.042]                 ...future.FUN(...future.X_jj, ...)
[16:01:41.042]             })
[16:01:41.042]         }
[16:01:41.042]     }, args = future.call.arguments)
[16:01:41.042] }
[16:01:41.043] Tweak future expression to call with '...' arguments ... DONE
[16:01:41.043] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.044] 
[16:01:41.044] getGlobalsAndPackages() ... DONE
[16:01:41.044] run() for ‘Future’ ...
[16:01:41.044] - state: ‘created’
[16:01:41.045] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:41.049] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:41.050] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:41.050]   - Field: ‘label’
[16:01:41.050]   - Field: ‘local’
[16:01:41.050]   - Field: ‘owner’
[16:01:41.050]   - Field: ‘envir’
[16:01:41.050]   - Field: ‘workers’
[16:01:41.050]   - Field: ‘packages’
[16:01:41.051]   - Field: ‘gc’
[16:01:41.054]   - Field: ‘job’
[16:01:41.054]   - Field: ‘conditions’
[16:01:41.055]   - Field: ‘expr’
[16:01:41.055]   - Field: ‘uuid’
[16:01:41.055]   - Field: ‘seed’
[16:01:41.056]   - Field: ‘version’
[16:01:41.056]   - Field: ‘result’
[16:01:41.056]   - Field: ‘asynchronous’
[16:01:41.057]   - Field: ‘calls’
[16:01:41.057]   - Field: ‘globals’
[16:01:41.057]   - Field: ‘stdout’
[16:01:41.057]   - Field: ‘earlySignal’
[16:01:41.058]   - Field: ‘lazy’
[16:01:41.058]   - Field: ‘state’
[16:01:41.058] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:41.058] - Launch lazy future ...
[16:01:41.059] Packages needed by the future expression (n = 0): <none>
[16:01:41.060] Packages needed by future strategies (n = 0): <none>
[16:01:41.061] {
[16:01:41.061]     {
[16:01:41.061]         {
[16:01:41.061]             ...future.startTime <- base::Sys.time()
[16:01:41.061]             {
[16:01:41.061]                 {
[16:01:41.061]                   {
[16:01:41.061]                     {
[16:01:41.061]                       base::local({
[16:01:41.061]                         has_future <- base::requireNamespace("future", 
[16:01:41.061]                           quietly = TRUE)
[16:01:41.061]                         if (has_future) {
[16:01:41.061]                           ns <- base::getNamespace("future")
[16:01:41.061]                           version <- ns[[".package"]][["version"]]
[16:01:41.061]                           if (is.null(version)) 
[16:01:41.061]                             version <- utils::packageVersion("future")
[16:01:41.061]                         }
[16:01:41.061]                         else {
[16:01:41.061]                           version <- NULL
[16:01:41.061]                         }
[16:01:41.061]                         if (!has_future || version < "1.8.0") {
[16:01:41.061]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:41.061]                             "", base::R.version$version.string), 
[16:01:41.061]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:41.061]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:41.061]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:41.061]                               "release", "version")], collapse = " "), 
[16:01:41.061]                             hostname = base::Sys.info()[["nodename"]])
[16:01:41.061]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:41.061]                             info)
[16:01:41.061]                           info <- base::paste(info, collapse = "; ")
[16:01:41.061]                           if (!has_future) {
[16:01:41.061]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:41.061]                               info)
[16:01:41.061]                           }
[16:01:41.061]                           else {
[16:01:41.061]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:41.061]                               info, version)
[16:01:41.061]                           }
[16:01:41.061]                           base::stop(msg)
[16:01:41.061]                         }
[16:01:41.061]                       })
[16:01:41.061]                     }
[16:01:41.061]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:41.061]                     base::options(mc.cores = 1L)
[16:01:41.061]                   }
[16:01:41.061]                   options(future.plan = NULL)
[16:01:41.061]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:41.061]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:41.061]                 }
[16:01:41.061]                 ...future.workdir <- getwd()
[16:01:41.061]             }
[16:01:41.061]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:41.061]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:41.061]         }
[16:01:41.061]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:41.061]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:41.061]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:41.061]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:41.061]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:41.061]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:41.061]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:41.061]             base::names(...future.oldOptions))
[16:01:41.061]     }
[16:01:41.061]     if (FALSE) {
[16:01:41.061]     }
[16:01:41.061]     else {
[16:01:41.061]         if (TRUE) {
[16:01:41.061]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:41.061]                 open = "w")
[16:01:41.061]         }
[16:01:41.061]         else {
[16:01:41.061]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:41.061]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:41.061]         }
[16:01:41.061]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:41.061]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:41.061]             base::sink(type = "output", split = FALSE)
[16:01:41.061]             base::close(...future.stdout)
[16:01:41.061]         }, add = TRUE)
[16:01:41.061]     }
[16:01:41.061]     ...future.frame <- base::sys.nframe()
[16:01:41.061]     ...future.conditions <- base::list()
[16:01:41.061]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:41.061]     if (FALSE) {
[16:01:41.061]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:41.061]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:41.061]     }
[16:01:41.061]     ...future.result <- base::tryCatch({
[16:01:41.061]         base::withCallingHandlers({
[16:01:41.061]             ...future.value <- base::withVisible(base::local({
[16:01:41.061]                 withCallingHandlers({
[16:01:41.061]                   {
[16:01:41.061]                     do.call(function(...) {
[16:01:41.061]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.061]                       if (!identical(...future.globals.maxSize.org, 
[16:01:41.061]                         ...future.globals.maxSize)) {
[16:01:41.061]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.061]                         on.exit(options(oopts), add = TRUE)
[16:01:41.061]                       }
[16:01:41.061]                       {
[16:01:41.061]                         lapply(seq_along(...future.elements_ii), 
[16:01:41.061]                           FUN = function(jj) {
[16:01:41.061]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.061]                             ...future.FUN(...future.X_jj, ...)
[16:01:41.061]                           })
[16:01:41.061]                       }
[16:01:41.061]                     }, args = future.call.arguments)
[16:01:41.061]                   }
[16:01:41.061]                 }, immediateCondition = function(cond) {
[16:01:41.061]                   save_rds <- function (object, pathname, ...) 
[16:01:41.061]                   {
[16:01:41.061]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:41.061]                     if (file_test("-f", pathname_tmp)) {
[16:01:41.061]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.061]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:41.061]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.061]                         fi_tmp[["mtime"]])
[16:01:41.061]                     }
[16:01:41.061]                     tryCatch({
[16:01:41.061]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:41.061]                     }, error = function(ex) {
[16:01:41.061]                       msg <- conditionMessage(ex)
[16:01:41.061]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.061]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:41.061]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.061]                         fi_tmp[["mtime"]], msg)
[16:01:41.061]                       ex$message <- msg
[16:01:41.061]                       stop(ex)
[16:01:41.061]                     })
[16:01:41.061]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:41.061]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:41.061]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:41.061]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.061]                       fi <- file.info(pathname)
[16:01:41.061]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:41.061]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.061]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:41.061]                         fi[["size"]], fi[["mtime"]])
[16:01:41.061]                       stop(msg)
[16:01:41.061]                     }
[16:01:41.061]                     invisible(pathname)
[16:01:41.061]                   }
[16:01:41.061]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:41.061]                     rootPath = tempdir()) 
[16:01:41.061]                   {
[16:01:41.061]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:41.061]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:41.061]                       tmpdir = path, fileext = ".rds")
[16:01:41.061]                     save_rds(obj, file)
[16:01:41.061]                   }
[16:01:41.061]                   saveImmediateCondition(cond, path = "/tmp/RtmplAoKyr/.future/immediateConditions")
[16:01:41.061]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.061]                   {
[16:01:41.061]                     inherits <- base::inherits
[16:01:41.061]                     invokeRestart <- base::invokeRestart
[16:01:41.061]                     is.null <- base::is.null
[16:01:41.061]                     muffled <- FALSE
[16:01:41.061]                     if (inherits(cond, "message")) {
[16:01:41.061]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:41.061]                       if (muffled) 
[16:01:41.061]                         invokeRestart("muffleMessage")
[16:01:41.061]                     }
[16:01:41.061]                     else if (inherits(cond, "warning")) {
[16:01:41.061]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:41.061]                       if (muffled) 
[16:01:41.061]                         invokeRestart("muffleWarning")
[16:01:41.061]                     }
[16:01:41.061]                     else if (inherits(cond, "condition")) {
[16:01:41.061]                       if (!is.null(pattern)) {
[16:01:41.061]                         computeRestarts <- base::computeRestarts
[16:01:41.061]                         grepl <- base::grepl
[16:01:41.061]                         restarts <- computeRestarts(cond)
[16:01:41.061]                         for (restart in restarts) {
[16:01:41.061]                           name <- restart$name
[16:01:41.061]                           if (is.null(name)) 
[16:01:41.061]                             next
[16:01:41.061]                           if (!grepl(pattern, name)) 
[16:01:41.061]                             next
[16:01:41.061]                           invokeRestart(restart)
[16:01:41.061]                           muffled <- TRUE
[16:01:41.061]                           break
[16:01:41.061]                         }
[16:01:41.061]                       }
[16:01:41.061]                     }
[16:01:41.061]                     invisible(muffled)
[16:01:41.061]                   }
[16:01:41.061]                   muffleCondition(cond)
[16:01:41.061]                 })
[16:01:41.061]             }))
[16:01:41.061]             future::FutureResult(value = ...future.value$value, 
[16:01:41.061]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:41.061]                   ...future.rng), globalenv = if (FALSE) 
[16:01:41.061]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:41.061]                     ...future.globalenv.names))
[16:01:41.061]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:41.061]         }, condition = base::local({
[16:01:41.061]             c <- base::c
[16:01:41.061]             inherits <- base::inherits
[16:01:41.061]             invokeRestart <- base::invokeRestart
[16:01:41.061]             length <- base::length
[16:01:41.061]             list <- base::list
[16:01:41.061]             seq.int <- base::seq.int
[16:01:41.061]             signalCondition <- base::signalCondition
[16:01:41.061]             sys.calls <- base::sys.calls
[16:01:41.061]             `[[` <- base::`[[`
[16:01:41.061]             `+` <- base::`+`
[16:01:41.061]             `<<-` <- base::`<<-`
[16:01:41.061]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:41.061]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:41.061]                   3L)]
[16:01:41.061]             }
[16:01:41.061]             function(cond) {
[16:01:41.061]                 is_error <- inherits(cond, "error")
[16:01:41.061]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:41.061]                   NULL)
[16:01:41.061]                 if (is_error) {
[16:01:41.061]                   sessionInformation <- function() {
[16:01:41.061]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:41.061]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:41.061]                       search = base::search(), system = base::Sys.info())
[16:01:41.061]                   }
[16:01:41.061]                   ...future.conditions[[length(...future.conditions) + 
[16:01:41.061]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:41.061]                     cond$call), session = sessionInformation(), 
[16:01:41.061]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:41.061]                   signalCondition(cond)
[16:01:41.061]                 }
[16:01:41.061]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:41.061]                 "immediateCondition"))) {
[16:01:41.061]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:41.061]                   ...future.conditions[[length(...future.conditions) + 
[16:01:41.061]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:41.061]                   if (TRUE && !signal) {
[16:01:41.061]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.061]                     {
[16:01:41.061]                       inherits <- base::inherits
[16:01:41.061]                       invokeRestart <- base::invokeRestart
[16:01:41.061]                       is.null <- base::is.null
[16:01:41.061]                       muffled <- FALSE
[16:01:41.061]                       if (inherits(cond, "message")) {
[16:01:41.061]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:41.061]                         if (muffled) 
[16:01:41.061]                           invokeRestart("muffleMessage")
[16:01:41.061]                       }
[16:01:41.061]                       else if (inherits(cond, "warning")) {
[16:01:41.061]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:41.061]                         if (muffled) 
[16:01:41.061]                           invokeRestart("muffleWarning")
[16:01:41.061]                       }
[16:01:41.061]                       else if (inherits(cond, "condition")) {
[16:01:41.061]                         if (!is.null(pattern)) {
[16:01:41.061]                           computeRestarts <- base::computeRestarts
[16:01:41.061]                           grepl <- base::grepl
[16:01:41.061]                           restarts <- computeRestarts(cond)
[16:01:41.061]                           for (restart in restarts) {
[16:01:41.061]                             name <- restart$name
[16:01:41.061]                             if (is.null(name)) 
[16:01:41.061]                               next
[16:01:41.061]                             if (!grepl(pattern, name)) 
[16:01:41.061]                               next
[16:01:41.061]                             invokeRestart(restart)
[16:01:41.061]                             muffled <- TRUE
[16:01:41.061]                             break
[16:01:41.061]                           }
[16:01:41.061]                         }
[16:01:41.061]                       }
[16:01:41.061]                       invisible(muffled)
[16:01:41.061]                     }
[16:01:41.061]                     muffleCondition(cond, pattern = "^muffle")
[16:01:41.061]                   }
[16:01:41.061]                 }
[16:01:41.061]                 else {
[16:01:41.061]                   if (TRUE) {
[16:01:41.061]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.061]                     {
[16:01:41.061]                       inherits <- base::inherits
[16:01:41.061]                       invokeRestart <- base::invokeRestart
[16:01:41.061]                       is.null <- base::is.null
[16:01:41.061]                       muffled <- FALSE
[16:01:41.061]                       if (inherits(cond, "message")) {
[16:01:41.061]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:41.061]                         if (muffled) 
[16:01:41.061]                           invokeRestart("muffleMessage")
[16:01:41.061]                       }
[16:01:41.061]                       else if (inherits(cond, "warning")) {
[16:01:41.061]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:41.061]                         if (muffled) 
[16:01:41.061]                           invokeRestart("muffleWarning")
[16:01:41.061]                       }
[16:01:41.061]                       else if (inherits(cond, "condition")) {
[16:01:41.061]                         if (!is.null(pattern)) {
[16:01:41.061]                           computeRestarts <- base::computeRestarts
[16:01:41.061]                           grepl <- base::grepl
[16:01:41.061]                           restarts <- computeRestarts(cond)
[16:01:41.061]                           for (restart in restarts) {
[16:01:41.061]                             name <- restart$name
[16:01:41.061]                             if (is.null(name)) 
[16:01:41.061]                               next
[16:01:41.061]                             if (!grepl(pattern, name)) 
[16:01:41.061]                               next
[16:01:41.061]                             invokeRestart(restart)
[16:01:41.061]                             muffled <- TRUE
[16:01:41.061]                             break
[16:01:41.061]                           }
[16:01:41.061]                         }
[16:01:41.061]                       }
[16:01:41.061]                       invisible(muffled)
[16:01:41.061]                     }
[16:01:41.061]                     muffleCondition(cond, pattern = "^muffle")
[16:01:41.061]                   }
[16:01:41.061]                 }
[16:01:41.061]             }
[16:01:41.061]         }))
[16:01:41.061]     }, error = function(ex) {
[16:01:41.061]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:41.061]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:41.061]                 ...future.rng), started = ...future.startTime, 
[16:01:41.061]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:41.061]             version = "1.8"), class = "FutureResult")
[16:01:41.061]     }, finally = {
[16:01:41.061]         if (!identical(...future.workdir, getwd())) 
[16:01:41.061]             setwd(...future.workdir)
[16:01:41.061]         {
[16:01:41.061]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:41.061]                 ...future.oldOptions$nwarnings <- NULL
[16:01:41.061]             }
[16:01:41.061]             base::options(...future.oldOptions)
[16:01:41.061]             if (.Platform$OS.type == "windows") {
[16:01:41.061]                 old_names <- names(...future.oldEnvVars)
[16:01:41.061]                 envs <- base::Sys.getenv()
[16:01:41.061]                 names <- names(envs)
[16:01:41.061]                 common <- intersect(names, old_names)
[16:01:41.061]                 added <- setdiff(names, old_names)
[16:01:41.061]                 removed <- setdiff(old_names, names)
[16:01:41.061]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:41.061]                   envs[common]]
[16:01:41.061]                 NAMES <- toupper(changed)
[16:01:41.061]                 args <- list()
[16:01:41.061]                 for (kk in seq_along(NAMES)) {
[16:01:41.061]                   name <- changed[[kk]]
[16:01:41.061]                   NAME <- NAMES[[kk]]
[16:01:41.061]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.061]                     next
[16:01:41.061]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:41.061]                 }
[16:01:41.061]                 NAMES <- toupper(added)
[16:01:41.061]                 for (kk in seq_along(NAMES)) {
[16:01:41.061]                   name <- added[[kk]]
[16:01:41.061]                   NAME <- NAMES[[kk]]
[16:01:41.061]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.061]                     next
[16:01:41.061]                   args[[name]] <- ""
[16:01:41.061]                 }
[16:01:41.061]                 NAMES <- toupper(removed)
[16:01:41.061]                 for (kk in seq_along(NAMES)) {
[16:01:41.061]                   name <- removed[[kk]]
[16:01:41.061]                   NAME <- NAMES[[kk]]
[16:01:41.061]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.061]                     next
[16:01:41.061]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:41.061]                 }
[16:01:41.061]                 if (length(args) > 0) 
[16:01:41.061]                   base::do.call(base::Sys.setenv, args = args)
[16:01:41.061]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:41.061]             }
[16:01:41.061]             else {
[16:01:41.061]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:41.061]             }
[16:01:41.061]             {
[16:01:41.061]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:41.061]                   0L) {
[16:01:41.061]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:41.061]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:41.061]                   base::options(opts)
[16:01:41.061]                 }
[16:01:41.061]                 {
[16:01:41.061]                   {
[16:01:41.061]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:41.061]                     NULL
[16:01:41.061]                   }
[16:01:41.061]                   options(future.plan = NULL)
[16:01:41.061]                   if (is.na(NA_character_)) 
[16:01:41.061]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:41.061]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:41.061]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:41.061]                     envir = parent.frame()) 
[16:01:41.061]                   {
[16:01:41.061]                     default_workers <- missing(workers)
[16:01:41.061]                     if (is.function(workers)) 
[16:01:41.061]                       workers <- workers()
[16:01:41.061]                     workers <- structure(as.integer(workers), 
[16:01:41.061]                       class = class(workers))
[16:01:41.061]                     stop_if_not(is.finite(workers), workers >= 
[16:01:41.061]                       1L)
[16:01:41.061]                     if ((workers == 1L && !inherits(workers, 
[16:01:41.061]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:41.061]                       if (default_workers) 
[16:01:41.061]                         supportsMulticore(warn = TRUE)
[16:01:41.061]                       return(sequential(..., envir = envir))
[16:01:41.061]                     }
[16:01:41.061]                     oopts <- options(mc.cores = workers)
[16:01:41.061]                     on.exit(options(oopts))
[16:01:41.061]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:41.061]                       envir = envir)
[16:01:41.061]                     if (!future$lazy) 
[16:01:41.061]                       future <- run(future)
[16:01:41.061]                     invisible(future)
[16:01:41.061]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:41.061]                 }
[16:01:41.061]             }
[16:01:41.061]         }
[16:01:41.061]     })
[16:01:41.061]     if (TRUE) {
[16:01:41.061]         base::sink(type = "output", split = FALSE)
[16:01:41.061]         if (TRUE) {
[16:01:41.061]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:41.061]         }
[16:01:41.061]         else {
[16:01:41.061]             ...future.result["stdout"] <- base::list(NULL)
[16:01:41.061]         }
[16:01:41.061]         base::close(...future.stdout)
[16:01:41.061]         ...future.stdout <- NULL
[16:01:41.061]     }
[16:01:41.061]     ...future.result$conditions <- ...future.conditions
[16:01:41.061]     ...future.result$finished <- base::Sys.time()
[16:01:41.061]     ...future.result
[16:01:41.061] }
[16:01:41.064] assign_globals() ...
[16:01:41.064] List of 5
[16:01:41.064]  $ future.call.arguments    : list()
[16:01:41.064]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:41.064]  $ ...future.FUN            :function (x)  
[16:01:41.064]  $ ...future.elements_ii    :List of 3
[16:01:41.064]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[16:01:41.064]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[16:01:41.064]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[16:01:41.064]  $ ...future.seeds_ii       : NULL
[16:01:41.064]  $ ...future.globals.maxSize: num Inf
[16:01:41.064]  - attr(*, "resolved")= logi FALSE
[16:01:41.064]  - attr(*, "total_size")= num NA
[16:01:41.064]  - attr(*, "where")=List of 5
[16:01:41.064]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:41.064]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:41.064]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:41.064]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:41.064]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:41.064]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:41.064]  - attr(*, "already-done")= logi TRUE
[16:01:41.073] - copied ‘future.call.arguments’ to environment
[16:01:41.073] - copied ‘...future.FUN’ to environment
[16:01:41.073] - copied ‘...future.elements_ii’ to environment
[16:01:41.074] - copied ‘...future.seeds_ii’ to environment
[16:01:41.074] - copied ‘...future.globals.maxSize’ to environment
[16:01:41.074] assign_globals() ... done
[16:01:41.074] requestCore(): workers = 2
[16:01:41.076] MulticoreFuture started
[16:01:41.077] - Launch lazy future ... done
[16:01:41.077] run() for ‘MulticoreFuture’ ... done
[16:01:41.077] Created future:
[16:01:41.077] plan(): Setting new future strategy stack:
[16:01:41.078] List of future strategies:
[16:01:41.078] 1. sequential:
[16:01:41.078]    - args: function (..., envir = parent.frame())
[16:01:41.078]    - tweaked: FALSE
[16:01:41.078]    - call: NULL
[16:01:41.078] plan(): nbrOfWorkers() = 1
[16:01:41.080] plan(): Setting new future strategy stack:
[16:01:41.081] List of future strategies:
[16:01:41.081] 1. multicore:
[16:01:41.081]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:41.081]    - tweaked: FALSE
[16:01:41.081]    - call: plan(strategy)
[16:01:41.086] plan(): nbrOfWorkers() = 2
[16:01:41.077] MulticoreFuture:
[16:01:41.077] Label: ‘future_apply-2’
[16:01:41.077] Expression:
[16:01:41.077] {
[16:01:41.077]     do.call(function(...) {
[16:01:41.077]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.077]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:41.077]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.077]             on.exit(options(oopts), add = TRUE)
[16:01:41.077]         }
[16:01:41.077]         {
[16:01:41.077]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:41.077]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.077]                 ...future.FUN(...future.X_jj, ...)
[16:01:41.077]             })
[16:01:41.077]         }
[16:01:41.077]     }, args = future.call.arguments)
[16:01:41.077] }
[16:01:41.077] Lazy evaluation: FALSE
[16:01:41.077] Asynchronous evaluation: TRUE
[16:01:41.077] Local evaluation: TRUE
[16:01:41.077] Environment: R_GlobalEnv
[16:01:41.077] Capture standard output: TRUE
[16:01:41.077] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:41.077] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:41.077] Packages: <none>
[16:01:41.077] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:41.077] Resolved: TRUE
[16:01:41.077] Value: <not collected>
[16:01:41.077] Conditions captured: <none>
[16:01:41.077] Early signaling: FALSE
[16:01:41.077] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:41.077] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:41.087] Chunk #2 of 2 ... DONE
[16:01:41.087] Launching 2 futures (chunks) ... DONE
[16:01:41.087] Resolving 2 futures (chunks) ...
[16:01:41.088] resolve() on list ...
[16:01:41.088]  recursive: 0
[16:01:41.088]  length: 2
[16:01:41.088] 
[16:01:41.088] Future #1
[16:01:41.089] result() for MulticoreFuture ...
[16:01:41.090] result() for MulticoreFuture ...
[16:01:41.090] result() for MulticoreFuture ... done
[16:01:41.090] result() for MulticoreFuture ... done
[16:01:41.090] result() for MulticoreFuture ...
[16:01:41.090] result() for MulticoreFuture ... done
[16:01:41.091] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:01:41.091] - nx: 2
[16:01:41.091] - relay: TRUE
[16:01:41.091] - stdout: TRUE
[16:01:41.091] - signal: TRUE
[16:01:41.092] - resignal: FALSE
[16:01:41.092] - force: TRUE
[16:01:41.092] - relayed: [n=2] FALSE, FALSE
[16:01:41.092] - queued futures: [n=2] FALSE, FALSE
[16:01:41.092]  - until=1
[16:01:41.093]  - relaying element #1
[16:01:41.093] result() for MulticoreFuture ...
[16:01:41.093] result() for MulticoreFuture ... done
[16:01:41.093] result() for MulticoreFuture ...
[16:01:41.094] result() for MulticoreFuture ... done
[16:01:41.094] result() for MulticoreFuture ...
[16:01:41.094] result() for MulticoreFuture ... done
[16:01:41.094] result() for MulticoreFuture ...
[16:01:41.094] result() for MulticoreFuture ... done
[16:01:41.094] - relayed: [n=2] TRUE, FALSE
[16:01:41.095] - queued futures: [n=2] TRUE, FALSE
[16:01:41.095] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:01:41.095]  length: 1 (resolved future 1)
[16:01:41.095] Future #2
[16:01:41.095] result() for MulticoreFuture ...
[16:01:41.096] result() for MulticoreFuture ...
[16:01:41.097] result() for MulticoreFuture ... done
[16:01:41.097] result() for MulticoreFuture ... done
[16:01:41.097] result() for MulticoreFuture ...
[16:01:41.097] result() for MulticoreFuture ... done
[16:01:41.097] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:01:41.098] - nx: 2
[16:01:41.098] - relay: TRUE
[16:01:41.098] - stdout: TRUE
[16:01:41.098] - signal: TRUE
[16:01:41.098] - resignal: FALSE
[16:01:41.099] - force: TRUE
[16:01:41.099] - relayed: [n=2] TRUE, FALSE
[16:01:41.099] - queued futures: [n=2] TRUE, FALSE
[16:01:41.099]  - until=2
[16:01:41.099]  - relaying element #2
[16:01:41.099] result() for MulticoreFuture ...
[16:01:41.099] result() for MulticoreFuture ... done
[16:01:41.100] result() for MulticoreFuture ...
[16:01:41.100] result() for MulticoreFuture ... done
[16:01:41.100] result() for MulticoreFuture ...
[16:01:41.100] result() for MulticoreFuture ... done
[16:01:41.100] result() for MulticoreFuture ...
[16:01:41.100] result() for MulticoreFuture ... done
[16:01:41.100] - relayed: [n=2] TRUE, TRUE
[16:01:41.101] - queued futures: [n=2] TRUE, TRUE
[16:01:41.101] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:01:41.101]  length: 0 (resolved future 2)
[16:01:41.101] Relaying remaining futures
[16:01:41.101] signalConditionsASAP(NULL, pos=0) ...
[16:01:41.101] - nx: 2
[16:01:41.101] - relay: TRUE
[16:01:41.101] - stdout: TRUE
[16:01:41.101] - signal: TRUE
[16:01:41.102] - resignal: FALSE
[16:01:41.102] - force: TRUE
[16:01:41.102] - relayed: [n=2] TRUE, TRUE
[16:01:41.102] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:41.102] - relayed: [n=2] TRUE, TRUE
[16:01:41.102] - queued futures: [n=2] TRUE, TRUE
[16:01:41.102] signalConditionsASAP(NULL, pos=0) ... done
[16:01:41.102] resolve() on list ... DONE
[16:01:41.102] result() for MulticoreFuture ...
[16:01:41.103] result() for MulticoreFuture ... done
[16:01:41.103] result() for MulticoreFuture ...
[16:01:41.103] result() for MulticoreFuture ... done
[16:01:41.105] result() for MulticoreFuture ...
[16:01:41.105] result() for MulticoreFuture ... done
[16:01:41.106] result() for MulticoreFuture ...
[16:01:41.106] result() for MulticoreFuture ... done
[16:01:41.106]  - Number of value chunks collected: 2
[16:01:41.106] Resolving 2 futures (chunks) ... DONE
[16:01:41.106] Reducing values from 2 chunks ...
[16:01:41.107]  - Number of values collected after concatenation: 6
[16:01:41.107]  - Number of values expected: 6
[16:01:41.107] Reducing values from 2 chunks ... DONE
[16:01:41.107] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[16:01:41.108] getGlobalsAndPackagesXApply() ...
[16:01:41.108]  - future.globals: TRUE
[16:01:41.108] getGlobalsAndPackages() ...
[16:01:41.108] Searching for globals...
[16:01:41.110] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[16:01:41.110] Searching for globals ... DONE
[16:01:41.111] Resolving globals: FALSE
[16:01:41.111] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[16:01:41.112] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[16:01:41.112] - globals: [1] ‘FUN’
[16:01:41.112] 
[16:01:41.112] getGlobalsAndPackages() ... DONE
[16:01:41.112]  - globals found/used: [n=1] ‘FUN’
[16:01:41.112]  - needed namespaces: [n=0] 
[16:01:41.112] Finding globals ... DONE
[16:01:41.112]  - use_args: TRUE
[16:01:41.112]  - Getting '...' globals ...
[16:01:41.113] resolve() on list ...
[16:01:41.113]  recursive: 0
[16:01:41.113]  length: 1
[16:01:41.113]  elements: ‘...’
[16:01:41.113]  length: 0 (resolved future 1)
[16:01:41.114] resolve() on list ... DONE
[16:01:41.114]    - '...' content: [n=0] 
[16:01:41.114] List of 1
[16:01:41.114]  $ ...: list()
[16:01:41.114]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:41.114]  - attr(*, "where")=List of 1
[16:01:41.114]   ..$ ...:<environment: 0x55fb64aa9020> 
[16:01:41.114]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:41.114]  - attr(*, "resolved")= logi TRUE
[16:01:41.114]  - attr(*, "total_size")= num NA
[16:01:41.117]  - Getting '...' globals ... DONE
[16:01:41.117] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:41.117] List of 2
[16:01:41.117]  $ ...future.FUN:function (x)  
[16:01:41.117]  $ ...          : list()
[16:01:41.117]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:41.117]  - attr(*, "where")=List of 2
[16:01:41.117]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:41.117]   ..$ ...          :<environment: 0x55fb64aa9020> 
[16:01:41.117]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:41.117]  - attr(*, "resolved")= logi FALSE
[16:01:41.117]  - attr(*, "total_size")= num 1768
[16:01:41.120] Packages to be attached in all futures: [n=0] 
[16:01:41.120] getGlobalsAndPackagesXApply() ... DONE
[16:01:41.124] future_lapply() ...
[16:01:41.128] Number of chunks: 2
[16:01:41.128] getGlobalsAndPackagesXApply() ...
[16:01:41.128]  - future.globals: <name-value list> with names ‘list()’
[16:01:41.129]  - use_args: TRUE
[16:01:41.129] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:01:41.129] List of 2
[16:01:41.129]  $ ...          : list()
[16:01:41.129]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:41.129]  $ ...future.FUN:function (x)  
[16:01:41.129]  - attr(*, "where")=List of 2
[16:01:41.129]   ..$ ...          :<environment: 0x55fb64aa9020> 
[16:01:41.129]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[16:01:41.129]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:41.129]  - attr(*, "resolved")= logi FALSE
[16:01:41.129]  - attr(*, "total_size")= num NA
[16:01:41.132] Packages to be attached in all futures: [n=0] 
[16:01:41.132] getGlobalsAndPackagesXApply() ... DONE
[16:01:41.132] Number of futures (= number of chunks): 2
[16:01:41.132] Launching 2 futures (chunks) ...
[16:01:41.132] Chunk #1 of 2 ...
[16:01:41.132]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:41.133]  - seeds: <none>
[16:01:41.133]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.133] getGlobalsAndPackages() ...
[16:01:41.133] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.133] Resolving globals: FALSE
[16:01:41.133] Tweak future expression to call with '...' arguments ...
[16:01:41.133] {
[16:01:41.133]     do.call(function(...) {
[16:01:41.133]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.133]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:41.133]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.133]             on.exit(options(oopts), add = TRUE)
[16:01:41.133]         }
[16:01:41.133]         {
[16:01:41.133]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:41.133]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.133]                 ...future.FUN(...future.X_jj, ...)
[16:01:41.133]             })
[16:01:41.133]         }
[16:01:41.133]     }, args = future.call.arguments)
[16:01:41.133] }
[16:01:41.134] Tweak future expression to call with '...' arguments ... DONE
[16:01:41.134] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.136] 
[16:01:41.136] getGlobalsAndPackages() ... DONE
[16:01:41.137] run() for ‘Future’ ...
[16:01:41.137] - state: ‘created’
[16:01:41.137] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:41.141] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:41.141] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:41.141]   - Field: ‘label’
[16:01:41.141]   - Field: ‘local’
[16:01:41.141]   - Field: ‘owner’
[16:01:41.142]   - Field: ‘envir’
[16:01:41.142]   - Field: ‘workers’
[16:01:41.142]   - Field: ‘packages’
[16:01:41.142]   - Field: ‘gc’
[16:01:41.142]   - Field: ‘job’
[16:01:41.142]   - Field: ‘conditions’
[16:01:41.142]   - Field: ‘expr’
[16:01:41.142]   - Field: ‘uuid’
[16:01:41.142]   - Field: ‘seed’
[16:01:41.143]   - Field: ‘version’
[16:01:41.143]   - Field: ‘result’
[16:01:41.143]   - Field: ‘asynchronous’
[16:01:41.143]   - Field: ‘calls’
[16:01:41.143]   - Field: ‘globals’
[16:01:41.143]   - Field: ‘stdout’
[16:01:41.143]   - Field: ‘earlySignal’
[16:01:41.143]   - Field: ‘lazy’
[16:01:41.143]   - Field: ‘state’
[16:01:41.143] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:41.144] - Launch lazy future ...
[16:01:41.144] Packages needed by the future expression (n = 0): <none>
[16:01:41.144] Packages needed by future strategies (n = 0): <none>
[16:01:41.144] {
[16:01:41.144]     {
[16:01:41.144]         {
[16:01:41.144]             ...future.startTime <- base::Sys.time()
[16:01:41.144]             {
[16:01:41.144]                 {
[16:01:41.144]                   {
[16:01:41.144]                     {
[16:01:41.144]                       base::local({
[16:01:41.144]                         has_future <- base::requireNamespace("future", 
[16:01:41.144]                           quietly = TRUE)
[16:01:41.144]                         if (has_future) {
[16:01:41.144]                           ns <- base::getNamespace("future")
[16:01:41.144]                           version <- ns[[".package"]][["version"]]
[16:01:41.144]                           if (is.null(version)) 
[16:01:41.144]                             version <- utils::packageVersion("future")
[16:01:41.144]                         }
[16:01:41.144]                         else {
[16:01:41.144]                           version <- NULL
[16:01:41.144]                         }
[16:01:41.144]                         if (!has_future || version < "1.8.0") {
[16:01:41.144]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:41.144]                             "", base::R.version$version.string), 
[16:01:41.144]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:41.144]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:41.144]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:41.144]                               "release", "version")], collapse = " "), 
[16:01:41.144]                             hostname = base::Sys.info()[["nodename"]])
[16:01:41.144]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:41.144]                             info)
[16:01:41.144]                           info <- base::paste(info, collapse = "; ")
[16:01:41.144]                           if (!has_future) {
[16:01:41.144]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:41.144]                               info)
[16:01:41.144]                           }
[16:01:41.144]                           else {
[16:01:41.144]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:41.144]                               info, version)
[16:01:41.144]                           }
[16:01:41.144]                           base::stop(msg)
[16:01:41.144]                         }
[16:01:41.144]                       })
[16:01:41.144]                     }
[16:01:41.144]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:41.144]                     base::options(mc.cores = 1L)
[16:01:41.144]                   }
[16:01:41.144]                   options(future.plan = NULL)
[16:01:41.144]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:41.144]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:41.144]                 }
[16:01:41.144]                 ...future.workdir <- getwd()
[16:01:41.144]             }
[16:01:41.144]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:41.144]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:41.144]         }
[16:01:41.144]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:41.144]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:41.144]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:41.144]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:41.144]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:41.144]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:41.144]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:41.144]             base::names(...future.oldOptions))
[16:01:41.144]     }
[16:01:41.144]     if (FALSE) {
[16:01:41.144]     }
[16:01:41.144]     else {
[16:01:41.144]         if (TRUE) {
[16:01:41.144]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:41.144]                 open = "w")
[16:01:41.144]         }
[16:01:41.144]         else {
[16:01:41.144]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:41.144]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:41.144]         }
[16:01:41.144]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:41.144]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:41.144]             base::sink(type = "output", split = FALSE)
[16:01:41.144]             base::close(...future.stdout)
[16:01:41.144]         }, add = TRUE)
[16:01:41.144]     }
[16:01:41.144]     ...future.frame <- base::sys.nframe()
[16:01:41.144]     ...future.conditions <- base::list()
[16:01:41.144]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:41.144]     if (FALSE) {
[16:01:41.144]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:41.144]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:41.144]     }
[16:01:41.144]     ...future.result <- base::tryCatch({
[16:01:41.144]         base::withCallingHandlers({
[16:01:41.144]             ...future.value <- base::withVisible(base::local({
[16:01:41.144]                 withCallingHandlers({
[16:01:41.144]                   {
[16:01:41.144]                     do.call(function(...) {
[16:01:41.144]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.144]                       if (!identical(...future.globals.maxSize.org, 
[16:01:41.144]                         ...future.globals.maxSize)) {
[16:01:41.144]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.144]                         on.exit(options(oopts), add = TRUE)
[16:01:41.144]                       }
[16:01:41.144]                       {
[16:01:41.144]                         lapply(seq_along(...future.elements_ii), 
[16:01:41.144]                           FUN = function(jj) {
[16:01:41.144]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.144]                             ...future.FUN(...future.X_jj, ...)
[16:01:41.144]                           })
[16:01:41.144]                       }
[16:01:41.144]                     }, args = future.call.arguments)
[16:01:41.144]                   }
[16:01:41.144]                 }, immediateCondition = function(cond) {
[16:01:41.144]                   save_rds <- function (object, pathname, ...) 
[16:01:41.144]                   {
[16:01:41.144]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:41.144]                     if (file_test("-f", pathname_tmp)) {
[16:01:41.144]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.144]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:41.144]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.144]                         fi_tmp[["mtime"]])
[16:01:41.144]                     }
[16:01:41.144]                     tryCatch({
[16:01:41.144]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:41.144]                     }, error = function(ex) {
[16:01:41.144]                       msg <- conditionMessage(ex)
[16:01:41.144]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.144]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:41.144]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.144]                         fi_tmp[["mtime"]], msg)
[16:01:41.144]                       ex$message <- msg
[16:01:41.144]                       stop(ex)
[16:01:41.144]                     })
[16:01:41.144]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:41.144]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:41.144]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:41.144]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.144]                       fi <- file.info(pathname)
[16:01:41.144]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:41.144]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.144]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:41.144]                         fi[["size"]], fi[["mtime"]])
[16:01:41.144]                       stop(msg)
[16:01:41.144]                     }
[16:01:41.144]                     invisible(pathname)
[16:01:41.144]                   }
[16:01:41.144]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:41.144]                     rootPath = tempdir()) 
[16:01:41.144]                   {
[16:01:41.144]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:41.144]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:41.144]                       tmpdir = path, fileext = ".rds")
[16:01:41.144]                     save_rds(obj, file)
[16:01:41.144]                   }
[16:01:41.144]                   saveImmediateCondition(cond, path = "/tmp/RtmplAoKyr/.future/immediateConditions")
[16:01:41.144]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.144]                   {
[16:01:41.144]                     inherits <- base::inherits
[16:01:41.144]                     invokeRestart <- base::invokeRestart
[16:01:41.144]                     is.null <- base::is.null
[16:01:41.144]                     muffled <- FALSE
[16:01:41.144]                     if (inherits(cond, "message")) {
[16:01:41.144]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:41.144]                       if (muffled) 
[16:01:41.144]                         invokeRestart("muffleMessage")
[16:01:41.144]                     }
[16:01:41.144]                     else if (inherits(cond, "warning")) {
[16:01:41.144]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:41.144]                       if (muffled) 
[16:01:41.144]                         invokeRestart("muffleWarning")
[16:01:41.144]                     }
[16:01:41.144]                     else if (inherits(cond, "condition")) {
[16:01:41.144]                       if (!is.null(pattern)) {
[16:01:41.144]                         computeRestarts <- base::computeRestarts
[16:01:41.144]                         grepl <- base::grepl
[16:01:41.144]                         restarts <- computeRestarts(cond)
[16:01:41.144]                         for (restart in restarts) {
[16:01:41.144]                           name <- restart$name
[16:01:41.144]                           if (is.null(name)) 
[16:01:41.144]                             next
[16:01:41.144]                           if (!grepl(pattern, name)) 
[16:01:41.144]                             next
[16:01:41.144]                           invokeRestart(restart)
[16:01:41.144]                           muffled <- TRUE
[16:01:41.144]                           break
[16:01:41.144]                         }
[16:01:41.144]                       }
[16:01:41.144]                     }
[16:01:41.144]                     invisible(muffled)
[16:01:41.144]                   }
[16:01:41.144]                   muffleCondition(cond)
[16:01:41.144]                 })
[16:01:41.144]             }))
[16:01:41.144]             future::FutureResult(value = ...future.value$value, 
[16:01:41.144]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:41.144]                   ...future.rng), globalenv = if (FALSE) 
[16:01:41.144]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:41.144]                     ...future.globalenv.names))
[16:01:41.144]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:41.144]         }, condition = base::local({
[16:01:41.144]             c <- base::c
[16:01:41.144]             inherits <- base::inherits
[16:01:41.144]             invokeRestart <- base::invokeRestart
[16:01:41.144]             length <- base::length
[16:01:41.144]             list <- base::list
[16:01:41.144]             seq.int <- base::seq.int
[16:01:41.144]             signalCondition <- base::signalCondition
[16:01:41.144]             sys.calls <- base::sys.calls
[16:01:41.144]             `[[` <- base::`[[`
[16:01:41.144]             `+` <- base::`+`
[16:01:41.144]             `<<-` <- base::`<<-`
[16:01:41.144]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:41.144]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:41.144]                   3L)]
[16:01:41.144]             }
[16:01:41.144]             function(cond) {
[16:01:41.144]                 is_error <- inherits(cond, "error")
[16:01:41.144]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:41.144]                   NULL)
[16:01:41.144]                 if (is_error) {
[16:01:41.144]                   sessionInformation <- function() {
[16:01:41.144]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:41.144]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:41.144]                       search = base::search(), system = base::Sys.info())
[16:01:41.144]                   }
[16:01:41.144]                   ...future.conditions[[length(...future.conditions) + 
[16:01:41.144]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:41.144]                     cond$call), session = sessionInformation(), 
[16:01:41.144]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:41.144]                   signalCondition(cond)
[16:01:41.144]                 }
[16:01:41.144]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:41.144]                 "immediateCondition"))) {
[16:01:41.144]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:41.144]                   ...future.conditions[[length(...future.conditions) + 
[16:01:41.144]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:41.144]                   if (TRUE && !signal) {
[16:01:41.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.144]                     {
[16:01:41.144]                       inherits <- base::inherits
[16:01:41.144]                       invokeRestart <- base::invokeRestart
[16:01:41.144]                       is.null <- base::is.null
[16:01:41.144]                       muffled <- FALSE
[16:01:41.144]                       if (inherits(cond, "message")) {
[16:01:41.144]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:41.144]                         if (muffled) 
[16:01:41.144]                           invokeRestart("muffleMessage")
[16:01:41.144]                       }
[16:01:41.144]                       else if (inherits(cond, "warning")) {
[16:01:41.144]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:41.144]                         if (muffled) 
[16:01:41.144]                           invokeRestart("muffleWarning")
[16:01:41.144]                       }
[16:01:41.144]                       else if (inherits(cond, "condition")) {
[16:01:41.144]                         if (!is.null(pattern)) {
[16:01:41.144]                           computeRestarts <- base::computeRestarts
[16:01:41.144]                           grepl <- base::grepl
[16:01:41.144]                           restarts <- computeRestarts(cond)
[16:01:41.144]                           for (restart in restarts) {
[16:01:41.144]                             name <- restart$name
[16:01:41.144]                             if (is.null(name)) 
[16:01:41.144]                               next
[16:01:41.144]                             if (!grepl(pattern, name)) 
[16:01:41.144]                               next
[16:01:41.144]                             invokeRestart(restart)
[16:01:41.144]                             muffled <- TRUE
[16:01:41.144]                             break
[16:01:41.144]                           }
[16:01:41.144]                         }
[16:01:41.144]                       }
[16:01:41.144]                       invisible(muffled)
[16:01:41.144]                     }
[16:01:41.144]                     muffleCondition(cond, pattern = "^muffle")
[16:01:41.144]                   }
[16:01:41.144]                 }
[16:01:41.144]                 else {
[16:01:41.144]                   if (TRUE) {
[16:01:41.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.144]                     {
[16:01:41.144]                       inherits <- base::inherits
[16:01:41.144]                       invokeRestart <- base::invokeRestart
[16:01:41.144]                       is.null <- base::is.null
[16:01:41.144]                       muffled <- FALSE
[16:01:41.144]                       if (inherits(cond, "message")) {
[16:01:41.144]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:41.144]                         if (muffled) 
[16:01:41.144]                           invokeRestart("muffleMessage")
[16:01:41.144]                       }
[16:01:41.144]                       else if (inherits(cond, "warning")) {
[16:01:41.144]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:41.144]                         if (muffled) 
[16:01:41.144]                           invokeRestart("muffleWarning")
[16:01:41.144]                       }
[16:01:41.144]                       else if (inherits(cond, "condition")) {
[16:01:41.144]                         if (!is.null(pattern)) {
[16:01:41.144]                           computeRestarts <- base::computeRestarts
[16:01:41.144]                           grepl <- base::grepl
[16:01:41.144]                           restarts <- computeRestarts(cond)
[16:01:41.144]                           for (restart in restarts) {
[16:01:41.144]                             name <- restart$name
[16:01:41.144]                             if (is.null(name)) 
[16:01:41.144]                               next
[16:01:41.144]                             if (!grepl(pattern, name)) 
[16:01:41.144]                               next
[16:01:41.144]                             invokeRestart(restart)
[16:01:41.144]                             muffled <- TRUE
[16:01:41.144]                             break
[16:01:41.144]                           }
[16:01:41.144]                         }
[16:01:41.144]                       }
[16:01:41.144]                       invisible(muffled)
[16:01:41.144]                     }
[16:01:41.144]                     muffleCondition(cond, pattern = "^muffle")
[16:01:41.144]                   }
[16:01:41.144]                 }
[16:01:41.144]             }
[16:01:41.144]         }))
[16:01:41.144]     }, error = function(ex) {
[16:01:41.144]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:41.144]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:41.144]                 ...future.rng), started = ...future.startTime, 
[16:01:41.144]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:41.144]             version = "1.8"), class = "FutureResult")
[16:01:41.144]     }, finally = {
[16:01:41.144]         if (!identical(...future.workdir, getwd())) 
[16:01:41.144]             setwd(...future.workdir)
[16:01:41.144]         {
[16:01:41.144]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:41.144]                 ...future.oldOptions$nwarnings <- NULL
[16:01:41.144]             }
[16:01:41.144]             base::options(...future.oldOptions)
[16:01:41.144]             if (.Platform$OS.type == "windows") {
[16:01:41.144]                 old_names <- names(...future.oldEnvVars)
[16:01:41.144]                 envs <- base::Sys.getenv()
[16:01:41.144]                 names <- names(envs)
[16:01:41.144]                 common <- intersect(names, old_names)
[16:01:41.144]                 added <- setdiff(names, old_names)
[16:01:41.144]                 removed <- setdiff(old_names, names)
[16:01:41.144]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:41.144]                   envs[common]]
[16:01:41.144]                 NAMES <- toupper(changed)
[16:01:41.144]                 args <- list()
[16:01:41.144]                 for (kk in seq_along(NAMES)) {
[16:01:41.144]                   name <- changed[[kk]]
[16:01:41.144]                   NAME <- NAMES[[kk]]
[16:01:41.144]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.144]                     next
[16:01:41.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:41.144]                 }
[16:01:41.144]                 NAMES <- toupper(added)
[16:01:41.144]                 for (kk in seq_along(NAMES)) {
[16:01:41.144]                   name <- added[[kk]]
[16:01:41.144]                   NAME <- NAMES[[kk]]
[16:01:41.144]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.144]                     next
[16:01:41.144]                   args[[name]] <- ""
[16:01:41.144]                 }
[16:01:41.144]                 NAMES <- toupper(removed)
[16:01:41.144]                 for (kk in seq_along(NAMES)) {
[16:01:41.144]                   name <- removed[[kk]]
[16:01:41.144]                   NAME <- NAMES[[kk]]
[16:01:41.144]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.144]                     next
[16:01:41.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:41.144]                 }
[16:01:41.144]                 if (length(args) > 0) 
[16:01:41.144]                   base::do.call(base::Sys.setenv, args = args)
[16:01:41.144]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:41.144]             }
[16:01:41.144]             else {
[16:01:41.144]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:41.144]             }
[16:01:41.144]             {
[16:01:41.144]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:41.144]                   0L) {
[16:01:41.144]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:41.144]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:41.144]                   base::options(opts)
[16:01:41.144]                 }
[16:01:41.144]                 {
[16:01:41.144]                   {
[16:01:41.144]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:41.144]                     NULL
[16:01:41.144]                   }
[16:01:41.144]                   options(future.plan = NULL)
[16:01:41.144]                   if (is.na(NA_character_)) 
[16:01:41.144]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:41.144]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:41.144]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:41.144]                     envir = parent.frame()) 
[16:01:41.144]                   {
[16:01:41.144]                     default_workers <- missing(workers)
[16:01:41.144]                     if (is.function(workers)) 
[16:01:41.144]                       workers <- workers()
[16:01:41.144]                     workers <- structure(as.integer(workers), 
[16:01:41.144]                       class = class(workers))
[16:01:41.144]                     stop_if_not(is.finite(workers), workers >= 
[16:01:41.144]                       1L)
[16:01:41.144]                     if ((workers == 1L && !inherits(workers, 
[16:01:41.144]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:41.144]                       if (default_workers) 
[16:01:41.144]                         supportsMulticore(warn = TRUE)
[16:01:41.144]                       return(sequential(..., envir = envir))
[16:01:41.144]                     }
[16:01:41.144]                     oopts <- options(mc.cores = workers)
[16:01:41.144]                     on.exit(options(oopts))
[16:01:41.144]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:41.144]                       envir = envir)
[16:01:41.144]                     if (!future$lazy) 
[16:01:41.144]                       future <- run(future)
[16:01:41.144]                     invisible(future)
[16:01:41.144]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:41.144]                 }
[16:01:41.144]             }
[16:01:41.144]         }
[16:01:41.144]     })
[16:01:41.144]     if (TRUE) {
[16:01:41.144]         base::sink(type = "output", split = FALSE)
[16:01:41.144]         if (TRUE) {
[16:01:41.144]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:41.144]         }
[16:01:41.144]         else {
[16:01:41.144]             ...future.result["stdout"] <- base::list(NULL)
[16:01:41.144]         }
[16:01:41.144]         base::close(...future.stdout)
[16:01:41.144]         ...future.stdout <- NULL
[16:01:41.144]     }
[16:01:41.144]     ...future.result$conditions <- ...future.conditions
[16:01:41.144]     ...future.result$finished <- base::Sys.time()
[16:01:41.144]     ...future.result
[16:01:41.144] }
[16:01:41.147] assign_globals() ...
[16:01:41.147] List of 5
[16:01:41.147]  $ future.call.arguments    : list()
[16:01:41.147]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:41.147]  $ ...future.FUN            :function (x)  
[16:01:41.147]  $ ...future.elements_ii    :List of 3
[16:01:41.147]   ..$ : int [1:4] 1 7 13 19
[16:01:41.147]   ..$ : int [1:4] 2 8 14 20
[16:01:41.147]   ..$ : int [1:4] 3 9 15 21
[16:01:41.147]  $ ...future.seeds_ii       : NULL
[16:01:41.147]  $ ...future.globals.maxSize: num Inf
[16:01:41.147]  - attr(*, "resolved")= logi FALSE
[16:01:41.147]  - attr(*, "total_size")= num NA
[16:01:41.147]  - attr(*, "where")=List of 5
[16:01:41.147]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:41.147]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:41.147]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:41.147]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:41.147]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:41.147]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:41.147]  - attr(*, "already-done")= logi TRUE
[16:01:41.153] - copied ‘future.call.arguments’ to environment
[16:01:41.153] - reassign environment for ‘...future.FUN’
[16:01:41.153] - copied ‘...future.FUN’ to environment
[16:01:41.153] - copied ‘...future.elements_ii’ to environment
[16:01:41.153] - copied ‘...future.seeds_ii’ to environment
[16:01:41.153] - copied ‘...future.globals.maxSize’ to environment
[16:01:41.153] assign_globals() ... done
[16:01:41.153] requestCore(): workers = 2
[16:01:41.156] MulticoreFuture started
[16:01:41.156] - Launch lazy future ... done
[16:01:41.156] run() for ‘MulticoreFuture’ ... done
[16:01:41.157] Created future:
[16:01:41.157] plan(): Setting new future strategy stack:
[16:01:41.157] List of future strategies:
[16:01:41.157] 1. sequential:
[16:01:41.157]    - args: function (..., envir = parent.frame())
[16:01:41.157]    - tweaked: FALSE
[16:01:41.157]    - call: NULL
[16:01:41.158] plan(): nbrOfWorkers() = 1
[16:01:41.160] plan(): Setting new future strategy stack:
[16:01:41.160] List of future strategies:
[16:01:41.160] 1. multicore:
[16:01:41.160]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:41.160]    - tweaked: FALSE
[16:01:41.160]    - call: plan(strategy)
[16:01:41.166] plan(): nbrOfWorkers() = 2
[16:01:41.157] MulticoreFuture:
[16:01:41.157] Label: ‘future_apply-1’
[16:01:41.157] Expression:
[16:01:41.157] {
[16:01:41.157]     do.call(function(...) {
[16:01:41.157]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.157]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:41.157]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.157]             on.exit(options(oopts), add = TRUE)
[16:01:41.157]         }
[16:01:41.157]         {
[16:01:41.157]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:41.157]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.157]                 ...future.FUN(...future.X_jj, ...)
[16:01:41.157]             })
[16:01:41.157]         }
[16:01:41.157]     }, args = future.call.arguments)
[16:01:41.157] }
[16:01:41.157] Lazy evaluation: FALSE
[16:01:41.157] Asynchronous evaluation: TRUE
[16:01:41.157] Local evaluation: TRUE
[16:01:41.157] Environment: R_GlobalEnv
[16:01:41.157] Capture standard output: TRUE
[16:01:41.157] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:41.157] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:41.157] Packages: <none>
[16:01:41.157] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:41.157] Resolved: TRUE
[16:01:41.157] Value: <not collected>
[16:01:41.157] Conditions captured: <none>
[16:01:41.157] Early signaling: FALSE
[16:01:41.157] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:41.157] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:41.167] Chunk #1 of 2 ... DONE
[16:01:41.168] Chunk #2 of 2 ...
[16:01:41.168]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:41.168]  - seeds: <none>
[16:01:41.168]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.168] getGlobalsAndPackages() ...
[16:01:41.169] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.169] Resolving globals: FALSE
[16:01:41.169] Tweak future expression to call with '...' arguments ...
[16:01:41.169] {
[16:01:41.169]     do.call(function(...) {
[16:01:41.169]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.169]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:41.169]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.169]             on.exit(options(oopts), add = TRUE)
[16:01:41.169]         }
[16:01:41.169]         {
[16:01:41.169]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:41.169]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.169]                 ...future.FUN(...future.X_jj, ...)
[16:01:41.169]             })
[16:01:41.169]         }
[16:01:41.169]     }, args = future.call.arguments)
[16:01:41.169] }
[16:01:41.170] Tweak future expression to call with '...' arguments ... DONE
[16:01:41.170] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.170] 
[16:01:41.171] getGlobalsAndPackages() ... DONE
[16:01:41.171] run() for ‘Future’ ...
[16:01:41.171] - state: ‘created’
[16:01:41.171] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:41.176] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:41.176] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:41.176]   - Field: ‘label’
[16:01:41.177]   - Field: ‘local’
[16:01:41.177]   - Field: ‘owner’
[16:01:41.177]   - Field: ‘envir’
[16:01:41.177]   - Field: ‘workers’
[16:01:41.177]   - Field: ‘packages’
[16:01:41.177]   - Field: ‘gc’
[16:01:41.177]   - Field: ‘job’
[16:01:41.178]   - Field: ‘conditions’
[16:01:41.178]   - Field: ‘expr’
[16:01:41.178]   - Field: ‘uuid’
[16:01:41.178]   - Field: ‘seed’
[16:01:41.178]   - Field: ‘version’
[16:01:41.178]   - Field: ‘result’
[16:01:41.178]   - Field: ‘asynchronous’
[16:01:41.179]   - Field: ‘calls’
[16:01:41.179]   - Field: ‘globals’
[16:01:41.179]   - Field: ‘stdout’
[16:01:41.179]   - Field: ‘earlySignal’
[16:01:41.179]   - Field: ‘lazy’
[16:01:41.179]   - Field: ‘state’
[16:01:41.179] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:41.180] - Launch lazy future ...
[16:01:41.184] Packages needed by the future expression (n = 0): <none>
[16:01:41.184] Packages needed by future strategies (n = 0): <none>
[16:01:41.186] {
[16:01:41.186]     {
[16:01:41.186]         {
[16:01:41.186]             ...future.startTime <- base::Sys.time()
[16:01:41.186]             {
[16:01:41.186]                 {
[16:01:41.186]                   {
[16:01:41.186]                     {
[16:01:41.186]                       base::local({
[16:01:41.186]                         has_future <- base::requireNamespace("future", 
[16:01:41.186]                           quietly = TRUE)
[16:01:41.186]                         if (has_future) {
[16:01:41.186]                           ns <- base::getNamespace("future")
[16:01:41.186]                           version <- ns[[".package"]][["version"]]
[16:01:41.186]                           if (is.null(version)) 
[16:01:41.186]                             version <- utils::packageVersion("future")
[16:01:41.186]                         }
[16:01:41.186]                         else {
[16:01:41.186]                           version <- NULL
[16:01:41.186]                         }
[16:01:41.186]                         if (!has_future || version < "1.8.0") {
[16:01:41.186]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:41.186]                             "", base::R.version$version.string), 
[16:01:41.186]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:41.186]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:41.186]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:41.186]                               "release", "version")], collapse = " "), 
[16:01:41.186]                             hostname = base::Sys.info()[["nodename"]])
[16:01:41.186]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:41.186]                             info)
[16:01:41.186]                           info <- base::paste(info, collapse = "; ")
[16:01:41.186]                           if (!has_future) {
[16:01:41.186]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:41.186]                               info)
[16:01:41.186]                           }
[16:01:41.186]                           else {
[16:01:41.186]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:41.186]                               info, version)
[16:01:41.186]                           }
[16:01:41.186]                           base::stop(msg)
[16:01:41.186]                         }
[16:01:41.186]                       })
[16:01:41.186]                     }
[16:01:41.186]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:41.186]                     base::options(mc.cores = 1L)
[16:01:41.186]                   }
[16:01:41.186]                   options(future.plan = NULL)
[16:01:41.186]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:41.186]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:41.186]                 }
[16:01:41.186]                 ...future.workdir <- getwd()
[16:01:41.186]             }
[16:01:41.186]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:41.186]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:41.186]         }
[16:01:41.186]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:41.186]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:41.186]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:41.186]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:41.186]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:41.186]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:41.186]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:41.186]             base::names(...future.oldOptions))
[16:01:41.186]     }
[16:01:41.186]     if (FALSE) {
[16:01:41.186]     }
[16:01:41.186]     else {
[16:01:41.186]         if (TRUE) {
[16:01:41.186]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:41.186]                 open = "w")
[16:01:41.186]         }
[16:01:41.186]         else {
[16:01:41.186]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:41.186]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:41.186]         }
[16:01:41.186]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:41.186]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:41.186]             base::sink(type = "output", split = FALSE)
[16:01:41.186]             base::close(...future.stdout)
[16:01:41.186]         }, add = TRUE)
[16:01:41.186]     }
[16:01:41.186]     ...future.frame <- base::sys.nframe()
[16:01:41.186]     ...future.conditions <- base::list()
[16:01:41.186]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:41.186]     if (FALSE) {
[16:01:41.186]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:41.186]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:41.186]     }
[16:01:41.186]     ...future.result <- base::tryCatch({
[16:01:41.186]         base::withCallingHandlers({
[16:01:41.186]             ...future.value <- base::withVisible(base::local({
[16:01:41.186]                 withCallingHandlers({
[16:01:41.186]                   {
[16:01:41.186]                     do.call(function(...) {
[16:01:41.186]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.186]                       if (!identical(...future.globals.maxSize.org, 
[16:01:41.186]                         ...future.globals.maxSize)) {
[16:01:41.186]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.186]                         on.exit(options(oopts), add = TRUE)
[16:01:41.186]                       }
[16:01:41.186]                       {
[16:01:41.186]                         lapply(seq_along(...future.elements_ii), 
[16:01:41.186]                           FUN = function(jj) {
[16:01:41.186]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.186]                             ...future.FUN(...future.X_jj, ...)
[16:01:41.186]                           })
[16:01:41.186]                       }
[16:01:41.186]                     }, args = future.call.arguments)
[16:01:41.186]                   }
[16:01:41.186]                 }, immediateCondition = function(cond) {
[16:01:41.186]                   save_rds <- function (object, pathname, ...) 
[16:01:41.186]                   {
[16:01:41.186]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:41.186]                     if (file_test("-f", pathname_tmp)) {
[16:01:41.186]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.186]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:41.186]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.186]                         fi_tmp[["mtime"]])
[16:01:41.186]                     }
[16:01:41.186]                     tryCatch({
[16:01:41.186]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:41.186]                     }, error = function(ex) {
[16:01:41.186]                       msg <- conditionMessage(ex)
[16:01:41.186]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.186]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:41.186]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.186]                         fi_tmp[["mtime"]], msg)
[16:01:41.186]                       ex$message <- msg
[16:01:41.186]                       stop(ex)
[16:01:41.186]                     })
[16:01:41.186]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:41.186]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:41.186]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:41.186]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.186]                       fi <- file.info(pathname)
[16:01:41.186]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:41.186]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.186]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:41.186]                         fi[["size"]], fi[["mtime"]])
[16:01:41.186]                       stop(msg)
[16:01:41.186]                     }
[16:01:41.186]                     invisible(pathname)
[16:01:41.186]                   }
[16:01:41.186]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:41.186]                     rootPath = tempdir()) 
[16:01:41.186]                   {
[16:01:41.186]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:41.186]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:41.186]                       tmpdir = path, fileext = ".rds")
[16:01:41.186]                     save_rds(obj, file)
[16:01:41.186]                   }
[16:01:41.186]                   saveImmediateCondition(cond, path = "/tmp/RtmplAoKyr/.future/immediateConditions")
[16:01:41.186]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.186]                   {
[16:01:41.186]                     inherits <- base::inherits
[16:01:41.186]                     invokeRestart <- base::invokeRestart
[16:01:41.186]                     is.null <- base::is.null
[16:01:41.186]                     muffled <- FALSE
[16:01:41.186]                     if (inherits(cond, "message")) {
[16:01:41.186]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:41.186]                       if (muffled) 
[16:01:41.186]                         invokeRestart("muffleMessage")
[16:01:41.186]                     }
[16:01:41.186]                     else if (inherits(cond, "warning")) {
[16:01:41.186]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:41.186]                       if (muffled) 
[16:01:41.186]                         invokeRestart("muffleWarning")
[16:01:41.186]                     }
[16:01:41.186]                     else if (inherits(cond, "condition")) {
[16:01:41.186]                       if (!is.null(pattern)) {
[16:01:41.186]                         computeRestarts <- base::computeRestarts
[16:01:41.186]                         grepl <- base::grepl
[16:01:41.186]                         restarts <- computeRestarts(cond)
[16:01:41.186]                         for (restart in restarts) {
[16:01:41.186]                           name <- restart$name
[16:01:41.186]                           if (is.null(name)) 
[16:01:41.186]                             next
[16:01:41.186]                           if (!grepl(pattern, name)) 
[16:01:41.186]                             next
[16:01:41.186]                           invokeRestart(restart)
[16:01:41.186]                           muffled <- TRUE
[16:01:41.186]                           break
[16:01:41.186]                         }
[16:01:41.186]                       }
[16:01:41.186]                     }
[16:01:41.186]                     invisible(muffled)
[16:01:41.186]                   }
[16:01:41.186]                   muffleCondition(cond)
[16:01:41.186]                 })
[16:01:41.186]             }))
[16:01:41.186]             future::FutureResult(value = ...future.value$value, 
[16:01:41.186]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:41.186]                   ...future.rng), globalenv = if (FALSE) 
[16:01:41.186]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:41.186]                     ...future.globalenv.names))
[16:01:41.186]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:41.186]         }, condition = base::local({
[16:01:41.186]             c <- base::c
[16:01:41.186]             inherits <- base::inherits
[16:01:41.186]             invokeRestart <- base::invokeRestart
[16:01:41.186]             length <- base::length
[16:01:41.186]             list <- base::list
[16:01:41.186]             seq.int <- base::seq.int
[16:01:41.186]             signalCondition <- base::signalCondition
[16:01:41.186]             sys.calls <- base::sys.calls
[16:01:41.186]             `[[` <- base::`[[`
[16:01:41.186]             `+` <- base::`+`
[16:01:41.186]             `<<-` <- base::`<<-`
[16:01:41.186]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:41.186]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:41.186]                   3L)]
[16:01:41.186]             }
[16:01:41.186]             function(cond) {
[16:01:41.186]                 is_error <- inherits(cond, "error")
[16:01:41.186]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:41.186]                   NULL)
[16:01:41.186]                 if (is_error) {
[16:01:41.186]                   sessionInformation <- function() {
[16:01:41.186]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:41.186]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:41.186]                       search = base::search(), system = base::Sys.info())
[16:01:41.186]                   }
[16:01:41.186]                   ...future.conditions[[length(...future.conditions) + 
[16:01:41.186]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:41.186]                     cond$call), session = sessionInformation(), 
[16:01:41.186]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:41.186]                   signalCondition(cond)
[16:01:41.186]                 }
[16:01:41.186]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:41.186]                 "immediateCondition"))) {
[16:01:41.186]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:41.186]                   ...future.conditions[[length(...future.conditions) + 
[16:01:41.186]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:41.186]                   if (TRUE && !signal) {
[16:01:41.186]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.186]                     {
[16:01:41.186]                       inherits <- base::inherits
[16:01:41.186]                       invokeRestart <- base::invokeRestart
[16:01:41.186]                       is.null <- base::is.null
[16:01:41.186]                       muffled <- FALSE
[16:01:41.186]                       if (inherits(cond, "message")) {
[16:01:41.186]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:41.186]                         if (muffled) 
[16:01:41.186]                           invokeRestart("muffleMessage")
[16:01:41.186]                       }
[16:01:41.186]                       else if (inherits(cond, "warning")) {
[16:01:41.186]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:41.186]                         if (muffled) 
[16:01:41.186]                           invokeRestart("muffleWarning")
[16:01:41.186]                       }
[16:01:41.186]                       else if (inherits(cond, "condition")) {
[16:01:41.186]                         if (!is.null(pattern)) {
[16:01:41.186]                           computeRestarts <- base::computeRestarts
[16:01:41.186]                           grepl <- base::grepl
[16:01:41.186]                           restarts <- computeRestarts(cond)
[16:01:41.186]                           for (restart in restarts) {
[16:01:41.186]                             name <- restart$name
[16:01:41.186]                             if (is.null(name)) 
[16:01:41.186]                               next
[16:01:41.186]                             if (!grepl(pattern, name)) 
[16:01:41.186]                               next
[16:01:41.186]                             invokeRestart(restart)
[16:01:41.186]                             muffled <- TRUE
[16:01:41.186]                             break
[16:01:41.186]                           }
[16:01:41.186]                         }
[16:01:41.186]                       }
[16:01:41.186]                       invisible(muffled)
[16:01:41.186]                     }
[16:01:41.186]                     muffleCondition(cond, pattern = "^muffle")
[16:01:41.186]                   }
[16:01:41.186]                 }
[16:01:41.186]                 else {
[16:01:41.186]                   if (TRUE) {
[16:01:41.186]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.186]                     {
[16:01:41.186]                       inherits <- base::inherits
[16:01:41.186]                       invokeRestart <- base::invokeRestart
[16:01:41.186]                       is.null <- base::is.null
[16:01:41.186]                       muffled <- FALSE
[16:01:41.186]                       if (inherits(cond, "message")) {
[16:01:41.186]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:41.186]                         if (muffled) 
[16:01:41.186]                           invokeRestart("muffleMessage")
[16:01:41.186]                       }
[16:01:41.186]                       else if (inherits(cond, "warning")) {
[16:01:41.186]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:41.186]                         if (muffled) 
[16:01:41.186]                           invokeRestart("muffleWarning")
[16:01:41.186]                       }
[16:01:41.186]                       else if (inherits(cond, "condition")) {
[16:01:41.186]                         if (!is.null(pattern)) {
[16:01:41.186]                           computeRestarts <- base::computeRestarts
[16:01:41.186]                           grepl <- base::grepl
[16:01:41.186]                           restarts <- computeRestarts(cond)
[16:01:41.186]                           for (restart in restarts) {
[16:01:41.186]                             name <- restart$name
[16:01:41.186]                             if (is.null(name)) 
[16:01:41.186]                               next
[16:01:41.186]                             if (!grepl(pattern, name)) 
[16:01:41.186]                               next
[16:01:41.186]                             invokeRestart(restart)
[16:01:41.186]                             muffled <- TRUE
[16:01:41.186]                             break
[16:01:41.186]                           }
[16:01:41.186]                         }
[16:01:41.186]                       }
[16:01:41.186]                       invisible(muffled)
[16:01:41.186]                     }
[16:01:41.186]                     muffleCondition(cond, pattern = "^muffle")
[16:01:41.186]                   }
[16:01:41.186]                 }
[16:01:41.186]             }
[16:01:41.186]         }))
[16:01:41.186]     }, error = function(ex) {
[16:01:41.186]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:41.186]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:41.186]                 ...future.rng), started = ...future.startTime, 
[16:01:41.186]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:41.186]             version = "1.8"), class = "FutureResult")
[16:01:41.186]     }, finally = {
[16:01:41.186]         if (!identical(...future.workdir, getwd())) 
[16:01:41.186]             setwd(...future.workdir)
[16:01:41.186]         {
[16:01:41.186]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:41.186]                 ...future.oldOptions$nwarnings <- NULL
[16:01:41.186]             }
[16:01:41.186]             base::options(...future.oldOptions)
[16:01:41.186]             if (.Platform$OS.type == "windows") {
[16:01:41.186]                 old_names <- names(...future.oldEnvVars)
[16:01:41.186]                 envs <- base::Sys.getenv()
[16:01:41.186]                 names <- names(envs)
[16:01:41.186]                 common <- intersect(names, old_names)
[16:01:41.186]                 added <- setdiff(names, old_names)
[16:01:41.186]                 removed <- setdiff(old_names, names)
[16:01:41.186]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:41.186]                   envs[common]]
[16:01:41.186]                 NAMES <- toupper(changed)
[16:01:41.186]                 args <- list()
[16:01:41.186]                 for (kk in seq_along(NAMES)) {
[16:01:41.186]                   name <- changed[[kk]]
[16:01:41.186]                   NAME <- NAMES[[kk]]
[16:01:41.186]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.186]                     next
[16:01:41.186]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:41.186]                 }
[16:01:41.186]                 NAMES <- toupper(added)
[16:01:41.186]                 for (kk in seq_along(NAMES)) {
[16:01:41.186]                   name <- added[[kk]]
[16:01:41.186]                   NAME <- NAMES[[kk]]
[16:01:41.186]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.186]                     next
[16:01:41.186]                   args[[name]] <- ""
[16:01:41.186]                 }
[16:01:41.186]                 NAMES <- toupper(removed)
[16:01:41.186]                 for (kk in seq_along(NAMES)) {
[16:01:41.186]                   name <- removed[[kk]]
[16:01:41.186]                   NAME <- NAMES[[kk]]
[16:01:41.186]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.186]                     next
[16:01:41.186]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:41.186]                 }
[16:01:41.186]                 if (length(args) > 0) 
[16:01:41.186]                   base::do.call(base::Sys.setenv, args = args)
[16:01:41.186]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:41.186]             }
[16:01:41.186]             else {
[16:01:41.186]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:41.186]             }
[16:01:41.186]             {
[16:01:41.186]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:41.186]                   0L) {
[16:01:41.186]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:41.186]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:41.186]                   base::options(opts)
[16:01:41.186]                 }
[16:01:41.186]                 {
[16:01:41.186]                   {
[16:01:41.186]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:41.186]                     NULL
[16:01:41.186]                   }
[16:01:41.186]                   options(future.plan = NULL)
[16:01:41.186]                   if (is.na(NA_character_)) 
[16:01:41.186]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:41.186]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:41.186]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:41.186]                     envir = parent.frame()) 
[16:01:41.186]                   {
[16:01:41.186]                     default_workers <- missing(workers)
[16:01:41.186]                     if (is.function(workers)) 
[16:01:41.186]                       workers <- workers()
[16:01:41.186]                     workers <- structure(as.integer(workers), 
[16:01:41.186]                       class = class(workers))
[16:01:41.186]                     stop_if_not(is.finite(workers), workers >= 
[16:01:41.186]                       1L)
[16:01:41.186]                     if ((workers == 1L && !inherits(workers, 
[16:01:41.186]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:41.186]                       if (default_workers) 
[16:01:41.186]                         supportsMulticore(warn = TRUE)
[16:01:41.186]                       return(sequential(..., envir = envir))
[16:01:41.186]                     }
[16:01:41.186]                     oopts <- options(mc.cores = workers)
[16:01:41.186]                     on.exit(options(oopts))
[16:01:41.186]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:41.186]                       envir = envir)
[16:01:41.186]                     if (!future$lazy) 
[16:01:41.186]                       future <- run(future)
[16:01:41.186]                     invisible(future)
[16:01:41.186]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:41.186]                 }
[16:01:41.186]             }
[16:01:41.186]         }
[16:01:41.186]     })
[16:01:41.186]     if (TRUE) {
[16:01:41.186]         base::sink(type = "output", split = FALSE)
[16:01:41.186]         if (TRUE) {
[16:01:41.186]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:41.186]         }
[16:01:41.186]         else {
[16:01:41.186]             ...future.result["stdout"] <- base::list(NULL)
[16:01:41.186]         }
[16:01:41.186]         base::close(...future.stdout)
[16:01:41.186]         ...future.stdout <- NULL
[16:01:41.186]     }
[16:01:41.186]     ...future.result$conditions <- ...future.conditions
[16:01:41.186]     ...future.result$finished <- base::Sys.time()
[16:01:41.186]     ...future.result
[16:01:41.186] }
[16:01:41.189] assign_globals() ...
[16:01:41.189] List of 5
[16:01:41.189]  $ future.call.arguments    : list()
[16:01:41.189]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:41.189]  $ ...future.FUN            :function (x)  
[16:01:41.189]  $ ...future.elements_ii    :List of 3
[16:01:41.189]   ..$ : int [1:4] 4 10 16 22
[16:01:41.189]   ..$ : int [1:4] 5 11 17 23
[16:01:41.189]   ..$ : int [1:4] 6 12 18 24
[16:01:41.189]  $ ...future.seeds_ii       : NULL
[16:01:41.189]  $ ...future.globals.maxSize: num Inf
[16:01:41.189]  - attr(*, "resolved")= logi FALSE
[16:01:41.189]  - attr(*, "total_size")= num NA
[16:01:41.189]  - attr(*, "where")=List of 5
[16:01:41.189]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:41.189]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:41.189]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:41.189]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:41.189]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:41.189]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:41.189]  - attr(*, "already-done")= logi TRUE
[16:01:41.200] - copied ‘future.call.arguments’ to environment
[16:01:41.200] - reassign environment for ‘...future.FUN’
[16:01:41.200] - copied ‘...future.FUN’ to environment
[16:01:41.200] - copied ‘...future.elements_ii’ to environment
[16:01:41.200] - copied ‘...future.seeds_ii’ to environment
[16:01:41.200] - copied ‘...future.globals.maxSize’ to environment
[16:01:41.200] assign_globals() ... done
[16:01:41.201] requestCore(): workers = 2
[16:01:41.203] MulticoreFuture started
[16:01:41.203] - Launch lazy future ... done
[16:01:41.204] run() for ‘MulticoreFuture’ ... done
[16:01:41.204] Created future:
[16:01:41.204] plan(): Setting new future strategy stack:
[16:01:41.204] List of future strategies:
[16:01:41.204] 1. sequential:
[16:01:41.204]    - args: function (..., envir = parent.frame())
[16:01:41.204]    - tweaked: FALSE
[16:01:41.204]    - call: NULL
[16:01:41.205] plan(): nbrOfWorkers() = 1
[16:01:41.207] plan(): Setting new future strategy stack:
[16:01:41.207] List of future strategies:
[16:01:41.207] 1. multicore:
[16:01:41.207]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:41.207]    - tweaked: FALSE
[16:01:41.207]    - call: plan(strategy)
[16:01:41.213] plan(): nbrOfWorkers() = 2
[16:01:41.204] MulticoreFuture:
[16:01:41.204] Label: ‘future_apply-2’
[16:01:41.204] Expression:
[16:01:41.204] {
[16:01:41.204]     do.call(function(...) {
[16:01:41.204]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.204]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:41.204]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.204]             on.exit(options(oopts), add = TRUE)
[16:01:41.204]         }
[16:01:41.204]         {
[16:01:41.204]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:41.204]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.204]                 ...future.FUN(...future.X_jj, ...)
[16:01:41.204]             })
[16:01:41.204]         }
[16:01:41.204]     }, args = future.call.arguments)
[16:01:41.204] }
[16:01:41.204] Lazy evaluation: FALSE
[16:01:41.204] Asynchronous evaluation: TRUE
[16:01:41.204] Local evaluation: TRUE
[16:01:41.204] Environment: R_GlobalEnv
[16:01:41.204] Capture standard output: TRUE
[16:01:41.204] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:41.204] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:41.204] Packages: <none>
[16:01:41.204] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:41.204] Resolved: TRUE
[16:01:41.204] Value: <not collected>
[16:01:41.204] Conditions captured: <none>
[16:01:41.204] Early signaling: FALSE
[16:01:41.204] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:41.204] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:41.214] Chunk #2 of 2 ... DONE
[16:01:41.214] Launching 2 futures (chunks) ... DONE
[16:01:41.214] Resolving 2 futures (chunks) ...
[16:01:41.214] resolve() on list ...
[16:01:41.215]  recursive: 0
[16:01:41.215]  length: 2
[16:01:41.215] 
[16:01:41.215] Future #1
[16:01:41.215] result() for MulticoreFuture ...
[16:01:41.216] result() for MulticoreFuture ...
[16:01:41.216] result() for MulticoreFuture ... done
[16:01:41.217] result() for MulticoreFuture ... done
[16:01:41.217] result() for MulticoreFuture ...
[16:01:41.217] result() for MulticoreFuture ... done
[16:01:41.217] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:01:41.217] - nx: 2
[16:01:41.217] - relay: TRUE
[16:01:41.218] - stdout: TRUE
[16:01:41.218] - signal: TRUE
[16:01:41.218] - resignal: FALSE
[16:01:41.218] - force: TRUE
[16:01:41.218] - relayed: [n=2] FALSE, FALSE
[16:01:41.218] - queued futures: [n=2] FALSE, FALSE
[16:01:41.218]  - until=1
[16:01:41.219]  - relaying element #1
[16:01:41.219] result() for MulticoreFuture ...
[16:01:41.219] result() for MulticoreFuture ... done
[16:01:41.219] result() for MulticoreFuture ...
[16:01:41.219] result() for MulticoreFuture ... done
[16:01:41.220] result() for MulticoreFuture ...
[16:01:41.220] result() for MulticoreFuture ... done
[16:01:41.220] result() for MulticoreFuture ...
[16:01:41.220] result() for MulticoreFuture ... done
[16:01:41.220] - relayed: [n=2] TRUE, FALSE
[16:01:41.220] - queued futures: [n=2] TRUE, FALSE
[16:01:41.220] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:01:41.221]  length: 1 (resolved future 1)
[16:01:41.221] Future #2
[16:01:41.221] result() for MulticoreFuture ...
[16:01:41.222] result() for MulticoreFuture ...
[16:01:41.222] result() for MulticoreFuture ... done
[16:01:41.222] result() for MulticoreFuture ... done
[16:01:41.222] result() for MulticoreFuture ...
[16:01:41.223] result() for MulticoreFuture ... done
[16:01:41.223] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:01:41.223] - nx: 2
[16:01:41.223] - relay: TRUE
[16:01:41.223] - stdout: TRUE
[16:01:41.223] - signal: TRUE
[16:01:41.223] - resignal: FALSE
[16:01:41.223] - force: TRUE
[16:01:41.224] - relayed: [n=2] TRUE, FALSE
[16:01:41.224] - queued futures: [n=2] TRUE, FALSE
[16:01:41.224]  - until=2
[16:01:41.224]  - relaying element #2
[16:01:41.224] result() for MulticoreFuture ...
[16:01:41.224] result() for MulticoreFuture ... done
[16:01:41.224] result() for MulticoreFuture ...
[16:01:41.224] result() for MulticoreFuture ... done
[16:01:41.225] result() for MulticoreFuture ...
[16:01:41.225] result() for MulticoreFuture ... done
[16:01:41.225] result() for MulticoreFuture ...
[16:01:41.225] result() for MulticoreFuture ... done
[16:01:41.225] - relayed: [n=2] TRUE, TRUE
[16:01:41.225] - queued futures: [n=2] TRUE, TRUE
[16:01:41.225] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:01:41.225]  length: 0 (resolved future 2)
[16:01:41.225] Relaying remaining futures
[16:01:41.226] signalConditionsASAP(NULL, pos=0) ...
[16:01:41.226] - nx: 2
[16:01:41.226] - relay: TRUE
[16:01:41.226] - stdout: TRUE
[16:01:41.226] - signal: TRUE
[16:01:41.226] - resignal: FALSE
[16:01:41.226] - force: TRUE
[16:01:41.226] - relayed: [n=2] TRUE, TRUE
[16:01:41.226] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:41.227] - relayed: [n=2] TRUE, TRUE
[16:01:41.227] - queued futures: [n=2] TRUE, TRUE
[16:01:41.227] signalConditionsASAP(NULL, pos=0) ... done
[16:01:41.227] resolve() on list ... DONE
[16:01:41.227] result() for MulticoreFuture ...
[16:01:41.227] result() for MulticoreFuture ... done
[16:01:41.227] result() for MulticoreFuture ...
[16:01:41.227] result() for MulticoreFuture ... done
[16:01:41.228] result() for MulticoreFuture ...
[16:01:41.228] result() for MulticoreFuture ... done
[16:01:41.228] result() for MulticoreFuture ...
[16:01:41.228] result() for MulticoreFuture ... done
[16:01:41.228]  - Number of value chunks collected: 2
[16:01:41.228] Resolving 2 futures (chunks) ... DONE
[16:01:41.228] Reducing values from 2 chunks ...
[16:01:41.228]  - Number of values collected after concatenation: 6
[16:01:41.228]  - Number of values expected: 6
[16:01:41.229] Reducing values from 2 chunks ... DONE
[16:01:41.229] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[16:01:41.232] getGlobalsAndPackagesXApply() ...
[16:01:41.232]  - future.globals: TRUE
[16:01:41.232] getGlobalsAndPackages() ...
[16:01:41.232] Searching for globals...
[16:01:41.234] - globals found: [1] ‘FUN’
[16:01:41.234] Searching for globals ... DONE
[16:01:41.234] Resolving globals: FALSE
[16:01:41.235] The total size of the 1 globals is 848 bytes (848 bytes)
[16:01:41.235] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:01:41.236] - globals: [1] ‘FUN’
[16:01:41.236] 
[16:01:41.236] getGlobalsAndPackages() ... DONE
[16:01:41.236]  - globals found/used: [n=1] ‘FUN’
[16:01:41.236]  - needed namespaces: [n=0] 
[16:01:41.236] Finding globals ... DONE
[16:01:41.237]  - use_args: TRUE
[16:01:41.237]  - Getting '...' globals ...
[16:01:41.237] resolve() on list ...
[16:01:41.237]  recursive: 0
[16:01:41.237]  length: 1
[16:01:41.237]  elements: ‘...’
[16:01:41.238]  length: 0 (resolved future 1)
[16:01:41.238] resolve() on list ... DONE
[16:01:41.238]    - '...' content: [n=0] 
[16:01:41.238] List of 1
[16:01:41.238]  $ ...: list()
[16:01:41.238]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:41.238]  - attr(*, "where")=List of 1
[16:01:41.238]   ..$ ...:<environment: 0x55fb6251ba78> 
[16:01:41.238]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:41.238]  - attr(*, "resolved")= logi TRUE
[16:01:41.238]  - attr(*, "total_size")= num NA
[16:01:41.241]  - Getting '...' globals ... DONE
[16:01:41.241] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:41.242] List of 2
[16:01:41.242]  $ ...future.FUN:function (x)  
[16:01:41.242]  $ ...          : list()
[16:01:41.242]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:41.242]  - attr(*, "where")=List of 2
[16:01:41.242]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:41.242]   ..$ ...          :<environment: 0x55fb6251ba78> 
[16:01:41.242]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:41.242]  - attr(*, "resolved")= logi FALSE
[16:01:41.242]  - attr(*, "total_size")= num 848
[16:01:41.244] Packages to be attached in all futures: [n=0] 
[16:01:41.244] getGlobalsAndPackagesXApply() ... DONE
[16:01:41.248] future_lapply() ...
[16:01:41.252] Number of chunks: 2
[16:01:41.253] getGlobalsAndPackagesXApply() ...
[16:01:41.253]  - future.globals: <name-value list> with names ‘list()’
[16:01:41.253]  - use_args: TRUE
[16:01:41.253] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:01:41.253] List of 2
[16:01:41.253]  $ ...          : list()
[16:01:41.253]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:41.253]  $ ...future.FUN:function (x)  
[16:01:41.253]  - attr(*, "where")=List of 2
[16:01:41.253]   ..$ ...          :<environment: 0x55fb6251ba78> 
[16:01:41.253]   ..$ ...future.FUN:<environment: namespace:base> 
[16:01:41.253]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:41.253]  - attr(*, "resolved")= logi FALSE
[16:01:41.253]  - attr(*, "total_size")= num NA
[16:01:41.257] Packages to be attached in all futures: [n=0] 
[16:01:41.257] getGlobalsAndPackagesXApply() ... DONE
[16:01:41.257] Number of futures (= number of chunks): 2
[16:01:41.257] Launching 2 futures (chunks) ...
[16:01:41.257] Chunk #1 of 2 ...
[16:01:41.258]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:41.258]  - seeds: <none>
[16:01:41.258]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.258] getGlobalsAndPackages() ...
[16:01:41.258] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.258] Resolving globals: FALSE
[16:01:41.258] Tweak future expression to call with '...' arguments ...
[16:01:41.258] {
[16:01:41.258]     do.call(function(...) {
[16:01:41.258]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.258]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:41.258]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.258]             on.exit(options(oopts), add = TRUE)
[16:01:41.258]         }
[16:01:41.258]         {
[16:01:41.258]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:41.258]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.258]                 ...future.FUN(...future.X_jj, ...)
[16:01:41.258]             })
[16:01:41.258]         }
[16:01:41.258]     }, args = future.call.arguments)
[16:01:41.258] }
[16:01:41.259] Tweak future expression to call with '...' arguments ... DONE
[16:01:41.259] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.259] 
[16:01:41.259] getGlobalsAndPackages() ... DONE
[16:01:41.260] run() for ‘Future’ ...
[16:01:41.260] - state: ‘created’
[16:01:41.260] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:41.265] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:41.266] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:41.266]   - Field: ‘label’
[16:01:41.266]   - Field: ‘local’
[16:01:41.266]   - Field: ‘owner’
[16:01:41.266]   - Field: ‘envir’
[16:01:41.266]   - Field: ‘workers’
[16:01:41.266]   - Field: ‘packages’
[16:01:41.266]   - Field: ‘gc’
[16:01:41.267]   - Field: ‘job’
[16:01:41.267]   - Field: ‘conditions’
[16:01:41.267]   - Field: ‘expr’
[16:01:41.267]   - Field: ‘uuid’
[16:01:41.267]   - Field: ‘seed’
[16:01:41.267]   - Field: ‘version’
[16:01:41.267]   - Field: ‘result’
[16:01:41.267]   - Field: ‘asynchronous’
[16:01:41.268]   - Field: ‘calls’
[16:01:41.268]   - Field: ‘globals’
[16:01:41.268]   - Field: ‘stdout’
[16:01:41.268]   - Field: ‘earlySignal’
[16:01:41.268]   - Field: ‘lazy’
[16:01:41.268]   - Field: ‘state’
[16:01:41.268] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:41.268] - Launch lazy future ...
[16:01:41.269] Packages needed by the future expression (n = 0): <none>
[16:01:41.269] Packages needed by future strategies (n = 0): <none>
[16:01:41.269] {
[16:01:41.269]     {
[16:01:41.269]         {
[16:01:41.269]             ...future.startTime <- base::Sys.time()
[16:01:41.269]             {
[16:01:41.269]                 {
[16:01:41.269]                   {
[16:01:41.269]                     {
[16:01:41.269]                       base::local({
[16:01:41.269]                         has_future <- base::requireNamespace("future", 
[16:01:41.269]                           quietly = TRUE)
[16:01:41.269]                         if (has_future) {
[16:01:41.269]                           ns <- base::getNamespace("future")
[16:01:41.269]                           version <- ns[[".package"]][["version"]]
[16:01:41.269]                           if (is.null(version)) 
[16:01:41.269]                             version <- utils::packageVersion("future")
[16:01:41.269]                         }
[16:01:41.269]                         else {
[16:01:41.269]                           version <- NULL
[16:01:41.269]                         }
[16:01:41.269]                         if (!has_future || version < "1.8.0") {
[16:01:41.269]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:41.269]                             "", base::R.version$version.string), 
[16:01:41.269]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:41.269]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:41.269]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:41.269]                               "release", "version")], collapse = " "), 
[16:01:41.269]                             hostname = base::Sys.info()[["nodename"]])
[16:01:41.269]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:41.269]                             info)
[16:01:41.269]                           info <- base::paste(info, collapse = "; ")
[16:01:41.269]                           if (!has_future) {
[16:01:41.269]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:41.269]                               info)
[16:01:41.269]                           }
[16:01:41.269]                           else {
[16:01:41.269]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:41.269]                               info, version)
[16:01:41.269]                           }
[16:01:41.269]                           base::stop(msg)
[16:01:41.269]                         }
[16:01:41.269]                       })
[16:01:41.269]                     }
[16:01:41.269]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:41.269]                     base::options(mc.cores = 1L)
[16:01:41.269]                   }
[16:01:41.269]                   options(future.plan = NULL)
[16:01:41.269]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:41.269]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:41.269]                 }
[16:01:41.269]                 ...future.workdir <- getwd()
[16:01:41.269]             }
[16:01:41.269]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:41.269]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:41.269]         }
[16:01:41.269]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:41.269]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:41.269]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:41.269]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:41.269]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:41.269]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:41.269]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:41.269]             base::names(...future.oldOptions))
[16:01:41.269]     }
[16:01:41.269]     if (FALSE) {
[16:01:41.269]     }
[16:01:41.269]     else {
[16:01:41.269]         if (TRUE) {
[16:01:41.269]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:41.269]                 open = "w")
[16:01:41.269]         }
[16:01:41.269]         else {
[16:01:41.269]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:41.269]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:41.269]         }
[16:01:41.269]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:41.269]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:41.269]             base::sink(type = "output", split = FALSE)
[16:01:41.269]             base::close(...future.stdout)
[16:01:41.269]         }, add = TRUE)
[16:01:41.269]     }
[16:01:41.269]     ...future.frame <- base::sys.nframe()
[16:01:41.269]     ...future.conditions <- base::list()
[16:01:41.269]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:41.269]     if (FALSE) {
[16:01:41.269]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:41.269]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:41.269]     }
[16:01:41.269]     ...future.result <- base::tryCatch({
[16:01:41.269]         base::withCallingHandlers({
[16:01:41.269]             ...future.value <- base::withVisible(base::local({
[16:01:41.269]                 withCallingHandlers({
[16:01:41.269]                   {
[16:01:41.269]                     do.call(function(...) {
[16:01:41.269]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.269]                       if (!identical(...future.globals.maxSize.org, 
[16:01:41.269]                         ...future.globals.maxSize)) {
[16:01:41.269]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.269]                         on.exit(options(oopts), add = TRUE)
[16:01:41.269]                       }
[16:01:41.269]                       {
[16:01:41.269]                         lapply(seq_along(...future.elements_ii), 
[16:01:41.269]                           FUN = function(jj) {
[16:01:41.269]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.269]                             ...future.FUN(...future.X_jj, ...)
[16:01:41.269]                           })
[16:01:41.269]                       }
[16:01:41.269]                     }, args = future.call.arguments)
[16:01:41.269]                   }
[16:01:41.269]                 }, immediateCondition = function(cond) {
[16:01:41.269]                   save_rds <- function (object, pathname, ...) 
[16:01:41.269]                   {
[16:01:41.269]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:41.269]                     if (file_test("-f", pathname_tmp)) {
[16:01:41.269]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.269]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:41.269]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.269]                         fi_tmp[["mtime"]])
[16:01:41.269]                     }
[16:01:41.269]                     tryCatch({
[16:01:41.269]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:41.269]                     }, error = function(ex) {
[16:01:41.269]                       msg <- conditionMessage(ex)
[16:01:41.269]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.269]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:41.269]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.269]                         fi_tmp[["mtime"]], msg)
[16:01:41.269]                       ex$message <- msg
[16:01:41.269]                       stop(ex)
[16:01:41.269]                     })
[16:01:41.269]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:41.269]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:41.269]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:41.269]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.269]                       fi <- file.info(pathname)
[16:01:41.269]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:41.269]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.269]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:41.269]                         fi[["size"]], fi[["mtime"]])
[16:01:41.269]                       stop(msg)
[16:01:41.269]                     }
[16:01:41.269]                     invisible(pathname)
[16:01:41.269]                   }
[16:01:41.269]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:41.269]                     rootPath = tempdir()) 
[16:01:41.269]                   {
[16:01:41.269]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:41.269]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:41.269]                       tmpdir = path, fileext = ".rds")
[16:01:41.269]                     save_rds(obj, file)
[16:01:41.269]                   }
[16:01:41.269]                   saveImmediateCondition(cond, path = "/tmp/RtmplAoKyr/.future/immediateConditions")
[16:01:41.269]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.269]                   {
[16:01:41.269]                     inherits <- base::inherits
[16:01:41.269]                     invokeRestart <- base::invokeRestart
[16:01:41.269]                     is.null <- base::is.null
[16:01:41.269]                     muffled <- FALSE
[16:01:41.269]                     if (inherits(cond, "message")) {
[16:01:41.269]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:41.269]                       if (muffled) 
[16:01:41.269]                         invokeRestart("muffleMessage")
[16:01:41.269]                     }
[16:01:41.269]                     else if (inherits(cond, "warning")) {
[16:01:41.269]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:41.269]                       if (muffled) 
[16:01:41.269]                         invokeRestart("muffleWarning")
[16:01:41.269]                     }
[16:01:41.269]                     else if (inherits(cond, "condition")) {
[16:01:41.269]                       if (!is.null(pattern)) {
[16:01:41.269]                         computeRestarts <- base::computeRestarts
[16:01:41.269]                         grepl <- base::grepl
[16:01:41.269]                         restarts <- computeRestarts(cond)
[16:01:41.269]                         for (restart in restarts) {
[16:01:41.269]                           name <- restart$name
[16:01:41.269]                           if (is.null(name)) 
[16:01:41.269]                             next
[16:01:41.269]                           if (!grepl(pattern, name)) 
[16:01:41.269]                             next
[16:01:41.269]                           invokeRestart(restart)
[16:01:41.269]                           muffled <- TRUE
[16:01:41.269]                           break
[16:01:41.269]                         }
[16:01:41.269]                       }
[16:01:41.269]                     }
[16:01:41.269]                     invisible(muffled)
[16:01:41.269]                   }
[16:01:41.269]                   muffleCondition(cond)
[16:01:41.269]                 })
[16:01:41.269]             }))
[16:01:41.269]             future::FutureResult(value = ...future.value$value, 
[16:01:41.269]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:41.269]                   ...future.rng), globalenv = if (FALSE) 
[16:01:41.269]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:41.269]                     ...future.globalenv.names))
[16:01:41.269]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:41.269]         }, condition = base::local({
[16:01:41.269]             c <- base::c
[16:01:41.269]             inherits <- base::inherits
[16:01:41.269]             invokeRestart <- base::invokeRestart
[16:01:41.269]             length <- base::length
[16:01:41.269]             list <- base::list
[16:01:41.269]             seq.int <- base::seq.int
[16:01:41.269]             signalCondition <- base::signalCondition
[16:01:41.269]             sys.calls <- base::sys.calls
[16:01:41.269]             `[[` <- base::`[[`
[16:01:41.269]             `+` <- base::`+`
[16:01:41.269]             `<<-` <- base::`<<-`
[16:01:41.269]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:41.269]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:41.269]                   3L)]
[16:01:41.269]             }
[16:01:41.269]             function(cond) {
[16:01:41.269]                 is_error <- inherits(cond, "error")
[16:01:41.269]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:41.269]                   NULL)
[16:01:41.269]                 if (is_error) {
[16:01:41.269]                   sessionInformation <- function() {
[16:01:41.269]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:41.269]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:41.269]                       search = base::search(), system = base::Sys.info())
[16:01:41.269]                   }
[16:01:41.269]                   ...future.conditions[[length(...future.conditions) + 
[16:01:41.269]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:41.269]                     cond$call), session = sessionInformation(), 
[16:01:41.269]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:41.269]                   signalCondition(cond)
[16:01:41.269]                 }
[16:01:41.269]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:41.269]                 "immediateCondition"))) {
[16:01:41.269]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:41.269]                   ...future.conditions[[length(...future.conditions) + 
[16:01:41.269]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:41.269]                   if (TRUE && !signal) {
[16:01:41.269]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.269]                     {
[16:01:41.269]                       inherits <- base::inherits
[16:01:41.269]                       invokeRestart <- base::invokeRestart
[16:01:41.269]                       is.null <- base::is.null
[16:01:41.269]                       muffled <- FALSE
[16:01:41.269]                       if (inherits(cond, "message")) {
[16:01:41.269]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:41.269]                         if (muffled) 
[16:01:41.269]                           invokeRestart("muffleMessage")
[16:01:41.269]                       }
[16:01:41.269]                       else if (inherits(cond, "warning")) {
[16:01:41.269]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:41.269]                         if (muffled) 
[16:01:41.269]                           invokeRestart("muffleWarning")
[16:01:41.269]                       }
[16:01:41.269]                       else if (inherits(cond, "condition")) {
[16:01:41.269]                         if (!is.null(pattern)) {
[16:01:41.269]                           computeRestarts <- base::computeRestarts
[16:01:41.269]                           grepl <- base::grepl
[16:01:41.269]                           restarts <- computeRestarts(cond)
[16:01:41.269]                           for (restart in restarts) {
[16:01:41.269]                             name <- restart$name
[16:01:41.269]                             if (is.null(name)) 
[16:01:41.269]                               next
[16:01:41.269]                             if (!grepl(pattern, name)) 
[16:01:41.269]                               next
[16:01:41.269]                             invokeRestart(restart)
[16:01:41.269]                             muffled <- TRUE
[16:01:41.269]                             break
[16:01:41.269]                           }
[16:01:41.269]                         }
[16:01:41.269]                       }
[16:01:41.269]                       invisible(muffled)
[16:01:41.269]                     }
[16:01:41.269]                     muffleCondition(cond, pattern = "^muffle")
[16:01:41.269]                   }
[16:01:41.269]                 }
[16:01:41.269]                 else {
[16:01:41.269]                   if (TRUE) {
[16:01:41.269]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.269]                     {
[16:01:41.269]                       inherits <- base::inherits
[16:01:41.269]                       invokeRestart <- base::invokeRestart
[16:01:41.269]                       is.null <- base::is.null
[16:01:41.269]                       muffled <- FALSE
[16:01:41.269]                       if (inherits(cond, "message")) {
[16:01:41.269]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:41.269]                         if (muffled) 
[16:01:41.269]                           invokeRestart("muffleMessage")
[16:01:41.269]                       }
[16:01:41.269]                       else if (inherits(cond, "warning")) {
[16:01:41.269]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:41.269]                         if (muffled) 
[16:01:41.269]                           invokeRestart("muffleWarning")
[16:01:41.269]                       }
[16:01:41.269]                       else if (inherits(cond, "condition")) {
[16:01:41.269]                         if (!is.null(pattern)) {
[16:01:41.269]                           computeRestarts <- base::computeRestarts
[16:01:41.269]                           grepl <- base::grepl
[16:01:41.269]                           restarts <- computeRestarts(cond)
[16:01:41.269]                           for (restart in restarts) {
[16:01:41.269]                             name <- restart$name
[16:01:41.269]                             if (is.null(name)) 
[16:01:41.269]                               next
[16:01:41.269]                             if (!grepl(pattern, name)) 
[16:01:41.269]                               next
[16:01:41.269]                             invokeRestart(restart)
[16:01:41.269]                             muffled <- TRUE
[16:01:41.269]                             break
[16:01:41.269]                           }
[16:01:41.269]                         }
[16:01:41.269]                       }
[16:01:41.269]                       invisible(muffled)
[16:01:41.269]                     }
[16:01:41.269]                     muffleCondition(cond, pattern = "^muffle")
[16:01:41.269]                   }
[16:01:41.269]                 }
[16:01:41.269]             }
[16:01:41.269]         }))
[16:01:41.269]     }, error = function(ex) {
[16:01:41.269]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:41.269]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:41.269]                 ...future.rng), started = ...future.startTime, 
[16:01:41.269]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:41.269]             version = "1.8"), class = "FutureResult")
[16:01:41.269]     }, finally = {
[16:01:41.269]         if (!identical(...future.workdir, getwd())) 
[16:01:41.269]             setwd(...future.workdir)
[16:01:41.269]         {
[16:01:41.269]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:41.269]                 ...future.oldOptions$nwarnings <- NULL
[16:01:41.269]             }
[16:01:41.269]             base::options(...future.oldOptions)
[16:01:41.269]             if (.Platform$OS.type == "windows") {
[16:01:41.269]                 old_names <- names(...future.oldEnvVars)
[16:01:41.269]                 envs <- base::Sys.getenv()
[16:01:41.269]                 names <- names(envs)
[16:01:41.269]                 common <- intersect(names, old_names)
[16:01:41.269]                 added <- setdiff(names, old_names)
[16:01:41.269]                 removed <- setdiff(old_names, names)
[16:01:41.269]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:41.269]                   envs[common]]
[16:01:41.269]                 NAMES <- toupper(changed)
[16:01:41.269]                 args <- list()
[16:01:41.269]                 for (kk in seq_along(NAMES)) {
[16:01:41.269]                   name <- changed[[kk]]
[16:01:41.269]                   NAME <- NAMES[[kk]]
[16:01:41.269]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.269]                     next
[16:01:41.269]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:41.269]                 }
[16:01:41.269]                 NAMES <- toupper(added)
[16:01:41.269]                 for (kk in seq_along(NAMES)) {
[16:01:41.269]                   name <- added[[kk]]
[16:01:41.269]                   NAME <- NAMES[[kk]]
[16:01:41.269]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.269]                     next
[16:01:41.269]                   args[[name]] <- ""
[16:01:41.269]                 }
[16:01:41.269]                 NAMES <- toupper(removed)
[16:01:41.269]                 for (kk in seq_along(NAMES)) {
[16:01:41.269]                   name <- removed[[kk]]
[16:01:41.269]                   NAME <- NAMES[[kk]]
[16:01:41.269]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.269]                     next
[16:01:41.269]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:41.269]                 }
[16:01:41.269]                 if (length(args) > 0) 
[16:01:41.269]                   base::do.call(base::Sys.setenv, args = args)
[16:01:41.269]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:41.269]             }
[16:01:41.269]             else {
[16:01:41.269]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:41.269]             }
[16:01:41.269]             {
[16:01:41.269]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:41.269]                   0L) {
[16:01:41.269]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:41.269]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:41.269]                   base::options(opts)
[16:01:41.269]                 }
[16:01:41.269]                 {
[16:01:41.269]                   {
[16:01:41.269]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:41.269]                     NULL
[16:01:41.269]                   }
[16:01:41.269]                   options(future.plan = NULL)
[16:01:41.269]                   if (is.na(NA_character_)) 
[16:01:41.269]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:41.269]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:41.269]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:41.269]                     envir = parent.frame()) 
[16:01:41.269]                   {
[16:01:41.269]                     default_workers <- missing(workers)
[16:01:41.269]                     if (is.function(workers)) 
[16:01:41.269]                       workers <- workers()
[16:01:41.269]                     workers <- structure(as.integer(workers), 
[16:01:41.269]                       class = class(workers))
[16:01:41.269]                     stop_if_not(is.finite(workers), workers >= 
[16:01:41.269]                       1L)
[16:01:41.269]                     if ((workers == 1L && !inherits(workers, 
[16:01:41.269]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:41.269]                       if (default_workers) 
[16:01:41.269]                         supportsMulticore(warn = TRUE)
[16:01:41.269]                       return(sequential(..., envir = envir))
[16:01:41.269]                     }
[16:01:41.269]                     oopts <- options(mc.cores = workers)
[16:01:41.269]                     on.exit(options(oopts))
[16:01:41.269]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:41.269]                       envir = envir)
[16:01:41.269]                     if (!future$lazy) 
[16:01:41.269]                       future <- run(future)
[16:01:41.269]                     invisible(future)
[16:01:41.269]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:41.269]                 }
[16:01:41.269]             }
[16:01:41.269]         }
[16:01:41.269]     })
[16:01:41.269]     if (TRUE) {
[16:01:41.269]         base::sink(type = "output", split = FALSE)
[16:01:41.269]         if (TRUE) {
[16:01:41.269]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:41.269]         }
[16:01:41.269]         else {
[16:01:41.269]             ...future.result["stdout"] <- base::list(NULL)
[16:01:41.269]         }
[16:01:41.269]         base::close(...future.stdout)
[16:01:41.269]         ...future.stdout <- NULL
[16:01:41.269]     }
[16:01:41.269]     ...future.result$conditions <- ...future.conditions
[16:01:41.269]     ...future.result$finished <- base::Sys.time()
[16:01:41.269]     ...future.result
[16:01:41.269] }
[16:01:41.272] assign_globals() ...
[16:01:41.272] List of 5
[16:01:41.272]  $ future.call.arguments    : list()
[16:01:41.272]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:41.272]  $ ...future.FUN            :function (x)  
[16:01:41.272]  $ ...future.elements_ii    :List of 1
[16:01:41.272]   ..$ : int 1
[16:01:41.272]  $ ...future.seeds_ii       : NULL
[16:01:41.272]  $ ...future.globals.maxSize: num Inf
[16:01:41.272]  - attr(*, "resolved")= logi FALSE
[16:01:41.272]  - attr(*, "total_size")= num NA
[16:01:41.272]  - attr(*, "where")=List of 5
[16:01:41.272]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:41.272]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:41.272]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:41.272]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:41.272]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:41.272]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:41.272]  - attr(*, "already-done")= logi TRUE
[16:01:41.277] - copied ‘future.call.arguments’ to environment
[16:01:41.277] - copied ‘...future.FUN’ to environment
[16:01:41.277] - copied ‘...future.elements_ii’ to environment
[16:01:41.277] - copied ‘...future.seeds_ii’ to environment
[16:01:41.277] - copied ‘...future.globals.maxSize’ to environment
[16:01:41.277] assign_globals() ... done
[16:01:41.277] requestCore(): workers = 2
[16:01:41.279] MulticoreFuture started
[16:01:41.280] - Launch lazy future ... done
[16:01:41.280] run() for ‘MulticoreFuture’ ... done
[16:01:41.280] Created future:
[16:01:41.281] plan(): Setting new future strategy stack:
[16:01:41.281] List of future strategies:
[16:01:41.281] 1. sequential:
[16:01:41.281]    - args: function (..., envir = parent.frame())
[16:01:41.281]    - tweaked: FALSE
[16:01:41.281]    - call: NULL
[16:01:41.282] plan(): nbrOfWorkers() = 1
[16:01:41.284] plan(): Setting new future strategy stack:
[16:01:41.284] List of future strategies:
[16:01:41.284] 1. multicore:
[16:01:41.284]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:41.284]    - tweaked: FALSE
[16:01:41.284]    - call: plan(strategy)
[16:01:41.289] plan(): nbrOfWorkers() = 2
[16:01:41.281] MulticoreFuture:
[16:01:41.281] Label: ‘future_apply-1’
[16:01:41.281] Expression:
[16:01:41.281] {
[16:01:41.281]     do.call(function(...) {
[16:01:41.281]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.281]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:41.281]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.281]             on.exit(options(oopts), add = TRUE)
[16:01:41.281]         }
[16:01:41.281]         {
[16:01:41.281]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:41.281]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.281]                 ...future.FUN(...future.X_jj, ...)
[16:01:41.281]             })
[16:01:41.281]         }
[16:01:41.281]     }, args = future.call.arguments)
[16:01:41.281] }
[16:01:41.281] Lazy evaluation: FALSE
[16:01:41.281] Asynchronous evaluation: TRUE
[16:01:41.281] Local evaluation: TRUE
[16:01:41.281] Environment: R_GlobalEnv
[16:01:41.281] Capture standard output: TRUE
[16:01:41.281] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:41.281] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:41.281] Packages: <none>
[16:01:41.281] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:41.281] Resolved: TRUE
[16:01:41.281] Value: <not collected>
[16:01:41.281] Conditions captured: <none>
[16:01:41.281] Early signaling: FALSE
[16:01:41.281] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:41.281] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:41.290] Chunk #1 of 2 ... DONE
[16:01:41.290] Chunk #2 of 2 ...
[16:01:41.291]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:41.291]  - seeds: <none>
[16:01:41.291]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.291] getGlobalsAndPackages() ...
[16:01:41.291] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.292] Resolving globals: FALSE
[16:01:41.292] Tweak future expression to call with '...' arguments ...
[16:01:41.292] {
[16:01:41.292]     do.call(function(...) {
[16:01:41.292]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.292]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:41.292]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.292]             on.exit(options(oopts), add = TRUE)
[16:01:41.292]         }
[16:01:41.292]         {
[16:01:41.292]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:41.292]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.292]                 ...future.FUN(...future.X_jj, ...)
[16:01:41.292]             })
[16:01:41.292]         }
[16:01:41.292]     }, args = future.call.arguments)
[16:01:41.292] }
[16:01:41.292] Tweak future expression to call with '...' arguments ... DONE
[16:01:41.293] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.293] 
[16:01:41.293] getGlobalsAndPackages() ... DONE
[16:01:41.294] run() for ‘Future’ ...
[16:01:41.294] - state: ‘created’
[16:01:41.294] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:41.299] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:41.299] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:41.299]   - Field: ‘label’
[16:01:41.299]   - Field: ‘local’
[16:01:41.300]   - Field: ‘owner’
[16:01:41.300]   - Field: ‘envir’
[16:01:41.300]   - Field: ‘workers’
[16:01:41.300]   - Field: ‘packages’
[16:01:41.300]   - Field: ‘gc’
[16:01:41.300]   - Field: ‘job’
[16:01:41.301]   - Field: ‘conditions’
[16:01:41.301]   - Field: ‘expr’
[16:01:41.301]   - Field: ‘uuid’
[16:01:41.301]   - Field: ‘seed’
[16:01:41.301]   - Field: ‘version’
[16:01:41.301]   - Field: ‘result’
[16:01:41.301]   - Field: ‘asynchronous’
[16:01:41.301]   - Field: ‘calls’
[16:01:41.302]   - Field: ‘globals’
[16:01:41.302]   - Field: ‘stdout’
[16:01:41.302]   - Field: ‘earlySignal’
[16:01:41.302]   - Field: ‘lazy’
[16:01:41.302]   - Field: ‘state’
[16:01:41.302] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:41.302] - Launch lazy future ...
[16:01:41.303] Packages needed by the future expression (n = 0): <none>
[16:01:41.303] Packages needed by future strategies (n = 0): <none>
[16:01:41.304] {
[16:01:41.304]     {
[16:01:41.304]         {
[16:01:41.304]             ...future.startTime <- base::Sys.time()
[16:01:41.304]             {
[16:01:41.304]                 {
[16:01:41.304]                   {
[16:01:41.304]                     {
[16:01:41.304]                       base::local({
[16:01:41.304]                         has_future <- base::requireNamespace("future", 
[16:01:41.304]                           quietly = TRUE)
[16:01:41.304]                         if (has_future) {
[16:01:41.304]                           ns <- base::getNamespace("future")
[16:01:41.304]                           version <- ns[[".package"]][["version"]]
[16:01:41.304]                           if (is.null(version)) 
[16:01:41.304]                             version <- utils::packageVersion("future")
[16:01:41.304]                         }
[16:01:41.304]                         else {
[16:01:41.304]                           version <- NULL
[16:01:41.304]                         }
[16:01:41.304]                         if (!has_future || version < "1.8.0") {
[16:01:41.304]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:41.304]                             "", base::R.version$version.string), 
[16:01:41.304]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:41.304]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:41.304]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:41.304]                               "release", "version")], collapse = " "), 
[16:01:41.304]                             hostname = base::Sys.info()[["nodename"]])
[16:01:41.304]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:41.304]                             info)
[16:01:41.304]                           info <- base::paste(info, collapse = "; ")
[16:01:41.304]                           if (!has_future) {
[16:01:41.304]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:41.304]                               info)
[16:01:41.304]                           }
[16:01:41.304]                           else {
[16:01:41.304]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:41.304]                               info, version)
[16:01:41.304]                           }
[16:01:41.304]                           base::stop(msg)
[16:01:41.304]                         }
[16:01:41.304]                       })
[16:01:41.304]                     }
[16:01:41.304]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:41.304]                     base::options(mc.cores = 1L)
[16:01:41.304]                   }
[16:01:41.304]                   options(future.plan = NULL)
[16:01:41.304]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:41.304]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:41.304]                 }
[16:01:41.304]                 ...future.workdir <- getwd()
[16:01:41.304]             }
[16:01:41.304]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:41.304]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:41.304]         }
[16:01:41.304]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:41.304]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:41.304]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:41.304]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:41.304]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:41.304]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:41.304]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:41.304]             base::names(...future.oldOptions))
[16:01:41.304]     }
[16:01:41.304]     if (FALSE) {
[16:01:41.304]     }
[16:01:41.304]     else {
[16:01:41.304]         if (TRUE) {
[16:01:41.304]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:41.304]                 open = "w")
[16:01:41.304]         }
[16:01:41.304]         else {
[16:01:41.304]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:41.304]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:41.304]         }
[16:01:41.304]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:41.304]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:41.304]             base::sink(type = "output", split = FALSE)
[16:01:41.304]             base::close(...future.stdout)
[16:01:41.304]         }, add = TRUE)
[16:01:41.304]     }
[16:01:41.304]     ...future.frame <- base::sys.nframe()
[16:01:41.304]     ...future.conditions <- base::list()
[16:01:41.304]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:41.304]     if (FALSE) {
[16:01:41.304]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:41.304]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:41.304]     }
[16:01:41.304]     ...future.result <- base::tryCatch({
[16:01:41.304]         base::withCallingHandlers({
[16:01:41.304]             ...future.value <- base::withVisible(base::local({
[16:01:41.304]                 withCallingHandlers({
[16:01:41.304]                   {
[16:01:41.304]                     do.call(function(...) {
[16:01:41.304]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.304]                       if (!identical(...future.globals.maxSize.org, 
[16:01:41.304]                         ...future.globals.maxSize)) {
[16:01:41.304]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.304]                         on.exit(options(oopts), add = TRUE)
[16:01:41.304]                       }
[16:01:41.304]                       {
[16:01:41.304]                         lapply(seq_along(...future.elements_ii), 
[16:01:41.304]                           FUN = function(jj) {
[16:01:41.304]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.304]                             ...future.FUN(...future.X_jj, ...)
[16:01:41.304]                           })
[16:01:41.304]                       }
[16:01:41.304]                     }, args = future.call.arguments)
[16:01:41.304]                   }
[16:01:41.304]                 }, immediateCondition = function(cond) {
[16:01:41.304]                   save_rds <- function (object, pathname, ...) 
[16:01:41.304]                   {
[16:01:41.304]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:41.304]                     if (file_test("-f", pathname_tmp)) {
[16:01:41.304]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.304]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:41.304]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.304]                         fi_tmp[["mtime"]])
[16:01:41.304]                     }
[16:01:41.304]                     tryCatch({
[16:01:41.304]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:41.304]                     }, error = function(ex) {
[16:01:41.304]                       msg <- conditionMessage(ex)
[16:01:41.304]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.304]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:41.304]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.304]                         fi_tmp[["mtime"]], msg)
[16:01:41.304]                       ex$message <- msg
[16:01:41.304]                       stop(ex)
[16:01:41.304]                     })
[16:01:41.304]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:41.304]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:41.304]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:41.304]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.304]                       fi <- file.info(pathname)
[16:01:41.304]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:41.304]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.304]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:41.304]                         fi[["size"]], fi[["mtime"]])
[16:01:41.304]                       stop(msg)
[16:01:41.304]                     }
[16:01:41.304]                     invisible(pathname)
[16:01:41.304]                   }
[16:01:41.304]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:41.304]                     rootPath = tempdir()) 
[16:01:41.304]                   {
[16:01:41.304]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:41.304]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:41.304]                       tmpdir = path, fileext = ".rds")
[16:01:41.304]                     save_rds(obj, file)
[16:01:41.304]                   }
[16:01:41.304]                   saveImmediateCondition(cond, path = "/tmp/RtmplAoKyr/.future/immediateConditions")
[16:01:41.304]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.304]                   {
[16:01:41.304]                     inherits <- base::inherits
[16:01:41.304]                     invokeRestart <- base::invokeRestart
[16:01:41.304]                     is.null <- base::is.null
[16:01:41.304]                     muffled <- FALSE
[16:01:41.304]                     if (inherits(cond, "message")) {
[16:01:41.304]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:41.304]                       if (muffled) 
[16:01:41.304]                         invokeRestart("muffleMessage")
[16:01:41.304]                     }
[16:01:41.304]                     else if (inherits(cond, "warning")) {
[16:01:41.304]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:41.304]                       if (muffled) 
[16:01:41.304]                         invokeRestart("muffleWarning")
[16:01:41.304]                     }
[16:01:41.304]                     else if (inherits(cond, "condition")) {
[16:01:41.304]                       if (!is.null(pattern)) {
[16:01:41.304]                         computeRestarts <- base::computeRestarts
[16:01:41.304]                         grepl <- base::grepl
[16:01:41.304]                         restarts <- computeRestarts(cond)
[16:01:41.304]                         for (restart in restarts) {
[16:01:41.304]                           name <- restart$name
[16:01:41.304]                           if (is.null(name)) 
[16:01:41.304]                             next
[16:01:41.304]                           if (!grepl(pattern, name)) 
[16:01:41.304]                             next
[16:01:41.304]                           invokeRestart(restart)
[16:01:41.304]                           muffled <- TRUE
[16:01:41.304]                           break
[16:01:41.304]                         }
[16:01:41.304]                       }
[16:01:41.304]                     }
[16:01:41.304]                     invisible(muffled)
[16:01:41.304]                   }
[16:01:41.304]                   muffleCondition(cond)
[16:01:41.304]                 })
[16:01:41.304]             }))
[16:01:41.304]             future::FutureResult(value = ...future.value$value, 
[16:01:41.304]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:41.304]                   ...future.rng), globalenv = if (FALSE) 
[16:01:41.304]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:41.304]                     ...future.globalenv.names))
[16:01:41.304]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:41.304]         }, condition = base::local({
[16:01:41.304]             c <- base::c
[16:01:41.304]             inherits <- base::inherits
[16:01:41.304]             invokeRestart <- base::invokeRestart
[16:01:41.304]             length <- base::length
[16:01:41.304]             list <- base::list
[16:01:41.304]             seq.int <- base::seq.int
[16:01:41.304]             signalCondition <- base::signalCondition
[16:01:41.304]             sys.calls <- base::sys.calls
[16:01:41.304]             `[[` <- base::`[[`
[16:01:41.304]             `+` <- base::`+`
[16:01:41.304]             `<<-` <- base::`<<-`
[16:01:41.304]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:41.304]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:41.304]                   3L)]
[16:01:41.304]             }
[16:01:41.304]             function(cond) {
[16:01:41.304]                 is_error <- inherits(cond, "error")
[16:01:41.304]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:41.304]                   NULL)
[16:01:41.304]                 if (is_error) {
[16:01:41.304]                   sessionInformation <- function() {
[16:01:41.304]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:41.304]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:41.304]                       search = base::search(), system = base::Sys.info())
[16:01:41.304]                   }
[16:01:41.304]                   ...future.conditions[[length(...future.conditions) + 
[16:01:41.304]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:41.304]                     cond$call), session = sessionInformation(), 
[16:01:41.304]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:41.304]                   signalCondition(cond)
[16:01:41.304]                 }
[16:01:41.304]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:41.304]                 "immediateCondition"))) {
[16:01:41.304]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:41.304]                   ...future.conditions[[length(...future.conditions) + 
[16:01:41.304]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:41.304]                   if (TRUE && !signal) {
[16:01:41.304]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.304]                     {
[16:01:41.304]                       inherits <- base::inherits
[16:01:41.304]                       invokeRestart <- base::invokeRestart
[16:01:41.304]                       is.null <- base::is.null
[16:01:41.304]                       muffled <- FALSE
[16:01:41.304]                       if (inherits(cond, "message")) {
[16:01:41.304]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:41.304]                         if (muffled) 
[16:01:41.304]                           invokeRestart("muffleMessage")
[16:01:41.304]                       }
[16:01:41.304]                       else if (inherits(cond, "warning")) {
[16:01:41.304]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:41.304]                         if (muffled) 
[16:01:41.304]                           invokeRestart("muffleWarning")
[16:01:41.304]                       }
[16:01:41.304]                       else if (inherits(cond, "condition")) {
[16:01:41.304]                         if (!is.null(pattern)) {
[16:01:41.304]                           computeRestarts <- base::computeRestarts
[16:01:41.304]                           grepl <- base::grepl
[16:01:41.304]                           restarts <- computeRestarts(cond)
[16:01:41.304]                           for (restart in restarts) {
[16:01:41.304]                             name <- restart$name
[16:01:41.304]                             if (is.null(name)) 
[16:01:41.304]                               next
[16:01:41.304]                             if (!grepl(pattern, name)) 
[16:01:41.304]                               next
[16:01:41.304]                             invokeRestart(restart)
[16:01:41.304]                             muffled <- TRUE
[16:01:41.304]                             break
[16:01:41.304]                           }
[16:01:41.304]                         }
[16:01:41.304]                       }
[16:01:41.304]                       invisible(muffled)
[16:01:41.304]                     }
[16:01:41.304]                     muffleCondition(cond, pattern = "^muffle")
[16:01:41.304]                   }
[16:01:41.304]                 }
[16:01:41.304]                 else {
[16:01:41.304]                   if (TRUE) {
[16:01:41.304]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.304]                     {
[16:01:41.304]                       inherits <- base::inherits
[16:01:41.304]                       invokeRestart <- base::invokeRestart
[16:01:41.304]                       is.null <- base::is.null
[16:01:41.304]                       muffled <- FALSE
[16:01:41.304]                       if (inherits(cond, "message")) {
[16:01:41.304]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:41.304]                         if (muffled) 
[16:01:41.304]                           invokeRestart("muffleMessage")
[16:01:41.304]                       }
[16:01:41.304]                       else if (inherits(cond, "warning")) {
[16:01:41.304]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:41.304]                         if (muffled) 
[16:01:41.304]                           invokeRestart("muffleWarning")
[16:01:41.304]                       }
[16:01:41.304]                       else if (inherits(cond, "condition")) {
[16:01:41.304]                         if (!is.null(pattern)) {
[16:01:41.304]                           computeRestarts <- base::computeRestarts
[16:01:41.304]                           grepl <- base::grepl
[16:01:41.304]                           restarts <- computeRestarts(cond)
[16:01:41.304]                           for (restart in restarts) {
[16:01:41.304]                             name <- restart$name
[16:01:41.304]                             if (is.null(name)) 
[16:01:41.304]                               next
[16:01:41.304]                             if (!grepl(pattern, name)) 
[16:01:41.304]                               next
[16:01:41.304]                             invokeRestart(restart)
[16:01:41.304]                             muffled <- TRUE
[16:01:41.304]                             break
[16:01:41.304]                           }
[16:01:41.304]                         }
[16:01:41.304]                       }
[16:01:41.304]                       invisible(muffled)
[16:01:41.304]                     }
[16:01:41.304]                     muffleCondition(cond, pattern = "^muffle")
[16:01:41.304]                   }
[16:01:41.304]                 }
[16:01:41.304]             }
[16:01:41.304]         }))
[16:01:41.304]     }, error = function(ex) {
[16:01:41.304]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:41.304]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:41.304]                 ...future.rng), started = ...future.startTime, 
[16:01:41.304]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:41.304]             version = "1.8"), class = "FutureResult")
[16:01:41.304]     }, finally = {
[16:01:41.304]         if (!identical(...future.workdir, getwd())) 
[16:01:41.304]             setwd(...future.workdir)
[16:01:41.304]         {
[16:01:41.304]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:41.304]                 ...future.oldOptions$nwarnings <- NULL
[16:01:41.304]             }
[16:01:41.304]             base::options(...future.oldOptions)
[16:01:41.304]             if (.Platform$OS.type == "windows") {
[16:01:41.304]                 old_names <- names(...future.oldEnvVars)
[16:01:41.304]                 envs <- base::Sys.getenv()
[16:01:41.304]                 names <- names(envs)
[16:01:41.304]                 common <- intersect(names, old_names)
[16:01:41.304]                 added <- setdiff(names, old_names)
[16:01:41.304]                 removed <- setdiff(old_names, names)
[16:01:41.304]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:41.304]                   envs[common]]
[16:01:41.304]                 NAMES <- toupper(changed)
[16:01:41.304]                 args <- list()
[16:01:41.304]                 for (kk in seq_along(NAMES)) {
[16:01:41.304]                   name <- changed[[kk]]
[16:01:41.304]                   NAME <- NAMES[[kk]]
[16:01:41.304]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.304]                     next
[16:01:41.304]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:41.304]                 }
[16:01:41.304]                 NAMES <- toupper(added)
[16:01:41.304]                 for (kk in seq_along(NAMES)) {
[16:01:41.304]                   name <- added[[kk]]
[16:01:41.304]                   NAME <- NAMES[[kk]]
[16:01:41.304]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.304]                     next
[16:01:41.304]                   args[[name]] <- ""
[16:01:41.304]                 }
[16:01:41.304]                 NAMES <- toupper(removed)
[16:01:41.304]                 for (kk in seq_along(NAMES)) {
[16:01:41.304]                   name <- removed[[kk]]
[16:01:41.304]                   NAME <- NAMES[[kk]]
[16:01:41.304]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.304]                     next
[16:01:41.304]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:41.304]                 }
[16:01:41.304]                 if (length(args) > 0) 
[16:01:41.304]                   base::do.call(base::Sys.setenv, args = args)
[16:01:41.304]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:41.304]             }
[16:01:41.304]             else {
[16:01:41.304]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:41.304]             }
[16:01:41.304]             {
[16:01:41.304]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:41.304]                   0L) {
[16:01:41.304]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:41.304]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:41.304]                   base::options(opts)
[16:01:41.304]                 }
[16:01:41.304]                 {
[16:01:41.304]                   {
[16:01:41.304]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:41.304]                     NULL
[16:01:41.304]                   }
[16:01:41.304]                   options(future.plan = NULL)
[16:01:41.304]                   if (is.na(NA_character_)) 
[16:01:41.304]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:41.304]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:41.304]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:41.304]                     envir = parent.frame()) 
[16:01:41.304]                   {
[16:01:41.304]                     default_workers <- missing(workers)
[16:01:41.304]                     if (is.function(workers)) 
[16:01:41.304]                       workers <- workers()
[16:01:41.304]                     workers <- structure(as.integer(workers), 
[16:01:41.304]                       class = class(workers))
[16:01:41.304]                     stop_if_not(is.finite(workers), workers >= 
[16:01:41.304]                       1L)
[16:01:41.304]                     if ((workers == 1L && !inherits(workers, 
[16:01:41.304]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:41.304]                       if (default_workers) 
[16:01:41.304]                         supportsMulticore(warn = TRUE)
[16:01:41.304]                       return(sequential(..., envir = envir))
[16:01:41.304]                     }
[16:01:41.304]                     oopts <- options(mc.cores = workers)
[16:01:41.304]                     on.exit(options(oopts))
[16:01:41.304]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:41.304]                       envir = envir)
[16:01:41.304]                     if (!future$lazy) 
[16:01:41.304]                       future <- run(future)
[16:01:41.304]                     invisible(future)
[16:01:41.304]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:41.304]                 }
[16:01:41.304]             }
[16:01:41.304]         }
[16:01:41.304]     })
[16:01:41.304]     if (TRUE) {
[16:01:41.304]         base::sink(type = "output", split = FALSE)
[16:01:41.304]         if (TRUE) {
[16:01:41.304]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:41.304]         }
[16:01:41.304]         else {
[16:01:41.304]             ...future.result["stdout"] <- base::list(NULL)
[16:01:41.304]         }
[16:01:41.304]         base::close(...future.stdout)
[16:01:41.304]         ...future.stdout <- NULL
[16:01:41.304]     }
[16:01:41.304]     ...future.result$conditions <- ...future.conditions
[16:01:41.304]     ...future.result$finished <- base::Sys.time()
[16:01:41.304]     ...future.result
[16:01:41.304] }
[16:01:41.307] assign_globals() ...
[16:01:41.307] List of 5
[16:01:41.307]  $ future.call.arguments    : list()
[16:01:41.307]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:41.307]  $ ...future.FUN            :function (x)  
[16:01:41.307]  $ ...future.elements_ii    :List of 1
[16:01:41.307]   ..$ : int 2
[16:01:41.307]  $ ...future.seeds_ii       : NULL
[16:01:41.307]  $ ...future.globals.maxSize: num Inf
[16:01:41.307]  - attr(*, "resolved")= logi FALSE
[16:01:41.307]  - attr(*, "total_size")= num NA
[16:01:41.307]  - attr(*, "where")=List of 5
[16:01:41.307]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:41.307]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:41.307]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:41.307]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:41.307]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:41.307]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:41.307]  - attr(*, "already-done")= logi TRUE
[16:01:41.321] - copied ‘future.call.arguments’ to environment
[16:01:41.321] - copied ‘...future.FUN’ to environment
[16:01:41.321] - copied ‘...future.elements_ii’ to environment
[16:01:41.322] - copied ‘...future.seeds_ii’ to environment
[16:01:41.322] - copied ‘...future.globals.maxSize’ to environment
[16:01:41.322] assign_globals() ... done
[16:01:41.322] requestCore(): workers = 2
[16:01:41.324] MulticoreFuture started
[16:01:41.325] - Launch lazy future ... done
[16:01:41.325] run() for ‘MulticoreFuture’ ... done
[16:01:41.326] Created future:
[16:01:41.326] plan(): Setting new future strategy stack:
[16:01:41.326] List of future strategies:
[16:01:41.326] 1. sequential:
[16:01:41.326]    - args: function (..., envir = parent.frame())
[16:01:41.326]    - tweaked: FALSE
[16:01:41.326]    - call: NULL
[16:01:41.327] plan(): nbrOfWorkers() = 1
[16:01:41.329] plan(): Setting new future strategy stack:
[16:01:41.330] List of future strategies:
[16:01:41.330] 1. multicore:
[16:01:41.330]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:41.330]    - tweaked: FALSE
[16:01:41.330]    - call: plan(strategy)
[16:01:41.335] plan(): nbrOfWorkers() = 2
[16:01:41.326] MulticoreFuture:
[16:01:41.326] Label: ‘future_apply-2’
[16:01:41.326] Expression:
[16:01:41.326] {
[16:01:41.326]     do.call(function(...) {
[16:01:41.326]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.326]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:41.326]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.326]             on.exit(options(oopts), add = TRUE)
[16:01:41.326]         }
[16:01:41.326]         {
[16:01:41.326]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:41.326]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.326]                 ...future.FUN(...future.X_jj, ...)
[16:01:41.326]             })
[16:01:41.326]         }
[16:01:41.326]     }, args = future.call.arguments)
[16:01:41.326] }
[16:01:41.326] Lazy evaluation: FALSE
[16:01:41.326] Asynchronous evaluation: TRUE
[16:01:41.326] Local evaluation: TRUE
[16:01:41.326] Environment: R_GlobalEnv
[16:01:41.326] Capture standard output: TRUE
[16:01:41.326] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:41.326] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:41.326] Packages: <none>
[16:01:41.326] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:41.326] Resolved: TRUE
[16:01:41.326] Value: <not collected>
[16:01:41.326] Conditions captured: <none>
[16:01:41.326] Early signaling: FALSE
[16:01:41.326] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:41.326] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:41.336] Chunk #2 of 2 ... DONE
[16:01:41.336] Launching 2 futures (chunks) ... DONE
[16:01:41.336] Resolving 2 futures (chunks) ...
[16:01:41.337] resolve() on list ...
[16:01:41.337]  recursive: 0
[16:01:41.337]  length: 2
[16:01:41.337] 
[16:01:41.337] Future #1
[16:01:41.338] result() for MulticoreFuture ...
[16:01:41.339] result() for MulticoreFuture ...
[16:01:41.339] result() for MulticoreFuture ... done
[16:01:41.339] result() for MulticoreFuture ... done
[16:01:41.339] result() for MulticoreFuture ...
[16:01:41.339] result() for MulticoreFuture ... done
[16:01:41.339] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:01:41.340] - nx: 2
[16:01:41.340] - relay: TRUE
[16:01:41.340] - stdout: TRUE
[16:01:41.340] - signal: TRUE
[16:01:41.340] - resignal: FALSE
[16:01:41.340] - force: TRUE
[16:01:41.340] - relayed: [n=2] FALSE, FALSE
[16:01:41.341] - queued futures: [n=2] FALSE, FALSE
[16:01:41.341]  - until=1
[16:01:41.341]  - relaying element #1
[16:01:41.341] result() for MulticoreFuture ...
[16:01:41.341] result() for MulticoreFuture ... done
[16:01:41.341] result() for MulticoreFuture ...
[16:01:41.342] result() for MulticoreFuture ... done
[16:01:41.342] result() for MulticoreFuture ...
[16:01:41.342] result() for MulticoreFuture ... done
[16:01:41.342] result() for MulticoreFuture ...
[16:01:41.342] result() for MulticoreFuture ... done
[16:01:41.342] - relayed: [n=2] TRUE, FALSE
[16:01:41.343] - queued futures: [n=2] TRUE, FALSE
[16:01:41.343] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:01:41.343]  length: 1 (resolved future 1)
[16:01:41.343] Future #2
[16:01:41.343] result() for MulticoreFuture ...
[16:01:41.344] result() for MulticoreFuture ...
[16:01:41.344] result() for MulticoreFuture ... done
[16:01:41.345] result() for MulticoreFuture ... done
[16:01:41.345] result() for MulticoreFuture ...
[16:01:41.345] result() for MulticoreFuture ... done
[16:01:41.345] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:01:41.345] - nx: 2
[16:01:41.346] - relay: TRUE
[16:01:41.346] - stdout: TRUE
[16:01:41.346] - signal: TRUE
[16:01:41.346] - resignal: FALSE
[16:01:41.346] - force: TRUE
[16:01:41.346] - relayed: [n=2] TRUE, FALSE
[16:01:41.347] - queued futures: [n=2] TRUE, FALSE
[16:01:41.347]  - until=2
[16:01:41.347]  - relaying element #2
[16:01:41.347] result() for MulticoreFuture ...
[16:01:41.347] result() for MulticoreFuture ... done
[16:01:41.347] result() for MulticoreFuture ...
[16:01:41.348] result() for MulticoreFuture ... done
[16:01:41.348] result() for MulticoreFuture ...
[16:01:41.348] result() for MulticoreFuture ... done
[16:01:41.348] result() for MulticoreFuture ...
[16:01:41.348] result() for MulticoreFuture ... done
[16:01:41.348] - relayed: [n=2] TRUE, TRUE
[16:01:41.348] - queued futures: [n=2] TRUE, TRUE
[16:01:41.348] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:01:41.349]  length: 0 (resolved future 2)
[16:01:41.349] Relaying remaining futures
[16:01:41.349] signalConditionsASAP(NULL, pos=0) ...
[16:01:41.349] - nx: 2
[16:01:41.349] - relay: TRUE
[16:01:41.349] - stdout: TRUE
[16:01:41.349] - signal: TRUE
[16:01:41.349] - resignal: FALSE
[16:01:41.349] - force: TRUE
[16:01:41.350] - relayed: [n=2] TRUE, TRUE
[16:01:41.350] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:41.350] - relayed: [n=2] TRUE, TRUE
[16:01:41.350] - queued futures: [n=2] TRUE, TRUE
[16:01:41.350] signalConditionsASAP(NULL, pos=0) ... done
[16:01:41.350] resolve() on list ... DONE
[16:01:41.350] result() for MulticoreFuture ...
[16:01:41.350] result() for MulticoreFuture ... done
[16:01:41.350] result() for MulticoreFuture ...
[16:01:41.351] result() for MulticoreFuture ... done
[16:01:41.351] result() for MulticoreFuture ...
[16:01:41.351] result() for MulticoreFuture ... done
[16:01:41.351] result() for MulticoreFuture ...
[16:01:41.351] result() for MulticoreFuture ... done
[16:01:41.351]  - Number of value chunks collected: 2
[16:01:41.351] Resolving 2 futures (chunks) ... DONE
[16:01:41.351] Reducing values from 2 chunks ...
[16:01:41.352]  - Number of values collected after concatenation: 2
[16:01:41.352]  - Number of values expected: 2
[16:01:41.352] Reducing values from 2 chunks ... DONE
[16:01:41.352] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[16:01:41.352] getGlobalsAndPackagesXApply() ...
[16:01:41.352]  - future.globals: TRUE
[16:01:41.353] getGlobalsAndPackages() ...
[16:01:41.353] Searching for globals...
[16:01:41.354] - globals found: [1] ‘FUN’
[16:01:41.354] Searching for globals ... DONE
[16:01:41.354] Resolving globals: FALSE
[16:01:41.355] The total size of the 1 globals is 848 bytes (848 bytes)
[16:01:41.357] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:01:41.358] - globals: [1] ‘FUN’
[16:01:41.358] 
[16:01:41.358] getGlobalsAndPackages() ... DONE
[16:01:41.358]  - globals found/used: [n=1] ‘FUN’
[16:01:41.358]  - needed namespaces: [n=0] 
[16:01:41.359] Finding globals ... DONE
[16:01:41.359]  - use_args: TRUE
[16:01:41.359]  - Getting '...' globals ...
[16:01:41.359] resolve() on list ...
[16:01:41.359]  recursive: 0
[16:01:41.360]  length: 1
[16:01:41.360]  elements: ‘...’
[16:01:41.360]  length: 0 (resolved future 1)
[16:01:41.360] resolve() on list ... DONE
[16:01:41.360]    - '...' content: [n=0] 
[16:01:41.360] List of 1
[16:01:41.360]  $ ...: list()
[16:01:41.360]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:41.360]  - attr(*, "where")=List of 1
[16:01:41.360]   ..$ ...:<environment: 0x55fb6499a738> 
[16:01:41.360]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:41.360]  - attr(*, "resolved")= logi TRUE
[16:01:41.360]  - attr(*, "total_size")= num NA
[16:01:41.364]  - Getting '...' globals ... DONE
[16:01:41.364] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:41.364] List of 2
[16:01:41.364]  $ ...future.FUN:function (x)  
[16:01:41.364]  $ ...          : list()
[16:01:41.364]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:41.364]  - attr(*, "where")=List of 2
[16:01:41.364]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:41.364]   ..$ ...          :<environment: 0x55fb6499a738> 
[16:01:41.364]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:41.364]  - attr(*, "resolved")= logi FALSE
[16:01:41.364]  - attr(*, "total_size")= num 848
[16:01:41.367] Packages to be attached in all futures: [n=0] 
[16:01:41.367] getGlobalsAndPackagesXApply() ... DONE
[16:01:41.372] future_lapply() ...
[16:01:41.376] Number of chunks: 2
[16:01:41.376] getGlobalsAndPackagesXApply() ...
[16:01:41.376]  - future.globals: <name-value list> with names ‘list()’
[16:01:41.376]  - use_args: TRUE
[16:01:41.376] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:01:41.376] List of 2
[16:01:41.376]  $ ...          : list()
[16:01:41.376]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:41.376]  $ ...future.FUN:function (x)  
[16:01:41.376]  - attr(*, "where")=List of 2
[16:01:41.376]   ..$ ...          :<environment: 0x55fb6499a738> 
[16:01:41.376]   ..$ ...future.FUN:<environment: namespace:base> 
[16:01:41.376]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:41.376]  - attr(*, "resolved")= logi FALSE
[16:01:41.376]  - attr(*, "total_size")= num NA
[16:01:41.380] Packages to be attached in all futures: [n=0] 
[16:01:41.380] getGlobalsAndPackagesXApply() ... DONE
[16:01:41.380] Number of futures (= number of chunks): 2
[16:01:41.380] Launching 2 futures (chunks) ...
[16:01:41.380] Chunk #1 of 2 ...
[16:01:41.380]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:41.381]  - seeds: <none>
[16:01:41.381]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.381] getGlobalsAndPackages() ...
[16:01:41.381] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.381] Resolving globals: FALSE
[16:01:41.381] Tweak future expression to call with '...' arguments ...
[16:01:41.381] {
[16:01:41.381]     do.call(function(...) {
[16:01:41.381]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.381]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:41.381]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.381]             on.exit(options(oopts), add = TRUE)
[16:01:41.381]         }
[16:01:41.381]         {
[16:01:41.381]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:41.381]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.381]                 ...future.FUN(...future.X_jj, ...)
[16:01:41.381]             })
[16:01:41.381]         }
[16:01:41.381]     }, args = future.call.arguments)
[16:01:41.381] }
[16:01:41.381] Tweak future expression to call with '...' arguments ... DONE
[16:01:41.382] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.382] 
[16:01:41.382] getGlobalsAndPackages() ... DONE
[16:01:41.382] run() for ‘Future’ ...
[16:01:41.383] - state: ‘created’
[16:01:41.383] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:41.386] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:41.386] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:41.386]   - Field: ‘label’
[16:01:41.387]   - Field: ‘local’
[16:01:41.387]   - Field: ‘owner’
[16:01:41.387]   - Field: ‘envir’
[16:01:41.387]   - Field: ‘workers’
[16:01:41.387]   - Field: ‘packages’
[16:01:41.387]   - Field: ‘gc’
[16:01:41.387]   - Field: ‘job’
[16:01:41.387]   - Field: ‘conditions’
[16:01:41.389]   - Field: ‘expr’
[16:01:41.389]   - Field: ‘uuid’
[16:01:41.389]   - Field: ‘seed’
[16:01:41.389]   - Field: ‘version’
[16:01:41.389]   - Field: ‘result’
[16:01:41.390]   - Field: ‘asynchronous’
[16:01:41.390]   - Field: ‘calls’
[16:01:41.390]   - Field: ‘globals’
[16:01:41.390]   - Field: ‘stdout’
[16:01:41.390]   - Field: ‘earlySignal’
[16:01:41.390]   - Field: ‘lazy’
[16:01:41.390]   - Field: ‘state’
[16:01:41.390] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:41.390] - Launch lazy future ...
[16:01:41.391] Packages needed by the future expression (n = 0): <none>
[16:01:41.391] Packages needed by future strategies (n = 0): <none>
[16:01:41.391] {
[16:01:41.391]     {
[16:01:41.391]         {
[16:01:41.391]             ...future.startTime <- base::Sys.time()
[16:01:41.391]             {
[16:01:41.391]                 {
[16:01:41.391]                   {
[16:01:41.391]                     {
[16:01:41.391]                       base::local({
[16:01:41.391]                         has_future <- base::requireNamespace("future", 
[16:01:41.391]                           quietly = TRUE)
[16:01:41.391]                         if (has_future) {
[16:01:41.391]                           ns <- base::getNamespace("future")
[16:01:41.391]                           version <- ns[[".package"]][["version"]]
[16:01:41.391]                           if (is.null(version)) 
[16:01:41.391]                             version <- utils::packageVersion("future")
[16:01:41.391]                         }
[16:01:41.391]                         else {
[16:01:41.391]                           version <- NULL
[16:01:41.391]                         }
[16:01:41.391]                         if (!has_future || version < "1.8.0") {
[16:01:41.391]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:41.391]                             "", base::R.version$version.string), 
[16:01:41.391]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:41.391]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:41.391]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:41.391]                               "release", "version")], collapse = " "), 
[16:01:41.391]                             hostname = base::Sys.info()[["nodename"]])
[16:01:41.391]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:41.391]                             info)
[16:01:41.391]                           info <- base::paste(info, collapse = "; ")
[16:01:41.391]                           if (!has_future) {
[16:01:41.391]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:41.391]                               info)
[16:01:41.391]                           }
[16:01:41.391]                           else {
[16:01:41.391]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:41.391]                               info, version)
[16:01:41.391]                           }
[16:01:41.391]                           base::stop(msg)
[16:01:41.391]                         }
[16:01:41.391]                       })
[16:01:41.391]                     }
[16:01:41.391]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:41.391]                     base::options(mc.cores = 1L)
[16:01:41.391]                   }
[16:01:41.391]                   options(future.plan = NULL)
[16:01:41.391]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:41.391]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:41.391]                 }
[16:01:41.391]                 ...future.workdir <- getwd()
[16:01:41.391]             }
[16:01:41.391]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:41.391]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:41.391]         }
[16:01:41.391]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:41.391]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:41.391]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:41.391]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:41.391]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:41.391]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:41.391]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:41.391]             base::names(...future.oldOptions))
[16:01:41.391]     }
[16:01:41.391]     if (FALSE) {
[16:01:41.391]     }
[16:01:41.391]     else {
[16:01:41.391]         if (TRUE) {
[16:01:41.391]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:41.391]                 open = "w")
[16:01:41.391]         }
[16:01:41.391]         else {
[16:01:41.391]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:41.391]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:41.391]         }
[16:01:41.391]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:41.391]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:41.391]             base::sink(type = "output", split = FALSE)
[16:01:41.391]             base::close(...future.stdout)
[16:01:41.391]         }, add = TRUE)
[16:01:41.391]     }
[16:01:41.391]     ...future.frame <- base::sys.nframe()
[16:01:41.391]     ...future.conditions <- base::list()
[16:01:41.391]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:41.391]     if (FALSE) {
[16:01:41.391]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:41.391]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:41.391]     }
[16:01:41.391]     ...future.result <- base::tryCatch({
[16:01:41.391]         base::withCallingHandlers({
[16:01:41.391]             ...future.value <- base::withVisible(base::local({
[16:01:41.391]                 withCallingHandlers({
[16:01:41.391]                   {
[16:01:41.391]                     do.call(function(...) {
[16:01:41.391]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.391]                       if (!identical(...future.globals.maxSize.org, 
[16:01:41.391]                         ...future.globals.maxSize)) {
[16:01:41.391]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.391]                         on.exit(options(oopts), add = TRUE)
[16:01:41.391]                       }
[16:01:41.391]                       {
[16:01:41.391]                         lapply(seq_along(...future.elements_ii), 
[16:01:41.391]                           FUN = function(jj) {
[16:01:41.391]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.391]                             ...future.FUN(...future.X_jj, ...)
[16:01:41.391]                           })
[16:01:41.391]                       }
[16:01:41.391]                     }, args = future.call.arguments)
[16:01:41.391]                   }
[16:01:41.391]                 }, immediateCondition = function(cond) {
[16:01:41.391]                   save_rds <- function (object, pathname, ...) 
[16:01:41.391]                   {
[16:01:41.391]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:41.391]                     if (file_test("-f", pathname_tmp)) {
[16:01:41.391]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.391]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:41.391]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.391]                         fi_tmp[["mtime"]])
[16:01:41.391]                     }
[16:01:41.391]                     tryCatch({
[16:01:41.391]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:41.391]                     }, error = function(ex) {
[16:01:41.391]                       msg <- conditionMessage(ex)
[16:01:41.391]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.391]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:41.391]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.391]                         fi_tmp[["mtime"]], msg)
[16:01:41.391]                       ex$message <- msg
[16:01:41.391]                       stop(ex)
[16:01:41.391]                     })
[16:01:41.391]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:41.391]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:41.391]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:41.391]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.391]                       fi <- file.info(pathname)
[16:01:41.391]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:41.391]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.391]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:41.391]                         fi[["size"]], fi[["mtime"]])
[16:01:41.391]                       stop(msg)
[16:01:41.391]                     }
[16:01:41.391]                     invisible(pathname)
[16:01:41.391]                   }
[16:01:41.391]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:41.391]                     rootPath = tempdir()) 
[16:01:41.391]                   {
[16:01:41.391]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:41.391]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:41.391]                       tmpdir = path, fileext = ".rds")
[16:01:41.391]                     save_rds(obj, file)
[16:01:41.391]                   }
[16:01:41.391]                   saveImmediateCondition(cond, path = "/tmp/RtmplAoKyr/.future/immediateConditions")
[16:01:41.391]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.391]                   {
[16:01:41.391]                     inherits <- base::inherits
[16:01:41.391]                     invokeRestart <- base::invokeRestart
[16:01:41.391]                     is.null <- base::is.null
[16:01:41.391]                     muffled <- FALSE
[16:01:41.391]                     if (inherits(cond, "message")) {
[16:01:41.391]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:41.391]                       if (muffled) 
[16:01:41.391]                         invokeRestart("muffleMessage")
[16:01:41.391]                     }
[16:01:41.391]                     else if (inherits(cond, "warning")) {
[16:01:41.391]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:41.391]                       if (muffled) 
[16:01:41.391]                         invokeRestart("muffleWarning")
[16:01:41.391]                     }
[16:01:41.391]                     else if (inherits(cond, "condition")) {
[16:01:41.391]                       if (!is.null(pattern)) {
[16:01:41.391]                         computeRestarts <- base::computeRestarts
[16:01:41.391]                         grepl <- base::grepl
[16:01:41.391]                         restarts <- computeRestarts(cond)
[16:01:41.391]                         for (restart in restarts) {
[16:01:41.391]                           name <- restart$name
[16:01:41.391]                           if (is.null(name)) 
[16:01:41.391]                             next
[16:01:41.391]                           if (!grepl(pattern, name)) 
[16:01:41.391]                             next
[16:01:41.391]                           invokeRestart(restart)
[16:01:41.391]                           muffled <- TRUE
[16:01:41.391]                           break
[16:01:41.391]                         }
[16:01:41.391]                       }
[16:01:41.391]                     }
[16:01:41.391]                     invisible(muffled)
[16:01:41.391]                   }
[16:01:41.391]                   muffleCondition(cond)
[16:01:41.391]                 })
[16:01:41.391]             }))
[16:01:41.391]             future::FutureResult(value = ...future.value$value, 
[16:01:41.391]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:41.391]                   ...future.rng), globalenv = if (FALSE) 
[16:01:41.391]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:41.391]                     ...future.globalenv.names))
[16:01:41.391]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:41.391]         }, condition = base::local({
[16:01:41.391]             c <- base::c
[16:01:41.391]             inherits <- base::inherits
[16:01:41.391]             invokeRestart <- base::invokeRestart
[16:01:41.391]             length <- base::length
[16:01:41.391]             list <- base::list
[16:01:41.391]             seq.int <- base::seq.int
[16:01:41.391]             signalCondition <- base::signalCondition
[16:01:41.391]             sys.calls <- base::sys.calls
[16:01:41.391]             `[[` <- base::`[[`
[16:01:41.391]             `+` <- base::`+`
[16:01:41.391]             `<<-` <- base::`<<-`
[16:01:41.391]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:41.391]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:41.391]                   3L)]
[16:01:41.391]             }
[16:01:41.391]             function(cond) {
[16:01:41.391]                 is_error <- inherits(cond, "error")
[16:01:41.391]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:41.391]                   NULL)
[16:01:41.391]                 if (is_error) {
[16:01:41.391]                   sessionInformation <- function() {
[16:01:41.391]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:41.391]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:41.391]                       search = base::search(), system = base::Sys.info())
[16:01:41.391]                   }
[16:01:41.391]                   ...future.conditions[[length(...future.conditions) + 
[16:01:41.391]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:41.391]                     cond$call), session = sessionInformation(), 
[16:01:41.391]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:41.391]                   signalCondition(cond)
[16:01:41.391]                 }
[16:01:41.391]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:41.391]                 "immediateCondition"))) {
[16:01:41.391]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:41.391]                   ...future.conditions[[length(...future.conditions) + 
[16:01:41.391]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:41.391]                   if (TRUE && !signal) {
[16:01:41.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.391]                     {
[16:01:41.391]                       inherits <- base::inherits
[16:01:41.391]                       invokeRestart <- base::invokeRestart
[16:01:41.391]                       is.null <- base::is.null
[16:01:41.391]                       muffled <- FALSE
[16:01:41.391]                       if (inherits(cond, "message")) {
[16:01:41.391]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:41.391]                         if (muffled) 
[16:01:41.391]                           invokeRestart("muffleMessage")
[16:01:41.391]                       }
[16:01:41.391]                       else if (inherits(cond, "warning")) {
[16:01:41.391]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:41.391]                         if (muffled) 
[16:01:41.391]                           invokeRestart("muffleWarning")
[16:01:41.391]                       }
[16:01:41.391]                       else if (inherits(cond, "condition")) {
[16:01:41.391]                         if (!is.null(pattern)) {
[16:01:41.391]                           computeRestarts <- base::computeRestarts
[16:01:41.391]                           grepl <- base::grepl
[16:01:41.391]                           restarts <- computeRestarts(cond)
[16:01:41.391]                           for (restart in restarts) {
[16:01:41.391]                             name <- restart$name
[16:01:41.391]                             if (is.null(name)) 
[16:01:41.391]                               next
[16:01:41.391]                             if (!grepl(pattern, name)) 
[16:01:41.391]                               next
[16:01:41.391]                             invokeRestart(restart)
[16:01:41.391]                             muffled <- TRUE
[16:01:41.391]                             break
[16:01:41.391]                           }
[16:01:41.391]                         }
[16:01:41.391]                       }
[16:01:41.391]                       invisible(muffled)
[16:01:41.391]                     }
[16:01:41.391]                     muffleCondition(cond, pattern = "^muffle")
[16:01:41.391]                   }
[16:01:41.391]                 }
[16:01:41.391]                 else {
[16:01:41.391]                   if (TRUE) {
[16:01:41.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.391]                     {
[16:01:41.391]                       inherits <- base::inherits
[16:01:41.391]                       invokeRestart <- base::invokeRestart
[16:01:41.391]                       is.null <- base::is.null
[16:01:41.391]                       muffled <- FALSE
[16:01:41.391]                       if (inherits(cond, "message")) {
[16:01:41.391]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:41.391]                         if (muffled) 
[16:01:41.391]                           invokeRestart("muffleMessage")
[16:01:41.391]                       }
[16:01:41.391]                       else if (inherits(cond, "warning")) {
[16:01:41.391]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:41.391]                         if (muffled) 
[16:01:41.391]                           invokeRestart("muffleWarning")
[16:01:41.391]                       }
[16:01:41.391]                       else if (inherits(cond, "condition")) {
[16:01:41.391]                         if (!is.null(pattern)) {
[16:01:41.391]                           computeRestarts <- base::computeRestarts
[16:01:41.391]                           grepl <- base::grepl
[16:01:41.391]                           restarts <- computeRestarts(cond)
[16:01:41.391]                           for (restart in restarts) {
[16:01:41.391]                             name <- restart$name
[16:01:41.391]                             if (is.null(name)) 
[16:01:41.391]                               next
[16:01:41.391]                             if (!grepl(pattern, name)) 
[16:01:41.391]                               next
[16:01:41.391]                             invokeRestart(restart)
[16:01:41.391]                             muffled <- TRUE
[16:01:41.391]                             break
[16:01:41.391]                           }
[16:01:41.391]                         }
[16:01:41.391]                       }
[16:01:41.391]                       invisible(muffled)
[16:01:41.391]                     }
[16:01:41.391]                     muffleCondition(cond, pattern = "^muffle")
[16:01:41.391]                   }
[16:01:41.391]                 }
[16:01:41.391]             }
[16:01:41.391]         }))
[16:01:41.391]     }, error = function(ex) {
[16:01:41.391]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:41.391]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:41.391]                 ...future.rng), started = ...future.startTime, 
[16:01:41.391]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:41.391]             version = "1.8"), class = "FutureResult")
[16:01:41.391]     }, finally = {
[16:01:41.391]         if (!identical(...future.workdir, getwd())) 
[16:01:41.391]             setwd(...future.workdir)
[16:01:41.391]         {
[16:01:41.391]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:41.391]                 ...future.oldOptions$nwarnings <- NULL
[16:01:41.391]             }
[16:01:41.391]             base::options(...future.oldOptions)
[16:01:41.391]             if (.Platform$OS.type == "windows") {
[16:01:41.391]                 old_names <- names(...future.oldEnvVars)
[16:01:41.391]                 envs <- base::Sys.getenv()
[16:01:41.391]                 names <- names(envs)
[16:01:41.391]                 common <- intersect(names, old_names)
[16:01:41.391]                 added <- setdiff(names, old_names)
[16:01:41.391]                 removed <- setdiff(old_names, names)
[16:01:41.391]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:41.391]                   envs[common]]
[16:01:41.391]                 NAMES <- toupper(changed)
[16:01:41.391]                 args <- list()
[16:01:41.391]                 for (kk in seq_along(NAMES)) {
[16:01:41.391]                   name <- changed[[kk]]
[16:01:41.391]                   NAME <- NAMES[[kk]]
[16:01:41.391]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.391]                     next
[16:01:41.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:41.391]                 }
[16:01:41.391]                 NAMES <- toupper(added)
[16:01:41.391]                 for (kk in seq_along(NAMES)) {
[16:01:41.391]                   name <- added[[kk]]
[16:01:41.391]                   NAME <- NAMES[[kk]]
[16:01:41.391]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.391]                     next
[16:01:41.391]                   args[[name]] <- ""
[16:01:41.391]                 }
[16:01:41.391]                 NAMES <- toupper(removed)
[16:01:41.391]                 for (kk in seq_along(NAMES)) {
[16:01:41.391]                   name <- removed[[kk]]
[16:01:41.391]                   NAME <- NAMES[[kk]]
[16:01:41.391]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.391]                     next
[16:01:41.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:41.391]                 }
[16:01:41.391]                 if (length(args) > 0) 
[16:01:41.391]                   base::do.call(base::Sys.setenv, args = args)
[16:01:41.391]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:41.391]             }
[16:01:41.391]             else {
[16:01:41.391]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:41.391]             }
[16:01:41.391]             {
[16:01:41.391]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:41.391]                   0L) {
[16:01:41.391]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:41.391]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:41.391]                   base::options(opts)
[16:01:41.391]                 }
[16:01:41.391]                 {
[16:01:41.391]                   {
[16:01:41.391]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:41.391]                     NULL
[16:01:41.391]                   }
[16:01:41.391]                   options(future.plan = NULL)
[16:01:41.391]                   if (is.na(NA_character_)) 
[16:01:41.391]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:41.391]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:41.391]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:41.391]                     envir = parent.frame()) 
[16:01:41.391]                   {
[16:01:41.391]                     default_workers <- missing(workers)
[16:01:41.391]                     if (is.function(workers)) 
[16:01:41.391]                       workers <- workers()
[16:01:41.391]                     workers <- structure(as.integer(workers), 
[16:01:41.391]                       class = class(workers))
[16:01:41.391]                     stop_if_not(is.finite(workers), workers >= 
[16:01:41.391]                       1L)
[16:01:41.391]                     if ((workers == 1L && !inherits(workers, 
[16:01:41.391]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:41.391]                       if (default_workers) 
[16:01:41.391]                         supportsMulticore(warn = TRUE)
[16:01:41.391]                       return(sequential(..., envir = envir))
[16:01:41.391]                     }
[16:01:41.391]                     oopts <- options(mc.cores = workers)
[16:01:41.391]                     on.exit(options(oopts))
[16:01:41.391]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:41.391]                       envir = envir)
[16:01:41.391]                     if (!future$lazy) 
[16:01:41.391]                       future <- run(future)
[16:01:41.391]                     invisible(future)
[16:01:41.391]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:41.391]                 }
[16:01:41.391]             }
[16:01:41.391]         }
[16:01:41.391]     })
[16:01:41.391]     if (TRUE) {
[16:01:41.391]         base::sink(type = "output", split = FALSE)
[16:01:41.391]         if (TRUE) {
[16:01:41.391]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:41.391]         }
[16:01:41.391]         else {
[16:01:41.391]             ...future.result["stdout"] <- base::list(NULL)
[16:01:41.391]         }
[16:01:41.391]         base::close(...future.stdout)
[16:01:41.391]         ...future.stdout <- NULL
[16:01:41.391]     }
[16:01:41.391]     ...future.result$conditions <- ...future.conditions
[16:01:41.391]     ...future.result$finished <- base::Sys.time()
[16:01:41.391]     ...future.result
[16:01:41.391] }
[16:01:41.394] assign_globals() ...
[16:01:41.394] List of 5
[16:01:41.394]  $ future.call.arguments    : list()
[16:01:41.394]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:41.394]  $ ...future.FUN            :function (x)  
[16:01:41.394]  $ ...future.elements_ii    :List of 1
[16:01:41.394]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[16:01:41.394]  $ ...future.seeds_ii       : NULL
[16:01:41.394]  $ ...future.globals.maxSize: num Inf
[16:01:41.394]  - attr(*, "resolved")= logi FALSE
[16:01:41.394]  - attr(*, "total_size")= num NA
[16:01:41.394]  - attr(*, "where")=List of 5
[16:01:41.394]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:41.394]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:41.394]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:41.394]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:41.394]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:41.394]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:41.394]  - attr(*, "already-done")= logi TRUE
[16:01:41.399] - copied ‘future.call.arguments’ to environment
[16:01:41.399] - copied ‘...future.FUN’ to environment
[16:01:41.399] - copied ‘...future.elements_ii’ to environment
[16:01:41.400] - copied ‘...future.seeds_ii’ to environment
[16:01:41.400] - copied ‘...future.globals.maxSize’ to environment
[16:01:41.400] assign_globals() ... done
[16:01:41.400] requestCore(): workers = 2
[16:01:41.402] MulticoreFuture started
[16:01:41.402] - Launch lazy future ... done
[16:01:41.403] run() for ‘MulticoreFuture’ ... done
[16:01:41.403] Created future:
[16:01:41.403] plan(): Setting new future strategy stack:
[16:01:41.404] List of future strategies:
[16:01:41.404] 1. sequential:
[16:01:41.404]    - args: function (..., envir = parent.frame())
[16:01:41.404]    - tweaked: FALSE
[16:01:41.404]    - call: NULL
[16:01:41.404] plan(): nbrOfWorkers() = 1
[16:01:41.406] plan(): Setting new future strategy stack:
[16:01:41.406] List of future strategies:
[16:01:41.406] 1. multicore:
[16:01:41.406]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:41.406]    - tweaked: FALSE
[16:01:41.406]    - call: plan(strategy)
[16:01:41.412] plan(): nbrOfWorkers() = 2
[16:01:41.403] MulticoreFuture:
[16:01:41.403] Label: ‘future_apply-1’
[16:01:41.403] Expression:
[16:01:41.403] {
[16:01:41.403]     do.call(function(...) {
[16:01:41.403]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.403]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:41.403]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.403]             on.exit(options(oopts), add = TRUE)
[16:01:41.403]         }
[16:01:41.403]         {
[16:01:41.403]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:41.403]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.403]                 ...future.FUN(...future.X_jj, ...)
[16:01:41.403]             })
[16:01:41.403]         }
[16:01:41.403]     }, args = future.call.arguments)
[16:01:41.403] }
[16:01:41.403] Lazy evaluation: FALSE
[16:01:41.403] Asynchronous evaluation: TRUE
[16:01:41.403] Local evaluation: TRUE
[16:01:41.403] Environment: R_GlobalEnv
[16:01:41.403] Capture standard output: TRUE
[16:01:41.403] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:41.403] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:41.403] Packages: <none>
[16:01:41.403] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:41.403] Resolved: TRUE
[16:01:41.403] Value: <not collected>
[16:01:41.403] Conditions captured: <none>
[16:01:41.403] Early signaling: FALSE
[16:01:41.403] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:41.403] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:41.413] Chunk #1 of 2 ... DONE
[16:01:41.413] Chunk #2 of 2 ...
[16:01:41.413]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:41.413]  - seeds: <none>
[16:01:41.413]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.414] getGlobalsAndPackages() ...
[16:01:41.414] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.414] Resolving globals: FALSE
[16:01:41.414] Tweak future expression to call with '...' arguments ...
[16:01:41.414] {
[16:01:41.414]     do.call(function(...) {
[16:01:41.414]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.414]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:41.414]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.414]             on.exit(options(oopts), add = TRUE)
[16:01:41.414]         }
[16:01:41.414]         {
[16:01:41.414]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:41.414]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.414]                 ...future.FUN(...future.X_jj, ...)
[16:01:41.414]             })
[16:01:41.414]         }
[16:01:41.414]     }, args = future.call.arguments)
[16:01:41.414] }
[16:01:41.415] Tweak future expression to call with '...' arguments ... DONE
[16:01:41.416] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.416] 
[16:01:41.416] getGlobalsAndPackages() ... DONE
[16:01:41.416] run() for ‘Future’ ...
[16:01:41.417] - state: ‘created’
[16:01:41.417] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:41.422] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:41.422] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:41.422]   - Field: ‘label’
[16:01:41.422]   - Field: ‘local’
[16:01:41.422]   - Field: ‘owner’
[16:01:41.423]   - Field: ‘envir’
[16:01:41.423]   - Field: ‘workers’
[16:01:41.423]   - Field: ‘packages’
[16:01:41.423]   - Field: ‘gc’
[16:01:41.423]   - Field: ‘job’
[16:01:41.423]   - Field: ‘conditions’
[16:01:41.423]   - Field: ‘expr’
[16:01:41.424]   - Field: ‘uuid’
[16:01:41.424]   - Field: ‘seed’
[16:01:41.424]   - Field: ‘version’
[16:01:41.424]   - Field: ‘result’
[16:01:41.424]   - Field: ‘asynchronous’
[16:01:41.424]   - Field: ‘calls’
[16:01:41.424]   - Field: ‘globals’
[16:01:41.425]   - Field: ‘stdout’
[16:01:41.425]   - Field: ‘earlySignal’
[16:01:41.425]   - Field: ‘lazy’
[16:01:41.425]   - Field: ‘state’
[16:01:41.425] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:41.425] - Launch lazy future ...
[16:01:41.426] Packages needed by the future expression (n = 0): <none>
[16:01:41.426] Packages needed by future strategies (n = 0): <none>
[16:01:41.427] {
[16:01:41.427]     {
[16:01:41.427]         {
[16:01:41.427]             ...future.startTime <- base::Sys.time()
[16:01:41.427]             {
[16:01:41.427]                 {
[16:01:41.427]                   {
[16:01:41.427]                     {
[16:01:41.427]                       base::local({
[16:01:41.427]                         has_future <- base::requireNamespace("future", 
[16:01:41.427]                           quietly = TRUE)
[16:01:41.427]                         if (has_future) {
[16:01:41.427]                           ns <- base::getNamespace("future")
[16:01:41.427]                           version <- ns[[".package"]][["version"]]
[16:01:41.427]                           if (is.null(version)) 
[16:01:41.427]                             version <- utils::packageVersion("future")
[16:01:41.427]                         }
[16:01:41.427]                         else {
[16:01:41.427]                           version <- NULL
[16:01:41.427]                         }
[16:01:41.427]                         if (!has_future || version < "1.8.0") {
[16:01:41.427]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:41.427]                             "", base::R.version$version.string), 
[16:01:41.427]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:41.427]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:41.427]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:41.427]                               "release", "version")], collapse = " "), 
[16:01:41.427]                             hostname = base::Sys.info()[["nodename"]])
[16:01:41.427]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:41.427]                             info)
[16:01:41.427]                           info <- base::paste(info, collapse = "; ")
[16:01:41.427]                           if (!has_future) {
[16:01:41.427]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:41.427]                               info)
[16:01:41.427]                           }
[16:01:41.427]                           else {
[16:01:41.427]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:41.427]                               info, version)
[16:01:41.427]                           }
[16:01:41.427]                           base::stop(msg)
[16:01:41.427]                         }
[16:01:41.427]                       })
[16:01:41.427]                     }
[16:01:41.427]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:41.427]                     base::options(mc.cores = 1L)
[16:01:41.427]                   }
[16:01:41.427]                   options(future.plan = NULL)
[16:01:41.427]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:41.427]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:41.427]                 }
[16:01:41.427]                 ...future.workdir <- getwd()
[16:01:41.427]             }
[16:01:41.427]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:41.427]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:41.427]         }
[16:01:41.427]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:41.427]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:41.427]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:41.427]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:41.427]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:41.427]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:41.427]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:41.427]             base::names(...future.oldOptions))
[16:01:41.427]     }
[16:01:41.427]     if (FALSE) {
[16:01:41.427]     }
[16:01:41.427]     else {
[16:01:41.427]         if (TRUE) {
[16:01:41.427]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:41.427]                 open = "w")
[16:01:41.427]         }
[16:01:41.427]         else {
[16:01:41.427]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:41.427]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:41.427]         }
[16:01:41.427]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:41.427]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:41.427]             base::sink(type = "output", split = FALSE)
[16:01:41.427]             base::close(...future.stdout)
[16:01:41.427]         }, add = TRUE)
[16:01:41.427]     }
[16:01:41.427]     ...future.frame <- base::sys.nframe()
[16:01:41.427]     ...future.conditions <- base::list()
[16:01:41.427]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:41.427]     if (FALSE) {
[16:01:41.427]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:41.427]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:41.427]     }
[16:01:41.427]     ...future.result <- base::tryCatch({
[16:01:41.427]         base::withCallingHandlers({
[16:01:41.427]             ...future.value <- base::withVisible(base::local({
[16:01:41.427]                 withCallingHandlers({
[16:01:41.427]                   {
[16:01:41.427]                     do.call(function(...) {
[16:01:41.427]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.427]                       if (!identical(...future.globals.maxSize.org, 
[16:01:41.427]                         ...future.globals.maxSize)) {
[16:01:41.427]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.427]                         on.exit(options(oopts), add = TRUE)
[16:01:41.427]                       }
[16:01:41.427]                       {
[16:01:41.427]                         lapply(seq_along(...future.elements_ii), 
[16:01:41.427]                           FUN = function(jj) {
[16:01:41.427]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.427]                             ...future.FUN(...future.X_jj, ...)
[16:01:41.427]                           })
[16:01:41.427]                       }
[16:01:41.427]                     }, args = future.call.arguments)
[16:01:41.427]                   }
[16:01:41.427]                 }, immediateCondition = function(cond) {
[16:01:41.427]                   save_rds <- function (object, pathname, ...) 
[16:01:41.427]                   {
[16:01:41.427]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:41.427]                     if (file_test("-f", pathname_tmp)) {
[16:01:41.427]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.427]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:41.427]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.427]                         fi_tmp[["mtime"]])
[16:01:41.427]                     }
[16:01:41.427]                     tryCatch({
[16:01:41.427]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:41.427]                     }, error = function(ex) {
[16:01:41.427]                       msg <- conditionMessage(ex)
[16:01:41.427]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.427]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:41.427]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.427]                         fi_tmp[["mtime"]], msg)
[16:01:41.427]                       ex$message <- msg
[16:01:41.427]                       stop(ex)
[16:01:41.427]                     })
[16:01:41.427]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:41.427]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:41.427]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:41.427]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.427]                       fi <- file.info(pathname)
[16:01:41.427]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:41.427]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.427]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:41.427]                         fi[["size"]], fi[["mtime"]])
[16:01:41.427]                       stop(msg)
[16:01:41.427]                     }
[16:01:41.427]                     invisible(pathname)
[16:01:41.427]                   }
[16:01:41.427]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:41.427]                     rootPath = tempdir()) 
[16:01:41.427]                   {
[16:01:41.427]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:41.427]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:41.427]                       tmpdir = path, fileext = ".rds")
[16:01:41.427]                     save_rds(obj, file)
[16:01:41.427]                   }
[16:01:41.427]                   saveImmediateCondition(cond, path = "/tmp/RtmplAoKyr/.future/immediateConditions")
[16:01:41.427]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.427]                   {
[16:01:41.427]                     inherits <- base::inherits
[16:01:41.427]                     invokeRestart <- base::invokeRestart
[16:01:41.427]                     is.null <- base::is.null
[16:01:41.427]                     muffled <- FALSE
[16:01:41.427]                     if (inherits(cond, "message")) {
[16:01:41.427]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:41.427]                       if (muffled) 
[16:01:41.427]                         invokeRestart("muffleMessage")
[16:01:41.427]                     }
[16:01:41.427]                     else if (inherits(cond, "warning")) {
[16:01:41.427]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:41.427]                       if (muffled) 
[16:01:41.427]                         invokeRestart("muffleWarning")
[16:01:41.427]                     }
[16:01:41.427]                     else if (inherits(cond, "condition")) {
[16:01:41.427]                       if (!is.null(pattern)) {
[16:01:41.427]                         computeRestarts <- base::computeRestarts
[16:01:41.427]                         grepl <- base::grepl
[16:01:41.427]                         restarts <- computeRestarts(cond)
[16:01:41.427]                         for (restart in restarts) {
[16:01:41.427]                           name <- restart$name
[16:01:41.427]                           if (is.null(name)) 
[16:01:41.427]                             next
[16:01:41.427]                           if (!grepl(pattern, name)) 
[16:01:41.427]                             next
[16:01:41.427]                           invokeRestart(restart)
[16:01:41.427]                           muffled <- TRUE
[16:01:41.427]                           break
[16:01:41.427]                         }
[16:01:41.427]                       }
[16:01:41.427]                     }
[16:01:41.427]                     invisible(muffled)
[16:01:41.427]                   }
[16:01:41.427]                   muffleCondition(cond)
[16:01:41.427]                 })
[16:01:41.427]             }))
[16:01:41.427]             future::FutureResult(value = ...future.value$value, 
[16:01:41.427]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:41.427]                   ...future.rng), globalenv = if (FALSE) 
[16:01:41.427]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:41.427]                     ...future.globalenv.names))
[16:01:41.427]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:41.427]         }, condition = base::local({
[16:01:41.427]             c <- base::c
[16:01:41.427]             inherits <- base::inherits
[16:01:41.427]             invokeRestart <- base::invokeRestart
[16:01:41.427]             length <- base::length
[16:01:41.427]             list <- base::list
[16:01:41.427]             seq.int <- base::seq.int
[16:01:41.427]             signalCondition <- base::signalCondition
[16:01:41.427]             sys.calls <- base::sys.calls
[16:01:41.427]             `[[` <- base::`[[`
[16:01:41.427]             `+` <- base::`+`
[16:01:41.427]             `<<-` <- base::`<<-`
[16:01:41.427]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:41.427]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:41.427]                   3L)]
[16:01:41.427]             }
[16:01:41.427]             function(cond) {
[16:01:41.427]                 is_error <- inherits(cond, "error")
[16:01:41.427]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:41.427]                   NULL)
[16:01:41.427]                 if (is_error) {
[16:01:41.427]                   sessionInformation <- function() {
[16:01:41.427]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:41.427]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:41.427]                       search = base::search(), system = base::Sys.info())
[16:01:41.427]                   }
[16:01:41.427]                   ...future.conditions[[length(...future.conditions) + 
[16:01:41.427]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:41.427]                     cond$call), session = sessionInformation(), 
[16:01:41.427]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:41.427]                   signalCondition(cond)
[16:01:41.427]                 }
[16:01:41.427]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:41.427]                 "immediateCondition"))) {
[16:01:41.427]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:41.427]                   ...future.conditions[[length(...future.conditions) + 
[16:01:41.427]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:41.427]                   if (TRUE && !signal) {
[16:01:41.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.427]                     {
[16:01:41.427]                       inherits <- base::inherits
[16:01:41.427]                       invokeRestart <- base::invokeRestart
[16:01:41.427]                       is.null <- base::is.null
[16:01:41.427]                       muffled <- FALSE
[16:01:41.427]                       if (inherits(cond, "message")) {
[16:01:41.427]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:41.427]                         if (muffled) 
[16:01:41.427]                           invokeRestart("muffleMessage")
[16:01:41.427]                       }
[16:01:41.427]                       else if (inherits(cond, "warning")) {
[16:01:41.427]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:41.427]                         if (muffled) 
[16:01:41.427]                           invokeRestart("muffleWarning")
[16:01:41.427]                       }
[16:01:41.427]                       else if (inherits(cond, "condition")) {
[16:01:41.427]                         if (!is.null(pattern)) {
[16:01:41.427]                           computeRestarts <- base::computeRestarts
[16:01:41.427]                           grepl <- base::grepl
[16:01:41.427]                           restarts <- computeRestarts(cond)
[16:01:41.427]                           for (restart in restarts) {
[16:01:41.427]                             name <- restart$name
[16:01:41.427]                             if (is.null(name)) 
[16:01:41.427]                               next
[16:01:41.427]                             if (!grepl(pattern, name)) 
[16:01:41.427]                               next
[16:01:41.427]                             invokeRestart(restart)
[16:01:41.427]                             muffled <- TRUE
[16:01:41.427]                             break
[16:01:41.427]                           }
[16:01:41.427]                         }
[16:01:41.427]                       }
[16:01:41.427]                       invisible(muffled)
[16:01:41.427]                     }
[16:01:41.427]                     muffleCondition(cond, pattern = "^muffle")
[16:01:41.427]                   }
[16:01:41.427]                 }
[16:01:41.427]                 else {
[16:01:41.427]                   if (TRUE) {
[16:01:41.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.427]                     {
[16:01:41.427]                       inherits <- base::inherits
[16:01:41.427]                       invokeRestart <- base::invokeRestart
[16:01:41.427]                       is.null <- base::is.null
[16:01:41.427]                       muffled <- FALSE
[16:01:41.427]                       if (inherits(cond, "message")) {
[16:01:41.427]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:41.427]                         if (muffled) 
[16:01:41.427]                           invokeRestart("muffleMessage")
[16:01:41.427]                       }
[16:01:41.427]                       else if (inherits(cond, "warning")) {
[16:01:41.427]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:41.427]                         if (muffled) 
[16:01:41.427]                           invokeRestart("muffleWarning")
[16:01:41.427]                       }
[16:01:41.427]                       else if (inherits(cond, "condition")) {
[16:01:41.427]                         if (!is.null(pattern)) {
[16:01:41.427]                           computeRestarts <- base::computeRestarts
[16:01:41.427]                           grepl <- base::grepl
[16:01:41.427]                           restarts <- computeRestarts(cond)
[16:01:41.427]                           for (restart in restarts) {
[16:01:41.427]                             name <- restart$name
[16:01:41.427]                             if (is.null(name)) 
[16:01:41.427]                               next
[16:01:41.427]                             if (!grepl(pattern, name)) 
[16:01:41.427]                               next
[16:01:41.427]                             invokeRestart(restart)
[16:01:41.427]                             muffled <- TRUE
[16:01:41.427]                             break
[16:01:41.427]                           }
[16:01:41.427]                         }
[16:01:41.427]                       }
[16:01:41.427]                       invisible(muffled)
[16:01:41.427]                     }
[16:01:41.427]                     muffleCondition(cond, pattern = "^muffle")
[16:01:41.427]                   }
[16:01:41.427]                 }
[16:01:41.427]             }
[16:01:41.427]         }))
[16:01:41.427]     }, error = function(ex) {
[16:01:41.427]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:41.427]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:41.427]                 ...future.rng), started = ...future.startTime, 
[16:01:41.427]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:41.427]             version = "1.8"), class = "FutureResult")
[16:01:41.427]     }, finally = {
[16:01:41.427]         if (!identical(...future.workdir, getwd())) 
[16:01:41.427]             setwd(...future.workdir)
[16:01:41.427]         {
[16:01:41.427]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:41.427]                 ...future.oldOptions$nwarnings <- NULL
[16:01:41.427]             }
[16:01:41.427]             base::options(...future.oldOptions)
[16:01:41.427]             if (.Platform$OS.type == "windows") {
[16:01:41.427]                 old_names <- names(...future.oldEnvVars)
[16:01:41.427]                 envs <- base::Sys.getenv()
[16:01:41.427]                 names <- names(envs)
[16:01:41.427]                 common <- intersect(names, old_names)
[16:01:41.427]                 added <- setdiff(names, old_names)
[16:01:41.427]                 removed <- setdiff(old_names, names)
[16:01:41.427]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:41.427]                   envs[common]]
[16:01:41.427]                 NAMES <- toupper(changed)
[16:01:41.427]                 args <- list()
[16:01:41.427]                 for (kk in seq_along(NAMES)) {
[16:01:41.427]                   name <- changed[[kk]]
[16:01:41.427]                   NAME <- NAMES[[kk]]
[16:01:41.427]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.427]                     next
[16:01:41.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:41.427]                 }
[16:01:41.427]                 NAMES <- toupper(added)
[16:01:41.427]                 for (kk in seq_along(NAMES)) {
[16:01:41.427]                   name <- added[[kk]]
[16:01:41.427]                   NAME <- NAMES[[kk]]
[16:01:41.427]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.427]                     next
[16:01:41.427]                   args[[name]] <- ""
[16:01:41.427]                 }
[16:01:41.427]                 NAMES <- toupper(removed)
[16:01:41.427]                 for (kk in seq_along(NAMES)) {
[16:01:41.427]                   name <- removed[[kk]]
[16:01:41.427]                   NAME <- NAMES[[kk]]
[16:01:41.427]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.427]                     next
[16:01:41.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:41.427]                 }
[16:01:41.427]                 if (length(args) > 0) 
[16:01:41.427]                   base::do.call(base::Sys.setenv, args = args)
[16:01:41.427]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:41.427]             }
[16:01:41.427]             else {
[16:01:41.427]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:41.427]             }
[16:01:41.427]             {
[16:01:41.427]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:41.427]                   0L) {
[16:01:41.427]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:41.427]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:41.427]                   base::options(opts)
[16:01:41.427]                 }
[16:01:41.427]                 {
[16:01:41.427]                   {
[16:01:41.427]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:41.427]                     NULL
[16:01:41.427]                   }
[16:01:41.427]                   options(future.plan = NULL)
[16:01:41.427]                   if (is.na(NA_character_)) 
[16:01:41.427]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:41.427]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:41.427]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:41.427]                     envir = parent.frame()) 
[16:01:41.427]                   {
[16:01:41.427]                     default_workers <- missing(workers)
[16:01:41.427]                     if (is.function(workers)) 
[16:01:41.427]                       workers <- workers()
[16:01:41.427]                     workers <- structure(as.integer(workers), 
[16:01:41.427]                       class = class(workers))
[16:01:41.427]                     stop_if_not(is.finite(workers), workers >= 
[16:01:41.427]                       1L)
[16:01:41.427]                     if ((workers == 1L && !inherits(workers, 
[16:01:41.427]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:41.427]                       if (default_workers) 
[16:01:41.427]                         supportsMulticore(warn = TRUE)
[16:01:41.427]                       return(sequential(..., envir = envir))
[16:01:41.427]                     }
[16:01:41.427]                     oopts <- options(mc.cores = workers)
[16:01:41.427]                     on.exit(options(oopts))
[16:01:41.427]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:41.427]                       envir = envir)
[16:01:41.427]                     if (!future$lazy) 
[16:01:41.427]                       future <- run(future)
[16:01:41.427]                     invisible(future)
[16:01:41.427]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:41.427]                 }
[16:01:41.427]             }
[16:01:41.427]         }
[16:01:41.427]     })
[16:01:41.427]     if (TRUE) {
[16:01:41.427]         base::sink(type = "output", split = FALSE)
[16:01:41.427]         if (TRUE) {
[16:01:41.427]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:41.427]         }
[16:01:41.427]         else {
[16:01:41.427]             ...future.result["stdout"] <- base::list(NULL)
[16:01:41.427]         }
[16:01:41.427]         base::close(...future.stdout)
[16:01:41.427]         ...future.stdout <- NULL
[16:01:41.427]     }
[16:01:41.427]     ...future.result$conditions <- ...future.conditions
[16:01:41.427]     ...future.result$finished <- base::Sys.time()
[16:01:41.427]     ...future.result
[16:01:41.427] }
[16:01:41.430] assign_globals() ...
[16:01:41.430] List of 5
[16:01:41.430]  $ future.call.arguments    : list()
[16:01:41.430]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:41.430]  $ ...future.FUN            :function (x)  
[16:01:41.430]  $ ...future.elements_ii    :List of 1
[16:01:41.430]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[16:01:41.430]  $ ...future.seeds_ii       : NULL
[16:01:41.430]  $ ...future.globals.maxSize: num Inf
[16:01:41.430]  - attr(*, "resolved")= logi FALSE
[16:01:41.430]  - attr(*, "total_size")= num NA
[16:01:41.430]  - attr(*, "where")=List of 5
[16:01:41.430]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:41.430]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:41.430]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:41.430]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:41.430]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:41.430]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:41.430]  - attr(*, "already-done")= logi TRUE
[16:01:41.444] - copied ‘future.call.arguments’ to environment
[16:01:41.444] - copied ‘...future.FUN’ to environment
[16:01:41.445] - copied ‘...future.elements_ii’ to environment
[16:01:41.445] - copied ‘...future.seeds_ii’ to environment
[16:01:41.445] - copied ‘...future.globals.maxSize’ to environment
[16:01:41.445] assign_globals() ... done
[16:01:41.445] requestCore(): workers = 2
[16:01:41.448] MulticoreFuture started
[16:01:41.448] - Launch lazy future ... done
[16:01:41.449] run() for ‘MulticoreFuture’ ... done
[16:01:41.449] Created future:
[16:01:41.449] plan(): Setting new future strategy stack:
[16:01:41.449] List of future strategies:
[16:01:41.449] 1. sequential:
[16:01:41.449]    - args: function (..., envir = parent.frame())
[16:01:41.449]    - tweaked: FALSE
[16:01:41.449]    - call: NULL
[16:01:41.450] plan(): nbrOfWorkers() = 1
[16:01:41.453] plan(): Setting new future strategy stack:
[16:01:41.453] List of future strategies:
[16:01:41.453] 1. multicore:
[16:01:41.453]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:41.453]    - tweaked: FALSE
[16:01:41.453]    - call: plan(strategy)
[16:01:41.459] plan(): nbrOfWorkers() = 2
[16:01:41.449] MulticoreFuture:
[16:01:41.449] Label: ‘future_apply-2’
[16:01:41.449] Expression:
[16:01:41.449] {
[16:01:41.449]     do.call(function(...) {
[16:01:41.449]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.449]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:41.449]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.449]             on.exit(options(oopts), add = TRUE)
[16:01:41.449]         }
[16:01:41.449]         {
[16:01:41.449]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:41.449]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.449]                 ...future.FUN(...future.X_jj, ...)
[16:01:41.449]             })
[16:01:41.449]         }
[16:01:41.449]     }, args = future.call.arguments)
[16:01:41.449] }
[16:01:41.449] Lazy evaluation: FALSE
[16:01:41.449] Asynchronous evaluation: TRUE
[16:01:41.449] Local evaluation: TRUE
[16:01:41.449] Environment: R_GlobalEnv
[16:01:41.449] Capture standard output: TRUE
[16:01:41.449] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:41.449] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:41.449] Packages: <none>
[16:01:41.449] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:41.449] Resolved: TRUE
[16:01:41.449] Value: <not collected>
[16:01:41.449] Conditions captured: <none>
[16:01:41.449] Early signaling: FALSE
[16:01:41.449] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:41.449] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:41.460] Chunk #2 of 2 ... DONE
[16:01:41.460] Launching 2 futures (chunks) ... DONE
[16:01:41.460] Resolving 2 futures (chunks) ...
[16:01:41.461] resolve() on list ...
[16:01:41.461]  recursive: 0
[16:01:41.461]  length: 2
[16:01:41.461] 
[16:01:41.462] Future #1
[16:01:41.462] result() for MulticoreFuture ...
[16:01:41.463] result() for MulticoreFuture ...
[16:01:41.463] result() for MulticoreFuture ... done
[16:01:41.463] result() for MulticoreFuture ... done
[16:01:41.463] result() for MulticoreFuture ...
[16:01:41.464] result() for MulticoreFuture ... done
[16:01:41.464] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:01:41.464] - nx: 2
[16:01:41.464] - relay: TRUE
[16:01:41.465] - stdout: TRUE
[16:01:41.465] - signal: TRUE
[16:01:41.465] - resignal: FALSE
[16:01:41.465] - force: TRUE
[16:01:41.465] - relayed: [n=2] FALSE, FALSE
[16:01:41.465] - queued futures: [n=2] FALSE, FALSE
[16:01:41.466]  - until=1
[16:01:41.466]  - relaying element #1
[16:01:41.466] result() for MulticoreFuture ...
[16:01:41.466] result() for MulticoreFuture ... done
[16:01:41.467] result() for MulticoreFuture ...
[16:01:41.467] result() for MulticoreFuture ... done
[16:01:41.467] result() for MulticoreFuture ...
[16:01:41.467] result() for MulticoreFuture ... done
[16:01:41.468] result() for MulticoreFuture ...
[16:01:41.468] result() for MulticoreFuture ... done
[16:01:41.468] - relayed: [n=2] TRUE, FALSE
[16:01:41.468] - queued futures: [n=2] TRUE, FALSE
[16:01:41.468] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:01:41.468]  length: 1 (resolved future 1)
[16:01:41.469] Future #2
[16:01:41.469] result() for MulticoreFuture ...
[16:01:41.470] result() for MulticoreFuture ...
[16:01:41.470] result() for MulticoreFuture ... done
[16:01:41.470] result() for MulticoreFuture ... done
[16:01:41.470] result() for MulticoreFuture ...
[16:01:41.470] result() for MulticoreFuture ... done
[16:01:41.470] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:01:41.470] - nx: 2
[16:01:41.471] - relay: TRUE
[16:01:41.471] - stdout: TRUE
[16:01:41.471] - signal: TRUE
[16:01:41.471] - resignal: FALSE
[16:01:41.471] - force: TRUE
[16:01:41.471] - relayed: [n=2] TRUE, FALSE
[16:01:41.471] - queued futures: [n=2] TRUE, FALSE
[16:01:41.471]  - until=2
[16:01:41.472]  - relaying element #2
[16:01:41.472] result() for MulticoreFuture ...
[16:01:41.472] result() for MulticoreFuture ... done
[16:01:41.472] result() for MulticoreFuture ...
[16:01:41.472] result() for MulticoreFuture ... done
[16:01:41.472] result() for MulticoreFuture ...
[16:01:41.472] result() for MulticoreFuture ... done
[16:01:41.473] result() for MulticoreFuture ...
[16:01:41.473] result() for MulticoreFuture ... done
[16:01:41.473] - relayed: [n=2] TRUE, TRUE
[16:01:41.473] - queued futures: [n=2] TRUE, TRUE
[16:01:41.473] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:01:41.473]  length: 0 (resolved future 2)
[16:01:41.473] Relaying remaining futures
[16:01:41.473] signalConditionsASAP(NULL, pos=0) ...
[16:01:41.473] - nx: 2
[16:01:41.474] - relay: TRUE
[16:01:41.474] - stdout: TRUE
[16:01:41.474] - signal: TRUE
[16:01:41.474] - resignal: FALSE
[16:01:41.474] - force: TRUE
[16:01:41.474] - relayed: [n=2] TRUE, TRUE
[16:01:41.474] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:41.474] - relayed: [n=2] TRUE, TRUE
[16:01:41.474] - queued futures: [n=2] TRUE, TRUE
[16:01:41.475] signalConditionsASAP(NULL, pos=0) ... done
[16:01:41.475] resolve() on list ... DONE
[16:01:41.475] result() for MulticoreFuture ...
[16:01:41.475] result() for MulticoreFuture ... done
[16:01:41.475] result() for MulticoreFuture ...
[16:01:41.475] result() for MulticoreFuture ... done
[16:01:41.475] result() for MulticoreFuture ...
[16:01:41.475] result() for MulticoreFuture ... done
[16:01:41.476] result() for MulticoreFuture ...
[16:01:41.476] result() for MulticoreFuture ... done
[16:01:41.476]  - Number of value chunks collected: 2
[16:01:41.476] Resolving 2 futures (chunks) ... DONE
[16:01:41.476] Reducing values from 2 chunks ...
[16:01:41.476]  - Number of values collected after concatenation: 2
[16:01:41.476]  - Number of values expected: 2
[16:01:41.476] Reducing values from 2 chunks ... DONE
[16:01:41.476] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[16:01:41.477] getGlobalsAndPackagesXApply() ...
[16:01:41.477]  - future.globals: TRUE
[16:01:41.477] getGlobalsAndPackages() ...
[16:01:41.477] Searching for globals...
[16:01:41.483] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[16:01:41.483] Searching for globals ... DONE
[16:01:41.483] Resolving globals: FALSE
[16:01:41.484] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[16:01:41.485] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[16:01:41.485] - globals: [1] ‘FUN’
[16:01:41.485] 
[16:01:41.485] getGlobalsAndPackages() ... DONE
[16:01:41.485]  - globals found/used: [n=1] ‘FUN’
[16:01:41.486]  - needed namespaces: [n=0] 
[16:01:41.486] Finding globals ... DONE
[16:01:41.486]  - use_args: TRUE
[16:01:41.486]  - Getting '...' globals ...
[16:01:41.486] resolve() on list ...
[16:01:41.487]  recursive: 0
[16:01:41.487]  length: 1
[16:01:41.487]  elements: ‘...’
[16:01:41.487]  length: 0 (resolved future 1)
[16:01:41.487] resolve() on list ... DONE
[16:01:41.487]    - '...' content: [n=0] 
[16:01:41.487] List of 1
[16:01:41.487]  $ ...: list()
[16:01:41.487]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:41.487]  - attr(*, "where")=List of 1
[16:01:41.487]   ..$ ...:<environment: 0x55fb648edad0> 
[16:01:41.487]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:41.487]  - attr(*, "resolved")= logi TRUE
[16:01:41.487]  - attr(*, "total_size")= num NA
[16:01:41.490]  - Getting '...' globals ... DONE
[16:01:41.490] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:41.491] List of 2
[16:01:41.491]  $ ...future.FUN:function (x)  
[16:01:41.491]  $ ...          : list()
[16:01:41.491]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:41.491]  - attr(*, "where")=List of 2
[16:01:41.491]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:41.491]   ..$ ...          :<environment: 0x55fb648edad0> 
[16:01:41.491]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:41.491]  - attr(*, "resolved")= logi FALSE
[16:01:41.491]  - attr(*, "total_size")= num 9888
[16:01:41.493] Packages to be attached in all futures: [n=0] 
[16:01:41.493] getGlobalsAndPackagesXApply() ... DONE
[16:01:41.497] future_lapply() ...
[16:01:41.502] Number of chunks: 2
[16:01:41.502] getGlobalsAndPackagesXApply() ...
[16:01:41.502]  - future.globals: <name-value list> with names ‘list()’
[16:01:41.502]  - use_args: TRUE
[16:01:41.503] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:01:41.503] List of 2
[16:01:41.503]  $ ...          : list()
[16:01:41.503]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:41.503]  $ ...future.FUN:function (x)  
[16:01:41.503]  - attr(*, "where")=List of 2
[16:01:41.503]   ..$ ...          :<environment: 0x55fb648edad0> 
[16:01:41.503]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[16:01:41.503]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:41.503]  - attr(*, "resolved")= logi FALSE
[16:01:41.503]  - attr(*, "total_size")= num NA
[16:01:41.506] Packages to be attached in all futures: [n=0] 
[16:01:41.506] getGlobalsAndPackagesXApply() ... DONE
[16:01:41.506] Number of futures (= number of chunks): 2
[16:01:41.506] Launching 2 futures (chunks) ...
[16:01:41.506] Chunk #1 of 2 ...
[16:01:41.506]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:41.506]  - seeds: <none>
[16:01:41.506]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.507] getGlobalsAndPackages() ...
[16:01:41.507] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.507] Resolving globals: FALSE
[16:01:41.507] Tweak future expression to call with '...' arguments ...
[16:01:41.507] {
[16:01:41.507]     do.call(function(...) {
[16:01:41.507]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.507]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:41.507]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.507]             on.exit(options(oopts), add = TRUE)
[16:01:41.507]         }
[16:01:41.507]         {
[16:01:41.507]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:41.507]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.507]                 ...future.FUN(...future.X_jj, ...)
[16:01:41.507]             })
[16:01:41.507]         }
[16:01:41.507]     }, args = future.call.arguments)
[16:01:41.507] }
[16:01:41.507] Tweak future expression to call with '...' arguments ... DONE
[16:01:41.510] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.510] 
[16:01:41.510] getGlobalsAndPackages() ... DONE
[16:01:41.510] run() for ‘Future’ ...
[16:01:41.510] - state: ‘created’
[16:01:41.511] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:41.514] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:41.515] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:41.515]   - Field: ‘label’
[16:01:41.515]   - Field: ‘local’
[16:01:41.515]   - Field: ‘owner’
[16:01:41.515]   - Field: ‘envir’
[16:01:41.515]   - Field: ‘workers’
[16:01:41.515]   - Field: ‘packages’
[16:01:41.516]   - Field: ‘gc’
[16:01:41.516]   - Field: ‘job’
[16:01:41.516]   - Field: ‘conditions’
[16:01:41.516]   - Field: ‘expr’
[16:01:41.516]   - Field: ‘uuid’
[16:01:41.516]   - Field: ‘seed’
[16:01:41.516]   - Field: ‘version’
[16:01:41.516]   - Field: ‘result’
[16:01:41.516]   - Field: ‘asynchronous’
[16:01:41.516]   - Field: ‘calls’
[16:01:41.517]   - Field: ‘globals’
[16:01:41.517]   - Field: ‘stdout’
[16:01:41.517]   - Field: ‘earlySignal’
[16:01:41.517]   - Field: ‘lazy’
[16:01:41.517]   - Field: ‘state’
[16:01:41.517] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:41.517] - Launch lazy future ...
[16:01:41.517] Packages needed by the future expression (n = 0): <none>
[16:01:41.518] Packages needed by future strategies (n = 0): <none>
[16:01:41.518] {
[16:01:41.518]     {
[16:01:41.518]         {
[16:01:41.518]             ...future.startTime <- base::Sys.time()
[16:01:41.518]             {
[16:01:41.518]                 {
[16:01:41.518]                   {
[16:01:41.518]                     {
[16:01:41.518]                       base::local({
[16:01:41.518]                         has_future <- base::requireNamespace("future", 
[16:01:41.518]                           quietly = TRUE)
[16:01:41.518]                         if (has_future) {
[16:01:41.518]                           ns <- base::getNamespace("future")
[16:01:41.518]                           version <- ns[[".package"]][["version"]]
[16:01:41.518]                           if (is.null(version)) 
[16:01:41.518]                             version <- utils::packageVersion("future")
[16:01:41.518]                         }
[16:01:41.518]                         else {
[16:01:41.518]                           version <- NULL
[16:01:41.518]                         }
[16:01:41.518]                         if (!has_future || version < "1.8.0") {
[16:01:41.518]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:41.518]                             "", base::R.version$version.string), 
[16:01:41.518]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:41.518]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:41.518]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:41.518]                               "release", "version")], collapse = " "), 
[16:01:41.518]                             hostname = base::Sys.info()[["nodename"]])
[16:01:41.518]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:41.518]                             info)
[16:01:41.518]                           info <- base::paste(info, collapse = "; ")
[16:01:41.518]                           if (!has_future) {
[16:01:41.518]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:41.518]                               info)
[16:01:41.518]                           }
[16:01:41.518]                           else {
[16:01:41.518]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:41.518]                               info, version)
[16:01:41.518]                           }
[16:01:41.518]                           base::stop(msg)
[16:01:41.518]                         }
[16:01:41.518]                       })
[16:01:41.518]                     }
[16:01:41.518]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:41.518]                     base::options(mc.cores = 1L)
[16:01:41.518]                   }
[16:01:41.518]                   options(future.plan = NULL)
[16:01:41.518]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:41.518]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:41.518]                 }
[16:01:41.518]                 ...future.workdir <- getwd()
[16:01:41.518]             }
[16:01:41.518]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:41.518]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:41.518]         }
[16:01:41.518]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:41.518]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:41.518]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:41.518]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:41.518]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:41.518]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:41.518]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:41.518]             base::names(...future.oldOptions))
[16:01:41.518]     }
[16:01:41.518]     if (FALSE) {
[16:01:41.518]     }
[16:01:41.518]     else {
[16:01:41.518]         if (TRUE) {
[16:01:41.518]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:41.518]                 open = "w")
[16:01:41.518]         }
[16:01:41.518]         else {
[16:01:41.518]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:41.518]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:41.518]         }
[16:01:41.518]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:41.518]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:41.518]             base::sink(type = "output", split = FALSE)
[16:01:41.518]             base::close(...future.stdout)
[16:01:41.518]         }, add = TRUE)
[16:01:41.518]     }
[16:01:41.518]     ...future.frame <- base::sys.nframe()
[16:01:41.518]     ...future.conditions <- base::list()
[16:01:41.518]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:41.518]     if (FALSE) {
[16:01:41.518]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:41.518]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:41.518]     }
[16:01:41.518]     ...future.result <- base::tryCatch({
[16:01:41.518]         base::withCallingHandlers({
[16:01:41.518]             ...future.value <- base::withVisible(base::local({
[16:01:41.518]                 withCallingHandlers({
[16:01:41.518]                   {
[16:01:41.518]                     do.call(function(...) {
[16:01:41.518]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.518]                       if (!identical(...future.globals.maxSize.org, 
[16:01:41.518]                         ...future.globals.maxSize)) {
[16:01:41.518]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.518]                         on.exit(options(oopts), add = TRUE)
[16:01:41.518]                       }
[16:01:41.518]                       {
[16:01:41.518]                         lapply(seq_along(...future.elements_ii), 
[16:01:41.518]                           FUN = function(jj) {
[16:01:41.518]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.518]                             ...future.FUN(...future.X_jj, ...)
[16:01:41.518]                           })
[16:01:41.518]                       }
[16:01:41.518]                     }, args = future.call.arguments)
[16:01:41.518]                   }
[16:01:41.518]                 }, immediateCondition = function(cond) {
[16:01:41.518]                   save_rds <- function (object, pathname, ...) 
[16:01:41.518]                   {
[16:01:41.518]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:41.518]                     if (file_test("-f", pathname_tmp)) {
[16:01:41.518]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.518]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:41.518]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.518]                         fi_tmp[["mtime"]])
[16:01:41.518]                     }
[16:01:41.518]                     tryCatch({
[16:01:41.518]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:41.518]                     }, error = function(ex) {
[16:01:41.518]                       msg <- conditionMessage(ex)
[16:01:41.518]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.518]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:41.518]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.518]                         fi_tmp[["mtime"]], msg)
[16:01:41.518]                       ex$message <- msg
[16:01:41.518]                       stop(ex)
[16:01:41.518]                     })
[16:01:41.518]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:41.518]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:41.518]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:41.518]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.518]                       fi <- file.info(pathname)
[16:01:41.518]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:41.518]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.518]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:41.518]                         fi[["size"]], fi[["mtime"]])
[16:01:41.518]                       stop(msg)
[16:01:41.518]                     }
[16:01:41.518]                     invisible(pathname)
[16:01:41.518]                   }
[16:01:41.518]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:41.518]                     rootPath = tempdir()) 
[16:01:41.518]                   {
[16:01:41.518]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:41.518]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:41.518]                       tmpdir = path, fileext = ".rds")
[16:01:41.518]                     save_rds(obj, file)
[16:01:41.518]                   }
[16:01:41.518]                   saveImmediateCondition(cond, path = "/tmp/RtmplAoKyr/.future/immediateConditions")
[16:01:41.518]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.518]                   {
[16:01:41.518]                     inherits <- base::inherits
[16:01:41.518]                     invokeRestart <- base::invokeRestart
[16:01:41.518]                     is.null <- base::is.null
[16:01:41.518]                     muffled <- FALSE
[16:01:41.518]                     if (inherits(cond, "message")) {
[16:01:41.518]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:41.518]                       if (muffled) 
[16:01:41.518]                         invokeRestart("muffleMessage")
[16:01:41.518]                     }
[16:01:41.518]                     else if (inherits(cond, "warning")) {
[16:01:41.518]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:41.518]                       if (muffled) 
[16:01:41.518]                         invokeRestart("muffleWarning")
[16:01:41.518]                     }
[16:01:41.518]                     else if (inherits(cond, "condition")) {
[16:01:41.518]                       if (!is.null(pattern)) {
[16:01:41.518]                         computeRestarts <- base::computeRestarts
[16:01:41.518]                         grepl <- base::grepl
[16:01:41.518]                         restarts <- computeRestarts(cond)
[16:01:41.518]                         for (restart in restarts) {
[16:01:41.518]                           name <- restart$name
[16:01:41.518]                           if (is.null(name)) 
[16:01:41.518]                             next
[16:01:41.518]                           if (!grepl(pattern, name)) 
[16:01:41.518]                             next
[16:01:41.518]                           invokeRestart(restart)
[16:01:41.518]                           muffled <- TRUE
[16:01:41.518]                           break
[16:01:41.518]                         }
[16:01:41.518]                       }
[16:01:41.518]                     }
[16:01:41.518]                     invisible(muffled)
[16:01:41.518]                   }
[16:01:41.518]                   muffleCondition(cond)
[16:01:41.518]                 })
[16:01:41.518]             }))
[16:01:41.518]             future::FutureResult(value = ...future.value$value, 
[16:01:41.518]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:41.518]                   ...future.rng), globalenv = if (FALSE) 
[16:01:41.518]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:41.518]                     ...future.globalenv.names))
[16:01:41.518]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:41.518]         }, condition = base::local({
[16:01:41.518]             c <- base::c
[16:01:41.518]             inherits <- base::inherits
[16:01:41.518]             invokeRestart <- base::invokeRestart
[16:01:41.518]             length <- base::length
[16:01:41.518]             list <- base::list
[16:01:41.518]             seq.int <- base::seq.int
[16:01:41.518]             signalCondition <- base::signalCondition
[16:01:41.518]             sys.calls <- base::sys.calls
[16:01:41.518]             `[[` <- base::`[[`
[16:01:41.518]             `+` <- base::`+`
[16:01:41.518]             `<<-` <- base::`<<-`
[16:01:41.518]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:41.518]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:41.518]                   3L)]
[16:01:41.518]             }
[16:01:41.518]             function(cond) {
[16:01:41.518]                 is_error <- inherits(cond, "error")
[16:01:41.518]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:41.518]                   NULL)
[16:01:41.518]                 if (is_error) {
[16:01:41.518]                   sessionInformation <- function() {
[16:01:41.518]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:41.518]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:41.518]                       search = base::search(), system = base::Sys.info())
[16:01:41.518]                   }
[16:01:41.518]                   ...future.conditions[[length(...future.conditions) + 
[16:01:41.518]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:41.518]                     cond$call), session = sessionInformation(), 
[16:01:41.518]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:41.518]                   signalCondition(cond)
[16:01:41.518]                 }
[16:01:41.518]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:41.518]                 "immediateCondition"))) {
[16:01:41.518]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:41.518]                   ...future.conditions[[length(...future.conditions) + 
[16:01:41.518]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:41.518]                   if (TRUE && !signal) {
[16:01:41.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.518]                     {
[16:01:41.518]                       inherits <- base::inherits
[16:01:41.518]                       invokeRestart <- base::invokeRestart
[16:01:41.518]                       is.null <- base::is.null
[16:01:41.518]                       muffled <- FALSE
[16:01:41.518]                       if (inherits(cond, "message")) {
[16:01:41.518]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:41.518]                         if (muffled) 
[16:01:41.518]                           invokeRestart("muffleMessage")
[16:01:41.518]                       }
[16:01:41.518]                       else if (inherits(cond, "warning")) {
[16:01:41.518]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:41.518]                         if (muffled) 
[16:01:41.518]                           invokeRestart("muffleWarning")
[16:01:41.518]                       }
[16:01:41.518]                       else if (inherits(cond, "condition")) {
[16:01:41.518]                         if (!is.null(pattern)) {
[16:01:41.518]                           computeRestarts <- base::computeRestarts
[16:01:41.518]                           grepl <- base::grepl
[16:01:41.518]                           restarts <- computeRestarts(cond)
[16:01:41.518]                           for (restart in restarts) {
[16:01:41.518]                             name <- restart$name
[16:01:41.518]                             if (is.null(name)) 
[16:01:41.518]                               next
[16:01:41.518]                             if (!grepl(pattern, name)) 
[16:01:41.518]                               next
[16:01:41.518]                             invokeRestart(restart)
[16:01:41.518]                             muffled <- TRUE
[16:01:41.518]                             break
[16:01:41.518]                           }
[16:01:41.518]                         }
[16:01:41.518]                       }
[16:01:41.518]                       invisible(muffled)
[16:01:41.518]                     }
[16:01:41.518]                     muffleCondition(cond, pattern = "^muffle")
[16:01:41.518]                   }
[16:01:41.518]                 }
[16:01:41.518]                 else {
[16:01:41.518]                   if (TRUE) {
[16:01:41.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.518]                     {
[16:01:41.518]                       inherits <- base::inherits
[16:01:41.518]                       invokeRestart <- base::invokeRestart
[16:01:41.518]                       is.null <- base::is.null
[16:01:41.518]                       muffled <- FALSE
[16:01:41.518]                       if (inherits(cond, "message")) {
[16:01:41.518]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:41.518]                         if (muffled) 
[16:01:41.518]                           invokeRestart("muffleMessage")
[16:01:41.518]                       }
[16:01:41.518]                       else if (inherits(cond, "warning")) {
[16:01:41.518]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:41.518]                         if (muffled) 
[16:01:41.518]                           invokeRestart("muffleWarning")
[16:01:41.518]                       }
[16:01:41.518]                       else if (inherits(cond, "condition")) {
[16:01:41.518]                         if (!is.null(pattern)) {
[16:01:41.518]                           computeRestarts <- base::computeRestarts
[16:01:41.518]                           grepl <- base::grepl
[16:01:41.518]                           restarts <- computeRestarts(cond)
[16:01:41.518]                           for (restart in restarts) {
[16:01:41.518]                             name <- restart$name
[16:01:41.518]                             if (is.null(name)) 
[16:01:41.518]                               next
[16:01:41.518]                             if (!grepl(pattern, name)) 
[16:01:41.518]                               next
[16:01:41.518]                             invokeRestart(restart)
[16:01:41.518]                             muffled <- TRUE
[16:01:41.518]                             break
[16:01:41.518]                           }
[16:01:41.518]                         }
[16:01:41.518]                       }
[16:01:41.518]                       invisible(muffled)
[16:01:41.518]                     }
[16:01:41.518]                     muffleCondition(cond, pattern = "^muffle")
[16:01:41.518]                   }
[16:01:41.518]                 }
[16:01:41.518]             }
[16:01:41.518]         }))
[16:01:41.518]     }, error = function(ex) {
[16:01:41.518]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:41.518]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:41.518]                 ...future.rng), started = ...future.startTime, 
[16:01:41.518]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:41.518]             version = "1.8"), class = "FutureResult")
[16:01:41.518]     }, finally = {
[16:01:41.518]         if (!identical(...future.workdir, getwd())) 
[16:01:41.518]             setwd(...future.workdir)
[16:01:41.518]         {
[16:01:41.518]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:41.518]                 ...future.oldOptions$nwarnings <- NULL
[16:01:41.518]             }
[16:01:41.518]             base::options(...future.oldOptions)
[16:01:41.518]             if (.Platform$OS.type == "windows") {
[16:01:41.518]                 old_names <- names(...future.oldEnvVars)
[16:01:41.518]                 envs <- base::Sys.getenv()
[16:01:41.518]                 names <- names(envs)
[16:01:41.518]                 common <- intersect(names, old_names)
[16:01:41.518]                 added <- setdiff(names, old_names)
[16:01:41.518]                 removed <- setdiff(old_names, names)
[16:01:41.518]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:41.518]                   envs[common]]
[16:01:41.518]                 NAMES <- toupper(changed)
[16:01:41.518]                 args <- list()
[16:01:41.518]                 for (kk in seq_along(NAMES)) {
[16:01:41.518]                   name <- changed[[kk]]
[16:01:41.518]                   NAME <- NAMES[[kk]]
[16:01:41.518]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.518]                     next
[16:01:41.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:41.518]                 }
[16:01:41.518]                 NAMES <- toupper(added)
[16:01:41.518]                 for (kk in seq_along(NAMES)) {
[16:01:41.518]                   name <- added[[kk]]
[16:01:41.518]                   NAME <- NAMES[[kk]]
[16:01:41.518]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.518]                     next
[16:01:41.518]                   args[[name]] <- ""
[16:01:41.518]                 }
[16:01:41.518]                 NAMES <- toupper(removed)
[16:01:41.518]                 for (kk in seq_along(NAMES)) {
[16:01:41.518]                   name <- removed[[kk]]
[16:01:41.518]                   NAME <- NAMES[[kk]]
[16:01:41.518]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.518]                     next
[16:01:41.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:41.518]                 }
[16:01:41.518]                 if (length(args) > 0) 
[16:01:41.518]                   base::do.call(base::Sys.setenv, args = args)
[16:01:41.518]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:41.518]             }
[16:01:41.518]             else {
[16:01:41.518]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:41.518]             }
[16:01:41.518]             {
[16:01:41.518]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:41.518]                   0L) {
[16:01:41.518]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:41.518]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:41.518]                   base::options(opts)
[16:01:41.518]                 }
[16:01:41.518]                 {
[16:01:41.518]                   {
[16:01:41.518]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:41.518]                     NULL
[16:01:41.518]                   }
[16:01:41.518]                   options(future.plan = NULL)
[16:01:41.518]                   if (is.na(NA_character_)) 
[16:01:41.518]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:41.518]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:41.518]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:41.518]                     envir = parent.frame()) 
[16:01:41.518]                   {
[16:01:41.518]                     default_workers <- missing(workers)
[16:01:41.518]                     if (is.function(workers)) 
[16:01:41.518]                       workers <- workers()
[16:01:41.518]                     workers <- structure(as.integer(workers), 
[16:01:41.518]                       class = class(workers))
[16:01:41.518]                     stop_if_not(is.finite(workers), workers >= 
[16:01:41.518]                       1L)
[16:01:41.518]                     if ((workers == 1L && !inherits(workers, 
[16:01:41.518]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:41.518]                       if (default_workers) 
[16:01:41.518]                         supportsMulticore(warn = TRUE)
[16:01:41.518]                       return(sequential(..., envir = envir))
[16:01:41.518]                     }
[16:01:41.518]                     oopts <- options(mc.cores = workers)
[16:01:41.518]                     on.exit(options(oopts))
[16:01:41.518]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:41.518]                       envir = envir)
[16:01:41.518]                     if (!future$lazy) 
[16:01:41.518]                       future <- run(future)
[16:01:41.518]                     invisible(future)
[16:01:41.518]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:41.518]                 }
[16:01:41.518]             }
[16:01:41.518]         }
[16:01:41.518]     })
[16:01:41.518]     if (TRUE) {
[16:01:41.518]         base::sink(type = "output", split = FALSE)
[16:01:41.518]         if (TRUE) {
[16:01:41.518]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:41.518]         }
[16:01:41.518]         else {
[16:01:41.518]             ...future.result["stdout"] <- base::list(NULL)
[16:01:41.518]         }
[16:01:41.518]         base::close(...future.stdout)
[16:01:41.518]         ...future.stdout <- NULL
[16:01:41.518]     }
[16:01:41.518]     ...future.result$conditions <- ...future.conditions
[16:01:41.518]     ...future.result$finished <- base::Sys.time()
[16:01:41.518]     ...future.result
[16:01:41.518] }
[16:01:41.521] assign_globals() ...
[16:01:41.521] List of 5
[16:01:41.521]  $ future.call.arguments    : list()
[16:01:41.521]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:41.521]  $ ...future.FUN            :function (x)  
[16:01:41.521]  $ ...future.elements_ii    :List of 1
[16:01:41.521]   ..$ : int [1:2] 1 3
[16:01:41.521]  $ ...future.seeds_ii       : NULL
[16:01:41.521]  $ ...future.globals.maxSize: num Inf
[16:01:41.521]  - attr(*, "resolved")= logi FALSE
[16:01:41.521]  - attr(*, "total_size")= num NA
[16:01:41.521]  - attr(*, "where")=List of 5
[16:01:41.521]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:41.521]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:41.521]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:41.521]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:41.521]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:41.521]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:41.521]  - attr(*, "already-done")= logi TRUE
[16:01:41.526] - copied ‘future.call.arguments’ to environment
[16:01:41.526] - reassign environment for ‘...future.FUN’
[16:01:41.526] - copied ‘...future.FUN’ to environment
[16:01:41.526] - copied ‘...future.elements_ii’ to environment
[16:01:41.526] - copied ‘...future.seeds_ii’ to environment
[16:01:41.526] - copied ‘...future.globals.maxSize’ to environment
[16:01:41.526] assign_globals() ... done
[16:01:41.527] requestCore(): workers = 2
[16:01:41.529] MulticoreFuture started
[16:01:41.529] - Launch lazy future ... done
[16:01:41.529] run() for ‘MulticoreFuture’ ... done
[16:01:41.530] Created future:
[16:01:41.530] plan(): Setting new future strategy stack:
[16:01:41.530] List of future strategies:
[16:01:41.530] 1. sequential:
[16:01:41.530]    - args: function (..., envir = parent.frame())
[16:01:41.530]    - tweaked: FALSE
[16:01:41.530]    - call: NULL
[16:01:41.531] plan(): nbrOfWorkers() = 1
[16:01:41.533] plan(): Setting new future strategy stack:
[16:01:41.533] List of future strategies:
[16:01:41.533] 1. multicore:
[16:01:41.533]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:41.533]    - tweaked: FALSE
[16:01:41.533]    - call: plan(strategy)
[16:01:41.539] plan(): nbrOfWorkers() = 2
[16:01:41.530] MulticoreFuture:
[16:01:41.530] Label: ‘future_apply-1’
[16:01:41.530] Expression:
[16:01:41.530] {
[16:01:41.530]     do.call(function(...) {
[16:01:41.530]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.530]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:41.530]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.530]             on.exit(options(oopts), add = TRUE)
[16:01:41.530]         }
[16:01:41.530]         {
[16:01:41.530]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:41.530]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.530]                 ...future.FUN(...future.X_jj, ...)
[16:01:41.530]             })
[16:01:41.530]         }
[16:01:41.530]     }, args = future.call.arguments)
[16:01:41.530] }
[16:01:41.530] Lazy evaluation: FALSE
[16:01:41.530] Asynchronous evaluation: TRUE
[16:01:41.530] Local evaluation: TRUE
[16:01:41.530] Environment: R_GlobalEnv
[16:01:41.530] Capture standard output: TRUE
[16:01:41.530] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:41.530] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:41.530] Packages: <none>
[16:01:41.530] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:41.530] Resolved: TRUE
[16:01:41.530] Value: <not collected>
[16:01:41.530] Conditions captured: <none>
[16:01:41.530] Early signaling: FALSE
[16:01:41.530] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:41.530] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:41.540] Chunk #1 of 2 ... DONE
[16:01:41.540] Chunk #2 of 2 ...
[16:01:41.540]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:41.540]  - seeds: <none>
[16:01:41.541]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.541] getGlobalsAndPackages() ...
[16:01:41.541] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.541] Resolving globals: FALSE
[16:01:41.541] Tweak future expression to call with '...' arguments ...
[16:01:41.541] {
[16:01:41.541]     do.call(function(...) {
[16:01:41.541]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.541]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:41.541]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.541]             on.exit(options(oopts), add = TRUE)
[16:01:41.541]         }
[16:01:41.541]         {
[16:01:41.541]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:41.541]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.541]                 ...future.FUN(...future.X_jj, ...)
[16:01:41.541]             })
[16:01:41.541]         }
[16:01:41.541]     }, args = future.call.arguments)
[16:01:41.541] }
[16:01:41.542] Tweak future expression to call with '...' arguments ... DONE
[16:01:41.543] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.543] 
[16:01:41.543] getGlobalsAndPackages() ... DONE
[16:01:41.543] run() for ‘Future’ ...
[16:01:41.544] - state: ‘created’
[16:01:41.544] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:41.549] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:41.549] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:41.549]   - Field: ‘label’
[16:01:41.549]   - Field: ‘local’
[16:01:41.549]   - Field: ‘owner’
[16:01:41.549]   - Field: ‘envir’
[16:01:41.550]   - Field: ‘workers’
[16:01:41.550]   - Field: ‘packages’
[16:01:41.550]   - Field: ‘gc’
[16:01:41.550]   - Field: ‘job’
[16:01:41.550]   - Field: ‘conditions’
[16:01:41.550]   - Field: ‘expr’
[16:01:41.550]   - Field: ‘uuid’
[16:01:41.551]   - Field: ‘seed’
[16:01:41.551]   - Field: ‘version’
[16:01:41.551]   - Field: ‘result’
[16:01:41.551]   - Field: ‘asynchronous’
[16:01:41.551]   - Field: ‘calls’
[16:01:41.555]   - Field: ‘globals’
[16:01:41.555]   - Field: ‘stdout’
[16:01:41.556]   - Field: ‘earlySignal’
[16:01:41.556]   - Field: ‘lazy’
[16:01:41.556]   - Field: ‘state’
[16:01:41.557] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:41.557] - Launch lazy future ...
[16:01:41.558] Packages needed by the future expression (n = 0): <none>
[16:01:41.558] Packages needed by future strategies (n = 0): <none>
[16:01:41.559] {
[16:01:41.559]     {
[16:01:41.559]         {
[16:01:41.559]             ...future.startTime <- base::Sys.time()
[16:01:41.559]             {
[16:01:41.559]                 {
[16:01:41.559]                   {
[16:01:41.559]                     {
[16:01:41.559]                       base::local({
[16:01:41.559]                         has_future <- base::requireNamespace("future", 
[16:01:41.559]                           quietly = TRUE)
[16:01:41.559]                         if (has_future) {
[16:01:41.559]                           ns <- base::getNamespace("future")
[16:01:41.559]                           version <- ns[[".package"]][["version"]]
[16:01:41.559]                           if (is.null(version)) 
[16:01:41.559]                             version <- utils::packageVersion("future")
[16:01:41.559]                         }
[16:01:41.559]                         else {
[16:01:41.559]                           version <- NULL
[16:01:41.559]                         }
[16:01:41.559]                         if (!has_future || version < "1.8.0") {
[16:01:41.559]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:41.559]                             "", base::R.version$version.string), 
[16:01:41.559]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:41.559]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:41.559]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:41.559]                               "release", "version")], collapse = " "), 
[16:01:41.559]                             hostname = base::Sys.info()[["nodename"]])
[16:01:41.559]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:41.559]                             info)
[16:01:41.559]                           info <- base::paste(info, collapse = "; ")
[16:01:41.559]                           if (!has_future) {
[16:01:41.559]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:41.559]                               info)
[16:01:41.559]                           }
[16:01:41.559]                           else {
[16:01:41.559]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:41.559]                               info, version)
[16:01:41.559]                           }
[16:01:41.559]                           base::stop(msg)
[16:01:41.559]                         }
[16:01:41.559]                       })
[16:01:41.559]                     }
[16:01:41.559]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:41.559]                     base::options(mc.cores = 1L)
[16:01:41.559]                   }
[16:01:41.559]                   options(future.plan = NULL)
[16:01:41.559]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:41.559]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:41.559]                 }
[16:01:41.559]                 ...future.workdir <- getwd()
[16:01:41.559]             }
[16:01:41.559]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:41.559]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:41.559]         }
[16:01:41.559]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:41.559]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:41.559]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:41.559]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:41.559]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:41.559]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:41.559]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:41.559]             base::names(...future.oldOptions))
[16:01:41.559]     }
[16:01:41.559]     if (FALSE) {
[16:01:41.559]     }
[16:01:41.559]     else {
[16:01:41.559]         if (TRUE) {
[16:01:41.559]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:41.559]                 open = "w")
[16:01:41.559]         }
[16:01:41.559]         else {
[16:01:41.559]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:41.559]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:41.559]         }
[16:01:41.559]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:41.559]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:41.559]             base::sink(type = "output", split = FALSE)
[16:01:41.559]             base::close(...future.stdout)
[16:01:41.559]         }, add = TRUE)
[16:01:41.559]     }
[16:01:41.559]     ...future.frame <- base::sys.nframe()
[16:01:41.559]     ...future.conditions <- base::list()
[16:01:41.559]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:41.559]     if (FALSE) {
[16:01:41.559]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:41.559]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:41.559]     }
[16:01:41.559]     ...future.result <- base::tryCatch({
[16:01:41.559]         base::withCallingHandlers({
[16:01:41.559]             ...future.value <- base::withVisible(base::local({
[16:01:41.559]                 withCallingHandlers({
[16:01:41.559]                   {
[16:01:41.559]                     do.call(function(...) {
[16:01:41.559]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.559]                       if (!identical(...future.globals.maxSize.org, 
[16:01:41.559]                         ...future.globals.maxSize)) {
[16:01:41.559]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.559]                         on.exit(options(oopts), add = TRUE)
[16:01:41.559]                       }
[16:01:41.559]                       {
[16:01:41.559]                         lapply(seq_along(...future.elements_ii), 
[16:01:41.559]                           FUN = function(jj) {
[16:01:41.559]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.559]                             ...future.FUN(...future.X_jj, ...)
[16:01:41.559]                           })
[16:01:41.559]                       }
[16:01:41.559]                     }, args = future.call.arguments)
[16:01:41.559]                   }
[16:01:41.559]                 }, immediateCondition = function(cond) {
[16:01:41.559]                   save_rds <- function (object, pathname, ...) 
[16:01:41.559]                   {
[16:01:41.559]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:41.559]                     if (file_test("-f", pathname_tmp)) {
[16:01:41.559]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.559]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:41.559]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.559]                         fi_tmp[["mtime"]])
[16:01:41.559]                     }
[16:01:41.559]                     tryCatch({
[16:01:41.559]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:41.559]                     }, error = function(ex) {
[16:01:41.559]                       msg <- conditionMessage(ex)
[16:01:41.559]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.559]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:41.559]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.559]                         fi_tmp[["mtime"]], msg)
[16:01:41.559]                       ex$message <- msg
[16:01:41.559]                       stop(ex)
[16:01:41.559]                     })
[16:01:41.559]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:41.559]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:41.559]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:41.559]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.559]                       fi <- file.info(pathname)
[16:01:41.559]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:41.559]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.559]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:41.559]                         fi[["size"]], fi[["mtime"]])
[16:01:41.559]                       stop(msg)
[16:01:41.559]                     }
[16:01:41.559]                     invisible(pathname)
[16:01:41.559]                   }
[16:01:41.559]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:41.559]                     rootPath = tempdir()) 
[16:01:41.559]                   {
[16:01:41.559]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:41.559]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:41.559]                       tmpdir = path, fileext = ".rds")
[16:01:41.559]                     save_rds(obj, file)
[16:01:41.559]                   }
[16:01:41.559]                   saveImmediateCondition(cond, path = "/tmp/RtmplAoKyr/.future/immediateConditions")
[16:01:41.559]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.559]                   {
[16:01:41.559]                     inherits <- base::inherits
[16:01:41.559]                     invokeRestart <- base::invokeRestart
[16:01:41.559]                     is.null <- base::is.null
[16:01:41.559]                     muffled <- FALSE
[16:01:41.559]                     if (inherits(cond, "message")) {
[16:01:41.559]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:41.559]                       if (muffled) 
[16:01:41.559]                         invokeRestart("muffleMessage")
[16:01:41.559]                     }
[16:01:41.559]                     else if (inherits(cond, "warning")) {
[16:01:41.559]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:41.559]                       if (muffled) 
[16:01:41.559]                         invokeRestart("muffleWarning")
[16:01:41.559]                     }
[16:01:41.559]                     else if (inherits(cond, "condition")) {
[16:01:41.559]                       if (!is.null(pattern)) {
[16:01:41.559]                         computeRestarts <- base::computeRestarts
[16:01:41.559]                         grepl <- base::grepl
[16:01:41.559]                         restarts <- computeRestarts(cond)
[16:01:41.559]                         for (restart in restarts) {
[16:01:41.559]                           name <- restart$name
[16:01:41.559]                           if (is.null(name)) 
[16:01:41.559]                             next
[16:01:41.559]                           if (!grepl(pattern, name)) 
[16:01:41.559]                             next
[16:01:41.559]                           invokeRestart(restart)
[16:01:41.559]                           muffled <- TRUE
[16:01:41.559]                           break
[16:01:41.559]                         }
[16:01:41.559]                       }
[16:01:41.559]                     }
[16:01:41.559]                     invisible(muffled)
[16:01:41.559]                   }
[16:01:41.559]                   muffleCondition(cond)
[16:01:41.559]                 })
[16:01:41.559]             }))
[16:01:41.559]             future::FutureResult(value = ...future.value$value, 
[16:01:41.559]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:41.559]                   ...future.rng), globalenv = if (FALSE) 
[16:01:41.559]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:41.559]                     ...future.globalenv.names))
[16:01:41.559]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:41.559]         }, condition = base::local({
[16:01:41.559]             c <- base::c
[16:01:41.559]             inherits <- base::inherits
[16:01:41.559]             invokeRestart <- base::invokeRestart
[16:01:41.559]             length <- base::length
[16:01:41.559]             list <- base::list
[16:01:41.559]             seq.int <- base::seq.int
[16:01:41.559]             signalCondition <- base::signalCondition
[16:01:41.559]             sys.calls <- base::sys.calls
[16:01:41.559]             `[[` <- base::`[[`
[16:01:41.559]             `+` <- base::`+`
[16:01:41.559]             `<<-` <- base::`<<-`
[16:01:41.559]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:41.559]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:41.559]                   3L)]
[16:01:41.559]             }
[16:01:41.559]             function(cond) {
[16:01:41.559]                 is_error <- inherits(cond, "error")
[16:01:41.559]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:41.559]                   NULL)
[16:01:41.559]                 if (is_error) {
[16:01:41.559]                   sessionInformation <- function() {
[16:01:41.559]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:41.559]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:41.559]                       search = base::search(), system = base::Sys.info())
[16:01:41.559]                   }
[16:01:41.559]                   ...future.conditions[[length(...future.conditions) + 
[16:01:41.559]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:41.559]                     cond$call), session = sessionInformation(), 
[16:01:41.559]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:41.559]                   signalCondition(cond)
[16:01:41.559]                 }
[16:01:41.559]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:41.559]                 "immediateCondition"))) {
[16:01:41.559]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:41.559]                   ...future.conditions[[length(...future.conditions) + 
[16:01:41.559]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:41.559]                   if (TRUE && !signal) {
[16:01:41.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.559]                     {
[16:01:41.559]                       inherits <- base::inherits
[16:01:41.559]                       invokeRestart <- base::invokeRestart
[16:01:41.559]                       is.null <- base::is.null
[16:01:41.559]                       muffled <- FALSE
[16:01:41.559]                       if (inherits(cond, "message")) {
[16:01:41.559]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:41.559]                         if (muffled) 
[16:01:41.559]                           invokeRestart("muffleMessage")
[16:01:41.559]                       }
[16:01:41.559]                       else if (inherits(cond, "warning")) {
[16:01:41.559]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:41.559]                         if (muffled) 
[16:01:41.559]                           invokeRestart("muffleWarning")
[16:01:41.559]                       }
[16:01:41.559]                       else if (inherits(cond, "condition")) {
[16:01:41.559]                         if (!is.null(pattern)) {
[16:01:41.559]                           computeRestarts <- base::computeRestarts
[16:01:41.559]                           grepl <- base::grepl
[16:01:41.559]                           restarts <- computeRestarts(cond)
[16:01:41.559]                           for (restart in restarts) {
[16:01:41.559]                             name <- restart$name
[16:01:41.559]                             if (is.null(name)) 
[16:01:41.559]                               next
[16:01:41.559]                             if (!grepl(pattern, name)) 
[16:01:41.559]                               next
[16:01:41.559]                             invokeRestart(restart)
[16:01:41.559]                             muffled <- TRUE
[16:01:41.559]                             break
[16:01:41.559]                           }
[16:01:41.559]                         }
[16:01:41.559]                       }
[16:01:41.559]                       invisible(muffled)
[16:01:41.559]                     }
[16:01:41.559]                     muffleCondition(cond, pattern = "^muffle")
[16:01:41.559]                   }
[16:01:41.559]                 }
[16:01:41.559]                 else {
[16:01:41.559]                   if (TRUE) {
[16:01:41.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.559]                     {
[16:01:41.559]                       inherits <- base::inherits
[16:01:41.559]                       invokeRestart <- base::invokeRestart
[16:01:41.559]                       is.null <- base::is.null
[16:01:41.559]                       muffled <- FALSE
[16:01:41.559]                       if (inherits(cond, "message")) {
[16:01:41.559]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:41.559]                         if (muffled) 
[16:01:41.559]                           invokeRestart("muffleMessage")
[16:01:41.559]                       }
[16:01:41.559]                       else if (inherits(cond, "warning")) {
[16:01:41.559]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:41.559]                         if (muffled) 
[16:01:41.559]                           invokeRestart("muffleWarning")
[16:01:41.559]                       }
[16:01:41.559]                       else if (inherits(cond, "condition")) {
[16:01:41.559]                         if (!is.null(pattern)) {
[16:01:41.559]                           computeRestarts <- base::computeRestarts
[16:01:41.559]                           grepl <- base::grepl
[16:01:41.559]                           restarts <- computeRestarts(cond)
[16:01:41.559]                           for (restart in restarts) {
[16:01:41.559]                             name <- restart$name
[16:01:41.559]                             if (is.null(name)) 
[16:01:41.559]                               next
[16:01:41.559]                             if (!grepl(pattern, name)) 
[16:01:41.559]                               next
[16:01:41.559]                             invokeRestart(restart)
[16:01:41.559]                             muffled <- TRUE
[16:01:41.559]                             break
[16:01:41.559]                           }
[16:01:41.559]                         }
[16:01:41.559]                       }
[16:01:41.559]                       invisible(muffled)
[16:01:41.559]                     }
[16:01:41.559]                     muffleCondition(cond, pattern = "^muffle")
[16:01:41.559]                   }
[16:01:41.559]                 }
[16:01:41.559]             }
[16:01:41.559]         }))
[16:01:41.559]     }, error = function(ex) {
[16:01:41.559]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:41.559]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:41.559]                 ...future.rng), started = ...future.startTime, 
[16:01:41.559]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:41.559]             version = "1.8"), class = "FutureResult")
[16:01:41.559]     }, finally = {
[16:01:41.559]         if (!identical(...future.workdir, getwd())) 
[16:01:41.559]             setwd(...future.workdir)
[16:01:41.559]         {
[16:01:41.559]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:41.559]                 ...future.oldOptions$nwarnings <- NULL
[16:01:41.559]             }
[16:01:41.559]             base::options(...future.oldOptions)
[16:01:41.559]             if (.Platform$OS.type == "windows") {
[16:01:41.559]                 old_names <- names(...future.oldEnvVars)
[16:01:41.559]                 envs <- base::Sys.getenv()
[16:01:41.559]                 names <- names(envs)
[16:01:41.559]                 common <- intersect(names, old_names)
[16:01:41.559]                 added <- setdiff(names, old_names)
[16:01:41.559]                 removed <- setdiff(old_names, names)
[16:01:41.559]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:41.559]                   envs[common]]
[16:01:41.559]                 NAMES <- toupper(changed)
[16:01:41.559]                 args <- list()
[16:01:41.559]                 for (kk in seq_along(NAMES)) {
[16:01:41.559]                   name <- changed[[kk]]
[16:01:41.559]                   NAME <- NAMES[[kk]]
[16:01:41.559]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.559]                     next
[16:01:41.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:41.559]                 }
[16:01:41.559]                 NAMES <- toupper(added)
[16:01:41.559]                 for (kk in seq_along(NAMES)) {
[16:01:41.559]                   name <- added[[kk]]
[16:01:41.559]                   NAME <- NAMES[[kk]]
[16:01:41.559]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.559]                     next
[16:01:41.559]                   args[[name]] <- ""
[16:01:41.559]                 }
[16:01:41.559]                 NAMES <- toupper(removed)
[16:01:41.559]                 for (kk in seq_along(NAMES)) {
[16:01:41.559]                   name <- removed[[kk]]
[16:01:41.559]                   NAME <- NAMES[[kk]]
[16:01:41.559]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.559]                     next
[16:01:41.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:41.559]                 }
[16:01:41.559]                 if (length(args) > 0) 
[16:01:41.559]                   base::do.call(base::Sys.setenv, args = args)
[16:01:41.559]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:41.559]             }
[16:01:41.559]             else {
[16:01:41.559]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:41.559]             }
[16:01:41.559]             {
[16:01:41.559]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:41.559]                   0L) {
[16:01:41.559]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:41.559]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:41.559]                   base::options(opts)
[16:01:41.559]                 }
[16:01:41.559]                 {
[16:01:41.559]                   {
[16:01:41.559]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:41.559]                     NULL
[16:01:41.559]                   }
[16:01:41.559]                   options(future.plan = NULL)
[16:01:41.559]                   if (is.na(NA_character_)) 
[16:01:41.559]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:41.559]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:41.559]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:41.559]                     envir = parent.frame()) 
[16:01:41.559]                   {
[16:01:41.559]                     default_workers <- missing(workers)
[16:01:41.559]                     if (is.function(workers)) 
[16:01:41.559]                       workers <- workers()
[16:01:41.559]                     workers <- structure(as.integer(workers), 
[16:01:41.559]                       class = class(workers))
[16:01:41.559]                     stop_if_not(is.finite(workers), workers >= 
[16:01:41.559]                       1L)
[16:01:41.559]                     if ((workers == 1L && !inherits(workers, 
[16:01:41.559]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:41.559]                       if (default_workers) 
[16:01:41.559]                         supportsMulticore(warn = TRUE)
[16:01:41.559]                       return(sequential(..., envir = envir))
[16:01:41.559]                     }
[16:01:41.559]                     oopts <- options(mc.cores = workers)
[16:01:41.559]                     on.exit(options(oopts))
[16:01:41.559]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:41.559]                       envir = envir)
[16:01:41.559]                     if (!future$lazy) 
[16:01:41.559]                       future <- run(future)
[16:01:41.559]                     invisible(future)
[16:01:41.559]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:41.559]                 }
[16:01:41.559]             }
[16:01:41.559]         }
[16:01:41.559]     })
[16:01:41.559]     if (TRUE) {
[16:01:41.559]         base::sink(type = "output", split = FALSE)
[16:01:41.559]         if (TRUE) {
[16:01:41.559]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:41.559]         }
[16:01:41.559]         else {
[16:01:41.559]             ...future.result["stdout"] <- base::list(NULL)
[16:01:41.559]         }
[16:01:41.559]         base::close(...future.stdout)
[16:01:41.559]         ...future.stdout <- NULL
[16:01:41.559]     }
[16:01:41.559]     ...future.result$conditions <- ...future.conditions
[16:01:41.559]     ...future.result$finished <- base::Sys.time()
[16:01:41.559]     ...future.result
[16:01:41.559] }
[16:01:41.563] assign_globals() ...
[16:01:41.563] List of 5
[16:01:41.563]  $ future.call.arguments    : list()
[16:01:41.563]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:41.563]  $ ...future.FUN            :function (x)  
[16:01:41.563]  $ ...future.elements_ii    :List of 1
[16:01:41.563]   ..$ : int [1:2] 2 4
[16:01:41.563]  $ ...future.seeds_ii       : NULL
[16:01:41.563]  $ ...future.globals.maxSize: num Inf
[16:01:41.563]  - attr(*, "resolved")= logi FALSE
[16:01:41.563]  - attr(*, "total_size")= num NA
[16:01:41.563]  - attr(*, "where")=List of 5
[16:01:41.563]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:41.563]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:41.563]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:41.563]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:41.563]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:41.563]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:41.563]  - attr(*, "already-done")= logi TRUE
[16:01:41.572] - copied ‘future.call.arguments’ to environment
[16:01:41.572] - reassign environment for ‘...future.FUN’
[16:01:41.572] - copied ‘...future.FUN’ to environment
[16:01:41.572] - copied ‘...future.elements_ii’ to environment
[16:01:41.573] - copied ‘...future.seeds_ii’ to environment
[16:01:41.573] - copied ‘...future.globals.maxSize’ to environment
[16:01:41.573] assign_globals() ... done
[16:01:41.573] requestCore(): workers = 2
[16:01:41.575] MulticoreFuture started
[16:01:41.576] - Launch lazy future ... done
[16:01:41.576] run() for ‘MulticoreFuture’ ... done
[16:01:41.576] Created future:
[16:01:41.577] plan(): Setting new future strategy stack:
[16:01:41.577] List of future strategies:
[16:01:41.577] 1. sequential:
[16:01:41.577]    - args: function (..., envir = parent.frame())
[16:01:41.577]    - tweaked: FALSE
[16:01:41.577]    - call: NULL
[16:01:41.578] plan(): nbrOfWorkers() = 1
[16:01:41.580] plan(): Setting new future strategy stack:
[16:01:41.580] List of future strategies:
[16:01:41.580] 1. multicore:
[16:01:41.580]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:41.580]    - tweaked: FALSE
[16:01:41.580]    - call: plan(strategy)
[16:01:41.586] plan(): nbrOfWorkers() = 2
[16:01:41.577] MulticoreFuture:
[16:01:41.577] Label: ‘future_apply-2’
[16:01:41.577] Expression:
[16:01:41.577] {
[16:01:41.577]     do.call(function(...) {
[16:01:41.577]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.577]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:41.577]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.577]             on.exit(options(oopts), add = TRUE)
[16:01:41.577]         }
[16:01:41.577]         {
[16:01:41.577]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:41.577]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.577]                 ...future.FUN(...future.X_jj, ...)
[16:01:41.577]             })
[16:01:41.577]         }
[16:01:41.577]     }, args = future.call.arguments)
[16:01:41.577] }
[16:01:41.577] Lazy evaluation: FALSE
[16:01:41.577] Asynchronous evaluation: TRUE
[16:01:41.577] Local evaluation: TRUE
[16:01:41.577] Environment: R_GlobalEnv
[16:01:41.577] Capture standard output: TRUE
[16:01:41.577] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:41.577] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:41.577] Packages: <none>
[16:01:41.577] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:41.577] Resolved: TRUE
[16:01:41.577] Value: <not collected>
[16:01:41.577] Conditions captured: <none>
[16:01:41.577] Early signaling: FALSE
[16:01:41.577] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:41.577] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:41.587] Chunk #2 of 2 ... DONE
[16:01:41.587] Launching 2 futures (chunks) ... DONE
[16:01:41.587] Resolving 2 futures (chunks) ...
[16:01:41.587] resolve() on list ...
[16:01:41.588]  recursive: 0
[16:01:41.588]  length: 2
[16:01:41.588] 
[16:01:41.588] Future #1
[16:01:41.588] result() for MulticoreFuture ...
[16:01:41.589] result() for MulticoreFuture ...
[16:01:41.590] result() for MulticoreFuture ... done
[16:01:41.590] result() for MulticoreFuture ... done
[16:01:41.590] result() for MulticoreFuture ...
[16:01:41.590] result() for MulticoreFuture ... done
[16:01:41.590] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:01:41.590] - nx: 2
[16:01:41.591] - relay: TRUE
[16:01:41.591] - stdout: TRUE
[16:01:41.591] - signal: TRUE
[16:01:41.591] - resignal: FALSE
[16:01:41.591] - force: TRUE
[16:01:41.591] - relayed: [n=2] FALSE, FALSE
[16:01:41.591] - queued futures: [n=2] FALSE, FALSE
[16:01:41.592]  - until=1
[16:01:41.592]  - relaying element #1
[16:01:41.592] result() for MulticoreFuture ...
[16:01:41.592] result() for MulticoreFuture ... done
[16:01:41.592] result() for MulticoreFuture ...
[16:01:41.592] result() for MulticoreFuture ... done
[16:01:41.593] result() for MulticoreFuture ...
[16:01:41.593] result() for MulticoreFuture ... done
[16:01:41.593] result() for MulticoreFuture ...
[16:01:41.593] result() for MulticoreFuture ... done
[16:01:41.593] - relayed: [n=2] TRUE, FALSE
[16:01:41.593] - queued futures: [n=2] TRUE, FALSE
[16:01:41.594] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:01:41.594]  length: 1 (resolved future 1)
[16:01:41.594] Future #2
[16:01:41.594] result() for MulticoreFuture ...
[16:01:41.595] result() for MulticoreFuture ...
[16:01:41.595] result() for MulticoreFuture ... done
[16:01:41.595] result() for MulticoreFuture ... done
[16:01:41.596] result() for MulticoreFuture ...
[16:01:41.596] result() for MulticoreFuture ... done
[16:01:41.596] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:01:41.596] - nx: 2
[16:01:41.596] - relay: TRUE
[16:01:41.596] - stdout: TRUE
[16:01:41.596] - signal: TRUE
[16:01:41.597] - resignal: FALSE
[16:01:41.597] - force: TRUE
[16:01:41.597] - relayed: [n=2] TRUE, FALSE
[16:01:41.597] - queued futures: [n=2] TRUE, FALSE
[16:01:41.597]  - until=2
[16:01:41.597]  - relaying element #2
[16:01:41.597] result() for MulticoreFuture ...
[16:01:41.597] result() for MulticoreFuture ... done
[16:01:41.597] result() for MulticoreFuture ...
[16:01:41.598] result() for MulticoreFuture ... done
[16:01:41.598] result() for MulticoreFuture ...
[16:01:41.598] result() for MulticoreFuture ... done
[16:01:41.598] result() for MulticoreFuture ...
[16:01:41.598] result() for MulticoreFuture ... done
[16:01:41.598] - relayed: [n=2] TRUE, TRUE
[16:01:41.598] - queued futures: [n=2] TRUE, TRUE
[16:01:41.598] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:01:41.599]  length: 0 (resolved future 2)
[16:01:41.599] Relaying remaining futures
[16:01:41.599] signalConditionsASAP(NULL, pos=0) ...
[16:01:41.599] - nx: 2
[16:01:41.599] - relay: TRUE
[16:01:41.599] - stdout: TRUE
[16:01:41.599] - signal: TRUE
[16:01:41.599] - resignal: FALSE
[16:01:41.599] - force: TRUE
[16:01:41.600] - relayed: [n=2] TRUE, TRUE
[16:01:41.600] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:41.600] - relayed: [n=2] TRUE, TRUE
[16:01:41.600] - queued futures: [n=2] TRUE, TRUE
[16:01:41.600] signalConditionsASAP(NULL, pos=0) ... done
[16:01:41.600] resolve() on list ... DONE
[16:01:41.600] result() for MulticoreFuture ...
[16:01:41.600] result() for MulticoreFuture ... done
[16:01:41.601] result() for MulticoreFuture ...
[16:01:41.603] result() for MulticoreFuture ... done
[16:01:41.604] result() for MulticoreFuture ...
[16:01:41.604] result() for MulticoreFuture ... done
[16:01:41.604] result() for MulticoreFuture ...
[16:01:41.604] result() for MulticoreFuture ... done
[16:01:41.604]  - Number of value chunks collected: 2
[16:01:41.605] Resolving 2 futures (chunks) ... DONE
[16:01:41.605] Reducing values from 2 chunks ...
[16:01:41.605]  - Number of values collected after concatenation: 2
[16:01:41.605]  - Number of values expected: 2
[16:01:41.605] Reducing values from 2 chunks ... DONE
[16:01:41.605] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[16:01:41.606] getGlobalsAndPackagesXApply() ...
[16:01:41.606]  - future.globals: TRUE
[16:01:41.606] getGlobalsAndPackages() ...
[16:01:41.606] Searching for globals...
[16:01:41.611] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[16:01:41.611] Searching for globals ... DONE
[16:01:41.611] Resolving globals: FALSE
[16:01:41.612] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[16:01:41.612] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[16:01:41.613] - globals: [1] ‘FUN’
[16:01:41.613] 
[16:01:41.613] getGlobalsAndPackages() ... DONE
[16:01:41.613]  - globals found/used: [n=1] ‘FUN’
[16:01:41.613]  - needed namespaces: [n=0] 
[16:01:41.613] Finding globals ... DONE
[16:01:41.613]  - use_args: TRUE
[16:01:41.613]  - Getting '...' globals ...
[16:01:41.614] resolve() on list ...
[16:01:41.614]  recursive: 0
[16:01:41.614]  length: 1
[16:01:41.614]  elements: ‘...’
[16:01:41.614]  length: 0 (resolved future 1)
[16:01:41.614] resolve() on list ... DONE
[16:01:41.614]    - '...' content: [n=0] 
[16:01:41.615] List of 1
[16:01:41.615]  $ ...: list()
[16:01:41.615]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:41.615]  - attr(*, "where")=List of 1
[16:01:41.615]   ..$ ...:<environment: 0x55fb62763028> 
[16:01:41.615]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:41.615]  - attr(*, "resolved")= logi TRUE
[16:01:41.615]  - attr(*, "total_size")= num NA
[16:01:41.617]  - Getting '...' globals ... DONE
[16:01:41.618] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:41.618] List of 2
[16:01:41.618]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[16:01:41.618]  $ ...          : list()
[16:01:41.618]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:41.618]  - attr(*, "where")=List of 2
[16:01:41.618]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:41.618]   ..$ ...          :<environment: 0x55fb62763028> 
[16:01:41.618]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:41.618]  - attr(*, "resolved")= logi FALSE
[16:01:41.618]  - attr(*, "total_size")= num 36296
[16:01:41.620] Packages to be attached in all futures: [n=0] 
[16:01:41.621] getGlobalsAndPackagesXApply() ... DONE
[16:01:41.625] future_lapply() ...
[16:01:41.627] Generating random seeds ...
[16:01:41.627] Generating random seed streams for 2 elements ...
[16:01:41.628] Generating random seed streams for 2 elements ... DONE
[16:01:41.628] Generating random seeds ... DONE
[16:01:41.628] Will set RNG state on exit: 10407, -1984911120, 1352037004, -227317540, -369701816, 2028281285, 1643107619
[16:01:41.636] Number of chunks: 2
[16:01:41.636] getGlobalsAndPackagesXApply() ...
[16:01:41.637]  - future.globals: <name-value list> with names ‘list()’
[16:01:41.637]  - use_args: TRUE
[16:01:41.637] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:01:41.637] List of 2
[16:01:41.637]  $ ...          : list()
[16:01:41.637]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:41.637]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[16:01:41.637]  - attr(*, "where")=List of 2
[16:01:41.637]   ..$ ...          :<environment: 0x55fb62763028> 
[16:01:41.637]   ..$ ...future.FUN:<environment: namespace:base> 
[16:01:41.637]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:41.637]  - attr(*, "resolved")= logi FALSE
[16:01:41.637]  - attr(*, "total_size")= num NA
[16:01:41.642] Packages to be attached in all futures: [n=0] 
[16:01:41.642] getGlobalsAndPackagesXApply() ... DONE
[16:01:41.642] Number of futures (= number of chunks): 2
[16:01:41.642] Launching 2 futures (chunks) ...
[16:01:41.642] Chunk #1 of 2 ...
[16:01:41.643]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:41.643]  - seeds: [1] <seeds>
[16:01:41.643]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.643] getGlobalsAndPackages() ...
[16:01:41.643] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.643] Resolving globals: FALSE
[16:01:41.643] Tweak future expression to call with '...' arguments ...
[16:01:41.643] {
[16:01:41.643]     do.call(function(...) {
[16:01:41.643]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.643]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:41.643]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.643]             on.exit(options(oopts), add = TRUE)
[16:01:41.643]         }
[16:01:41.643]         {
[16:01:41.643]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:41.643]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.643]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:01:41.643]                   envir = globalenv(), inherits = FALSE)
[16:01:41.643]                 ...future.FUN(...future.X_jj, ...)
[16:01:41.643]             })
[16:01:41.643]         }
[16:01:41.643]     }, args = future.call.arguments)
[16:01:41.643] }
[16:01:41.644] Tweak future expression to call with '...' arguments ... DONE
[16:01:41.644] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.644] 
[16:01:41.644] getGlobalsAndPackages() ... DONE
[16:01:41.645] run() for ‘Future’ ...
[16:01:41.645] - state: ‘created’
[16:01:41.645] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:41.649] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:41.649] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:41.650]   - Field: ‘label’
[16:01:41.650]   - Field: ‘local’
[16:01:41.650]   - Field: ‘owner’
[16:01:41.650]   - Field: ‘envir’
[16:01:41.650]   - Field: ‘workers’
[16:01:41.650]   - Field: ‘packages’
[16:01:41.650]   - Field: ‘gc’
[16:01:41.650]   - Field: ‘job’
[16:01:41.651]   - Field: ‘conditions’
[16:01:41.651]   - Field: ‘expr’
[16:01:41.651]   - Field: ‘uuid’
[16:01:41.651]   - Field: ‘seed’
[16:01:41.651]   - Field: ‘version’
[16:01:41.651]   - Field: ‘result’
[16:01:41.651]   - Field: ‘asynchronous’
[16:01:41.651]   - Field: ‘calls’
[16:01:41.652]   - Field: ‘globals’
[16:01:41.652]   - Field: ‘stdout’
[16:01:41.652]   - Field: ‘earlySignal’
[16:01:41.652]   - Field: ‘lazy’
[16:01:41.652]   - Field: ‘state’
[16:01:41.652] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:41.652] - Launch lazy future ...
[16:01:41.652] Packages needed by the future expression (n = 0): <none>
[16:01:41.653] Packages needed by future strategies (n = 0): <none>
[16:01:41.653] {
[16:01:41.653]     {
[16:01:41.653]         {
[16:01:41.653]             ...future.startTime <- base::Sys.time()
[16:01:41.653]             {
[16:01:41.653]                 {
[16:01:41.653]                   {
[16:01:41.653]                     {
[16:01:41.653]                       base::local({
[16:01:41.653]                         has_future <- base::requireNamespace("future", 
[16:01:41.653]                           quietly = TRUE)
[16:01:41.653]                         if (has_future) {
[16:01:41.653]                           ns <- base::getNamespace("future")
[16:01:41.653]                           version <- ns[[".package"]][["version"]]
[16:01:41.653]                           if (is.null(version)) 
[16:01:41.653]                             version <- utils::packageVersion("future")
[16:01:41.653]                         }
[16:01:41.653]                         else {
[16:01:41.653]                           version <- NULL
[16:01:41.653]                         }
[16:01:41.653]                         if (!has_future || version < "1.8.0") {
[16:01:41.653]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:41.653]                             "", base::R.version$version.string), 
[16:01:41.653]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:41.653]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:41.653]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:41.653]                               "release", "version")], collapse = " "), 
[16:01:41.653]                             hostname = base::Sys.info()[["nodename"]])
[16:01:41.653]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:41.653]                             info)
[16:01:41.653]                           info <- base::paste(info, collapse = "; ")
[16:01:41.653]                           if (!has_future) {
[16:01:41.653]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:41.653]                               info)
[16:01:41.653]                           }
[16:01:41.653]                           else {
[16:01:41.653]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:41.653]                               info, version)
[16:01:41.653]                           }
[16:01:41.653]                           base::stop(msg)
[16:01:41.653]                         }
[16:01:41.653]                       })
[16:01:41.653]                     }
[16:01:41.653]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:41.653]                     base::options(mc.cores = 1L)
[16:01:41.653]                   }
[16:01:41.653]                   options(future.plan = NULL)
[16:01:41.653]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:41.653]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:41.653]                 }
[16:01:41.653]                 ...future.workdir <- getwd()
[16:01:41.653]             }
[16:01:41.653]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:41.653]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:41.653]         }
[16:01:41.653]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:41.653]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:41.653]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:41.653]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:41.653]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:41.653]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:41.653]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:41.653]             base::names(...future.oldOptions))
[16:01:41.653]     }
[16:01:41.653]     if (FALSE) {
[16:01:41.653]     }
[16:01:41.653]     else {
[16:01:41.653]         if (TRUE) {
[16:01:41.653]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:41.653]                 open = "w")
[16:01:41.653]         }
[16:01:41.653]         else {
[16:01:41.653]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:41.653]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:41.653]         }
[16:01:41.653]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:41.653]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:41.653]             base::sink(type = "output", split = FALSE)
[16:01:41.653]             base::close(...future.stdout)
[16:01:41.653]         }, add = TRUE)
[16:01:41.653]     }
[16:01:41.653]     ...future.frame <- base::sys.nframe()
[16:01:41.653]     ...future.conditions <- base::list()
[16:01:41.653]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:41.653]     if (FALSE) {
[16:01:41.653]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:41.653]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:41.653]     }
[16:01:41.653]     ...future.result <- base::tryCatch({
[16:01:41.653]         base::withCallingHandlers({
[16:01:41.653]             ...future.value <- base::withVisible(base::local({
[16:01:41.653]                 withCallingHandlers({
[16:01:41.653]                   {
[16:01:41.653]                     do.call(function(...) {
[16:01:41.653]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.653]                       if (!identical(...future.globals.maxSize.org, 
[16:01:41.653]                         ...future.globals.maxSize)) {
[16:01:41.653]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.653]                         on.exit(options(oopts), add = TRUE)
[16:01:41.653]                       }
[16:01:41.653]                       {
[16:01:41.653]                         lapply(seq_along(...future.elements_ii), 
[16:01:41.653]                           FUN = function(jj) {
[16:01:41.653]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.653]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:01:41.653]                               envir = globalenv(), inherits = FALSE)
[16:01:41.653]                             ...future.FUN(...future.X_jj, ...)
[16:01:41.653]                           })
[16:01:41.653]                       }
[16:01:41.653]                     }, args = future.call.arguments)
[16:01:41.653]                   }
[16:01:41.653]                 }, immediateCondition = function(cond) {
[16:01:41.653]                   save_rds <- function (object, pathname, ...) 
[16:01:41.653]                   {
[16:01:41.653]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:41.653]                     if (file_test("-f", pathname_tmp)) {
[16:01:41.653]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.653]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:41.653]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.653]                         fi_tmp[["mtime"]])
[16:01:41.653]                     }
[16:01:41.653]                     tryCatch({
[16:01:41.653]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:41.653]                     }, error = function(ex) {
[16:01:41.653]                       msg <- conditionMessage(ex)
[16:01:41.653]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.653]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:41.653]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.653]                         fi_tmp[["mtime"]], msg)
[16:01:41.653]                       ex$message <- msg
[16:01:41.653]                       stop(ex)
[16:01:41.653]                     })
[16:01:41.653]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:41.653]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:41.653]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:41.653]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.653]                       fi <- file.info(pathname)
[16:01:41.653]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:41.653]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.653]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:41.653]                         fi[["size"]], fi[["mtime"]])
[16:01:41.653]                       stop(msg)
[16:01:41.653]                     }
[16:01:41.653]                     invisible(pathname)
[16:01:41.653]                   }
[16:01:41.653]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:41.653]                     rootPath = tempdir()) 
[16:01:41.653]                   {
[16:01:41.653]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:41.653]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:41.653]                       tmpdir = path, fileext = ".rds")
[16:01:41.653]                     save_rds(obj, file)
[16:01:41.653]                   }
[16:01:41.653]                   saveImmediateCondition(cond, path = "/tmp/RtmplAoKyr/.future/immediateConditions")
[16:01:41.653]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.653]                   {
[16:01:41.653]                     inherits <- base::inherits
[16:01:41.653]                     invokeRestart <- base::invokeRestart
[16:01:41.653]                     is.null <- base::is.null
[16:01:41.653]                     muffled <- FALSE
[16:01:41.653]                     if (inherits(cond, "message")) {
[16:01:41.653]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:41.653]                       if (muffled) 
[16:01:41.653]                         invokeRestart("muffleMessage")
[16:01:41.653]                     }
[16:01:41.653]                     else if (inherits(cond, "warning")) {
[16:01:41.653]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:41.653]                       if (muffled) 
[16:01:41.653]                         invokeRestart("muffleWarning")
[16:01:41.653]                     }
[16:01:41.653]                     else if (inherits(cond, "condition")) {
[16:01:41.653]                       if (!is.null(pattern)) {
[16:01:41.653]                         computeRestarts <- base::computeRestarts
[16:01:41.653]                         grepl <- base::grepl
[16:01:41.653]                         restarts <- computeRestarts(cond)
[16:01:41.653]                         for (restart in restarts) {
[16:01:41.653]                           name <- restart$name
[16:01:41.653]                           if (is.null(name)) 
[16:01:41.653]                             next
[16:01:41.653]                           if (!grepl(pattern, name)) 
[16:01:41.653]                             next
[16:01:41.653]                           invokeRestart(restart)
[16:01:41.653]                           muffled <- TRUE
[16:01:41.653]                           break
[16:01:41.653]                         }
[16:01:41.653]                       }
[16:01:41.653]                     }
[16:01:41.653]                     invisible(muffled)
[16:01:41.653]                   }
[16:01:41.653]                   muffleCondition(cond)
[16:01:41.653]                 })
[16:01:41.653]             }))
[16:01:41.653]             future::FutureResult(value = ...future.value$value, 
[16:01:41.653]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:41.653]                   ...future.rng), globalenv = if (FALSE) 
[16:01:41.653]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:41.653]                     ...future.globalenv.names))
[16:01:41.653]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:41.653]         }, condition = base::local({
[16:01:41.653]             c <- base::c
[16:01:41.653]             inherits <- base::inherits
[16:01:41.653]             invokeRestart <- base::invokeRestart
[16:01:41.653]             length <- base::length
[16:01:41.653]             list <- base::list
[16:01:41.653]             seq.int <- base::seq.int
[16:01:41.653]             signalCondition <- base::signalCondition
[16:01:41.653]             sys.calls <- base::sys.calls
[16:01:41.653]             `[[` <- base::`[[`
[16:01:41.653]             `+` <- base::`+`
[16:01:41.653]             `<<-` <- base::`<<-`
[16:01:41.653]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:41.653]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:41.653]                   3L)]
[16:01:41.653]             }
[16:01:41.653]             function(cond) {
[16:01:41.653]                 is_error <- inherits(cond, "error")
[16:01:41.653]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:41.653]                   NULL)
[16:01:41.653]                 if (is_error) {
[16:01:41.653]                   sessionInformation <- function() {
[16:01:41.653]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:41.653]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:41.653]                       search = base::search(), system = base::Sys.info())
[16:01:41.653]                   }
[16:01:41.653]                   ...future.conditions[[length(...future.conditions) + 
[16:01:41.653]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:41.653]                     cond$call), session = sessionInformation(), 
[16:01:41.653]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:41.653]                   signalCondition(cond)
[16:01:41.653]                 }
[16:01:41.653]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[16:01:41.653]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:41.653]                   ...future.conditions[[length(...future.conditions) + 
[16:01:41.653]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:41.653]                   if (TRUE && !signal) {
[16:01:41.653]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.653]                     {
[16:01:41.653]                       inherits <- base::inherits
[16:01:41.653]                       invokeRestart <- base::invokeRestart
[16:01:41.653]                       is.null <- base::is.null
[16:01:41.653]                       muffled <- FALSE
[16:01:41.653]                       if (inherits(cond, "message")) {
[16:01:41.653]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:41.653]                         if (muffled) 
[16:01:41.653]                           invokeRestart("muffleMessage")
[16:01:41.653]                       }
[16:01:41.653]                       else if (inherits(cond, "warning")) {
[16:01:41.653]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:41.653]                         if (muffled) 
[16:01:41.653]                           invokeRestart("muffleWarning")
[16:01:41.653]                       }
[16:01:41.653]                       else if (inherits(cond, "condition")) {
[16:01:41.653]                         if (!is.null(pattern)) {
[16:01:41.653]                           computeRestarts <- base::computeRestarts
[16:01:41.653]                           grepl <- base::grepl
[16:01:41.653]                           restarts <- computeRestarts(cond)
[16:01:41.653]                           for (restart in restarts) {
[16:01:41.653]                             name <- restart$name
[16:01:41.653]                             if (is.null(name)) 
[16:01:41.653]                               next
[16:01:41.653]                             if (!grepl(pattern, name)) 
[16:01:41.653]                               next
[16:01:41.653]                             invokeRestart(restart)
[16:01:41.653]                             muffled <- TRUE
[16:01:41.653]                             break
[16:01:41.653]                           }
[16:01:41.653]                         }
[16:01:41.653]                       }
[16:01:41.653]                       invisible(muffled)
[16:01:41.653]                     }
[16:01:41.653]                     muffleCondition(cond, pattern = "^muffle")
[16:01:41.653]                   }
[16:01:41.653]                 }
[16:01:41.653]                 else {
[16:01:41.653]                   if (TRUE) {
[16:01:41.653]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.653]                     {
[16:01:41.653]                       inherits <- base::inherits
[16:01:41.653]                       invokeRestart <- base::invokeRestart
[16:01:41.653]                       is.null <- base::is.null
[16:01:41.653]                       muffled <- FALSE
[16:01:41.653]                       if (inherits(cond, "message")) {
[16:01:41.653]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:41.653]                         if (muffled) 
[16:01:41.653]                           invokeRestart("muffleMessage")
[16:01:41.653]                       }
[16:01:41.653]                       else if (inherits(cond, "warning")) {
[16:01:41.653]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:41.653]                         if (muffled) 
[16:01:41.653]                           invokeRestart("muffleWarning")
[16:01:41.653]                       }
[16:01:41.653]                       else if (inherits(cond, "condition")) {
[16:01:41.653]                         if (!is.null(pattern)) {
[16:01:41.653]                           computeRestarts <- base::computeRestarts
[16:01:41.653]                           grepl <- base::grepl
[16:01:41.653]                           restarts <- computeRestarts(cond)
[16:01:41.653]                           for (restart in restarts) {
[16:01:41.653]                             name <- restart$name
[16:01:41.653]                             if (is.null(name)) 
[16:01:41.653]                               next
[16:01:41.653]                             if (!grepl(pattern, name)) 
[16:01:41.653]                               next
[16:01:41.653]                             invokeRestart(restart)
[16:01:41.653]                             muffled <- TRUE
[16:01:41.653]                             break
[16:01:41.653]                           }
[16:01:41.653]                         }
[16:01:41.653]                       }
[16:01:41.653]                       invisible(muffled)
[16:01:41.653]                     }
[16:01:41.653]                     muffleCondition(cond, pattern = "^muffle")
[16:01:41.653]                   }
[16:01:41.653]                 }
[16:01:41.653]             }
[16:01:41.653]         }))
[16:01:41.653]     }, error = function(ex) {
[16:01:41.653]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:41.653]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:41.653]                 ...future.rng), started = ...future.startTime, 
[16:01:41.653]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:41.653]             version = "1.8"), class = "FutureResult")
[16:01:41.653]     }, finally = {
[16:01:41.653]         if (!identical(...future.workdir, getwd())) 
[16:01:41.653]             setwd(...future.workdir)
[16:01:41.653]         {
[16:01:41.653]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:41.653]                 ...future.oldOptions$nwarnings <- NULL
[16:01:41.653]             }
[16:01:41.653]             base::options(...future.oldOptions)
[16:01:41.653]             if (.Platform$OS.type == "windows") {
[16:01:41.653]                 old_names <- names(...future.oldEnvVars)
[16:01:41.653]                 envs <- base::Sys.getenv()
[16:01:41.653]                 names <- names(envs)
[16:01:41.653]                 common <- intersect(names, old_names)
[16:01:41.653]                 added <- setdiff(names, old_names)
[16:01:41.653]                 removed <- setdiff(old_names, names)
[16:01:41.653]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:41.653]                   envs[common]]
[16:01:41.653]                 NAMES <- toupper(changed)
[16:01:41.653]                 args <- list()
[16:01:41.653]                 for (kk in seq_along(NAMES)) {
[16:01:41.653]                   name <- changed[[kk]]
[16:01:41.653]                   NAME <- NAMES[[kk]]
[16:01:41.653]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.653]                     next
[16:01:41.653]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:41.653]                 }
[16:01:41.653]                 NAMES <- toupper(added)
[16:01:41.653]                 for (kk in seq_along(NAMES)) {
[16:01:41.653]                   name <- added[[kk]]
[16:01:41.653]                   NAME <- NAMES[[kk]]
[16:01:41.653]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.653]                     next
[16:01:41.653]                   args[[name]] <- ""
[16:01:41.653]                 }
[16:01:41.653]                 NAMES <- toupper(removed)
[16:01:41.653]                 for (kk in seq_along(NAMES)) {
[16:01:41.653]                   name <- removed[[kk]]
[16:01:41.653]                   NAME <- NAMES[[kk]]
[16:01:41.653]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.653]                     next
[16:01:41.653]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:41.653]                 }
[16:01:41.653]                 if (length(args) > 0) 
[16:01:41.653]                   base::do.call(base::Sys.setenv, args = args)
[16:01:41.653]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:41.653]             }
[16:01:41.653]             else {
[16:01:41.653]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:41.653]             }
[16:01:41.653]             {
[16:01:41.653]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:41.653]                   0L) {
[16:01:41.653]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:41.653]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:41.653]                   base::options(opts)
[16:01:41.653]                 }
[16:01:41.653]                 {
[16:01:41.653]                   {
[16:01:41.653]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:41.653]                     NULL
[16:01:41.653]                   }
[16:01:41.653]                   options(future.plan = NULL)
[16:01:41.653]                   if (is.na(NA_character_)) 
[16:01:41.653]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:41.653]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:41.653]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:41.653]                     envir = parent.frame()) 
[16:01:41.653]                   {
[16:01:41.653]                     default_workers <- missing(workers)
[16:01:41.653]                     if (is.function(workers)) 
[16:01:41.653]                       workers <- workers()
[16:01:41.653]                     workers <- structure(as.integer(workers), 
[16:01:41.653]                       class = class(workers))
[16:01:41.653]                     stop_if_not(is.finite(workers), workers >= 
[16:01:41.653]                       1L)
[16:01:41.653]                     if ((workers == 1L && !inherits(workers, 
[16:01:41.653]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:41.653]                       if (default_workers) 
[16:01:41.653]                         supportsMulticore(warn = TRUE)
[16:01:41.653]                       return(sequential(..., envir = envir))
[16:01:41.653]                     }
[16:01:41.653]                     oopts <- options(mc.cores = workers)
[16:01:41.653]                     on.exit(options(oopts))
[16:01:41.653]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:41.653]                       envir = envir)
[16:01:41.653]                     if (!future$lazy) 
[16:01:41.653]                       future <- run(future)
[16:01:41.653]                     invisible(future)
[16:01:41.653]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:41.653]                 }
[16:01:41.653]             }
[16:01:41.653]         }
[16:01:41.653]     })
[16:01:41.653]     if (TRUE) {
[16:01:41.653]         base::sink(type = "output", split = FALSE)
[16:01:41.653]         if (TRUE) {
[16:01:41.653]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:41.653]         }
[16:01:41.653]         else {
[16:01:41.653]             ...future.result["stdout"] <- base::list(NULL)
[16:01:41.653]         }
[16:01:41.653]         base::close(...future.stdout)
[16:01:41.653]         ...future.stdout <- NULL
[16:01:41.653]     }
[16:01:41.653]     ...future.result$conditions <- ...future.conditions
[16:01:41.653]     ...future.result$finished <- base::Sys.time()
[16:01:41.653]     ...future.result
[16:01:41.653] }
[16:01:41.656] assign_globals() ...
[16:01:41.656] List of 5
[16:01:41.656]  $ future.call.arguments    : list()
[16:01:41.656]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:41.656]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[16:01:41.656]  $ ...future.elements_ii    :List of 1
[16:01:41.656]   ..$ : int [1:2] 1 3
[16:01:41.656]  $ ...future.seeds_ii       :List of 1
[16:01:41.656]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[16:01:41.656]  $ ...future.globals.maxSize: num Inf
[16:01:41.656]  - attr(*, "resolved")= logi FALSE
[16:01:41.656]  - attr(*, "total_size")= num NA
[16:01:41.656]  - attr(*, "where")=List of 5
[16:01:41.656]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:41.656]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:41.656]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:41.656]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:41.656]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:41.656]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:41.656]  - attr(*, "already-done")= logi TRUE
[16:01:41.661] - copied ‘future.call.arguments’ to environment
[16:01:41.661] - copied ‘...future.FUN’ to environment
[16:01:41.662] - copied ‘...future.elements_ii’ to environment
[16:01:41.662] - copied ‘...future.seeds_ii’ to environment
[16:01:41.662] - copied ‘...future.globals.maxSize’ to environment
[16:01:41.662] assign_globals() ... done
[16:01:41.662] requestCore(): workers = 2
[16:01:41.664] MulticoreFuture started
[16:01:41.665] - Launch lazy future ... done
[16:01:41.665] run() for ‘MulticoreFuture’ ... done
[16:01:41.665] Created future:
[16:01:41.665] plan(): Setting new future strategy stack:
[16:01:41.666] List of future strategies:
[16:01:41.666] 1. sequential:
[16:01:41.666]    - args: function (..., envir = parent.frame())
[16:01:41.666]    - tweaked: FALSE
[16:01:41.666]    - call: NULL
[16:01:41.667] plan(): nbrOfWorkers() = 1
[16:01:41.669] plan(): Setting new future strategy stack:
[16:01:41.669] List of future strategies:
[16:01:41.669] 1. multicore:
[16:01:41.669]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:41.669]    - tweaked: FALSE
[16:01:41.669]    - call: plan(strategy)
[16:01:41.666] MulticoreFuture:
[16:01:41.666] Label: ‘future_apply-1’
[16:01:41.666] Expression:
[16:01:41.666] {
[16:01:41.666]     do.call(function(...) {
[16:01:41.666]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.666]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:41.666]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.666]             on.exit(options(oopts), add = TRUE)
[16:01:41.666]         }
[16:01:41.666]         {
[16:01:41.666]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:41.666]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.666]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:01:41.666]                   envir = globalenv(), inherits = FALSE)
[16:01:41.666]                 ...future.FUN(...future.X_jj, ...)
[16:01:41.666]             })
[16:01:41.666]         }
[16:01:41.666]     }, args = future.call.arguments)
[16:01:41.666] }
[16:01:41.666] Lazy evaluation: FALSE
[16:01:41.666] Asynchronous evaluation: TRUE
[16:01:41.666] Local evaluation: TRUE
[16:01:41.666] Environment: R_GlobalEnv
[16:01:41.666] Capture standard output: TRUE
[16:01:41.666] Capture condition classes: <none>
[16:01:41.666] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:41.666] Packages: <none>
[16:01:41.666] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[16:01:41.666] Resolved: FALSE
[16:01:41.666] Value: <not collected>
[16:01:41.666] Conditions captured: <none>
[16:01:41.666] Early signaling: FALSE
[16:01:41.666] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:41.666] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:41.679] Chunk #1 of 2 ... DONE
[16:01:41.682] plan(): nbrOfWorkers() = 2
[16:01:41.682] Chunk #2 of 2 ...
[16:01:41.682]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:41.683]  - seeds: [1] <seeds>
[16:01:41.683]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.683] getGlobalsAndPackages() ...
[16:01:41.684] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.684] Resolving globals: FALSE
[16:01:41.684] Tweak future expression to call with '...' arguments ...
[16:01:41.684] {
[16:01:41.684]     do.call(function(...) {
[16:01:41.684]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.684]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:41.684]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.684]             on.exit(options(oopts), add = TRUE)
[16:01:41.684]         }
[16:01:41.684]         {
[16:01:41.684]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:41.684]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.684]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:01:41.684]                   envir = globalenv(), inherits = FALSE)
[16:01:41.684]                 ...future.FUN(...future.X_jj, ...)
[16:01:41.684]             })
[16:01:41.684]         }
[16:01:41.684]     }, args = future.call.arguments)
[16:01:41.684] }
[16:01:41.685] Tweak future expression to call with '...' arguments ... DONE
[16:01:41.686] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:41.686] 
[16:01:41.687] getGlobalsAndPackages() ... DONE
[16:01:41.687] run() for ‘Future’ ...
[16:01:41.688] - state: ‘created’
[16:01:41.688] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:01:41.694] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:41.694] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:01:41.695]   - Field: ‘label’
[16:01:41.695]   - Field: ‘local’
[16:01:41.695]   - Field: ‘owner’
[16:01:41.695]   - Field: ‘envir’
[16:01:41.696]   - Field: ‘workers’
[16:01:41.696]   - Field: ‘packages’
[16:01:41.696]   - Field: ‘gc’
[16:01:41.696]   - Field: ‘job’
[16:01:41.696]   - Field: ‘conditions’
[16:01:41.697]   - Field: ‘expr’
[16:01:41.697]   - Field: ‘uuid’
[16:01:41.697]   - Field: ‘seed’
[16:01:41.697]   - Field: ‘version’
[16:01:41.697]   - Field: ‘result’
[16:01:41.697]   - Field: ‘asynchronous’
[16:01:41.697]   - Field: ‘calls’
[16:01:41.698]   - Field: ‘globals’
[16:01:41.698]   - Field: ‘stdout’
[16:01:41.698]   - Field: ‘earlySignal’
[16:01:41.698]   - Field: ‘lazy’
[16:01:41.698]   - Field: ‘state’
[16:01:41.698] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:01:41.699] - Launch lazy future ...
[16:01:41.699] Packages needed by the future expression (n = 0): <none>
[16:01:41.699] Packages needed by future strategies (n = 0): <none>
[16:01:41.700] {
[16:01:41.700]     {
[16:01:41.700]         {
[16:01:41.700]             ...future.startTime <- base::Sys.time()
[16:01:41.700]             {
[16:01:41.700]                 {
[16:01:41.700]                   {
[16:01:41.700]                     {
[16:01:41.700]                       base::local({
[16:01:41.700]                         has_future <- base::requireNamespace("future", 
[16:01:41.700]                           quietly = TRUE)
[16:01:41.700]                         if (has_future) {
[16:01:41.700]                           ns <- base::getNamespace("future")
[16:01:41.700]                           version <- ns[[".package"]][["version"]]
[16:01:41.700]                           if (is.null(version)) 
[16:01:41.700]                             version <- utils::packageVersion("future")
[16:01:41.700]                         }
[16:01:41.700]                         else {
[16:01:41.700]                           version <- NULL
[16:01:41.700]                         }
[16:01:41.700]                         if (!has_future || version < "1.8.0") {
[16:01:41.700]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:41.700]                             "", base::R.version$version.string), 
[16:01:41.700]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:41.700]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:41.700]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:41.700]                               "release", "version")], collapse = " "), 
[16:01:41.700]                             hostname = base::Sys.info()[["nodename"]])
[16:01:41.700]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:41.700]                             info)
[16:01:41.700]                           info <- base::paste(info, collapse = "; ")
[16:01:41.700]                           if (!has_future) {
[16:01:41.700]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:41.700]                               info)
[16:01:41.700]                           }
[16:01:41.700]                           else {
[16:01:41.700]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:41.700]                               info, version)
[16:01:41.700]                           }
[16:01:41.700]                           base::stop(msg)
[16:01:41.700]                         }
[16:01:41.700]                       })
[16:01:41.700]                     }
[16:01:41.700]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:41.700]                     base::options(mc.cores = 1L)
[16:01:41.700]                   }
[16:01:41.700]                   options(future.plan = NULL)
[16:01:41.700]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:41.700]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:41.700]                 }
[16:01:41.700]                 ...future.workdir <- getwd()
[16:01:41.700]             }
[16:01:41.700]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:41.700]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:41.700]         }
[16:01:41.700]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:41.700]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:41.700]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:41.700]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:41.700]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:41.700]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:41.700]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:41.700]             base::names(...future.oldOptions))
[16:01:41.700]     }
[16:01:41.700]     if (FALSE) {
[16:01:41.700]     }
[16:01:41.700]     else {
[16:01:41.700]         if (TRUE) {
[16:01:41.700]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:41.700]                 open = "w")
[16:01:41.700]         }
[16:01:41.700]         else {
[16:01:41.700]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:41.700]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:41.700]         }
[16:01:41.700]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:41.700]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:41.700]             base::sink(type = "output", split = FALSE)
[16:01:41.700]             base::close(...future.stdout)
[16:01:41.700]         }, add = TRUE)
[16:01:41.700]     }
[16:01:41.700]     ...future.frame <- base::sys.nframe()
[16:01:41.700]     ...future.conditions <- base::list()
[16:01:41.700]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:41.700]     if (FALSE) {
[16:01:41.700]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:41.700]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:41.700]     }
[16:01:41.700]     ...future.result <- base::tryCatch({
[16:01:41.700]         base::withCallingHandlers({
[16:01:41.700]             ...future.value <- base::withVisible(base::local({
[16:01:41.700]                 withCallingHandlers({
[16:01:41.700]                   {
[16:01:41.700]                     do.call(function(...) {
[16:01:41.700]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.700]                       if (!identical(...future.globals.maxSize.org, 
[16:01:41.700]                         ...future.globals.maxSize)) {
[16:01:41.700]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.700]                         on.exit(options(oopts), add = TRUE)
[16:01:41.700]                       }
[16:01:41.700]                       {
[16:01:41.700]                         lapply(seq_along(...future.elements_ii), 
[16:01:41.700]                           FUN = function(jj) {
[16:01:41.700]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.700]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:01:41.700]                               envir = globalenv(), inherits = FALSE)
[16:01:41.700]                             ...future.FUN(...future.X_jj, ...)
[16:01:41.700]                           })
[16:01:41.700]                       }
[16:01:41.700]                     }, args = future.call.arguments)
[16:01:41.700]                   }
[16:01:41.700]                 }, immediateCondition = function(cond) {
[16:01:41.700]                   save_rds <- function (object, pathname, ...) 
[16:01:41.700]                   {
[16:01:41.700]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:01:41.700]                     if (file_test("-f", pathname_tmp)) {
[16:01:41.700]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.700]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:01:41.700]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.700]                         fi_tmp[["mtime"]])
[16:01:41.700]                     }
[16:01:41.700]                     tryCatch({
[16:01:41.700]                       saveRDS(object, file = pathname_tmp, ...)
[16:01:41.700]                     }, error = function(ex) {
[16:01:41.700]                       msg <- conditionMessage(ex)
[16:01:41.700]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.700]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:01:41.700]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.700]                         fi_tmp[["mtime"]], msg)
[16:01:41.700]                       ex$message <- msg
[16:01:41.700]                       stop(ex)
[16:01:41.700]                     })
[16:01:41.700]                     stopifnot(file_test("-f", pathname_tmp))
[16:01:41.700]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:01:41.700]                     if (!res || file_test("-f", pathname_tmp)) {
[16:01:41.700]                       fi_tmp <- file.info(pathname_tmp)
[16:01:41.700]                       fi <- file.info(pathname)
[16:01:41.700]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:01:41.700]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:01:41.700]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:01:41.700]                         fi[["size"]], fi[["mtime"]])
[16:01:41.700]                       stop(msg)
[16:01:41.700]                     }
[16:01:41.700]                     invisible(pathname)
[16:01:41.700]                   }
[16:01:41.700]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:01:41.700]                     rootPath = tempdir()) 
[16:01:41.700]                   {
[16:01:41.700]                     obj <- list(time = Sys.time(), condition = cond)
[16:01:41.700]                     file <- tempfile(pattern = class(cond)[1], 
[16:01:41.700]                       tmpdir = path, fileext = ".rds")
[16:01:41.700]                     save_rds(obj, file)
[16:01:41.700]                   }
[16:01:41.700]                   saveImmediateCondition(cond, path = "/tmp/RtmplAoKyr/.future/immediateConditions")
[16:01:41.700]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.700]                   {
[16:01:41.700]                     inherits <- base::inherits
[16:01:41.700]                     invokeRestart <- base::invokeRestart
[16:01:41.700]                     is.null <- base::is.null
[16:01:41.700]                     muffled <- FALSE
[16:01:41.700]                     if (inherits(cond, "message")) {
[16:01:41.700]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:41.700]                       if (muffled) 
[16:01:41.700]                         invokeRestart("muffleMessage")
[16:01:41.700]                     }
[16:01:41.700]                     else if (inherits(cond, "warning")) {
[16:01:41.700]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:41.700]                       if (muffled) 
[16:01:41.700]                         invokeRestart("muffleWarning")
[16:01:41.700]                     }
[16:01:41.700]                     else if (inherits(cond, "condition")) {
[16:01:41.700]                       if (!is.null(pattern)) {
[16:01:41.700]                         computeRestarts <- base::computeRestarts
[16:01:41.700]                         grepl <- base::grepl
[16:01:41.700]                         restarts <- computeRestarts(cond)
[16:01:41.700]                         for (restart in restarts) {
[16:01:41.700]                           name <- restart$name
[16:01:41.700]                           if (is.null(name)) 
[16:01:41.700]                             next
[16:01:41.700]                           if (!grepl(pattern, name)) 
[16:01:41.700]                             next
[16:01:41.700]                           invokeRestart(restart)
[16:01:41.700]                           muffled <- TRUE
[16:01:41.700]                           break
[16:01:41.700]                         }
[16:01:41.700]                       }
[16:01:41.700]                     }
[16:01:41.700]                     invisible(muffled)
[16:01:41.700]                   }
[16:01:41.700]                   muffleCondition(cond)
[16:01:41.700]                 })
[16:01:41.700]             }))
[16:01:41.700]             future::FutureResult(value = ...future.value$value, 
[16:01:41.700]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:41.700]                   ...future.rng), globalenv = if (FALSE) 
[16:01:41.700]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:41.700]                     ...future.globalenv.names))
[16:01:41.700]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:41.700]         }, condition = base::local({
[16:01:41.700]             c <- base::c
[16:01:41.700]             inherits <- base::inherits
[16:01:41.700]             invokeRestart <- base::invokeRestart
[16:01:41.700]             length <- base::length
[16:01:41.700]             list <- base::list
[16:01:41.700]             seq.int <- base::seq.int
[16:01:41.700]             signalCondition <- base::signalCondition
[16:01:41.700]             sys.calls <- base::sys.calls
[16:01:41.700]             `[[` <- base::`[[`
[16:01:41.700]             `+` <- base::`+`
[16:01:41.700]             `<<-` <- base::`<<-`
[16:01:41.700]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:41.700]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:41.700]                   3L)]
[16:01:41.700]             }
[16:01:41.700]             function(cond) {
[16:01:41.700]                 is_error <- inherits(cond, "error")
[16:01:41.700]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:41.700]                   NULL)
[16:01:41.700]                 if (is_error) {
[16:01:41.700]                   sessionInformation <- function() {
[16:01:41.700]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:41.700]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:41.700]                       search = base::search(), system = base::Sys.info())
[16:01:41.700]                   }
[16:01:41.700]                   ...future.conditions[[length(...future.conditions) + 
[16:01:41.700]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:41.700]                     cond$call), session = sessionInformation(), 
[16:01:41.700]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:41.700]                   signalCondition(cond)
[16:01:41.700]                 }
[16:01:41.700]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[16:01:41.700]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:41.700]                   ...future.conditions[[length(...future.conditions) + 
[16:01:41.700]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:41.700]                   if (TRUE && !signal) {
[16:01:41.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.700]                     {
[16:01:41.700]                       inherits <- base::inherits
[16:01:41.700]                       invokeRestart <- base::invokeRestart
[16:01:41.700]                       is.null <- base::is.null
[16:01:41.700]                       muffled <- FALSE
[16:01:41.700]                       if (inherits(cond, "message")) {
[16:01:41.700]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:41.700]                         if (muffled) 
[16:01:41.700]                           invokeRestart("muffleMessage")
[16:01:41.700]                       }
[16:01:41.700]                       else if (inherits(cond, "warning")) {
[16:01:41.700]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:41.700]                         if (muffled) 
[16:01:41.700]                           invokeRestart("muffleWarning")
[16:01:41.700]                       }
[16:01:41.700]                       else if (inherits(cond, "condition")) {
[16:01:41.700]                         if (!is.null(pattern)) {
[16:01:41.700]                           computeRestarts <- base::computeRestarts
[16:01:41.700]                           grepl <- base::grepl
[16:01:41.700]                           restarts <- computeRestarts(cond)
[16:01:41.700]                           for (restart in restarts) {
[16:01:41.700]                             name <- restart$name
[16:01:41.700]                             if (is.null(name)) 
[16:01:41.700]                               next
[16:01:41.700]                             if (!grepl(pattern, name)) 
[16:01:41.700]                               next
[16:01:41.700]                             invokeRestart(restart)
[16:01:41.700]                             muffled <- TRUE
[16:01:41.700]                             break
[16:01:41.700]                           }
[16:01:41.700]                         }
[16:01:41.700]                       }
[16:01:41.700]                       invisible(muffled)
[16:01:41.700]                     }
[16:01:41.700]                     muffleCondition(cond, pattern = "^muffle")
[16:01:41.700]                   }
[16:01:41.700]                 }
[16:01:41.700]                 else {
[16:01:41.700]                   if (TRUE) {
[16:01:41.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:41.700]                     {
[16:01:41.700]                       inherits <- base::inherits
[16:01:41.700]                       invokeRestart <- base::invokeRestart
[16:01:41.700]                       is.null <- base::is.null
[16:01:41.700]                       muffled <- FALSE
[16:01:41.700]                       if (inherits(cond, "message")) {
[16:01:41.700]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:41.700]                         if (muffled) 
[16:01:41.700]                           invokeRestart("muffleMessage")
[16:01:41.700]                       }
[16:01:41.700]                       else if (inherits(cond, "warning")) {
[16:01:41.700]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:41.700]                         if (muffled) 
[16:01:41.700]                           invokeRestart("muffleWarning")
[16:01:41.700]                       }
[16:01:41.700]                       else if (inherits(cond, "condition")) {
[16:01:41.700]                         if (!is.null(pattern)) {
[16:01:41.700]                           computeRestarts <- base::computeRestarts
[16:01:41.700]                           grepl <- base::grepl
[16:01:41.700]                           restarts <- computeRestarts(cond)
[16:01:41.700]                           for (restart in restarts) {
[16:01:41.700]                             name <- restart$name
[16:01:41.700]                             if (is.null(name)) 
[16:01:41.700]                               next
[16:01:41.700]                             if (!grepl(pattern, name)) 
[16:01:41.700]                               next
[16:01:41.700]                             invokeRestart(restart)
[16:01:41.700]                             muffled <- TRUE
[16:01:41.700]                             break
[16:01:41.700]                           }
[16:01:41.700]                         }
[16:01:41.700]                       }
[16:01:41.700]                       invisible(muffled)
[16:01:41.700]                     }
[16:01:41.700]                     muffleCondition(cond, pattern = "^muffle")
[16:01:41.700]                   }
[16:01:41.700]                 }
[16:01:41.700]             }
[16:01:41.700]         }))
[16:01:41.700]     }, error = function(ex) {
[16:01:41.700]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:41.700]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:41.700]                 ...future.rng), started = ...future.startTime, 
[16:01:41.700]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:41.700]             version = "1.8"), class = "FutureResult")
[16:01:41.700]     }, finally = {
[16:01:41.700]         if (!identical(...future.workdir, getwd())) 
[16:01:41.700]             setwd(...future.workdir)
[16:01:41.700]         {
[16:01:41.700]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:41.700]                 ...future.oldOptions$nwarnings <- NULL
[16:01:41.700]             }
[16:01:41.700]             base::options(...future.oldOptions)
[16:01:41.700]             if (.Platform$OS.type == "windows") {
[16:01:41.700]                 old_names <- names(...future.oldEnvVars)
[16:01:41.700]                 envs <- base::Sys.getenv()
[16:01:41.700]                 names <- names(envs)
[16:01:41.700]                 common <- intersect(names, old_names)
[16:01:41.700]                 added <- setdiff(names, old_names)
[16:01:41.700]                 removed <- setdiff(old_names, names)
[16:01:41.700]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:41.700]                   envs[common]]
[16:01:41.700]                 NAMES <- toupper(changed)
[16:01:41.700]                 args <- list()
[16:01:41.700]                 for (kk in seq_along(NAMES)) {
[16:01:41.700]                   name <- changed[[kk]]
[16:01:41.700]                   NAME <- NAMES[[kk]]
[16:01:41.700]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.700]                     next
[16:01:41.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:41.700]                 }
[16:01:41.700]                 NAMES <- toupper(added)
[16:01:41.700]                 for (kk in seq_along(NAMES)) {
[16:01:41.700]                   name <- added[[kk]]
[16:01:41.700]                   NAME <- NAMES[[kk]]
[16:01:41.700]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.700]                     next
[16:01:41.700]                   args[[name]] <- ""
[16:01:41.700]                 }
[16:01:41.700]                 NAMES <- toupper(removed)
[16:01:41.700]                 for (kk in seq_along(NAMES)) {
[16:01:41.700]                   name <- removed[[kk]]
[16:01:41.700]                   NAME <- NAMES[[kk]]
[16:01:41.700]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:41.700]                     next
[16:01:41.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:41.700]                 }
[16:01:41.700]                 if (length(args) > 0) 
[16:01:41.700]                   base::do.call(base::Sys.setenv, args = args)
[16:01:41.700]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:41.700]             }
[16:01:41.700]             else {
[16:01:41.700]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:41.700]             }
[16:01:41.700]             {
[16:01:41.700]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:41.700]                   0L) {
[16:01:41.700]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:41.700]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:41.700]                   base::options(opts)
[16:01:41.700]                 }
[16:01:41.700]                 {
[16:01:41.700]                   {
[16:01:41.700]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:41.700]                     NULL
[16:01:41.700]                   }
[16:01:41.700]                   options(future.plan = NULL)
[16:01:41.700]                   if (is.na(NA_character_)) 
[16:01:41.700]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:41.700]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:41.700]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:01:41.700]                     envir = parent.frame()) 
[16:01:41.700]                   {
[16:01:41.700]                     default_workers <- missing(workers)
[16:01:41.700]                     if (is.function(workers)) 
[16:01:41.700]                       workers <- workers()
[16:01:41.700]                     workers <- structure(as.integer(workers), 
[16:01:41.700]                       class = class(workers))
[16:01:41.700]                     stop_if_not(is.finite(workers), workers >= 
[16:01:41.700]                       1L)
[16:01:41.700]                     if ((workers == 1L && !inherits(workers, 
[16:01:41.700]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:01:41.700]                       if (default_workers) 
[16:01:41.700]                         supportsMulticore(warn = TRUE)
[16:01:41.700]                       return(sequential(..., envir = envir))
[16:01:41.700]                     }
[16:01:41.700]                     oopts <- options(mc.cores = workers)
[16:01:41.700]                     on.exit(options(oopts))
[16:01:41.700]                     future <- MulticoreFuture(..., workers = workers, 
[16:01:41.700]                       envir = envir)
[16:01:41.700]                     if (!future$lazy) 
[16:01:41.700]                       future <- run(future)
[16:01:41.700]                     invisible(future)
[16:01:41.700]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:41.700]                 }
[16:01:41.700]             }
[16:01:41.700]         }
[16:01:41.700]     })
[16:01:41.700]     if (TRUE) {
[16:01:41.700]         base::sink(type = "output", split = FALSE)
[16:01:41.700]         if (TRUE) {
[16:01:41.700]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:41.700]         }
[16:01:41.700]         else {
[16:01:41.700]             ...future.result["stdout"] <- base::list(NULL)
[16:01:41.700]         }
[16:01:41.700]         base::close(...future.stdout)
[16:01:41.700]         ...future.stdout <- NULL
[16:01:41.700]     }
[16:01:41.700]     ...future.result$conditions <- ...future.conditions
[16:01:41.700]     ...future.result$finished <- base::Sys.time()
[16:01:41.700]     ...future.result
[16:01:41.700] }
[16:01:41.703] assign_globals() ...
[16:01:41.704] List of 5
[16:01:41.704]  $ future.call.arguments    : list()
[16:01:41.704]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:41.704]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[16:01:41.704]  $ ...future.elements_ii    :List of 1
[16:01:41.704]   ..$ : int [1:2] 2 4
[16:01:41.704]  $ ...future.seeds_ii       :List of 1
[16:01:41.704]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[16:01:41.704]  $ ...future.globals.maxSize: num Inf
[16:01:41.704]  - attr(*, "resolved")= logi FALSE
[16:01:41.704]  - attr(*, "total_size")= num NA
[16:01:41.704]  - attr(*, "where")=List of 5
[16:01:41.704]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:01:41.704]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:01:41.704]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:01:41.704]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:01:41.704]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:01:41.704]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:41.704]  - attr(*, "already-done")= logi TRUE
[16:01:41.711] - copied ‘future.call.arguments’ to environment
[16:01:41.711] - copied ‘...future.FUN’ to environment
[16:01:41.711] - copied ‘...future.elements_ii’ to environment
[16:01:41.711] - copied ‘...future.seeds_ii’ to environment
[16:01:41.711] - copied ‘...future.globals.maxSize’ to environment
[16:01:41.711] assign_globals() ... done
[16:01:41.712] requestCore(): workers = 2
[16:01:41.714] MulticoreFuture started
[16:01:41.714] - Launch lazy future ... done
[16:01:41.715] run() for ‘MulticoreFuture’ ... done
[16:01:41.715] Created future:
[16:01:41.715] plan(): Setting new future strategy stack:
[16:01:41.715] List of future strategies:
[16:01:41.715] 1. sequential:
[16:01:41.715]    - args: function (..., envir = parent.frame())
[16:01:41.715]    - tweaked: FALSE
[16:01:41.715]    - call: NULL
[16:01:41.716] plan(): nbrOfWorkers() = 1
[16:01:41.718] plan(): Setting new future strategy stack:
[16:01:41.719] List of future strategies:
[16:01:41.719] 1. multicore:
[16:01:41.719]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:01:41.719]    - tweaked: FALSE
[16:01:41.719]    - call: plan(strategy)
[16:01:41.724] plan(): nbrOfWorkers() = 2
[16:01:41.715] MulticoreFuture:
[16:01:41.715] Label: ‘future_apply-2’
[16:01:41.715] Expression:
[16:01:41.715] {
[16:01:41.715]     do.call(function(...) {
[16:01:41.715]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:41.715]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:41.715]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:41.715]             on.exit(options(oopts), add = TRUE)
[16:01:41.715]         }
[16:01:41.715]         {
[16:01:41.715]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:41.715]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:41.715]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:01:41.715]                   envir = globalenv(), inherits = FALSE)
[16:01:41.715]                 ...future.FUN(...future.X_jj, ...)
[16:01:41.715]             })
[16:01:41.715]         }
[16:01:41.715]     }, args = future.call.arguments)
[16:01:41.715] }
[16:01:41.715] Lazy evaluation: FALSE
[16:01:41.715] Asynchronous evaluation: TRUE
[16:01:41.715] Local evaluation: TRUE
[16:01:41.715] Environment: R_GlobalEnv
[16:01:41.715] Capture standard output: TRUE
[16:01:41.715] Capture condition classes: <none>
[16:01:41.715] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:41.715] Packages: <none>
[16:01:41.715] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[16:01:41.715] Resolved: TRUE
[16:01:41.715] Value: <not collected>
[16:01:41.715] Conditions captured: <none>
[16:01:41.715] Early signaling: FALSE
[16:01:41.715] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:41.715] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:41.725] Chunk #2 of 2 ... DONE
[16:01:41.725] Launching 2 futures (chunks) ... DONE
[16:01:41.726] Resolving 2 futures (chunks) ...
[16:01:41.726] resolve() on list ...
[16:01:41.726]  recursive: 0
[16:01:41.726]  length: 2
[16:01:41.726] 
[16:01:41.727] Future #1
[16:01:41.727] result() for MulticoreFuture ...
[16:01:41.728] result() for MulticoreFuture ...
[16:01:41.728] result() for MulticoreFuture ... done
[16:01:41.728] result() for MulticoreFuture ... done
[16:01:41.728] result() for MulticoreFuture ...
[16:01:41.728] result() for MulticoreFuture ... done
[16:01:41.729] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:01:41.729] - nx: 2
[16:01:41.729] - relay: TRUE
[16:01:41.729] - stdout: TRUE
[16:01:41.729] - signal: TRUE
[16:01:41.729] - resignal: FALSE
[16:01:41.729] - force: TRUE
[16:01:41.730] - relayed: [n=2] FALSE, FALSE
[16:01:41.730] - queued futures: [n=2] FALSE, FALSE
[16:01:41.730]  - until=1
[16:01:41.730]  - relaying element #1
[16:01:41.730] result() for MulticoreFuture ...
[16:01:41.730] result() for MulticoreFuture ... done
[16:01:41.731] result() for MulticoreFuture ...
[16:01:41.731] result() for MulticoreFuture ... done
[16:01:41.731] result() for MulticoreFuture ...
[16:01:41.731] result() for MulticoreFuture ... done
[16:01:41.731] result() for MulticoreFuture ...
[16:01:41.731] result() for MulticoreFuture ... done
[16:01:41.732] - relayed: [n=2] TRUE, FALSE
[16:01:41.732] - queued futures: [n=2] TRUE, FALSE
[16:01:41.732] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:01:41.732]  length: 1 (resolved future 1)
[16:01:41.732] Future #2
[16:01:41.733] result() for MulticoreFuture ...
[16:01:41.733] result() for MulticoreFuture ...
[16:01:41.733] result() for MulticoreFuture ... done
[16:01:41.734] result() for MulticoreFuture ... done
[16:01:41.737] result() for MulticoreFuture ...
[16:01:41.737] result() for MulticoreFuture ... done
[16:01:41.738] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:01:41.738] - nx: 2
[16:01:41.738] - relay: TRUE
[16:01:41.738] - stdout: TRUE
[16:01:41.738] - signal: TRUE
[16:01:41.738] - resignal: FALSE
[16:01:41.739] - force: TRUE
[16:01:41.739] - relayed: [n=2] TRUE, FALSE
[16:01:41.739] - queued futures: [n=2] TRUE, FALSE
[16:01:41.739]  - until=2
[16:01:41.739]  - relaying element #2
[16:01:41.739] result() for MulticoreFuture ...
[16:01:41.740] result() for MulticoreFuture ... done
[16:01:41.740] result() for MulticoreFuture ...
[16:01:41.740] result() for MulticoreFuture ... done
[16:01:41.740] result() for MulticoreFuture ...
[16:01:41.740] result() for MulticoreFuture ... done
[16:01:41.741] result() for MulticoreFuture ...
[16:01:41.741] result() for MulticoreFuture ... done
[16:01:41.741] - relayed: [n=2] TRUE, TRUE
[16:01:41.741] - queued futures: [n=2] TRUE, TRUE
[16:01:41.741] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:01:41.741]  length: 0 (resolved future 2)
[16:01:41.741] Relaying remaining futures
[16:01:41.742] signalConditionsASAP(NULL, pos=0) ...
[16:01:41.742] - nx: 2
[16:01:41.742] - relay: TRUE
[16:01:41.742] - stdout: TRUE
[16:01:41.742] - signal: TRUE
[16:01:41.742] - resignal: FALSE
[16:01:41.743] - force: TRUE
[16:01:41.743] - relayed: [n=2] TRUE, TRUE
[16:01:41.743] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:41.743] - relayed: [n=2] TRUE, TRUE
[16:01:41.743] - queued futures: [n=2] TRUE, TRUE
[16:01:41.743] signalConditionsASAP(NULL, pos=0) ... done
[16:01:41.744] resolve() on list ... DONE
[16:01:41.744] result() for MulticoreFuture ...
[16:01:41.744] result() for MulticoreFuture ... done
[16:01:41.744] result() for MulticoreFuture ...
[16:01:41.744] result() for MulticoreFuture ... done
[16:01:41.744] result() for MulticoreFuture ...
[16:01:41.744] result() for MulticoreFuture ... done
[16:01:41.745] result() for MulticoreFuture ...
[16:01:41.745] result() for MulticoreFuture ... done
[16:01:41.745]  - Number of value chunks collected: 2
[16:01:41.745] Resolving 2 futures (chunks) ... DONE
[16:01:41.745] Reducing values from 2 chunks ...
[16:01:41.745]  - Number of values collected after concatenation: 2
[16:01:41.745]  - Number of values expected: 2
[16:01:41.745] Reducing values from 2 chunks ... DONE
[16:01:41.746] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[16:01:41.746] plan(): Setting new future strategy stack:
[16:01:41.746] List of future strategies:
[16:01:41.746] 1. sequential:
[16:01:41.746]    - args: function (..., envir = parent.frame())
[16:01:41.746]    - tweaked: FALSE
[16:01:41.746]    - call: plan(sequential)
[16:01:41.747] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[16:01:41.747] plan(): Setting new future strategy stack:
[16:01:41.747] List of future strategies:
[16:01:41.747] 1. multisession:
[16:01:41.747]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:01:41.747]    - tweaked: FALSE
[16:01:41.747]    - call: plan(strategy)
[16:01:41.748] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:01:41.748] multisession:
[16:01:41.748] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:01:41.748] - tweaked: FALSE
[16:01:41.748] - call: plan(strategy)
[16:01:41.756] getGlobalsAndPackages() ...
[16:01:41.756] Not searching for globals
[16:01:41.757] - globals: [0] <none>
[16:01:41.757] getGlobalsAndPackages() ... DONE
[16:01:41.757] [local output] makeClusterPSOCK() ...
[16:01:41.807] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:01:41.808] [local output] Base port: 11384
[16:01:41.809] [local output] Getting setup options for 2 cluster nodes ...
[16:01:41.809] [local output]  - Node 1 of 2 ...
[16:01:41.809] [local output] localMachine=TRUE => revtunnel=FALSE

[16:01:41.810] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmplAoKyr/worker.rank=1.parallelly.parent=68182.10a564f07d67e.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmplAoKyr/worker.rank=1.parallelly.parent=68182.10a564f07d67e.pid")'’
[16:01:42.007] - Possible to infer worker's PID: TRUE
[16:01:42.007] [local output] Rscript port: 11384

[16:01:42.008] [local output]  - Node 2 of 2 ...
[16:01:42.008] [local output] localMachine=TRUE => revtunnel=FALSE

[16:01:42.009] [local output] Rscript port: 11384

[16:01:42.009] [local output] Getting setup options for 2 cluster nodes ... done
[16:01:42.009] [local output]  - Parallel setup requested for some PSOCK nodes
[16:01:42.010] [local output] Setting up PSOCK nodes in parallel
[16:01:42.010] List of 36
[16:01:42.010]  $ worker          : chr "localhost"
[16:01:42.010]   ..- attr(*, "localhost")= logi TRUE
[16:01:42.010]  $ master          : chr "localhost"
[16:01:42.010]  $ port            : int 11384
[16:01:42.010]  $ connectTimeout  : num 120
[16:01:42.010]  $ timeout         : num 2592000
[16:01:42.010]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:01:42.010]  $ homogeneous     : logi TRUE
[16:01:42.010]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:01:42.010]  $ rscript_envs    : NULL
[16:01:42.010]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:01:42.010]  $ rscript_startup : NULL
[16:01:42.010]  $ rscript_sh      : chr "sh"
[16:01:42.010]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:01:42.010]  $ methods         : logi TRUE
[16:01:42.010]  $ socketOptions   : chr "no-delay"
[16:01:42.010]  $ useXDR          : logi FALSE
[16:01:42.010]  $ outfile         : chr "/dev/null"
[16:01:42.010]  $ renice          : int NA
[16:01:42.010]  $ rshcmd          : NULL
[16:01:42.010]  $ user            : chr(0) 
[16:01:42.010]  $ revtunnel       : logi FALSE
[16:01:42.010]  $ rshlogfile      : NULL
[16:01:42.010]  $ rshopts         : chr(0) 
[16:01:42.010]  $ rank            : int 1
[16:01:42.010]  $ manual          : logi FALSE
[16:01:42.010]  $ dryrun          : logi FALSE
[16:01:42.010]  $ quiet           : logi FALSE
[16:01:42.010]  $ setup_strategy  : chr "parallel"
[16:01:42.010]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:01:42.010]  $ pidfile         : chr "/tmp/RtmplAoKyr/worker.rank=1.parallelly.parent=68182.10a564f07d67e.pid"
[16:01:42.010]  $ rshcmd_label    : NULL
[16:01:42.010]  $ rsh_call        : NULL
[16:01:42.010]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:01:42.010]  $ localMachine    : logi TRUE
[16:01:42.010]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:01:42.010]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:01:42.010]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:01:42.010]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:01:42.010]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:01:42.010]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:01:42.010]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:01:42.010]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:01:42.010]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:01:42.010]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:01:42.010]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:01:42.010]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:01:42.010]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:01:42.010]  $ arguments       :List of 28
[16:01:42.010]   ..$ worker          : chr "localhost"
[16:01:42.010]   ..$ master          : NULL
[16:01:42.010]   ..$ port            : int 11384
[16:01:42.010]   ..$ connectTimeout  : num 120
[16:01:42.010]   ..$ timeout         : num 2592000
[16:01:42.010]   ..$ rscript         : NULL
[16:01:42.010]   ..$ homogeneous     : NULL
[16:01:42.010]   ..$ rscript_args    : NULL
[16:01:42.010]   ..$ rscript_envs    : NULL
[16:01:42.010]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:01:42.010]   ..$ rscript_startup : NULL
[16:01:42.010]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:01:42.010]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:01:42.010]   ..$ methods         : logi TRUE
[16:01:42.010]   ..$ socketOptions   : chr "no-delay"
[16:01:42.010]   ..$ useXDR          : logi FALSE
[16:01:42.010]   ..$ outfile         : chr "/dev/null"
[16:01:42.010]   ..$ renice          : int NA
[16:01:42.010]   ..$ rshcmd          : NULL
[16:01:42.010]   ..$ user            : NULL
[16:01:42.010]   ..$ revtunnel       : logi NA
[16:01:42.010]   ..$ rshlogfile      : NULL
[16:01:42.010]   ..$ rshopts         : NULL
[16:01:42.010]   ..$ rank            : int 1
[16:01:42.010]   ..$ manual          : logi FALSE
[16:01:42.010]   ..$ dryrun          : logi FALSE
[16:01:42.010]   ..$ quiet           : logi FALSE
[16:01:42.010]   ..$ setup_strategy  : chr "parallel"
[16:01:42.010]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:01:42.027] [local output] System call to launch all workers:
[16:01:42.027] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmplAoKyr/worker.rank=1.parallelly.parent=68182.10a564f07d67e.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11384 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:01:42.027] [local output] Starting PSOCK main server
[16:01:42.033] [local output] Workers launched
[16:01:42.033] [local output] Waiting for workers to connect back
[16:01:42.033]  - [local output] 0 workers out of 2 ready
[16:01:42.282]  - [local output] 0 workers out of 2 ready
[16:01:42.282]  - [local output] 1 workers out of 2 ready
[16:01:42.284]  - [local output] 1 workers out of 2 ready
[16:01:42.285]  - [local output] 2 workers out of 2 ready
[16:01:42.285] [local output] Launching of workers completed
[16:01:42.285] [local output] Collecting session information from workers
[16:01:42.286] [local output]  - Worker #1 of 2
[16:01:42.287] [local output]  - Worker #2 of 2
[16:01:42.287] [local output] makeClusterPSOCK() ... done
[16:01:42.298] Packages needed by the future expression (n = 0): <none>
[16:01:42.298] Packages needed by future strategies (n = 0): <none>
[16:01:42.299] {
[16:01:42.299]     {
[16:01:42.299]         {
[16:01:42.299]             ...future.startTime <- base::Sys.time()
[16:01:42.299]             {
[16:01:42.299]                 {
[16:01:42.299]                   {
[16:01:42.299]                     {
[16:01:42.299]                       base::local({
[16:01:42.299]                         has_future <- base::requireNamespace("future", 
[16:01:42.299]                           quietly = TRUE)
[16:01:42.299]                         if (has_future) {
[16:01:42.299]                           ns <- base::getNamespace("future")
[16:01:42.299]                           version <- ns[[".package"]][["version"]]
[16:01:42.299]                           if (is.null(version)) 
[16:01:42.299]                             version <- utils::packageVersion("future")
[16:01:42.299]                         }
[16:01:42.299]                         else {
[16:01:42.299]                           version <- NULL
[16:01:42.299]                         }
[16:01:42.299]                         if (!has_future || version < "1.8.0") {
[16:01:42.299]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:42.299]                             "", base::R.version$version.string), 
[16:01:42.299]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:42.299]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:42.299]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:42.299]                               "release", "version")], collapse = " "), 
[16:01:42.299]                             hostname = base::Sys.info()[["nodename"]])
[16:01:42.299]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:42.299]                             info)
[16:01:42.299]                           info <- base::paste(info, collapse = "; ")
[16:01:42.299]                           if (!has_future) {
[16:01:42.299]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:42.299]                               info)
[16:01:42.299]                           }
[16:01:42.299]                           else {
[16:01:42.299]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:42.299]                               info, version)
[16:01:42.299]                           }
[16:01:42.299]                           base::stop(msg)
[16:01:42.299]                         }
[16:01:42.299]                       })
[16:01:42.299]                     }
[16:01:42.299]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:42.299]                     base::options(mc.cores = 1L)
[16:01:42.299]                   }
[16:01:42.299]                   options(future.plan = NULL)
[16:01:42.299]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:42.299]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:42.299]                 }
[16:01:42.299]                 ...future.workdir <- getwd()
[16:01:42.299]             }
[16:01:42.299]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:42.299]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:42.299]         }
[16:01:42.299]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:42.299]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:01:42.299]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:42.299]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:42.299]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:42.299]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:42.299]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:42.299]             base::names(...future.oldOptions))
[16:01:42.299]     }
[16:01:42.299]     if (FALSE) {
[16:01:42.299]     }
[16:01:42.299]     else {
[16:01:42.299]         if (TRUE) {
[16:01:42.299]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:42.299]                 open = "w")
[16:01:42.299]         }
[16:01:42.299]         else {
[16:01:42.299]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:42.299]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:42.299]         }
[16:01:42.299]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:42.299]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:42.299]             base::sink(type = "output", split = FALSE)
[16:01:42.299]             base::close(...future.stdout)
[16:01:42.299]         }, add = TRUE)
[16:01:42.299]     }
[16:01:42.299]     ...future.frame <- base::sys.nframe()
[16:01:42.299]     ...future.conditions <- base::list()
[16:01:42.299]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:42.299]     if (FALSE) {
[16:01:42.299]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:42.299]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:42.299]     }
[16:01:42.299]     ...future.result <- base::tryCatch({
[16:01:42.299]         base::withCallingHandlers({
[16:01:42.299]             ...future.value <- base::withVisible(base::local({
[16:01:42.299]                 ...future.makeSendCondition <- base::local({
[16:01:42.299]                   sendCondition <- NULL
[16:01:42.299]                   function(frame = 1L) {
[16:01:42.299]                     if (is.function(sendCondition)) 
[16:01:42.299]                       return(sendCondition)
[16:01:42.299]                     ns <- getNamespace("parallel")
[16:01:42.299]                     if (exists("sendData", mode = "function", 
[16:01:42.299]                       envir = ns)) {
[16:01:42.299]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:42.299]                         envir = ns)
[16:01:42.299]                       envir <- sys.frame(frame)
[16:01:42.299]                       master <- NULL
[16:01:42.299]                       while (!identical(envir, .GlobalEnv) && 
[16:01:42.299]                         !identical(envir, emptyenv())) {
[16:01:42.299]                         if (exists("master", mode = "list", envir = envir, 
[16:01:42.299]                           inherits = FALSE)) {
[16:01:42.299]                           master <- get("master", mode = "list", 
[16:01:42.299]                             envir = envir, inherits = FALSE)
[16:01:42.299]                           if (inherits(master, c("SOCKnode", 
[16:01:42.299]                             "SOCK0node"))) {
[16:01:42.299]                             sendCondition <<- function(cond) {
[16:01:42.299]                               data <- list(type = "VALUE", value = cond, 
[16:01:42.299]                                 success = TRUE)
[16:01:42.299]                               parallel_sendData(master, data)
[16:01:42.299]                             }
[16:01:42.299]                             return(sendCondition)
[16:01:42.299]                           }
[16:01:42.299]                         }
[16:01:42.299]                         frame <- frame + 1L
[16:01:42.299]                         envir <- sys.frame(frame)
[16:01:42.299]                       }
[16:01:42.299]                     }
[16:01:42.299]                     sendCondition <<- function(cond) NULL
[16:01:42.299]                   }
[16:01:42.299]                 })
[16:01:42.299]                 withCallingHandlers({
[16:01:42.299]                   NA
[16:01:42.299]                 }, immediateCondition = function(cond) {
[16:01:42.299]                   sendCondition <- ...future.makeSendCondition()
[16:01:42.299]                   sendCondition(cond)
[16:01:42.299]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:42.299]                   {
[16:01:42.299]                     inherits <- base::inherits
[16:01:42.299]                     invokeRestart <- base::invokeRestart
[16:01:42.299]                     is.null <- base::is.null
[16:01:42.299]                     muffled <- FALSE
[16:01:42.299]                     if (inherits(cond, "message")) {
[16:01:42.299]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:42.299]                       if (muffled) 
[16:01:42.299]                         invokeRestart("muffleMessage")
[16:01:42.299]                     }
[16:01:42.299]                     else if (inherits(cond, "warning")) {
[16:01:42.299]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:42.299]                       if (muffled) 
[16:01:42.299]                         invokeRestart("muffleWarning")
[16:01:42.299]                     }
[16:01:42.299]                     else if (inherits(cond, "condition")) {
[16:01:42.299]                       if (!is.null(pattern)) {
[16:01:42.299]                         computeRestarts <- base::computeRestarts
[16:01:42.299]                         grepl <- base::grepl
[16:01:42.299]                         restarts <- computeRestarts(cond)
[16:01:42.299]                         for (restart in restarts) {
[16:01:42.299]                           name <- restart$name
[16:01:42.299]                           if (is.null(name)) 
[16:01:42.299]                             next
[16:01:42.299]                           if (!grepl(pattern, name)) 
[16:01:42.299]                             next
[16:01:42.299]                           invokeRestart(restart)
[16:01:42.299]                           muffled <- TRUE
[16:01:42.299]                           break
[16:01:42.299]                         }
[16:01:42.299]                       }
[16:01:42.299]                     }
[16:01:42.299]                     invisible(muffled)
[16:01:42.299]                   }
[16:01:42.299]                   muffleCondition(cond)
[16:01:42.299]                 })
[16:01:42.299]             }))
[16:01:42.299]             future::FutureResult(value = ...future.value$value, 
[16:01:42.299]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:42.299]                   ...future.rng), globalenv = if (FALSE) 
[16:01:42.299]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:42.299]                     ...future.globalenv.names))
[16:01:42.299]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:42.299]         }, condition = base::local({
[16:01:42.299]             c <- base::c
[16:01:42.299]             inherits <- base::inherits
[16:01:42.299]             invokeRestart <- base::invokeRestart
[16:01:42.299]             length <- base::length
[16:01:42.299]             list <- base::list
[16:01:42.299]             seq.int <- base::seq.int
[16:01:42.299]             signalCondition <- base::signalCondition
[16:01:42.299]             sys.calls <- base::sys.calls
[16:01:42.299]             `[[` <- base::`[[`
[16:01:42.299]             `+` <- base::`+`
[16:01:42.299]             `<<-` <- base::`<<-`
[16:01:42.299]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:42.299]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:42.299]                   3L)]
[16:01:42.299]             }
[16:01:42.299]             function(cond) {
[16:01:42.299]                 is_error <- inherits(cond, "error")
[16:01:42.299]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:42.299]                   NULL)
[16:01:42.299]                 if (is_error) {
[16:01:42.299]                   sessionInformation <- function() {
[16:01:42.299]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:42.299]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:42.299]                       search = base::search(), system = base::Sys.info())
[16:01:42.299]                   }
[16:01:42.299]                   ...future.conditions[[length(...future.conditions) + 
[16:01:42.299]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:42.299]                     cond$call), session = sessionInformation(), 
[16:01:42.299]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:42.299]                   signalCondition(cond)
[16:01:42.299]                 }
[16:01:42.299]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:42.299]                 "immediateCondition"))) {
[16:01:42.299]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:42.299]                   ...future.conditions[[length(...future.conditions) + 
[16:01:42.299]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:42.299]                   if (TRUE && !signal) {
[16:01:42.299]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:42.299]                     {
[16:01:42.299]                       inherits <- base::inherits
[16:01:42.299]                       invokeRestart <- base::invokeRestart
[16:01:42.299]                       is.null <- base::is.null
[16:01:42.299]                       muffled <- FALSE
[16:01:42.299]                       if (inherits(cond, "message")) {
[16:01:42.299]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:42.299]                         if (muffled) 
[16:01:42.299]                           invokeRestart("muffleMessage")
[16:01:42.299]                       }
[16:01:42.299]                       else if (inherits(cond, "warning")) {
[16:01:42.299]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:42.299]                         if (muffled) 
[16:01:42.299]                           invokeRestart("muffleWarning")
[16:01:42.299]                       }
[16:01:42.299]                       else if (inherits(cond, "condition")) {
[16:01:42.299]                         if (!is.null(pattern)) {
[16:01:42.299]                           computeRestarts <- base::computeRestarts
[16:01:42.299]                           grepl <- base::grepl
[16:01:42.299]                           restarts <- computeRestarts(cond)
[16:01:42.299]                           for (restart in restarts) {
[16:01:42.299]                             name <- restart$name
[16:01:42.299]                             if (is.null(name)) 
[16:01:42.299]                               next
[16:01:42.299]                             if (!grepl(pattern, name)) 
[16:01:42.299]                               next
[16:01:42.299]                             invokeRestart(restart)
[16:01:42.299]                             muffled <- TRUE
[16:01:42.299]                             break
[16:01:42.299]                           }
[16:01:42.299]                         }
[16:01:42.299]                       }
[16:01:42.299]                       invisible(muffled)
[16:01:42.299]                     }
[16:01:42.299]                     muffleCondition(cond, pattern = "^muffle")
[16:01:42.299]                   }
[16:01:42.299]                 }
[16:01:42.299]                 else {
[16:01:42.299]                   if (TRUE) {
[16:01:42.299]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:42.299]                     {
[16:01:42.299]                       inherits <- base::inherits
[16:01:42.299]                       invokeRestart <- base::invokeRestart
[16:01:42.299]                       is.null <- base::is.null
[16:01:42.299]                       muffled <- FALSE
[16:01:42.299]                       if (inherits(cond, "message")) {
[16:01:42.299]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:42.299]                         if (muffled) 
[16:01:42.299]                           invokeRestart("muffleMessage")
[16:01:42.299]                       }
[16:01:42.299]                       else if (inherits(cond, "warning")) {
[16:01:42.299]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:42.299]                         if (muffled) 
[16:01:42.299]                           invokeRestart("muffleWarning")
[16:01:42.299]                       }
[16:01:42.299]                       else if (inherits(cond, "condition")) {
[16:01:42.299]                         if (!is.null(pattern)) {
[16:01:42.299]                           computeRestarts <- base::computeRestarts
[16:01:42.299]                           grepl <- base::grepl
[16:01:42.299]                           restarts <- computeRestarts(cond)
[16:01:42.299]                           for (restart in restarts) {
[16:01:42.299]                             name <- restart$name
[16:01:42.299]                             if (is.null(name)) 
[16:01:42.299]                               next
[16:01:42.299]                             if (!grepl(pattern, name)) 
[16:01:42.299]                               next
[16:01:42.299]                             invokeRestart(restart)
[16:01:42.299]                             muffled <- TRUE
[16:01:42.299]                             break
[16:01:42.299]                           }
[16:01:42.299]                         }
[16:01:42.299]                       }
[16:01:42.299]                       invisible(muffled)
[16:01:42.299]                     }
[16:01:42.299]                     muffleCondition(cond, pattern = "^muffle")
[16:01:42.299]                   }
[16:01:42.299]                 }
[16:01:42.299]             }
[16:01:42.299]         }))
[16:01:42.299]     }, error = function(ex) {
[16:01:42.299]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:42.299]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:42.299]                 ...future.rng), started = ...future.startTime, 
[16:01:42.299]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:42.299]             version = "1.8"), class = "FutureResult")
[16:01:42.299]     }, finally = {
[16:01:42.299]         if (!identical(...future.workdir, getwd())) 
[16:01:42.299]             setwd(...future.workdir)
[16:01:42.299]         {
[16:01:42.299]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:42.299]                 ...future.oldOptions$nwarnings <- NULL
[16:01:42.299]             }
[16:01:42.299]             base::options(...future.oldOptions)
[16:01:42.299]             if (.Platform$OS.type == "windows") {
[16:01:42.299]                 old_names <- names(...future.oldEnvVars)
[16:01:42.299]                 envs <- base::Sys.getenv()
[16:01:42.299]                 names <- names(envs)
[16:01:42.299]                 common <- intersect(names, old_names)
[16:01:42.299]                 added <- setdiff(names, old_names)
[16:01:42.299]                 removed <- setdiff(old_names, names)
[16:01:42.299]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:42.299]                   envs[common]]
[16:01:42.299]                 NAMES <- toupper(changed)
[16:01:42.299]                 args <- list()
[16:01:42.299]                 for (kk in seq_along(NAMES)) {
[16:01:42.299]                   name <- changed[[kk]]
[16:01:42.299]                   NAME <- NAMES[[kk]]
[16:01:42.299]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:42.299]                     next
[16:01:42.299]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:42.299]                 }
[16:01:42.299]                 NAMES <- toupper(added)
[16:01:42.299]                 for (kk in seq_along(NAMES)) {
[16:01:42.299]                   name <- added[[kk]]
[16:01:42.299]                   NAME <- NAMES[[kk]]
[16:01:42.299]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:42.299]                     next
[16:01:42.299]                   args[[name]] <- ""
[16:01:42.299]                 }
[16:01:42.299]                 NAMES <- toupper(removed)
[16:01:42.299]                 for (kk in seq_along(NAMES)) {
[16:01:42.299]                   name <- removed[[kk]]
[16:01:42.299]                   NAME <- NAMES[[kk]]
[16:01:42.299]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:42.299]                     next
[16:01:42.299]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:42.299]                 }
[16:01:42.299]                 if (length(args) > 0) 
[16:01:42.299]                   base::do.call(base::Sys.setenv, args = args)
[16:01:42.299]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:42.299]             }
[16:01:42.299]             else {
[16:01:42.299]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:42.299]             }
[16:01:42.299]             {
[16:01:42.299]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:42.299]                   0L) {
[16:01:42.299]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:42.299]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:42.299]                   base::options(opts)
[16:01:42.299]                 }
[16:01:42.299]                 {
[16:01:42.299]                   {
[16:01:42.299]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:42.299]                     NULL
[16:01:42.299]                   }
[16:01:42.299]                   options(future.plan = NULL)
[16:01:42.299]                   if (is.na(NA_character_)) 
[16:01:42.299]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:42.299]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:42.299]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:42.299]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:42.299]                     envir = parent.frame()) 
[16:01:42.299]                   {
[16:01:42.299]                     if (is.function(workers)) 
[16:01:42.299]                       workers <- workers()
[16:01:42.299]                     workers <- structure(as.integer(workers), 
[16:01:42.299]                       class = class(workers))
[16:01:42.299]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:42.299]                       workers >= 1)
[16:01:42.299]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:42.299]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:42.299]                     }
[16:01:42.299]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:42.299]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:42.299]                       envir = envir)
[16:01:42.299]                     if (!future$lazy) 
[16:01:42.299]                       future <- run(future)
[16:01:42.299]                     invisible(future)
[16:01:42.299]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:42.299]                 }
[16:01:42.299]             }
[16:01:42.299]         }
[16:01:42.299]     })
[16:01:42.299]     if (TRUE) {
[16:01:42.299]         base::sink(type = "output", split = FALSE)
[16:01:42.299]         if (TRUE) {
[16:01:42.299]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:42.299]         }
[16:01:42.299]         else {
[16:01:42.299]             ...future.result["stdout"] <- base::list(NULL)
[16:01:42.299]         }
[16:01:42.299]         base::close(...future.stdout)
[16:01:42.299]         ...future.stdout <- NULL
[16:01:42.299]     }
[16:01:42.299]     ...future.result$conditions <- ...future.conditions
[16:01:42.299]     ...future.result$finished <- base::Sys.time()
[16:01:42.299]     ...future.result
[16:01:42.299] }
[16:01:42.355] MultisessionFuture started
[16:01:42.355] result() for ClusterFuture ...
[16:01:42.356] receiveMessageFromWorker() for ClusterFuture ...
[16:01:42.356] - Validating connection of MultisessionFuture
[16:01:42.402] - received message: FutureResult
[16:01:42.402] - Received FutureResult
[16:01:42.402] - Erased future from FutureRegistry
[16:01:42.402] result() for ClusterFuture ...
[16:01:42.402] - result already collected: FutureResult
[16:01:42.402] result() for ClusterFuture ... done
[16:01:42.403] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:42.403] result() for ClusterFuture ... done
[16:01:42.403] result() for ClusterFuture ...
[16:01:42.403] - result already collected: FutureResult
[16:01:42.403] result() for ClusterFuture ... done
[16:01:42.403] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:01:42.407] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[16:01:42.408] getGlobalsAndPackagesXApply() ...
[16:01:42.408]  - future.globals: TRUE
[16:01:42.408] getGlobalsAndPackages() ...
[16:01:42.408] Searching for globals...
[16:01:42.452] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[16:01:42.453] Searching for globals ... DONE
[16:01:42.453] Resolving globals: FALSE
[16:01:42.454] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[16:01:42.455] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[16:01:42.455] - globals: [1] ‘FUN’
[16:01:42.455] 
[16:01:42.455] getGlobalsAndPackages() ... DONE
[16:01:42.455]  - globals found/used: [n=1] ‘FUN’
[16:01:42.455]  - needed namespaces: [n=0] 
[16:01:42.455] Finding globals ... DONE
[16:01:42.455]  - use_args: TRUE
[16:01:42.456]  - Getting '...' globals ...
[16:01:42.456] resolve() on list ...
[16:01:42.456]  recursive: 0
[16:01:42.456]  length: 1
[16:01:42.456]  elements: ‘...’
[16:01:42.456]  length: 0 (resolved future 1)
[16:01:42.456] resolve() on list ... DONE
[16:01:42.456]    - '...' content: [n=0] 
[16:01:42.457] List of 1
[16:01:42.457]  $ ...: list()
[16:01:42.457]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:42.457]  - attr(*, "where")=List of 1
[16:01:42.457]   ..$ ...:<environment: 0x55fb658f2e40> 
[16:01:42.457]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:42.457]  - attr(*, "resolved")= logi TRUE
[16:01:42.457]  - attr(*, "total_size")= num NA
[16:01:42.459]  - Getting '...' globals ... DONE
[16:01:42.459] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:42.459] List of 2
[16:01:42.459]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:01:42.459]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:01:42.459]  $ ...          : list()
[16:01:42.459]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:42.459]  - attr(*, "where")=List of 2
[16:01:42.459]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:42.459]   ..$ ...          :<environment: 0x55fb658f2e40> 
[16:01:42.459]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:42.459]  - attr(*, "resolved")= logi FALSE
[16:01:42.459]  - attr(*, "total_size")= num 354224
[16:01:42.462] Packages to be attached in all futures: [n=0] 
[16:01:42.462] getGlobalsAndPackagesXApply() ... DONE
[16:01:42.465] future_lapply() ...
[16:01:42.499] Number of chunks: 2
[16:01:42.499] getGlobalsAndPackagesXApply() ...
[16:01:42.500]  - future.globals: <name-value list> with names ‘list()’
[16:01:42.500]  - use_args: TRUE
[16:01:42.500] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:01:42.500] List of 2
[16:01:42.500]  $ ...          : list()
[16:01:42.500]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:42.500]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:01:42.500]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:01:42.500]  - attr(*, "where")=List of 2
[16:01:42.500]   ..$ ...          :<environment: 0x55fb658f2e40> 
[16:01:42.500]   ..$ ...future.FUN:<environment: namespace:base> 
[16:01:42.500]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:42.500]  - attr(*, "resolved")= logi FALSE
[16:01:42.500]  - attr(*, "total_size")= num NA
[16:01:42.504] Packages to be attached in all futures: [n=0] 
[16:01:42.504] getGlobalsAndPackagesXApply() ... DONE
[16:01:42.504] Number of futures (= number of chunks): 2
[16:01:42.504] Launching 2 futures (chunks) ...
[16:01:42.504] Chunk #1 of 2 ...
[16:01:42.504]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:42.504]  - seeds: <none>
[16:01:42.504]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:42.505] getGlobalsAndPackages() ...
[16:01:42.505] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:42.505] Resolving globals: FALSE
[16:01:42.505] Tweak future expression to call with '...' arguments ...
[16:01:42.505] {
[16:01:42.505]     do.call(function(...) {
[16:01:42.505]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:42.505]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:42.505]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:42.505]             on.exit(options(oopts), add = TRUE)
[16:01:42.505]         }
[16:01:42.505]         {
[16:01:42.505]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:42.505]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:42.505]                 ...future.FUN(...future.X_jj, ...)
[16:01:42.505]             })
[16:01:42.505]         }
[16:01:42.505]     }, args = future.call.arguments)
[16:01:42.505] }
[16:01:42.505] Tweak future expression to call with '...' arguments ... DONE
[16:01:42.506] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:42.506] 
[16:01:42.506] getGlobalsAndPackages() ... DONE
[16:01:42.506] run() for ‘Future’ ...
[16:01:42.506] - state: ‘created’
[16:01:42.506] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:42.520] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:42.520] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:42.521]   - Field: ‘node’
[16:01:42.521]   - Field: ‘label’
[16:01:42.521]   - Field: ‘local’
[16:01:42.521]   - Field: ‘owner’
[16:01:42.521]   - Field: ‘envir’
[16:01:42.521]   - Field: ‘workers’
[16:01:42.521]   - Field: ‘packages’
[16:01:42.521]   - Field: ‘gc’
[16:01:42.521]   - Field: ‘conditions’
[16:01:42.522]   - Field: ‘persistent’
[16:01:42.522]   - Field: ‘expr’
[16:01:42.522]   - Field: ‘uuid’
[16:01:42.522]   - Field: ‘seed’
[16:01:42.522]   - Field: ‘version’
[16:01:42.522]   - Field: ‘result’
[16:01:42.522]   - Field: ‘asynchronous’
[16:01:42.522]   - Field: ‘calls’
[16:01:42.522]   - Field: ‘globals’
[16:01:42.522]   - Field: ‘stdout’
[16:01:42.522]   - Field: ‘earlySignal’
[16:01:42.523]   - Field: ‘lazy’
[16:01:42.523]   - Field: ‘state’
[16:01:42.523] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:42.523] - Launch lazy future ...
[16:01:42.523] Packages needed by the future expression (n = 0): <none>
[16:01:42.523] Packages needed by future strategies (n = 0): <none>
[16:01:42.524] {
[16:01:42.524]     {
[16:01:42.524]         {
[16:01:42.524]             ...future.startTime <- base::Sys.time()
[16:01:42.524]             {
[16:01:42.524]                 {
[16:01:42.524]                   {
[16:01:42.524]                     {
[16:01:42.524]                       base::local({
[16:01:42.524]                         has_future <- base::requireNamespace("future", 
[16:01:42.524]                           quietly = TRUE)
[16:01:42.524]                         if (has_future) {
[16:01:42.524]                           ns <- base::getNamespace("future")
[16:01:42.524]                           version <- ns[[".package"]][["version"]]
[16:01:42.524]                           if (is.null(version)) 
[16:01:42.524]                             version <- utils::packageVersion("future")
[16:01:42.524]                         }
[16:01:42.524]                         else {
[16:01:42.524]                           version <- NULL
[16:01:42.524]                         }
[16:01:42.524]                         if (!has_future || version < "1.8.0") {
[16:01:42.524]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:42.524]                             "", base::R.version$version.string), 
[16:01:42.524]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:42.524]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:42.524]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:42.524]                               "release", "version")], collapse = " "), 
[16:01:42.524]                             hostname = base::Sys.info()[["nodename"]])
[16:01:42.524]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:42.524]                             info)
[16:01:42.524]                           info <- base::paste(info, collapse = "; ")
[16:01:42.524]                           if (!has_future) {
[16:01:42.524]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:42.524]                               info)
[16:01:42.524]                           }
[16:01:42.524]                           else {
[16:01:42.524]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:42.524]                               info, version)
[16:01:42.524]                           }
[16:01:42.524]                           base::stop(msg)
[16:01:42.524]                         }
[16:01:42.524]                       })
[16:01:42.524]                     }
[16:01:42.524]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:42.524]                     base::options(mc.cores = 1L)
[16:01:42.524]                   }
[16:01:42.524]                   options(future.plan = NULL)
[16:01:42.524]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:42.524]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:42.524]                 }
[16:01:42.524]                 ...future.workdir <- getwd()
[16:01:42.524]             }
[16:01:42.524]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:42.524]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:42.524]         }
[16:01:42.524]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:42.524]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:42.524]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:42.524]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:42.524]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:42.524]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:42.524]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:42.524]             base::names(...future.oldOptions))
[16:01:42.524]     }
[16:01:42.524]     if (FALSE) {
[16:01:42.524]     }
[16:01:42.524]     else {
[16:01:42.524]         if (TRUE) {
[16:01:42.524]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:42.524]                 open = "w")
[16:01:42.524]         }
[16:01:42.524]         else {
[16:01:42.524]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:42.524]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:42.524]         }
[16:01:42.524]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:42.524]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:42.524]             base::sink(type = "output", split = FALSE)
[16:01:42.524]             base::close(...future.stdout)
[16:01:42.524]         }, add = TRUE)
[16:01:42.524]     }
[16:01:42.524]     ...future.frame <- base::sys.nframe()
[16:01:42.524]     ...future.conditions <- base::list()
[16:01:42.524]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:42.524]     if (FALSE) {
[16:01:42.524]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:42.524]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:42.524]     }
[16:01:42.524]     ...future.result <- base::tryCatch({
[16:01:42.524]         base::withCallingHandlers({
[16:01:42.524]             ...future.value <- base::withVisible(base::local({
[16:01:42.524]                 ...future.makeSendCondition <- base::local({
[16:01:42.524]                   sendCondition <- NULL
[16:01:42.524]                   function(frame = 1L) {
[16:01:42.524]                     if (is.function(sendCondition)) 
[16:01:42.524]                       return(sendCondition)
[16:01:42.524]                     ns <- getNamespace("parallel")
[16:01:42.524]                     if (exists("sendData", mode = "function", 
[16:01:42.524]                       envir = ns)) {
[16:01:42.524]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:42.524]                         envir = ns)
[16:01:42.524]                       envir <- sys.frame(frame)
[16:01:42.524]                       master <- NULL
[16:01:42.524]                       while (!identical(envir, .GlobalEnv) && 
[16:01:42.524]                         !identical(envir, emptyenv())) {
[16:01:42.524]                         if (exists("master", mode = "list", envir = envir, 
[16:01:42.524]                           inherits = FALSE)) {
[16:01:42.524]                           master <- get("master", mode = "list", 
[16:01:42.524]                             envir = envir, inherits = FALSE)
[16:01:42.524]                           if (inherits(master, c("SOCKnode", 
[16:01:42.524]                             "SOCK0node"))) {
[16:01:42.524]                             sendCondition <<- function(cond) {
[16:01:42.524]                               data <- list(type = "VALUE", value = cond, 
[16:01:42.524]                                 success = TRUE)
[16:01:42.524]                               parallel_sendData(master, data)
[16:01:42.524]                             }
[16:01:42.524]                             return(sendCondition)
[16:01:42.524]                           }
[16:01:42.524]                         }
[16:01:42.524]                         frame <- frame + 1L
[16:01:42.524]                         envir <- sys.frame(frame)
[16:01:42.524]                       }
[16:01:42.524]                     }
[16:01:42.524]                     sendCondition <<- function(cond) NULL
[16:01:42.524]                   }
[16:01:42.524]                 })
[16:01:42.524]                 withCallingHandlers({
[16:01:42.524]                   {
[16:01:42.524]                     do.call(function(...) {
[16:01:42.524]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:42.524]                       if (!identical(...future.globals.maxSize.org, 
[16:01:42.524]                         ...future.globals.maxSize)) {
[16:01:42.524]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:42.524]                         on.exit(options(oopts), add = TRUE)
[16:01:42.524]                       }
[16:01:42.524]                       {
[16:01:42.524]                         lapply(seq_along(...future.elements_ii), 
[16:01:42.524]                           FUN = function(jj) {
[16:01:42.524]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:42.524]                             ...future.FUN(...future.X_jj, ...)
[16:01:42.524]                           })
[16:01:42.524]                       }
[16:01:42.524]                     }, args = future.call.arguments)
[16:01:42.524]                   }
[16:01:42.524]                 }, immediateCondition = function(cond) {
[16:01:42.524]                   sendCondition <- ...future.makeSendCondition()
[16:01:42.524]                   sendCondition(cond)
[16:01:42.524]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:42.524]                   {
[16:01:42.524]                     inherits <- base::inherits
[16:01:42.524]                     invokeRestart <- base::invokeRestart
[16:01:42.524]                     is.null <- base::is.null
[16:01:42.524]                     muffled <- FALSE
[16:01:42.524]                     if (inherits(cond, "message")) {
[16:01:42.524]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:42.524]                       if (muffled) 
[16:01:42.524]                         invokeRestart("muffleMessage")
[16:01:42.524]                     }
[16:01:42.524]                     else if (inherits(cond, "warning")) {
[16:01:42.524]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:42.524]                       if (muffled) 
[16:01:42.524]                         invokeRestart("muffleWarning")
[16:01:42.524]                     }
[16:01:42.524]                     else if (inherits(cond, "condition")) {
[16:01:42.524]                       if (!is.null(pattern)) {
[16:01:42.524]                         computeRestarts <- base::computeRestarts
[16:01:42.524]                         grepl <- base::grepl
[16:01:42.524]                         restarts <- computeRestarts(cond)
[16:01:42.524]                         for (restart in restarts) {
[16:01:42.524]                           name <- restart$name
[16:01:42.524]                           if (is.null(name)) 
[16:01:42.524]                             next
[16:01:42.524]                           if (!grepl(pattern, name)) 
[16:01:42.524]                             next
[16:01:42.524]                           invokeRestart(restart)
[16:01:42.524]                           muffled <- TRUE
[16:01:42.524]                           break
[16:01:42.524]                         }
[16:01:42.524]                       }
[16:01:42.524]                     }
[16:01:42.524]                     invisible(muffled)
[16:01:42.524]                   }
[16:01:42.524]                   muffleCondition(cond)
[16:01:42.524]                 })
[16:01:42.524]             }))
[16:01:42.524]             future::FutureResult(value = ...future.value$value, 
[16:01:42.524]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:42.524]                   ...future.rng), globalenv = if (FALSE) 
[16:01:42.524]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:42.524]                     ...future.globalenv.names))
[16:01:42.524]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:42.524]         }, condition = base::local({
[16:01:42.524]             c <- base::c
[16:01:42.524]             inherits <- base::inherits
[16:01:42.524]             invokeRestart <- base::invokeRestart
[16:01:42.524]             length <- base::length
[16:01:42.524]             list <- base::list
[16:01:42.524]             seq.int <- base::seq.int
[16:01:42.524]             signalCondition <- base::signalCondition
[16:01:42.524]             sys.calls <- base::sys.calls
[16:01:42.524]             `[[` <- base::`[[`
[16:01:42.524]             `+` <- base::`+`
[16:01:42.524]             `<<-` <- base::`<<-`
[16:01:42.524]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:42.524]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:42.524]                   3L)]
[16:01:42.524]             }
[16:01:42.524]             function(cond) {
[16:01:42.524]                 is_error <- inherits(cond, "error")
[16:01:42.524]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:42.524]                   NULL)
[16:01:42.524]                 if (is_error) {
[16:01:42.524]                   sessionInformation <- function() {
[16:01:42.524]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:42.524]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:42.524]                       search = base::search(), system = base::Sys.info())
[16:01:42.524]                   }
[16:01:42.524]                   ...future.conditions[[length(...future.conditions) + 
[16:01:42.524]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:42.524]                     cond$call), session = sessionInformation(), 
[16:01:42.524]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:42.524]                   signalCondition(cond)
[16:01:42.524]                 }
[16:01:42.524]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:42.524]                 "immediateCondition"))) {
[16:01:42.524]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:42.524]                   ...future.conditions[[length(...future.conditions) + 
[16:01:42.524]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:42.524]                   if (TRUE && !signal) {
[16:01:42.524]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:42.524]                     {
[16:01:42.524]                       inherits <- base::inherits
[16:01:42.524]                       invokeRestart <- base::invokeRestart
[16:01:42.524]                       is.null <- base::is.null
[16:01:42.524]                       muffled <- FALSE
[16:01:42.524]                       if (inherits(cond, "message")) {
[16:01:42.524]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:42.524]                         if (muffled) 
[16:01:42.524]                           invokeRestart("muffleMessage")
[16:01:42.524]                       }
[16:01:42.524]                       else if (inherits(cond, "warning")) {
[16:01:42.524]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:42.524]                         if (muffled) 
[16:01:42.524]                           invokeRestart("muffleWarning")
[16:01:42.524]                       }
[16:01:42.524]                       else if (inherits(cond, "condition")) {
[16:01:42.524]                         if (!is.null(pattern)) {
[16:01:42.524]                           computeRestarts <- base::computeRestarts
[16:01:42.524]                           grepl <- base::grepl
[16:01:42.524]                           restarts <- computeRestarts(cond)
[16:01:42.524]                           for (restart in restarts) {
[16:01:42.524]                             name <- restart$name
[16:01:42.524]                             if (is.null(name)) 
[16:01:42.524]                               next
[16:01:42.524]                             if (!grepl(pattern, name)) 
[16:01:42.524]                               next
[16:01:42.524]                             invokeRestart(restart)
[16:01:42.524]                             muffled <- TRUE
[16:01:42.524]                             break
[16:01:42.524]                           }
[16:01:42.524]                         }
[16:01:42.524]                       }
[16:01:42.524]                       invisible(muffled)
[16:01:42.524]                     }
[16:01:42.524]                     muffleCondition(cond, pattern = "^muffle")
[16:01:42.524]                   }
[16:01:42.524]                 }
[16:01:42.524]                 else {
[16:01:42.524]                   if (TRUE) {
[16:01:42.524]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:42.524]                     {
[16:01:42.524]                       inherits <- base::inherits
[16:01:42.524]                       invokeRestart <- base::invokeRestart
[16:01:42.524]                       is.null <- base::is.null
[16:01:42.524]                       muffled <- FALSE
[16:01:42.524]                       if (inherits(cond, "message")) {
[16:01:42.524]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:42.524]                         if (muffled) 
[16:01:42.524]                           invokeRestart("muffleMessage")
[16:01:42.524]                       }
[16:01:42.524]                       else if (inherits(cond, "warning")) {
[16:01:42.524]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:42.524]                         if (muffled) 
[16:01:42.524]                           invokeRestart("muffleWarning")
[16:01:42.524]                       }
[16:01:42.524]                       else if (inherits(cond, "condition")) {
[16:01:42.524]                         if (!is.null(pattern)) {
[16:01:42.524]                           computeRestarts <- base::computeRestarts
[16:01:42.524]                           grepl <- base::grepl
[16:01:42.524]                           restarts <- computeRestarts(cond)
[16:01:42.524]                           for (restart in restarts) {
[16:01:42.524]                             name <- restart$name
[16:01:42.524]                             if (is.null(name)) 
[16:01:42.524]                               next
[16:01:42.524]                             if (!grepl(pattern, name)) 
[16:01:42.524]                               next
[16:01:42.524]                             invokeRestart(restart)
[16:01:42.524]                             muffled <- TRUE
[16:01:42.524]                             break
[16:01:42.524]                           }
[16:01:42.524]                         }
[16:01:42.524]                       }
[16:01:42.524]                       invisible(muffled)
[16:01:42.524]                     }
[16:01:42.524]                     muffleCondition(cond, pattern = "^muffle")
[16:01:42.524]                   }
[16:01:42.524]                 }
[16:01:42.524]             }
[16:01:42.524]         }))
[16:01:42.524]     }, error = function(ex) {
[16:01:42.524]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:42.524]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:42.524]                 ...future.rng), started = ...future.startTime, 
[16:01:42.524]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:42.524]             version = "1.8"), class = "FutureResult")
[16:01:42.524]     }, finally = {
[16:01:42.524]         if (!identical(...future.workdir, getwd())) 
[16:01:42.524]             setwd(...future.workdir)
[16:01:42.524]         {
[16:01:42.524]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:42.524]                 ...future.oldOptions$nwarnings <- NULL
[16:01:42.524]             }
[16:01:42.524]             base::options(...future.oldOptions)
[16:01:42.524]             if (.Platform$OS.type == "windows") {
[16:01:42.524]                 old_names <- names(...future.oldEnvVars)
[16:01:42.524]                 envs <- base::Sys.getenv()
[16:01:42.524]                 names <- names(envs)
[16:01:42.524]                 common <- intersect(names, old_names)
[16:01:42.524]                 added <- setdiff(names, old_names)
[16:01:42.524]                 removed <- setdiff(old_names, names)
[16:01:42.524]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:42.524]                   envs[common]]
[16:01:42.524]                 NAMES <- toupper(changed)
[16:01:42.524]                 args <- list()
[16:01:42.524]                 for (kk in seq_along(NAMES)) {
[16:01:42.524]                   name <- changed[[kk]]
[16:01:42.524]                   NAME <- NAMES[[kk]]
[16:01:42.524]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:42.524]                     next
[16:01:42.524]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:42.524]                 }
[16:01:42.524]                 NAMES <- toupper(added)
[16:01:42.524]                 for (kk in seq_along(NAMES)) {
[16:01:42.524]                   name <- added[[kk]]
[16:01:42.524]                   NAME <- NAMES[[kk]]
[16:01:42.524]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:42.524]                     next
[16:01:42.524]                   args[[name]] <- ""
[16:01:42.524]                 }
[16:01:42.524]                 NAMES <- toupper(removed)
[16:01:42.524]                 for (kk in seq_along(NAMES)) {
[16:01:42.524]                   name <- removed[[kk]]
[16:01:42.524]                   NAME <- NAMES[[kk]]
[16:01:42.524]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:42.524]                     next
[16:01:42.524]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:42.524]                 }
[16:01:42.524]                 if (length(args) > 0) 
[16:01:42.524]                   base::do.call(base::Sys.setenv, args = args)
[16:01:42.524]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:42.524]             }
[16:01:42.524]             else {
[16:01:42.524]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:42.524]             }
[16:01:42.524]             {
[16:01:42.524]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:42.524]                   0L) {
[16:01:42.524]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:42.524]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:42.524]                   base::options(opts)
[16:01:42.524]                 }
[16:01:42.524]                 {
[16:01:42.524]                   {
[16:01:42.524]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:42.524]                     NULL
[16:01:42.524]                   }
[16:01:42.524]                   options(future.plan = NULL)
[16:01:42.524]                   if (is.na(NA_character_)) 
[16:01:42.524]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:42.524]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:42.524]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:42.524]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:42.524]                     envir = parent.frame()) 
[16:01:42.524]                   {
[16:01:42.524]                     if (is.function(workers)) 
[16:01:42.524]                       workers <- workers()
[16:01:42.524]                     workers <- structure(as.integer(workers), 
[16:01:42.524]                       class = class(workers))
[16:01:42.524]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:42.524]                       workers >= 1)
[16:01:42.524]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:42.524]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:42.524]                     }
[16:01:42.524]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:42.524]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:42.524]                       envir = envir)
[16:01:42.524]                     if (!future$lazy) 
[16:01:42.524]                       future <- run(future)
[16:01:42.524]                     invisible(future)
[16:01:42.524]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:42.524]                 }
[16:01:42.524]             }
[16:01:42.524]         }
[16:01:42.524]     })
[16:01:42.524]     if (TRUE) {
[16:01:42.524]         base::sink(type = "output", split = FALSE)
[16:01:42.524]         if (TRUE) {
[16:01:42.524]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:42.524]         }
[16:01:42.524]         else {
[16:01:42.524]             ...future.result["stdout"] <- base::list(NULL)
[16:01:42.524]         }
[16:01:42.524]         base::close(...future.stdout)
[16:01:42.524]         ...future.stdout <- NULL
[16:01:42.524]     }
[16:01:42.524]     ...future.result$conditions <- ...future.conditions
[16:01:42.524]     ...future.result$finished <- base::Sys.time()
[16:01:42.524]     ...future.result
[16:01:42.524] }
[16:01:42.527] Exporting 5 global objects (346.05 KiB) to cluster node #1 ...
[16:01:42.527] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:01:42.528] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:01:42.528] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ...
[16:01:42.572] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ... DONE
[16:01:42.572] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[16:01:42.572] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[16:01:42.572] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:01:42.573] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:01:42.573] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:01:42.573] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:01:42.573] Exporting 5 global objects (346.05 KiB) to cluster node #1 ... DONE
[16:01:42.574] MultisessionFuture started
[16:01:42.574] - Launch lazy future ... done
[16:01:42.574] run() for ‘MultisessionFuture’ ... done
[16:01:42.575] Created future:
[16:01:42.575] MultisessionFuture:
[16:01:42.575] Label: ‘future_apply-1’
[16:01:42.575] Expression:
[16:01:42.575] {
[16:01:42.575]     do.call(function(...) {
[16:01:42.575]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:42.575]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:42.575]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:42.575]             on.exit(options(oopts), add = TRUE)
[16:01:42.575]         }
[16:01:42.575]         {
[16:01:42.575]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:42.575]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:42.575]                 ...future.FUN(...future.X_jj, ...)
[16:01:42.575]             })
[16:01:42.575]         }
[16:01:42.575]     }, args = future.call.arguments)
[16:01:42.575] }
[16:01:42.575] Lazy evaluation: FALSE
[16:01:42.575] Asynchronous evaluation: TRUE
[16:01:42.575] Local evaluation: TRUE
[16:01:42.575] Environment: R_GlobalEnv
[16:01:42.575] Capture standard output: TRUE
[16:01:42.575] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:42.575] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:42.575] Packages: <none>
[16:01:42.575] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:42.575] Resolved: FALSE
[16:01:42.575] Value: <not collected>
[16:01:42.575] Conditions captured: <none>
[16:01:42.575] Early signaling: FALSE
[16:01:42.575] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:42.575] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:42.587] Chunk #1 of 2 ... DONE
[16:01:42.587] Chunk #2 of 2 ...
[16:01:42.587]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:42.587]  - seeds: <none>
[16:01:42.587]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:42.588] getGlobalsAndPackages() ...
[16:01:42.588] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:42.588] Resolving globals: FALSE
[16:01:42.588] Tweak future expression to call with '...' arguments ...
[16:01:42.588] {
[16:01:42.588]     do.call(function(...) {
[16:01:42.588]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:42.588]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:42.588]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:42.588]             on.exit(options(oopts), add = TRUE)
[16:01:42.588]         }
[16:01:42.588]         {
[16:01:42.588]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:42.588]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:42.588]                 ...future.FUN(...future.X_jj, ...)
[16:01:42.588]             })
[16:01:42.588]         }
[16:01:42.588]     }, args = future.call.arguments)
[16:01:42.588] }
[16:01:42.588] Tweak future expression to call with '...' arguments ... DONE
[16:01:42.589] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:42.589] 
[16:01:42.589] getGlobalsAndPackages() ... DONE
[16:01:42.589] run() for ‘Future’ ...
[16:01:42.589] - state: ‘created’
[16:01:42.590] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:42.604] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:42.604] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:42.604]   - Field: ‘node’
[16:01:42.604]   - Field: ‘label’
[16:01:42.604]   - Field: ‘local’
[16:01:42.604]   - Field: ‘owner’
[16:01:42.604]   - Field: ‘envir’
[16:01:42.605]   - Field: ‘workers’
[16:01:42.607]   - Field: ‘packages’
[16:01:42.607]   - Field: ‘gc’
[16:01:42.607]   - Field: ‘conditions’
[16:01:42.607]   - Field: ‘persistent’
[16:01:42.607]   - Field: ‘expr’
[16:01:42.607]   - Field: ‘uuid’
[16:01:42.607]   - Field: ‘seed’
[16:01:42.607]   - Field: ‘version’
[16:01:42.607]   - Field: ‘result’
[16:01:42.608]   - Field: ‘asynchronous’
[16:01:42.608]   - Field: ‘calls’
[16:01:42.608]   - Field: ‘globals’
[16:01:42.608]   - Field: ‘stdout’
[16:01:42.608]   - Field: ‘earlySignal’
[16:01:42.608]   - Field: ‘lazy’
[16:01:42.608]   - Field: ‘state’
[16:01:42.608] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:42.608] - Launch lazy future ...
[16:01:42.609] Packages needed by the future expression (n = 0): <none>
[16:01:42.609] Packages needed by future strategies (n = 0): <none>
[16:01:42.609] {
[16:01:42.609]     {
[16:01:42.609]         {
[16:01:42.609]             ...future.startTime <- base::Sys.time()
[16:01:42.609]             {
[16:01:42.609]                 {
[16:01:42.609]                   {
[16:01:42.609]                     {
[16:01:42.609]                       base::local({
[16:01:42.609]                         has_future <- base::requireNamespace("future", 
[16:01:42.609]                           quietly = TRUE)
[16:01:42.609]                         if (has_future) {
[16:01:42.609]                           ns <- base::getNamespace("future")
[16:01:42.609]                           version <- ns[[".package"]][["version"]]
[16:01:42.609]                           if (is.null(version)) 
[16:01:42.609]                             version <- utils::packageVersion("future")
[16:01:42.609]                         }
[16:01:42.609]                         else {
[16:01:42.609]                           version <- NULL
[16:01:42.609]                         }
[16:01:42.609]                         if (!has_future || version < "1.8.0") {
[16:01:42.609]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:42.609]                             "", base::R.version$version.string), 
[16:01:42.609]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:42.609]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:42.609]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:42.609]                               "release", "version")], collapse = " "), 
[16:01:42.609]                             hostname = base::Sys.info()[["nodename"]])
[16:01:42.609]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:42.609]                             info)
[16:01:42.609]                           info <- base::paste(info, collapse = "; ")
[16:01:42.609]                           if (!has_future) {
[16:01:42.609]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:42.609]                               info)
[16:01:42.609]                           }
[16:01:42.609]                           else {
[16:01:42.609]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:42.609]                               info, version)
[16:01:42.609]                           }
[16:01:42.609]                           base::stop(msg)
[16:01:42.609]                         }
[16:01:42.609]                       })
[16:01:42.609]                     }
[16:01:42.609]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:42.609]                     base::options(mc.cores = 1L)
[16:01:42.609]                   }
[16:01:42.609]                   options(future.plan = NULL)
[16:01:42.609]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:42.609]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:42.609]                 }
[16:01:42.609]                 ...future.workdir <- getwd()
[16:01:42.609]             }
[16:01:42.609]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:42.609]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:42.609]         }
[16:01:42.609]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:42.609]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:42.609]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:42.609]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:42.609]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:42.609]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:42.609]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:42.609]             base::names(...future.oldOptions))
[16:01:42.609]     }
[16:01:42.609]     if (FALSE) {
[16:01:42.609]     }
[16:01:42.609]     else {
[16:01:42.609]         if (TRUE) {
[16:01:42.609]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:42.609]                 open = "w")
[16:01:42.609]         }
[16:01:42.609]         else {
[16:01:42.609]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:42.609]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:42.609]         }
[16:01:42.609]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:42.609]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:42.609]             base::sink(type = "output", split = FALSE)
[16:01:42.609]             base::close(...future.stdout)
[16:01:42.609]         }, add = TRUE)
[16:01:42.609]     }
[16:01:42.609]     ...future.frame <- base::sys.nframe()
[16:01:42.609]     ...future.conditions <- base::list()
[16:01:42.609]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:42.609]     if (FALSE) {
[16:01:42.609]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:42.609]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:42.609]     }
[16:01:42.609]     ...future.result <- base::tryCatch({
[16:01:42.609]         base::withCallingHandlers({
[16:01:42.609]             ...future.value <- base::withVisible(base::local({
[16:01:42.609]                 ...future.makeSendCondition <- base::local({
[16:01:42.609]                   sendCondition <- NULL
[16:01:42.609]                   function(frame = 1L) {
[16:01:42.609]                     if (is.function(sendCondition)) 
[16:01:42.609]                       return(sendCondition)
[16:01:42.609]                     ns <- getNamespace("parallel")
[16:01:42.609]                     if (exists("sendData", mode = "function", 
[16:01:42.609]                       envir = ns)) {
[16:01:42.609]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:42.609]                         envir = ns)
[16:01:42.609]                       envir <- sys.frame(frame)
[16:01:42.609]                       master <- NULL
[16:01:42.609]                       while (!identical(envir, .GlobalEnv) && 
[16:01:42.609]                         !identical(envir, emptyenv())) {
[16:01:42.609]                         if (exists("master", mode = "list", envir = envir, 
[16:01:42.609]                           inherits = FALSE)) {
[16:01:42.609]                           master <- get("master", mode = "list", 
[16:01:42.609]                             envir = envir, inherits = FALSE)
[16:01:42.609]                           if (inherits(master, c("SOCKnode", 
[16:01:42.609]                             "SOCK0node"))) {
[16:01:42.609]                             sendCondition <<- function(cond) {
[16:01:42.609]                               data <- list(type = "VALUE", value = cond, 
[16:01:42.609]                                 success = TRUE)
[16:01:42.609]                               parallel_sendData(master, data)
[16:01:42.609]                             }
[16:01:42.609]                             return(sendCondition)
[16:01:42.609]                           }
[16:01:42.609]                         }
[16:01:42.609]                         frame <- frame + 1L
[16:01:42.609]                         envir <- sys.frame(frame)
[16:01:42.609]                       }
[16:01:42.609]                     }
[16:01:42.609]                     sendCondition <<- function(cond) NULL
[16:01:42.609]                   }
[16:01:42.609]                 })
[16:01:42.609]                 withCallingHandlers({
[16:01:42.609]                   {
[16:01:42.609]                     do.call(function(...) {
[16:01:42.609]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:42.609]                       if (!identical(...future.globals.maxSize.org, 
[16:01:42.609]                         ...future.globals.maxSize)) {
[16:01:42.609]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:42.609]                         on.exit(options(oopts), add = TRUE)
[16:01:42.609]                       }
[16:01:42.609]                       {
[16:01:42.609]                         lapply(seq_along(...future.elements_ii), 
[16:01:42.609]                           FUN = function(jj) {
[16:01:42.609]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:42.609]                             ...future.FUN(...future.X_jj, ...)
[16:01:42.609]                           })
[16:01:42.609]                       }
[16:01:42.609]                     }, args = future.call.arguments)
[16:01:42.609]                   }
[16:01:42.609]                 }, immediateCondition = function(cond) {
[16:01:42.609]                   sendCondition <- ...future.makeSendCondition()
[16:01:42.609]                   sendCondition(cond)
[16:01:42.609]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:42.609]                   {
[16:01:42.609]                     inherits <- base::inherits
[16:01:42.609]                     invokeRestart <- base::invokeRestart
[16:01:42.609]                     is.null <- base::is.null
[16:01:42.609]                     muffled <- FALSE
[16:01:42.609]                     if (inherits(cond, "message")) {
[16:01:42.609]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:42.609]                       if (muffled) 
[16:01:42.609]                         invokeRestart("muffleMessage")
[16:01:42.609]                     }
[16:01:42.609]                     else if (inherits(cond, "warning")) {
[16:01:42.609]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:42.609]                       if (muffled) 
[16:01:42.609]                         invokeRestart("muffleWarning")
[16:01:42.609]                     }
[16:01:42.609]                     else if (inherits(cond, "condition")) {
[16:01:42.609]                       if (!is.null(pattern)) {
[16:01:42.609]                         computeRestarts <- base::computeRestarts
[16:01:42.609]                         grepl <- base::grepl
[16:01:42.609]                         restarts <- computeRestarts(cond)
[16:01:42.609]                         for (restart in restarts) {
[16:01:42.609]                           name <- restart$name
[16:01:42.609]                           if (is.null(name)) 
[16:01:42.609]                             next
[16:01:42.609]                           if (!grepl(pattern, name)) 
[16:01:42.609]                             next
[16:01:42.609]                           invokeRestart(restart)
[16:01:42.609]                           muffled <- TRUE
[16:01:42.609]                           break
[16:01:42.609]                         }
[16:01:42.609]                       }
[16:01:42.609]                     }
[16:01:42.609]                     invisible(muffled)
[16:01:42.609]                   }
[16:01:42.609]                   muffleCondition(cond)
[16:01:42.609]                 })
[16:01:42.609]             }))
[16:01:42.609]             future::FutureResult(value = ...future.value$value, 
[16:01:42.609]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:42.609]                   ...future.rng), globalenv = if (FALSE) 
[16:01:42.609]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:42.609]                     ...future.globalenv.names))
[16:01:42.609]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:42.609]         }, condition = base::local({
[16:01:42.609]             c <- base::c
[16:01:42.609]             inherits <- base::inherits
[16:01:42.609]             invokeRestart <- base::invokeRestart
[16:01:42.609]             length <- base::length
[16:01:42.609]             list <- base::list
[16:01:42.609]             seq.int <- base::seq.int
[16:01:42.609]             signalCondition <- base::signalCondition
[16:01:42.609]             sys.calls <- base::sys.calls
[16:01:42.609]             `[[` <- base::`[[`
[16:01:42.609]             `+` <- base::`+`
[16:01:42.609]             `<<-` <- base::`<<-`
[16:01:42.609]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:42.609]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:42.609]                   3L)]
[16:01:42.609]             }
[16:01:42.609]             function(cond) {
[16:01:42.609]                 is_error <- inherits(cond, "error")
[16:01:42.609]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:42.609]                   NULL)
[16:01:42.609]                 if (is_error) {
[16:01:42.609]                   sessionInformation <- function() {
[16:01:42.609]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:42.609]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:42.609]                       search = base::search(), system = base::Sys.info())
[16:01:42.609]                   }
[16:01:42.609]                   ...future.conditions[[length(...future.conditions) + 
[16:01:42.609]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:42.609]                     cond$call), session = sessionInformation(), 
[16:01:42.609]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:42.609]                   signalCondition(cond)
[16:01:42.609]                 }
[16:01:42.609]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:42.609]                 "immediateCondition"))) {
[16:01:42.609]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:42.609]                   ...future.conditions[[length(...future.conditions) + 
[16:01:42.609]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:42.609]                   if (TRUE && !signal) {
[16:01:42.609]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:42.609]                     {
[16:01:42.609]                       inherits <- base::inherits
[16:01:42.609]                       invokeRestart <- base::invokeRestart
[16:01:42.609]                       is.null <- base::is.null
[16:01:42.609]                       muffled <- FALSE
[16:01:42.609]                       if (inherits(cond, "message")) {
[16:01:42.609]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:42.609]                         if (muffled) 
[16:01:42.609]                           invokeRestart("muffleMessage")
[16:01:42.609]                       }
[16:01:42.609]                       else if (inherits(cond, "warning")) {
[16:01:42.609]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:42.609]                         if (muffled) 
[16:01:42.609]                           invokeRestart("muffleWarning")
[16:01:42.609]                       }
[16:01:42.609]                       else if (inherits(cond, "condition")) {
[16:01:42.609]                         if (!is.null(pattern)) {
[16:01:42.609]                           computeRestarts <- base::computeRestarts
[16:01:42.609]                           grepl <- base::grepl
[16:01:42.609]                           restarts <- computeRestarts(cond)
[16:01:42.609]                           for (restart in restarts) {
[16:01:42.609]                             name <- restart$name
[16:01:42.609]                             if (is.null(name)) 
[16:01:42.609]                               next
[16:01:42.609]                             if (!grepl(pattern, name)) 
[16:01:42.609]                               next
[16:01:42.609]                             invokeRestart(restart)
[16:01:42.609]                             muffled <- TRUE
[16:01:42.609]                             break
[16:01:42.609]                           }
[16:01:42.609]                         }
[16:01:42.609]                       }
[16:01:42.609]                       invisible(muffled)
[16:01:42.609]                     }
[16:01:42.609]                     muffleCondition(cond, pattern = "^muffle")
[16:01:42.609]                   }
[16:01:42.609]                 }
[16:01:42.609]                 else {
[16:01:42.609]                   if (TRUE) {
[16:01:42.609]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:42.609]                     {
[16:01:42.609]                       inherits <- base::inherits
[16:01:42.609]                       invokeRestart <- base::invokeRestart
[16:01:42.609]                       is.null <- base::is.null
[16:01:42.609]                       muffled <- FALSE
[16:01:42.609]                       if (inherits(cond, "message")) {
[16:01:42.609]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:42.609]                         if (muffled) 
[16:01:42.609]                           invokeRestart("muffleMessage")
[16:01:42.609]                       }
[16:01:42.609]                       else if (inherits(cond, "warning")) {
[16:01:42.609]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:42.609]                         if (muffled) 
[16:01:42.609]                           invokeRestart("muffleWarning")
[16:01:42.609]                       }
[16:01:42.609]                       else if (inherits(cond, "condition")) {
[16:01:42.609]                         if (!is.null(pattern)) {
[16:01:42.609]                           computeRestarts <- base::computeRestarts
[16:01:42.609]                           grepl <- base::grepl
[16:01:42.609]                           restarts <- computeRestarts(cond)
[16:01:42.609]                           for (restart in restarts) {
[16:01:42.609]                             name <- restart$name
[16:01:42.609]                             if (is.null(name)) 
[16:01:42.609]                               next
[16:01:42.609]                             if (!grepl(pattern, name)) 
[16:01:42.609]                               next
[16:01:42.609]                             invokeRestart(restart)
[16:01:42.609]                             muffled <- TRUE
[16:01:42.609]                             break
[16:01:42.609]                           }
[16:01:42.609]                         }
[16:01:42.609]                       }
[16:01:42.609]                       invisible(muffled)
[16:01:42.609]                     }
[16:01:42.609]                     muffleCondition(cond, pattern = "^muffle")
[16:01:42.609]                   }
[16:01:42.609]                 }
[16:01:42.609]             }
[16:01:42.609]         }))
[16:01:42.609]     }, error = function(ex) {
[16:01:42.609]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:42.609]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:42.609]                 ...future.rng), started = ...future.startTime, 
[16:01:42.609]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:42.609]             version = "1.8"), class = "FutureResult")
[16:01:42.609]     }, finally = {
[16:01:42.609]         if (!identical(...future.workdir, getwd())) 
[16:01:42.609]             setwd(...future.workdir)
[16:01:42.609]         {
[16:01:42.609]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:42.609]                 ...future.oldOptions$nwarnings <- NULL
[16:01:42.609]             }
[16:01:42.609]             base::options(...future.oldOptions)
[16:01:42.609]             if (.Platform$OS.type == "windows") {
[16:01:42.609]                 old_names <- names(...future.oldEnvVars)
[16:01:42.609]                 envs <- base::Sys.getenv()
[16:01:42.609]                 names <- names(envs)
[16:01:42.609]                 common <- intersect(names, old_names)
[16:01:42.609]                 added <- setdiff(names, old_names)
[16:01:42.609]                 removed <- setdiff(old_names, names)
[16:01:42.609]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:42.609]                   envs[common]]
[16:01:42.609]                 NAMES <- toupper(changed)
[16:01:42.609]                 args <- list()
[16:01:42.609]                 for (kk in seq_along(NAMES)) {
[16:01:42.609]                   name <- changed[[kk]]
[16:01:42.609]                   NAME <- NAMES[[kk]]
[16:01:42.609]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:42.609]                     next
[16:01:42.609]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:42.609]                 }
[16:01:42.609]                 NAMES <- toupper(added)
[16:01:42.609]                 for (kk in seq_along(NAMES)) {
[16:01:42.609]                   name <- added[[kk]]
[16:01:42.609]                   NAME <- NAMES[[kk]]
[16:01:42.609]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:42.609]                     next
[16:01:42.609]                   args[[name]] <- ""
[16:01:42.609]                 }
[16:01:42.609]                 NAMES <- toupper(removed)
[16:01:42.609]                 for (kk in seq_along(NAMES)) {
[16:01:42.609]                   name <- removed[[kk]]
[16:01:42.609]                   NAME <- NAMES[[kk]]
[16:01:42.609]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:42.609]                     next
[16:01:42.609]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:42.609]                 }
[16:01:42.609]                 if (length(args) > 0) 
[16:01:42.609]                   base::do.call(base::Sys.setenv, args = args)
[16:01:42.609]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:42.609]             }
[16:01:42.609]             else {
[16:01:42.609]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:42.609]             }
[16:01:42.609]             {
[16:01:42.609]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:42.609]                   0L) {
[16:01:42.609]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:42.609]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:42.609]                   base::options(opts)
[16:01:42.609]                 }
[16:01:42.609]                 {
[16:01:42.609]                   {
[16:01:42.609]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:42.609]                     NULL
[16:01:42.609]                   }
[16:01:42.609]                   options(future.plan = NULL)
[16:01:42.609]                   if (is.na(NA_character_)) 
[16:01:42.609]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:42.609]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:42.609]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:42.609]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:42.609]                     envir = parent.frame()) 
[16:01:42.609]                   {
[16:01:42.609]                     if (is.function(workers)) 
[16:01:42.609]                       workers <- workers()
[16:01:42.609]                     workers <- structure(as.integer(workers), 
[16:01:42.609]                       class = class(workers))
[16:01:42.609]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:42.609]                       workers >= 1)
[16:01:42.609]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:42.609]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:42.609]                     }
[16:01:42.609]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:42.609]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:42.609]                       envir = envir)
[16:01:42.609]                     if (!future$lazy) 
[16:01:42.609]                       future <- run(future)
[16:01:42.609]                     invisible(future)
[16:01:42.609]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:42.609]                 }
[16:01:42.609]             }
[16:01:42.609]         }
[16:01:42.609]     })
[16:01:42.609]     if (TRUE) {
[16:01:42.609]         base::sink(type = "output", split = FALSE)
[16:01:42.609]         if (TRUE) {
[16:01:42.609]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:42.609]         }
[16:01:42.609]         else {
[16:01:42.609]             ...future.result["stdout"] <- base::list(NULL)
[16:01:42.609]         }
[16:01:42.609]         base::close(...future.stdout)
[16:01:42.609]         ...future.stdout <- NULL
[16:01:42.609]     }
[16:01:42.609]     ...future.result$conditions <- ...future.conditions
[16:01:42.609]     ...future.result$finished <- base::Sys.time()
[16:01:42.609]     ...future.result
[16:01:42.609] }
[16:01:42.665] Exporting 5 global objects (346.05 KiB) to cluster node #2 ...
[16:01:42.665] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:01:42.665] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:01:42.666] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ...
[16:01:42.707] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ... DONE
[16:01:42.708] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[16:01:42.708] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[16:01:42.708] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:01:42.709] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:01:42.709] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[16:01:42.709] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[16:01:42.709] Exporting 5 global objects (346.05 KiB) to cluster node #2 ... DONE
[16:01:42.710] MultisessionFuture started
[16:01:42.710] - Launch lazy future ... done
[16:01:42.710] run() for ‘MultisessionFuture’ ... done
[16:01:42.710] Created future:
[16:01:42.710] MultisessionFuture:
[16:01:42.710] Label: ‘future_apply-2’
[16:01:42.710] Expression:
[16:01:42.710] {
[16:01:42.710]     do.call(function(...) {
[16:01:42.710]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:42.710]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:42.710]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:42.710]             on.exit(options(oopts), add = TRUE)
[16:01:42.710]         }
[16:01:42.710]         {
[16:01:42.710]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:42.710]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:42.710]                 ...future.FUN(...future.X_jj, ...)
[16:01:42.710]             })
[16:01:42.710]         }
[16:01:42.710]     }, args = future.call.arguments)
[16:01:42.710] }
[16:01:42.710] Lazy evaluation: FALSE
[16:01:42.710] Asynchronous evaluation: TRUE
[16:01:42.710] Local evaluation: TRUE
[16:01:42.710] Environment: R_GlobalEnv
[16:01:42.710] Capture standard output: TRUE
[16:01:42.710] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:42.710] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:42.710] Packages: <none>
[16:01:42.710] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:42.710] Resolved: FALSE
[16:01:42.710] Value: <not collected>
[16:01:42.710] Conditions captured: <none>
[16:01:42.710] Early signaling: FALSE
[16:01:42.710] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:42.710] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:42.722] Chunk #2 of 2 ... DONE
[16:01:42.722] Launching 2 futures (chunks) ... DONE
[16:01:42.722] Resolving 2 futures (chunks) ...
[16:01:42.722] resolve() on list ...
[16:01:42.723]  recursive: 0
[16:01:42.723]  length: 2
[16:01:42.723] 
[16:01:42.723] receiveMessageFromWorker() for ClusterFuture ...
[16:01:42.723] - Validating connection of MultisessionFuture
[16:01:42.724] - received message: FutureResult
[16:01:42.724] - Received FutureResult
[16:01:42.724] - Erased future from FutureRegistry
[16:01:42.724] result() for ClusterFuture ...
[16:01:42.724] - result already collected: FutureResult
[16:01:42.724] result() for ClusterFuture ... done
[16:01:42.724] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:42.724] Future #1
[16:01:42.724] result() for ClusterFuture ...
[16:01:42.725] - result already collected: FutureResult
[16:01:42.725] result() for ClusterFuture ... done
[16:01:42.725] result() for ClusterFuture ...
[16:01:42.725] - result already collected: FutureResult
[16:01:42.725] result() for ClusterFuture ... done
[16:01:42.725] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:01:42.725] - nx: 2
[16:01:42.725] - relay: TRUE
[16:01:42.725] - stdout: TRUE
[16:01:42.725] - signal: TRUE
[16:01:42.725] - resignal: FALSE
[16:01:42.725] - force: TRUE
[16:01:42.726] - relayed: [n=2] FALSE, FALSE
[16:01:42.726] - queued futures: [n=2] FALSE, FALSE
[16:01:42.726]  - until=1
[16:01:42.726]  - relaying element #1
[16:01:42.726] result() for ClusterFuture ...
[16:01:42.726] - result already collected: FutureResult
[16:01:42.726] result() for ClusterFuture ... done
[16:01:42.726] result() for ClusterFuture ...
[16:01:42.726] - result already collected: FutureResult
[16:01:42.726] result() for ClusterFuture ... done
[16:01:42.726] result() for ClusterFuture ...
[16:01:42.726] - result already collected: FutureResult
[16:01:42.727] result() for ClusterFuture ... done
[16:01:42.727] result() for ClusterFuture ...
[16:01:42.727] - result already collected: FutureResult
[16:01:42.727] result() for ClusterFuture ... done
[16:01:42.727] - relayed: [n=2] TRUE, FALSE
[16:01:42.727] - queued futures: [n=2] TRUE, FALSE
[16:01:42.727] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:01:42.727]  length: 1 (resolved future 1)
[16:01:42.798] receiveMessageFromWorker() for ClusterFuture ...
[16:01:42.798] - Validating connection of MultisessionFuture
[16:01:42.798] - received message: FutureResult
[16:01:42.798] - Received FutureResult
[16:01:42.798] - Erased future from FutureRegistry
[16:01:42.799] result() for ClusterFuture ...
[16:01:42.799] - result already collected: FutureResult
[16:01:42.799] result() for ClusterFuture ... done
[16:01:42.799] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:42.799] Future #2
[16:01:42.799] result() for ClusterFuture ...
[16:01:42.799] - result already collected: FutureResult
[16:01:42.799] result() for ClusterFuture ... done
[16:01:42.799] result() for ClusterFuture ...
[16:01:42.799] - result already collected: FutureResult
[16:01:42.800] result() for ClusterFuture ... done
[16:01:42.800] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:01:42.800] - nx: 2
[16:01:42.800] - relay: TRUE
[16:01:42.800] - stdout: TRUE
[16:01:42.800] - signal: TRUE
[16:01:42.800] - resignal: FALSE
[16:01:42.800] - force: TRUE
[16:01:42.800] - relayed: [n=2] TRUE, FALSE
[16:01:42.800] - queued futures: [n=2] TRUE, FALSE
[16:01:42.800]  - until=2
[16:01:42.801]  - relaying element #2
[16:01:42.801] result() for ClusterFuture ...
[16:01:42.801] - result already collected: FutureResult
[16:01:42.801] result() for ClusterFuture ... done
[16:01:42.801] result() for ClusterFuture ...
[16:01:42.801] - result already collected: FutureResult
[16:01:42.801] result() for ClusterFuture ... done
[16:01:42.801] result() for ClusterFuture ...
[16:01:42.801] - result already collected: FutureResult
[16:01:42.801] result() for ClusterFuture ... done
[16:01:42.801] result() for ClusterFuture ...
[16:01:42.802] - result already collected: FutureResult
[16:01:42.802] result() for ClusterFuture ... done
[16:01:42.802] - relayed: [n=2] TRUE, TRUE
[16:01:42.802] - queued futures: [n=2] TRUE, TRUE
[16:01:42.802] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:01:42.802]  length: 0 (resolved future 2)
[16:01:42.802] Relaying remaining futures
[16:01:42.802] signalConditionsASAP(NULL, pos=0) ...
[16:01:42.802] - nx: 2
[16:01:42.802] - relay: TRUE
[16:01:42.802] - stdout: TRUE
[16:01:42.802] - signal: TRUE
[16:01:42.803] - resignal: FALSE
[16:01:42.803] - force: TRUE
[16:01:42.803] - relayed: [n=2] TRUE, TRUE
[16:01:42.803] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:42.803] - relayed: [n=2] TRUE, TRUE
[16:01:42.803] - queued futures: [n=2] TRUE, TRUE
[16:01:42.803] signalConditionsASAP(NULL, pos=0) ... done
[16:01:42.803] resolve() on list ... DONE
[16:01:42.803] result() for ClusterFuture ...
[16:01:42.803] - result already collected: FutureResult
[16:01:42.804] result() for ClusterFuture ... done
[16:01:42.804] result() for ClusterFuture ...
[16:01:42.804] - result already collected: FutureResult
[16:01:42.804] result() for ClusterFuture ... done
[16:01:42.804] result() for ClusterFuture ...
[16:01:42.804] - result already collected: FutureResult
[16:01:42.804] result() for ClusterFuture ... done
[16:01:42.804] result() for ClusterFuture ...
[16:01:42.804] - result already collected: FutureResult
[16:01:42.804] result() for ClusterFuture ... done
[16:01:42.804]  - Number of value chunks collected: 2
[16:01:42.805] Resolving 2 futures (chunks) ... DONE
[16:01:42.805] Reducing values from 2 chunks ...
[16:01:42.805]  - Number of values collected after concatenation: 2
[16:01:42.805]  - Number of values expected: 2
[16:01:42.805] Reducing values from 2 chunks ... DONE
[16:01:42.805] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[16:01:42.805] getGlobalsAndPackagesXApply() ...
[16:01:42.806]  - future.globals: TRUE
[16:01:42.806] getGlobalsAndPackages() ...
[16:01:42.806] Searching for globals...
[16:01:42.838] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[16:01:42.838] Searching for globals ... DONE
[16:01:42.838] Resolving globals: FALSE
[16:01:42.840] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[16:01:42.840] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[16:01:42.840] - globals: [1] ‘FUN’
[16:01:42.841] 
[16:01:42.841] getGlobalsAndPackages() ... DONE
[16:01:42.841]  - globals found/used: [n=1] ‘FUN’
[16:01:42.841]  - needed namespaces: [n=0] 
[16:01:42.841] Finding globals ... DONE
[16:01:42.841]  - use_args: TRUE
[16:01:42.841]  - Getting '...' globals ...
[16:01:42.841] resolve() on list ...
[16:01:42.842]  recursive: 0
[16:01:42.842]  length: 1
[16:01:42.842]  elements: ‘...’
[16:01:42.842]  length: 0 (resolved future 1)
[16:01:42.842] resolve() on list ... DONE
[16:01:42.842]    - '...' content: [n=0] 
[16:01:42.842] List of 1
[16:01:42.842]  $ ...: list()
[16:01:42.842]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:42.842]  - attr(*, "where")=List of 1
[16:01:42.842]   ..$ ...:<environment: 0x55fb63ccba68> 
[16:01:42.842]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:42.842]  - attr(*, "resolved")= logi TRUE
[16:01:42.842]  - attr(*, "total_size")= num NA
[16:01:42.845]  - Getting '...' globals ... DONE
[16:01:42.845] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:42.845] List of 2
[16:01:42.845]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:01:42.845]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:01:42.845]  $ ...          : list()
[16:01:42.845]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:42.845]  - attr(*, "where")=List of 2
[16:01:42.845]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:42.845]   ..$ ...          :<environment: 0x55fb63ccba68> 
[16:01:42.845]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:42.845]  - attr(*, "resolved")= logi FALSE
[16:01:42.845]  - attr(*, "total_size")= num 354224
[16:01:42.848] Packages to be attached in all futures: [n=0] 
[16:01:42.848] getGlobalsAndPackagesXApply() ... DONE
[16:01:42.853] future_lapply() ...
[16:01:42.887] Number of chunks: 2
[16:01:42.887] getGlobalsAndPackagesXApply() ...
[16:01:42.887]  - future.globals: <name-value list> with names ‘list()’
[16:01:42.888]  - use_args: TRUE
[16:01:42.888] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:01:42.888] List of 2
[16:01:42.888]  $ ...          : list()
[16:01:42.888]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:42.888]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:01:42.888]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:01:42.888]  - attr(*, "where")=List of 2
[16:01:42.888]   ..$ ...          :<environment: 0x55fb63ccba68> 
[16:01:42.888]   ..$ ...future.FUN:<environment: namespace:base> 
[16:01:42.888]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:42.888]  - attr(*, "resolved")= logi FALSE
[16:01:42.888]  - attr(*, "total_size")= num NA
[16:01:42.892] Packages to be attached in all futures: [n=0] 
[16:01:42.892] getGlobalsAndPackagesXApply() ... DONE
[16:01:42.892] Number of futures (= number of chunks): 2
[16:01:42.892] Launching 2 futures (chunks) ...
[16:01:42.892] Chunk #1 of 2 ...
[16:01:42.892]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:42.892]  - seeds: <none>
[16:01:42.892]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:42.893] getGlobalsAndPackages() ...
[16:01:42.893] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:42.893] Resolving globals: FALSE
[16:01:42.893] Tweak future expression to call with '...' arguments ...
[16:01:42.893] {
[16:01:42.893]     do.call(function(...) {
[16:01:42.893]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:42.893]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:42.893]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:42.893]             on.exit(options(oopts), add = TRUE)
[16:01:42.893]         }
[16:01:42.893]         {
[16:01:42.893]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:42.893]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:42.893]                 ...future.FUN(...future.X_jj, ...)
[16:01:42.893]             })
[16:01:42.893]         }
[16:01:42.893]     }, args = future.call.arguments)
[16:01:42.893] }
[16:01:42.893] Tweak future expression to call with '...' arguments ... DONE
[16:01:42.894] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:42.894] 
[16:01:42.894] getGlobalsAndPackages() ... DONE
[16:01:42.894] run() for ‘Future’ ...
[16:01:42.894] - state: ‘created’
[16:01:42.894] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:42.908] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:42.909] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:42.909]   - Field: ‘node’
[16:01:42.909]   - Field: ‘label’
[16:01:42.909]   - Field: ‘local’
[16:01:42.909]   - Field: ‘owner’
[16:01:42.909]   - Field: ‘envir’
[16:01:42.909]   - Field: ‘workers’
[16:01:42.909]   - Field: ‘packages’
[16:01:42.909]   - Field: ‘gc’
[16:01:42.909]   - Field: ‘conditions’
[16:01:42.910]   - Field: ‘persistent’
[16:01:42.910]   - Field: ‘expr’
[16:01:42.910]   - Field: ‘uuid’
[16:01:42.910]   - Field: ‘seed’
[16:01:42.910]   - Field: ‘version’
[16:01:42.910]   - Field: ‘result’
[16:01:42.910]   - Field: ‘asynchronous’
[16:01:42.910]   - Field: ‘calls’
[16:01:42.910]   - Field: ‘globals’
[16:01:42.910]   - Field: ‘stdout’
[16:01:42.910]   - Field: ‘earlySignal’
[16:01:42.911]   - Field: ‘lazy’
[16:01:42.911]   - Field: ‘state’
[16:01:42.911] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:42.911] - Launch lazy future ...
[16:01:42.911] Packages needed by the future expression (n = 0): <none>
[16:01:42.911] Packages needed by future strategies (n = 0): <none>
[16:01:42.912] {
[16:01:42.912]     {
[16:01:42.912]         {
[16:01:42.912]             ...future.startTime <- base::Sys.time()
[16:01:42.912]             {
[16:01:42.912]                 {
[16:01:42.912]                   {
[16:01:42.912]                     {
[16:01:42.912]                       base::local({
[16:01:42.912]                         has_future <- base::requireNamespace("future", 
[16:01:42.912]                           quietly = TRUE)
[16:01:42.912]                         if (has_future) {
[16:01:42.912]                           ns <- base::getNamespace("future")
[16:01:42.912]                           version <- ns[[".package"]][["version"]]
[16:01:42.912]                           if (is.null(version)) 
[16:01:42.912]                             version <- utils::packageVersion("future")
[16:01:42.912]                         }
[16:01:42.912]                         else {
[16:01:42.912]                           version <- NULL
[16:01:42.912]                         }
[16:01:42.912]                         if (!has_future || version < "1.8.0") {
[16:01:42.912]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:42.912]                             "", base::R.version$version.string), 
[16:01:42.912]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:42.912]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:42.912]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:42.912]                               "release", "version")], collapse = " "), 
[16:01:42.912]                             hostname = base::Sys.info()[["nodename"]])
[16:01:42.912]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:42.912]                             info)
[16:01:42.912]                           info <- base::paste(info, collapse = "; ")
[16:01:42.912]                           if (!has_future) {
[16:01:42.912]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:42.912]                               info)
[16:01:42.912]                           }
[16:01:42.912]                           else {
[16:01:42.912]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:42.912]                               info, version)
[16:01:42.912]                           }
[16:01:42.912]                           base::stop(msg)
[16:01:42.912]                         }
[16:01:42.912]                       })
[16:01:42.912]                     }
[16:01:42.912]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:42.912]                     base::options(mc.cores = 1L)
[16:01:42.912]                   }
[16:01:42.912]                   options(future.plan = NULL)
[16:01:42.912]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:42.912]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:42.912]                 }
[16:01:42.912]                 ...future.workdir <- getwd()
[16:01:42.912]             }
[16:01:42.912]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:42.912]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:42.912]         }
[16:01:42.912]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:42.912]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:42.912]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:42.912]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:42.912]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:42.912]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:42.912]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:42.912]             base::names(...future.oldOptions))
[16:01:42.912]     }
[16:01:42.912]     if (FALSE) {
[16:01:42.912]     }
[16:01:42.912]     else {
[16:01:42.912]         if (TRUE) {
[16:01:42.912]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:42.912]                 open = "w")
[16:01:42.912]         }
[16:01:42.912]         else {
[16:01:42.912]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:42.912]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:42.912]         }
[16:01:42.912]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:42.912]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:42.912]             base::sink(type = "output", split = FALSE)
[16:01:42.912]             base::close(...future.stdout)
[16:01:42.912]         }, add = TRUE)
[16:01:42.912]     }
[16:01:42.912]     ...future.frame <- base::sys.nframe()
[16:01:42.912]     ...future.conditions <- base::list()
[16:01:42.912]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:42.912]     if (FALSE) {
[16:01:42.912]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:42.912]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:42.912]     }
[16:01:42.912]     ...future.result <- base::tryCatch({
[16:01:42.912]         base::withCallingHandlers({
[16:01:42.912]             ...future.value <- base::withVisible(base::local({
[16:01:42.912]                 ...future.makeSendCondition <- base::local({
[16:01:42.912]                   sendCondition <- NULL
[16:01:42.912]                   function(frame = 1L) {
[16:01:42.912]                     if (is.function(sendCondition)) 
[16:01:42.912]                       return(sendCondition)
[16:01:42.912]                     ns <- getNamespace("parallel")
[16:01:42.912]                     if (exists("sendData", mode = "function", 
[16:01:42.912]                       envir = ns)) {
[16:01:42.912]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:42.912]                         envir = ns)
[16:01:42.912]                       envir <- sys.frame(frame)
[16:01:42.912]                       master <- NULL
[16:01:42.912]                       while (!identical(envir, .GlobalEnv) && 
[16:01:42.912]                         !identical(envir, emptyenv())) {
[16:01:42.912]                         if (exists("master", mode = "list", envir = envir, 
[16:01:42.912]                           inherits = FALSE)) {
[16:01:42.912]                           master <- get("master", mode = "list", 
[16:01:42.912]                             envir = envir, inherits = FALSE)
[16:01:42.912]                           if (inherits(master, c("SOCKnode", 
[16:01:42.912]                             "SOCK0node"))) {
[16:01:42.912]                             sendCondition <<- function(cond) {
[16:01:42.912]                               data <- list(type = "VALUE", value = cond, 
[16:01:42.912]                                 success = TRUE)
[16:01:42.912]                               parallel_sendData(master, data)
[16:01:42.912]                             }
[16:01:42.912]                             return(sendCondition)
[16:01:42.912]                           }
[16:01:42.912]                         }
[16:01:42.912]                         frame <- frame + 1L
[16:01:42.912]                         envir <- sys.frame(frame)
[16:01:42.912]                       }
[16:01:42.912]                     }
[16:01:42.912]                     sendCondition <<- function(cond) NULL
[16:01:42.912]                   }
[16:01:42.912]                 })
[16:01:42.912]                 withCallingHandlers({
[16:01:42.912]                   {
[16:01:42.912]                     do.call(function(...) {
[16:01:42.912]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:42.912]                       if (!identical(...future.globals.maxSize.org, 
[16:01:42.912]                         ...future.globals.maxSize)) {
[16:01:42.912]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:42.912]                         on.exit(options(oopts), add = TRUE)
[16:01:42.912]                       }
[16:01:42.912]                       {
[16:01:42.912]                         lapply(seq_along(...future.elements_ii), 
[16:01:42.912]                           FUN = function(jj) {
[16:01:42.912]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:42.912]                             ...future.FUN(...future.X_jj, ...)
[16:01:42.912]                           })
[16:01:42.912]                       }
[16:01:42.912]                     }, args = future.call.arguments)
[16:01:42.912]                   }
[16:01:42.912]                 }, immediateCondition = function(cond) {
[16:01:42.912]                   sendCondition <- ...future.makeSendCondition()
[16:01:42.912]                   sendCondition(cond)
[16:01:42.912]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:42.912]                   {
[16:01:42.912]                     inherits <- base::inherits
[16:01:42.912]                     invokeRestart <- base::invokeRestart
[16:01:42.912]                     is.null <- base::is.null
[16:01:42.912]                     muffled <- FALSE
[16:01:42.912]                     if (inherits(cond, "message")) {
[16:01:42.912]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:42.912]                       if (muffled) 
[16:01:42.912]                         invokeRestart("muffleMessage")
[16:01:42.912]                     }
[16:01:42.912]                     else if (inherits(cond, "warning")) {
[16:01:42.912]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:42.912]                       if (muffled) 
[16:01:42.912]                         invokeRestart("muffleWarning")
[16:01:42.912]                     }
[16:01:42.912]                     else if (inherits(cond, "condition")) {
[16:01:42.912]                       if (!is.null(pattern)) {
[16:01:42.912]                         computeRestarts <- base::computeRestarts
[16:01:42.912]                         grepl <- base::grepl
[16:01:42.912]                         restarts <- computeRestarts(cond)
[16:01:42.912]                         for (restart in restarts) {
[16:01:42.912]                           name <- restart$name
[16:01:42.912]                           if (is.null(name)) 
[16:01:42.912]                             next
[16:01:42.912]                           if (!grepl(pattern, name)) 
[16:01:42.912]                             next
[16:01:42.912]                           invokeRestart(restart)
[16:01:42.912]                           muffled <- TRUE
[16:01:42.912]                           break
[16:01:42.912]                         }
[16:01:42.912]                       }
[16:01:42.912]                     }
[16:01:42.912]                     invisible(muffled)
[16:01:42.912]                   }
[16:01:42.912]                   muffleCondition(cond)
[16:01:42.912]                 })
[16:01:42.912]             }))
[16:01:42.912]             future::FutureResult(value = ...future.value$value, 
[16:01:42.912]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:42.912]                   ...future.rng), globalenv = if (FALSE) 
[16:01:42.912]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:42.912]                     ...future.globalenv.names))
[16:01:42.912]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:42.912]         }, condition = base::local({
[16:01:42.912]             c <- base::c
[16:01:42.912]             inherits <- base::inherits
[16:01:42.912]             invokeRestart <- base::invokeRestart
[16:01:42.912]             length <- base::length
[16:01:42.912]             list <- base::list
[16:01:42.912]             seq.int <- base::seq.int
[16:01:42.912]             signalCondition <- base::signalCondition
[16:01:42.912]             sys.calls <- base::sys.calls
[16:01:42.912]             `[[` <- base::`[[`
[16:01:42.912]             `+` <- base::`+`
[16:01:42.912]             `<<-` <- base::`<<-`
[16:01:42.912]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:42.912]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:42.912]                   3L)]
[16:01:42.912]             }
[16:01:42.912]             function(cond) {
[16:01:42.912]                 is_error <- inherits(cond, "error")
[16:01:42.912]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:42.912]                   NULL)
[16:01:42.912]                 if (is_error) {
[16:01:42.912]                   sessionInformation <- function() {
[16:01:42.912]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:42.912]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:42.912]                       search = base::search(), system = base::Sys.info())
[16:01:42.912]                   }
[16:01:42.912]                   ...future.conditions[[length(...future.conditions) + 
[16:01:42.912]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:42.912]                     cond$call), session = sessionInformation(), 
[16:01:42.912]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:42.912]                   signalCondition(cond)
[16:01:42.912]                 }
[16:01:42.912]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:42.912]                 "immediateCondition"))) {
[16:01:42.912]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:42.912]                   ...future.conditions[[length(...future.conditions) + 
[16:01:42.912]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:42.912]                   if (TRUE && !signal) {
[16:01:42.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:42.912]                     {
[16:01:42.912]                       inherits <- base::inherits
[16:01:42.912]                       invokeRestart <- base::invokeRestart
[16:01:42.912]                       is.null <- base::is.null
[16:01:42.912]                       muffled <- FALSE
[16:01:42.912]                       if (inherits(cond, "message")) {
[16:01:42.912]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:42.912]                         if (muffled) 
[16:01:42.912]                           invokeRestart("muffleMessage")
[16:01:42.912]                       }
[16:01:42.912]                       else if (inherits(cond, "warning")) {
[16:01:42.912]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:42.912]                         if (muffled) 
[16:01:42.912]                           invokeRestart("muffleWarning")
[16:01:42.912]                       }
[16:01:42.912]                       else if (inherits(cond, "condition")) {
[16:01:42.912]                         if (!is.null(pattern)) {
[16:01:42.912]                           computeRestarts <- base::computeRestarts
[16:01:42.912]                           grepl <- base::grepl
[16:01:42.912]                           restarts <- computeRestarts(cond)
[16:01:42.912]                           for (restart in restarts) {
[16:01:42.912]                             name <- restart$name
[16:01:42.912]                             if (is.null(name)) 
[16:01:42.912]                               next
[16:01:42.912]                             if (!grepl(pattern, name)) 
[16:01:42.912]                               next
[16:01:42.912]                             invokeRestart(restart)
[16:01:42.912]                             muffled <- TRUE
[16:01:42.912]                             break
[16:01:42.912]                           }
[16:01:42.912]                         }
[16:01:42.912]                       }
[16:01:42.912]                       invisible(muffled)
[16:01:42.912]                     }
[16:01:42.912]                     muffleCondition(cond, pattern = "^muffle")
[16:01:42.912]                   }
[16:01:42.912]                 }
[16:01:42.912]                 else {
[16:01:42.912]                   if (TRUE) {
[16:01:42.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:42.912]                     {
[16:01:42.912]                       inherits <- base::inherits
[16:01:42.912]                       invokeRestart <- base::invokeRestart
[16:01:42.912]                       is.null <- base::is.null
[16:01:42.912]                       muffled <- FALSE
[16:01:42.912]                       if (inherits(cond, "message")) {
[16:01:42.912]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:42.912]                         if (muffled) 
[16:01:42.912]                           invokeRestart("muffleMessage")
[16:01:42.912]                       }
[16:01:42.912]                       else if (inherits(cond, "warning")) {
[16:01:42.912]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:42.912]                         if (muffled) 
[16:01:42.912]                           invokeRestart("muffleWarning")
[16:01:42.912]                       }
[16:01:42.912]                       else if (inherits(cond, "condition")) {
[16:01:42.912]                         if (!is.null(pattern)) {
[16:01:42.912]                           computeRestarts <- base::computeRestarts
[16:01:42.912]                           grepl <- base::grepl
[16:01:42.912]                           restarts <- computeRestarts(cond)
[16:01:42.912]                           for (restart in restarts) {
[16:01:42.912]                             name <- restart$name
[16:01:42.912]                             if (is.null(name)) 
[16:01:42.912]                               next
[16:01:42.912]                             if (!grepl(pattern, name)) 
[16:01:42.912]                               next
[16:01:42.912]                             invokeRestart(restart)
[16:01:42.912]                             muffled <- TRUE
[16:01:42.912]                             break
[16:01:42.912]                           }
[16:01:42.912]                         }
[16:01:42.912]                       }
[16:01:42.912]                       invisible(muffled)
[16:01:42.912]                     }
[16:01:42.912]                     muffleCondition(cond, pattern = "^muffle")
[16:01:42.912]                   }
[16:01:42.912]                 }
[16:01:42.912]             }
[16:01:42.912]         }))
[16:01:42.912]     }, error = function(ex) {
[16:01:42.912]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:42.912]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:42.912]                 ...future.rng), started = ...future.startTime, 
[16:01:42.912]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:42.912]             version = "1.8"), class = "FutureResult")
[16:01:42.912]     }, finally = {
[16:01:42.912]         if (!identical(...future.workdir, getwd())) 
[16:01:42.912]             setwd(...future.workdir)
[16:01:42.912]         {
[16:01:42.912]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:42.912]                 ...future.oldOptions$nwarnings <- NULL
[16:01:42.912]             }
[16:01:42.912]             base::options(...future.oldOptions)
[16:01:42.912]             if (.Platform$OS.type == "windows") {
[16:01:42.912]                 old_names <- names(...future.oldEnvVars)
[16:01:42.912]                 envs <- base::Sys.getenv()
[16:01:42.912]                 names <- names(envs)
[16:01:42.912]                 common <- intersect(names, old_names)
[16:01:42.912]                 added <- setdiff(names, old_names)
[16:01:42.912]                 removed <- setdiff(old_names, names)
[16:01:42.912]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:42.912]                   envs[common]]
[16:01:42.912]                 NAMES <- toupper(changed)
[16:01:42.912]                 args <- list()
[16:01:42.912]                 for (kk in seq_along(NAMES)) {
[16:01:42.912]                   name <- changed[[kk]]
[16:01:42.912]                   NAME <- NAMES[[kk]]
[16:01:42.912]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:42.912]                     next
[16:01:42.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:42.912]                 }
[16:01:42.912]                 NAMES <- toupper(added)
[16:01:42.912]                 for (kk in seq_along(NAMES)) {
[16:01:42.912]                   name <- added[[kk]]
[16:01:42.912]                   NAME <- NAMES[[kk]]
[16:01:42.912]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:42.912]                     next
[16:01:42.912]                   args[[name]] <- ""
[16:01:42.912]                 }
[16:01:42.912]                 NAMES <- toupper(removed)
[16:01:42.912]                 for (kk in seq_along(NAMES)) {
[16:01:42.912]                   name <- removed[[kk]]
[16:01:42.912]                   NAME <- NAMES[[kk]]
[16:01:42.912]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:42.912]                     next
[16:01:42.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:42.912]                 }
[16:01:42.912]                 if (length(args) > 0) 
[16:01:42.912]                   base::do.call(base::Sys.setenv, args = args)
[16:01:42.912]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:42.912]             }
[16:01:42.912]             else {
[16:01:42.912]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:42.912]             }
[16:01:42.912]             {
[16:01:42.912]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:42.912]                   0L) {
[16:01:42.912]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:42.912]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:42.912]                   base::options(opts)
[16:01:42.912]                 }
[16:01:42.912]                 {
[16:01:42.912]                   {
[16:01:42.912]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:42.912]                     NULL
[16:01:42.912]                   }
[16:01:42.912]                   options(future.plan = NULL)
[16:01:42.912]                   if (is.na(NA_character_)) 
[16:01:42.912]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:42.912]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:42.912]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:42.912]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:42.912]                     envir = parent.frame()) 
[16:01:42.912]                   {
[16:01:42.912]                     if (is.function(workers)) 
[16:01:42.912]                       workers <- workers()
[16:01:42.912]                     workers <- structure(as.integer(workers), 
[16:01:42.912]                       class = class(workers))
[16:01:42.912]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:42.912]                       workers >= 1)
[16:01:42.912]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:42.912]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:42.912]                     }
[16:01:42.912]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:42.912]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:42.912]                       envir = envir)
[16:01:42.912]                     if (!future$lazy) 
[16:01:42.912]                       future <- run(future)
[16:01:42.912]                     invisible(future)
[16:01:42.912]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:42.912]                 }
[16:01:42.912]             }
[16:01:42.912]         }
[16:01:42.912]     })
[16:01:42.912]     if (TRUE) {
[16:01:42.912]         base::sink(type = "output", split = FALSE)
[16:01:42.912]         if (TRUE) {
[16:01:42.912]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:42.912]         }
[16:01:42.912]         else {
[16:01:42.912]             ...future.result["stdout"] <- base::list(NULL)
[16:01:42.912]         }
[16:01:42.912]         base::close(...future.stdout)
[16:01:42.912]         ...future.stdout <- NULL
[16:01:42.912]     }
[16:01:42.912]     ...future.result$conditions <- ...future.conditions
[16:01:42.912]     ...future.result$finished <- base::Sys.time()
[16:01:42.912]     ...future.result
[16:01:42.912] }
[16:01:42.915] Exporting 5 global objects (346.05 KiB) to cluster node #1 ...
[16:01:42.915] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:01:42.916] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:01:42.916] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ...
[16:01:42.960] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ... DONE
[16:01:42.960] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[16:01:42.960] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[16:01:42.960] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:01:42.961] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:01:42.961] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:01:42.961] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:01:42.961] Exporting 5 global objects (346.05 KiB) to cluster node #1 ... DONE
[16:01:42.962] MultisessionFuture started
[16:01:42.962] - Launch lazy future ... done
[16:01:42.962] run() for ‘MultisessionFuture’ ... done
[16:01:42.963] Created future:
[16:01:42.963] MultisessionFuture:
[16:01:42.963] Label: ‘future_apply-1’
[16:01:42.963] Expression:
[16:01:42.963] {
[16:01:42.963]     do.call(function(...) {
[16:01:42.963]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:42.963]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:42.963]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:42.963]             on.exit(options(oopts), add = TRUE)
[16:01:42.963]         }
[16:01:42.963]         {
[16:01:42.963]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:42.963]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:42.963]                 ...future.FUN(...future.X_jj, ...)
[16:01:42.963]             })
[16:01:42.963]         }
[16:01:42.963]     }, args = future.call.arguments)
[16:01:42.963] }
[16:01:42.963] Lazy evaluation: FALSE
[16:01:42.963] Asynchronous evaluation: TRUE
[16:01:42.963] Local evaluation: TRUE
[16:01:42.963] Environment: R_GlobalEnv
[16:01:42.963] Capture standard output: TRUE
[16:01:42.963] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:42.963] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:42.963] Packages: <none>
[16:01:42.963] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:42.963] Resolved: FALSE
[16:01:42.963] Value: <not collected>
[16:01:42.963] Conditions captured: <none>
[16:01:42.963] Early signaling: FALSE
[16:01:42.963] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:42.963] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:42.974] Chunk #1 of 2 ... DONE
[16:01:42.975] Chunk #2 of 2 ...
[16:01:42.975]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:42.975]  - seeds: <none>
[16:01:42.975]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:42.975] getGlobalsAndPackages() ...
[16:01:42.975] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:42.975] Resolving globals: FALSE
[16:01:42.975] Tweak future expression to call with '...' arguments ...
[16:01:42.976] {
[16:01:42.976]     do.call(function(...) {
[16:01:42.976]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:42.976]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:42.976]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:42.976]             on.exit(options(oopts), add = TRUE)
[16:01:42.976]         }
[16:01:42.976]         {
[16:01:42.976]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:42.976]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:42.976]                 ...future.FUN(...future.X_jj, ...)
[16:01:42.976]             })
[16:01:42.976]         }
[16:01:42.976]     }, args = future.call.arguments)
[16:01:42.976] }
[16:01:42.976] Tweak future expression to call with '...' arguments ... DONE
[16:01:42.976] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:42.976] 
[16:01:42.976] getGlobalsAndPackages() ... DONE
[16:01:42.977] run() for ‘Future’ ...
[16:01:42.977] - state: ‘created’
[16:01:42.977] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:42.991] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:42.992] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:42.992]   - Field: ‘node’
[16:01:42.992]   - Field: ‘label’
[16:01:42.992]   - Field: ‘local’
[16:01:42.992]   - Field: ‘owner’
[16:01:42.992]   - Field: ‘envir’
[16:01:42.992]   - Field: ‘workers’
[16:01:42.992]   - Field: ‘packages’
[16:01:42.992]   - Field: ‘gc’
[16:01:42.993]   - Field: ‘conditions’
[16:01:42.993]   - Field: ‘persistent’
[16:01:42.993]   - Field: ‘expr’
[16:01:42.993]   - Field: ‘uuid’
[16:01:42.993]   - Field: ‘seed’
[16:01:42.993]   - Field: ‘version’
[16:01:42.993]   - Field: ‘result’
[16:01:42.993]   - Field: ‘asynchronous’
[16:01:42.993]   - Field: ‘calls’
[16:01:42.993]   - Field: ‘globals’
[16:01:42.994]   - Field: ‘stdout’
[16:01:42.994]   - Field: ‘earlySignal’
[16:01:42.994]   - Field: ‘lazy’
[16:01:42.994]   - Field: ‘state’
[16:01:42.994] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:42.994] - Launch lazy future ...
[16:01:42.994] Packages needed by the future expression (n = 0): <none>
[16:01:42.994] Packages needed by future strategies (n = 0): <none>
[16:01:42.995] {
[16:01:42.995]     {
[16:01:42.995]         {
[16:01:42.995]             ...future.startTime <- base::Sys.time()
[16:01:42.995]             {
[16:01:42.995]                 {
[16:01:42.995]                   {
[16:01:42.995]                     {
[16:01:42.995]                       base::local({
[16:01:42.995]                         has_future <- base::requireNamespace("future", 
[16:01:42.995]                           quietly = TRUE)
[16:01:42.995]                         if (has_future) {
[16:01:42.995]                           ns <- base::getNamespace("future")
[16:01:42.995]                           version <- ns[[".package"]][["version"]]
[16:01:42.995]                           if (is.null(version)) 
[16:01:42.995]                             version <- utils::packageVersion("future")
[16:01:42.995]                         }
[16:01:42.995]                         else {
[16:01:42.995]                           version <- NULL
[16:01:42.995]                         }
[16:01:42.995]                         if (!has_future || version < "1.8.0") {
[16:01:42.995]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:42.995]                             "", base::R.version$version.string), 
[16:01:42.995]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:42.995]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:42.995]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:42.995]                               "release", "version")], collapse = " "), 
[16:01:42.995]                             hostname = base::Sys.info()[["nodename"]])
[16:01:42.995]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:42.995]                             info)
[16:01:42.995]                           info <- base::paste(info, collapse = "; ")
[16:01:42.995]                           if (!has_future) {
[16:01:42.995]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:42.995]                               info)
[16:01:42.995]                           }
[16:01:42.995]                           else {
[16:01:42.995]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:42.995]                               info, version)
[16:01:42.995]                           }
[16:01:42.995]                           base::stop(msg)
[16:01:42.995]                         }
[16:01:42.995]                       })
[16:01:42.995]                     }
[16:01:42.995]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:42.995]                     base::options(mc.cores = 1L)
[16:01:42.995]                   }
[16:01:42.995]                   options(future.plan = NULL)
[16:01:42.995]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:42.995]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:42.995]                 }
[16:01:42.995]                 ...future.workdir <- getwd()
[16:01:42.995]             }
[16:01:42.995]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:42.995]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:42.995]         }
[16:01:42.995]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:42.995]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:42.995]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:42.995]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:42.995]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:42.995]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:42.995]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:42.995]             base::names(...future.oldOptions))
[16:01:42.995]     }
[16:01:42.995]     if (FALSE) {
[16:01:42.995]     }
[16:01:42.995]     else {
[16:01:42.995]         if (TRUE) {
[16:01:42.995]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:42.995]                 open = "w")
[16:01:42.995]         }
[16:01:42.995]         else {
[16:01:42.995]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:42.995]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:42.995]         }
[16:01:42.995]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:42.995]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:42.995]             base::sink(type = "output", split = FALSE)
[16:01:42.995]             base::close(...future.stdout)
[16:01:42.995]         }, add = TRUE)
[16:01:42.995]     }
[16:01:42.995]     ...future.frame <- base::sys.nframe()
[16:01:42.995]     ...future.conditions <- base::list()
[16:01:42.995]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:42.995]     if (FALSE) {
[16:01:42.995]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:42.995]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:42.995]     }
[16:01:42.995]     ...future.result <- base::tryCatch({
[16:01:42.995]         base::withCallingHandlers({
[16:01:42.995]             ...future.value <- base::withVisible(base::local({
[16:01:42.995]                 ...future.makeSendCondition <- base::local({
[16:01:42.995]                   sendCondition <- NULL
[16:01:42.995]                   function(frame = 1L) {
[16:01:42.995]                     if (is.function(sendCondition)) 
[16:01:42.995]                       return(sendCondition)
[16:01:42.995]                     ns <- getNamespace("parallel")
[16:01:42.995]                     if (exists("sendData", mode = "function", 
[16:01:42.995]                       envir = ns)) {
[16:01:42.995]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:42.995]                         envir = ns)
[16:01:42.995]                       envir <- sys.frame(frame)
[16:01:42.995]                       master <- NULL
[16:01:42.995]                       while (!identical(envir, .GlobalEnv) && 
[16:01:42.995]                         !identical(envir, emptyenv())) {
[16:01:42.995]                         if (exists("master", mode = "list", envir = envir, 
[16:01:42.995]                           inherits = FALSE)) {
[16:01:42.995]                           master <- get("master", mode = "list", 
[16:01:42.995]                             envir = envir, inherits = FALSE)
[16:01:42.995]                           if (inherits(master, c("SOCKnode", 
[16:01:42.995]                             "SOCK0node"))) {
[16:01:42.995]                             sendCondition <<- function(cond) {
[16:01:42.995]                               data <- list(type = "VALUE", value = cond, 
[16:01:42.995]                                 success = TRUE)
[16:01:42.995]                               parallel_sendData(master, data)
[16:01:42.995]                             }
[16:01:42.995]                             return(sendCondition)
[16:01:42.995]                           }
[16:01:42.995]                         }
[16:01:42.995]                         frame <- frame + 1L
[16:01:42.995]                         envir <- sys.frame(frame)
[16:01:42.995]                       }
[16:01:42.995]                     }
[16:01:42.995]                     sendCondition <<- function(cond) NULL
[16:01:42.995]                   }
[16:01:42.995]                 })
[16:01:42.995]                 withCallingHandlers({
[16:01:42.995]                   {
[16:01:42.995]                     do.call(function(...) {
[16:01:42.995]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:42.995]                       if (!identical(...future.globals.maxSize.org, 
[16:01:42.995]                         ...future.globals.maxSize)) {
[16:01:42.995]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:42.995]                         on.exit(options(oopts), add = TRUE)
[16:01:42.995]                       }
[16:01:42.995]                       {
[16:01:42.995]                         lapply(seq_along(...future.elements_ii), 
[16:01:42.995]                           FUN = function(jj) {
[16:01:42.995]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:42.995]                             ...future.FUN(...future.X_jj, ...)
[16:01:42.995]                           })
[16:01:42.995]                       }
[16:01:42.995]                     }, args = future.call.arguments)
[16:01:42.995]                   }
[16:01:42.995]                 }, immediateCondition = function(cond) {
[16:01:42.995]                   sendCondition <- ...future.makeSendCondition()
[16:01:42.995]                   sendCondition(cond)
[16:01:42.995]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:42.995]                   {
[16:01:42.995]                     inherits <- base::inherits
[16:01:42.995]                     invokeRestart <- base::invokeRestart
[16:01:42.995]                     is.null <- base::is.null
[16:01:42.995]                     muffled <- FALSE
[16:01:42.995]                     if (inherits(cond, "message")) {
[16:01:42.995]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:42.995]                       if (muffled) 
[16:01:42.995]                         invokeRestart("muffleMessage")
[16:01:42.995]                     }
[16:01:42.995]                     else if (inherits(cond, "warning")) {
[16:01:42.995]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:42.995]                       if (muffled) 
[16:01:42.995]                         invokeRestart("muffleWarning")
[16:01:42.995]                     }
[16:01:42.995]                     else if (inherits(cond, "condition")) {
[16:01:42.995]                       if (!is.null(pattern)) {
[16:01:42.995]                         computeRestarts <- base::computeRestarts
[16:01:42.995]                         grepl <- base::grepl
[16:01:42.995]                         restarts <- computeRestarts(cond)
[16:01:42.995]                         for (restart in restarts) {
[16:01:42.995]                           name <- restart$name
[16:01:42.995]                           if (is.null(name)) 
[16:01:42.995]                             next
[16:01:42.995]                           if (!grepl(pattern, name)) 
[16:01:42.995]                             next
[16:01:42.995]                           invokeRestart(restart)
[16:01:42.995]                           muffled <- TRUE
[16:01:42.995]                           break
[16:01:42.995]                         }
[16:01:42.995]                       }
[16:01:42.995]                     }
[16:01:42.995]                     invisible(muffled)
[16:01:42.995]                   }
[16:01:42.995]                   muffleCondition(cond)
[16:01:42.995]                 })
[16:01:42.995]             }))
[16:01:42.995]             future::FutureResult(value = ...future.value$value, 
[16:01:42.995]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:42.995]                   ...future.rng), globalenv = if (FALSE) 
[16:01:42.995]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:42.995]                     ...future.globalenv.names))
[16:01:42.995]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:42.995]         }, condition = base::local({
[16:01:42.995]             c <- base::c
[16:01:42.995]             inherits <- base::inherits
[16:01:42.995]             invokeRestart <- base::invokeRestart
[16:01:42.995]             length <- base::length
[16:01:42.995]             list <- base::list
[16:01:42.995]             seq.int <- base::seq.int
[16:01:42.995]             signalCondition <- base::signalCondition
[16:01:42.995]             sys.calls <- base::sys.calls
[16:01:42.995]             `[[` <- base::`[[`
[16:01:42.995]             `+` <- base::`+`
[16:01:42.995]             `<<-` <- base::`<<-`
[16:01:42.995]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:42.995]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:42.995]                   3L)]
[16:01:42.995]             }
[16:01:42.995]             function(cond) {
[16:01:42.995]                 is_error <- inherits(cond, "error")
[16:01:42.995]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:42.995]                   NULL)
[16:01:42.995]                 if (is_error) {
[16:01:42.995]                   sessionInformation <- function() {
[16:01:42.995]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:42.995]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:42.995]                       search = base::search(), system = base::Sys.info())
[16:01:42.995]                   }
[16:01:42.995]                   ...future.conditions[[length(...future.conditions) + 
[16:01:42.995]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:42.995]                     cond$call), session = sessionInformation(), 
[16:01:42.995]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:42.995]                   signalCondition(cond)
[16:01:42.995]                 }
[16:01:42.995]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:42.995]                 "immediateCondition"))) {
[16:01:42.995]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:42.995]                   ...future.conditions[[length(...future.conditions) + 
[16:01:42.995]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:42.995]                   if (TRUE && !signal) {
[16:01:42.995]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:42.995]                     {
[16:01:42.995]                       inherits <- base::inherits
[16:01:42.995]                       invokeRestart <- base::invokeRestart
[16:01:42.995]                       is.null <- base::is.null
[16:01:42.995]                       muffled <- FALSE
[16:01:42.995]                       if (inherits(cond, "message")) {
[16:01:42.995]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:42.995]                         if (muffled) 
[16:01:42.995]                           invokeRestart("muffleMessage")
[16:01:42.995]                       }
[16:01:42.995]                       else if (inherits(cond, "warning")) {
[16:01:42.995]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:42.995]                         if (muffled) 
[16:01:42.995]                           invokeRestart("muffleWarning")
[16:01:42.995]                       }
[16:01:42.995]                       else if (inherits(cond, "condition")) {
[16:01:42.995]                         if (!is.null(pattern)) {
[16:01:42.995]                           computeRestarts <- base::computeRestarts
[16:01:42.995]                           grepl <- base::grepl
[16:01:42.995]                           restarts <- computeRestarts(cond)
[16:01:42.995]                           for (restart in restarts) {
[16:01:42.995]                             name <- restart$name
[16:01:42.995]                             if (is.null(name)) 
[16:01:42.995]                               next
[16:01:42.995]                             if (!grepl(pattern, name)) 
[16:01:42.995]                               next
[16:01:42.995]                             invokeRestart(restart)
[16:01:42.995]                             muffled <- TRUE
[16:01:42.995]                             break
[16:01:42.995]                           }
[16:01:42.995]                         }
[16:01:42.995]                       }
[16:01:42.995]                       invisible(muffled)
[16:01:42.995]                     }
[16:01:42.995]                     muffleCondition(cond, pattern = "^muffle")
[16:01:42.995]                   }
[16:01:42.995]                 }
[16:01:42.995]                 else {
[16:01:42.995]                   if (TRUE) {
[16:01:42.995]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:42.995]                     {
[16:01:42.995]                       inherits <- base::inherits
[16:01:42.995]                       invokeRestart <- base::invokeRestart
[16:01:42.995]                       is.null <- base::is.null
[16:01:42.995]                       muffled <- FALSE
[16:01:42.995]                       if (inherits(cond, "message")) {
[16:01:42.995]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:42.995]                         if (muffled) 
[16:01:42.995]                           invokeRestart("muffleMessage")
[16:01:42.995]                       }
[16:01:42.995]                       else if (inherits(cond, "warning")) {
[16:01:42.995]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:42.995]                         if (muffled) 
[16:01:42.995]                           invokeRestart("muffleWarning")
[16:01:42.995]                       }
[16:01:42.995]                       else if (inherits(cond, "condition")) {
[16:01:42.995]                         if (!is.null(pattern)) {
[16:01:42.995]                           computeRestarts <- base::computeRestarts
[16:01:42.995]                           grepl <- base::grepl
[16:01:42.995]                           restarts <- computeRestarts(cond)
[16:01:42.995]                           for (restart in restarts) {
[16:01:42.995]                             name <- restart$name
[16:01:42.995]                             if (is.null(name)) 
[16:01:42.995]                               next
[16:01:42.995]                             if (!grepl(pattern, name)) 
[16:01:42.995]                               next
[16:01:42.995]                             invokeRestart(restart)
[16:01:42.995]                             muffled <- TRUE
[16:01:42.995]                             break
[16:01:42.995]                           }
[16:01:42.995]                         }
[16:01:42.995]                       }
[16:01:42.995]                       invisible(muffled)
[16:01:42.995]                     }
[16:01:42.995]                     muffleCondition(cond, pattern = "^muffle")
[16:01:42.995]                   }
[16:01:42.995]                 }
[16:01:42.995]             }
[16:01:42.995]         }))
[16:01:42.995]     }, error = function(ex) {
[16:01:42.995]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:42.995]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:42.995]                 ...future.rng), started = ...future.startTime, 
[16:01:42.995]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:42.995]             version = "1.8"), class = "FutureResult")
[16:01:42.995]     }, finally = {
[16:01:42.995]         if (!identical(...future.workdir, getwd())) 
[16:01:42.995]             setwd(...future.workdir)
[16:01:42.995]         {
[16:01:42.995]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:42.995]                 ...future.oldOptions$nwarnings <- NULL
[16:01:42.995]             }
[16:01:42.995]             base::options(...future.oldOptions)
[16:01:42.995]             if (.Platform$OS.type == "windows") {
[16:01:42.995]                 old_names <- names(...future.oldEnvVars)
[16:01:42.995]                 envs <- base::Sys.getenv()
[16:01:42.995]                 names <- names(envs)
[16:01:42.995]                 common <- intersect(names, old_names)
[16:01:42.995]                 added <- setdiff(names, old_names)
[16:01:42.995]                 removed <- setdiff(old_names, names)
[16:01:42.995]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:42.995]                   envs[common]]
[16:01:42.995]                 NAMES <- toupper(changed)
[16:01:42.995]                 args <- list()
[16:01:42.995]                 for (kk in seq_along(NAMES)) {
[16:01:42.995]                   name <- changed[[kk]]
[16:01:42.995]                   NAME <- NAMES[[kk]]
[16:01:42.995]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:42.995]                     next
[16:01:42.995]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:42.995]                 }
[16:01:42.995]                 NAMES <- toupper(added)
[16:01:42.995]                 for (kk in seq_along(NAMES)) {
[16:01:42.995]                   name <- added[[kk]]
[16:01:42.995]                   NAME <- NAMES[[kk]]
[16:01:42.995]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:42.995]                     next
[16:01:42.995]                   args[[name]] <- ""
[16:01:42.995]                 }
[16:01:42.995]                 NAMES <- toupper(removed)
[16:01:42.995]                 for (kk in seq_along(NAMES)) {
[16:01:42.995]                   name <- removed[[kk]]
[16:01:42.995]                   NAME <- NAMES[[kk]]
[16:01:42.995]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:42.995]                     next
[16:01:42.995]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:42.995]                 }
[16:01:42.995]                 if (length(args) > 0) 
[16:01:42.995]                   base::do.call(base::Sys.setenv, args = args)
[16:01:42.995]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:42.995]             }
[16:01:42.995]             else {
[16:01:42.995]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:42.995]             }
[16:01:42.995]             {
[16:01:42.995]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:42.995]                   0L) {
[16:01:42.995]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:42.995]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:42.995]                   base::options(opts)
[16:01:42.995]                 }
[16:01:42.995]                 {
[16:01:42.995]                   {
[16:01:42.995]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:42.995]                     NULL
[16:01:42.995]                   }
[16:01:42.995]                   options(future.plan = NULL)
[16:01:42.995]                   if (is.na(NA_character_)) 
[16:01:42.995]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:42.995]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:42.995]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:42.995]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:42.995]                     envir = parent.frame()) 
[16:01:42.995]                   {
[16:01:42.995]                     if (is.function(workers)) 
[16:01:42.995]                       workers <- workers()
[16:01:42.995]                     workers <- structure(as.integer(workers), 
[16:01:42.995]                       class = class(workers))
[16:01:42.995]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:42.995]                       workers >= 1)
[16:01:42.995]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:42.995]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:42.995]                     }
[16:01:42.995]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:42.995]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:42.995]                       envir = envir)
[16:01:42.995]                     if (!future$lazy) 
[16:01:42.995]                       future <- run(future)
[16:01:42.995]                     invisible(future)
[16:01:42.995]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:42.995]                 }
[16:01:42.995]             }
[16:01:42.995]         }
[16:01:42.995]     })
[16:01:42.995]     if (TRUE) {
[16:01:42.995]         base::sink(type = "output", split = FALSE)
[16:01:42.995]         if (TRUE) {
[16:01:42.995]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:42.995]         }
[16:01:42.995]         else {
[16:01:42.995]             ...future.result["stdout"] <- base::list(NULL)
[16:01:42.995]         }
[16:01:42.995]         base::close(...future.stdout)
[16:01:42.995]         ...future.stdout <- NULL
[16:01:42.995]     }
[16:01:42.995]     ...future.result$conditions <- ...future.conditions
[16:01:42.995]     ...future.result$finished <- base::Sys.time()
[16:01:42.995]     ...future.result
[16:01:42.995] }
[16:01:42.998] Exporting 5 global objects (346.05 KiB) to cluster node #2 ...
[16:01:42.998] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:01:42.999] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:01:42.999] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ...
[16:01:43.044] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ... DONE
[16:01:43.044] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[16:01:43.044] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[16:01:43.044] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:01:43.045] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:01:43.045] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[16:01:43.045] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[16:01:43.045] Exporting 5 global objects (346.05 KiB) to cluster node #2 ... DONE
[16:01:43.046] MultisessionFuture started
[16:01:43.046] - Launch lazy future ... done
[16:01:43.046] run() for ‘MultisessionFuture’ ... done
[16:01:43.046] Created future:
[16:01:43.047] MultisessionFuture:
[16:01:43.047] Label: ‘future_apply-2’
[16:01:43.047] Expression:
[16:01:43.047] {
[16:01:43.047]     do.call(function(...) {
[16:01:43.047]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.047]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:43.047]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.047]             on.exit(options(oopts), add = TRUE)
[16:01:43.047]         }
[16:01:43.047]         {
[16:01:43.047]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:43.047]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.047]                 ...future.FUN(...future.X_jj, ...)
[16:01:43.047]             })
[16:01:43.047]         }
[16:01:43.047]     }, args = future.call.arguments)
[16:01:43.047] }
[16:01:43.047] Lazy evaluation: FALSE
[16:01:43.047] Asynchronous evaluation: TRUE
[16:01:43.047] Local evaluation: TRUE
[16:01:43.047] Environment: R_GlobalEnv
[16:01:43.047] Capture standard output: TRUE
[16:01:43.047] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:43.047] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:43.047] Packages: <none>
[16:01:43.047] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:43.047] Resolved: FALSE
[16:01:43.047] Value: <not collected>
[16:01:43.047] Conditions captured: <none>
[16:01:43.047] Early signaling: FALSE
[16:01:43.047] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:43.047] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:43.058] Chunk #2 of 2 ... DONE
[16:01:43.059] Launching 2 futures (chunks) ... DONE
[16:01:43.059] Resolving 2 futures (chunks) ...
[16:01:43.059] resolve() on list ...
[16:01:43.059]  recursive: 0
[16:01:43.059]  length: 2
[16:01:43.059] 
[16:01:43.060] receiveMessageFromWorker() for ClusterFuture ...
[16:01:43.060] - Validating connection of MultisessionFuture
[16:01:43.060] - received message: FutureResult
[16:01:43.060] - Received FutureResult
[16:01:43.060] - Erased future from FutureRegistry
[16:01:43.060] result() for ClusterFuture ...
[16:01:43.060] - result already collected: FutureResult
[16:01:43.061] result() for ClusterFuture ... done
[16:01:43.061] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:43.061] Future #1
[16:01:43.061] result() for ClusterFuture ...
[16:01:43.061] - result already collected: FutureResult
[16:01:43.061] result() for ClusterFuture ... done
[16:01:43.061] result() for ClusterFuture ...
[16:01:43.061] - result already collected: FutureResult
[16:01:43.061] result() for ClusterFuture ... done
[16:01:43.061] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:01:43.062] - nx: 2
[16:01:43.062] - relay: TRUE
[16:01:43.062] - stdout: TRUE
[16:01:43.062] - signal: TRUE
[16:01:43.062] - resignal: FALSE
[16:01:43.062] - force: TRUE
[16:01:43.062] - relayed: [n=2] FALSE, FALSE
[16:01:43.062] - queued futures: [n=2] FALSE, FALSE
[16:01:43.062]  - until=1
[16:01:43.062]  - relaying element #1
[16:01:43.062] result() for ClusterFuture ...
[16:01:43.063] - result already collected: FutureResult
[16:01:43.063] result() for ClusterFuture ... done
[16:01:43.063] result() for ClusterFuture ...
[16:01:43.063] - result already collected: FutureResult
[16:01:43.063] result() for ClusterFuture ... done
[16:01:43.063] result() for ClusterFuture ...
[16:01:43.063] - result already collected: FutureResult
[16:01:43.065] result() for ClusterFuture ... done
[16:01:43.065] result() for ClusterFuture ...
[16:01:43.065] - result already collected: FutureResult
[16:01:43.066] result() for ClusterFuture ... done
[16:01:43.066] - relayed: [n=2] TRUE, FALSE
[16:01:43.066] - queued futures: [n=2] TRUE, FALSE
[16:01:43.066] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:01:43.066]  length: 1 (resolved future 1)
[16:01:43.092] receiveMessageFromWorker() for ClusterFuture ...
[16:01:43.092] - Validating connection of MultisessionFuture
[16:01:43.092] - received message: FutureResult
[16:01:43.093] - Received FutureResult
[16:01:43.093] - Erased future from FutureRegistry
[16:01:43.093] result() for ClusterFuture ...
[16:01:43.093] - result already collected: FutureResult
[16:01:43.093] result() for ClusterFuture ... done
[16:01:43.093] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:43.093] Future #2
[16:01:43.093] result() for ClusterFuture ...
[16:01:43.093] - result already collected: FutureResult
[16:01:43.093] result() for ClusterFuture ... done
[16:01:43.093] result() for ClusterFuture ...
[16:01:43.094] - result already collected: FutureResult
[16:01:43.094] result() for ClusterFuture ... done
[16:01:43.094] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:01:43.094] - nx: 2
[16:01:43.094] - relay: TRUE
[16:01:43.094] - stdout: TRUE
[16:01:43.094] - signal: TRUE
[16:01:43.094] - resignal: FALSE
[16:01:43.094] - force: TRUE
[16:01:43.094] - relayed: [n=2] TRUE, FALSE
[16:01:43.094] - queued futures: [n=2] TRUE, FALSE
[16:01:43.095]  - until=2
[16:01:43.095]  - relaying element #2
[16:01:43.095] result() for ClusterFuture ...
[16:01:43.095] - result already collected: FutureResult
[16:01:43.095] result() for ClusterFuture ... done
[16:01:43.095] result() for ClusterFuture ...
[16:01:43.095] - result already collected: FutureResult
[16:01:43.095] result() for ClusterFuture ... done
[16:01:43.095] result() for ClusterFuture ...
[16:01:43.095] - result already collected: FutureResult
[16:01:43.095] result() for ClusterFuture ... done
[16:01:43.096] result() for ClusterFuture ...
[16:01:43.096] - result already collected: FutureResult
[16:01:43.096] result() for ClusterFuture ... done
[16:01:43.096] - relayed: [n=2] TRUE, TRUE
[16:01:43.096] - queued futures: [n=2] TRUE, TRUE
[16:01:43.096] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:01:43.096]  length: 0 (resolved future 2)
[16:01:43.096] Relaying remaining futures
[16:01:43.096] signalConditionsASAP(NULL, pos=0) ...
[16:01:43.096] - nx: 2
[16:01:43.096] - relay: TRUE
[16:01:43.096] - stdout: TRUE
[16:01:43.097] - signal: TRUE
[16:01:43.097] - resignal: FALSE
[16:01:43.097] - force: TRUE
[16:01:43.097] - relayed: [n=2] TRUE, TRUE
[16:01:43.097] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:43.097] - relayed: [n=2] TRUE, TRUE
[16:01:43.097] - queued futures: [n=2] TRUE, TRUE
[16:01:43.097] signalConditionsASAP(NULL, pos=0) ... done
[16:01:43.097] resolve() on list ... DONE
[16:01:43.097] result() for ClusterFuture ...
[16:01:43.097] - result already collected: FutureResult
[16:01:43.098] result() for ClusterFuture ... done
[16:01:43.098] result() for ClusterFuture ...
[16:01:43.098] - result already collected: FutureResult
[16:01:43.098] result() for ClusterFuture ... done
[16:01:43.098] result() for ClusterFuture ...
[16:01:43.098] - result already collected: FutureResult
[16:01:43.098] result() for ClusterFuture ... done
[16:01:43.098] result() for ClusterFuture ...
[16:01:43.098] - result already collected: FutureResult
[16:01:43.098] result() for ClusterFuture ... done
[16:01:43.098]  - Number of value chunks collected: 2
[16:01:43.099] Resolving 2 futures (chunks) ... DONE
[16:01:43.099] Reducing values from 2 chunks ...
[16:01:43.099]  - Number of values collected after concatenation: 2
[16:01:43.099]  - Number of values expected: 2
[16:01:43.099] Reducing values from 2 chunks ... DONE
[16:01:43.099] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[16:01:43.100] getGlobalsAndPackagesXApply() ...
[16:01:43.100]  - future.globals: TRUE
[16:01:43.100] getGlobalsAndPackages() ...
[16:01:43.100] Searching for globals...
[16:01:43.101] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:01:43.101] Searching for globals ... DONE
[16:01:43.102] Resolving globals: FALSE
[16:01:43.102] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:01:43.102] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:01:43.102] - globals: [1] ‘FUN’
[16:01:43.103] - packages: [1] ‘stats’
[16:01:43.103] getGlobalsAndPackages() ... DONE
[16:01:43.103]  - globals found/used: [n=1] ‘FUN’
[16:01:43.103]  - needed namespaces: [n=1] ‘stats’
[16:01:43.103] Finding globals ... DONE
[16:01:43.103]  - use_args: TRUE
[16:01:43.103]  - Getting '...' globals ...
[16:01:43.103] resolve() on list ...
[16:01:43.104]  recursive: 0
[16:01:43.104]  length: 1
[16:01:43.104]  elements: ‘...’
[16:01:43.104]  length: 0 (resolved future 1)
[16:01:43.104] resolve() on list ... DONE
[16:01:43.104]    - '...' content: [n=0] 
[16:01:43.104] List of 1
[16:01:43.104]  $ ...: list()
[16:01:43.104]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:43.104]  - attr(*, "where")=List of 1
[16:01:43.104]   ..$ ...:<environment: 0x55fb649e4348> 
[16:01:43.104]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:43.104]  - attr(*, "resolved")= logi TRUE
[16:01:43.104]  - attr(*, "total_size")= num NA
[16:01:43.107]  - Getting '...' globals ... DONE
[16:01:43.107] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:43.107] List of 2
[16:01:43.107]  $ ...future.FUN:function (x, ...)  
[16:01:43.107]  $ ...          : list()
[16:01:43.107]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:43.107]  - attr(*, "where")=List of 2
[16:01:43.107]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:43.107]   ..$ ...          :<environment: 0x55fb649e4348> 
[16:01:43.107]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:43.107]  - attr(*, "resolved")= logi FALSE
[16:01:43.107]  - attr(*, "total_size")= num 1248
[16:01:43.110] Packages to be attached in all futures: [n=1] ‘stats’
[16:01:43.110] getGlobalsAndPackagesXApply() ... DONE
[16:01:43.114] future_lapply() ...
[16:01:43.117] Number of chunks: 2
[16:01:43.118] getGlobalsAndPackagesXApply() ...
[16:01:43.118]  - future.globals: <name-value list> with names ‘list()’
[16:01:43.118]  - use_args: TRUE
[16:01:43.118] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:01:43.118] List of 2
[16:01:43.118]  $ ...          : list()
[16:01:43.118]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:43.118]  $ ...future.FUN:function (x, ...)  
[16:01:43.118]  - attr(*, "where")=List of 2
[16:01:43.118]   ..$ ...          :<environment: 0x55fb649e4348> 
[16:01:43.118]   ..$ ...future.FUN:<environment: namespace:stats> 
[16:01:43.118]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:43.118]  - attr(*, "resolved")= logi FALSE
[16:01:43.118]  - attr(*, "total_size")= num NA
[16:01:43.121] Packages to be attached in all futures: [n=1] ‘stats’
[16:01:43.121] getGlobalsAndPackagesXApply() ... DONE
[16:01:43.121] Number of futures (= number of chunks): 2
[16:01:43.121] Launching 2 futures (chunks) ...
[16:01:43.122] Chunk #1 of 2 ...
[16:01:43.122]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:43.122]  - seeds: <none>
[16:01:43.122]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.122] getGlobalsAndPackages() ...
[16:01:43.122] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.122] Resolving globals: FALSE
[16:01:43.122] Tweak future expression to call with '...' arguments ...
[16:01:43.122] {
[16:01:43.122]     do.call(function(...) {
[16:01:43.122]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.122]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:43.122]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.122]             on.exit(options(oopts), add = TRUE)
[16:01:43.122]         }
[16:01:43.122]         {
[16:01:43.122]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:43.122]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.122]                 ...future.FUN(...future.X_jj, ...)
[16:01:43.122]             })
[16:01:43.122]         }
[16:01:43.122]     }, args = future.call.arguments)
[16:01:43.122] }
[16:01:43.123] Tweak future expression to call with '...' arguments ... DONE
[16:01:43.123] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.123] - packages: [1] ‘stats’
[16:01:43.123] getGlobalsAndPackages() ... DONE
[16:01:43.124] run() for ‘Future’ ...
[16:01:43.124] - state: ‘created’
[16:01:43.124] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:43.138] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:43.138] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:43.138]   - Field: ‘node’
[16:01:43.138]   - Field: ‘label’
[16:01:43.139]   - Field: ‘local’
[16:01:43.139]   - Field: ‘owner’
[16:01:43.139]   - Field: ‘envir’
[16:01:43.139]   - Field: ‘workers’
[16:01:43.139]   - Field: ‘packages’
[16:01:43.139]   - Field: ‘gc’
[16:01:43.139]   - Field: ‘conditions’
[16:01:43.139]   - Field: ‘persistent’
[16:01:43.139]   - Field: ‘expr’
[16:01:43.139]   - Field: ‘uuid’
[16:01:43.140]   - Field: ‘seed’
[16:01:43.140]   - Field: ‘version’
[16:01:43.140]   - Field: ‘result’
[16:01:43.140]   - Field: ‘asynchronous’
[16:01:43.140]   - Field: ‘calls’
[16:01:43.140]   - Field: ‘globals’
[16:01:43.140]   - Field: ‘stdout’
[16:01:43.140]   - Field: ‘earlySignal’
[16:01:43.140]   - Field: ‘lazy’
[16:01:43.140]   - Field: ‘state’
[16:01:43.140] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:43.141] - Launch lazy future ...
[16:01:43.141] Packages needed by the future expression (n = 1): ‘stats’
[16:01:43.141] Packages needed by future strategies (n = 0): <none>
[16:01:43.142] {
[16:01:43.142]     {
[16:01:43.142]         {
[16:01:43.142]             ...future.startTime <- base::Sys.time()
[16:01:43.142]             {
[16:01:43.142]                 {
[16:01:43.142]                   {
[16:01:43.142]                     {
[16:01:43.142]                       {
[16:01:43.142]                         base::local({
[16:01:43.142]                           has_future <- base::requireNamespace("future", 
[16:01:43.142]                             quietly = TRUE)
[16:01:43.142]                           if (has_future) {
[16:01:43.142]                             ns <- base::getNamespace("future")
[16:01:43.142]                             version <- ns[[".package"]][["version"]]
[16:01:43.142]                             if (is.null(version)) 
[16:01:43.142]                               version <- utils::packageVersion("future")
[16:01:43.142]                           }
[16:01:43.142]                           else {
[16:01:43.142]                             version <- NULL
[16:01:43.142]                           }
[16:01:43.142]                           if (!has_future || version < "1.8.0") {
[16:01:43.142]                             info <- base::c(r_version = base::gsub("R version ", 
[16:01:43.142]                               "", base::R.version$version.string), 
[16:01:43.142]                               platform = base::sprintf("%s (%s-bit)", 
[16:01:43.142]                                 base::R.version$platform, 8 * 
[16:01:43.142]                                   base::.Machine$sizeof.pointer), 
[16:01:43.142]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:43.142]                                 "release", "version")], collapse = " "), 
[16:01:43.142]                               hostname = base::Sys.info()[["nodename"]])
[16:01:43.142]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:01:43.142]                               info)
[16:01:43.142]                             info <- base::paste(info, collapse = "; ")
[16:01:43.142]                             if (!has_future) {
[16:01:43.142]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:43.142]                                 info)
[16:01:43.142]                             }
[16:01:43.142]                             else {
[16:01:43.142]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:43.142]                                 info, version)
[16:01:43.142]                             }
[16:01:43.142]                             base::stop(msg)
[16:01:43.142]                           }
[16:01:43.142]                         })
[16:01:43.142]                       }
[16:01:43.142]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:43.142]                       base::options(mc.cores = 1L)
[16:01:43.142]                     }
[16:01:43.142]                     base::local({
[16:01:43.142]                       for (pkg in "stats") {
[16:01:43.142]                         base::loadNamespace(pkg)
[16:01:43.142]                         base::library(pkg, character.only = TRUE)
[16:01:43.142]                       }
[16:01:43.142]                     })
[16:01:43.142]                   }
[16:01:43.142]                   options(future.plan = NULL)
[16:01:43.142]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:43.142]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:43.142]                 }
[16:01:43.142]                 ...future.workdir <- getwd()
[16:01:43.142]             }
[16:01:43.142]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:43.142]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:43.142]         }
[16:01:43.142]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:43.142]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:43.142]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:43.142]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:43.142]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:43.142]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:43.142]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:43.142]             base::names(...future.oldOptions))
[16:01:43.142]     }
[16:01:43.142]     if (FALSE) {
[16:01:43.142]     }
[16:01:43.142]     else {
[16:01:43.142]         if (TRUE) {
[16:01:43.142]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:43.142]                 open = "w")
[16:01:43.142]         }
[16:01:43.142]         else {
[16:01:43.142]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:43.142]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:43.142]         }
[16:01:43.142]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:43.142]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:43.142]             base::sink(type = "output", split = FALSE)
[16:01:43.142]             base::close(...future.stdout)
[16:01:43.142]         }, add = TRUE)
[16:01:43.142]     }
[16:01:43.142]     ...future.frame <- base::sys.nframe()
[16:01:43.142]     ...future.conditions <- base::list()
[16:01:43.142]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:43.142]     if (FALSE) {
[16:01:43.142]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:43.142]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:43.142]     }
[16:01:43.142]     ...future.result <- base::tryCatch({
[16:01:43.142]         base::withCallingHandlers({
[16:01:43.142]             ...future.value <- base::withVisible(base::local({
[16:01:43.142]                 ...future.makeSendCondition <- base::local({
[16:01:43.142]                   sendCondition <- NULL
[16:01:43.142]                   function(frame = 1L) {
[16:01:43.142]                     if (is.function(sendCondition)) 
[16:01:43.142]                       return(sendCondition)
[16:01:43.142]                     ns <- getNamespace("parallel")
[16:01:43.142]                     if (exists("sendData", mode = "function", 
[16:01:43.142]                       envir = ns)) {
[16:01:43.142]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:43.142]                         envir = ns)
[16:01:43.142]                       envir <- sys.frame(frame)
[16:01:43.142]                       master <- NULL
[16:01:43.142]                       while (!identical(envir, .GlobalEnv) && 
[16:01:43.142]                         !identical(envir, emptyenv())) {
[16:01:43.142]                         if (exists("master", mode = "list", envir = envir, 
[16:01:43.142]                           inherits = FALSE)) {
[16:01:43.142]                           master <- get("master", mode = "list", 
[16:01:43.142]                             envir = envir, inherits = FALSE)
[16:01:43.142]                           if (inherits(master, c("SOCKnode", 
[16:01:43.142]                             "SOCK0node"))) {
[16:01:43.142]                             sendCondition <<- function(cond) {
[16:01:43.142]                               data <- list(type = "VALUE", value = cond, 
[16:01:43.142]                                 success = TRUE)
[16:01:43.142]                               parallel_sendData(master, data)
[16:01:43.142]                             }
[16:01:43.142]                             return(sendCondition)
[16:01:43.142]                           }
[16:01:43.142]                         }
[16:01:43.142]                         frame <- frame + 1L
[16:01:43.142]                         envir <- sys.frame(frame)
[16:01:43.142]                       }
[16:01:43.142]                     }
[16:01:43.142]                     sendCondition <<- function(cond) NULL
[16:01:43.142]                   }
[16:01:43.142]                 })
[16:01:43.142]                 withCallingHandlers({
[16:01:43.142]                   {
[16:01:43.142]                     do.call(function(...) {
[16:01:43.142]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.142]                       if (!identical(...future.globals.maxSize.org, 
[16:01:43.142]                         ...future.globals.maxSize)) {
[16:01:43.142]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.142]                         on.exit(options(oopts), add = TRUE)
[16:01:43.142]                       }
[16:01:43.142]                       {
[16:01:43.142]                         lapply(seq_along(...future.elements_ii), 
[16:01:43.142]                           FUN = function(jj) {
[16:01:43.142]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.142]                             ...future.FUN(...future.X_jj, ...)
[16:01:43.142]                           })
[16:01:43.142]                       }
[16:01:43.142]                     }, args = future.call.arguments)
[16:01:43.142]                   }
[16:01:43.142]                 }, immediateCondition = function(cond) {
[16:01:43.142]                   sendCondition <- ...future.makeSendCondition()
[16:01:43.142]                   sendCondition(cond)
[16:01:43.142]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.142]                   {
[16:01:43.142]                     inherits <- base::inherits
[16:01:43.142]                     invokeRestart <- base::invokeRestart
[16:01:43.142]                     is.null <- base::is.null
[16:01:43.142]                     muffled <- FALSE
[16:01:43.142]                     if (inherits(cond, "message")) {
[16:01:43.142]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:43.142]                       if (muffled) 
[16:01:43.142]                         invokeRestart("muffleMessage")
[16:01:43.142]                     }
[16:01:43.142]                     else if (inherits(cond, "warning")) {
[16:01:43.142]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:43.142]                       if (muffled) 
[16:01:43.142]                         invokeRestart("muffleWarning")
[16:01:43.142]                     }
[16:01:43.142]                     else if (inherits(cond, "condition")) {
[16:01:43.142]                       if (!is.null(pattern)) {
[16:01:43.142]                         computeRestarts <- base::computeRestarts
[16:01:43.142]                         grepl <- base::grepl
[16:01:43.142]                         restarts <- computeRestarts(cond)
[16:01:43.142]                         for (restart in restarts) {
[16:01:43.142]                           name <- restart$name
[16:01:43.142]                           if (is.null(name)) 
[16:01:43.142]                             next
[16:01:43.142]                           if (!grepl(pattern, name)) 
[16:01:43.142]                             next
[16:01:43.142]                           invokeRestart(restart)
[16:01:43.142]                           muffled <- TRUE
[16:01:43.142]                           break
[16:01:43.142]                         }
[16:01:43.142]                       }
[16:01:43.142]                     }
[16:01:43.142]                     invisible(muffled)
[16:01:43.142]                   }
[16:01:43.142]                   muffleCondition(cond)
[16:01:43.142]                 })
[16:01:43.142]             }))
[16:01:43.142]             future::FutureResult(value = ...future.value$value, 
[16:01:43.142]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:43.142]                   ...future.rng), globalenv = if (FALSE) 
[16:01:43.142]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:43.142]                     ...future.globalenv.names))
[16:01:43.142]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:43.142]         }, condition = base::local({
[16:01:43.142]             c <- base::c
[16:01:43.142]             inherits <- base::inherits
[16:01:43.142]             invokeRestart <- base::invokeRestart
[16:01:43.142]             length <- base::length
[16:01:43.142]             list <- base::list
[16:01:43.142]             seq.int <- base::seq.int
[16:01:43.142]             signalCondition <- base::signalCondition
[16:01:43.142]             sys.calls <- base::sys.calls
[16:01:43.142]             `[[` <- base::`[[`
[16:01:43.142]             `+` <- base::`+`
[16:01:43.142]             `<<-` <- base::`<<-`
[16:01:43.142]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:43.142]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:43.142]                   3L)]
[16:01:43.142]             }
[16:01:43.142]             function(cond) {
[16:01:43.142]                 is_error <- inherits(cond, "error")
[16:01:43.142]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:43.142]                   NULL)
[16:01:43.142]                 if (is_error) {
[16:01:43.142]                   sessionInformation <- function() {
[16:01:43.142]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:43.142]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:43.142]                       search = base::search(), system = base::Sys.info())
[16:01:43.142]                   }
[16:01:43.142]                   ...future.conditions[[length(...future.conditions) + 
[16:01:43.142]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:43.142]                     cond$call), session = sessionInformation(), 
[16:01:43.142]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:43.142]                   signalCondition(cond)
[16:01:43.142]                 }
[16:01:43.142]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:43.142]                 "immediateCondition"))) {
[16:01:43.142]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:43.142]                   ...future.conditions[[length(...future.conditions) + 
[16:01:43.142]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:43.142]                   if (TRUE && !signal) {
[16:01:43.142]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.142]                     {
[16:01:43.142]                       inherits <- base::inherits
[16:01:43.142]                       invokeRestart <- base::invokeRestart
[16:01:43.142]                       is.null <- base::is.null
[16:01:43.142]                       muffled <- FALSE
[16:01:43.142]                       if (inherits(cond, "message")) {
[16:01:43.142]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:43.142]                         if (muffled) 
[16:01:43.142]                           invokeRestart("muffleMessage")
[16:01:43.142]                       }
[16:01:43.142]                       else if (inherits(cond, "warning")) {
[16:01:43.142]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:43.142]                         if (muffled) 
[16:01:43.142]                           invokeRestart("muffleWarning")
[16:01:43.142]                       }
[16:01:43.142]                       else if (inherits(cond, "condition")) {
[16:01:43.142]                         if (!is.null(pattern)) {
[16:01:43.142]                           computeRestarts <- base::computeRestarts
[16:01:43.142]                           grepl <- base::grepl
[16:01:43.142]                           restarts <- computeRestarts(cond)
[16:01:43.142]                           for (restart in restarts) {
[16:01:43.142]                             name <- restart$name
[16:01:43.142]                             if (is.null(name)) 
[16:01:43.142]                               next
[16:01:43.142]                             if (!grepl(pattern, name)) 
[16:01:43.142]                               next
[16:01:43.142]                             invokeRestart(restart)
[16:01:43.142]                             muffled <- TRUE
[16:01:43.142]                             break
[16:01:43.142]                           }
[16:01:43.142]                         }
[16:01:43.142]                       }
[16:01:43.142]                       invisible(muffled)
[16:01:43.142]                     }
[16:01:43.142]                     muffleCondition(cond, pattern = "^muffle")
[16:01:43.142]                   }
[16:01:43.142]                 }
[16:01:43.142]                 else {
[16:01:43.142]                   if (TRUE) {
[16:01:43.142]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.142]                     {
[16:01:43.142]                       inherits <- base::inherits
[16:01:43.142]                       invokeRestart <- base::invokeRestart
[16:01:43.142]                       is.null <- base::is.null
[16:01:43.142]                       muffled <- FALSE
[16:01:43.142]                       if (inherits(cond, "message")) {
[16:01:43.142]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:43.142]                         if (muffled) 
[16:01:43.142]                           invokeRestart("muffleMessage")
[16:01:43.142]                       }
[16:01:43.142]                       else if (inherits(cond, "warning")) {
[16:01:43.142]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:43.142]                         if (muffled) 
[16:01:43.142]                           invokeRestart("muffleWarning")
[16:01:43.142]                       }
[16:01:43.142]                       else if (inherits(cond, "condition")) {
[16:01:43.142]                         if (!is.null(pattern)) {
[16:01:43.142]                           computeRestarts <- base::computeRestarts
[16:01:43.142]                           grepl <- base::grepl
[16:01:43.142]                           restarts <- computeRestarts(cond)
[16:01:43.142]                           for (restart in restarts) {
[16:01:43.142]                             name <- restart$name
[16:01:43.142]                             if (is.null(name)) 
[16:01:43.142]                               next
[16:01:43.142]                             if (!grepl(pattern, name)) 
[16:01:43.142]                               next
[16:01:43.142]                             invokeRestart(restart)
[16:01:43.142]                             muffled <- TRUE
[16:01:43.142]                             break
[16:01:43.142]                           }
[16:01:43.142]                         }
[16:01:43.142]                       }
[16:01:43.142]                       invisible(muffled)
[16:01:43.142]                     }
[16:01:43.142]                     muffleCondition(cond, pattern = "^muffle")
[16:01:43.142]                   }
[16:01:43.142]                 }
[16:01:43.142]             }
[16:01:43.142]         }))
[16:01:43.142]     }, error = function(ex) {
[16:01:43.142]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:43.142]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:43.142]                 ...future.rng), started = ...future.startTime, 
[16:01:43.142]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:43.142]             version = "1.8"), class = "FutureResult")
[16:01:43.142]     }, finally = {
[16:01:43.142]         if (!identical(...future.workdir, getwd())) 
[16:01:43.142]             setwd(...future.workdir)
[16:01:43.142]         {
[16:01:43.142]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:43.142]                 ...future.oldOptions$nwarnings <- NULL
[16:01:43.142]             }
[16:01:43.142]             base::options(...future.oldOptions)
[16:01:43.142]             if (.Platform$OS.type == "windows") {
[16:01:43.142]                 old_names <- names(...future.oldEnvVars)
[16:01:43.142]                 envs <- base::Sys.getenv()
[16:01:43.142]                 names <- names(envs)
[16:01:43.142]                 common <- intersect(names, old_names)
[16:01:43.142]                 added <- setdiff(names, old_names)
[16:01:43.142]                 removed <- setdiff(old_names, names)
[16:01:43.142]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:43.142]                   envs[common]]
[16:01:43.142]                 NAMES <- toupper(changed)
[16:01:43.142]                 args <- list()
[16:01:43.142]                 for (kk in seq_along(NAMES)) {
[16:01:43.142]                   name <- changed[[kk]]
[16:01:43.142]                   NAME <- NAMES[[kk]]
[16:01:43.142]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.142]                     next
[16:01:43.142]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:43.142]                 }
[16:01:43.142]                 NAMES <- toupper(added)
[16:01:43.142]                 for (kk in seq_along(NAMES)) {
[16:01:43.142]                   name <- added[[kk]]
[16:01:43.142]                   NAME <- NAMES[[kk]]
[16:01:43.142]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.142]                     next
[16:01:43.142]                   args[[name]] <- ""
[16:01:43.142]                 }
[16:01:43.142]                 NAMES <- toupper(removed)
[16:01:43.142]                 for (kk in seq_along(NAMES)) {
[16:01:43.142]                   name <- removed[[kk]]
[16:01:43.142]                   NAME <- NAMES[[kk]]
[16:01:43.142]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.142]                     next
[16:01:43.142]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:43.142]                 }
[16:01:43.142]                 if (length(args) > 0) 
[16:01:43.142]                   base::do.call(base::Sys.setenv, args = args)
[16:01:43.142]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:43.142]             }
[16:01:43.142]             else {
[16:01:43.142]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:43.142]             }
[16:01:43.142]             {
[16:01:43.142]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:43.142]                   0L) {
[16:01:43.142]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:43.142]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:43.142]                   base::options(opts)
[16:01:43.142]                 }
[16:01:43.142]                 {
[16:01:43.142]                   {
[16:01:43.142]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:43.142]                     NULL
[16:01:43.142]                   }
[16:01:43.142]                   options(future.plan = NULL)
[16:01:43.142]                   if (is.na(NA_character_)) 
[16:01:43.142]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:43.142]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:43.142]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:43.142]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:43.142]                     envir = parent.frame()) 
[16:01:43.142]                   {
[16:01:43.142]                     if (is.function(workers)) 
[16:01:43.142]                       workers <- workers()
[16:01:43.142]                     workers <- structure(as.integer(workers), 
[16:01:43.142]                       class = class(workers))
[16:01:43.142]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:43.142]                       workers >= 1)
[16:01:43.142]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:43.142]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:43.142]                     }
[16:01:43.142]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:43.142]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:43.142]                       envir = envir)
[16:01:43.142]                     if (!future$lazy) 
[16:01:43.142]                       future <- run(future)
[16:01:43.142]                     invisible(future)
[16:01:43.142]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:43.142]                 }
[16:01:43.142]             }
[16:01:43.142]         }
[16:01:43.142]     })
[16:01:43.142]     if (TRUE) {
[16:01:43.142]         base::sink(type = "output", split = FALSE)
[16:01:43.142]         if (TRUE) {
[16:01:43.142]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:43.142]         }
[16:01:43.142]         else {
[16:01:43.142]             ...future.result["stdout"] <- base::list(NULL)
[16:01:43.142]         }
[16:01:43.142]         base::close(...future.stdout)
[16:01:43.142]         ...future.stdout <- NULL
[16:01:43.142]     }
[16:01:43.142]     ...future.result$conditions <- ...future.conditions
[16:01:43.142]     ...future.result$finished <- base::Sys.time()
[16:01:43.142]     ...future.result
[16:01:43.142] }
[16:01:43.145] Exporting 5 global objects (1.35 KiB) to cluster node #1 ...
[16:01:43.145] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:01:43.145] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:01:43.146] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[16:01:43.146] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[16:01:43.146] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[16:01:43.147] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[16:01:43.147] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:01:43.147] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:01:43.147] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:01:43.148] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:01:43.148] Exporting 5 global objects (1.35 KiB) to cluster node #1 ... DONE
[16:01:43.148] MultisessionFuture started
[16:01:43.148] - Launch lazy future ... done
[16:01:43.149] run() for ‘MultisessionFuture’ ... done
[16:01:43.149] Created future:
[16:01:43.149] MultisessionFuture:
[16:01:43.149] Label: ‘future_apply-1’
[16:01:43.149] Expression:
[16:01:43.149] {
[16:01:43.149]     do.call(function(...) {
[16:01:43.149]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.149]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:43.149]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.149]             on.exit(options(oopts), add = TRUE)
[16:01:43.149]         }
[16:01:43.149]         {
[16:01:43.149]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:43.149]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.149]                 ...future.FUN(...future.X_jj, ...)
[16:01:43.149]             })
[16:01:43.149]         }
[16:01:43.149]     }, args = future.call.arguments)
[16:01:43.149] }
[16:01:43.149] Lazy evaluation: FALSE
[16:01:43.149] Asynchronous evaluation: TRUE
[16:01:43.149] Local evaluation: TRUE
[16:01:43.149] Environment: R_GlobalEnv
[16:01:43.149] Capture standard output: TRUE
[16:01:43.149] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:43.149] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:43.149] Packages: 1 packages (‘stats’)
[16:01:43.149] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:43.149] Resolved: FALSE
[16:01:43.149] Value: <not collected>
[16:01:43.149] Conditions captured: <none>
[16:01:43.149] Early signaling: FALSE
[16:01:43.149] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:43.149] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:43.160] Chunk #1 of 2 ... DONE
[16:01:43.160] Chunk #2 of 2 ...
[16:01:43.161]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:43.161]  - seeds: <none>
[16:01:43.161]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.161] getGlobalsAndPackages() ...
[16:01:43.161] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.161] Resolving globals: FALSE
[16:01:43.161] Tweak future expression to call with '...' arguments ...
[16:01:43.161] {
[16:01:43.161]     do.call(function(...) {
[16:01:43.161]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.161]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:43.161]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.161]             on.exit(options(oopts), add = TRUE)
[16:01:43.161]         }
[16:01:43.161]         {
[16:01:43.161]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:43.161]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.161]                 ...future.FUN(...future.X_jj, ...)
[16:01:43.161]             })
[16:01:43.161]         }
[16:01:43.161]     }, args = future.call.arguments)
[16:01:43.161] }
[16:01:43.162] Tweak future expression to call with '...' arguments ... DONE
[16:01:43.162] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.162] - packages: [1] ‘stats’
[16:01:43.162] getGlobalsAndPackages() ... DONE
[16:01:43.163] run() for ‘Future’ ...
[16:01:43.163] - state: ‘created’
[16:01:43.163] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:43.177] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:43.177] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:43.177]   - Field: ‘node’
[16:01:43.177]   - Field: ‘label’
[16:01:43.178]   - Field: ‘local’
[16:01:43.178]   - Field: ‘owner’
[16:01:43.178]   - Field: ‘envir’
[16:01:43.178]   - Field: ‘workers’
[16:01:43.178]   - Field: ‘packages’
[16:01:43.178]   - Field: ‘gc’
[16:01:43.178]   - Field: ‘conditions’
[16:01:43.178]   - Field: ‘persistent’
[16:01:43.178]   - Field: ‘expr’
[16:01:43.178]   - Field: ‘uuid’
[16:01:43.178]   - Field: ‘seed’
[16:01:43.179]   - Field: ‘version’
[16:01:43.179]   - Field: ‘result’
[16:01:43.179]   - Field: ‘asynchronous’
[16:01:43.179]   - Field: ‘calls’
[16:01:43.179]   - Field: ‘globals’
[16:01:43.179]   - Field: ‘stdout’
[16:01:43.179]   - Field: ‘earlySignal’
[16:01:43.179]   - Field: ‘lazy’
[16:01:43.179]   - Field: ‘state’
[16:01:43.179] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:43.180] - Launch lazy future ...
[16:01:43.180] Packages needed by the future expression (n = 1): ‘stats’
[16:01:43.180] Packages needed by future strategies (n = 0): <none>
[16:01:43.181] {
[16:01:43.181]     {
[16:01:43.181]         {
[16:01:43.181]             ...future.startTime <- base::Sys.time()
[16:01:43.181]             {
[16:01:43.181]                 {
[16:01:43.181]                   {
[16:01:43.181]                     {
[16:01:43.181]                       {
[16:01:43.181]                         base::local({
[16:01:43.181]                           has_future <- base::requireNamespace("future", 
[16:01:43.181]                             quietly = TRUE)
[16:01:43.181]                           if (has_future) {
[16:01:43.181]                             ns <- base::getNamespace("future")
[16:01:43.181]                             version <- ns[[".package"]][["version"]]
[16:01:43.181]                             if (is.null(version)) 
[16:01:43.181]                               version <- utils::packageVersion("future")
[16:01:43.181]                           }
[16:01:43.181]                           else {
[16:01:43.181]                             version <- NULL
[16:01:43.181]                           }
[16:01:43.181]                           if (!has_future || version < "1.8.0") {
[16:01:43.181]                             info <- base::c(r_version = base::gsub("R version ", 
[16:01:43.181]                               "", base::R.version$version.string), 
[16:01:43.181]                               platform = base::sprintf("%s (%s-bit)", 
[16:01:43.181]                                 base::R.version$platform, 8 * 
[16:01:43.181]                                   base::.Machine$sizeof.pointer), 
[16:01:43.181]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:43.181]                                 "release", "version")], collapse = " "), 
[16:01:43.181]                               hostname = base::Sys.info()[["nodename"]])
[16:01:43.181]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:01:43.181]                               info)
[16:01:43.181]                             info <- base::paste(info, collapse = "; ")
[16:01:43.181]                             if (!has_future) {
[16:01:43.181]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:43.181]                                 info)
[16:01:43.181]                             }
[16:01:43.181]                             else {
[16:01:43.181]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:43.181]                                 info, version)
[16:01:43.181]                             }
[16:01:43.181]                             base::stop(msg)
[16:01:43.181]                           }
[16:01:43.181]                         })
[16:01:43.181]                       }
[16:01:43.181]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:43.181]                       base::options(mc.cores = 1L)
[16:01:43.181]                     }
[16:01:43.181]                     base::local({
[16:01:43.181]                       for (pkg in "stats") {
[16:01:43.181]                         base::loadNamespace(pkg)
[16:01:43.181]                         base::library(pkg, character.only = TRUE)
[16:01:43.181]                       }
[16:01:43.181]                     })
[16:01:43.181]                   }
[16:01:43.181]                   options(future.plan = NULL)
[16:01:43.181]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:43.181]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:43.181]                 }
[16:01:43.181]                 ...future.workdir <- getwd()
[16:01:43.181]             }
[16:01:43.181]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:43.181]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:43.181]         }
[16:01:43.181]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:43.181]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:43.181]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:43.181]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:43.181]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:43.181]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:43.181]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:43.181]             base::names(...future.oldOptions))
[16:01:43.181]     }
[16:01:43.181]     if (FALSE) {
[16:01:43.181]     }
[16:01:43.181]     else {
[16:01:43.181]         if (TRUE) {
[16:01:43.181]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:43.181]                 open = "w")
[16:01:43.181]         }
[16:01:43.181]         else {
[16:01:43.181]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:43.181]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:43.181]         }
[16:01:43.181]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:43.181]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:43.181]             base::sink(type = "output", split = FALSE)
[16:01:43.181]             base::close(...future.stdout)
[16:01:43.181]         }, add = TRUE)
[16:01:43.181]     }
[16:01:43.181]     ...future.frame <- base::sys.nframe()
[16:01:43.181]     ...future.conditions <- base::list()
[16:01:43.181]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:43.181]     if (FALSE) {
[16:01:43.181]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:43.181]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:43.181]     }
[16:01:43.181]     ...future.result <- base::tryCatch({
[16:01:43.181]         base::withCallingHandlers({
[16:01:43.181]             ...future.value <- base::withVisible(base::local({
[16:01:43.181]                 ...future.makeSendCondition <- base::local({
[16:01:43.181]                   sendCondition <- NULL
[16:01:43.181]                   function(frame = 1L) {
[16:01:43.181]                     if (is.function(sendCondition)) 
[16:01:43.181]                       return(sendCondition)
[16:01:43.181]                     ns <- getNamespace("parallel")
[16:01:43.181]                     if (exists("sendData", mode = "function", 
[16:01:43.181]                       envir = ns)) {
[16:01:43.181]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:43.181]                         envir = ns)
[16:01:43.181]                       envir <- sys.frame(frame)
[16:01:43.181]                       master <- NULL
[16:01:43.181]                       while (!identical(envir, .GlobalEnv) && 
[16:01:43.181]                         !identical(envir, emptyenv())) {
[16:01:43.181]                         if (exists("master", mode = "list", envir = envir, 
[16:01:43.181]                           inherits = FALSE)) {
[16:01:43.181]                           master <- get("master", mode = "list", 
[16:01:43.181]                             envir = envir, inherits = FALSE)
[16:01:43.181]                           if (inherits(master, c("SOCKnode", 
[16:01:43.181]                             "SOCK0node"))) {
[16:01:43.181]                             sendCondition <<- function(cond) {
[16:01:43.181]                               data <- list(type = "VALUE", value = cond, 
[16:01:43.181]                                 success = TRUE)
[16:01:43.181]                               parallel_sendData(master, data)
[16:01:43.181]                             }
[16:01:43.181]                             return(sendCondition)
[16:01:43.181]                           }
[16:01:43.181]                         }
[16:01:43.181]                         frame <- frame + 1L
[16:01:43.181]                         envir <- sys.frame(frame)
[16:01:43.181]                       }
[16:01:43.181]                     }
[16:01:43.181]                     sendCondition <<- function(cond) NULL
[16:01:43.181]                   }
[16:01:43.181]                 })
[16:01:43.181]                 withCallingHandlers({
[16:01:43.181]                   {
[16:01:43.181]                     do.call(function(...) {
[16:01:43.181]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.181]                       if (!identical(...future.globals.maxSize.org, 
[16:01:43.181]                         ...future.globals.maxSize)) {
[16:01:43.181]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.181]                         on.exit(options(oopts), add = TRUE)
[16:01:43.181]                       }
[16:01:43.181]                       {
[16:01:43.181]                         lapply(seq_along(...future.elements_ii), 
[16:01:43.181]                           FUN = function(jj) {
[16:01:43.181]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.181]                             ...future.FUN(...future.X_jj, ...)
[16:01:43.181]                           })
[16:01:43.181]                       }
[16:01:43.181]                     }, args = future.call.arguments)
[16:01:43.181]                   }
[16:01:43.181]                 }, immediateCondition = function(cond) {
[16:01:43.181]                   sendCondition <- ...future.makeSendCondition()
[16:01:43.181]                   sendCondition(cond)
[16:01:43.181]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.181]                   {
[16:01:43.181]                     inherits <- base::inherits
[16:01:43.181]                     invokeRestart <- base::invokeRestart
[16:01:43.181]                     is.null <- base::is.null
[16:01:43.181]                     muffled <- FALSE
[16:01:43.181]                     if (inherits(cond, "message")) {
[16:01:43.181]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:43.181]                       if (muffled) 
[16:01:43.181]                         invokeRestart("muffleMessage")
[16:01:43.181]                     }
[16:01:43.181]                     else if (inherits(cond, "warning")) {
[16:01:43.181]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:43.181]                       if (muffled) 
[16:01:43.181]                         invokeRestart("muffleWarning")
[16:01:43.181]                     }
[16:01:43.181]                     else if (inherits(cond, "condition")) {
[16:01:43.181]                       if (!is.null(pattern)) {
[16:01:43.181]                         computeRestarts <- base::computeRestarts
[16:01:43.181]                         grepl <- base::grepl
[16:01:43.181]                         restarts <- computeRestarts(cond)
[16:01:43.181]                         for (restart in restarts) {
[16:01:43.181]                           name <- restart$name
[16:01:43.181]                           if (is.null(name)) 
[16:01:43.181]                             next
[16:01:43.181]                           if (!grepl(pattern, name)) 
[16:01:43.181]                             next
[16:01:43.181]                           invokeRestart(restart)
[16:01:43.181]                           muffled <- TRUE
[16:01:43.181]                           break
[16:01:43.181]                         }
[16:01:43.181]                       }
[16:01:43.181]                     }
[16:01:43.181]                     invisible(muffled)
[16:01:43.181]                   }
[16:01:43.181]                   muffleCondition(cond)
[16:01:43.181]                 })
[16:01:43.181]             }))
[16:01:43.181]             future::FutureResult(value = ...future.value$value, 
[16:01:43.181]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:43.181]                   ...future.rng), globalenv = if (FALSE) 
[16:01:43.181]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:43.181]                     ...future.globalenv.names))
[16:01:43.181]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:43.181]         }, condition = base::local({
[16:01:43.181]             c <- base::c
[16:01:43.181]             inherits <- base::inherits
[16:01:43.181]             invokeRestart <- base::invokeRestart
[16:01:43.181]             length <- base::length
[16:01:43.181]             list <- base::list
[16:01:43.181]             seq.int <- base::seq.int
[16:01:43.181]             signalCondition <- base::signalCondition
[16:01:43.181]             sys.calls <- base::sys.calls
[16:01:43.181]             `[[` <- base::`[[`
[16:01:43.181]             `+` <- base::`+`
[16:01:43.181]             `<<-` <- base::`<<-`
[16:01:43.181]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:43.181]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:43.181]                   3L)]
[16:01:43.181]             }
[16:01:43.181]             function(cond) {
[16:01:43.181]                 is_error <- inherits(cond, "error")
[16:01:43.181]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:43.181]                   NULL)
[16:01:43.181]                 if (is_error) {
[16:01:43.181]                   sessionInformation <- function() {
[16:01:43.181]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:43.181]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:43.181]                       search = base::search(), system = base::Sys.info())
[16:01:43.181]                   }
[16:01:43.181]                   ...future.conditions[[length(...future.conditions) + 
[16:01:43.181]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:43.181]                     cond$call), session = sessionInformation(), 
[16:01:43.181]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:43.181]                   signalCondition(cond)
[16:01:43.181]                 }
[16:01:43.181]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:43.181]                 "immediateCondition"))) {
[16:01:43.181]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:43.181]                   ...future.conditions[[length(...future.conditions) + 
[16:01:43.181]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:43.181]                   if (TRUE && !signal) {
[16:01:43.181]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.181]                     {
[16:01:43.181]                       inherits <- base::inherits
[16:01:43.181]                       invokeRestart <- base::invokeRestart
[16:01:43.181]                       is.null <- base::is.null
[16:01:43.181]                       muffled <- FALSE
[16:01:43.181]                       if (inherits(cond, "message")) {
[16:01:43.181]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:43.181]                         if (muffled) 
[16:01:43.181]                           invokeRestart("muffleMessage")
[16:01:43.181]                       }
[16:01:43.181]                       else if (inherits(cond, "warning")) {
[16:01:43.181]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:43.181]                         if (muffled) 
[16:01:43.181]                           invokeRestart("muffleWarning")
[16:01:43.181]                       }
[16:01:43.181]                       else if (inherits(cond, "condition")) {
[16:01:43.181]                         if (!is.null(pattern)) {
[16:01:43.181]                           computeRestarts <- base::computeRestarts
[16:01:43.181]                           grepl <- base::grepl
[16:01:43.181]                           restarts <- computeRestarts(cond)
[16:01:43.181]                           for (restart in restarts) {
[16:01:43.181]                             name <- restart$name
[16:01:43.181]                             if (is.null(name)) 
[16:01:43.181]                               next
[16:01:43.181]                             if (!grepl(pattern, name)) 
[16:01:43.181]                               next
[16:01:43.181]                             invokeRestart(restart)
[16:01:43.181]                             muffled <- TRUE
[16:01:43.181]                             break
[16:01:43.181]                           }
[16:01:43.181]                         }
[16:01:43.181]                       }
[16:01:43.181]                       invisible(muffled)
[16:01:43.181]                     }
[16:01:43.181]                     muffleCondition(cond, pattern = "^muffle")
[16:01:43.181]                   }
[16:01:43.181]                 }
[16:01:43.181]                 else {
[16:01:43.181]                   if (TRUE) {
[16:01:43.181]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.181]                     {
[16:01:43.181]                       inherits <- base::inherits
[16:01:43.181]                       invokeRestart <- base::invokeRestart
[16:01:43.181]                       is.null <- base::is.null
[16:01:43.181]                       muffled <- FALSE
[16:01:43.181]                       if (inherits(cond, "message")) {
[16:01:43.181]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:43.181]                         if (muffled) 
[16:01:43.181]                           invokeRestart("muffleMessage")
[16:01:43.181]                       }
[16:01:43.181]                       else if (inherits(cond, "warning")) {
[16:01:43.181]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:43.181]                         if (muffled) 
[16:01:43.181]                           invokeRestart("muffleWarning")
[16:01:43.181]                       }
[16:01:43.181]                       else if (inherits(cond, "condition")) {
[16:01:43.181]                         if (!is.null(pattern)) {
[16:01:43.181]                           computeRestarts <- base::computeRestarts
[16:01:43.181]                           grepl <- base::grepl
[16:01:43.181]                           restarts <- computeRestarts(cond)
[16:01:43.181]                           for (restart in restarts) {
[16:01:43.181]                             name <- restart$name
[16:01:43.181]                             if (is.null(name)) 
[16:01:43.181]                               next
[16:01:43.181]                             if (!grepl(pattern, name)) 
[16:01:43.181]                               next
[16:01:43.181]                             invokeRestart(restart)
[16:01:43.181]                             muffled <- TRUE
[16:01:43.181]                             break
[16:01:43.181]                           }
[16:01:43.181]                         }
[16:01:43.181]                       }
[16:01:43.181]                       invisible(muffled)
[16:01:43.181]                     }
[16:01:43.181]                     muffleCondition(cond, pattern = "^muffle")
[16:01:43.181]                   }
[16:01:43.181]                 }
[16:01:43.181]             }
[16:01:43.181]         }))
[16:01:43.181]     }, error = function(ex) {
[16:01:43.181]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:43.181]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:43.181]                 ...future.rng), started = ...future.startTime, 
[16:01:43.181]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:43.181]             version = "1.8"), class = "FutureResult")
[16:01:43.181]     }, finally = {
[16:01:43.181]         if (!identical(...future.workdir, getwd())) 
[16:01:43.181]             setwd(...future.workdir)
[16:01:43.181]         {
[16:01:43.181]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:43.181]                 ...future.oldOptions$nwarnings <- NULL
[16:01:43.181]             }
[16:01:43.181]             base::options(...future.oldOptions)
[16:01:43.181]             if (.Platform$OS.type == "windows") {
[16:01:43.181]                 old_names <- names(...future.oldEnvVars)
[16:01:43.181]                 envs <- base::Sys.getenv()
[16:01:43.181]                 names <- names(envs)
[16:01:43.181]                 common <- intersect(names, old_names)
[16:01:43.181]                 added <- setdiff(names, old_names)
[16:01:43.181]                 removed <- setdiff(old_names, names)
[16:01:43.181]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:43.181]                   envs[common]]
[16:01:43.181]                 NAMES <- toupper(changed)
[16:01:43.181]                 args <- list()
[16:01:43.181]                 for (kk in seq_along(NAMES)) {
[16:01:43.181]                   name <- changed[[kk]]
[16:01:43.181]                   NAME <- NAMES[[kk]]
[16:01:43.181]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.181]                     next
[16:01:43.181]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:43.181]                 }
[16:01:43.181]                 NAMES <- toupper(added)
[16:01:43.181]                 for (kk in seq_along(NAMES)) {
[16:01:43.181]                   name <- added[[kk]]
[16:01:43.181]                   NAME <- NAMES[[kk]]
[16:01:43.181]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.181]                     next
[16:01:43.181]                   args[[name]] <- ""
[16:01:43.181]                 }
[16:01:43.181]                 NAMES <- toupper(removed)
[16:01:43.181]                 for (kk in seq_along(NAMES)) {
[16:01:43.181]                   name <- removed[[kk]]
[16:01:43.181]                   NAME <- NAMES[[kk]]
[16:01:43.181]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.181]                     next
[16:01:43.181]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:43.181]                 }
[16:01:43.181]                 if (length(args) > 0) 
[16:01:43.181]                   base::do.call(base::Sys.setenv, args = args)
[16:01:43.181]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:43.181]             }
[16:01:43.181]             else {
[16:01:43.181]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:43.181]             }
[16:01:43.181]             {
[16:01:43.181]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:43.181]                   0L) {
[16:01:43.181]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:43.181]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:43.181]                   base::options(opts)
[16:01:43.181]                 }
[16:01:43.181]                 {
[16:01:43.181]                   {
[16:01:43.181]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:43.181]                     NULL
[16:01:43.181]                   }
[16:01:43.181]                   options(future.plan = NULL)
[16:01:43.181]                   if (is.na(NA_character_)) 
[16:01:43.181]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:43.181]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:43.181]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:43.181]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:43.181]                     envir = parent.frame()) 
[16:01:43.181]                   {
[16:01:43.181]                     if (is.function(workers)) 
[16:01:43.181]                       workers <- workers()
[16:01:43.181]                     workers <- structure(as.integer(workers), 
[16:01:43.181]                       class = class(workers))
[16:01:43.181]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:43.181]                       workers >= 1)
[16:01:43.181]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:43.181]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:43.181]                     }
[16:01:43.181]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:43.181]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:43.181]                       envir = envir)
[16:01:43.181]                     if (!future$lazy) 
[16:01:43.181]                       future <- run(future)
[16:01:43.181]                     invisible(future)
[16:01:43.181]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:43.181]                 }
[16:01:43.181]             }
[16:01:43.181]         }
[16:01:43.181]     })
[16:01:43.181]     if (TRUE) {
[16:01:43.181]         base::sink(type = "output", split = FALSE)
[16:01:43.181]         if (TRUE) {
[16:01:43.181]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:43.181]         }
[16:01:43.181]         else {
[16:01:43.181]             ...future.result["stdout"] <- base::list(NULL)
[16:01:43.181]         }
[16:01:43.181]         base::close(...future.stdout)
[16:01:43.181]         ...future.stdout <- NULL
[16:01:43.181]     }
[16:01:43.181]     ...future.result$conditions <- ...future.conditions
[16:01:43.181]     ...future.result$finished <- base::Sys.time()
[16:01:43.181]     ...future.result
[16:01:43.181] }
[16:01:43.184] Exporting 5 global objects (1.35 KiB) to cluster node #2 ...
[16:01:43.184] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:01:43.184] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:01:43.185] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[16:01:43.185] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[16:01:43.185] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[16:01:43.185] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[16:01:43.185] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:01:43.186] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:01:43.186] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[16:01:43.186] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[16:01:43.186] Exporting 5 global objects (1.35 KiB) to cluster node #2 ... DONE
[16:01:43.187] MultisessionFuture started
[16:01:43.187] - Launch lazy future ... done
[16:01:43.187] run() for ‘MultisessionFuture’ ... done
[16:01:43.187] Created future:
[16:01:43.187] MultisessionFuture:
[16:01:43.187] Label: ‘future_apply-2’
[16:01:43.187] Expression:
[16:01:43.187] {
[16:01:43.187]     do.call(function(...) {
[16:01:43.187]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.187]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:43.187]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.187]             on.exit(options(oopts), add = TRUE)
[16:01:43.187]         }
[16:01:43.187]         {
[16:01:43.187]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:43.187]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.187]                 ...future.FUN(...future.X_jj, ...)
[16:01:43.187]             })
[16:01:43.187]         }
[16:01:43.187]     }, args = future.call.arguments)
[16:01:43.187] }
[16:01:43.187] Lazy evaluation: FALSE
[16:01:43.187] Asynchronous evaluation: TRUE
[16:01:43.187] Local evaluation: TRUE
[16:01:43.187] Environment: R_GlobalEnv
[16:01:43.187] Capture standard output: TRUE
[16:01:43.187] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:43.187] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:43.187] Packages: 1 packages (‘stats’)
[16:01:43.187] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:43.187] Resolved: FALSE
[16:01:43.187] Value: <not collected>
[16:01:43.187] Conditions captured: <none>
[16:01:43.187] Early signaling: FALSE
[16:01:43.187] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:43.187] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:43.199] Chunk #2 of 2 ... DONE
[16:01:43.199] Launching 2 futures (chunks) ... DONE
[16:01:43.199] Resolving 2 futures (chunks) ...
[16:01:43.200] resolve() on list ...
[16:01:43.200]  recursive: 0
[16:01:43.200]  length: 2
[16:01:43.200] 
[16:01:43.200] receiveMessageFromWorker() for ClusterFuture ...
[16:01:43.200] - Validating connection of MultisessionFuture
[16:01:43.201] - received message: FutureResult
[16:01:43.201] - Received FutureResult
[16:01:43.201] - Erased future from FutureRegistry
[16:01:43.201] result() for ClusterFuture ...
[16:01:43.201] - result already collected: FutureResult
[16:01:43.201] result() for ClusterFuture ... done
[16:01:43.201] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:43.201] Future #1
[16:01:43.201] result() for ClusterFuture ...
[16:01:43.202] - result already collected: FutureResult
[16:01:43.202] result() for ClusterFuture ... done
[16:01:43.202] result() for ClusterFuture ...
[16:01:43.202] - result already collected: FutureResult
[16:01:43.202] result() for ClusterFuture ... done
[16:01:43.202] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:01:43.202] - nx: 2
[16:01:43.202] - relay: TRUE
[16:01:43.202] - stdout: TRUE
[16:01:43.202] - signal: TRUE
[16:01:43.202] - resignal: FALSE
[16:01:43.203] - force: TRUE
[16:01:43.203] - relayed: [n=2] FALSE, FALSE
[16:01:43.203] - queued futures: [n=2] FALSE, FALSE
[16:01:43.203]  - until=1
[16:01:43.203]  - relaying element #1
[16:01:43.203] result() for ClusterFuture ...
[16:01:43.203] - result already collected: FutureResult
[16:01:43.203] result() for ClusterFuture ... done
[16:01:43.203] result() for ClusterFuture ...
[16:01:43.203] - result already collected: FutureResult
[16:01:43.203] result() for ClusterFuture ... done
[16:01:43.204] result() for ClusterFuture ...
[16:01:43.204] - result already collected: FutureResult
[16:01:43.204] result() for ClusterFuture ... done
[16:01:43.204] result() for ClusterFuture ...
[16:01:43.204] - result already collected: FutureResult
[16:01:43.204] result() for ClusterFuture ... done
[16:01:43.204] - relayed: [n=2] TRUE, FALSE
[16:01:43.204] - queued futures: [n=2] TRUE, FALSE
[16:01:43.204] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:01:43.204]  length: 1 (resolved future 1)
[16:01:43.234] receiveMessageFromWorker() for ClusterFuture ...
[16:01:43.235] - Validating connection of MultisessionFuture
[16:01:43.235] - received message: FutureResult
[16:01:43.235] - Received FutureResult
[16:01:43.235] - Erased future from FutureRegistry
[16:01:43.235] result() for ClusterFuture ...
[16:01:43.235] - result already collected: FutureResult
[16:01:43.236] result() for ClusterFuture ... done
[16:01:43.236] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:43.236] Future #2
[16:01:43.236] result() for ClusterFuture ...
[16:01:43.236] - result already collected: FutureResult
[16:01:43.236] result() for ClusterFuture ... done
[16:01:43.236] result() for ClusterFuture ...
[16:01:43.236] - result already collected: FutureResult
[16:01:43.236] result() for ClusterFuture ... done
[16:01:43.236] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:01:43.236] - nx: 2
[16:01:43.237] - relay: TRUE
[16:01:43.237] - stdout: TRUE
[16:01:43.237] - signal: TRUE
[16:01:43.237] - resignal: FALSE
[16:01:43.237] - force: TRUE
[16:01:43.237] - relayed: [n=2] TRUE, FALSE
[16:01:43.237] - queued futures: [n=2] TRUE, FALSE
[16:01:43.237]  - until=2
[16:01:43.237]  - relaying element #2
[16:01:43.237] result() for ClusterFuture ...
[16:01:43.237] - result already collected: FutureResult
[16:01:43.237] result() for ClusterFuture ... done
[16:01:43.238] result() for ClusterFuture ...
[16:01:43.238] - result already collected: FutureResult
[16:01:43.238] result() for ClusterFuture ... done
[16:01:43.238] result() for ClusterFuture ...
[16:01:43.238] - result already collected: FutureResult
[16:01:43.238] result() for ClusterFuture ... done
[16:01:43.238] result() for ClusterFuture ...
[16:01:43.238] - result already collected: FutureResult
[16:01:43.238] result() for ClusterFuture ... done
[16:01:43.238] - relayed: [n=2] TRUE, TRUE
[16:01:43.238] - queued futures: [n=2] TRUE, TRUE
[16:01:43.239] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:01:43.239]  length: 0 (resolved future 2)
[16:01:43.239] Relaying remaining futures
[16:01:43.239] signalConditionsASAP(NULL, pos=0) ...
[16:01:43.239] - nx: 2
[16:01:43.239] - relay: TRUE
[16:01:43.239] - stdout: TRUE
[16:01:43.239] - signal: TRUE
[16:01:43.239] - resignal: FALSE
[16:01:43.239] - force: TRUE
[16:01:43.239] - relayed: [n=2] TRUE, TRUE
[16:01:43.240] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:43.240] - relayed: [n=2] TRUE, TRUE
[16:01:43.240] - queued futures: [n=2] TRUE, TRUE
[16:01:43.240] signalConditionsASAP(NULL, pos=0) ... done
[16:01:43.240] resolve() on list ... DONE
[16:01:43.240] result() for ClusterFuture ...
[16:01:43.240] - result already collected: FutureResult
[16:01:43.240] result() for ClusterFuture ... done
[16:01:43.240] result() for ClusterFuture ...
[16:01:43.240] - result already collected: FutureResult
[16:01:43.240] result() for ClusterFuture ... done
[16:01:43.241] result() for ClusterFuture ...
[16:01:43.241] - result already collected: FutureResult
[16:01:43.241] result() for ClusterFuture ... done
[16:01:43.241] result() for ClusterFuture ...
[16:01:43.241] - result already collected: FutureResult
[16:01:43.241] result() for ClusterFuture ... done
[16:01:43.241]  - Number of value chunks collected: 2
[16:01:43.241] Resolving 2 futures (chunks) ... DONE
[16:01:43.241] Reducing values from 2 chunks ...
[16:01:43.241]  - Number of values collected after concatenation: 2
[16:01:43.241]  - Number of values expected: 2
[16:01:43.242] Reducing values from 2 chunks ... DONE
[16:01:43.242] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[16:01:43.242] getGlobalsAndPackagesXApply() ...
[16:01:43.242]  - future.globals: TRUE
[16:01:43.242] getGlobalsAndPackages() ...
[16:01:43.242] Searching for globals...
[16:01:43.244] - globals found: [1] ‘FUN’
[16:01:43.244] Searching for globals ... DONE
[16:01:43.244] Resolving globals: FALSE
[16:01:43.244] The total size of the 1 globals is 848 bytes (848 bytes)
[16:01:43.245] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:01:43.245] - globals: [1] ‘FUN’
[16:01:43.245] 
[16:01:43.245] getGlobalsAndPackages() ... DONE
[16:01:43.245]  - globals found/used: [n=1] ‘FUN’
[16:01:43.245]  - needed namespaces: [n=0] 
[16:01:43.245] Finding globals ... DONE
[16:01:43.245]  - use_args: TRUE
[16:01:43.245]  - Getting '...' globals ...
[16:01:43.246] resolve() on list ...
[16:01:43.246]  recursive: 0
[16:01:43.246]  length: 1
[16:01:43.246]  elements: ‘...’
[16:01:43.246]  length: 0 (resolved future 1)
[16:01:43.246] resolve() on list ... DONE
[16:01:43.246]    - '...' content: [n=0] 
[16:01:43.246] List of 1
[16:01:43.246]  $ ...: list()
[16:01:43.246]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:43.246]  - attr(*, "where")=List of 1
[16:01:43.246]   ..$ ...:<environment: 0x55fb665c1df0> 
[16:01:43.246]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:43.246]  - attr(*, "resolved")= logi TRUE
[16:01:43.246]  - attr(*, "total_size")= num NA
[16:01:43.249]  - Getting '...' globals ... DONE
[16:01:43.249] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:43.249] List of 2
[16:01:43.249]  $ ...future.FUN:function (x)  
[16:01:43.249]  $ ...          : list()
[16:01:43.249]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:43.249]  - attr(*, "where")=List of 2
[16:01:43.249]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:43.249]   ..$ ...          :<environment: 0x55fb665c1df0> 
[16:01:43.249]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:43.249]  - attr(*, "resolved")= logi FALSE
[16:01:43.249]  - attr(*, "total_size")= num 848
[16:01:43.252] Packages to be attached in all futures: [n=0] 
[16:01:43.254] getGlobalsAndPackagesXApply() ... DONE
[16:01:43.258] future_lapply() ...
[16:01:43.261] Number of chunks: 2
[16:01:43.261] getGlobalsAndPackagesXApply() ...
[16:01:43.262]  - future.globals: <name-value list> with names ‘list()’
[16:01:43.262]  - use_args: TRUE
[16:01:43.262] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:01:43.262] List of 2
[16:01:43.262]  $ ...          : list()
[16:01:43.262]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:43.262]  $ ...future.FUN:function (x)  
[16:01:43.262]  - attr(*, "where")=List of 2
[16:01:43.262]   ..$ ...          :<environment: 0x55fb665c1df0> 
[16:01:43.262]   ..$ ...future.FUN:<environment: namespace:base> 
[16:01:43.262]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:43.262]  - attr(*, "resolved")= logi FALSE
[16:01:43.262]  - attr(*, "total_size")= num NA
[16:01:43.265] Packages to be attached in all futures: [n=0] 
[16:01:43.266] getGlobalsAndPackagesXApply() ... DONE
[16:01:43.266] Number of futures (= number of chunks): 2
[16:01:43.266] Launching 2 futures (chunks) ...
[16:01:43.266] Chunk #1 of 2 ...
[16:01:43.266]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:43.266]  - seeds: <none>
[16:01:43.266]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.266] getGlobalsAndPackages() ...
[16:01:43.266] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.267] Resolving globals: FALSE
[16:01:43.267] Tweak future expression to call with '...' arguments ...
[16:01:43.267] {
[16:01:43.267]     do.call(function(...) {
[16:01:43.267]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.267]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:43.267]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.267]             on.exit(options(oopts), add = TRUE)
[16:01:43.267]         }
[16:01:43.267]         {
[16:01:43.267]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:43.267]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.267]                 ...future.FUN(...future.X_jj, ...)
[16:01:43.267]             })
[16:01:43.267]         }
[16:01:43.267]     }, args = future.call.arguments)
[16:01:43.267] }
[16:01:43.267] Tweak future expression to call with '...' arguments ... DONE
[16:01:43.267] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.268] 
[16:01:43.268] getGlobalsAndPackages() ... DONE
[16:01:43.268] run() for ‘Future’ ...
[16:01:43.268] - state: ‘created’
[16:01:43.268] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:43.282] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:43.282] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:43.283]   - Field: ‘node’
[16:01:43.283]   - Field: ‘label’
[16:01:43.283]   - Field: ‘local’
[16:01:43.283]   - Field: ‘owner’
[16:01:43.283]   - Field: ‘envir’
[16:01:43.283]   - Field: ‘workers’
[16:01:43.283]   - Field: ‘packages’
[16:01:43.283]   - Field: ‘gc’
[16:01:43.283]   - Field: ‘conditions’
[16:01:43.284]   - Field: ‘persistent’
[16:01:43.284]   - Field: ‘expr’
[16:01:43.284]   - Field: ‘uuid’
[16:01:43.284]   - Field: ‘seed’
[16:01:43.284]   - Field: ‘version’
[16:01:43.284]   - Field: ‘result’
[16:01:43.284]   - Field: ‘asynchronous’
[16:01:43.284]   - Field: ‘calls’
[16:01:43.284]   - Field: ‘globals’
[16:01:43.284]   - Field: ‘stdout’
[16:01:43.284]   - Field: ‘earlySignal’
[16:01:43.285]   - Field: ‘lazy’
[16:01:43.285]   - Field: ‘state’
[16:01:43.285] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:43.285] - Launch lazy future ...
[16:01:43.285] Packages needed by the future expression (n = 0): <none>
[16:01:43.285] Packages needed by future strategies (n = 0): <none>
[16:01:43.286] {
[16:01:43.286]     {
[16:01:43.286]         {
[16:01:43.286]             ...future.startTime <- base::Sys.time()
[16:01:43.286]             {
[16:01:43.286]                 {
[16:01:43.286]                   {
[16:01:43.286]                     {
[16:01:43.286]                       base::local({
[16:01:43.286]                         has_future <- base::requireNamespace("future", 
[16:01:43.286]                           quietly = TRUE)
[16:01:43.286]                         if (has_future) {
[16:01:43.286]                           ns <- base::getNamespace("future")
[16:01:43.286]                           version <- ns[[".package"]][["version"]]
[16:01:43.286]                           if (is.null(version)) 
[16:01:43.286]                             version <- utils::packageVersion("future")
[16:01:43.286]                         }
[16:01:43.286]                         else {
[16:01:43.286]                           version <- NULL
[16:01:43.286]                         }
[16:01:43.286]                         if (!has_future || version < "1.8.0") {
[16:01:43.286]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:43.286]                             "", base::R.version$version.string), 
[16:01:43.286]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:43.286]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:43.286]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:43.286]                               "release", "version")], collapse = " "), 
[16:01:43.286]                             hostname = base::Sys.info()[["nodename"]])
[16:01:43.286]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:43.286]                             info)
[16:01:43.286]                           info <- base::paste(info, collapse = "; ")
[16:01:43.286]                           if (!has_future) {
[16:01:43.286]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:43.286]                               info)
[16:01:43.286]                           }
[16:01:43.286]                           else {
[16:01:43.286]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:43.286]                               info, version)
[16:01:43.286]                           }
[16:01:43.286]                           base::stop(msg)
[16:01:43.286]                         }
[16:01:43.286]                       })
[16:01:43.286]                     }
[16:01:43.286]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:43.286]                     base::options(mc.cores = 1L)
[16:01:43.286]                   }
[16:01:43.286]                   options(future.plan = NULL)
[16:01:43.286]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:43.286]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:43.286]                 }
[16:01:43.286]                 ...future.workdir <- getwd()
[16:01:43.286]             }
[16:01:43.286]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:43.286]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:43.286]         }
[16:01:43.286]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:43.286]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:43.286]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:43.286]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:43.286]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:43.286]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:43.286]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:43.286]             base::names(...future.oldOptions))
[16:01:43.286]     }
[16:01:43.286]     if (FALSE) {
[16:01:43.286]     }
[16:01:43.286]     else {
[16:01:43.286]         if (TRUE) {
[16:01:43.286]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:43.286]                 open = "w")
[16:01:43.286]         }
[16:01:43.286]         else {
[16:01:43.286]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:43.286]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:43.286]         }
[16:01:43.286]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:43.286]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:43.286]             base::sink(type = "output", split = FALSE)
[16:01:43.286]             base::close(...future.stdout)
[16:01:43.286]         }, add = TRUE)
[16:01:43.286]     }
[16:01:43.286]     ...future.frame <- base::sys.nframe()
[16:01:43.286]     ...future.conditions <- base::list()
[16:01:43.286]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:43.286]     if (FALSE) {
[16:01:43.286]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:43.286]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:43.286]     }
[16:01:43.286]     ...future.result <- base::tryCatch({
[16:01:43.286]         base::withCallingHandlers({
[16:01:43.286]             ...future.value <- base::withVisible(base::local({
[16:01:43.286]                 ...future.makeSendCondition <- base::local({
[16:01:43.286]                   sendCondition <- NULL
[16:01:43.286]                   function(frame = 1L) {
[16:01:43.286]                     if (is.function(sendCondition)) 
[16:01:43.286]                       return(sendCondition)
[16:01:43.286]                     ns <- getNamespace("parallel")
[16:01:43.286]                     if (exists("sendData", mode = "function", 
[16:01:43.286]                       envir = ns)) {
[16:01:43.286]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:43.286]                         envir = ns)
[16:01:43.286]                       envir <- sys.frame(frame)
[16:01:43.286]                       master <- NULL
[16:01:43.286]                       while (!identical(envir, .GlobalEnv) && 
[16:01:43.286]                         !identical(envir, emptyenv())) {
[16:01:43.286]                         if (exists("master", mode = "list", envir = envir, 
[16:01:43.286]                           inherits = FALSE)) {
[16:01:43.286]                           master <- get("master", mode = "list", 
[16:01:43.286]                             envir = envir, inherits = FALSE)
[16:01:43.286]                           if (inherits(master, c("SOCKnode", 
[16:01:43.286]                             "SOCK0node"))) {
[16:01:43.286]                             sendCondition <<- function(cond) {
[16:01:43.286]                               data <- list(type = "VALUE", value = cond, 
[16:01:43.286]                                 success = TRUE)
[16:01:43.286]                               parallel_sendData(master, data)
[16:01:43.286]                             }
[16:01:43.286]                             return(sendCondition)
[16:01:43.286]                           }
[16:01:43.286]                         }
[16:01:43.286]                         frame <- frame + 1L
[16:01:43.286]                         envir <- sys.frame(frame)
[16:01:43.286]                       }
[16:01:43.286]                     }
[16:01:43.286]                     sendCondition <<- function(cond) NULL
[16:01:43.286]                   }
[16:01:43.286]                 })
[16:01:43.286]                 withCallingHandlers({
[16:01:43.286]                   {
[16:01:43.286]                     do.call(function(...) {
[16:01:43.286]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.286]                       if (!identical(...future.globals.maxSize.org, 
[16:01:43.286]                         ...future.globals.maxSize)) {
[16:01:43.286]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.286]                         on.exit(options(oopts), add = TRUE)
[16:01:43.286]                       }
[16:01:43.286]                       {
[16:01:43.286]                         lapply(seq_along(...future.elements_ii), 
[16:01:43.286]                           FUN = function(jj) {
[16:01:43.286]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.286]                             ...future.FUN(...future.X_jj, ...)
[16:01:43.286]                           })
[16:01:43.286]                       }
[16:01:43.286]                     }, args = future.call.arguments)
[16:01:43.286]                   }
[16:01:43.286]                 }, immediateCondition = function(cond) {
[16:01:43.286]                   sendCondition <- ...future.makeSendCondition()
[16:01:43.286]                   sendCondition(cond)
[16:01:43.286]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.286]                   {
[16:01:43.286]                     inherits <- base::inherits
[16:01:43.286]                     invokeRestart <- base::invokeRestart
[16:01:43.286]                     is.null <- base::is.null
[16:01:43.286]                     muffled <- FALSE
[16:01:43.286]                     if (inherits(cond, "message")) {
[16:01:43.286]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:43.286]                       if (muffled) 
[16:01:43.286]                         invokeRestart("muffleMessage")
[16:01:43.286]                     }
[16:01:43.286]                     else if (inherits(cond, "warning")) {
[16:01:43.286]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:43.286]                       if (muffled) 
[16:01:43.286]                         invokeRestart("muffleWarning")
[16:01:43.286]                     }
[16:01:43.286]                     else if (inherits(cond, "condition")) {
[16:01:43.286]                       if (!is.null(pattern)) {
[16:01:43.286]                         computeRestarts <- base::computeRestarts
[16:01:43.286]                         grepl <- base::grepl
[16:01:43.286]                         restarts <- computeRestarts(cond)
[16:01:43.286]                         for (restart in restarts) {
[16:01:43.286]                           name <- restart$name
[16:01:43.286]                           if (is.null(name)) 
[16:01:43.286]                             next
[16:01:43.286]                           if (!grepl(pattern, name)) 
[16:01:43.286]                             next
[16:01:43.286]                           invokeRestart(restart)
[16:01:43.286]                           muffled <- TRUE
[16:01:43.286]                           break
[16:01:43.286]                         }
[16:01:43.286]                       }
[16:01:43.286]                     }
[16:01:43.286]                     invisible(muffled)
[16:01:43.286]                   }
[16:01:43.286]                   muffleCondition(cond)
[16:01:43.286]                 })
[16:01:43.286]             }))
[16:01:43.286]             future::FutureResult(value = ...future.value$value, 
[16:01:43.286]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:43.286]                   ...future.rng), globalenv = if (FALSE) 
[16:01:43.286]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:43.286]                     ...future.globalenv.names))
[16:01:43.286]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:43.286]         }, condition = base::local({
[16:01:43.286]             c <- base::c
[16:01:43.286]             inherits <- base::inherits
[16:01:43.286]             invokeRestart <- base::invokeRestart
[16:01:43.286]             length <- base::length
[16:01:43.286]             list <- base::list
[16:01:43.286]             seq.int <- base::seq.int
[16:01:43.286]             signalCondition <- base::signalCondition
[16:01:43.286]             sys.calls <- base::sys.calls
[16:01:43.286]             `[[` <- base::`[[`
[16:01:43.286]             `+` <- base::`+`
[16:01:43.286]             `<<-` <- base::`<<-`
[16:01:43.286]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:43.286]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:43.286]                   3L)]
[16:01:43.286]             }
[16:01:43.286]             function(cond) {
[16:01:43.286]                 is_error <- inherits(cond, "error")
[16:01:43.286]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:43.286]                   NULL)
[16:01:43.286]                 if (is_error) {
[16:01:43.286]                   sessionInformation <- function() {
[16:01:43.286]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:43.286]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:43.286]                       search = base::search(), system = base::Sys.info())
[16:01:43.286]                   }
[16:01:43.286]                   ...future.conditions[[length(...future.conditions) + 
[16:01:43.286]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:43.286]                     cond$call), session = sessionInformation(), 
[16:01:43.286]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:43.286]                   signalCondition(cond)
[16:01:43.286]                 }
[16:01:43.286]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:43.286]                 "immediateCondition"))) {
[16:01:43.286]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:43.286]                   ...future.conditions[[length(...future.conditions) + 
[16:01:43.286]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:43.286]                   if (TRUE && !signal) {
[16:01:43.286]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.286]                     {
[16:01:43.286]                       inherits <- base::inherits
[16:01:43.286]                       invokeRestart <- base::invokeRestart
[16:01:43.286]                       is.null <- base::is.null
[16:01:43.286]                       muffled <- FALSE
[16:01:43.286]                       if (inherits(cond, "message")) {
[16:01:43.286]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:43.286]                         if (muffled) 
[16:01:43.286]                           invokeRestart("muffleMessage")
[16:01:43.286]                       }
[16:01:43.286]                       else if (inherits(cond, "warning")) {
[16:01:43.286]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:43.286]                         if (muffled) 
[16:01:43.286]                           invokeRestart("muffleWarning")
[16:01:43.286]                       }
[16:01:43.286]                       else if (inherits(cond, "condition")) {
[16:01:43.286]                         if (!is.null(pattern)) {
[16:01:43.286]                           computeRestarts <- base::computeRestarts
[16:01:43.286]                           grepl <- base::grepl
[16:01:43.286]                           restarts <- computeRestarts(cond)
[16:01:43.286]                           for (restart in restarts) {
[16:01:43.286]                             name <- restart$name
[16:01:43.286]                             if (is.null(name)) 
[16:01:43.286]                               next
[16:01:43.286]                             if (!grepl(pattern, name)) 
[16:01:43.286]                               next
[16:01:43.286]                             invokeRestart(restart)
[16:01:43.286]                             muffled <- TRUE
[16:01:43.286]                             break
[16:01:43.286]                           }
[16:01:43.286]                         }
[16:01:43.286]                       }
[16:01:43.286]                       invisible(muffled)
[16:01:43.286]                     }
[16:01:43.286]                     muffleCondition(cond, pattern = "^muffle")
[16:01:43.286]                   }
[16:01:43.286]                 }
[16:01:43.286]                 else {
[16:01:43.286]                   if (TRUE) {
[16:01:43.286]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.286]                     {
[16:01:43.286]                       inherits <- base::inherits
[16:01:43.286]                       invokeRestart <- base::invokeRestart
[16:01:43.286]                       is.null <- base::is.null
[16:01:43.286]                       muffled <- FALSE
[16:01:43.286]                       if (inherits(cond, "message")) {
[16:01:43.286]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:43.286]                         if (muffled) 
[16:01:43.286]                           invokeRestart("muffleMessage")
[16:01:43.286]                       }
[16:01:43.286]                       else if (inherits(cond, "warning")) {
[16:01:43.286]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:43.286]                         if (muffled) 
[16:01:43.286]                           invokeRestart("muffleWarning")
[16:01:43.286]                       }
[16:01:43.286]                       else if (inherits(cond, "condition")) {
[16:01:43.286]                         if (!is.null(pattern)) {
[16:01:43.286]                           computeRestarts <- base::computeRestarts
[16:01:43.286]                           grepl <- base::grepl
[16:01:43.286]                           restarts <- computeRestarts(cond)
[16:01:43.286]                           for (restart in restarts) {
[16:01:43.286]                             name <- restart$name
[16:01:43.286]                             if (is.null(name)) 
[16:01:43.286]                               next
[16:01:43.286]                             if (!grepl(pattern, name)) 
[16:01:43.286]                               next
[16:01:43.286]                             invokeRestart(restart)
[16:01:43.286]                             muffled <- TRUE
[16:01:43.286]                             break
[16:01:43.286]                           }
[16:01:43.286]                         }
[16:01:43.286]                       }
[16:01:43.286]                       invisible(muffled)
[16:01:43.286]                     }
[16:01:43.286]                     muffleCondition(cond, pattern = "^muffle")
[16:01:43.286]                   }
[16:01:43.286]                 }
[16:01:43.286]             }
[16:01:43.286]         }))
[16:01:43.286]     }, error = function(ex) {
[16:01:43.286]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:43.286]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:43.286]                 ...future.rng), started = ...future.startTime, 
[16:01:43.286]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:43.286]             version = "1.8"), class = "FutureResult")
[16:01:43.286]     }, finally = {
[16:01:43.286]         if (!identical(...future.workdir, getwd())) 
[16:01:43.286]             setwd(...future.workdir)
[16:01:43.286]         {
[16:01:43.286]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:43.286]                 ...future.oldOptions$nwarnings <- NULL
[16:01:43.286]             }
[16:01:43.286]             base::options(...future.oldOptions)
[16:01:43.286]             if (.Platform$OS.type == "windows") {
[16:01:43.286]                 old_names <- names(...future.oldEnvVars)
[16:01:43.286]                 envs <- base::Sys.getenv()
[16:01:43.286]                 names <- names(envs)
[16:01:43.286]                 common <- intersect(names, old_names)
[16:01:43.286]                 added <- setdiff(names, old_names)
[16:01:43.286]                 removed <- setdiff(old_names, names)
[16:01:43.286]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:43.286]                   envs[common]]
[16:01:43.286]                 NAMES <- toupper(changed)
[16:01:43.286]                 args <- list()
[16:01:43.286]                 for (kk in seq_along(NAMES)) {
[16:01:43.286]                   name <- changed[[kk]]
[16:01:43.286]                   NAME <- NAMES[[kk]]
[16:01:43.286]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.286]                     next
[16:01:43.286]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:43.286]                 }
[16:01:43.286]                 NAMES <- toupper(added)
[16:01:43.286]                 for (kk in seq_along(NAMES)) {
[16:01:43.286]                   name <- added[[kk]]
[16:01:43.286]                   NAME <- NAMES[[kk]]
[16:01:43.286]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.286]                     next
[16:01:43.286]                   args[[name]] <- ""
[16:01:43.286]                 }
[16:01:43.286]                 NAMES <- toupper(removed)
[16:01:43.286]                 for (kk in seq_along(NAMES)) {
[16:01:43.286]                   name <- removed[[kk]]
[16:01:43.286]                   NAME <- NAMES[[kk]]
[16:01:43.286]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.286]                     next
[16:01:43.286]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:43.286]                 }
[16:01:43.286]                 if (length(args) > 0) 
[16:01:43.286]                   base::do.call(base::Sys.setenv, args = args)
[16:01:43.286]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:43.286]             }
[16:01:43.286]             else {
[16:01:43.286]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:43.286]             }
[16:01:43.286]             {
[16:01:43.286]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:43.286]                   0L) {
[16:01:43.286]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:43.286]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:43.286]                   base::options(opts)
[16:01:43.286]                 }
[16:01:43.286]                 {
[16:01:43.286]                   {
[16:01:43.286]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:43.286]                     NULL
[16:01:43.286]                   }
[16:01:43.286]                   options(future.plan = NULL)
[16:01:43.286]                   if (is.na(NA_character_)) 
[16:01:43.286]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:43.286]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:43.286]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:43.286]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:43.286]                     envir = parent.frame()) 
[16:01:43.286]                   {
[16:01:43.286]                     if (is.function(workers)) 
[16:01:43.286]                       workers <- workers()
[16:01:43.286]                     workers <- structure(as.integer(workers), 
[16:01:43.286]                       class = class(workers))
[16:01:43.286]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:43.286]                       workers >= 1)
[16:01:43.286]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:43.286]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:43.286]                     }
[16:01:43.286]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:43.286]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:43.286]                       envir = envir)
[16:01:43.286]                     if (!future$lazy) 
[16:01:43.286]                       future <- run(future)
[16:01:43.286]                     invisible(future)
[16:01:43.286]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:43.286]                 }
[16:01:43.286]             }
[16:01:43.286]         }
[16:01:43.286]     })
[16:01:43.286]     if (TRUE) {
[16:01:43.286]         base::sink(type = "output", split = FALSE)
[16:01:43.286]         if (TRUE) {
[16:01:43.286]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:43.286]         }
[16:01:43.286]         else {
[16:01:43.286]             ...future.result["stdout"] <- base::list(NULL)
[16:01:43.286]         }
[16:01:43.286]         base::close(...future.stdout)
[16:01:43.286]         ...future.stdout <- NULL
[16:01:43.286]     }
[16:01:43.286]     ...future.result$conditions <- ...future.conditions
[16:01:43.286]     ...future.result$finished <- base::Sys.time()
[16:01:43.286]     ...future.result
[16:01:43.286] }
[16:01:43.289] Exporting 5 global objects (0.99 KiB) to cluster node #1 ...
[16:01:43.289] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:01:43.290] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:01:43.290] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[16:01:43.290] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[16:01:43.290] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[16:01:43.291] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[16:01:43.291] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:01:43.291] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:01:43.291] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:01:43.292] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:01:43.292] Exporting 5 global objects (0.99 KiB) to cluster node #1 ... DONE
[16:01:43.293] MultisessionFuture started
[16:01:43.293] - Launch lazy future ... done
[16:01:43.293] run() for ‘MultisessionFuture’ ... done
[16:01:43.293] Created future:
[16:01:43.293] MultisessionFuture:
[16:01:43.293] Label: ‘future_apply-1’
[16:01:43.293] Expression:
[16:01:43.293] {
[16:01:43.293]     do.call(function(...) {
[16:01:43.293]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.293]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:43.293]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.293]             on.exit(options(oopts), add = TRUE)
[16:01:43.293]         }
[16:01:43.293]         {
[16:01:43.293]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:43.293]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.293]                 ...future.FUN(...future.X_jj, ...)
[16:01:43.293]             })
[16:01:43.293]         }
[16:01:43.293]     }, args = future.call.arguments)
[16:01:43.293] }
[16:01:43.293] Lazy evaluation: FALSE
[16:01:43.293] Asynchronous evaluation: TRUE
[16:01:43.293] Local evaluation: TRUE
[16:01:43.293] Environment: R_GlobalEnv
[16:01:43.293] Capture standard output: TRUE
[16:01:43.293] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:43.293] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:43.293] Packages: <none>
[16:01:43.293] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:43.293] Resolved: FALSE
[16:01:43.293] Value: <not collected>
[16:01:43.293] Conditions captured: <none>
[16:01:43.293] Early signaling: FALSE
[16:01:43.293] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:43.293] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:43.305] Chunk #1 of 2 ... DONE
[16:01:43.305] Chunk #2 of 2 ...
[16:01:43.305]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:43.305]  - seeds: <none>
[16:01:43.305]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.306] getGlobalsAndPackages() ...
[16:01:43.306] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.306] Resolving globals: FALSE
[16:01:43.306] Tweak future expression to call with '...' arguments ...
[16:01:43.306] {
[16:01:43.306]     do.call(function(...) {
[16:01:43.306]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.306]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:43.306]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.306]             on.exit(options(oopts), add = TRUE)
[16:01:43.306]         }
[16:01:43.306]         {
[16:01:43.306]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:43.306]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.306]                 ...future.FUN(...future.X_jj, ...)
[16:01:43.306]             })
[16:01:43.306]         }
[16:01:43.306]     }, args = future.call.arguments)
[16:01:43.306] }
[16:01:43.306] Tweak future expression to call with '...' arguments ... DONE
[16:01:43.307] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.307] 
[16:01:43.307] getGlobalsAndPackages() ... DONE
[16:01:43.307] run() for ‘Future’ ...
[16:01:43.307] - state: ‘created’
[16:01:43.308] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:43.324] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:43.324] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:43.324]   - Field: ‘node’
[16:01:43.324]   - Field: ‘label’
[16:01:43.324]   - Field: ‘local’
[16:01:43.324]   - Field: ‘owner’
[16:01:43.324]   - Field: ‘envir’
[16:01:43.325]   - Field: ‘workers’
[16:01:43.325]   - Field: ‘packages’
[16:01:43.325]   - Field: ‘gc’
[16:01:43.325]   - Field: ‘conditions’
[16:01:43.325]   - Field: ‘persistent’
[16:01:43.325]   - Field: ‘expr’
[16:01:43.325]   - Field: ‘uuid’
[16:01:43.325]   - Field: ‘seed’
[16:01:43.325]   - Field: ‘version’
[16:01:43.325]   - Field: ‘result’
[16:01:43.326]   - Field: ‘asynchronous’
[16:01:43.326]   - Field: ‘calls’
[16:01:43.326]   - Field: ‘globals’
[16:01:43.326]   - Field: ‘stdout’
[16:01:43.326]   - Field: ‘earlySignal’
[16:01:43.326]   - Field: ‘lazy’
[16:01:43.326]   - Field: ‘state’
[16:01:43.326] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:43.326] - Launch lazy future ...
[16:01:43.327] Packages needed by the future expression (n = 0): <none>
[16:01:43.327] Packages needed by future strategies (n = 0): <none>
[16:01:43.327] {
[16:01:43.327]     {
[16:01:43.327]         {
[16:01:43.327]             ...future.startTime <- base::Sys.time()
[16:01:43.327]             {
[16:01:43.327]                 {
[16:01:43.327]                   {
[16:01:43.327]                     {
[16:01:43.327]                       base::local({
[16:01:43.327]                         has_future <- base::requireNamespace("future", 
[16:01:43.327]                           quietly = TRUE)
[16:01:43.327]                         if (has_future) {
[16:01:43.327]                           ns <- base::getNamespace("future")
[16:01:43.327]                           version <- ns[[".package"]][["version"]]
[16:01:43.327]                           if (is.null(version)) 
[16:01:43.327]                             version <- utils::packageVersion("future")
[16:01:43.327]                         }
[16:01:43.327]                         else {
[16:01:43.327]                           version <- NULL
[16:01:43.327]                         }
[16:01:43.327]                         if (!has_future || version < "1.8.0") {
[16:01:43.327]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:43.327]                             "", base::R.version$version.string), 
[16:01:43.327]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:43.327]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:43.327]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:43.327]                               "release", "version")], collapse = " "), 
[16:01:43.327]                             hostname = base::Sys.info()[["nodename"]])
[16:01:43.327]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:43.327]                             info)
[16:01:43.327]                           info <- base::paste(info, collapse = "; ")
[16:01:43.327]                           if (!has_future) {
[16:01:43.327]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:43.327]                               info)
[16:01:43.327]                           }
[16:01:43.327]                           else {
[16:01:43.327]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:43.327]                               info, version)
[16:01:43.327]                           }
[16:01:43.327]                           base::stop(msg)
[16:01:43.327]                         }
[16:01:43.327]                       })
[16:01:43.327]                     }
[16:01:43.327]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:43.327]                     base::options(mc.cores = 1L)
[16:01:43.327]                   }
[16:01:43.327]                   options(future.plan = NULL)
[16:01:43.327]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:43.327]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:43.327]                 }
[16:01:43.327]                 ...future.workdir <- getwd()
[16:01:43.327]             }
[16:01:43.327]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:43.327]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:43.327]         }
[16:01:43.327]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:43.327]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:43.327]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:43.327]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:43.327]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:43.327]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:43.327]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:43.327]             base::names(...future.oldOptions))
[16:01:43.327]     }
[16:01:43.327]     if (FALSE) {
[16:01:43.327]     }
[16:01:43.327]     else {
[16:01:43.327]         if (TRUE) {
[16:01:43.327]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:43.327]                 open = "w")
[16:01:43.327]         }
[16:01:43.327]         else {
[16:01:43.327]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:43.327]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:43.327]         }
[16:01:43.327]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:43.327]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:43.327]             base::sink(type = "output", split = FALSE)
[16:01:43.327]             base::close(...future.stdout)
[16:01:43.327]         }, add = TRUE)
[16:01:43.327]     }
[16:01:43.327]     ...future.frame <- base::sys.nframe()
[16:01:43.327]     ...future.conditions <- base::list()
[16:01:43.327]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:43.327]     if (FALSE) {
[16:01:43.327]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:43.327]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:43.327]     }
[16:01:43.327]     ...future.result <- base::tryCatch({
[16:01:43.327]         base::withCallingHandlers({
[16:01:43.327]             ...future.value <- base::withVisible(base::local({
[16:01:43.327]                 ...future.makeSendCondition <- base::local({
[16:01:43.327]                   sendCondition <- NULL
[16:01:43.327]                   function(frame = 1L) {
[16:01:43.327]                     if (is.function(sendCondition)) 
[16:01:43.327]                       return(sendCondition)
[16:01:43.327]                     ns <- getNamespace("parallel")
[16:01:43.327]                     if (exists("sendData", mode = "function", 
[16:01:43.327]                       envir = ns)) {
[16:01:43.327]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:43.327]                         envir = ns)
[16:01:43.327]                       envir <- sys.frame(frame)
[16:01:43.327]                       master <- NULL
[16:01:43.327]                       while (!identical(envir, .GlobalEnv) && 
[16:01:43.327]                         !identical(envir, emptyenv())) {
[16:01:43.327]                         if (exists("master", mode = "list", envir = envir, 
[16:01:43.327]                           inherits = FALSE)) {
[16:01:43.327]                           master <- get("master", mode = "list", 
[16:01:43.327]                             envir = envir, inherits = FALSE)
[16:01:43.327]                           if (inherits(master, c("SOCKnode", 
[16:01:43.327]                             "SOCK0node"))) {
[16:01:43.327]                             sendCondition <<- function(cond) {
[16:01:43.327]                               data <- list(type = "VALUE", value = cond, 
[16:01:43.327]                                 success = TRUE)
[16:01:43.327]                               parallel_sendData(master, data)
[16:01:43.327]                             }
[16:01:43.327]                             return(sendCondition)
[16:01:43.327]                           }
[16:01:43.327]                         }
[16:01:43.327]                         frame <- frame + 1L
[16:01:43.327]                         envir <- sys.frame(frame)
[16:01:43.327]                       }
[16:01:43.327]                     }
[16:01:43.327]                     sendCondition <<- function(cond) NULL
[16:01:43.327]                   }
[16:01:43.327]                 })
[16:01:43.327]                 withCallingHandlers({
[16:01:43.327]                   {
[16:01:43.327]                     do.call(function(...) {
[16:01:43.327]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.327]                       if (!identical(...future.globals.maxSize.org, 
[16:01:43.327]                         ...future.globals.maxSize)) {
[16:01:43.327]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.327]                         on.exit(options(oopts), add = TRUE)
[16:01:43.327]                       }
[16:01:43.327]                       {
[16:01:43.327]                         lapply(seq_along(...future.elements_ii), 
[16:01:43.327]                           FUN = function(jj) {
[16:01:43.327]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.327]                             ...future.FUN(...future.X_jj, ...)
[16:01:43.327]                           })
[16:01:43.327]                       }
[16:01:43.327]                     }, args = future.call.arguments)
[16:01:43.327]                   }
[16:01:43.327]                 }, immediateCondition = function(cond) {
[16:01:43.327]                   sendCondition <- ...future.makeSendCondition()
[16:01:43.327]                   sendCondition(cond)
[16:01:43.327]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.327]                   {
[16:01:43.327]                     inherits <- base::inherits
[16:01:43.327]                     invokeRestart <- base::invokeRestart
[16:01:43.327]                     is.null <- base::is.null
[16:01:43.327]                     muffled <- FALSE
[16:01:43.327]                     if (inherits(cond, "message")) {
[16:01:43.327]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:43.327]                       if (muffled) 
[16:01:43.327]                         invokeRestart("muffleMessage")
[16:01:43.327]                     }
[16:01:43.327]                     else if (inherits(cond, "warning")) {
[16:01:43.327]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:43.327]                       if (muffled) 
[16:01:43.327]                         invokeRestart("muffleWarning")
[16:01:43.327]                     }
[16:01:43.327]                     else if (inherits(cond, "condition")) {
[16:01:43.327]                       if (!is.null(pattern)) {
[16:01:43.327]                         computeRestarts <- base::computeRestarts
[16:01:43.327]                         grepl <- base::grepl
[16:01:43.327]                         restarts <- computeRestarts(cond)
[16:01:43.327]                         for (restart in restarts) {
[16:01:43.327]                           name <- restart$name
[16:01:43.327]                           if (is.null(name)) 
[16:01:43.327]                             next
[16:01:43.327]                           if (!grepl(pattern, name)) 
[16:01:43.327]                             next
[16:01:43.327]                           invokeRestart(restart)
[16:01:43.327]                           muffled <- TRUE
[16:01:43.327]                           break
[16:01:43.327]                         }
[16:01:43.327]                       }
[16:01:43.327]                     }
[16:01:43.327]                     invisible(muffled)
[16:01:43.327]                   }
[16:01:43.327]                   muffleCondition(cond)
[16:01:43.327]                 })
[16:01:43.327]             }))
[16:01:43.327]             future::FutureResult(value = ...future.value$value, 
[16:01:43.327]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:43.327]                   ...future.rng), globalenv = if (FALSE) 
[16:01:43.327]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:43.327]                     ...future.globalenv.names))
[16:01:43.327]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:43.327]         }, condition = base::local({
[16:01:43.327]             c <- base::c
[16:01:43.327]             inherits <- base::inherits
[16:01:43.327]             invokeRestart <- base::invokeRestart
[16:01:43.327]             length <- base::length
[16:01:43.327]             list <- base::list
[16:01:43.327]             seq.int <- base::seq.int
[16:01:43.327]             signalCondition <- base::signalCondition
[16:01:43.327]             sys.calls <- base::sys.calls
[16:01:43.327]             `[[` <- base::`[[`
[16:01:43.327]             `+` <- base::`+`
[16:01:43.327]             `<<-` <- base::`<<-`
[16:01:43.327]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:43.327]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:43.327]                   3L)]
[16:01:43.327]             }
[16:01:43.327]             function(cond) {
[16:01:43.327]                 is_error <- inherits(cond, "error")
[16:01:43.327]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:43.327]                   NULL)
[16:01:43.327]                 if (is_error) {
[16:01:43.327]                   sessionInformation <- function() {
[16:01:43.327]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:43.327]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:43.327]                       search = base::search(), system = base::Sys.info())
[16:01:43.327]                   }
[16:01:43.327]                   ...future.conditions[[length(...future.conditions) + 
[16:01:43.327]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:43.327]                     cond$call), session = sessionInformation(), 
[16:01:43.327]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:43.327]                   signalCondition(cond)
[16:01:43.327]                 }
[16:01:43.327]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:43.327]                 "immediateCondition"))) {
[16:01:43.327]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:43.327]                   ...future.conditions[[length(...future.conditions) + 
[16:01:43.327]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:43.327]                   if (TRUE && !signal) {
[16:01:43.327]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.327]                     {
[16:01:43.327]                       inherits <- base::inherits
[16:01:43.327]                       invokeRestart <- base::invokeRestart
[16:01:43.327]                       is.null <- base::is.null
[16:01:43.327]                       muffled <- FALSE
[16:01:43.327]                       if (inherits(cond, "message")) {
[16:01:43.327]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:43.327]                         if (muffled) 
[16:01:43.327]                           invokeRestart("muffleMessage")
[16:01:43.327]                       }
[16:01:43.327]                       else if (inherits(cond, "warning")) {
[16:01:43.327]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:43.327]                         if (muffled) 
[16:01:43.327]                           invokeRestart("muffleWarning")
[16:01:43.327]                       }
[16:01:43.327]                       else if (inherits(cond, "condition")) {
[16:01:43.327]                         if (!is.null(pattern)) {
[16:01:43.327]                           computeRestarts <- base::computeRestarts
[16:01:43.327]                           grepl <- base::grepl
[16:01:43.327]                           restarts <- computeRestarts(cond)
[16:01:43.327]                           for (restart in restarts) {
[16:01:43.327]                             name <- restart$name
[16:01:43.327]                             if (is.null(name)) 
[16:01:43.327]                               next
[16:01:43.327]                             if (!grepl(pattern, name)) 
[16:01:43.327]                               next
[16:01:43.327]                             invokeRestart(restart)
[16:01:43.327]                             muffled <- TRUE
[16:01:43.327]                             break
[16:01:43.327]                           }
[16:01:43.327]                         }
[16:01:43.327]                       }
[16:01:43.327]                       invisible(muffled)
[16:01:43.327]                     }
[16:01:43.327]                     muffleCondition(cond, pattern = "^muffle")
[16:01:43.327]                   }
[16:01:43.327]                 }
[16:01:43.327]                 else {
[16:01:43.327]                   if (TRUE) {
[16:01:43.327]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.327]                     {
[16:01:43.327]                       inherits <- base::inherits
[16:01:43.327]                       invokeRestart <- base::invokeRestart
[16:01:43.327]                       is.null <- base::is.null
[16:01:43.327]                       muffled <- FALSE
[16:01:43.327]                       if (inherits(cond, "message")) {
[16:01:43.327]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:43.327]                         if (muffled) 
[16:01:43.327]                           invokeRestart("muffleMessage")
[16:01:43.327]                       }
[16:01:43.327]                       else if (inherits(cond, "warning")) {
[16:01:43.327]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:43.327]                         if (muffled) 
[16:01:43.327]                           invokeRestart("muffleWarning")
[16:01:43.327]                       }
[16:01:43.327]                       else if (inherits(cond, "condition")) {
[16:01:43.327]                         if (!is.null(pattern)) {
[16:01:43.327]                           computeRestarts <- base::computeRestarts
[16:01:43.327]                           grepl <- base::grepl
[16:01:43.327]                           restarts <- computeRestarts(cond)
[16:01:43.327]                           for (restart in restarts) {
[16:01:43.327]                             name <- restart$name
[16:01:43.327]                             if (is.null(name)) 
[16:01:43.327]                               next
[16:01:43.327]                             if (!grepl(pattern, name)) 
[16:01:43.327]                               next
[16:01:43.327]                             invokeRestart(restart)
[16:01:43.327]                             muffled <- TRUE
[16:01:43.327]                             break
[16:01:43.327]                           }
[16:01:43.327]                         }
[16:01:43.327]                       }
[16:01:43.327]                       invisible(muffled)
[16:01:43.327]                     }
[16:01:43.327]                     muffleCondition(cond, pattern = "^muffle")
[16:01:43.327]                   }
[16:01:43.327]                 }
[16:01:43.327]             }
[16:01:43.327]         }))
[16:01:43.327]     }, error = function(ex) {
[16:01:43.327]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:43.327]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:43.327]                 ...future.rng), started = ...future.startTime, 
[16:01:43.327]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:43.327]             version = "1.8"), class = "FutureResult")
[16:01:43.327]     }, finally = {
[16:01:43.327]         if (!identical(...future.workdir, getwd())) 
[16:01:43.327]             setwd(...future.workdir)
[16:01:43.327]         {
[16:01:43.327]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:43.327]                 ...future.oldOptions$nwarnings <- NULL
[16:01:43.327]             }
[16:01:43.327]             base::options(...future.oldOptions)
[16:01:43.327]             if (.Platform$OS.type == "windows") {
[16:01:43.327]                 old_names <- names(...future.oldEnvVars)
[16:01:43.327]                 envs <- base::Sys.getenv()
[16:01:43.327]                 names <- names(envs)
[16:01:43.327]                 common <- intersect(names, old_names)
[16:01:43.327]                 added <- setdiff(names, old_names)
[16:01:43.327]                 removed <- setdiff(old_names, names)
[16:01:43.327]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:43.327]                   envs[common]]
[16:01:43.327]                 NAMES <- toupper(changed)
[16:01:43.327]                 args <- list()
[16:01:43.327]                 for (kk in seq_along(NAMES)) {
[16:01:43.327]                   name <- changed[[kk]]
[16:01:43.327]                   NAME <- NAMES[[kk]]
[16:01:43.327]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.327]                     next
[16:01:43.327]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:43.327]                 }
[16:01:43.327]                 NAMES <- toupper(added)
[16:01:43.327]                 for (kk in seq_along(NAMES)) {
[16:01:43.327]                   name <- added[[kk]]
[16:01:43.327]                   NAME <- NAMES[[kk]]
[16:01:43.327]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.327]                     next
[16:01:43.327]                   args[[name]] <- ""
[16:01:43.327]                 }
[16:01:43.327]                 NAMES <- toupper(removed)
[16:01:43.327]                 for (kk in seq_along(NAMES)) {
[16:01:43.327]                   name <- removed[[kk]]
[16:01:43.327]                   NAME <- NAMES[[kk]]
[16:01:43.327]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.327]                     next
[16:01:43.327]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:43.327]                 }
[16:01:43.327]                 if (length(args) > 0) 
[16:01:43.327]                   base::do.call(base::Sys.setenv, args = args)
[16:01:43.327]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:43.327]             }
[16:01:43.327]             else {
[16:01:43.327]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:43.327]             }
[16:01:43.327]             {
[16:01:43.327]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:43.327]                   0L) {
[16:01:43.327]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:43.327]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:43.327]                   base::options(opts)
[16:01:43.327]                 }
[16:01:43.327]                 {
[16:01:43.327]                   {
[16:01:43.327]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:43.327]                     NULL
[16:01:43.327]                   }
[16:01:43.327]                   options(future.plan = NULL)
[16:01:43.327]                   if (is.na(NA_character_)) 
[16:01:43.327]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:43.327]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:43.327]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:43.327]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:43.327]                     envir = parent.frame()) 
[16:01:43.327]                   {
[16:01:43.327]                     if (is.function(workers)) 
[16:01:43.327]                       workers <- workers()
[16:01:43.327]                     workers <- structure(as.integer(workers), 
[16:01:43.327]                       class = class(workers))
[16:01:43.327]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:43.327]                       workers >= 1)
[16:01:43.327]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:43.327]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:43.327]                     }
[16:01:43.327]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:43.327]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:43.327]                       envir = envir)
[16:01:43.327]                     if (!future$lazy) 
[16:01:43.327]                       future <- run(future)
[16:01:43.327]                     invisible(future)
[16:01:43.327]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:43.327]                 }
[16:01:43.327]             }
[16:01:43.327]         }
[16:01:43.327]     })
[16:01:43.327]     if (TRUE) {
[16:01:43.327]         base::sink(type = "output", split = FALSE)
[16:01:43.327]         if (TRUE) {
[16:01:43.327]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:43.327]         }
[16:01:43.327]         else {
[16:01:43.327]             ...future.result["stdout"] <- base::list(NULL)
[16:01:43.327]         }
[16:01:43.327]         base::close(...future.stdout)
[16:01:43.327]         ...future.stdout <- NULL
[16:01:43.327]     }
[16:01:43.327]     ...future.result$conditions <- ...future.conditions
[16:01:43.327]     ...future.result$finished <- base::Sys.time()
[16:01:43.327]     ...future.result
[16:01:43.327] }
[16:01:43.330] Exporting 5 global objects (0.99 KiB) to cluster node #2 ...
[16:01:43.331] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:01:43.331] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:01:43.331] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[16:01:43.332] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[16:01:43.332] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[16:01:43.332] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[16:01:43.332] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:01:43.333] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:01:43.333] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[16:01:43.333] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[16:01:43.333] Exporting 5 global objects (0.99 KiB) to cluster node #2 ... DONE
[16:01:43.334] MultisessionFuture started
[16:01:43.334] - Launch lazy future ... done
[16:01:43.334] run() for ‘MultisessionFuture’ ... done
[16:01:43.334] Created future:
[16:01:43.334] MultisessionFuture:
[16:01:43.334] Label: ‘future_apply-2’
[16:01:43.334] Expression:
[16:01:43.334] {
[16:01:43.334]     do.call(function(...) {
[16:01:43.334]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.334]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:43.334]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.334]             on.exit(options(oopts), add = TRUE)
[16:01:43.334]         }
[16:01:43.334]         {
[16:01:43.334]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:43.334]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.334]                 ...future.FUN(...future.X_jj, ...)
[16:01:43.334]             })
[16:01:43.334]         }
[16:01:43.334]     }, args = future.call.arguments)
[16:01:43.334] }
[16:01:43.334] Lazy evaluation: FALSE
[16:01:43.334] Asynchronous evaluation: TRUE
[16:01:43.334] Local evaluation: TRUE
[16:01:43.334] Environment: R_GlobalEnv
[16:01:43.334] Capture standard output: TRUE
[16:01:43.334] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:43.334] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:43.334] Packages: <none>
[16:01:43.334] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:43.334] Resolved: FALSE
[16:01:43.334] Value: <not collected>
[16:01:43.334] Conditions captured: <none>
[16:01:43.334] Early signaling: FALSE
[16:01:43.334] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:43.334] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:43.346] Chunk #2 of 2 ... DONE
[16:01:43.346] Launching 2 futures (chunks) ... DONE
[16:01:43.346] Resolving 2 futures (chunks) ...
[16:01:43.346] resolve() on list ...
[16:01:43.346]  recursive: 0
[16:01:43.347]  length: 2
[16:01:43.347] 
[16:01:43.347] receiveMessageFromWorker() for ClusterFuture ...
[16:01:43.347] - Validating connection of MultisessionFuture
[16:01:43.348] - received message: FutureResult
[16:01:43.348] - Received FutureResult
[16:01:43.348] - Erased future from FutureRegistry
[16:01:43.348] result() for ClusterFuture ...
[16:01:43.348] - result already collected: FutureResult
[16:01:43.348] result() for ClusterFuture ... done
[16:01:43.348] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:43.348] Future #1
[16:01:43.348] result() for ClusterFuture ...
[16:01:43.349] - result already collected: FutureResult
[16:01:43.349] result() for ClusterFuture ... done
[16:01:43.349] result() for ClusterFuture ...
[16:01:43.349] - result already collected: FutureResult
[16:01:43.349] result() for ClusterFuture ... done
[16:01:43.349] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:01:43.349] - nx: 2
[16:01:43.349] - relay: TRUE
[16:01:43.349] - stdout: TRUE
[16:01:43.349] - signal: TRUE
[16:01:43.349] - resignal: FALSE
[16:01:43.349] - force: TRUE
[16:01:43.350] - relayed: [n=2] FALSE, FALSE
[16:01:43.350] - queued futures: [n=2] FALSE, FALSE
[16:01:43.350]  - until=1
[16:01:43.350]  - relaying element #1
[16:01:43.350] result() for ClusterFuture ...
[16:01:43.350] - result already collected: FutureResult
[16:01:43.350] result() for ClusterFuture ... done
[16:01:43.350] result() for ClusterFuture ...
[16:01:43.350] - result already collected: FutureResult
[16:01:43.350] result() for ClusterFuture ... done
[16:01:43.350] result() for ClusterFuture ...
[16:01:43.351] - result already collected: FutureResult
[16:01:43.351] result() for ClusterFuture ... done
[16:01:43.351] result() for ClusterFuture ...
[16:01:43.351] - result already collected: FutureResult
[16:01:43.351] result() for ClusterFuture ... done
[16:01:43.351] - relayed: [n=2] TRUE, FALSE
[16:01:43.351] - queued futures: [n=2] TRUE, FALSE
[16:01:43.351] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:01:43.351]  length: 1 (resolved future 1)
[16:01:43.380] receiveMessageFromWorker() for ClusterFuture ...
[16:01:43.380] - Validating connection of MultisessionFuture
[16:01:43.380] - received message: FutureResult
[16:01:43.381] - Received FutureResult
[16:01:43.381] - Erased future from FutureRegistry
[16:01:43.381] result() for ClusterFuture ...
[16:01:43.381] - result already collected: FutureResult
[16:01:43.381] result() for ClusterFuture ... done
[16:01:43.381] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:43.381] Future #2
[16:01:43.381] result() for ClusterFuture ...
[16:01:43.381] - result already collected: FutureResult
[16:01:43.381] result() for ClusterFuture ... done
[16:01:43.382] result() for ClusterFuture ...
[16:01:43.382] - result already collected: FutureResult
[16:01:43.382] result() for ClusterFuture ... done
[16:01:43.382] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:01:43.382] - nx: 2
[16:01:43.382] - relay: TRUE
[16:01:43.382] - stdout: TRUE
[16:01:43.382] - signal: TRUE
[16:01:43.382] - resignal: FALSE
[16:01:43.382] - force: TRUE
[16:01:43.382] - relayed: [n=2] TRUE, FALSE
[16:01:43.382] - queued futures: [n=2] TRUE, FALSE
[16:01:43.383]  - until=2
[16:01:43.383]  - relaying element #2
[16:01:43.383] result() for ClusterFuture ...
[16:01:43.383] - result already collected: FutureResult
[16:01:43.383] result() for ClusterFuture ... done
[16:01:43.383] result() for ClusterFuture ...
[16:01:43.383] - result already collected: FutureResult
[16:01:43.383] result() for ClusterFuture ... done
[16:01:43.383] result() for ClusterFuture ...
[16:01:43.383] - result already collected: FutureResult
[16:01:43.384] result() for ClusterFuture ... done
[16:01:43.384] result() for ClusterFuture ...
[16:01:43.384] - result already collected: FutureResult
[16:01:43.384] result() for ClusterFuture ... done
[16:01:43.384] - relayed: [n=2] TRUE, TRUE
[16:01:43.384] - queued futures: [n=2] TRUE, TRUE
[16:01:43.384] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:01:43.384]  length: 0 (resolved future 2)
[16:01:43.384] Relaying remaining futures
[16:01:43.384] signalConditionsASAP(NULL, pos=0) ...
[16:01:43.384] - nx: 2
[16:01:43.385] - relay: TRUE
[16:01:43.385] - stdout: TRUE
[16:01:43.385] - signal: TRUE
[16:01:43.385] - resignal: FALSE
[16:01:43.385] - force: TRUE
[16:01:43.385] - relayed: [n=2] TRUE, TRUE
[16:01:43.385] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:43.385] - relayed: [n=2] TRUE, TRUE
[16:01:43.385] - queued futures: [n=2] TRUE, TRUE
[16:01:43.385] signalConditionsASAP(NULL, pos=0) ... done
[16:01:43.385] resolve() on list ... DONE
[16:01:43.385] result() for ClusterFuture ...
[16:01:43.386] - result already collected: FutureResult
[16:01:43.386] result() for ClusterFuture ... done
[16:01:43.386] result() for ClusterFuture ...
[16:01:43.386] - result already collected: FutureResult
[16:01:43.386] result() for ClusterFuture ... done
[16:01:43.386] result() for ClusterFuture ...
[16:01:43.386] - result already collected: FutureResult
[16:01:43.386] result() for ClusterFuture ... done
[16:01:43.386] result() for ClusterFuture ...
[16:01:43.386] - result already collected: FutureResult
[16:01:43.386] result() for ClusterFuture ... done
[16:01:43.387]  - Number of value chunks collected: 2
[16:01:43.387] Resolving 2 futures (chunks) ... DONE
[16:01:43.387] Reducing values from 2 chunks ...
[16:01:43.387]  - Number of values collected after concatenation: 2
[16:01:43.387]  - Number of values expected: 2
[16:01:43.387] Reducing values from 2 chunks ... DONE
[16:01:43.387] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[16:01:43.387] getGlobalsAndPackagesXApply() ...
[16:01:43.388]  - future.globals: TRUE
[16:01:43.388] getGlobalsAndPackages() ...
[16:01:43.388] Searching for globals...
[16:01:43.389] - globals found: [1] ‘FUN’
[16:01:43.389] Searching for globals ... DONE
[16:01:43.389] Resolving globals: FALSE
[16:01:43.389] The total size of the 1 globals is 848 bytes (848 bytes)
[16:01:43.390] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:01:43.390] - globals: [1] ‘FUN’
[16:01:43.390] 
[16:01:43.390] getGlobalsAndPackages() ... DONE
[16:01:43.390]  - globals found/used: [n=1] ‘FUN’
[16:01:43.390]  - needed namespaces: [n=0] 
[16:01:43.390] Finding globals ... DONE
[16:01:43.390]  - use_args: TRUE
[16:01:43.391]  - Getting '...' globals ...
[16:01:43.391] resolve() on list ...
[16:01:43.391]  recursive: 0
[16:01:43.391]  length: 1
[16:01:43.391]  elements: ‘...’
[16:01:43.391]  length: 0 (resolved future 1)
[16:01:43.391] resolve() on list ... DONE
[16:01:43.391]    - '...' content: [n=0] 
[16:01:43.392] List of 1
[16:01:43.392]  $ ...: list()
[16:01:43.392]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:43.392]  - attr(*, "where")=List of 1
[16:01:43.392]   ..$ ...:<environment: 0x55fb65d217c0> 
[16:01:43.392]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:43.392]  - attr(*, "resolved")= logi TRUE
[16:01:43.392]  - attr(*, "total_size")= num NA
[16:01:43.394]  - Getting '...' globals ... DONE
[16:01:43.394] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:43.394] List of 2
[16:01:43.394]  $ ...future.FUN:function (x)  
[16:01:43.394]  $ ...          : list()
[16:01:43.394]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:43.394]  - attr(*, "where")=List of 2
[16:01:43.394]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:43.394]   ..$ ...          :<environment: 0x55fb65d217c0> 
[16:01:43.394]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:43.394]  - attr(*, "resolved")= logi FALSE
[16:01:43.394]  - attr(*, "total_size")= num 848
[16:01:43.397] Packages to be attached in all futures: [n=0] 
[16:01:43.397] getGlobalsAndPackagesXApply() ... DONE
[16:01:43.401] future_lapply() ...
[16:01:43.405] Number of chunks: 2
[16:01:43.405] getGlobalsAndPackagesXApply() ...
[16:01:43.405]  - future.globals: <name-value list> with names ‘list()’
[16:01:43.405]  - use_args: TRUE
[16:01:43.405] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:01:43.405] List of 2
[16:01:43.405]  $ ...          : list()
[16:01:43.405]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:43.405]  $ ...future.FUN:function (x)  
[16:01:43.405]  - attr(*, "where")=List of 2
[16:01:43.405]   ..$ ...          :<environment: 0x55fb65d217c0> 
[16:01:43.405]   ..$ ...future.FUN:<environment: namespace:base> 
[16:01:43.405]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:43.405]  - attr(*, "resolved")= logi FALSE
[16:01:43.405]  - attr(*, "total_size")= num NA
[16:01:43.409] Packages to be attached in all futures: [n=0] 
[16:01:43.409] getGlobalsAndPackagesXApply() ... DONE
[16:01:43.409] Number of futures (= number of chunks): 2
[16:01:43.409] Launching 2 futures (chunks) ...
[16:01:43.409] Chunk #1 of 2 ...
[16:01:43.409]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:43.409]  - seeds: <none>
[16:01:43.409]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.410] getGlobalsAndPackages() ...
[16:01:43.410] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.410] Resolving globals: FALSE
[16:01:43.410] Tweak future expression to call with '...' arguments ...
[16:01:43.410] {
[16:01:43.410]     do.call(function(...) {
[16:01:43.410]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.410]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:43.410]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.410]             on.exit(options(oopts), add = TRUE)
[16:01:43.410]         }
[16:01:43.410]         {
[16:01:43.410]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:43.410]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.410]                 ...future.FUN(...future.X_jj, ...)
[16:01:43.410]             })
[16:01:43.410]         }
[16:01:43.410]     }, args = future.call.arguments)
[16:01:43.410] }
[16:01:43.410] Tweak future expression to call with '...' arguments ... DONE
[16:01:43.411] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.411] 
[16:01:43.411] getGlobalsAndPackages() ... DONE
[16:01:43.411] run() for ‘Future’ ...
[16:01:43.411] - state: ‘created’
[16:01:43.411] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:43.425] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:43.425] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:43.425]   - Field: ‘node’
[16:01:43.426]   - Field: ‘label’
[16:01:43.426]   - Field: ‘local’
[16:01:43.426]   - Field: ‘owner’
[16:01:43.426]   - Field: ‘envir’
[16:01:43.426]   - Field: ‘workers’
[16:01:43.426]   - Field: ‘packages’
[16:01:43.426]   - Field: ‘gc’
[16:01:43.426]   - Field: ‘conditions’
[16:01:43.426]   - Field: ‘persistent’
[16:01:43.426]   - Field: ‘expr’
[16:01:43.427]   - Field: ‘uuid’
[16:01:43.427]   - Field: ‘seed’
[16:01:43.427]   - Field: ‘version’
[16:01:43.427]   - Field: ‘result’
[16:01:43.427]   - Field: ‘asynchronous’
[16:01:43.427]   - Field: ‘calls’
[16:01:43.427]   - Field: ‘globals’
[16:01:43.427]   - Field: ‘stdout’
[16:01:43.427]   - Field: ‘earlySignal’
[16:01:43.427]   - Field: ‘lazy’
[16:01:43.427]   - Field: ‘state’
[16:01:43.428] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:43.428] - Launch lazy future ...
[16:01:43.428] Packages needed by the future expression (n = 0): <none>
[16:01:43.428] Packages needed by future strategies (n = 0): <none>
[16:01:43.429] {
[16:01:43.429]     {
[16:01:43.429]         {
[16:01:43.429]             ...future.startTime <- base::Sys.time()
[16:01:43.429]             {
[16:01:43.429]                 {
[16:01:43.429]                   {
[16:01:43.429]                     {
[16:01:43.429]                       base::local({
[16:01:43.429]                         has_future <- base::requireNamespace("future", 
[16:01:43.429]                           quietly = TRUE)
[16:01:43.429]                         if (has_future) {
[16:01:43.429]                           ns <- base::getNamespace("future")
[16:01:43.429]                           version <- ns[[".package"]][["version"]]
[16:01:43.429]                           if (is.null(version)) 
[16:01:43.429]                             version <- utils::packageVersion("future")
[16:01:43.429]                         }
[16:01:43.429]                         else {
[16:01:43.429]                           version <- NULL
[16:01:43.429]                         }
[16:01:43.429]                         if (!has_future || version < "1.8.0") {
[16:01:43.429]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:43.429]                             "", base::R.version$version.string), 
[16:01:43.429]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:43.429]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:43.429]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:43.429]                               "release", "version")], collapse = " "), 
[16:01:43.429]                             hostname = base::Sys.info()[["nodename"]])
[16:01:43.429]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:43.429]                             info)
[16:01:43.429]                           info <- base::paste(info, collapse = "; ")
[16:01:43.429]                           if (!has_future) {
[16:01:43.429]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:43.429]                               info)
[16:01:43.429]                           }
[16:01:43.429]                           else {
[16:01:43.429]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:43.429]                               info, version)
[16:01:43.429]                           }
[16:01:43.429]                           base::stop(msg)
[16:01:43.429]                         }
[16:01:43.429]                       })
[16:01:43.429]                     }
[16:01:43.429]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:43.429]                     base::options(mc.cores = 1L)
[16:01:43.429]                   }
[16:01:43.429]                   options(future.plan = NULL)
[16:01:43.429]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:43.429]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:43.429]                 }
[16:01:43.429]                 ...future.workdir <- getwd()
[16:01:43.429]             }
[16:01:43.429]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:43.429]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:43.429]         }
[16:01:43.429]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:43.429]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:43.429]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:43.429]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:43.429]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:43.429]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:43.429]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:43.429]             base::names(...future.oldOptions))
[16:01:43.429]     }
[16:01:43.429]     if (FALSE) {
[16:01:43.429]     }
[16:01:43.429]     else {
[16:01:43.429]         if (TRUE) {
[16:01:43.429]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:43.429]                 open = "w")
[16:01:43.429]         }
[16:01:43.429]         else {
[16:01:43.429]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:43.429]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:43.429]         }
[16:01:43.429]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:43.429]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:43.429]             base::sink(type = "output", split = FALSE)
[16:01:43.429]             base::close(...future.stdout)
[16:01:43.429]         }, add = TRUE)
[16:01:43.429]     }
[16:01:43.429]     ...future.frame <- base::sys.nframe()
[16:01:43.429]     ...future.conditions <- base::list()
[16:01:43.429]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:43.429]     if (FALSE) {
[16:01:43.429]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:43.429]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:43.429]     }
[16:01:43.429]     ...future.result <- base::tryCatch({
[16:01:43.429]         base::withCallingHandlers({
[16:01:43.429]             ...future.value <- base::withVisible(base::local({
[16:01:43.429]                 ...future.makeSendCondition <- base::local({
[16:01:43.429]                   sendCondition <- NULL
[16:01:43.429]                   function(frame = 1L) {
[16:01:43.429]                     if (is.function(sendCondition)) 
[16:01:43.429]                       return(sendCondition)
[16:01:43.429]                     ns <- getNamespace("parallel")
[16:01:43.429]                     if (exists("sendData", mode = "function", 
[16:01:43.429]                       envir = ns)) {
[16:01:43.429]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:43.429]                         envir = ns)
[16:01:43.429]                       envir <- sys.frame(frame)
[16:01:43.429]                       master <- NULL
[16:01:43.429]                       while (!identical(envir, .GlobalEnv) && 
[16:01:43.429]                         !identical(envir, emptyenv())) {
[16:01:43.429]                         if (exists("master", mode = "list", envir = envir, 
[16:01:43.429]                           inherits = FALSE)) {
[16:01:43.429]                           master <- get("master", mode = "list", 
[16:01:43.429]                             envir = envir, inherits = FALSE)
[16:01:43.429]                           if (inherits(master, c("SOCKnode", 
[16:01:43.429]                             "SOCK0node"))) {
[16:01:43.429]                             sendCondition <<- function(cond) {
[16:01:43.429]                               data <- list(type = "VALUE", value = cond, 
[16:01:43.429]                                 success = TRUE)
[16:01:43.429]                               parallel_sendData(master, data)
[16:01:43.429]                             }
[16:01:43.429]                             return(sendCondition)
[16:01:43.429]                           }
[16:01:43.429]                         }
[16:01:43.429]                         frame <- frame + 1L
[16:01:43.429]                         envir <- sys.frame(frame)
[16:01:43.429]                       }
[16:01:43.429]                     }
[16:01:43.429]                     sendCondition <<- function(cond) NULL
[16:01:43.429]                   }
[16:01:43.429]                 })
[16:01:43.429]                 withCallingHandlers({
[16:01:43.429]                   {
[16:01:43.429]                     do.call(function(...) {
[16:01:43.429]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.429]                       if (!identical(...future.globals.maxSize.org, 
[16:01:43.429]                         ...future.globals.maxSize)) {
[16:01:43.429]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.429]                         on.exit(options(oopts), add = TRUE)
[16:01:43.429]                       }
[16:01:43.429]                       {
[16:01:43.429]                         lapply(seq_along(...future.elements_ii), 
[16:01:43.429]                           FUN = function(jj) {
[16:01:43.429]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.429]                             ...future.FUN(...future.X_jj, ...)
[16:01:43.429]                           })
[16:01:43.429]                       }
[16:01:43.429]                     }, args = future.call.arguments)
[16:01:43.429]                   }
[16:01:43.429]                 }, immediateCondition = function(cond) {
[16:01:43.429]                   sendCondition <- ...future.makeSendCondition()
[16:01:43.429]                   sendCondition(cond)
[16:01:43.429]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.429]                   {
[16:01:43.429]                     inherits <- base::inherits
[16:01:43.429]                     invokeRestart <- base::invokeRestart
[16:01:43.429]                     is.null <- base::is.null
[16:01:43.429]                     muffled <- FALSE
[16:01:43.429]                     if (inherits(cond, "message")) {
[16:01:43.429]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:43.429]                       if (muffled) 
[16:01:43.429]                         invokeRestart("muffleMessage")
[16:01:43.429]                     }
[16:01:43.429]                     else if (inherits(cond, "warning")) {
[16:01:43.429]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:43.429]                       if (muffled) 
[16:01:43.429]                         invokeRestart("muffleWarning")
[16:01:43.429]                     }
[16:01:43.429]                     else if (inherits(cond, "condition")) {
[16:01:43.429]                       if (!is.null(pattern)) {
[16:01:43.429]                         computeRestarts <- base::computeRestarts
[16:01:43.429]                         grepl <- base::grepl
[16:01:43.429]                         restarts <- computeRestarts(cond)
[16:01:43.429]                         for (restart in restarts) {
[16:01:43.429]                           name <- restart$name
[16:01:43.429]                           if (is.null(name)) 
[16:01:43.429]                             next
[16:01:43.429]                           if (!grepl(pattern, name)) 
[16:01:43.429]                             next
[16:01:43.429]                           invokeRestart(restart)
[16:01:43.429]                           muffled <- TRUE
[16:01:43.429]                           break
[16:01:43.429]                         }
[16:01:43.429]                       }
[16:01:43.429]                     }
[16:01:43.429]                     invisible(muffled)
[16:01:43.429]                   }
[16:01:43.429]                   muffleCondition(cond)
[16:01:43.429]                 })
[16:01:43.429]             }))
[16:01:43.429]             future::FutureResult(value = ...future.value$value, 
[16:01:43.429]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:43.429]                   ...future.rng), globalenv = if (FALSE) 
[16:01:43.429]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:43.429]                     ...future.globalenv.names))
[16:01:43.429]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:43.429]         }, condition = base::local({
[16:01:43.429]             c <- base::c
[16:01:43.429]             inherits <- base::inherits
[16:01:43.429]             invokeRestart <- base::invokeRestart
[16:01:43.429]             length <- base::length
[16:01:43.429]             list <- base::list
[16:01:43.429]             seq.int <- base::seq.int
[16:01:43.429]             signalCondition <- base::signalCondition
[16:01:43.429]             sys.calls <- base::sys.calls
[16:01:43.429]             `[[` <- base::`[[`
[16:01:43.429]             `+` <- base::`+`
[16:01:43.429]             `<<-` <- base::`<<-`
[16:01:43.429]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:43.429]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:43.429]                   3L)]
[16:01:43.429]             }
[16:01:43.429]             function(cond) {
[16:01:43.429]                 is_error <- inherits(cond, "error")
[16:01:43.429]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:43.429]                   NULL)
[16:01:43.429]                 if (is_error) {
[16:01:43.429]                   sessionInformation <- function() {
[16:01:43.429]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:43.429]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:43.429]                       search = base::search(), system = base::Sys.info())
[16:01:43.429]                   }
[16:01:43.429]                   ...future.conditions[[length(...future.conditions) + 
[16:01:43.429]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:43.429]                     cond$call), session = sessionInformation(), 
[16:01:43.429]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:43.429]                   signalCondition(cond)
[16:01:43.429]                 }
[16:01:43.429]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:43.429]                 "immediateCondition"))) {
[16:01:43.429]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:43.429]                   ...future.conditions[[length(...future.conditions) + 
[16:01:43.429]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:43.429]                   if (TRUE && !signal) {
[16:01:43.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.429]                     {
[16:01:43.429]                       inherits <- base::inherits
[16:01:43.429]                       invokeRestart <- base::invokeRestart
[16:01:43.429]                       is.null <- base::is.null
[16:01:43.429]                       muffled <- FALSE
[16:01:43.429]                       if (inherits(cond, "message")) {
[16:01:43.429]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:43.429]                         if (muffled) 
[16:01:43.429]                           invokeRestart("muffleMessage")
[16:01:43.429]                       }
[16:01:43.429]                       else if (inherits(cond, "warning")) {
[16:01:43.429]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:43.429]                         if (muffled) 
[16:01:43.429]                           invokeRestart("muffleWarning")
[16:01:43.429]                       }
[16:01:43.429]                       else if (inherits(cond, "condition")) {
[16:01:43.429]                         if (!is.null(pattern)) {
[16:01:43.429]                           computeRestarts <- base::computeRestarts
[16:01:43.429]                           grepl <- base::grepl
[16:01:43.429]                           restarts <- computeRestarts(cond)
[16:01:43.429]                           for (restart in restarts) {
[16:01:43.429]                             name <- restart$name
[16:01:43.429]                             if (is.null(name)) 
[16:01:43.429]                               next
[16:01:43.429]                             if (!grepl(pattern, name)) 
[16:01:43.429]                               next
[16:01:43.429]                             invokeRestart(restart)
[16:01:43.429]                             muffled <- TRUE
[16:01:43.429]                             break
[16:01:43.429]                           }
[16:01:43.429]                         }
[16:01:43.429]                       }
[16:01:43.429]                       invisible(muffled)
[16:01:43.429]                     }
[16:01:43.429]                     muffleCondition(cond, pattern = "^muffle")
[16:01:43.429]                   }
[16:01:43.429]                 }
[16:01:43.429]                 else {
[16:01:43.429]                   if (TRUE) {
[16:01:43.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.429]                     {
[16:01:43.429]                       inherits <- base::inherits
[16:01:43.429]                       invokeRestart <- base::invokeRestart
[16:01:43.429]                       is.null <- base::is.null
[16:01:43.429]                       muffled <- FALSE
[16:01:43.429]                       if (inherits(cond, "message")) {
[16:01:43.429]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:43.429]                         if (muffled) 
[16:01:43.429]                           invokeRestart("muffleMessage")
[16:01:43.429]                       }
[16:01:43.429]                       else if (inherits(cond, "warning")) {
[16:01:43.429]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:43.429]                         if (muffled) 
[16:01:43.429]                           invokeRestart("muffleWarning")
[16:01:43.429]                       }
[16:01:43.429]                       else if (inherits(cond, "condition")) {
[16:01:43.429]                         if (!is.null(pattern)) {
[16:01:43.429]                           computeRestarts <- base::computeRestarts
[16:01:43.429]                           grepl <- base::grepl
[16:01:43.429]                           restarts <- computeRestarts(cond)
[16:01:43.429]                           for (restart in restarts) {
[16:01:43.429]                             name <- restart$name
[16:01:43.429]                             if (is.null(name)) 
[16:01:43.429]                               next
[16:01:43.429]                             if (!grepl(pattern, name)) 
[16:01:43.429]                               next
[16:01:43.429]                             invokeRestart(restart)
[16:01:43.429]                             muffled <- TRUE
[16:01:43.429]                             break
[16:01:43.429]                           }
[16:01:43.429]                         }
[16:01:43.429]                       }
[16:01:43.429]                       invisible(muffled)
[16:01:43.429]                     }
[16:01:43.429]                     muffleCondition(cond, pattern = "^muffle")
[16:01:43.429]                   }
[16:01:43.429]                 }
[16:01:43.429]             }
[16:01:43.429]         }))
[16:01:43.429]     }, error = function(ex) {
[16:01:43.429]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:43.429]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:43.429]                 ...future.rng), started = ...future.startTime, 
[16:01:43.429]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:43.429]             version = "1.8"), class = "FutureResult")
[16:01:43.429]     }, finally = {
[16:01:43.429]         if (!identical(...future.workdir, getwd())) 
[16:01:43.429]             setwd(...future.workdir)
[16:01:43.429]         {
[16:01:43.429]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:43.429]                 ...future.oldOptions$nwarnings <- NULL
[16:01:43.429]             }
[16:01:43.429]             base::options(...future.oldOptions)
[16:01:43.429]             if (.Platform$OS.type == "windows") {
[16:01:43.429]                 old_names <- names(...future.oldEnvVars)
[16:01:43.429]                 envs <- base::Sys.getenv()
[16:01:43.429]                 names <- names(envs)
[16:01:43.429]                 common <- intersect(names, old_names)
[16:01:43.429]                 added <- setdiff(names, old_names)
[16:01:43.429]                 removed <- setdiff(old_names, names)
[16:01:43.429]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:43.429]                   envs[common]]
[16:01:43.429]                 NAMES <- toupper(changed)
[16:01:43.429]                 args <- list()
[16:01:43.429]                 for (kk in seq_along(NAMES)) {
[16:01:43.429]                   name <- changed[[kk]]
[16:01:43.429]                   NAME <- NAMES[[kk]]
[16:01:43.429]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.429]                     next
[16:01:43.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:43.429]                 }
[16:01:43.429]                 NAMES <- toupper(added)
[16:01:43.429]                 for (kk in seq_along(NAMES)) {
[16:01:43.429]                   name <- added[[kk]]
[16:01:43.429]                   NAME <- NAMES[[kk]]
[16:01:43.429]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.429]                     next
[16:01:43.429]                   args[[name]] <- ""
[16:01:43.429]                 }
[16:01:43.429]                 NAMES <- toupper(removed)
[16:01:43.429]                 for (kk in seq_along(NAMES)) {
[16:01:43.429]                   name <- removed[[kk]]
[16:01:43.429]                   NAME <- NAMES[[kk]]
[16:01:43.429]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.429]                     next
[16:01:43.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:43.429]                 }
[16:01:43.429]                 if (length(args) > 0) 
[16:01:43.429]                   base::do.call(base::Sys.setenv, args = args)
[16:01:43.429]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:43.429]             }
[16:01:43.429]             else {
[16:01:43.429]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:43.429]             }
[16:01:43.429]             {
[16:01:43.429]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:43.429]                   0L) {
[16:01:43.429]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:43.429]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:43.429]                   base::options(opts)
[16:01:43.429]                 }
[16:01:43.429]                 {
[16:01:43.429]                   {
[16:01:43.429]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:43.429]                     NULL
[16:01:43.429]                   }
[16:01:43.429]                   options(future.plan = NULL)
[16:01:43.429]                   if (is.na(NA_character_)) 
[16:01:43.429]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:43.429]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:43.429]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:43.429]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:43.429]                     envir = parent.frame()) 
[16:01:43.429]                   {
[16:01:43.429]                     if (is.function(workers)) 
[16:01:43.429]                       workers <- workers()
[16:01:43.429]                     workers <- structure(as.integer(workers), 
[16:01:43.429]                       class = class(workers))
[16:01:43.429]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:43.429]                       workers >= 1)
[16:01:43.429]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:43.429]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:43.429]                     }
[16:01:43.429]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:43.429]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:43.429]                       envir = envir)
[16:01:43.429]                     if (!future$lazy) 
[16:01:43.429]                       future <- run(future)
[16:01:43.429]                     invisible(future)
[16:01:43.429]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:43.429]                 }
[16:01:43.429]             }
[16:01:43.429]         }
[16:01:43.429]     })
[16:01:43.429]     if (TRUE) {
[16:01:43.429]         base::sink(type = "output", split = FALSE)
[16:01:43.429]         if (TRUE) {
[16:01:43.429]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:43.429]         }
[16:01:43.429]         else {
[16:01:43.429]             ...future.result["stdout"] <- base::list(NULL)
[16:01:43.429]         }
[16:01:43.429]         base::close(...future.stdout)
[16:01:43.429]         ...future.stdout <- NULL
[16:01:43.429]     }
[16:01:43.429]     ...future.result$conditions <- ...future.conditions
[16:01:43.429]     ...future.result$finished <- base::Sys.time()
[16:01:43.429]     ...future.result
[16:01:43.429] }
[16:01:43.432] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[16:01:43.432] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:01:43.432] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:01:43.433] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[16:01:43.433] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[16:01:43.433] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[16:01:43.433] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[16:01:43.434] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:01:43.434] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:01:43.434] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:01:43.434] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:01:43.434] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[16:01:43.435] MultisessionFuture started
[16:01:43.435] - Launch lazy future ... done
[16:01:43.435] run() for ‘MultisessionFuture’ ... done
[16:01:43.435] Created future:
[16:01:43.435] MultisessionFuture:
[16:01:43.435] Label: ‘future_apply-1’
[16:01:43.435] Expression:
[16:01:43.435] {
[16:01:43.435]     do.call(function(...) {
[16:01:43.435]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.435]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:43.435]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.435]             on.exit(options(oopts), add = TRUE)
[16:01:43.435]         }
[16:01:43.435]         {
[16:01:43.435]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:43.435]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.435]                 ...future.FUN(...future.X_jj, ...)
[16:01:43.435]             })
[16:01:43.435]         }
[16:01:43.435]     }, args = future.call.arguments)
[16:01:43.435] }
[16:01:43.435] Lazy evaluation: FALSE
[16:01:43.435] Asynchronous evaluation: TRUE
[16:01:43.435] Local evaluation: TRUE
[16:01:43.435] Environment: R_GlobalEnv
[16:01:43.435] Capture standard output: TRUE
[16:01:43.435] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:43.435] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:43.435] Packages: <none>
[16:01:43.435] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:43.435] Resolved: FALSE
[16:01:43.435] Value: <not collected>
[16:01:43.435] Conditions captured: <none>
[16:01:43.435] Early signaling: FALSE
[16:01:43.435] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:43.435] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:43.447] Chunk #1 of 2 ... DONE
[16:01:43.447] Chunk #2 of 2 ...
[16:01:43.448]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:43.448]  - seeds: <none>
[16:01:43.448]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.448] getGlobalsAndPackages() ...
[16:01:43.448] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.450] Resolving globals: FALSE
[16:01:43.450] Tweak future expression to call with '...' arguments ...
[16:01:43.451] {
[16:01:43.451]     do.call(function(...) {
[16:01:43.451]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.451]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:43.451]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.451]             on.exit(options(oopts), add = TRUE)
[16:01:43.451]         }
[16:01:43.451]         {
[16:01:43.451]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:43.451]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.451]                 ...future.FUN(...future.X_jj, ...)
[16:01:43.451]             })
[16:01:43.451]         }
[16:01:43.451]     }, args = future.call.arguments)
[16:01:43.451] }
[16:01:43.451] Tweak future expression to call with '...' arguments ... DONE
[16:01:43.451] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.451] 
[16:01:43.452] getGlobalsAndPackages() ... DONE
[16:01:43.452] run() for ‘Future’ ...
[16:01:43.452] - state: ‘created’
[16:01:43.452] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:43.467] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:43.467] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:43.467]   - Field: ‘node’
[16:01:43.467]   - Field: ‘label’
[16:01:43.467]   - Field: ‘local’
[16:01:43.467]   - Field: ‘owner’
[16:01:43.467]   - Field: ‘envir’
[16:01:43.467]   - Field: ‘workers’
[16:01:43.467]   - Field: ‘packages’
[16:01:43.468]   - Field: ‘gc’
[16:01:43.468]   - Field: ‘conditions’
[16:01:43.468]   - Field: ‘persistent’
[16:01:43.468]   - Field: ‘expr’
[16:01:43.468]   - Field: ‘uuid’
[16:01:43.468]   - Field: ‘seed’
[16:01:43.468]   - Field: ‘version’
[16:01:43.468]   - Field: ‘result’
[16:01:43.468]   - Field: ‘asynchronous’
[16:01:43.468]   - Field: ‘calls’
[16:01:43.468]   - Field: ‘globals’
[16:01:43.469]   - Field: ‘stdout’
[16:01:43.469]   - Field: ‘earlySignal’
[16:01:43.469]   - Field: ‘lazy’
[16:01:43.469]   - Field: ‘state’
[16:01:43.469] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:43.469] - Launch lazy future ...
[16:01:43.469] Packages needed by the future expression (n = 0): <none>
[16:01:43.469] Packages needed by future strategies (n = 0): <none>
[16:01:43.470] {
[16:01:43.470]     {
[16:01:43.470]         {
[16:01:43.470]             ...future.startTime <- base::Sys.time()
[16:01:43.470]             {
[16:01:43.470]                 {
[16:01:43.470]                   {
[16:01:43.470]                     {
[16:01:43.470]                       base::local({
[16:01:43.470]                         has_future <- base::requireNamespace("future", 
[16:01:43.470]                           quietly = TRUE)
[16:01:43.470]                         if (has_future) {
[16:01:43.470]                           ns <- base::getNamespace("future")
[16:01:43.470]                           version <- ns[[".package"]][["version"]]
[16:01:43.470]                           if (is.null(version)) 
[16:01:43.470]                             version <- utils::packageVersion("future")
[16:01:43.470]                         }
[16:01:43.470]                         else {
[16:01:43.470]                           version <- NULL
[16:01:43.470]                         }
[16:01:43.470]                         if (!has_future || version < "1.8.0") {
[16:01:43.470]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:43.470]                             "", base::R.version$version.string), 
[16:01:43.470]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:43.470]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:43.470]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:43.470]                               "release", "version")], collapse = " "), 
[16:01:43.470]                             hostname = base::Sys.info()[["nodename"]])
[16:01:43.470]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:43.470]                             info)
[16:01:43.470]                           info <- base::paste(info, collapse = "; ")
[16:01:43.470]                           if (!has_future) {
[16:01:43.470]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:43.470]                               info)
[16:01:43.470]                           }
[16:01:43.470]                           else {
[16:01:43.470]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:43.470]                               info, version)
[16:01:43.470]                           }
[16:01:43.470]                           base::stop(msg)
[16:01:43.470]                         }
[16:01:43.470]                       })
[16:01:43.470]                     }
[16:01:43.470]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:43.470]                     base::options(mc.cores = 1L)
[16:01:43.470]                   }
[16:01:43.470]                   options(future.plan = NULL)
[16:01:43.470]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:43.470]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:43.470]                 }
[16:01:43.470]                 ...future.workdir <- getwd()
[16:01:43.470]             }
[16:01:43.470]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:43.470]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:43.470]         }
[16:01:43.470]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:43.470]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:43.470]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:43.470]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:43.470]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:43.470]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:43.470]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:43.470]             base::names(...future.oldOptions))
[16:01:43.470]     }
[16:01:43.470]     if (FALSE) {
[16:01:43.470]     }
[16:01:43.470]     else {
[16:01:43.470]         if (TRUE) {
[16:01:43.470]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:43.470]                 open = "w")
[16:01:43.470]         }
[16:01:43.470]         else {
[16:01:43.470]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:43.470]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:43.470]         }
[16:01:43.470]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:43.470]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:43.470]             base::sink(type = "output", split = FALSE)
[16:01:43.470]             base::close(...future.stdout)
[16:01:43.470]         }, add = TRUE)
[16:01:43.470]     }
[16:01:43.470]     ...future.frame <- base::sys.nframe()
[16:01:43.470]     ...future.conditions <- base::list()
[16:01:43.470]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:43.470]     if (FALSE) {
[16:01:43.470]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:43.470]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:43.470]     }
[16:01:43.470]     ...future.result <- base::tryCatch({
[16:01:43.470]         base::withCallingHandlers({
[16:01:43.470]             ...future.value <- base::withVisible(base::local({
[16:01:43.470]                 ...future.makeSendCondition <- base::local({
[16:01:43.470]                   sendCondition <- NULL
[16:01:43.470]                   function(frame = 1L) {
[16:01:43.470]                     if (is.function(sendCondition)) 
[16:01:43.470]                       return(sendCondition)
[16:01:43.470]                     ns <- getNamespace("parallel")
[16:01:43.470]                     if (exists("sendData", mode = "function", 
[16:01:43.470]                       envir = ns)) {
[16:01:43.470]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:43.470]                         envir = ns)
[16:01:43.470]                       envir <- sys.frame(frame)
[16:01:43.470]                       master <- NULL
[16:01:43.470]                       while (!identical(envir, .GlobalEnv) && 
[16:01:43.470]                         !identical(envir, emptyenv())) {
[16:01:43.470]                         if (exists("master", mode = "list", envir = envir, 
[16:01:43.470]                           inherits = FALSE)) {
[16:01:43.470]                           master <- get("master", mode = "list", 
[16:01:43.470]                             envir = envir, inherits = FALSE)
[16:01:43.470]                           if (inherits(master, c("SOCKnode", 
[16:01:43.470]                             "SOCK0node"))) {
[16:01:43.470]                             sendCondition <<- function(cond) {
[16:01:43.470]                               data <- list(type = "VALUE", value = cond, 
[16:01:43.470]                                 success = TRUE)
[16:01:43.470]                               parallel_sendData(master, data)
[16:01:43.470]                             }
[16:01:43.470]                             return(sendCondition)
[16:01:43.470]                           }
[16:01:43.470]                         }
[16:01:43.470]                         frame <- frame + 1L
[16:01:43.470]                         envir <- sys.frame(frame)
[16:01:43.470]                       }
[16:01:43.470]                     }
[16:01:43.470]                     sendCondition <<- function(cond) NULL
[16:01:43.470]                   }
[16:01:43.470]                 })
[16:01:43.470]                 withCallingHandlers({
[16:01:43.470]                   {
[16:01:43.470]                     do.call(function(...) {
[16:01:43.470]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.470]                       if (!identical(...future.globals.maxSize.org, 
[16:01:43.470]                         ...future.globals.maxSize)) {
[16:01:43.470]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.470]                         on.exit(options(oopts), add = TRUE)
[16:01:43.470]                       }
[16:01:43.470]                       {
[16:01:43.470]                         lapply(seq_along(...future.elements_ii), 
[16:01:43.470]                           FUN = function(jj) {
[16:01:43.470]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.470]                             ...future.FUN(...future.X_jj, ...)
[16:01:43.470]                           })
[16:01:43.470]                       }
[16:01:43.470]                     }, args = future.call.arguments)
[16:01:43.470]                   }
[16:01:43.470]                 }, immediateCondition = function(cond) {
[16:01:43.470]                   sendCondition <- ...future.makeSendCondition()
[16:01:43.470]                   sendCondition(cond)
[16:01:43.470]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.470]                   {
[16:01:43.470]                     inherits <- base::inherits
[16:01:43.470]                     invokeRestart <- base::invokeRestart
[16:01:43.470]                     is.null <- base::is.null
[16:01:43.470]                     muffled <- FALSE
[16:01:43.470]                     if (inherits(cond, "message")) {
[16:01:43.470]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:43.470]                       if (muffled) 
[16:01:43.470]                         invokeRestart("muffleMessage")
[16:01:43.470]                     }
[16:01:43.470]                     else if (inherits(cond, "warning")) {
[16:01:43.470]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:43.470]                       if (muffled) 
[16:01:43.470]                         invokeRestart("muffleWarning")
[16:01:43.470]                     }
[16:01:43.470]                     else if (inherits(cond, "condition")) {
[16:01:43.470]                       if (!is.null(pattern)) {
[16:01:43.470]                         computeRestarts <- base::computeRestarts
[16:01:43.470]                         grepl <- base::grepl
[16:01:43.470]                         restarts <- computeRestarts(cond)
[16:01:43.470]                         for (restart in restarts) {
[16:01:43.470]                           name <- restart$name
[16:01:43.470]                           if (is.null(name)) 
[16:01:43.470]                             next
[16:01:43.470]                           if (!grepl(pattern, name)) 
[16:01:43.470]                             next
[16:01:43.470]                           invokeRestart(restart)
[16:01:43.470]                           muffled <- TRUE
[16:01:43.470]                           break
[16:01:43.470]                         }
[16:01:43.470]                       }
[16:01:43.470]                     }
[16:01:43.470]                     invisible(muffled)
[16:01:43.470]                   }
[16:01:43.470]                   muffleCondition(cond)
[16:01:43.470]                 })
[16:01:43.470]             }))
[16:01:43.470]             future::FutureResult(value = ...future.value$value, 
[16:01:43.470]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:43.470]                   ...future.rng), globalenv = if (FALSE) 
[16:01:43.470]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:43.470]                     ...future.globalenv.names))
[16:01:43.470]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:43.470]         }, condition = base::local({
[16:01:43.470]             c <- base::c
[16:01:43.470]             inherits <- base::inherits
[16:01:43.470]             invokeRestart <- base::invokeRestart
[16:01:43.470]             length <- base::length
[16:01:43.470]             list <- base::list
[16:01:43.470]             seq.int <- base::seq.int
[16:01:43.470]             signalCondition <- base::signalCondition
[16:01:43.470]             sys.calls <- base::sys.calls
[16:01:43.470]             `[[` <- base::`[[`
[16:01:43.470]             `+` <- base::`+`
[16:01:43.470]             `<<-` <- base::`<<-`
[16:01:43.470]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:43.470]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:43.470]                   3L)]
[16:01:43.470]             }
[16:01:43.470]             function(cond) {
[16:01:43.470]                 is_error <- inherits(cond, "error")
[16:01:43.470]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:43.470]                   NULL)
[16:01:43.470]                 if (is_error) {
[16:01:43.470]                   sessionInformation <- function() {
[16:01:43.470]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:43.470]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:43.470]                       search = base::search(), system = base::Sys.info())
[16:01:43.470]                   }
[16:01:43.470]                   ...future.conditions[[length(...future.conditions) + 
[16:01:43.470]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:43.470]                     cond$call), session = sessionInformation(), 
[16:01:43.470]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:43.470]                   signalCondition(cond)
[16:01:43.470]                 }
[16:01:43.470]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:43.470]                 "immediateCondition"))) {
[16:01:43.470]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:43.470]                   ...future.conditions[[length(...future.conditions) + 
[16:01:43.470]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:43.470]                   if (TRUE && !signal) {
[16:01:43.470]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.470]                     {
[16:01:43.470]                       inherits <- base::inherits
[16:01:43.470]                       invokeRestart <- base::invokeRestart
[16:01:43.470]                       is.null <- base::is.null
[16:01:43.470]                       muffled <- FALSE
[16:01:43.470]                       if (inherits(cond, "message")) {
[16:01:43.470]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:43.470]                         if (muffled) 
[16:01:43.470]                           invokeRestart("muffleMessage")
[16:01:43.470]                       }
[16:01:43.470]                       else if (inherits(cond, "warning")) {
[16:01:43.470]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:43.470]                         if (muffled) 
[16:01:43.470]                           invokeRestart("muffleWarning")
[16:01:43.470]                       }
[16:01:43.470]                       else if (inherits(cond, "condition")) {
[16:01:43.470]                         if (!is.null(pattern)) {
[16:01:43.470]                           computeRestarts <- base::computeRestarts
[16:01:43.470]                           grepl <- base::grepl
[16:01:43.470]                           restarts <- computeRestarts(cond)
[16:01:43.470]                           for (restart in restarts) {
[16:01:43.470]                             name <- restart$name
[16:01:43.470]                             if (is.null(name)) 
[16:01:43.470]                               next
[16:01:43.470]                             if (!grepl(pattern, name)) 
[16:01:43.470]                               next
[16:01:43.470]                             invokeRestart(restart)
[16:01:43.470]                             muffled <- TRUE
[16:01:43.470]                             break
[16:01:43.470]                           }
[16:01:43.470]                         }
[16:01:43.470]                       }
[16:01:43.470]                       invisible(muffled)
[16:01:43.470]                     }
[16:01:43.470]                     muffleCondition(cond, pattern = "^muffle")
[16:01:43.470]                   }
[16:01:43.470]                 }
[16:01:43.470]                 else {
[16:01:43.470]                   if (TRUE) {
[16:01:43.470]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.470]                     {
[16:01:43.470]                       inherits <- base::inherits
[16:01:43.470]                       invokeRestart <- base::invokeRestart
[16:01:43.470]                       is.null <- base::is.null
[16:01:43.470]                       muffled <- FALSE
[16:01:43.470]                       if (inherits(cond, "message")) {
[16:01:43.470]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:43.470]                         if (muffled) 
[16:01:43.470]                           invokeRestart("muffleMessage")
[16:01:43.470]                       }
[16:01:43.470]                       else if (inherits(cond, "warning")) {
[16:01:43.470]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:43.470]                         if (muffled) 
[16:01:43.470]                           invokeRestart("muffleWarning")
[16:01:43.470]                       }
[16:01:43.470]                       else if (inherits(cond, "condition")) {
[16:01:43.470]                         if (!is.null(pattern)) {
[16:01:43.470]                           computeRestarts <- base::computeRestarts
[16:01:43.470]                           grepl <- base::grepl
[16:01:43.470]                           restarts <- computeRestarts(cond)
[16:01:43.470]                           for (restart in restarts) {
[16:01:43.470]                             name <- restart$name
[16:01:43.470]                             if (is.null(name)) 
[16:01:43.470]                               next
[16:01:43.470]                             if (!grepl(pattern, name)) 
[16:01:43.470]                               next
[16:01:43.470]                             invokeRestart(restart)
[16:01:43.470]                             muffled <- TRUE
[16:01:43.470]                             break
[16:01:43.470]                           }
[16:01:43.470]                         }
[16:01:43.470]                       }
[16:01:43.470]                       invisible(muffled)
[16:01:43.470]                     }
[16:01:43.470]                     muffleCondition(cond, pattern = "^muffle")
[16:01:43.470]                   }
[16:01:43.470]                 }
[16:01:43.470]             }
[16:01:43.470]         }))
[16:01:43.470]     }, error = function(ex) {
[16:01:43.470]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:43.470]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:43.470]                 ...future.rng), started = ...future.startTime, 
[16:01:43.470]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:43.470]             version = "1.8"), class = "FutureResult")
[16:01:43.470]     }, finally = {
[16:01:43.470]         if (!identical(...future.workdir, getwd())) 
[16:01:43.470]             setwd(...future.workdir)
[16:01:43.470]         {
[16:01:43.470]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:43.470]                 ...future.oldOptions$nwarnings <- NULL
[16:01:43.470]             }
[16:01:43.470]             base::options(...future.oldOptions)
[16:01:43.470]             if (.Platform$OS.type == "windows") {
[16:01:43.470]                 old_names <- names(...future.oldEnvVars)
[16:01:43.470]                 envs <- base::Sys.getenv()
[16:01:43.470]                 names <- names(envs)
[16:01:43.470]                 common <- intersect(names, old_names)
[16:01:43.470]                 added <- setdiff(names, old_names)
[16:01:43.470]                 removed <- setdiff(old_names, names)
[16:01:43.470]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:43.470]                   envs[common]]
[16:01:43.470]                 NAMES <- toupper(changed)
[16:01:43.470]                 args <- list()
[16:01:43.470]                 for (kk in seq_along(NAMES)) {
[16:01:43.470]                   name <- changed[[kk]]
[16:01:43.470]                   NAME <- NAMES[[kk]]
[16:01:43.470]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.470]                     next
[16:01:43.470]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:43.470]                 }
[16:01:43.470]                 NAMES <- toupper(added)
[16:01:43.470]                 for (kk in seq_along(NAMES)) {
[16:01:43.470]                   name <- added[[kk]]
[16:01:43.470]                   NAME <- NAMES[[kk]]
[16:01:43.470]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.470]                     next
[16:01:43.470]                   args[[name]] <- ""
[16:01:43.470]                 }
[16:01:43.470]                 NAMES <- toupper(removed)
[16:01:43.470]                 for (kk in seq_along(NAMES)) {
[16:01:43.470]                   name <- removed[[kk]]
[16:01:43.470]                   NAME <- NAMES[[kk]]
[16:01:43.470]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.470]                     next
[16:01:43.470]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:43.470]                 }
[16:01:43.470]                 if (length(args) > 0) 
[16:01:43.470]                   base::do.call(base::Sys.setenv, args = args)
[16:01:43.470]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:43.470]             }
[16:01:43.470]             else {
[16:01:43.470]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:43.470]             }
[16:01:43.470]             {
[16:01:43.470]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:43.470]                   0L) {
[16:01:43.470]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:43.470]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:43.470]                   base::options(opts)
[16:01:43.470]                 }
[16:01:43.470]                 {
[16:01:43.470]                   {
[16:01:43.470]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:43.470]                     NULL
[16:01:43.470]                   }
[16:01:43.470]                   options(future.plan = NULL)
[16:01:43.470]                   if (is.na(NA_character_)) 
[16:01:43.470]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:43.470]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:43.470]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:43.470]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:43.470]                     envir = parent.frame()) 
[16:01:43.470]                   {
[16:01:43.470]                     if (is.function(workers)) 
[16:01:43.470]                       workers <- workers()
[16:01:43.470]                     workers <- structure(as.integer(workers), 
[16:01:43.470]                       class = class(workers))
[16:01:43.470]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:43.470]                       workers >= 1)
[16:01:43.470]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:43.470]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:43.470]                     }
[16:01:43.470]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:43.470]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:43.470]                       envir = envir)
[16:01:43.470]                     if (!future$lazy) 
[16:01:43.470]                       future <- run(future)
[16:01:43.470]                     invisible(future)
[16:01:43.470]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:43.470]                 }
[16:01:43.470]             }
[16:01:43.470]         }
[16:01:43.470]     })
[16:01:43.470]     if (TRUE) {
[16:01:43.470]         base::sink(type = "output", split = FALSE)
[16:01:43.470]         if (TRUE) {
[16:01:43.470]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:43.470]         }
[16:01:43.470]         else {
[16:01:43.470]             ...future.result["stdout"] <- base::list(NULL)
[16:01:43.470]         }
[16:01:43.470]         base::close(...future.stdout)
[16:01:43.470]         ...future.stdout <- NULL
[16:01:43.470]     }
[16:01:43.470]     ...future.result$conditions <- ...future.conditions
[16:01:43.470]     ...future.result$finished <- base::Sys.time()
[16:01:43.470]     ...future.result
[16:01:43.470] }
[16:01:43.473] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[16:01:43.473] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:01:43.474] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:01:43.474] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[16:01:43.474] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[16:01:43.474] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #2 ...
[16:01:43.475] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #2 ... DONE
[16:01:43.475] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:01:43.475] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:01:43.475] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[16:01:43.476] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[16:01:43.476] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[16:01:43.476] MultisessionFuture started
[16:01:43.476] - Launch lazy future ... done
[16:01:43.476] run() for ‘MultisessionFuture’ ... done
[16:01:43.476] Created future:
[16:01:43.477] MultisessionFuture:
[16:01:43.477] Label: ‘future_apply-2’
[16:01:43.477] Expression:
[16:01:43.477] {
[16:01:43.477]     do.call(function(...) {
[16:01:43.477]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.477]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:43.477]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.477]             on.exit(options(oopts), add = TRUE)
[16:01:43.477]         }
[16:01:43.477]         {
[16:01:43.477]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:43.477]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.477]                 ...future.FUN(...future.X_jj, ...)
[16:01:43.477]             })
[16:01:43.477]         }
[16:01:43.477]     }, args = future.call.arguments)
[16:01:43.477] }
[16:01:43.477] Lazy evaluation: FALSE
[16:01:43.477] Asynchronous evaluation: TRUE
[16:01:43.477] Local evaluation: TRUE
[16:01:43.477] Environment: R_GlobalEnv
[16:01:43.477] Capture standard output: TRUE
[16:01:43.477] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:43.477] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:43.477] Packages: <none>
[16:01:43.477] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:43.477] Resolved: FALSE
[16:01:43.477] Value: <not collected>
[16:01:43.477] Conditions captured: <none>
[16:01:43.477] Early signaling: FALSE
[16:01:43.477] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:43.477] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:43.488] Chunk #2 of 2 ... DONE
[16:01:43.488] Launching 2 futures (chunks) ... DONE
[16:01:43.488] Resolving 2 futures (chunks) ...
[16:01:43.489] resolve() on list ...
[16:01:43.489]  recursive: 0
[16:01:43.489]  length: 2
[16:01:43.489] 
[16:01:43.489] receiveMessageFromWorker() for ClusterFuture ...
[16:01:43.489] - Validating connection of MultisessionFuture
[16:01:43.490] - received message: FutureResult
[16:01:43.490] - Received FutureResult
[16:01:43.490] - Erased future from FutureRegistry
[16:01:43.490] result() for ClusterFuture ...
[16:01:43.490] - result already collected: FutureResult
[16:01:43.490] result() for ClusterFuture ... done
[16:01:43.490] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:43.490] Future #1
[16:01:43.490] result() for ClusterFuture ...
[16:01:43.491] - result already collected: FutureResult
[16:01:43.491] result() for ClusterFuture ... done
[16:01:43.491] result() for ClusterFuture ...
[16:01:43.491] - result already collected: FutureResult
[16:01:43.491] result() for ClusterFuture ... done
[16:01:43.491] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:01:43.491] - nx: 2
[16:01:43.491] - relay: TRUE
[16:01:43.491] - stdout: TRUE
[16:01:43.491] - signal: TRUE
[16:01:43.491] - resignal: FALSE
[16:01:43.492] - force: TRUE
[16:01:43.492] - relayed: [n=2] FALSE, FALSE
[16:01:43.492] - queued futures: [n=2] FALSE, FALSE
[16:01:43.492]  - until=1
[16:01:43.492]  - relaying element #1
[16:01:43.492] result() for ClusterFuture ...
[16:01:43.492] - result already collected: FutureResult
[16:01:43.492] result() for ClusterFuture ... done
[16:01:43.492] result() for ClusterFuture ...
[16:01:43.492] - result already collected: FutureResult
[16:01:43.492] result() for ClusterFuture ... done
[16:01:43.493] result() for ClusterFuture ...
[16:01:43.493] - result already collected: FutureResult
[16:01:43.493] result() for ClusterFuture ... done
[16:01:43.493] result() for ClusterFuture ...
[16:01:43.493] - result already collected: FutureResult
[16:01:43.493] result() for ClusterFuture ... done
[16:01:43.493] - relayed: [n=2] TRUE, FALSE
[16:01:43.493] - queued futures: [n=2] TRUE, FALSE
[16:01:43.493] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:01:43.493]  length: 1 (resolved future 1)
[16:01:43.535] receiveMessageFromWorker() for ClusterFuture ...
[16:01:43.536] - Validating connection of MultisessionFuture
[16:01:43.536] - received message: FutureResult
[16:01:43.536] - Received FutureResult
[16:01:43.536] - Erased future from FutureRegistry
[16:01:43.536] result() for ClusterFuture ...
[16:01:43.536] - result already collected: FutureResult
[16:01:43.536] result() for ClusterFuture ... done
[16:01:43.536] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:43.537] Future #2
[16:01:43.537] result() for ClusterFuture ...
[16:01:43.537] - result already collected: FutureResult
[16:01:43.537] result() for ClusterFuture ... done
[16:01:43.537] result() for ClusterFuture ...
[16:01:43.537] - result already collected: FutureResult
[16:01:43.537] result() for ClusterFuture ... done
[16:01:43.537] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:01:43.537] - nx: 2
[16:01:43.537] - relay: TRUE
[16:01:43.537] - stdout: TRUE
[16:01:43.537] - signal: TRUE
[16:01:43.538] - resignal: FALSE
[16:01:43.538] - force: TRUE
[16:01:43.538] - relayed: [n=2] TRUE, FALSE
[16:01:43.538] - queued futures: [n=2] TRUE, FALSE
[16:01:43.538]  - until=2
[16:01:43.538]  - relaying element #2
[16:01:43.538] result() for ClusterFuture ...
[16:01:43.538] - result already collected: FutureResult
[16:01:43.538] result() for ClusterFuture ... done
[16:01:43.538] result() for ClusterFuture ...
[16:01:43.538] - result already collected: FutureResult
[16:01:43.539] result() for ClusterFuture ... done
[16:01:43.539] result() for ClusterFuture ...
[16:01:43.539] - result already collected: FutureResult
[16:01:43.539] result() for ClusterFuture ... done
[16:01:43.539] result() for ClusterFuture ...
[16:01:43.539] - result already collected: FutureResult
[16:01:43.539] result() for ClusterFuture ... done
[16:01:43.539] - relayed: [n=2] TRUE, TRUE
[16:01:43.539] - queued futures: [n=2] TRUE, TRUE
[16:01:43.539] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:01:43.540]  length: 0 (resolved future 2)
[16:01:43.540] Relaying remaining futures
[16:01:43.540] signalConditionsASAP(NULL, pos=0) ...
[16:01:43.540] - nx: 2
[16:01:43.540] - relay: TRUE
[16:01:43.540] - stdout: TRUE
[16:01:43.540] - signal: TRUE
[16:01:43.540] - resignal: FALSE
[16:01:43.540] - force: TRUE
[16:01:43.540] - relayed: [n=2] TRUE, TRUE
[16:01:43.540] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:43.541] - relayed: [n=2] TRUE, TRUE
[16:01:43.541] - queued futures: [n=2] TRUE, TRUE
[16:01:43.541] signalConditionsASAP(NULL, pos=0) ... done
[16:01:43.541] resolve() on list ... DONE
[16:01:43.541] result() for ClusterFuture ...
[16:01:43.541] - result already collected: FutureResult
[16:01:43.541] result() for ClusterFuture ... done
[16:01:43.541] result() for ClusterFuture ...
[16:01:43.541] - result already collected: FutureResult
[16:01:43.541] result() for ClusterFuture ... done
[16:01:43.541] result() for ClusterFuture ...
[16:01:43.542] - result already collected: FutureResult
[16:01:43.542] result() for ClusterFuture ... done
[16:01:43.542] result() for ClusterFuture ...
[16:01:43.542] - result already collected: FutureResult
[16:01:43.542] result() for ClusterFuture ... done
[16:01:43.542]  - Number of value chunks collected: 2
[16:01:43.542] Resolving 2 futures (chunks) ... DONE
[16:01:43.542] Reducing values from 2 chunks ...
[16:01:43.542]  - Number of values collected after concatenation: 6
[16:01:43.542]  - Number of values expected: 6
[16:01:43.543] Reducing values from 2 chunks ... DONE
[16:01:43.543] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[16:01:43.543] getGlobalsAndPackagesXApply() ...
[16:01:43.543]  - future.globals: TRUE
[16:01:43.543] getGlobalsAndPackages() ...
[16:01:43.544] Searching for globals...
[16:01:43.545] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[16:01:43.545] Searching for globals ... DONE
[16:01:43.545] Resolving globals: FALSE
[16:01:43.545] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[16:01:43.546] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[16:01:43.546] - globals: [1] ‘FUN’
[16:01:43.546] 
[16:01:43.546] getGlobalsAndPackages() ... DONE
[16:01:43.546]  - globals found/used: [n=1] ‘FUN’
[16:01:43.546]  - needed namespaces: [n=0] 
[16:01:43.546] Finding globals ... DONE
[16:01:43.547]  - use_args: TRUE
[16:01:43.547]  - Getting '...' globals ...
[16:01:43.547] resolve() on list ...
[16:01:43.547]  recursive: 0
[16:01:43.547]  length: 1
[16:01:43.547]  elements: ‘...’
[16:01:43.547]  length: 0 (resolved future 1)
[16:01:43.547] resolve() on list ... DONE
[16:01:43.548]    - '...' content: [n=0] 
[16:01:43.548] List of 1
[16:01:43.548]  $ ...: list()
[16:01:43.548]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:43.548]  - attr(*, "where")=List of 1
[16:01:43.548]   ..$ ...:<environment: 0x55fb650553a0> 
[16:01:43.548]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:43.548]  - attr(*, "resolved")= logi TRUE
[16:01:43.548]  - attr(*, "total_size")= num NA
[16:01:43.550]  - Getting '...' globals ... DONE
[16:01:43.550] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:43.551] List of 2
[16:01:43.551]  $ ...future.FUN:function (x)  
[16:01:43.551]  $ ...          : list()
[16:01:43.551]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:43.551]  - attr(*, "where")=List of 2
[16:01:43.551]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:43.551]   ..$ ...          :<environment: 0x55fb650553a0> 
[16:01:43.551]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:43.551]  - attr(*, "resolved")= logi FALSE
[16:01:43.551]  - attr(*, "total_size")= num 1768
[16:01:43.553] Packages to be attached in all futures: [n=0] 
[16:01:43.553] getGlobalsAndPackagesXApply() ... DONE
[16:01:43.557] future_lapply() ...
[16:01:43.561] Number of chunks: 2
[16:01:43.561] getGlobalsAndPackagesXApply() ...
[16:01:43.561]  - future.globals: <name-value list> with names ‘list()’
[16:01:43.561]  - use_args: TRUE
[16:01:43.562] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:01:43.562] List of 2
[16:01:43.562]  $ ...          : list()
[16:01:43.562]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:43.562]  $ ...future.FUN:function (x)  
[16:01:43.562]  - attr(*, "where")=List of 2
[16:01:43.562]   ..$ ...          :<environment: 0x55fb650553a0> 
[16:01:43.562]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[16:01:43.562]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:43.562]  - attr(*, "resolved")= logi FALSE
[16:01:43.562]  - attr(*, "total_size")= num NA
[16:01:43.565] Packages to be attached in all futures: [n=0] 
[16:01:43.565] getGlobalsAndPackagesXApply() ... DONE
[16:01:43.565] Number of futures (= number of chunks): 2
[16:01:43.565] Launching 2 futures (chunks) ...
[16:01:43.565] Chunk #1 of 2 ...
[16:01:43.565]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:43.565]  - seeds: <none>
[16:01:43.565]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.566] getGlobalsAndPackages() ...
[16:01:43.566] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.566] Resolving globals: FALSE
[16:01:43.566] Tweak future expression to call with '...' arguments ...
[16:01:43.566] {
[16:01:43.566]     do.call(function(...) {
[16:01:43.566]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.566]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:43.566]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.566]             on.exit(options(oopts), add = TRUE)
[16:01:43.566]         }
[16:01:43.566]         {
[16:01:43.566]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:43.566]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.566]                 ...future.FUN(...future.X_jj, ...)
[16:01:43.566]             })
[16:01:43.566]         }
[16:01:43.566]     }, args = future.call.arguments)
[16:01:43.566] }
[16:01:43.566] Tweak future expression to call with '...' arguments ... DONE
[16:01:43.567] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.567] 
[16:01:43.567] getGlobalsAndPackages() ... DONE
[16:01:43.567] run() for ‘Future’ ...
[16:01:43.567] - state: ‘created’
[16:01:43.568] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:43.582] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:43.582] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:43.582]   - Field: ‘node’
[16:01:43.582]   - Field: ‘label’
[16:01:43.582]   - Field: ‘local’
[16:01:43.582]   - Field: ‘owner’
[16:01:43.582]   - Field: ‘envir’
[16:01:43.582]   - Field: ‘workers’
[16:01:43.583]   - Field: ‘packages’
[16:01:43.583]   - Field: ‘gc’
[16:01:43.583]   - Field: ‘conditions’
[16:01:43.583]   - Field: ‘persistent’
[16:01:43.583]   - Field: ‘expr’
[16:01:43.583]   - Field: ‘uuid’
[16:01:43.583]   - Field: ‘seed’
[16:01:43.583]   - Field: ‘version’
[16:01:43.583]   - Field: ‘result’
[16:01:43.583]   - Field: ‘asynchronous’
[16:01:43.583]   - Field: ‘calls’
[16:01:43.584]   - Field: ‘globals’
[16:01:43.584]   - Field: ‘stdout’
[16:01:43.584]   - Field: ‘earlySignal’
[16:01:43.584]   - Field: ‘lazy’
[16:01:43.584]   - Field: ‘state’
[16:01:43.584] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:43.584] - Launch lazy future ...
[16:01:43.584] Packages needed by the future expression (n = 0): <none>
[16:01:43.585] Packages needed by future strategies (n = 0): <none>
[16:01:43.585] {
[16:01:43.585]     {
[16:01:43.585]         {
[16:01:43.585]             ...future.startTime <- base::Sys.time()
[16:01:43.585]             {
[16:01:43.585]                 {
[16:01:43.585]                   {
[16:01:43.585]                     {
[16:01:43.585]                       base::local({
[16:01:43.585]                         has_future <- base::requireNamespace("future", 
[16:01:43.585]                           quietly = TRUE)
[16:01:43.585]                         if (has_future) {
[16:01:43.585]                           ns <- base::getNamespace("future")
[16:01:43.585]                           version <- ns[[".package"]][["version"]]
[16:01:43.585]                           if (is.null(version)) 
[16:01:43.585]                             version <- utils::packageVersion("future")
[16:01:43.585]                         }
[16:01:43.585]                         else {
[16:01:43.585]                           version <- NULL
[16:01:43.585]                         }
[16:01:43.585]                         if (!has_future || version < "1.8.0") {
[16:01:43.585]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:43.585]                             "", base::R.version$version.string), 
[16:01:43.585]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:43.585]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:43.585]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:43.585]                               "release", "version")], collapse = " "), 
[16:01:43.585]                             hostname = base::Sys.info()[["nodename"]])
[16:01:43.585]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:43.585]                             info)
[16:01:43.585]                           info <- base::paste(info, collapse = "; ")
[16:01:43.585]                           if (!has_future) {
[16:01:43.585]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:43.585]                               info)
[16:01:43.585]                           }
[16:01:43.585]                           else {
[16:01:43.585]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:43.585]                               info, version)
[16:01:43.585]                           }
[16:01:43.585]                           base::stop(msg)
[16:01:43.585]                         }
[16:01:43.585]                       })
[16:01:43.585]                     }
[16:01:43.585]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:43.585]                     base::options(mc.cores = 1L)
[16:01:43.585]                   }
[16:01:43.585]                   options(future.plan = NULL)
[16:01:43.585]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:43.585]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:43.585]                 }
[16:01:43.585]                 ...future.workdir <- getwd()
[16:01:43.585]             }
[16:01:43.585]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:43.585]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:43.585]         }
[16:01:43.585]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:43.585]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:43.585]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:43.585]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:43.585]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:43.585]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:43.585]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:43.585]             base::names(...future.oldOptions))
[16:01:43.585]     }
[16:01:43.585]     if (FALSE) {
[16:01:43.585]     }
[16:01:43.585]     else {
[16:01:43.585]         if (TRUE) {
[16:01:43.585]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:43.585]                 open = "w")
[16:01:43.585]         }
[16:01:43.585]         else {
[16:01:43.585]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:43.585]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:43.585]         }
[16:01:43.585]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:43.585]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:43.585]             base::sink(type = "output", split = FALSE)
[16:01:43.585]             base::close(...future.stdout)
[16:01:43.585]         }, add = TRUE)
[16:01:43.585]     }
[16:01:43.585]     ...future.frame <- base::sys.nframe()
[16:01:43.585]     ...future.conditions <- base::list()
[16:01:43.585]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:43.585]     if (FALSE) {
[16:01:43.585]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:43.585]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:43.585]     }
[16:01:43.585]     ...future.result <- base::tryCatch({
[16:01:43.585]         base::withCallingHandlers({
[16:01:43.585]             ...future.value <- base::withVisible(base::local({
[16:01:43.585]                 ...future.makeSendCondition <- base::local({
[16:01:43.585]                   sendCondition <- NULL
[16:01:43.585]                   function(frame = 1L) {
[16:01:43.585]                     if (is.function(sendCondition)) 
[16:01:43.585]                       return(sendCondition)
[16:01:43.585]                     ns <- getNamespace("parallel")
[16:01:43.585]                     if (exists("sendData", mode = "function", 
[16:01:43.585]                       envir = ns)) {
[16:01:43.585]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:43.585]                         envir = ns)
[16:01:43.585]                       envir <- sys.frame(frame)
[16:01:43.585]                       master <- NULL
[16:01:43.585]                       while (!identical(envir, .GlobalEnv) && 
[16:01:43.585]                         !identical(envir, emptyenv())) {
[16:01:43.585]                         if (exists("master", mode = "list", envir = envir, 
[16:01:43.585]                           inherits = FALSE)) {
[16:01:43.585]                           master <- get("master", mode = "list", 
[16:01:43.585]                             envir = envir, inherits = FALSE)
[16:01:43.585]                           if (inherits(master, c("SOCKnode", 
[16:01:43.585]                             "SOCK0node"))) {
[16:01:43.585]                             sendCondition <<- function(cond) {
[16:01:43.585]                               data <- list(type = "VALUE", value = cond, 
[16:01:43.585]                                 success = TRUE)
[16:01:43.585]                               parallel_sendData(master, data)
[16:01:43.585]                             }
[16:01:43.585]                             return(sendCondition)
[16:01:43.585]                           }
[16:01:43.585]                         }
[16:01:43.585]                         frame <- frame + 1L
[16:01:43.585]                         envir <- sys.frame(frame)
[16:01:43.585]                       }
[16:01:43.585]                     }
[16:01:43.585]                     sendCondition <<- function(cond) NULL
[16:01:43.585]                   }
[16:01:43.585]                 })
[16:01:43.585]                 withCallingHandlers({
[16:01:43.585]                   {
[16:01:43.585]                     do.call(function(...) {
[16:01:43.585]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.585]                       if (!identical(...future.globals.maxSize.org, 
[16:01:43.585]                         ...future.globals.maxSize)) {
[16:01:43.585]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.585]                         on.exit(options(oopts), add = TRUE)
[16:01:43.585]                       }
[16:01:43.585]                       {
[16:01:43.585]                         lapply(seq_along(...future.elements_ii), 
[16:01:43.585]                           FUN = function(jj) {
[16:01:43.585]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.585]                             ...future.FUN(...future.X_jj, ...)
[16:01:43.585]                           })
[16:01:43.585]                       }
[16:01:43.585]                     }, args = future.call.arguments)
[16:01:43.585]                   }
[16:01:43.585]                 }, immediateCondition = function(cond) {
[16:01:43.585]                   sendCondition <- ...future.makeSendCondition()
[16:01:43.585]                   sendCondition(cond)
[16:01:43.585]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.585]                   {
[16:01:43.585]                     inherits <- base::inherits
[16:01:43.585]                     invokeRestart <- base::invokeRestart
[16:01:43.585]                     is.null <- base::is.null
[16:01:43.585]                     muffled <- FALSE
[16:01:43.585]                     if (inherits(cond, "message")) {
[16:01:43.585]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:43.585]                       if (muffled) 
[16:01:43.585]                         invokeRestart("muffleMessage")
[16:01:43.585]                     }
[16:01:43.585]                     else if (inherits(cond, "warning")) {
[16:01:43.585]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:43.585]                       if (muffled) 
[16:01:43.585]                         invokeRestart("muffleWarning")
[16:01:43.585]                     }
[16:01:43.585]                     else if (inherits(cond, "condition")) {
[16:01:43.585]                       if (!is.null(pattern)) {
[16:01:43.585]                         computeRestarts <- base::computeRestarts
[16:01:43.585]                         grepl <- base::grepl
[16:01:43.585]                         restarts <- computeRestarts(cond)
[16:01:43.585]                         for (restart in restarts) {
[16:01:43.585]                           name <- restart$name
[16:01:43.585]                           if (is.null(name)) 
[16:01:43.585]                             next
[16:01:43.585]                           if (!grepl(pattern, name)) 
[16:01:43.585]                             next
[16:01:43.585]                           invokeRestart(restart)
[16:01:43.585]                           muffled <- TRUE
[16:01:43.585]                           break
[16:01:43.585]                         }
[16:01:43.585]                       }
[16:01:43.585]                     }
[16:01:43.585]                     invisible(muffled)
[16:01:43.585]                   }
[16:01:43.585]                   muffleCondition(cond)
[16:01:43.585]                 })
[16:01:43.585]             }))
[16:01:43.585]             future::FutureResult(value = ...future.value$value, 
[16:01:43.585]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:43.585]                   ...future.rng), globalenv = if (FALSE) 
[16:01:43.585]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:43.585]                     ...future.globalenv.names))
[16:01:43.585]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:43.585]         }, condition = base::local({
[16:01:43.585]             c <- base::c
[16:01:43.585]             inherits <- base::inherits
[16:01:43.585]             invokeRestart <- base::invokeRestart
[16:01:43.585]             length <- base::length
[16:01:43.585]             list <- base::list
[16:01:43.585]             seq.int <- base::seq.int
[16:01:43.585]             signalCondition <- base::signalCondition
[16:01:43.585]             sys.calls <- base::sys.calls
[16:01:43.585]             `[[` <- base::`[[`
[16:01:43.585]             `+` <- base::`+`
[16:01:43.585]             `<<-` <- base::`<<-`
[16:01:43.585]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:43.585]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:43.585]                   3L)]
[16:01:43.585]             }
[16:01:43.585]             function(cond) {
[16:01:43.585]                 is_error <- inherits(cond, "error")
[16:01:43.585]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:43.585]                   NULL)
[16:01:43.585]                 if (is_error) {
[16:01:43.585]                   sessionInformation <- function() {
[16:01:43.585]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:43.585]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:43.585]                       search = base::search(), system = base::Sys.info())
[16:01:43.585]                   }
[16:01:43.585]                   ...future.conditions[[length(...future.conditions) + 
[16:01:43.585]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:43.585]                     cond$call), session = sessionInformation(), 
[16:01:43.585]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:43.585]                   signalCondition(cond)
[16:01:43.585]                 }
[16:01:43.585]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:43.585]                 "immediateCondition"))) {
[16:01:43.585]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:43.585]                   ...future.conditions[[length(...future.conditions) + 
[16:01:43.585]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:43.585]                   if (TRUE && !signal) {
[16:01:43.585]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.585]                     {
[16:01:43.585]                       inherits <- base::inherits
[16:01:43.585]                       invokeRestart <- base::invokeRestart
[16:01:43.585]                       is.null <- base::is.null
[16:01:43.585]                       muffled <- FALSE
[16:01:43.585]                       if (inherits(cond, "message")) {
[16:01:43.585]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:43.585]                         if (muffled) 
[16:01:43.585]                           invokeRestart("muffleMessage")
[16:01:43.585]                       }
[16:01:43.585]                       else if (inherits(cond, "warning")) {
[16:01:43.585]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:43.585]                         if (muffled) 
[16:01:43.585]                           invokeRestart("muffleWarning")
[16:01:43.585]                       }
[16:01:43.585]                       else if (inherits(cond, "condition")) {
[16:01:43.585]                         if (!is.null(pattern)) {
[16:01:43.585]                           computeRestarts <- base::computeRestarts
[16:01:43.585]                           grepl <- base::grepl
[16:01:43.585]                           restarts <- computeRestarts(cond)
[16:01:43.585]                           for (restart in restarts) {
[16:01:43.585]                             name <- restart$name
[16:01:43.585]                             if (is.null(name)) 
[16:01:43.585]                               next
[16:01:43.585]                             if (!grepl(pattern, name)) 
[16:01:43.585]                               next
[16:01:43.585]                             invokeRestart(restart)
[16:01:43.585]                             muffled <- TRUE
[16:01:43.585]                             break
[16:01:43.585]                           }
[16:01:43.585]                         }
[16:01:43.585]                       }
[16:01:43.585]                       invisible(muffled)
[16:01:43.585]                     }
[16:01:43.585]                     muffleCondition(cond, pattern = "^muffle")
[16:01:43.585]                   }
[16:01:43.585]                 }
[16:01:43.585]                 else {
[16:01:43.585]                   if (TRUE) {
[16:01:43.585]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.585]                     {
[16:01:43.585]                       inherits <- base::inherits
[16:01:43.585]                       invokeRestart <- base::invokeRestart
[16:01:43.585]                       is.null <- base::is.null
[16:01:43.585]                       muffled <- FALSE
[16:01:43.585]                       if (inherits(cond, "message")) {
[16:01:43.585]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:43.585]                         if (muffled) 
[16:01:43.585]                           invokeRestart("muffleMessage")
[16:01:43.585]                       }
[16:01:43.585]                       else if (inherits(cond, "warning")) {
[16:01:43.585]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:43.585]                         if (muffled) 
[16:01:43.585]                           invokeRestart("muffleWarning")
[16:01:43.585]                       }
[16:01:43.585]                       else if (inherits(cond, "condition")) {
[16:01:43.585]                         if (!is.null(pattern)) {
[16:01:43.585]                           computeRestarts <- base::computeRestarts
[16:01:43.585]                           grepl <- base::grepl
[16:01:43.585]                           restarts <- computeRestarts(cond)
[16:01:43.585]                           for (restart in restarts) {
[16:01:43.585]                             name <- restart$name
[16:01:43.585]                             if (is.null(name)) 
[16:01:43.585]                               next
[16:01:43.585]                             if (!grepl(pattern, name)) 
[16:01:43.585]                               next
[16:01:43.585]                             invokeRestart(restart)
[16:01:43.585]                             muffled <- TRUE
[16:01:43.585]                             break
[16:01:43.585]                           }
[16:01:43.585]                         }
[16:01:43.585]                       }
[16:01:43.585]                       invisible(muffled)
[16:01:43.585]                     }
[16:01:43.585]                     muffleCondition(cond, pattern = "^muffle")
[16:01:43.585]                   }
[16:01:43.585]                 }
[16:01:43.585]             }
[16:01:43.585]         }))
[16:01:43.585]     }, error = function(ex) {
[16:01:43.585]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:43.585]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:43.585]                 ...future.rng), started = ...future.startTime, 
[16:01:43.585]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:43.585]             version = "1.8"), class = "FutureResult")
[16:01:43.585]     }, finally = {
[16:01:43.585]         if (!identical(...future.workdir, getwd())) 
[16:01:43.585]             setwd(...future.workdir)
[16:01:43.585]         {
[16:01:43.585]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:43.585]                 ...future.oldOptions$nwarnings <- NULL
[16:01:43.585]             }
[16:01:43.585]             base::options(...future.oldOptions)
[16:01:43.585]             if (.Platform$OS.type == "windows") {
[16:01:43.585]                 old_names <- names(...future.oldEnvVars)
[16:01:43.585]                 envs <- base::Sys.getenv()
[16:01:43.585]                 names <- names(envs)
[16:01:43.585]                 common <- intersect(names, old_names)
[16:01:43.585]                 added <- setdiff(names, old_names)
[16:01:43.585]                 removed <- setdiff(old_names, names)
[16:01:43.585]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:43.585]                   envs[common]]
[16:01:43.585]                 NAMES <- toupper(changed)
[16:01:43.585]                 args <- list()
[16:01:43.585]                 for (kk in seq_along(NAMES)) {
[16:01:43.585]                   name <- changed[[kk]]
[16:01:43.585]                   NAME <- NAMES[[kk]]
[16:01:43.585]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.585]                     next
[16:01:43.585]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:43.585]                 }
[16:01:43.585]                 NAMES <- toupper(added)
[16:01:43.585]                 for (kk in seq_along(NAMES)) {
[16:01:43.585]                   name <- added[[kk]]
[16:01:43.585]                   NAME <- NAMES[[kk]]
[16:01:43.585]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.585]                     next
[16:01:43.585]                   args[[name]] <- ""
[16:01:43.585]                 }
[16:01:43.585]                 NAMES <- toupper(removed)
[16:01:43.585]                 for (kk in seq_along(NAMES)) {
[16:01:43.585]                   name <- removed[[kk]]
[16:01:43.585]                   NAME <- NAMES[[kk]]
[16:01:43.585]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.585]                     next
[16:01:43.585]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:43.585]                 }
[16:01:43.585]                 if (length(args) > 0) 
[16:01:43.585]                   base::do.call(base::Sys.setenv, args = args)
[16:01:43.585]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:43.585]             }
[16:01:43.585]             else {
[16:01:43.585]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:43.585]             }
[16:01:43.585]             {
[16:01:43.585]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:43.585]                   0L) {
[16:01:43.585]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:43.585]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:43.585]                   base::options(opts)
[16:01:43.585]                 }
[16:01:43.585]                 {
[16:01:43.585]                   {
[16:01:43.585]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:43.585]                     NULL
[16:01:43.585]                   }
[16:01:43.585]                   options(future.plan = NULL)
[16:01:43.585]                   if (is.na(NA_character_)) 
[16:01:43.585]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:43.585]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:43.585]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:43.585]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:43.585]                     envir = parent.frame()) 
[16:01:43.585]                   {
[16:01:43.585]                     if (is.function(workers)) 
[16:01:43.585]                       workers <- workers()
[16:01:43.585]                     workers <- structure(as.integer(workers), 
[16:01:43.585]                       class = class(workers))
[16:01:43.585]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:43.585]                       workers >= 1)
[16:01:43.585]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:43.585]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:43.585]                     }
[16:01:43.585]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:43.585]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:43.585]                       envir = envir)
[16:01:43.585]                     if (!future$lazy) 
[16:01:43.585]                       future <- run(future)
[16:01:43.585]                     invisible(future)
[16:01:43.585]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:43.585]                 }
[16:01:43.585]             }
[16:01:43.585]         }
[16:01:43.585]     })
[16:01:43.585]     if (TRUE) {
[16:01:43.585]         base::sink(type = "output", split = FALSE)
[16:01:43.585]         if (TRUE) {
[16:01:43.585]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:43.585]         }
[16:01:43.585]         else {
[16:01:43.585]             ...future.result["stdout"] <- base::list(NULL)
[16:01:43.585]         }
[16:01:43.585]         base::close(...future.stdout)
[16:01:43.585]         ...future.stdout <- NULL
[16:01:43.585]     }
[16:01:43.585]     ...future.result$conditions <- ...future.conditions
[16:01:43.585]     ...future.result$finished <- base::Sys.time()
[16:01:43.585]     ...future.result
[16:01:43.585] }
[16:01:43.588] Exporting 5 global objects (1.97 KiB) to cluster node #1 ...
[16:01:43.589] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:01:43.589] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:01:43.589] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #1 ...
[16:01:43.589] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #1 ... DONE
[16:01:43.590] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #1 ...
[16:01:43.590] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #1 ... DONE
[16:01:43.590] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:01:43.590] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:01:43.590] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:01:43.591] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:01:43.591] Exporting 5 global objects (1.97 KiB) to cluster node #1 ... DONE
[16:01:43.591] MultisessionFuture started
[16:01:43.591] - Launch lazy future ... done
[16:01:43.592] run() for ‘MultisessionFuture’ ... done
[16:01:43.592] Created future:
[16:01:43.592] MultisessionFuture:
[16:01:43.592] Label: ‘future_apply-1’
[16:01:43.592] Expression:
[16:01:43.592] {
[16:01:43.592]     do.call(function(...) {
[16:01:43.592]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.592]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:43.592]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.592]             on.exit(options(oopts), add = TRUE)
[16:01:43.592]         }
[16:01:43.592]         {
[16:01:43.592]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:43.592]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.592]                 ...future.FUN(...future.X_jj, ...)
[16:01:43.592]             })
[16:01:43.592]         }
[16:01:43.592]     }, args = future.call.arguments)
[16:01:43.592] }
[16:01:43.592] Lazy evaluation: FALSE
[16:01:43.592] Asynchronous evaluation: TRUE
[16:01:43.592] Local evaluation: TRUE
[16:01:43.592] Environment: R_GlobalEnv
[16:01:43.592] Capture standard output: TRUE
[16:01:43.592] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:43.592] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:43.592] Packages: <none>
[16:01:43.592] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:43.592] Resolved: FALSE
[16:01:43.592] Value: <not collected>
[16:01:43.592] Conditions captured: <none>
[16:01:43.592] Early signaling: FALSE
[16:01:43.592] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:43.592] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:43.604] Chunk #1 of 2 ... DONE
[16:01:43.604] Chunk #2 of 2 ...
[16:01:43.604]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:43.604]  - seeds: <none>
[16:01:43.604]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.604] getGlobalsAndPackages() ...
[16:01:43.604] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.604] Resolving globals: FALSE
[16:01:43.604] Tweak future expression to call with '...' arguments ...
[16:01:43.605] {
[16:01:43.605]     do.call(function(...) {
[16:01:43.605]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.605]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:43.605]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.605]             on.exit(options(oopts), add = TRUE)
[16:01:43.605]         }
[16:01:43.605]         {
[16:01:43.605]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:43.605]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.605]                 ...future.FUN(...future.X_jj, ...)
[16:01:43.605]             })
[16:01:43.605]         }
[16:01:43.605]     }, args = future.call.arguments)
[16:01:43.605] }
[16:01:43.605] Tweak future expression to call with '...' arguments ... DONE
[16:01:43.605] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.605] 
[16:01:43.605] getGlobalsAndPackages() ... DONE
[16:01:43.606] run() for ‘Future’ ...
[16:01:43.606] - state: ‘created’
[16:01:43.606] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:43.620] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:43.620] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:43.620]   - Field: ‘node’
[16:01:43.620]   - Field: ‘label’
[16:01:43.621]   - Field: ‘local’
[16:01:43.621]   - Field: ‘owner’
[16:01:43.621]   - Field: ‘envir’
[16:01:43.621]   - Field: ‘workers’
[16:01:43.621]   - Field: ‘packages’
[16:01:43.621]   - Field: ‘gc’
[16:01:43.621]   - Field: ‘conditions’
[16:01:43.621]   - Field: ‘persistent’
[16:01:43.621]   - Field: ‘expr’
[16:01:43.621]   - Field: ‘uuid’
[16:01:43.622]   - Field: ‘seed’
[16:01:43.622]   - Field: ‘version’
[16:01:43.622]   - Field: ‘result’
[16:01:43.622]   - Field: ‘asynchronous’
[16:01:43.622]   - Field: ‘calls’
[16:01:43.622]   - Field: ‘globals’
[16:01:43.622]   - Field: ‘stdout’
[16:01:43.622]   - Field: ‘earlySignal’
[16:01:43.622]   - Field: ‘lazy’
[16:01:43.622]   - Field: ‘state’
[16:01:43.622] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:43.623] - Launch lazy future ...
[16:01:43.623] Packages needed by the future expression (n = 0): <none>
[16:01:43.623] Packages needed by future strategies (n = 0): <none>
[16:01:43.623] {
[16:01:43.623]     {
[16:01:43.623]         {
[16:01:43.623]             ...future.startTime <- base::Sys.time()
[16:01:43.623]             {
[16:01:43.623]                 {
[16:01:43.623]                   {
[16:01:43.623]                     {
[16:01:43.623]                       base::local({
[16:01:43.623]                         has_future <- base::requireNamespace("future", 
[16:01:43.623]                           quietly = TRUE)
[16:01:43.623]                         if (has_future) {
[16:01:43.623]                           ns <- base::getNamespace("future")
[16:01:43.623]                           version <- ns[[".package"]][["version"]]
[16:01:43.623]                           if (is.null(version)) 
[16:01:43.623]                             version <- utils::packageVersion("future")
[16:01:43.623]                         }
[16:01:43.623]                         else {
[16:01:43.623]                           version <- NULL
[16:01:43.623]                         }
[16:01:43.623]                         if (!has_future || version < "1.8.0") {
[16:01:43.623]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:43.623]                             "", base::R.version$version.string), 
[16:01:43.623]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:43.623]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:43.623]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:43.623]                               "release", "version")], collapse = " "), 
[16:01:43.623]                             hostname = base::Sys.info()[["nodename"]])
[16:01:43.623]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:43.623]                             info)
[16:01:43.623]                           info <- base::paste(info, collapse = "; ")
[16:01:43.623]                           if (!has_future) {
[16:01:43.623]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:43.623]                               info)
[16:01:43.623]                           }
[16:01:43.623]                           else {
[16:01:43.623]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:43.623]                               info, version)
[16:01:43.623]                           }
[16:01:43.623]                           base::stop(msg)
[16:01:43.623]                         }
[16:01:43.623]                       })
[16:01:43.623]                     }
[16:01:43.623]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:43.623]                     base::options(mc.cores = 1L)
[16:01:43.623]                   }
[16:01:43.623]                   options(future.plan = NULL)
[16:01:43.623]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:43.623]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:43.623]                 }
[16:01:43.623]                 ...future.workdir <- getwd()
[16:01:43.623]             }
[16:01:43.623]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:43.623]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:43.623]         }
[16:01:43.623]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:43.623]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:43.623]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:43.623]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:43.623]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:43.623]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:43.623]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:43.623]             base::names(...future.oldOptions))
[16:01:43.623]     }
[16:01:43.623]     if (FALSE) {
[16:01:43.623]     }
[16:01:43.623]     else {
[16:01:43.623]         if (TRUE) {
[16:01:43.623]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:43.623]                 open = "w")
[16:01:43.623]         }
[16:01:43.623]         else {
[16:01:43.623]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:43.623]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:43.623]         }
[16:01:43.623]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:43.623]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:43.623]             base::sink(type = "output", split = FALSE)
[16:01:43.623]             base::close(...future.stdout)
[16:01:43.623]         }, add = TRUE)
[16:01:43.623]     }
[16:01:43.623]     ...future.frame <- base::sys.nframe()
[16:01:43.623]     ...future.conditions <- base::list()
[16:01:43.623]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:43.623]     if (FALSE) {
[16:01:43.623]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:43.623]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:43.623]     }
[16:01:43.623]     ...future.result <- base::tryCatch({
[16:01:43.623]         base::withCallingHandlers({
[16:01:43.623]             ...future.value <- base::withVisible(base::local({
[16:01:43.623]                 ...future.makeSendCondition <- base::local({
[16:01:43.623]                   sendCondition <- NULL
[16:01:43.623]                   function(frame = 1L) {
[16:01:43.623]                     if (is.function(sendCondition)) 
[16:01:43.623]                       return(sendCondition)
[16:01:43.623]                     ns <- getNamespace("parallel")
[16:01:43.623]                     if (exists("sendData", mode = "function", 
[16:01:43.623]                       envir = ns)) {
[16:01:43.623]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:43.623]                         envir = ns)
[16:01:43.623]                       envir <- sys.frame(frame)
[16:01:43.623]                       master <- NULL
[16:01:43.623]                       while (!identical(envir, .GlobalEnv) && 
[16:01:43.623]                         !identical(envir, emptyenv())) {
[16:01:43.623]                         if (exists("master", mode = "list", envir = envir, 
[16:01:43.623]                           inherits = FALSE)) {
[16:01:43.623]                           master <- get("master", mode = "list", 
[16:01:43.623]                             envir = envir, inherits = FALSE)
[16:01:43.623]                           if (inherits(master, c("SOCKnode", 
[16:01:43.623]                             "SOCK0node"))) {
[16:01:43.623]                             sendCondition <<- function(cond) {
[16:01:43.623]                               data <- list(type = "VALUE", value = cond, 
[16:01:43.623]                                 success = TRUE)
[16:01:43.623]                               parallel_sendData(master, data)
[16:01:43.623]                             }
[16:01:43.623]                             return(sendCondition)
[16:01:43.623]                           }
[16:01:43.623]                         }
[16:01:43.623]                         frame <- frame + 1L
[16:01:43.623]                         envir <- sys.frame(frame)
[16:01:43.623]                       }
[16:01:43.623]                     }
[16:01:43.623]                     sendCondition <<- function(cond) NULL
[16:01:43.623]                   }
[16:01:43.623]                 })
[16:01:43.623]                 withCallingHandlers({
[16:01:43.623]                   {
[16:01:43.623]                     do.call(function(...) {
[16:01:43.623]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.623]                       if (!identical(...future.globals.maxSize.org, 
[16:01:43.623]                         ...future.globals.maxSize)) {
[16:01:43.623]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.623]                         on.exit(options(oopts), add = TRUE)
[16:01:43.623]                       }
[16:01:43.623]                       {
[16:01:43.623]                         lapply(seq_along(...future.elements_ii), 
[16:01:43.623]                           FUN = function(jj) {
[16:01:43.623]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.623]                             ...future.FUN(...future.X_jj, ...)
[16:01:43.623]                           })
[16:01:43.623]                       }
[16:01:43.623]                     }, args = future.call.arguments)
[16:01:43.623]                   }
[16:01:43.623]                 }, immediateCondition = function(cond) {
[16:01:43.623]                   sendCondition <- ...future.makeSendCondition()
[16:01:43.623]                   sendCondition(cond)
[16:01:43.623]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.623]                   {
[16:01:43.623]                     inherits <- base::inherits
[16:01:43.623]                     invokeRestart <- base::invokeRestart
[16:01:43.623]                     is.null <- base::is.null
[16:01:43.623]                     muffled <- FALSE
[16:01:43.623]                     if (inherits(cond, "message")) {
[16:01:43.623]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:43.623]                       if (muffled) 
[16:01:43.623]                         invokeRestart("muffleMessage")
[16:01:43.623]                     }
[16:01:43.623]                     else if (inherits(cond, "warning")) {
[16:01:43.623]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:43.623]                       if (muffled) 
[16:01:43.623]                         invokeRestart("muffleWarning")
[16:01:43.623]                     }
[16:01:43.623]                     else if (inherits(cond, "condition")) {
[16:01:43.623]                       if (!is.null(pattern)) {
[16:01:43.623]                         computeRestarts <- base::computeRestarts
[16:01:43.623]                         grepl <- base::grepl
[16:01:43.623]                         restarts <- computeRestarts(cond)
[16:01:43.623]                         for (restart in restarts) {
[16:01:43.623]                           name <- restart$name
[16:01:43.623]                           if (is.null(name)) 
[16:01:43.623]                             next
[16:01:43.623]                           if (!grepl(pattern, name)) 
[16:01:43.623]                             next
[16:01:43.623]                           invokeRestart(restart)
[16:01:43.623]                           muffled <- TRUE
[16:01:43.623]                           break
[16:01:43.623]                         }
[16:01:43.623]                       }
[16:01:43.623]                     }
[16:01:43.623]                     invisible(muffled)
[16:01:43.623]                   }
[16:01:43.623]                   muffleCondition(cond)
[16:01:43.623]                 })
[16:01:43.623]             }))
[16:01:43.623]             future::FutureResult(value = ...future.value$value, 
[16:01:43.623]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:43.623]                   ...future.rng), globalenv = if (FALSE) 
[16:01:43.623]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:43.623]                     ...future.globalenv.names))
[16:01:43.623]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:43.623]         }, condition = base::local({
[16:01:43.623]             c <- base::c
[16:01:43.623]             inherits <- base::inherits
[16:01:43.623]             invokeRestart <- base::invokeRestart
[16:01:43.623]             length <- base::length
[16:01:43.623]             list <- base::list
[16:01:43.623]             seq.int <- base::seq.int
[16:01:43.623]             signalCondition <- base::signalCondition
[16:01:43.623]             sys.calls <- base::sys.calls
[16:01:43.623]             `[[` <- base::`[[`
[16:01:43.623]             `+` <- base::`+`
[16:01:43.623]             `<<-` <- base::`<<-`
[16:01:43.623]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:43.623]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:43.623]                   3L)]
[16:01:43.623]             }
[16:01:43.623]             function(cond) {
[16:01:43.623]                 is_error <- inherits(cond, "error")
[16:01:43.623]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:43.623]                   NULL)
[16:01:43.623]                 if (is_error) {
[16:01:43.623]                   sessionInformation <- function() {
[16:01:43.623]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:43.623]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:43.623]                       search = base::search(), system = base::Sys.info())
[16:01:43.623]                   }
[16:01:43.623]                   ...future.conditions[[length(...future.conditions) + 
[16:01:43.623]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:43.623]                     cond$call), session = sessionInformation(), 
[16:01:43.623]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:43.623]                   signalCondition(cond)
[16:01:43.623]                 }
[16:01:43.623]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:43.623]                 "immediateCondition"))) {
[16:01:43.623]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:43.623]                   ...future.conditions[[length(...future.conditions) + 
[16:01:43.623]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:43.623]                   if (TRUE && !signal) {
[16:01:43.623]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.623]                     {
[16:01:43.623]                       inherits <- base::inherits
[16:01:43.623]                       invokeRestart <- base::invokeRestart
[16:01:43.623]                       is.null <- base::is.null
[16:01:43.623]                       muffled <- FALSE
[16:01:43.623]                       if (inherits(cond, "message")) {
[16:01:43.623]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:43.623]                         if (muffled) 
[16:01:43.623]                           invokeRestart("muffleMessage")
[16:01:43.623]                       }
[16:01:43.623]                       else if (inherits(cond, "warning")) {
[16:01:43.623]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:43.623]                         if (muffled) 
[16:01:43.623]                           invokeRestart("muffleWarning")
[16:01:43.623]                       }
[16:01:43.623]                       else if (inherits(cond, "condition")) {
[16:01:43.623]                         if (!is.null(pattern)) {
[16:01:43.623]                           computeRestarts <- base::computeRestarts
[16:01:43.623]                           grepl <- base::grepl
[16:01:43.623]                           restarts <- computeRestarts(cond)
[16:01:43.623]                           for (restart in restarts) {
[16:01:43.623]                             name <- restart$name
[16:01:43.623]                             if (is.null(name)) 
[16:01:43.623]                               next
[16:01:43.623]                             if (!grepl(pattern, name)) 
[16:01:43.623]                               next
[16:01:43.623]                             invokeRestart(restart)
[16:01:43.623]                             muffled <- TRUE
[16:01:43.623]                             break
[16:01:43.623]                           }
[16:01:43.623]                         }
[16:01:43.623]                       }
[16:01:43.623]                       invisible(muffled)
[16:01:43.623]                     }
[16:01:43.623]                     muffleCondition(cond, pattern = "^muffle")
[16:01:43.623]                   }
[16:01:43.623]                 }
[16:01:43.623]                 else {
[16:01:43.623]                   if (TRUE) {
[16:01:43.623]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.623]                     {
[16:01:43.623]                       inherits <- base::inherits
[16:01:43.623]                       invokeRestart <- base::invokeRestart
[16:01:43.623]                       is.null <- base::is.null
[16:01:43.623]                       muffled <- FALSE
[16:01:43.623]                       if (inherits(cond, "message")) {
[16:01:43.623]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:43.623]                         if (muffled) 
[16:01:43.623]                           invokeRestart("muffleMessage")
[16:01:43.623]                       }
[16:01:43.623]                       else if (inherits(cond, "warning")) {
[16:01:43.623]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:43.623]                         if (muffled) 
[16:01:43.623]                           invokeRestart("muffleWarning")
[16:01:43.623]                       }
[16:01:43.623]                       else if (inherits(cond, "condition")) {
[16:01:43.623]                         if (!is.null(pattern)) {
[16:01:43.623]                           computeRestarts <- base::computeRestarts
[16:01:43.623]                           grepl <- base::grepl
[16:01:43.623]                           restarts <- computeRestarts(cond)
[16:01:43.623]                           for (restart in restarts) {
[16:01:43.623]                             name <- restart$name
[16:01:43.623]                             if (is.null(name)) 
[16:01:43.623]                               next
[16:01:43.623]                             if (!grepl(pattern, name)) 
[16:01:43.623]                               next
[16:01:43.623]                             invokeRestart(restart)
[16:01:43.623]                             muffled <- TRUE
[16:01:43.623]                             break
[16:01:43.623]                           }
[16:01:43.623]                         }
[16:01:43.623]                       }
[16:01:43.623]                       invisible(muffled)
[16:01:43.623]                     }
[16:01:43.623]                     muffleCondition(cond, pattern = "^muffle")
[16:01:43.623]                   }
[16:01:43.623]                 }
[16:01:43.623]             }
[16:01:43.623]         }))
[16:01:43.623]     }, error = function(ex) {
[16:01:43.623]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:43.623]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:43.623]                 ...future.rng), started = ...future.startTime, 
[16:01:43.623]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:43.623]             version = "1.8"), class = "FutureResult")
[16:01:43.623]     }, finally = {
[16:01:43.623]         if (!identical(...future.workdir, getwd())) 
[16:01:43.623]             setwd(...future.workdir)
[16:01:43.623]         {
[16:01:43.623]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:43.623]                 ...future.oldOptions$nwarnings <- NULL
[16:01:43.623]             }
[16:01:43.623]             base::options(...future.oldOptions)
[16:01:43.623]             if (.Platform$OS.type == "windows") {
[16:01:43.623]                 old_names <- names(...future.oldEnvVars)
[16:01:43.623]                 envs <- base::Sys.getenv()
[16:01:43.623]                 names <- names(envs)
[16:01:43.623]                 common <- intersect(names, old_names)
[16:01:43.623]                 added <- setdiff(names, old_names)
[16:01:43.623]                 removed <- setdiff(old_names, names)
[16:01:43.623]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:43.623]                   envs[common]]
[16:01:43.623]                 NAMES <- toupper(changed)
[16:01:43.623]                 args <- list()
[16:01:43.623]                 for (kk in seq_along(NAMES)) {
[16:01:43.623]                   name <- changed[[kk]]
[16:01:43.623]                   NAME <- NAMES[[kk]]
[16:01:43.623]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.623]                     next
[16:01:43.623]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:43.623]                 }
[16:01:43.623]                 NAMES <- toupper(added)
[16:01:43.623]                 for (kk in seq_along(NAMES)) {
[16:01:43.623]                   name <- added[[kk]]
[16:01:43.623]                   NAME <- NAMES[[kk]]
[16:01:43.623]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.623]                     next
[16:01:43.623]                   args[[name]] <- ""
[16:01:43.623]                 }
[16:01:43.623]                 NAMES <- toupper(removed)
[16:01:43.623]                 for (kk in seq_along(NAMES)) {
[16:01:43.623]                   name <- removed[[kk]]
[16:01:43.623]                   NAME <- NAMES[[kk]]
[16:01:43.623]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.623]                     next
[16:01:43.623]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:43.623]                 }
[16:01:43.623]                 if (length(args) > 0) 
[16:01:43.623]                   base::do.call(base::Sys.setenv, args = args)
[16:01:43.623]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:43.623]             }
[16:01:43.623]             else {
[16:01:43.623]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:43.623]             }
[16:01:43.623]             {
[16:01:43.623]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:43.623]                   0L) {
[16:01:43.623]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:43.623]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:43.623]                   base::options(opts)
[16:01:43.623]                 }
[16:01:43.623]                 {
[16:01:43.623]                   {
[16:01:43.623]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:43.623]                     NULL
[16:01:43.623]                   }
[16:01:43.623]                   options(future.plan = NULL)
[16:01:43.623]                   if (is.na(NA_character_)) 
[16:01:43.623]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:43.623]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:43.623]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:43.623]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:43.623]                     envir = parent.frame()) 
[16:01:43.623]                   {
[16:01:43.623]                     if (is.function(workers)) 
[16:01:43.623]                       workers <- workers()
[16:01:43.623]                     workers <- structure(as.integer(workers), 
[16:01:43.623]                       class = class(workers))
[16:01:43.623]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:43.623]                       workers >= 1)
[16:01:43.623]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:43.623]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:43.623]                     }
[16:01:43.623]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:43.623]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:43.623]                       envir = envir)
[16:01:43.623]                     if (!future$lazy) 
[16:01:43.623]                       future <- run(future)
[16:01:43.623]                     invisible(future)
[16:01:43.623]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:43.623]                 }
[16:01:43.623]             }
[16:01:43.623]         }
[16:01:43.623]     })
[16:01:43.623]     if (TRUE) {
[16:01:43.623]         base::sink(type = "output", split = FALSE)
[16:01:43.623]         if (TRUE) {
[16:01:43.623]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:43.623]         }
[16:01:43.623]         else {
[16:01:43.623]             ...future.result["stdout"] <- base::list(NULL)
[16:01:43.623]         }
[16:01:43.623]         base::close(...future.stdout)
[16:01:43.623]         ...future.stdout <- NULL
[16:01:43.623]     }
[16:01:43.623]     ...future.result$conditions <- ...future.conditions
[16:01:43.623]     ...future.result$finished <- base::Sys.time()
[16:01:43.623]     ...future.result
[16:01:43.623] }
[16:01:43.627] Exporting 5 global objects (1.97 KiB) to cluster node #2 ...
[16:01:43.627] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:01:43.627] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:01:43.628] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #2 ...
[16:01:43.628] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #2 ... DONE
[16:01:43.628] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #2 ...
[16:01:43.628] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #2 ... DONE
[16:01:43.628] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:01:43.629] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:01:43.629] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[16:01:43.629] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[16:01:43.629] Exporting 5 global objects (1.97 KiB) to cluster node #2 ... DONE
[16:01:43.630] MultisessionFuture started
[16:01:43.630] - Launch lazy future ... done
[16:01:43.630] run() for ‘MultisessionFuture’ ... done
[16:01:43.630] Created future:
[16:01:43.630] MultisessionFuture:
[16:01:43.630] Label: ‘future_apply-2’
[16:01:43.630] Expression:
[16:01:43.630] {
[16:01:43.630]     do.call(function(...) {
[16:01:43.630]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.630]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:43.630]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.630]             on.exit(options(oopts), add = TRUE)
[16:01:43.630]         }
[16:01:43.630]         {
[16:01:43.630]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:43.630]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.630]                 ...future.FUN(...future.X_jj, ...)
[16:01:43.630]             })
[16:01:43.630]         }
[16:01:43.630]     }, args = future.call.arguments)
[16:01:43.630] }
[16:01:43.630] Lazy evaluation: FALSE
[16:01:43.630] Asynchronous evaluation: TRUE
[16:01:43.630] Local evaluation: TRUE
[16:01:43.630] Environment: R_GlobalEnv
[16:01:43.630] Capture standard output: TRUE
[16:01:43.630] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:43.630] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:43.630] Packages: <none>
[16:01:43.630] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:43.630] Resolved: FALSE
[16:01:43.630] Value: <not collected>
[16:01:43.630] Conditions captured: <none>
[16:01:43.630] Early signaling: FALSE
[16:01:43.630] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:43.630] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:43.642] Chunk #2 of 2 ... DONE
[16:01:43.642] Launching 2 futures (chunks) ... DONE
[16:01:43.642] Resolving 2 futures (chunks) ...
[16:01:43.642] resolve() on list ...
[16:01:43.643]  recursive: 0
[16:01:43.643]  length: 2
[16:01:43.643] 
[16:01:43.643] receiveMessageFromWorker() for ClusterFuture ...
[16:01:43.644] - Validating connection of MultisessionFuture
[16:01:43.644] - received message: FutureResult
[16:01:43.644] - Received FutureResult
[16:01:43.644] - Erased future from FutureRegistry
[16:01:43.644] result() for ClusterFuture ...
[16:01:43.644] - result already collected: FutureResult
[16:01:43.644] result() for ClusterFuture ... done
[16:01:43.644] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:43.644] Future #1
[16:01:43.645] result() for ClusterFuture ...
[16:01:43.645] - result already collected: FutureResult
[16:01:43.645] result() for ClusterFuture ... done
[16:01:43.645] result() for ClusterFuture ...
[16:01:43.645] - result already collected: FutureResult
[16:01:43.645] result() for ClusterFuture ... done
[16:01:43.645] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:01:43.645] - nx: 2
[16:01:43.645] - relay: TRUE
[16:01:43.645] - stdout: TRUE
[16:01:43.645] - signal: TRUE
[16:01:43.646] - resignal: FALSE
[16:01:43.646] - force: TRUE
[16:01:43.646] - relayed: [n=2] FALSE, FALSE
[16:01:43.646] - queued futures: [n=2] FALSE, FALSE
[16:01:43.646]  - until=1
[16:01:43.646]  - relaying element #1
[16:01:43.646] result() for ClusterFuture ...
[16:01:43.646] - result already collected: FutureResult
[16:01:43.646] result() for ClusterFuture ... done
[16:01:43.646] result() for ClusterFuture ...
[16:01:43.646] - result already collected: FutureResult
[16:01:43.647] result() for ClusterFuture ... done
[16:01:43.647] result() for ClusterFuture ...
[16:01:43.647] - result already collected: FutureResult
[16:01:43.647] result() for ClusterFuture ... done
[16:01:43.647] result() for ClusterFuture ...
[16:01:43.647] - result already collected: FutureResult
[16:01:43.647] result() for ClusterFuture ... done
[16:01:43.647] - relayed: [n=2] TRUE, FALSE
[16:01:43.647] - queued futures: [n=2] TRUE, FALSE
[16:01:43.647] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:01:43.648]  length: 1 (resolved future 1)
[16:01:43.690] receiveMessageFromWorker() for ClusterFuture ...
[16:01:43.690] - Validating connection of MultisessionFuture
[16:01:43.690] - received message: FutureResult
[16:01:43.690] - Received FutureResult
[16:01:43.690] - Erased future from FutureRegistry
[16:01:43.690] result() for ClusterFuture ...
[16:01:43.691] - result already collected: FutureResult
[16:01:43.691] result() for ClusterFuture ... done
[16:01:43.691] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:43.691] Future #2
[16:01:43.693] result() for ClusterFuture ...
[16:01:43.693] - result already collected: FutureResult
[16:01:43.693] result() for ClusterFuture ... done
[16:01:43.693] result() for ClusterFuture ...
[16:01:43.694] - result already collected: FutureResult
[16:01:43.694] result() for ClusterFuture ... done
[16:01:43.694] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:01:43.694] - nx: 2
[16:01:43.694] - relay: TRUE
[16:01:43.694] - stdout: TRUE
[16:01:43.694] - signal: TRUE
[16:01:43.694] - resignal: FALSE
[16:01:43.694] - force: TRUE
[16:01:43.694] - relayed: [n=2] TRUE, FALSE
[16:01:43.694] - queued futures: [n=2] TRUE, FALSE
[16:01:43.694]  - until=2
[16:01:43.695]  - relaying element #2
[16:01:43.695] result() for ClusterFuture ...
[16:01:43.695] - result already collected: FutureResult
[16:01:43.695] result() for ClusterFuture ... done
[16:01:43.695] result() for ClusterFuture ...
[16:01:43.695] - result already collected: FutureResult
[16:01:43.695] result() for ClusterFuture ... done
[16:01:43.695] result() for ClusterFuture ...
[16:01:43.695] - result already collected: FutureResult
[16:01:43.695] result() for ClusterFuture ... done
[16:01:43.696] result() for ClusterFuture ...
[16:01:43.696] - result already collected: FutureResult
[16:01:43.696] result() for ClusterFuture ... done
[16:01:43.696] - relayed: [n=2] TRUE, TRUE
[16:01:43.696] - queued futures: [n=2] TRUE, TRUE
[16:01:43.696] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:01:43.696]  length: 0 (resolved future 2)
[16:01:43.696] Relaying remaining futures
[16:01:43.696] signalConditionsASAP(NULL, pos=0) ...
[16:01:43.696] - nx: 2
[16:01:43.696] - relay: TRUE
[16:01:43.696] - stdout: TRUE
[16:01:43.697] - signal: TRUE
[16:01:43.697] - resignal: FALSE
[16:01:43.697] - force: TRUE
[16:01:43.697] - relayed: [n=2] TRUE, TRUE
[16:01:43.697] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:43.697] - relayed: [n=2] TRUE, TRUE
[16:01:43.697] - queued futures: [n=2] TRUE, TRUE
[16:01:43.697] signalConditionsASAP(NULL, pos=0) ... done
[16:01:43.697] resolve() on list ... DONE
[16:01:43.697] result() for ClusterFuture ...
[16:01:43.697] - result already collected: FutureResult
[16:01:43.698] result() for ClusterFuture ... done
[16:01:43.698] result() for ClusterFuture ...
[16:01:43.698] - result already collected: FutureResult
[16:01:43.698] result() for ClusterFuture ... done
[16:01:43.698] result() for ClusterFuture ...
[16:01:43.698] - result already collected: FutureResult
[16:01:43.698] result() for ClusterFuture ... done
[16:01:43.698] result() for ClusterFuture ...
[16:01:43.698] - result already collected: FutureResult
[16:01:43.698] result() for ClusterFuture ... done
[16:01:43.698]  - Number of value chunks collected: 2
[16:01:43.698] Resolving 2 futures (chunks) ... DONE
[16:01:43.699] Reducing values from 2 chunks ...
[16:01:43.699]  - Number of values collected after concatenation: 6
[16:01:43.699]  - Number of values expected: 6
[16:01:43.699] Reducing values from 2 chunks ... DONE
[16:01:43.699] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[16:01:43.699] getGlobalsAndPackagesXApply() ...
[16:01:43.699]  - future.globals: TRUE
[16:01:43.700] getGlobalsAndPackages() ...
[16:01:43.700] Searching for globals...
[16:01:43.701] - globals found: [1] ‘FUN’
[16:01:43.701] Searching for globals ... DONE
[16:01:43.701] Resolving globals: FALSE
[16:01:43.701] The total size of the 1 globals is 848 bytes (848 bytes)
[16:01:43.702] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:01:43.702] - globals: [1] ‘FUN’
[16:01:43.702] 
[16:01:43.702] getGlobalsAndPackages() ... DONE
[16:01:43.702]  - globals found/used: [n=1] ‘FUN’
[16:01:43.702]  - needed namespaces: [n=0] 
[16:01:43.702] Finding globals ... DONE
[16:01:43.702]  - use_args: TRUE
[16:01:43.702]  - Getting '...' globals ...
[16:01:43.703] resolve() on list ...
[16:01:43.703]  recursive: 0
[16:01:43.703]  length: 1
[16:01:43.703]  elements: ‘...’
[16:01:43.703]  length: 0 (resolved future 1)
[16:01:43.703] resolve() on list ... DONE
[16:01:43.703]    - '...' content: [n=0] 
[16:01:43.703] List of 1
[16:01:43.703]  $ ...: list()
[16:01:43.703]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:43.703]  - attr(*, "where")=List of 1
[16:01:43.703]   ..$ ...:<environment: 0x55fb64b94ad0> 
[16:01:43.703]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:43.703]  - attr(*, "resolved")= logi TRUE
[16:01:43.703]  - attr(*, "total_size")= num NA
[16:01:43.706]  - Getting '...' globals ... DONE
[16:01:43.706] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:43.706] List of 2
[16:01:43.706]  $ ...future.FUN:function (x)  
[16:01:43.706]  $ ...          : list()
[16:01:43.706]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:43.706]  - attr(*, "where")=List of 2
[16:01:43.706]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:43.706]   ..$ ...          :<environment: 0x55fb64b94ad0> 
[16:01:43.706]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:43.706]  - attr(*, "resolved")= logi FALSE
[16:01:43.706]  - attr(*, "total_size")= num 848
[16:01:43.709] Packages to be attached in all futures: [n=0] 
[16:01:43.709] getGlobalsAndPackagesXApply() ... DONE
[16:01:43.713] future_lapply() ...
[16:01:43.716] Number of chunks: 2
[16:01:43.717] getGlobalsAndPackagesXApply() ...
[16:01:43.717]  - future.globals: <name-value list> with names ‘list()’
[16:01:43.717]  - use_args: TRUE
[16:01:43.717] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:01:43.717] List of 2
[16:01:43.717]  $ ...          : list()
[16:01:43.717]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:43.717]  $ ...future.FUN:function (x)  
[16:01:43.717]  - attr(*, "where")=List of 2
[16:01:43.717]   ..$ ...          :<environment: 0x55fb64b94ad0> 
[16:01:43.717]   ..$ ...future.FUN:<environment: namespace:base> 
[16:01:43.717]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:43.717]  - attr(*, "resolved")= logi FALSE
[16:01:43.717]  - attr(*, "total_size")= num NA
[16:01:43.720] Packages to be attached in all futures: [n=0] 
[16:01:43.721] getGlobalsAndPackagesXApply() ... DONE
[16:01:43.721] Number of futures (= number of chunks): 2
[16:01:43.721] Launching 2 futures (chunks) ...
[16:01:43.721] Chunk #1 of 2 ...
[16:01:43.721]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:43.721]  - seeds: <none>
[16:01:43.721]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.721] getGlobalsAndPackages() ...
[16:01:43.722] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.722] Resolving globals: FALSE
[16:01:43.722] Tweak future expression to call with '...' arguments ...
[16:01:43.722] {
[16:01:43.722]     do.call(function(...) {
[16:01:43.722]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.722]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:43.722]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.722]             on.exit(options(oopts), add = TRUE)
[16:01:43.722]         }
[16:01:43.722]         {
[16:01:43.722]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:43.722]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.722]                 ...future.FUN(...future.X_jj, ...)
[16:01:43.722]             })
[16:01:43.722]         }
[16:01:43.722]     }, args = future.call.arguments)
[16:01:43.722] }
[16:01:43.722] Tweak future expression to call with '...' arguments ... DONE
[16:01:43.723] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.723] 
[16:01:43.723] getGlobalsAndPackages() ... DONE
[16:01:43.723] run() for ‘Future’ ...
[16:01:43.723] - state: ‘created’
[16:01:43.723] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:43.737] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:43.738] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:43.738]   - Field: ‘node’
[16:01:43.738]   - Field: ‘label’
[16:01:43.738]   - Field: ‘local’
[16:01:43.738]   - Field: ‘owner’
[16:01:43.738]   - Field: ‘envir’
[16:01:43.738]   - Field: ‘workers’
[16:01:43.738]   - Field: ‘packages’
[16:01:43.738]   - Field: ‘gc’
[16:01:43.738]   - Field: ‘conditions’
[16:01:43.739]   - Field: ‘persistent’
[16:01:43.739]   - Field: ‘expr’
[16:01:43.739]   - Field: ‘uuid’
[16:01:43.739]   - Field: ‘seed’
[16:01:43.739]   - Field: ‘version’
[16:01:43.739]   - Field: ‘result’
[16:01:43.739]   - Field: ‘asynchronous’
[16:01:43.739]   - Field: ‘calls’
[16:01:43.739]   - Field: ‘globals’
[16:01:43.739]   - Field: ‘stdout’
[16:01:43.739]   - Field: ‘earlySignal’
[16:01:43.740]   - Field: ‘lazy’
[16:01:43.740]   - Field: ‘state’
[16:01:43.740] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:43.740] - Launch lazy future ...
[16:01:43.740] Packages needed by the future expression (n = 0): <none>
[16:01:43.740] Packages needed by future strategies (n = 0): <none>
[16:01:43.741] {
[16:01:43.741]     {
[16:01:43.741]         {
[16:01:43.741]             ...future.startTime <- base::Sys.time()
[16:01:43.741]             {
[16:01:43.741]                 {
[16:01:43.741]                   {
[16:01:43.741]                     {
[16:01:43.741]                       base::local({
[16:01:43.741]                         has_future <- base::requireNamespace("future", 
[16:01:43.741]                           quietly = TRUE)
[16:01:43.741]                         if (has_future) {
[16:01:43.741]                           ns <- base::getNamespace("future")
[16:01:43.741]                           version <- ns[[".package"]][["version"]]
[16:01:43.741]                           if (is.null(version)) 
[16:01:43.741]                             version <- utils::packageVersion("future")
[16:01:43.741]                         }
[16:01:43.741]                         else {
[16:01:43.741]                           version <- NULL
[16:01:43.741]                         }
[16:01:43.741]                         if (!has_future || version < "1.8.0") {
[16:01:43.741]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:43.741]                             "", base::R.version$version.string), 
[16:01:43.741]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:43.741]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:43.741]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:43.741]                               "release", "version")], collapse = " "), 
[16:01:43.741]                             hostname = base::Sys.info()[["nodename"]])
[16:01:43.741]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:43.741]                             info)
[16:01:43.741]                           info <- base::paste(info, collapse = "; ")
[16:01:43.741]                           if (!has_future) {
[16:01:43.741]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:43.741]                               info)
[16:01:43.741]                           }
[16:01:43.741]                           else {
[16:01:43.741]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:43.741]                               info, version)
[16:01:43.741]                           }
[16:01:43.741]                           base::stop(msg)
[16:01:43.741]                         }
[16:01:43.741]                       })
[16:01:43.741]                     }
[16:01:43.741]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:43.741]                     base::options(mc.cores = 1L)
[16:01:43.741]                   }
[16:01:43.741]                   options(future.plan = NULL)
[16:01:43.741]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:43.741]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:43.741]                 }
[16:01:43.741]                 ...future.workdir <- getwd()
[16:01:43.741]             }
[16:01:43.741]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:43.741]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:43.741]         }
[16:01:43.741]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:43.741]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:43.741]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:43.741]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:43.741]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:43.741]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:43.741]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:43.741]             base::names(...future.oldOptions))
[16:01:43.741]     }
[16:01:43.741]     if (FALSE) {
[16:01:43.741]     }
[16:01:43.741]     else {
[16:01:43.741]         if (TRUE) {
[16:01:43.741]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:43.741]                 open = "w")
[16:01:43.741]         }
[16:01:43.741]         else {
[16:01:43.741]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:43.741]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:43.741]         }
[16:01:43.741]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:43.741]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:43.741]             base::sink(type = "output", split = FALSE)
[16:01:43.741]             base::close(...future.stdout)
[16:01:43.741]         }, add = TRUE)
[16:01:43.741]     }
[16:01:43.741]     ...future.frame <- base::sys.nframe()
[16:01:43.741]     ...future.conditions <- base::list()
[16:01:43.741]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:43.741]     if (FALSE) {
[16:01:43.741]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:43.741]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:43.741]     }
[16:01:43.741]     ...future.result <- base::tryCatch({
[16:01:43.741]         base::withCallingHandlers({
[16:01:43.741]             ...future.value <- base::withVisible(base::local({
[16:01:43.741]                 ...future.makeSendCondition <- base::local({
[16:01:43.741]                   sendCondition <- NULL
[16:01:43.741]                   function(frame = 1L) {
[16:01:43.741]                     if (is.function(sendCondition)) 
[16:01:43.741]                       return(sendCondition)
[16:01:43.741]                     ns <- getNamespace("parallel")
[16:01:43.741]                     if (exists("sendData", mode = "function", 
[16:01:43.741]                       envir = ns)) {
[16:01:43.741]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:43.741]                         envir = ns)
[16:01:43.741]                       envir <- sys.frame(frame)
[16:01:43.741]                       master <- NULL
[16:01:43.741]                       while (!identical(envir, .GlobalEnv) && 
[16:01:43.741]                         !identical(envir, emptyenv())) {
[16:01:43.741]                         if (exists("master", mode = "list", envir = envir, 
[16:01:43.741]                           inherits = FALSE)) {
[16:01:43.741]                           master <- get("master", mode = "list", 
[16:01:43.741]                             envir = envir, inherits = FALSE)
[16:01:43.741]                           if (inherits(master, c("SOCKnode", 
[16:01:43.741]                             "SOCK0node"))) {
[16:01:43.741]                             sendCondition <<- function(cond) {
[16:01:43.741]                               data <- list(type = "VALUE", value = cond, 
[16:01:43.741]                                 success = TRUE)
[16:01:43.741]                               parallel_sendData(master, data)
[16:01:43.741]                             }
[16:01:43.741]                             return(sendCondition)
[16:01:43.741]                           }
[16:01:43.741]                         }
[16:01:43.741]                         frame <- frame + 1L
[16:01:43.741]                         envir <- sys.frame(frame)
[16:01:43.741]                       }
[16:01:43.741]                     }
[16:01:43.741]                     sendCondition <<- function(cond) NULL
[16:01:43.741]                   }
[16:01:43.741]                 })
[16:01:43.741]                 withCallingHandlers({
[16:01:43.741]                   {
[16:01:43.741]                     do.call(function(...) {
[16:01:43.741]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.741]                       if (!identical(...future.globals.maxSize.org, 
[16:01:43.741]                         ...future.globals.maxSize)) {
[16:01:43.741]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.741]                         on.exit(options(oopts), add = TRUE)
[16:01:43.741]                       }
[16:01:43.741]                       {
[16:01:43.741]                         lapply(seq_along(...future.elements_ii), 
[16:01:43.741]                           FUN = function(jj) {
[16:01:43.741]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.741]                             ...future.FUN(...future.X_jj, ...)
[16:01:43.741]                           })
[16:01:43.741]                       }
[16:01:43.741]                     }, args = future.call.arguments)
[16:01:43.741]                   }
[16:01:43.741]                 }, immediateCondition = function(cond) {
[16:01:43.741]                   sendCondition <- ...future.makeSendCondition()
[16:01:43.741]                   sendCondition(cond)
[16:01:43.741]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.741]                   {
[16:01:43.741]                     inherits <- base::inherits
[16:01:43.741]                     invokeRestart <- base::invokeRestart
[16:01:43.741]                     is.null <- base::is.null
[16:01:43.741]                     muffled <- FALSE
[16:01:43.741]                     if (inherits(cond, "message")) {
[16:01:43.741]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:43.741]                       if (muffled) 
[16:01:43.741]                         invokeRestart("muffleMessage")
[16:01:43.741]                     }
[16:01:43.741]                     else if (inherits(cond, "warning")) {
[16:01:43.741]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:43.741]                       if (muffled) 
[16:01:43.741]                         invokeRestart("muffleWarning")
[16:01:43.741]                     }
[16:01:43.741]                     else if (inherits(cond, "condition")) {
[16:01:43.741]                       if (!is.null(pattern)) {
[16:01:43.741]                         computeRestarts <- base::computeRestarts
[16:01:43.741]                         grepl <- base::grepl
[16:01:43.741]                         restarts <- computeRestarts(cond)
[16:01:43.741]                         for (restart in restarts) {
[16:01:43.741]                           name <- restart$name
[16:01:43.741]                           if (is.null(name)) 
[16:01:43.741]                             next
[16:01:43.741]                           if (!grepl(pattern, name)) 
[16:01:43.741]                             next
[16:01:43.741]                           invokeRestart(restart)
[16:01:43.741]                           muffled <- TRUE
[16:01:43.741]                           break
[16:01:43.741]                         }
[16:01:43.741]                       }
[16:01:43.741]                     }
[16:01:43.741]                     invisible(muffled)
[16:01:43.741]                   }
[16:01:43.741]                   muffleCondition(cond)
[16:01:43.741]                 })
[16:01:43.741]             }))
[16:01:43.741]             future::FutureResult(value = ...future.value$value, 
[16:01:43.741]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:43.741]                   ...future.rng), globalenv = if (FALSE) 
[16:01:43.741]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:43.741]                     ...future.globalenv.names))
[16:01:43.741]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:43.741]         }, condition = base::local({
[16:01:43.741]             c <- base::c
[16:01:43.741]             inherits <- base::inherits
[16:01:43.741]             invokeRestart <- base::invokeRestart
[16:01:43.741]             length <- base::length
[16:01:43.741]             list <- base::list
[16:01:43.741]             seq.int <- base::seq.int
[16:01:43.741]             signalCondition <- base::signalCondition
[16:01:43.741]             sys.calls <- base::sys.calls
[16:01:43.741]             `[[` <- base::`[[`
[16:01:43.741]             `+` <- base::`+`
[16:01:43.741]             `<<-` <- base::`<<-`
[16:01:43.741]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:43.741]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:43.741]                   3L)]
[16:01:43.741]             }
[16:01:43.741]             function(cond) {
[16:01:43.741]                 is_error <- inherits(cond, "error")
[16:01:43.741]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:43.741]                   NULL)
[16:01:43.741]                 if (is_error) {
[16:01:43.741]                   sessionInformation <- function() {
[16:01:43.741]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:43.741]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:43.741]                       search = base::search(), system = base::Sys.info())
[16:01:43.741]                   }
[16:01:43.741]                   ...future.conditions[[length(...future.conditions) + 
[16:01:43.741]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:43.741]                     cond$call), session = sessionInformation(), 
[16:01:43.741]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:43.741]                   signalCondition(cond)
[16:01:43.741]                 }
[16:01:43.741]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:43.741]                 "immediateCondition"))) {
[16:01:43.741]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:43.741]                   ...future.conditions[[length(...future.conditions) + 
[16:01:43.741]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:43.741]                   if (TRUE && !signal) {
[16:01:43.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.741]                     {
[16:01:43.741]                       inherits <- base::inherits
[16:01:43.741]                       invokeRestart <- base::invokeRestart
[16:01:43.741]                       is.null <- base::is.null
[16:01:43.741]                       muffled <- FALSE
[16:01:43.741]                       if (inherits(cond, "message")) {
[16:01:43.741]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:43.741]                         if (muffled) 
[16:01:43.741]                           invokeRestart("muffleMessage")
[16:01:43.741]                       }
[16:01:43.741]                       else if (inherits(cond, "warning")) {
[16:01:43.741]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:43.741]                         if (muffled) 
[16:01:43.741]                           invokeRestart("muffleWarning")
[16:01:43.741]                       }
[16:01:43.741]                       else if (inherits(cond, "condition")) {
[16:01:43.741]                         if (!is.null(pattern)) {
[16:01:43.741]                           computeRestarts <- base::computeRestarts
[16:01:43.741]                           grepl <- base::grepl
[16:01:43.741]                           restarts <- computeRestarts(cond)
[16:01:43.741]                           for (restart in restarts) {
[16:01:43.741]                             name <- restart$name
[16:01:43.741]                             if (is.null(name)) 
[16:01:43.741]                               next
[16:01:43.741]                             if (!grepl(pattern, name)) 
[16:01:43.741]                               next
[16:01:43.741]                             invokeRestart(restart)
[16:01:43.741]                             muffled <- TRUE
[16:01:43.741]                             break
[16:01:43.741]                           }
[16:01:43.741]                         }
[16:01:43.741]                       }
[16:01:43.741]                       invisible(muffled)
[16:01:43.741]                     }
[16:01:43.741]                     muffleCondition(cond, pattern = "^muffle")
[16:01:43.741]                   }
[16:01:43.741]                 }
[16:01:43.741]                 else {
[16:01:43.741]                   if (TRUE) {
[16:01:43.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.741]                     {
[16:01:43.741]                       inherits <- base::inherits
[16:01:43.741]                       invokeRestart <- base::invokeRestart
[16:01:43.741]                       is.null <- base::is.null
[16:01:43.741]                       muffled <- FALSE
[16:01:43.741]                       if (inherits(cond, "message")) {
[16:01:43.741]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:43.741]                         if (muffled) 
[16:01:43.741]                           invokeRestart("muffleMessage")
[16:01:43.741]                       }
[16:01:43.741]                       else if (inherits(cond, "warning")) {
[16:01:43.741]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:43.741]                         if (muffled) 
[16:01:43.741]                           invokeRestart("muffleWarning")
[16:01:43.741]                       }
[16:01:43.741]                       else if (inherits(cond, "condition")) {
[16:01:43.741]                         if (!is.null(pattern)) {
[16:01:43.741]                           computeRestarts <- base::computeRestarts
[16:01:43.741]                           grepl <- base::grepl
[16:01:43.741]                           restarts <- computeRestarts(cond)
[16:01:43.741]                           for (restart in restarts) {
[16:01:43.741]                             name <- restart$name
[16:01:43.741]                             if (is.null(name)) 
[16:01:43.741]                               next
[16:01:43.741]                             if (!grepl(pattern, name)) 
[16:01:43.741]                               next
[16:01:43.741]                             invokeRestart(restart)
[16:01:43.741]                             muffled <- TRUE
[16:01:43.741]                             break
[16:01:43.741]                           }
[16:01:43.741]                         }
[16:01:43.741]                       }
[16:01:43.741]                       invisible(muffled)
[16:01:43.741]                     }
[16:01:43.741]                     muffleCondition(cond, pattern = "^muffle")
[16:01:43.741]                   }
[16:01:43.741]                 }
[16:01:43.741]             }
[16:01:43.741]         }))
[16:01:43.741]     }, error = function(ex) {
[16:01:43.741]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:43.741]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:43.741]                 ...future.rng), started = ...future.startTime, 
[16:01:43.741]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:43.741]             version = "1.8"), class = "FutureResult")
[16:01:43.741]     }, finally = {
[16:01:43.741]         if (!identical(...future.workdir, getwd())) 
[16:01:43.741]             setwd(...future.workdir)
[16:01:43.741]         {
[16:01:43.741]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:43.741]                 ...future.oldOptions$nwarnings <- NULL
[16:01:43.741]             }
[16:01:43.741]             base::options(...future.oldOptions)
[16:01:43.741]             if (.Platform$OS.type == "windows") {
[16:01:43.741]                 old_names <- names(...future.oldEnvVars)
[16:01:43.741]                 envs <- base::Sys.getenv()
[16:01:43.741]                 names <- names(envs)
[16:01:43.741]                 common <- intersect(names, old_names)
[16:01:43.741]                 added <- setdiff(names, old_names)
[16:01:43.741]                 removed <- setdiff(old_names, names)
[16:01:43.741]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:43.741]                   envs[common]]
[16:01:43.741]                 NAMES <- toupper(changed)
[16:01:43.741]                 args <- list()
[16:01:43.741]                 for (kk in seq_along(NAMES)) {
[16:01:43.741]                   name <- changed[[kk]]
[16:01:43.741]                   NAME <- NAMES[[kk]]
[16:01:43.741]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.741]                     next
[16:01:43.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:43.741]                 }
[16:01:43.741]                 NAMES <- toupper(added)
[16:01:43.741]                 for (kk in seq_along(NAMES)) {
[16:01:43.741]                   name <- added[[kk]]
[16:01:43.741]                   NAME <- NAMES[[kk]]
[16:01:43.741]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.741]                     next
[16:01:43.741]                   args[[name]] <- ""
[16:01:43.741]                 }
[16:01:43.741]                 NAMES <- toupper(removed)
[16:01:43.741]                 for (kk in seq_along(NAMES)) {
[16:01:43.741]                   name <- removed[[kk]]
[16:01:43.741]                   NAME <- NAMES[[kk]]
[16:01:43.741]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.741]                     next
[16:01:43.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:43.741]                 }
[16:01:43.741]                 if (length(args) > 0) 
[16:01:43.741]                   base::do.call(base::Sys.setenv, args = args)
[16:01:43.741]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:43.741]             }
[16:01:43.741]             else {
[16:01:43.741]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:43.741]             }
[16:01:43.741]             {
[16:01:43.741]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:43.741]                   0L) {
[16:01:43.741]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:43.741]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:43.741]                   base::options(opts)
[16:01:43.741]                 }
[16:01:43.741]                 {
[16:01:43.741]                   {
[16:01:43.741]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:43.741]                     NULL
[16:01:43.741]                   }
[16:01:43.741]                   options(future.plan = NULL)
[16:01:43.741]                   if (is.na(NA_character_)) 
[16:01:43.741]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:43.741]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:43.741]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:43.741]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:43.741]                     envir = parent.frame()) 
[16:01:43.741]                   {
[16:01:43.741]                     if (is.function(workers)) 
[16:01:43.741]                       workers <- workers()
[16:01:43.741]                     workers <- structure(as.integer(workers), 
[16:01:43.741]                       class = class(workers))
[16:01:43.741]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:43.741]                       workers >= 1)
[16:01:43.741]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:43.741]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:43.741]                     }
[16:01:43.741]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:43.741]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:43.741]                       envir = envir)
[16:01:43.741]                     if (!future$lazy) 
[16:01:43.741]                       future <- run(future)
[16:01:43.741]                     invisible(future)
[16:01:43.741]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:43.741]                 }
[16:01:43.741]             }
[16:01:43.741]         }
[16:01:43.741]     })
[16:01:43.741]     if (TRUE) {
[16:01:43.741]         base::sink(type = "output", split = FALSE)
[16:01:43.741]         if (TRUE) {
[16:01:43.741]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:43.741]         }
[16:01:43.741]         else {
[16:01:43.741]             ...future.result["stdout"] <- base::list(NULL)
[16:01:43.741]         }
[16:01:43.741]         base::close(...future.stdout)
[16:01:43.741]         ...future.stdout <- NULL
[16:01:43.741]     }
[16:01:43.741]     ...future.result$conditions <- ...future.conditions
[16:01:43.741]     ...future.result$finished <- base::Sys.time()
[16:01:43.741]     ...future.result
[16:01:43.741] }
[16:01:43.744] Exporting 5 global objects (960 bytes) to cluster node #1 ...
[16:01:43.744] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:01:43.745] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:01:43.745] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[16:01:43.745] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[16:01:43.745] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[16:01:43.745] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[16:01:43.746] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:01:43.746] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:01:43.746] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:01:43.746] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:01:43.746] Exporting 5 global objects (960 bytes) to cluster node #1 ... DONE
[16:01:43.747] MultisessionFuture started
[16:01:43.747] - Launch lazy future ... done
[16:01:43.747] run() for ‘MultisessionFuture’ ... done
[16:01:43.747] Created future:
[16:01:43.747] MultisessionFuture:
[16:01:43.747] Label: ‘future_apply-1’
[16:01:43.747] Expression:
[16:01:43.747] {
[16:01:43.747]     do.call(function(...) {
[16:01:43.747]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.747]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:43.747]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.747]             on.exit(options(oopts), add = TRUE)
[16:01:43.747]         }
[16:01:43.747]         {
[16:01:43.747]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:43.747]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.747]                 ...future.FUN(...future.X_jj, ...)
[16:01:43.747]             })
[16:01:43.747]         }
[16:01:43.747]     }, args = future.call.arguments)
[16:01:43.747] }
[16:01:43.747] Lazy evaluation: FALSE
[16:01:43.747] Asynchronous evaluation: TRUE
[16:01:43.747] Local evaluation: TRUE
[16:01:43.747] Environment: R_GlobalEnv
[16:01:43.747] Capture standard output: TRUE
[16:01:43.747] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:43.747] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:43.747] Packages: <none>
[16:01:43.747] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:43.747] Resolved: FALSE
[16:01:43.747] Value: <not collected>
[16:01:43.747] Conditions captured: <none>
[16:01:43.747] Early signaling: FALSE
[16:01:43.747] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:43.747] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:43.759] Chunk #1 of 2 ... DONE
[16:01:43.759] Chunk #2 of 2 ...
[16:01:43.760]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:43.760]  - seeds: <none>
[16:01:43.760]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.760] getGlobalsAndPackages() ...
[16:01:43.760] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.760] Resolving globals: FALSE
[16:01:43.760] Tweak future expression to call with '...' arguments ...
[16:01:43.760] {
[16:01:43.760]     do.call(function(...) {
[16:01:43.760]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.760]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:43.760]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.760]             on.exit(options(oopts), add = TRUE)
[16:01:43.760]         }
[16:01:43.760]         {
[16:01:43.760]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:43.760]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.760]                 ...future.FUN(...future.X_jj, ...)
[16:01:43.760]             })
[16:01:43.760]         }
[16:01:43.760]     }, args = future.call.arguments)
[16:01:43.760] }
[16:01:43.761] Tweak future expression to call with '...' arguments ... DONE
[16:01:43.761] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.761] 
[16:01:43.761] getGlobalsAndPackages() ... DONE
[16:01:43.762] run() for ‘Future’ ...
[16:01:43.762] - state: ‘created’
[16:01:43.762] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:43.776] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:43.776] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:43.776]   - Field: ‘node’
[16:01:43.776]   - Field: ‘label’
[16:01:43.776]   - Field: ‘local’
[16:01:43.777]   - Field: ‘owner’
[16:01:43.777]   - Field: ‘envir’
[16:01:43.777]   - Field: ‘workers’
[16:01:43.777]   - Field: ‘packages’
[16:01:43.777]   - Field: ‘gc’
[16:01:43.777]   - Field: ‘conditions’
[16:01:43.777]   - Field: ‘persistent’
[16:01:43.777]   - Field: ‘expr’
[16:01:43.777]   - Field: ‘uuid’
[16:01:43.777]   - Field: ‘seed’
[16:01:43.777]   - Field: ‘version’
[16:01:43.778]   - Field: ‘result’
[16:01:43.778]   - Field: ‘asynchronous’
[16:01:43.778]   - Field: ‘calls’
[16:01:43.778]   - Field: ‘globals’
[16:01:43.778]   - Field: ‘stdout’
[16:01:43.778]   - Field: ‘earlySignal’
[16:01:43.778]   - Field: ‘lazy’
[16:01:43.778]   - Field: ‘state’
[16:01:43.778] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:43.778] - Launch lazy future ...
[16:01:43.779] Packages needed by the future expression (n = 0): <none>
[16:01:43.779] Packages needed by future strategies (n = 0): <none>
[16:01:43.779] {
[16:01:43.779]     {
[16:01:43.779]         {
[16:01:43.779]             ...future.startTime <- base::Sys.time()
[16:01:43.779]             {
[16:01:43.779]                 {
[16:01:43.779]                   {
[16:01:43.779]                     {
[16:01:43.779]                       base::local({
[16:01:43.779]                         has_future <- base::requireNamespace("future", 
[16:01:43.779]                           quietly = TRUE)
[16:01:43.779]                         if (has_future) {
[16:01:43.779]                           ns <- base::getNamespace("future")
[16:01:43.779]                           version <- ns[[".package"]][["version"]]
[16:01:43.779]                           if (is.null(version)) 
[16:01:43.779]                             version <- utils::packageVersion("future")
[16:01:43.779]                         }
[16:01:43.779]                         else {
[16:01:43.779]                           version <- NULL
[16:01:43.779]                         }
[16:01:43.779]                         if (!has_future || version < "1.8.0") {
[16:01:43.779]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:43.779]                             "", base::R.version$version.string), 
[16:01:43.779]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:43.779]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:43.779]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:43.779]                               "release", "version")], collapse = " "), 
[16:01:43.779]                             hostname = base::Sys.info()[["nodename"]])
[16:01:43.779]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:43.779]                             info)
[16:01:43.779]                           info <- base::paste(info, collapse = "; ")
[16:01:43.779]                           if (!has_future) {
[16:01:43.779]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:43.779]                               info)
[16:01:43.779]                           }
[16:01:43.779]                           else {
[16:01:43.779]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:43.779]                               info, version)
[16:01:43.779]                           }
[16:01:43.779]                           base::stop(msg)
[16:01:43.779]                         }
[16:01:43.779]                       })
[16:01:43.779]                     }
[16:01:43.779]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:43.779]                     base::options(mc.cores = 1L)
[16:01:43.779]                   }
[16:01:43.779]                   options(future.plan = NULL)
[16:01:43.779]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:43.779]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:43.779]                 }
[16:01:43.779]                 ...future.workdir <- getwd()
[16:01:43.779]             }
[16:01:43.779]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:43.779]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:43.779]         }
[16:01:43.779]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:43.779]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:43.779]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:43.779]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:43.779]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:43.779]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:43.779]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:43.779]             base::names(...future.oldOptions))
[16:01:43.779]     }
[16:01:43.779]     if (FALSE) {
[16:01:43.779]     }
[16:01:43.779]     else {
[16:01:43.779]         if (TRUE) {
[16:01:43.779]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:43.779]                 open = "w")
[16:01:43.779]         }
[16:01:43.779]         else {
[16:01:43.779]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:43.779]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:43.779]         }
[16:01:43.779]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:43.779]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:43.779]             base::sink(type = "output", split = FALSE)
[16:01:43.779]             base::close(...future.stdout)
[16:01:43.779]         }, add = TRUE)
[16:01:43.779]     }
[16:01:43.779]     ...future.frame <- base::sys.nframe()
[16:01:43.779]     ...future.conditions <- base::list()
[16:01:43.779]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:43.779]     if (FALSE) {
[16:01:43.779]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:43.779]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:43.779]     }
[16:01:43.779]     ...future.result <- base::tryCatch({
[16:01:43.779]         base::withCallingHandlers({
[16:01:43.779]             ...future.value <- base::withVisible(base::local({
[16:01:43.779]                 ...future.makeSendCondition <- base::local({
[16:01:43.779]                   sendCondition <- NULL
[16:01:43.779]                   function(frame = 1L) {
[16:01:43.779]                     if (is.function(sendCondition)) 
[16:01:43.779]                       return(sendCondition)
[16:01:43.779]                     ns <- getNamespace("parallel")
[16:01:43.779]                     if (exists("sendData", mode = "function", 
[16:01:43.779]                       envir = ns)) {
[16:01:43.779]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:43.779]                         envir = ns)
[16:01:43.779]                       envir <- sys.frame(frame)
[16:01:43.779]                       master <- NULL
[16:01:43.779]                       while (!identical(envir, .GlobalEnv) && 
[16:01:43.779]                         !identical(envir, emptyenv())) {
[16:01:43.779]                         if (exists("master", mode = "list", envir = envir, 
[16:01:43.779]                           inherits = FALSE)) {
[16:01:43.779]                           master <- get("master", mode = "list", 
[16:01:43.779]                             envir = envir, inherits = FALSE)
[16:01:43.779]                           if (inherits(master, c("SOCKnode", 
[16:01:43.779]                             "SOCK0node"))) {
[16:01:43.779]                             sendCondition <<- function(cond) {
[16:01:43.779]                               data <- list(type = "VALUE", value = cond, 
[16:01:43.779]                                 success = TRUE)
[16:01:43.779]                               parallel_sendData(master, data)
[16:01:43.779]                             }
[16:01:43.779]                             return(sendCondition)
[16:01:43.779]                           }
[16:01:43.779]                         }
[16:01:43.779]                         frame <- frame + 1L
[16:01:43.779]                         envir <- sys.frame(frame)
[16:01:43.779]                       }
[16:01:43.779]                     }
[16:01:43.779]                     sendCondition <<- function(cond) NULL
[16:01:43.779]                   }
[16:01:43.779]                 })
[16:01:43.779]                 withCallingHandlers({
[16:01:43.779]                   {
[16:01:43.779]                     do.call(function(...) {
[16:01:43.779]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.779]                       if (!identical(...future.globals.maxSize.org, 
[16:01:43.779]                         ...future.globals.maxSize)) {
[16:01:43.779]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.779]                         on.exit(options(oopts), add = TRUE)
[16:01:43.779]                       }
[16:01:43.779]                       {
[16:01:43.779]                         lapply(seq_along(...future.elements_ii), 
[16:01:43.779]                           FUN = function(jj) {
[16:01:43.779]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.779]                             ...future.FUN(...future.X_jj, ...)
[16:01:43.779]                           })
[16:01:43.779]                       }
[16:01:43.779]                     }, args = future.call.arguments)
[16:01:43.779]                   }
[16:01:43.779]                 }, immediateCondition = function(cond) {
[16:01:43.779]                   sendCondition <- ...future.makeSendCondition()
[16:01:43.779]                   sendCondition(cond)
[16:01:43.779]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.779]                   {
[16:01:43.779]                     inherits <- base::inherits
[16:01:43.779]                     invokeRestart <- base::invokeRestart
[16:01:43.779]                     is.null <- base::is.null
[16:01:43.779]                     muffled <- FALSE
[16:01:43.779]                     if (inherits(cond, "message")) {
[16:01:43.779]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:43.779]                       if (muffled) 
[16:01:43.779]                         invokeRestart("muffleMessage")
[16:01:43.779]                     }
[16:01:43.779]                     else if (inherits(cond, "warning")) {
[16:01:43.779]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:43.779]                       if (muffled) 
[16:01:43.779]                         invokeRestart("muffleWarning")
[16:01:43.779]                     }
[16:01:43.779]                     else if (inherits(cond, "condition")) {
[16:01:43.779]                       if (!is.null(pattern)) {
[16:01:43.779]                         computeRestarts <- base::computeRestarts
[16:01:43.779]                         grepl <- base::grepl
[16:01:43.779]                         restarts <- computeRestarts(cond)
[16:01:43.779]                         for (restart in restarts) {
[16:01:43.779]                           name <- restart$name
[16:01:43.779]                           if (is.null(name)) 
[16:01:43.779]                             next
[16:01:43.779]                           if (!grepl(pattern, name)) 
[16:01:43.779]                             next
[16:01:43.779]                           invokeRestart(restart)
[16:01:43.779]                           muffled <- TRUE
[16:01:43.779]                           break
[16:01:43.779]                         }
[16:01:43.779]                       }
[16:01:43.779]                     }
[16:01:43.779]                     invisible(muffled)
[16:01:43.779]                   }
[16:01:43.779]                   muffleCondition(cond)
[16:01:43.779]                 })
[16:01:43.779]             }))
[16:01:43.779]             future::FutureResult(value = ...future.value$value, 
[16:01:43.779]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:43.779]                   ...future.rng), globalenv = if (FALSE) 
[16:01:43.779]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:43.779]                     ...future.globalenv.names))
[16:01:43.779]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:43.779]         }, condition = base::local({
[16:01:43.779]             c <- base::c
[16:01:43.779]             inherits <- base::inherits
[16:01:43.779]             invokeRestart <- base::invokeRestart
[16:01:43.779]             length <- base::length
[16:01:43.779]             list <- base::list
[16:01:43.779]             seq.int <- base::seq.int
[16:01:43.779]             signalCondition <- base::signalCondition
[16:01:43.779]             sys.calls <- base::sys.calls
[16:01:43.779]             `[[` <- base::`[[`
[16:01:43.779]             `+` <- base::`+`
[16:01:43.779]             `<<-` <- base::`<<-`
[16:01:43.779]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:43.779]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:43.779]                   3L)]
[16:01:43.779]             }
[16:01:43.779]             function(cond) {
[16:01:43.779]                 is_error <- inherits(cond, "error")
[16:01:43.779]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:43.779]                   NULL)
[16:01:43.779]                 if (is_error) {
[16:01:43.779]                   sessionInformation <- function() {
[16:01:43.779]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:43.779]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:43.779]                       search = base::search(), system = base::Sys.info())
[16:01:43.779]                   }
[16:01:43.779]                   ...future.conditions[[length(...future.conditions) + 
[16:01:43.779]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:43.779]                     cond$call), session = sessionInformation(), 
[16:01:43.779]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:43.779]                   signalCondition(cond)
[16:01:43.779]                 }
[16:01:43.779]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:43.779]                 "immediateCondition"))) {
[16:01:43.779]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:43.779]                   ...future.conditions[[length(...future.conditions) + 
[16:01:43.779]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:43.779]                   if (TRUE && !signal) {
[16:01:43.779]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.779]                     {
[16:01:43.779]                       inherits <- base::inherits
[16:01:43.779]                       invokeRestart <- base::invokeRestart
[16:01:43.779]                       is.null <- base::is.null
[16:01:43.779]                       muffled <- FALSE
[16:01:43.779]                       if (inherits(cond, "message")) {
[16:01:43.779]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:43.779]                         if (muffled) 
[16:01:43.779]                           invokeRestart("muffleMessage")
[16:01:43.779]                       }
[16:01:43.779]                       else if (inherits(cond, "warning")) {
[16:01:43.779]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:43.779]                         if (muffled) 
[16:01:43.779]                           invokeRestart("muffleWarning")
[16:01:43.779]                       }
[16:01:43.779]                       else if (inherits(cond, "condition")) {
[16:01:43.779]                         if (!is.null(pattern)) {
[16:01:43.779]                           computeRestarts <- base::computeRestarts
[16:01:43.779]                           grepl <- base::grepl
[16:01:43.779]                           restarts <- computeRestarts(cond)
[16:01:43.779]                           for (restart in restarts) {
[16:01:43.779]                             name <- restart$name
[16:01:43.779]                             if (is.null(name)) 
[16:01:43.779]                               next
[16:01:43.779]                             if (!grepl(pattern, name)) 
[16:01:43.779]                               next
[16:01:43.779]                             invokeRestart(restart)
[16:01:43.779]                             muffled <- TRUE
[16:01:43.779]                             break
[16:01:43.779]                           }
[16:01:43.779]                         }
[16:01:43.779]                       }
[16:01:43.779]                       invisible(muffled)
[16:01:43.779]                     }
[16:01:43.779]                     muffleCondition(cond, pattern = "^muffle")
[16:01:43.779]                   }
[16:01:43.779]                 }
[16:01:43.779]                 else {
[16:01:43.779]                   if (TRUE) {
[16:01:43.779]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.779]                     {
[16:01:43.779]                       inherits <- base::inherits
[16:01:43.779]                       invokeRestart <- base::invokeRestart
[16:01:43.779]                       is.null <- base::is.null
[16:01:43.779]                       muffled <- FALSE
[16:01:43.779]                       if (inherits(cond, "message")) {
[16:01:43.779]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:43.779]                         if (muffled) 
[16:01:43.779]                           invokeRestart("muffleMessage")
[16:01:43.779]                       }
[16:01:43.779]                       else if (inherits(cond, "warning")) {
[16:01:43.779]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:43.779]                         if (muffled) 
[16:01:43.779]                           invokeRestart("muffleWarning")
[16:01:43.779]                       }
[16:01:43.779]                       else if (inherits(cond, "condition")) {
[16:01:43.779]                         if (!is.null(pattern)) {
[16:01:43.779]                           computeRestarts <- base::computeRestarts
[16:01:43.779]                           grepl <- base::grepl
[16:01:43.779]                           restarts <- computeRestarts(cond)
[16:01:43.779]                           for (restart in restarts) {
[16:01:43.779]                             name <- restart$name
[16:01:43.779]                             if (is.null(name)) 
[16:01:43.779]                               next
[16:01:43.779]                             if (!grepl(pattern, name)) 
[16:01:43.779]                               next
[16:01:43.779]                             invokeRestart(restart)
[16:01:43.779]                             muffled <- TRUE
[16:01:43.779]                             break
[16:01:43.779]                           }
[16:01:43.779]                         }
[16:01:43.779]                       }
[16:01:43.779]                       invisible(muffled)
[16:01:43.779]                     }
[16:01:43.779]                     muffleCondition(cond, pattern = "^muffle")
[16:01:43.779]                   }
[16:01:43.779]                 }
[16:01:43.779]             }
[16:01:43.779]         }))
[16:01:43.779]     }, error = function(ex) {
[16:01:43.779]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:43.779]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:43.779]                 ...future.rng), started = ...future.startTime, 
[16:01:43.779]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:43.779]             version = "1.8"), class = "FutureResult")
[16:01:43.779]     }, finally = {
[16:01:43.779]         if (!identical(...future.workdir, getwd())) 
[16:01:43.779]             setwd(...future.workdir)
[16:01:43.779]         {
[16:01:43.779]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:43.779]                 ...future.oldOptions$nwarnings <- NULL
[16:01:43.779]             }
[16:01:43.779]             base::options(...future.oldOptions)
[16:01:43.779]             if (.Platform$OS.type == "windows") {
[16:01:43.779]                 old_names <- names(...future.oldEnvVars)
[16:01:43.779]                 envs <- base::Sys.getenv()
[16:01:43.779]                 names <- names(envs)
[16:01:43.779]                 common <- intersect(names, old_names)
[16:01:43.779]                 added <- setdiff(names, old_names)
[16:01:43.779]                 removed <- setdiff(old_names, names)
[16:01:43.779]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:43.779]                   envs[common]]
[16:01:43.779]                 NAMES <- toupper(changed)
[16:01:43.779]                 args <- list()
[16:01:43.779]                 for (kk in seq_along(NAMES)) {
[16:01:43.779]                   name <- changed[[kk]]
[16:01:43.779]                   NAME <- NAMES[[kk]]
[16:01:43.779]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.779]                     next
[16:01:43.779]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:43.779]                 }
[16:01:43.779]                 NAMES <- toupper(added)
[16:01:43.779]                 for (kk in seq_along(NAMES)) {
[16:01:43.779]                   name <- added[[kk]]
[16:01:43.779]                   NAME <- NAMES[[kk]]
[16:01:43.779]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.779]                     next
[16:01:43.779]                   args[[name]] <- ""
[16:01:43.779]                 }
[16:01:43.779]                 NAMES <- toupper(removed)
[16:01:43.779]                 for (kk in seq_along(NAMES)) {
[16:01:43.779]                   name <- removed[[kk]]
[16:01:43.779]                   NAME <- NAMES[[kk]]
[16:01:43.779]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.779]                     next
[16:01:43.779]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:43.779]                 }
[16:01:43.779]                 if (length(args) > 0) 
[16:01:43.779]                   base::do.call(base::Sys.setenv, args = args)
[16:01:43.779]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:43.779]             }
[16:01:43.779]             else {
[16:01:43.779]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:43.779]             }
[16:01:43.779]             {
[16:01:43.779]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:43.779]                   0L) {
[16:01:43.779]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:43.779]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:43.779]                   base::options(opts)
[16:01:43.779]                 }
[16:01:43.779]                 {
[16:01:43.779]                   {
[16:01:43.779]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:43.779]                     NULL
[16:01:43.779]                   }
[16:01:43.779]                   options(future.plan = NULL)
[16:01:43.779]                   if (is.na(NA_character_)) 
[16:01:43.779]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:43.779]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:43.779]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:43.779]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:43.779]                     envir = parent.frame()) 
[16:01:43.779]                   {
[16:01:43.779]                     if (is.function(workers)) 
[16:01:43.779]                       workers <- workers()
[16:01:43.779]                     workers <- structure(as.integer(workers), 
[16:01:43.779]                       class = class(workers))
[16:01:43.779]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:43.779]                       workers >= 1)
[16:01:43.779]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:43.779]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:43.779]                     }
[16:01:43.779]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:43.779]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:43.779]                       envir = envir)
[16:01:43.779]                     if (!future$lazy) 
[16:01:43.779]                       future <- run(future)
[16:01:43.779]                     invisible(future)
[16:01:43.779]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:43.779]                 }
[16:01:43.779]             }
[16:01:43.779]         }
[16:01:43.779]     })
[16:01:43.779]     if (TRUE) {
[16:01:43.779]         base::sink(type = "output", split = FALSE)
[16:01:43.779]         if (TRUE) {
[16:01:43.779]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:43.779]         }
[16:01:43.779]         else {
[16:01:43.779]             ...future.result["stdout"] <- base::list(NULL)
[16:01:43.779]         }
[16:01:43.779]         base::close(...future.stdout)
[16:01:43.779]         ...future.stdout <- NULL
[16:01:43.779]     }
[16:01:43.779]     ...future.result$conditions <- ...future.conditions
[16:01:43.779]     ...future.result$finished <- base::Sys.time()
[16:01:43.779]     ...future.result
[16:01:43.779] }
[16:01:43.783] Exporting 5 global objects (960 bytes) to cluster node #2 ...
[16:01:43.783] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:01:43.783] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:01:43.783] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[16:01:43.784] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[16:01:43.784] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[16:01:43.784] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[16:01:43.784] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:01:43.784] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:01:43.785] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[16:01:43.785] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[16:01:43.785] Exporting 5 global objects (960 bytes) to cluster node #2 ... DONE
[16:01:43.785] MultisessionFuture started
[16:01:43.786] - Launch lazy future ... done
[16:01:43.786] run() for ‘MultisessionFuture’ ... done
[16:01:43.786] Created future:
[16:01:43.786] MultisessionFuture:
[16:01:43.786] Label: ‘future_apply-2’
[16:01:43.786] Expression:
[16:01:43.786] {
[16:01:43.786]     do.call(function(...) {
[16:01:43.786]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.786]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:43.786]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.786]             on.exit(options(oopts), add = TRUE)
[16:01:43.786]         }
[16:01:43.786]         {
[16:01:43.786]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:43.786]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.786]                 ...future.FUN(...future.X_jj, ...)
[16:01:43.786]             })
[16:01:43.786]         }
[16:01:43.786]     }, args = future.call.arguments)
[16:01:43.786] }
[16:01:43.786] Lazy evaluation: FALSE
[16:01:43.786] Asynchronous evaluation: TRUE
[16:01:43.786] Local evaluation: TRUE
[16:01:43.786] Environment: R_GlobalEnv
[16:01:43.786] Capture standard output: TRUE
[16:01:43.786] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:43.786] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:43.786] Packages: <none>
[16:01:43.786] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:43.786] Resolved: FALSE
[16:01:43.786] Value: <not collected>
[16:01:43.786] Conditions captured: <none>
[16:01:43.786] Early signaling: FALSE
[16:01:43.786] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:43.786] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:43.798] Chunk #2 of 2 ... DONE
[16:01:43.798] Launching 2 futures (chunks) ... DONE
[16:01:43.798] Resolving 2 futures (chunks) ...
[16:01:43.798] resolve() on list ...
[16:01:43.798]  recursive: 0
[16:01:43.799]  length: 2
[16:01:43.799] 
[16:01:43.800] receiveMessageFromWorker() for ClusterFuture ...
[16:01:43.801] - Validating connection of MultisessionFuture
[16:01:43.801] - received message: FutureResult
[16:01:43.801] - Received FutureResult
[16:01:43.801] - Erased future from FutureRegistry
[16:01:43.801] result() for ClusterFuture ...
[16:01:43.801] - result already collected: FutureResult
[16:01:43.801] result() for ClusterFuture ... done
[16:01:43.801] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:43.802] Future #1
[16:01:43.802] result() for ClusterFuture ...
[16:01:43.802] - result already collected: FutureResult
[16:01:43.802] result() for ClusterFuture ... done
[16:01:43.802] result() for ClusterFuture ...
[16:01:43.802] - result already collected: FutureResult
[16:01:43.802] result() for ClusterFuture ... done
[16:01:43.802] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:01:43.802] - nx: 2
[16:01:43.802] - relay: TRUE
[16:01:43.802] - stdout: TRUE
[16:01:43.803] - signal: TRUE
[16:01:43.803] - resignal: FALSE
[16:01:43.803] - force: TRUE
[16:01:43.803] - relayed: [n=2] FALSE, FALSE
[16:01:43.803] - queued futures: [n=2] FALSE, FALSE
[16:01:43.803]  - until=1
[16:01:43.803]  - relaying element #1
[16:01:43.803] result() for ClusterFuture ...
[16:01:43.803] - result already collected: FutureResult
[16:01:43.803] result() for ClusterFuture ... done
[16:01:43.803] result() for ClusterFuture ...
[16:01:43.804] - result already collected: FutureResult
[16:01:43.804] result() for ClusterFuture ... done
[16:01:43.804] result() for ClusterFuture ...
[16:01:43.804] - result already collected: FutureResult
[16:01:43.804] result() for ClusterFuture ... done
[16:01:43.804] result() for ClusterFuture ...
[16:01:43.804] - result already collected: FutureResult
[16:01:43.804] result() for ClusterFuture ... done
[16:01:43.804] - relayed: [n=2] TRUE, FALSE
[16:01:43.804] - queued futures: [n=2] TRUE, FALSE
[16:01:43.804] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:01:43.805]  length: 1 (resolved future 1)
[16:01:43.832] receiveMessageFromWorker() for ClusterFuture ...
[16:01:43.832] - Validating connection of MultisessionFuture
[16:01:43.832] - received message: FutureResult
[16:01:43.833] - Received FutureResult
[16:01:43.833] - Erased future from FutureRegistry
[16:01:43.833] result() for ClusterFuture ...
[16:01:43.833] - result already collected: FutureResult
[16:01:43.833] result() for ClusterFuture ... done
[16:01:43.833] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:43.833] Future #2
[16:01:43.833] result() for ClusterFuture ...
[16:01:43.833] - result already collected: FutureResult
[16:01:43.833] result() for ClusterFuture ... done
[16:01:43.834] result() for ClusterFuture ...
[16:01:43.834] - result already collected: FutureResult
[16:01:43.834] result() for ClusterFuture ... done
[16:01:43.834] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:01:43.834] - nx: 2
[16:01:43.834] - relay: TRUE
[16:01:43.834] - stdout: TRUE
[16:01:43.834] - signal: TRUE
[16:01:43.834] - resignal: FALSE
[16:01:43.834] - force: TRUE
[16:01:43.834] - relayed: [n=2] TRUE, FALSE
[16:01:43.835] - queued futures: [n=2] TRUE, FALSE
[16:01:43.835]  - until=2
[16:01:43.835]  - relaying element #2
[16:01:43.835] result() for ClusterFuture ...
[16:01:43.835] - result already collected: FutureResult
[16:01:43.835] result() for ClusterFuture ... done
[16:01:43.835] result() for ClusterFuture ...
[16:01:43.835] - result already collected: FutureResult
[16:01:43.835] result() for ClusterFuture ... done
[16:01:43.835] result() for ClusterFuture ...
[16:01:43.836] - result already collected: FutureResult
[16:01:43.836] result() for ClusterFuture ... done
[16:01:43.836] result() for ClusterFuture ...
[16:01:43.836] - result already collected: FutureResult
[16:01:43.836] result() for ClusterFuture ... done
[16:01:43.836] - relayed: [n=2] TRUE, TRUE
[16:01:43.836] - queued futures: [n=2] TRUE, TRUE
[16:01:43.836] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:01:43.836]  length: 0 (resolved future 2)
[16:01:43.836] Relaying remaining futures
[16:01:43.836] signalConditionsASAP(NULL, pos=0) ...
[16:01:43.837] - nx: 2
[16:01:43.837] - relay: TRUE
[16:01:43.837] - stdout: TRUE
[16:01:43.837] - signal: TRUE
[16:01:43.837] - resignal: FALSE
[16:01:43.837] - force: TRUE
[16:01:43.837] - relayed: [n=2] TRUE, TRUE
[16:01:43.837] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:43.837] - relayed: [n=2] TRUE, TRUE
[16:01:43.837] - queued futures: [n=2] TRUE, TRUE
[16:01:43.837] signalConditionsASAP(NULL, pos=0) ... done
[16:01:43.838] resolve() on list ... DONE
[16:01:43.838] result() for ClusterFuture ...
[16:01:43.838] - result already collected: FutureResult
[16:01:43.838] result() for ClusterFuture ... done
[16:01:43.838] result() for ClusterFuture ...
[16:01:43.838] - result already collected: FutureResult
[16:01:43.838] result() for ClusterFuture ... done
[16:01:43.838] result() for ClusterFuture ...
[16:01:43.838] - result already collected: FutureResult
[16:01:43.838] result() for ClusterFuture ... done
[16:01:43.838] result() for ClusterFuture ...
[16:01:43.838] - result already collected: FutureResult
[16:01:43.839] result() for ClusterFuture ... done
[16:01:43.839]  - Number of value chunks collected: 2
[16:01:43.839] Resolving 2 futures (chunks) ... DONE
[16:01:43.839] Reducing values from 2 chunks ...
[16:01:43.839]  - Number of values collected after concatenation: 2
[16:01:43.839]  - Number of values expected: 2
[16:01:43.839] Reducing values from 2 chunks ... DONE
[16:01:43.839] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[16:01:43.840] getGlobalsAndPackagesXApply() ...
[16:01:43.840]  - future.globals: TRUE
[16:01:43.840] getGlobalsAndPackages() ...
[16:01:43.840] Searching for globals...
[16:01:43.841] - globals found: [1] ‘FUN’
[16:01:43.841] Searching for globals ... DONE
[16:01:43.841] Resolving globals: FALSE
[16:01:43.842] The total size of the 1 globals is 848 bytes (848 bytes)
[16:01:43.842] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:01:43.842] - globals: [1] ‘FUN’
[16:01:43.842] 
[16:01:43.842] getGlobalsAndPackages() ... DONE
[16:01:43.842]  - globals found/used: [n=1] ‘FUN’
[16:01:43.842]  - needed namespaces: [n=0] 
[16:01:43.842] Finding globals ... DONE
[16:01:43.843]  - use_args: TRUE
[16:01:43.843]  - Getting '...' globals ...
[16:01:43.843] resolve() on list ...
[16:01:43.843]  recursive: 0
[16:01:43.843]  length: 1
[16:01:43.843]  elements: ‘...’
[16:01:43.843]  length: 0 (resolved future 1)
[16:01:43.844] resolve() on list ... DONE
[16:01:43.844]    - '...' content: [n=0] 
[16:01:43.844] List of 1
[16:01:43.844]  $ ...: list()
[16:01:43.844]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:43.844]  - attr(*, "where")=List of 1
[16:01:43.844]   ..$ ...:<environment: 0x55fb6644d7f8> 
[16:01:43.844]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:43.844]  - attr(*, "resolved")= logi TRUE
[16:01:43.844]  - attr(*, "total_size")= num NA
[16:01:43.846]  - Getting '...' globals ... DONE
[16:01:43.846] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:43.846] List of 2
[16:01:43.846]  $ ...future.FUN:function (x)  
[16:01:43.846]  $ ...          : list()
[16:01:43.846]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:43.846]  - attr(*, "where")=List of 2
[16:01:43.846]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:43.846]   ..$ ...          :<environment: 0x55fb6644d7f8> 
[16:01:43.846]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:43.846]  - attr(*, "resolved")= logi FALSE
[16:01:43.846]  - attr(*, "total_size")= num 848
[16:01:43.849] Packages to be attached in all futures: [n=0] 
[16:01:43.849] getGlobalsAndPackagesXApply() ... DONE
[16:01:43.853] future_lapply() ...
[16:01:43.859] Number of chunks: 2
[16:01:43.859] getGlobalsAndPackagesXApply() ...
[16:01:43.859]  - future.globals: <name-value list> with names ‘list()’
[16:01:43.860]  - use_args: TRUE
[16:01:43.860] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:01:43.860] List of 2
[16:01:43.860]  $ ...          : list()
[16:01:43.860]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:43.860]  $ ...future.FUN:function (x)  
[16:01:43.860]  - attr(*, "where")=List of 2
[16:01:43.860]   ..$ ...          :<environment: 0x55fb6644d7f8> 
[16:01:43.860]   ..$ ...future.FUN:<environment: namespace:base> 
[16:01:43.860]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:43.860]  - attr(*, "resolved")= logi FALSE
[16:01:43.860]  - attr(*, "total_size")= num NA
[16:01:43.863] Packages to be attached in all futures: [n=0] 
[16:01:43.863] getGlobalsAndPackagesXApply() ... DONE
[16:01:43.863] Number of futures (= number of chunks): 2
[16:01:43.864] Launching 2 futures (chunks) ...
[16:01:43.864] Chunk #1 of 2 ...
[16:01:43.864]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:43.864]  - seeds: <none>
[16:01:43.864]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.864] getGlobalsAndPackages() ...
[16:01:43.864] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.864] Resolving globals: FALSE
[16:01:43.864] Tweak future expression to call with '...' arguments ...
[16:01:43.865] {
[16:01:43.865]     do.call(function(...) {
[16:01:43.865]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.865]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:43.865]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.865]             on.exit(options(oopts), add = TRUE)
[16:01:43.865]         }
[16:01:43.865]         {
[16:01:43.865]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:43.865]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.865]                 ...future.FUN(...future.X_jj, ...)
[16:01:43.865]             })
[16:01:43.865]         }
[16:01:43.865]     }, args = future.call.arguments)
[16:01:43.865] }
[16:01:43.865] Tweak future expression to call with '...' arguments ... DONE
[16:01:43.865] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.865] 
[16:01:43.865] getGlobalsAndPackages() ... DONE
[16:01:43.866] run() for ‘Future’ ...
[16:01:43.866] - state: ‘created’
[16:01:43.866] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:43.881] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:43.881] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:43.881]   - Field: ‘node’
[16:01:43.881]   - Field: ‘label’
[16:01:43.881]   - Field: ‘local’
[16:01:43.881]   - Field: ‘owner’
[16:01:43.881]   - Field: ‘envir’
[16:01:43.881]   - Field: ‘workers’
[16:01:43.881]   - Field: ‘packages’
[16:01:43.882]   - Field: ‘gc’
[16:01:43.882]   - Field: ‘conditions’
[16:01:43.882]   - Field: ‘persistent’
[16:01:43.882]   - Field: ‘expr’
[16:01:43.882]   - Field: ‘uuid’
[16:01:43.882]   - Field: ‘seed’
[16:01:43.882]   - Field: ‘version’
[16:01:43.882]   - Field: ‘result’
[16:01:43.882]   - Field: ‘asynchronous’
[16:01:43.882]   - Field: ‘calls’
[16:01:43.882]   - Field: ‘globals’
[16:01:43.883]   - Field: ‘stdout’
[16:01:43.883]   - Field: ‘earlySignal’
[16:01:43.883]   - Field: ‘lazy’
[16:01:43.883]   - Field: ‘state’
[16:01:43.883] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:43.883] - Launch lazy future ...
[16:01:43.883] Packages needed by the future expression (n = 0): <none>
[16:01:43.884] Packages needed by future strategies (n = 0): <none>
[16:01:43.884] {
[16:01:43.884]     {
[16:01:43.884]         {
[16:01:43.884]             ...future.startTime <- base::Sys.time()
[16:01:43.884]             {
[16:01:43.884]                 {
[16:01:43.884]                   {
[16:01:43.884]                     {
[16:01:43.884]                       base::local({
[16:01:43.884]                         has_future <- base::requireNamespace("future", 
[16:01:43.884]                           quietly = TRUE)
[16:01:43.884]                         if (has_future) {
[16:01:43.884]                           ns <- base::getNamespace("future")
[16:01:43.884]                           version <- ns[[".package"]][["version"]]
[16:01:43.884]                           if (is.null(version)) 
[16:01:43.884]                             version <- utils::packageVersion("future")
[16:01:43.884]                         }
[16:01:43.884]                         else {
[16:01:43.884]                           version <- NULL
[16:01:43.884]                         }
[16:01:43.884]                         if (!has_future || version < "1.8.0") {
[16:01:43.884]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:43.884]                             "", base::R.version$version.string), 
[16:01:43.884]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:43.884]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:43.884]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:43.884]                               "release", "version")], collapse = " "), 
[16:01:43.884]                             hostname = base::Sys.info()[["nodename"]])
[16:01:43.884]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:43.884]                             info)
[16:01:43.884]                           info <- base::paste(info, collapse = "; ")
[16:01:43.884]                           if (!has_future) {
[16:01:43.884]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:43.884]                               info)
[16:01:43.884]                           }
[16:01:43.884]                           else {
[16:01:43.884]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:43.884]                               info, version)
[16:01:43.884]                           }
[16:01:43.884]                           base::stop(msg)
[16:01:43.884]                         }
[16:01:43.884]                       })
[16:01:43.884]                     }
[16:01:43.884]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:43.884]                     base::options(mc.cores = 1L)
[16:01:43.884]                   }
[16:01:43.884]                   options(future.plan = NULL)
[16:01:43.884]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:43.884]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:43.884]                 }
[16:01:43.884]                 ...future.workdir <- getwd()
[16:01:43.884]             }
[16:01:43.884]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:43.884]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:43.884]         }
[16:01:43.884]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:43.884]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:43.884]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:43.884]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:43.884]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:43.884]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:43.884]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:43.884]             base::names(...future.oldOptions))
[16:01:43.884]     }
[16:01:43.884]     if (FALSE) {
[16:01:43.884]     }
[16:01:43.884]     else {
[16:01:43.884]         if (TRUE) {
[16:01:43.884]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:43.884]                 open = "w")
[16:01:43.884]         }
[16:01:43.884]         else {
[16:01:43.884]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:43.884]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:43.884]         }
[16:01:43.884]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:43.884]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:43.884]             base::sink(type = "output", split = FALSE)
[16:01:43.884]             base::close(...future.stdout)
[16:01:43.884]         }, add = TRUE)
[16:01:43.884]     }
[16:01:43.884]     ...future.frame <- base::sys.nframe()
[16:01:43.884]     ...future.conditions <- base::list()
[16:01:43.884]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:43.884]     if (FALSE) {
[16:01:43.884]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:43.884]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:43.884]     }
[16:01:43.884]     ...future.result <- base::tryCatch({
[16:01:43.884]         base::withCallingHandlers({
[16:01:43.884]             ...future.value <- base::withVisible(base::local({
[16:01:43.884]                 ...future.makeSendCondition <- base::local({
[16:01:43.884]                   sendCondition <- NULL
[16:01:43.884]                   function(frame = 1L) {
[16:01:43.884]                     if (is.function(sendCondition)) 
[16:01:43.884]                       return(sendCondition)
[16:01:43.884]                     ns <- getNamespace("parallel")
[16:01:43.884]                     if (exists("sendData", mode = "function", 
[16:01:43.884]                       envir = ns)) {
[16:01:43.884]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:43.884]                         envir = ns)
[16:01:43.884]                       envir <- sys.frame(frame)
[16:01:43.884]                       master <- NULL
[16:01:43.884]                       while (!identical(envir, .GlobalEnv) && 
[16:01:43.884]                         !identical(envir, emptyenv())) {
[16:01:43.884]                         if (exists("master", mode = "list", envir = envir, 
[16:01:43.884]                           inherits = FALSE)) {
[16:01:43.884]                           master <- get("master", mode = "list", 
[16:01:43.884]                             envir = envir, inherits = FALSE)
[16:01:43.884]                           if (inherits(master, c("SOCKnode", 
[16:01:43.884]                             "SOCK0node"))) {
[16:01:43.884]                             sendCondition <<- function(cond) {
[16:01:43.884]                               data <- list(type = "VALUE", value = cond, 
[16:01:43.884]                                 success = TRUE)
[16:01:43.884]                               parallel_sendData(master, data)
[16:01:43.884]                             }
[16:01:43.884]                             return(sendCondition)
[16:01:43.884]                           }
[16:01:43.884]                         }
[16:01:43.884]                         frame <- frame + 1L
[16:01:43.884]                         envir <- sys.frame(frame)
[16:01:43.884]                       }
[16:01:43.884]                     }
[16:01:43.884]                     sendCondition <<- function(cond) NULL
[16:01:43.884]                   }
[16:01:43.884]                 })
[16:01:43.884]                 withCallingHandlers({
[16:01:43.884]                   {
[16:01:43.884]                     do.call(function(...) {
[16:01:43.884]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.884]                       if (!identical(...future.globals.maxSize.org, 
[16:01:43.884]                         ...future.globals.maxSize)) {
[16:01:43.884]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.884]                         on.exit(options(oopts), add = TRUE)
[16:01:43.884]                       }
[16:01:43.884]                       {
[16:01:43.884]                         lapply(seq_along(...future.elements_ii), 
[16:01:43.884]                           FUN = function(jj) {
[16:01:43.884]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.884]                             ...future.FUN(...future.X_jj, ...)
[16:01:43.884]                           })
[16:01:43.884]                       }
[16:01:43.884]                     }, args = future.call.arguments)
[16:01:43.884]                   }
[16:01:43.884]                 }, immediateCondition = function(cond) {
[16:01:43.884]                   sendCondition <- ...future.makeSendCondition()
[16:01:43.884]                   sendCondition(cond)
[16:01:43.884]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.884]                   {
[16:01:43.884]                     inherits <- base::inherits
[16:01:43.884]                     invokeRestart <- base::invokeRestart
[16:01:43.884]                     is.null <- base::is.null
[16:01:43.884]                     muffled <- FALSE
[16:01:43.884]                     if (inherits(cond, "message")) {
[16:01:43.884]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:43.884]                       if (muffled) 
[16:01:43.884]                         invokeRestart("muffleMessage")
[16:01:43.884]                     }
[16:01:43.884]                     else if (inherits(cond, "warning")) {
[16:01:43.884]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:43.884]                       if (muffled) 
[16:01:43.884]                         invokeRestart("muffleWarning")
[16:01:43.884]                     }
[16:01:43.884]                     else if (inherits(cond, "condition")) {
[16:01:43.884]                       if (!is.null(pattern)) {
[16:01:43.884]                         computeRestarts <- base::computeRestarts
[16:01:43.884]                         grepl <- base::grepl
[16:01:43.884]                         restarts <- computeRestarts(cond)
[16:01:43.884]                         for (restart in restarts) {
[16:01:43.884]                           name <- restart$name
[16:01:43.884]                           if (is.null(name)) 
[16:01:43.884]                             next
[16:01:43.884]                           if (!grepl(pattern, name)) 
[16:01:43.884]                             next
[16:01:43.884]                           invokeRestart(restart)
[16:01:43.884]                           muffled <- TRUE
[16:01:43.884]                           break
[16:01:43.884]                         }
[16:01:43.884]                       }
[16:01:43.884]                     }
[16:01:43.884]                     invisible(muffled)
[16:01:43.884]                   }
[16:01:43.884]                   muffleCondition(cond)
[16:01:43.884]                 })
[16:01:43.884]             }))
[16:01:43.884]             future::FutureResult(value = ...future.value$value, 
[16:01:43.884]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:43.884]                   ...future.rng), globalenv = if (FALSE) 
[16:01:43.884]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:43.884]                     ...future.globalenv.names))
[16:01:43.884]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:43.884]         }, condition = base::local({
[16:01:43.884]             c <- base::c
[16:01:43.884]             inherits <- base::inherits
[16:01:43.884]             invokeRestart <- base::invokeRestart
[16:01:43.884]             length <- base::length
[16:01:43.884]             list <- base::list
[16:01:43.884]             seq.int <- base::seq.int
[16:01:43.884]             signalCondition <- base::signalCondition
[16:01:43.884]             sys.calls <- base::sys.calls
[16:01:43.884]             `[[` <- base::`[[`
[16:01:43.884]             `+` <- base::`+`
[16:01:43.884]             `<<-` <- base::`<<-`
[16:01:43.884]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:43.884]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:43.884]                   3L)]
[16:01:43.884]             }
[16:01:43.884]             function(cond) {
[16:01:43.884]                 is_error <- inherits(cond, "error")
[16:01:43.884]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:43.884]                   NULL)
[16:01:43.884]                 if (is_error) {
[16:01:43.884]                   sessionInformation <- function() {
[16:01:43.884]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:43.884]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:43.884]                       search = base::search(), system = base::Sys.info())
[16:01:43.884]                   }
[16:01:43.884]                   ...future.conditions[[length(...future.conditions) + 
[16:01:43.884]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:43.884]                     cond$call), session = sessionInformation(), 
[16:01:43.884]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:43.884]                   signalCondition(cond)
[16:01:43.884]                 }
[16:01:43.884]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:43.884]                 "immediateCondition"))) {
[16:01:43.884]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:43.884]                   ...future.conditions[[length(...future.conditions) + 
[16:01:43.884]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:43.884]                   if (TRUE && !signal) {
[16:01:43.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.884]                     {
[16:01:43.884]                       inherits <- base::inherits
[16:01:43.884]                       invokeRestart <- base::invokeRestart
[16:01:43.884]                       is.null <- base::is.null
[16:01:43.884]                       muffled <- FALSE
[16:01:43.884]                       if (inherits(cond, "message")) {
[16:01:43.884]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:43.884]                         if (muffled) 
[16:01:43.884]                           invokeRestart("muffleMessage")
[16:01:43.884]                       }
[16:01:43.884]                       else if (inherits(cond, "warning")) {
[16:01:43.884]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:43.884]                         if (muffled) 
[16:01:43.884]                           invokeRestart("muffleWarning")
[16:01:43.884]                       }
[16:01:43.884]                       else if (inherits(cond, "condition")) {
[16:01:43.884]                         if (!is.null(pattern)) {
[16:01:43.884]                           computeRestarts <- base::computeRestarts
[16:01:43.884]                           grepl <- base::grepl
[16:01:43.884]                           restarts <- computeRestarts(cond)
[16:01:43.884]                           for (restart in restarts) {
[16:01:43.884]                             name <- restart$name
[16:01:43.884]                             if (is.null(name)) 
[16:01:43.884]                               next
[16:01:43.884]                             if (!grepl(pattern, name)) 
[16:01:43.884]                               next
[16:01:43.884]                             invokeRestart(restart)
[16:01:43.884]                             muffled <- TRUE
[16:01:43.884]                             break
[16:01:43.884]                           }
[16:01:43.884]                         }
[16:01:43.884]                       }
[16:01:43.884]                       invisible(muffled)
[16:01:43.884]                     }
[16:01:43.884]                     muffleCondition(cond, pattern = "^muffle")
[16:01:43.884]                   }
[16:01:43.884]                 }
[16:01:43.884]                 else {
[16:01:43.884]                   if (TRUE) {
[16:01:43.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.884]                     {
[16:01:43.884]                       inherits <- base::inherits
[16:01:43.884]                       invokeRestart <- base::invokeRestart
[16:01:43.884]                       is.null <- base::is.null
[16:01:43.884]                       muffled <- FALSE
[16:01:43.884]                       if (inherits(cond, "message")) {
[16:01:43.884]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:43.884]                         if (muffled) 
[16:01:43.884]                           invokeRestart("muffleMessage")
[16:01:43.884]                       }
[16:01:43.884]                       else if (inherits(cond, "warning")) {
[16:01:43.884]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:43.884]                         if (muffled) 
[16:01:43.884]                           invokeRestart("muffleWarning")
[16:01:43.884]                       }
[16:01:43.884]                       else if (inherits(cond, "condition")) {
[16:01:43.884]                         if (!is.null(pattern)) {
[16:01:43.884]                           computeRestarts <- base::computeRestarts
[16:01:43.884]                           grepl <- base::grepl
[16:01:43.884]                           restarts <- computeRestarts(cond)
[16:01:43.884]                           for (restart in restarts) {
[16:01:43.884]                             name <- restart$name
[16:01:43.884]                             if (is.null(name)) 
[16:01:43.884]                               next
[16:01:43.884]                             if (!grepl(pattern, name)) 
[16:01:43.884]                               next
[16:01:43.884]                             invokeRestart(restart)
[16:01:43.884]                             muffled <- TRUE
[16:01:43.884]                             break
[16:01:43.884]                           }
[16:01:43.884]                         }
[16:01:43.884]                       }
[16:01:43.884]                       invisible(muffled)
[16:01:43.884]                     }
[16:01:43.884]                     muffleCondition(cond, pattern = "^muffle")
[16:01:43.884]                   }
[16:01:43.884]                 }
[16:01:43.884]             }
[16:01:43.884]         }))
[16:01:43.884]     }, error = function(ex) {
[16:01:43.884]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:43.884]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:43.884]                 ...future.rng), started = ...future.startTime, 
[16:01:43.884]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:43.884]             version = "1.8"), class = "FutureResult")
[16:01:43.884]     }, finally = {
[16:01:43.884]         if (!identical(...future.workdir, getwd())) 
[16:01:43.884]             setwd(...future.workdir)
[16:01:43.884]         {
[16:01:43.884]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:43.884]                 ...future.oldOptions$nwarnings <- NULL
[16:01:43.884]             }
[16:01:43.884]             base::options(...future.oldOptions)
[16:01:43.884]             if (.Platform$OS.type == "windows") {
[16:01:43.884]                 old_names <- names(...future.oldEnvVars)
[16:01:43.884]                 envs <- base::Sys.getenv()
[16:01:43.884]                 names <- names(envs)
[16:01:43.884]                 common <- intersect(names, old_names)
[16:01:43.884]                 added <- setdiff(names, old_names)
[16:01:43.884]                 removed <- setdiff(old_names, names)
[16:01:43.884]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:43.884]                   envs[common]]
[16:01:43.884]                 NAMES <- toupper(changed)
[16:01:43.884]                 args <- list()
[16:01:43.884]                 for (kk in seq_along(NAMES)) {
[16:01:43.884]                   name <- changed[[kk]]
[16:01:43.884]                   NAME <- NAMES[[kk]]
[16:01:43.884]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.884]                     next
[16:01:43.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:43.884]                 }
[16:01:43.884]                 NAMES <- toupper(added)
[16:01:43.884]                 for (kk in seq_along(NAMES)) {
[16:01:43.884]                   name <- added[[kk]]
[16:01:43.884]                   NAME <- NAMES[[kk]]
[16:01:43.884]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.884]                     next
[16:01:43.884]                   args[[name]] <- ""
[16:01:43.884]                 }
[16:01:43.884]                 NAMES <- toupper(removed)
[16:01:43.884]                 for (kk in seq_along(NAMES)) {
[16:01:43.884]                   name <- removed[[kk]]
[16:01:43.884]                   NAME <- NAMES[[kk]]
[16:01:43.884]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.884]                     next
[16:01:43.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:43.884]                 }
[16:01:43.884]                 if (length(args) > 0) 
[16:01:43.884]                   base::do.call(base::Sys.setenv, args = args)
[16:01:43.884]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:43.884]             }
[16:01:43.884]             else {
[16:01:43.884]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:43.884]             }
[16:01:43.884]             {
[16:01:43.884]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:43.884]                   0L) {
[16:01:43.884]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:43.884]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:43.884]                   base::options(opts)
[16:01:43.884]                 }
[16:01:43.884]                 {
[16:01:43.884]                   {
[16:01:43.884]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:43.884]                     NULL
[16:01:43.884]                   }
[16:01:43.884]                   options(future.plan = NULL)
[16:01:43.884]                   if (is.na(NA_character_)) 
[16:01:43.884]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:43.884]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:43.884]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:43.884]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:43.884]                     envir = parent.frame()) 
[16:01:43.884]                   {
[16:01:43.884]                     if (is.function(workers)) 
[16:01:43.884]                       workers <- workers()
[16:01:43.884]                     workers <- structure(as.integer(workers), 
[16:01:43.884]                       class = class(workers))
[16:01:43.884]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:43.884]                       workers >= 1)
[16:01:43.884]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:43.884]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:43.884]                     }
[16:01:43.884]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:43.884]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:43.884]                       envir = envir)
[16:01:43.884]                     if (!future$lazy) 
[16:01:43.884]                       future <- run(future)
[16:01:43.884]                     invisible(future)
[16:01:43.884]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:43.884]                 }
[16:01:43.884]             }
[16:01:43.884]         }
[16:01:43.884]     })
[16:01:43.884]     if (TRUE) {
[16:01:43.884]         base::sink(type = "output", split = FALSE)
[16:01:43.884]         if (TRUE) {
[16:01:43.884]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:43.884]         }
[16:01:43.884]         else {
[16:01:43.884]             ...future.result["stdout"] <- base::list(NULL)
[16:01:43.884]         }
[16:01:43.884]         base::close(...future.stdout)
[16:01:43.884]         ...future.stdout <- NULL
[16:01:43.884]     }
[16:01:43.884]     ...future.result$conditions <- ...future.conditions
[16:01:43.884]     ...future.result$finished <- base::Sys.time()
[16:01:43.884]     ...future.result
[16:01:43.884] }
[16:01:43.887] Exporting 5 global objects (1.12 KiB) to cluster node #1 ...
[16:01:43.888] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:01:43.888] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:01:43.888] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[16:01:43.888] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[16:01:43.888] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #1 ...
[16:01:43.889] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #1 ... DONE
[16:01:43.889] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:01:43.889] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:01:43.889] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:01:43.890] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:01:43.890] Exporting 5 global objects (1.12 KiB) to cluster node #1 ... DONE
[16:01:43.890] MultisessionFuture started
[16:01:43.890] - Launch lazy future ... done
[16:01:43.890] run() for ‘MultisessionFuture’ ... done
[16:01:43.891] Created future:
[16:01:43.891] MultisessionFuture:
[16:01:43.891] Label: ‘future_apply-1’
[16:01:43.891] Expression:
[16:01:43.891] {
[16:01:43.891]     do.call(function(...) {
[16:01:43.891]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.891]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:43.891]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.891]             on.exit(options(oopts), add = TRUE)
[16:01:43.891]         }
[16:01:43.891]         {
[16:01:43.891]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:43.891]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.891]                 ...future.FUN(...future.X_jj, ...)
[16:01:43.891]             })
[16:01:43.891]         }
[16:01:43.891]     }, args = future.call.arguments)
[16:01:43.891] }
[16:01:43.891] Lazy evaluation: FALSE
[16:01:43.891] Asynchronous evaluation: TRUE
[16:01:43.891] Local evaluation: TRUE
[16:01:43.891] Environment: R_GlobalEnv
[16:01:43.891] Capture standard output: TRUE
[16:01:43.891] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:43.891] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:43.891] Packages: <none>
[16:01:43.891] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:43.891] Resolved: FALSE
[16:01:43.891] Value: <not collected>
[16:01:43.891] Conditions captured: <none>
[16:01:43.891] Early signaling: FALSE
[16:01:43.891] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:43.891] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:43.902] Chunk #1 of 2 ... DONE
[16:01:43.903] Chunk #2 of 2 ...
[16:01:43.903]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:43.903]  - seeds: <none>
[16:01:43.903]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.903] getGlobalsAndPackages() ...
[16:01:43.903] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.903] Resolving globals: FALSE
[16:01:43.904] Tweak future expression to call with '...' arguments ...
[16:01:43.904] {
[16:01:43.904]     do.call(function(...) {
[16:01:43.904]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.904]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:43.904]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.904]             on.exit(options(oopts), add = TRUE)
[16:01:43.904]         }
[16:01:43.904]         {
[16:01:43.904]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:43.904]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.904]                 ...future.FUN(...future.X_jj, ...)
[16:01:43.904]             })
[16:01:43.904]         }
[16:01:43.904]     }, args = future.call.arguments)
[16:01:43.904] }
[16:01:43.904] Tweak future expression to call with '...' arguments ... DONE
[16:01:43.904] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:43.905] 
[16:01:43.905] getGlobalsAndPackages() ... DONE
[16:01:43.905] run() for ‘Future’ ...
[16:01:43.905] - state: ‘created’
[16:01:43.905] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:43.920] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:43.920] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:43.920]   - Field: ‘node’
[16:01:43.920]   - Field: ‘label’
[16:01:43.920]   - Field: ‘local’
[16:01:43.921]   - Field: ‘owner’
[16:01:43.921]   - Field: ‘envir’
[16:01:43.921]   - Field: ‘workers’
[16:01:43.921]   - Field: ‘packages’
[16:01:43.921]   - Field: ‘gc’
[16:01:43.921]   - Field: ‘conditions’
[16:01:43.921]   - Field: ‘persistent’
[16:01:43.921]   - Field: ‘expr’
[16:01:43.921]   - Field: ‘uuid’
[16:01:43.921]   - Field: ‘seed’
[16:01:43.921]   - Field: ‘version’
[16:01:43.922]   - Field: ‘result’
[16:01:43.922]   - Field: ‘asynchronous’
[16:01:43.922]   - Field: ‘calls’
[16:01:43.922]   - Field: ‘globals’
[16:01:43.922]   - Field: ‘stdout’
[16:01:43.922]   - Field: ‘earlySignal’
[16:01:43.922]   - Field: ‘lazy’
[16:01:43.922]   - Field: ‘state’
[16:01:43.922] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:43.922] - Launch lazy future ...
[16:01:43.923] Packages needed by the future expression (n = 0): <none>
[16:01:43.923] Packages needed by future strategies (n = 0): <none>
[16:01:43.923] {
[16:01:43.923]     {
[16:01:43.923]         {
[16:01:43.923]             ...future.startTime <- base::Sys.time()
[16:01:43.923]             {
[16:01:43.923]                 {
[16:01:43.923]                   {
[16:01:43.923]                     {
[16:01:43.923]                       base::local({
[16:01:43.923]                         has_future <- base::requireNamespace("future", 
[16:01:43.923]                           quietly = TRUE)
[16:01:43.923]                         if (has_future) {
[16:01:43.923]                           ns <- base::getNamespace("future")
[16:01:43.923]                           version <- ns[[".package"]][["version"]]
[16:01:43.923]                           if (is.null(version)) 
[16:01:43.923]                             version <- utils::packageVersion("future")
[16:01:43.923]                         }
[16:01:43.923]                         else {
[16:01:43.923]                           version <- NULL
[16:01:43.923]                         }
[16:01:43.923]                         if (!has_future || version < "1.8.0") {
[16:01:43.923]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:43.923]                             "", base::R.version$version.string), 
[16:01:43.923]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:43.923]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:43.923]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:43.923]                               "release", "version")], collapse = " "), 
[16:01:43.923]                             hostname = base::Sys.info()[["nodename"]])
[16:01:43.923]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:43.923]                             info)
[16:01:43.923]                           info <- base::paste(info, collapse = "; ")
[16:01:43.923]                           if (!has_future) {
[16:01:43.923]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:43.923]                               info)
[16:01:43.923]                           }
[16:01:43.923]                           else {
[16:01:43.923]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:43.923]                               info, version)
[16:01:43.923]                           }
[16:01:43.923]                           base::stop(msg)
[16:01:43.923]                         }
[16:01:43.923]                       })
[16:01:43.923]                     }
[16:01:43.923]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:43.923]                     base::options(mc.cores = 1L)
[16:01:43.923]                   }
[16:01:43.923]                   options(future.plan = NULL)
[16:01:43.923]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:43.923]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:43.923]                 }
[16:01:43.923]                 ...future.workdir <- getwd()
[16:01:43.923]             }
[16:01:43.923]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:43.923]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:43.923]         }
[16:01:43.923]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:43.923]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:43.923]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:43.923]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:43.923]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:43.923]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:43.923]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:43.923]             base::names(...future.oldOptions))
[16:01:43.923]     }
[16:01:43.923]     if (FALSE) {
[16:01:43.923]     }
[16:01:43.923]     else {
[16:01:43.923]         if (TRUE) {
[16:01:43.923]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:43.923]                 open = "w")
[16:01:43.923]         }
[16:01:43.923]         else {
[16:01:43.923]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:43.923]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:43.923]         }
[16:01:43.923]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:43.923]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:43.923]             base::sink(type = "output", split = FALSE)
[16:01:43.923]             base::close(...future.stdout)
[16:01:43.923]         }, add = TRUE)
[16:01:43.923]     }
[16:01:43.923]     ...future.frame <- base::sys.nframe()
[16:01:43.923]     ...future.conditions <- base::list()
[16:01:43.923]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:43.923]     if (FALSE) {
[16:01:43.923]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:43.923]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:43.923]     }
[16:01:43.923]     ...future.result <- base::tryCatch({
[16:01:43.923]         base::withCallingHandlers({
[16:01:43.923]             ...future.value <- base::withVisible(base::local({
[16:01:43.923]                 ...future.makeSendCondition <- base::local({
[16:01:43.923]                   sendCondition <- NULL
[16:01:43.923]                   function(frame = 1L) {
[16:01:43.923]                     if (is.function(sendCondition)) 
[16:01:43.923]                       return(sendCondition)
[16:01:43.923]                     ns <- getNamespace("parallel")
[16:01:43.923]                     if (exists("sendData", mode = "function", 
[16:01:43.923]                       envir = ns)) {
[16:01:43.923]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:43.923]                         envir = ns)
[16:01:43.923]                       envir <- sys.frame(frame)
[16:01:43.923]                       master <- NULL
[16:01:43.923]                       while (!identical(envir, .GlobalEnv) && 
[16:01:43.923]                         !identical(envir, emptyenv())) {
[16:01:43.923]                         if (exists("master", mode = "list", envir = envir, 
[16:01:43.923]                           inherits = FALSE)) {
[16:01:43.923]                           master <- get("master", mode = "list", 
[16:01:43.923]                             envir = envir, inherits = FALSE)
[16:01:43.923]                           if (inherits(master, c("SOCKnode", 
[16:01:43.923]                             "SOCK0node"))) {
[16:01:43.923]                             sendCondition <<- function(cond) {
[16:01:43.923]                               data <- list(type = "VALUE", value = cond, 
[16:01:43.923]                                 success = TRUE)
[16:01:43.923]                               parallel_sendData(master, data)
[16:01:43.923]                             }
[16:01:43.923]                             return(sendCondition)
[16:01:43.923]                           }
[16:01:43.923]                         }
[16:01:43.923]                         frame <- frame + 1L
[16:01:43.923]                         envir <- sys.frame(frame)
[16:01:43.923]                       }
[16:01:43.923]                     }
[16:01:43.923]                     sendCondition <<- function(cond) NULL
[16:01:43.923]                   }
[16:01:43.923]                 })
[16:01:43.923]                 withCallingHandlers({
[16:01:43.923]                   {
[16:01:43.923]                     do.call(function(...) {
[16:01:43.923]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.923]                       if (!identical(...future.globals.maxSize.org, 
[16:01:43.923]                         ...future.globals.maxSize)) {
[16:01:43.923]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.923]                         on.exit(options(oopts), add = TRUE)
[16:01:43.923]                       }
[16:01:43.923]                       {
[16:01:43.923]                         lapply(seq_along(...future.elements_ii), 
[16:01:43.923]                           FUN = function(jj) {
[16:01:43.923]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.923]                             ...future.FUN(...future.X_jj, ...)
[16:01:43.923]                           })
[16:01:43.923]                       }
[16:01:43.923]                     }, args = future.call.arguments)
[16:01:43.923]                   }
[16:01:43.923]                 }, immediateCondition = function(cond) {
[16:01:43.923]                   sendCondition <- ...future.makeSendCondition()
[16:01:43.923]                   sendCondition(cond)
[16:01:43.923]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.923]                   {
[16:01:43.923]                     inherits <- base::inherits
[16:01:43.923]                     invokeRestart <- base::invokeRestart
[16:01:43.923]                     is.null <- base::is.null
[16:01:43.923]                     muffled <- FALSE
[16:01:43.923]                     if (inherits(cond, "message")) {
[16:01:43.923]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:43.923]                       if (muffled) 
[16:01:43.923]                         invokeRestart("muffleMessage")
[16:01:43.923]                     }
[16:01:43.923]                     else if (inherits(cond, "warning")) {
[16:01:43.923]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:43.923]                       if (muffled) 
[16:01:43.923]                         invokeRestart("muffleWarning")
[16:01:43.923]                     }
[16:01:43.923]                     else if (inherits(cond, "condition")) {
[16:01:43.923]                       if (!is.null(pattern)) {
[16:01:43.923]                         computeRestarts <- base::computeRestarts
[16:01:43.923]                         grepl <- base::grepl
[16:01:43.923]                         restarts <- computeRestarts(cond)
[16:01:43.923]                         for (restart in restarts) {
[16:01:43.923]                           name <- restart$name
[16:01:43.923]                           if (is.null(name)) 
[16:01:43.923]                             next
[16:01:43.923]                           if (!grepl(pattern, name)) 
[16:01:43.923]                             next
[16:01:43.923]                           invokeRestart(restart)
[16:01:43.923]                           muffled <- TRUE
[16:01:43.923]                           break
[16:01:43.923]                         }
[16:01:43.923]                       }
[16:01:43.923]                     }
[16:01:43.923]                     invisible(muffled)
[16:01:43.923]                   }
[16:01:43.923]                   muffleCondition(cond)
[16:01:43.923]                 })
[16:01:43.923]             }))
[16:01:43.923]             future::FutureResult(value = ...future.value$value, 
[16:01:43.923]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:43.923]                   ...future.rng), globalenv = if (FALSE) 
[16:01:43.923]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:43.923]                     ...future.globalenv.names))
[16:01:43.923]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:43.923]         }, condition = base::local({
[16:01:43.923]             c <- base::c
[16:01:43.923]             inherits <- base::inherits
[16:01:43.923]             invokeRestart <- base::invokeRestart
[16:01:43.923]             length <- base::length
[16:01:43.923]             list <- base::list
[16:01:43.923]             seq.int <- base::seq.int
[16:01:43.923]             signalCondition <- base::signalCondition
[16:01:43.923]             sys.calls <- base::sys.calls
[16:01:43.923]             `[[` <- base::`[[`
[16:01:43.923]             `+` <- base::`+`
[16:01:43.923]             `<<-` <- base::`<<-`
[16:01:43.923]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:43.923]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:43.923]                   3L)]
[16:01:43.923]             }
[16:01:43.923]             function(cond) {
[16:01:43.923]                 is_error <- inherits(cond, "error")
[16:01:43.923]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:43.923]                   NULL)
[16:01:43.923]                 if (is_error) {
[16:01:43.923]                   sessionInformation <- function() {
[16:01:43.923]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:43.923]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:43.923]                       search = base::search(), system = base::Sys.info())
[16:01:43.923]                   }
[16:01:43.923]                   ...future.conditions[[length(...future.conditions) + 
[16:01:43.923]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:43.923]                     cond$call), session = sessionInformation(), 
[16:01:43.923]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:43.923]                   signalCondition(cond)
[16:01:43.923]                 }
[16:01:43.923]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:43.923]                 "immediateCondition"))) {
[16:01:43.923]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:43.923]                   ...future.conditions[[length(...future.conditions) + 
[16:01:43.923]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:43.923]                   if (TRUE && !signal) {
[16:01:43.923]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.923]                     {
[16:01:43.923]                       inherits <- base::inherits
[16:01:43.923]                       invokeRestart <- base::invokeRestart
[16:01:43.923]                       is.null <- base::is.null
[16:01:43.923]                       muffled <- FALSE
[16:01:43.923]                       if (inherits(cond, "message")) {
[16:01:43.923]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:43.923]                         if (muffled) 
[16:01:43.923]                           invokeRestart("muffleMessage")
[16:01:43.923]                       }
[16:01:43.923]                       else if (inherits(cond, "warning")) {
[16:01:43.923]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:43.923]                         if (muffled) 
[16:01:43.923]                           invokeRestart("muffleWarning")
[16:01:43.923]                       }
[16:01:43.923]                       else if (inherits(cond, "condition")) {
[16:01:43.923]                         if (!is.null(pattern)) {
[16:01:43.923]                           computeRestarts <- base::computeRestarts
[16:01:43.923]                           grepl <- base::grepl
[16:01:43.923]                           restarts <- computeRestarts(cond)
[16:01:43.923]                           for (restart in restarts) {
[16:01:43.923]                             name <- restart$name
[16:01:43.923]                             if (is.null(name)) 
[16:01:43.923]                               next
[16:01:43.923]                             if (!grepl(pattern, name)) 
[16:01:43.923]                               next
[16:01:43.923]                             invokeRestart(restart)
[16:01:43.923]                             muffled <- TRUE
[16:01:43.923]                             break
[16:01:43.923]                           }
[16:01:43.923]                         }
[16:01:43.923]                       }
[16:01:43.923]                       invisible(muffled)
[16:01:43.923]                     }
[16:01:43.923]                     muffleCondition(cond, pattern = "^muffle")
[16:01:43.923]                   }
[16:01:43.923]                 }
[16:01:43.923]                 else {
[16:01:43.923]                   if (TRUE) {
[16:01:43.923]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:43.923]                     {
[16:01:43.923]                       inherits <- base::inherits
[16:01:43.923]                       invokeRestart <- base::invokeRestart
[16:01:43.923]                       is.null <- base::is.null
[16:01:43.923]                       muffled <- FALSE
[16:01:43.923]                       if (inherits(cond, "message")) {
[16:01:43.923]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:43.923]                         if (muffled) 
[16:01:43.923]                           invokeRestart("muffleMessage")
[16:01:43.923]                       }
[16:01:43.923]                       else if (inherits(cond, "warning")) {
[16:01:43.923]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:43.923]                         if (muffled) 
[16:01:43.923]                           invokeRestart("muffleWarning")
[16:01:43.923]                       }
[16:01:43.923]                       else if (inherits(cond, "condition")) {
[16:01:43.923]                         if (!is.null(pattern)) {
[16:01:43.923]                           computeRestarts <- base::computeRestarts
[16:01:43.923]                           grepl <- base::grepl
[16:01:43.923]                           restarts <- computeRestarts(cond)
[16:01:43.923]                           for (restart in restarts) {
[16:01:43.923]                             name <- restart$name
[16:01:43.923]                             if (is.null(name)) 
[16:01:43.923]                               next
[16:01:43.923]                             if (!grepl(pattern, name)) 
[16:01:43.923]                               next
[16:01:43.923]                             invokeRestart(restart)
[16:01:43.923]                             muffled <- TRUE
[16:01:43.923]                             break
[16:01:43.923]                           }
[16:01:43.923]                         }
[16:01:43.923]                       }
[16:01:43.923]                       invisible(muffled)
[16:01:43.923]                     }
[16:01:43.923]                     muffleCondition(cond, pattern = "^muffle")
[16:01:43.923]                   }
[16:01:43.923]                 }
[16:01:43.923]             }
[16:01:43.923]         }))
[16:01:43.923]     }, error = function(ex) {
[16:01:43.923]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:43.923]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:43.923]                 ...future.rng), started = ...future.startTime, 
[16:01:43.923]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:43.923]             version = "1.8"), class = "FutureResult")
[16:01:43.923]     }, finally = {
[16:01:43.923]         if (!identical(...future.workdir, getwd())) 
[16:01:43.923]             setwd(...future.workdir)
[16:01:43.923]         {
[16:01:43.923]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:43.923]                 ...future.oldOptions$nwarnings <- NULL
[16:01:43.923]             }
[16:01:43.923]             base::options(...future.oldOptions)
[16:01:43.923]             if (.Platform$OS.type == "windows") {
[16:01:43.923]                 old_names <- names(...future.oldEnvVars)
[16:01:43.923]                 envs <- base::Sys.getenv()
[16:01:43.923]                 names <- names(envs)
[16:01:43.923]                 common <- intersect(names, old_names)
[16:01:43.923]                 added <- setdiff(names, old_names)
[16:01:43.923]                 removed <- setdiff(old_names, names)
[16:01:43.923]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:43.923]                   envs[common]]
[16:01:43.923]                 NAMES <- toupper(changed)
[16:01:43.923]                 args <- list()
[16:01:43.923]                 for (kk in seq_along(NAMES)) {
[16:01:43.923]                   name <- changed[[kk]]
[16:01:43.923]                   NAME <- NAMES[[kk]]
[16:01:43.923]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.923]                     next
[16:01:43.923]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:43.923]                 }
[16:01:43.923]                 NAMES <- toupper(added)
[16:01:43.923]                 for (kk in seq_along(NAMES)) {
[16:01:43.923]                   name <- added[[kk]]
[16:01:43.923]                   NAME <- NAMES[[kk]]
[16:01:43.923]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.923]                     next
[16:01:43.923]                   args[[name]] <- ""
[16:01:43.923]                 }
[16:01:43.923]                 NAMES <- toupper(removed)
[16:01:43.923]                 for (kk in seq_along(NAMES)) {
[16:01:43.923]                   name <- removed[[kk]]
[16:01:43.923]                   NAME <- NAMES[[kk]]
[16:01:43.923]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:43.923]                     next
[16:01:43.923]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:43.923]                 }
[16:01:43.923]                 if (length(args) > 0) 
[16:01:43.923]                   base::do.call(base::Sys.setenv, args = args)
[16:01:43.923]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:43.923]             }
[16:01:43.923]             else {
[16:01:43.923]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:43.923]             }
[16:01:43.923]             {
[16:01:43.923]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:43.923]                   0L) {
[16:01:43.923]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:43.923]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:43.923]                   base::options(opts)
[16:01:43.923]                 }
[16:01:43.923]                 {
[16:01:43.923]                   {
[16:01:43.923]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:43.923]                     NULL
[16:01:43.923]                   }
[16:01:43.923]                   options(future.plan = NULL)
[16:01:43.923]                   if (is.na(NA_character_)) 
[16:01:43.923]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:43.923]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:43.923]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:43.923]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:43.923]                     envir = parent.frame()) 
[16:01:43.923]                   {
[16:01:43.923]                     if (is.function(workers)) 
[16:01:43.923]                       workers <- workers()
[16:01:43.923]                     workers <- structure(as.integer(workers), 
[16:01:43.923]                       class = class(workers))
[16:01:43.923]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:43.923]                       workers >= 1)
[16:01:43.923]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:43.923]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:43.923]                     }
[16:01:43.923]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:43.923]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:43.923]                       envir = envir)
[16:01:43.923]                     if (!future$lazy) 
[16:01:43.923]                       future <- run(future)
[16:01:43.923]                     invisible(future)
[16:01:43.923]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:43.923]                 }
[16:01:43.923]             }
[16:01:43.923]         }
[16:01:43.923]     })
[16:01:43.923]     if (TRUE) {
[16:01:43.923]         base::sink(type = "output", split = FALSE)
[16:01:43.923]         if (TRUE) {
[16:01:43.923]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:43.923]         }
[16:01:43.923]         else {
[16:01:43.923]             ...future.result["stdout"] <- base::list(NULL)
[16:01:43.923]         }
[16:01:43.923]         base::close(...future.stdout)
[16:01:43.923]         ...future.stdout <- NULL
[16:01:43.923]     }
[16:01:43.923]     ...future.result$conditions <- ...future.conditions
[16:01:43.923]     ...future.result$finished <- base::Sys.time()
[16:01:43.923]     ...future.result
[16:01:43.923] }
[16:01:43.927] Exporting 5 global objects (1.12 KiB) to cluster node #2 ...
[16:01:43.927] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:01:43.927] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:01:43.927] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[16:01:43.928] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[16:01:43.928] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #2 ...
[16:01:43.928] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #2 ... DONE
[16:01:43.928] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:01:43.929] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:01:43.929] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[16:01:43.929] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[16:01:43.929] Exporting 5 global objects (1.12 KiB) to cluster node #2 ... DONE
[16:01:43.930] MultisessionFuture started
[16:01:43.930] - Launch lazy future ... done
[16:01:43.930] run() for ‘MultisessionFuture’ ... done
[16:01:43.930] Created future:
[16:01:43.930] MultisessionFuture:
[16:01:43.930] Label: ‘future_apply-2’
[16:01:43.930] Expression:
[16:01:43.930] {
[16:01:43.930]     do.call(function(...) {
[16:01:43.930]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:43.930]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:43.930]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:43.930]             on.exit(options(oopts), add = TRUE)
[16:01:43.930]         }
[16:01:43.930]         {
[16:01:43.930]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:43.930]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:43.930]                 ...future.FUN(...future.X_jj, ...)
[16:01:43.930]             })
[16:01:43.930]         }
[16:01:43.930]     }, args = future.call.arguments)
[16:01:43.930] }
[16:01:43.930] Lazy evaluation: FALSE
[16:01:43.930] Asynchronous evaluation: TRUE
[16:01:43.930] Local evaluation: TRUE
[16:01:43.930] Environment: R_GlobalEnv
[16:01:43.930] Capture standard output: TRUE
[16:01:43.930] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:43.930] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:43.930] Packages: <none>
[16:01:43.930] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:43.930] Resolved: FALSE
[16:01:43.930] Value: <not collected>
[16:01:43.930] Conditions captured: <none>
[16:01:43.930] Early signaling: FALSE
[16:01:43.930] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:43.930] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:43.942] Chunk #2 of 2 ... DONE
[16:01:43.942] Launching 2 futures (chunks) ... DONE
[16:01:43.942] Resolving 2 futures (chunks) ...
[16:01:43.942] resolve() on list ...
[16:01:43.942]  recursive: 0
[16:01:43.943]  length: 2
[16:01:43.943] 
[16:01:43.943] receiveMessageFromWorker() for ClusterFuture ...
[16:01:43.943] - Validating connection of MultisessionFuture
[16:01:43.943] - received message: FutureResult
[16:01:43.944] - Received FutureResult
[16:01:43.944] - Erased future from FutureRegistry
[16:01:43.944] result() for ClusterFuture ...
[16:01:43.944] - result already collected: FutureResult
[16:01:43.944] result() for ClusterFuture ... done
[16:01:43.944] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:43.944] Future #1
[16:01:43.944] result() for ClusterFuture ...
[16:01:43.944] - result already collected: FutureResult
[16:01:43.944] result() for ClusterFuture ... done
[16:01:43.945] result() for ClusterFuture ...
[16:01:43.945] - result already collected: FutureResult
[16:01:43.945] result() for ClusterFuture ... done
[16:01:43.945] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:01:43.945] - nx: 2
[16:01:43.945] - relay: TRUE
[16:01:43.945] - stdout: TRUE
[16:01:43.945] - signal: TRUE
[16:01:43.945] - resignal: FALSE
[16:01:43.945] - force: TRUE
[16:01:43.945] - relayed: [n=2] FALSE, FALSE
[16:01:43.946] - queued futures: [n=2] FALSE, FALSE
[16:01:43.946]  - until=1
[16:01:43.946]  - relaying element #1
[16:01:43.946] result() for ClusterFuture ...
[16:01:43.946] - result already collected: FutureResult
[16:01:43.946] result() for ClusterFuture ... done
[16:01:43.946] result() for ClusterFuture ...
[16:01:43.946] - result already collected: FutureResult
[16:01:43.946] result() for ClusterFuture ... done
[16:01:43.946] result() for ClusterFuture ...
[16:01:43.946] - result already collected: FutureResult
[16:01:43.947] result() for ClusterFuture ... done
[16:01:43.947] result() for ClusterFuture ...
[16:01:43.947] - result already collected: FutureResult
[16:01:43.947] result() for ClusterFuture ... done
[16:01:43.947] - relayed: [n=2] TRUE, FALSE
[16:01:43.947] - queued futures: [n=2] TRUE, FALSE
[16:01:43.947] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:01:43.947]  length: 1 (resolved future 1)
[16:01:43.976] receiveMessageFromWorker() for ClusterFuture ...
[16:01:43.976] - Validating connection of MultisessionFuture
[16:01:43.977] - received message: FutureResult
[16:01:43.977] - Received FutureResult
[16:01:43.977] - Erased future from FutureRegistry
[16:01:43.977] result() for ClusterFuture ...
[16:01:43.977] - result already collected: FutureResult
[16:01:43.977] result() for ClusterFuture ... done
[16:01:43.977] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:43.977] Future #2
[16:01:43.978] result() for ClusterFuture ...
[16:01:43.978] - result already collected: FutureResult
[16:01:43.978] result() for ClusterFuture ... done
[16:01:43.978] result() for ClusterFuture ...
[16:01:43.978] - result already collected: FutureResult
[16:01:43.978] result() for ClusterFuture ... done
[16:01:43.978] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:01:43.978] - nx: 2
[16:01:43.978] - relay: TRUE
[16:01:43.978] - stdout: TRUE
[16:01:43.978] - signal: TRUE
[16:01:43.979] - resignal: FALSE
[16:01:43.979] - force: TRUE
[16:01:43.979] - relayed: [n=2] TRUE, FALSE
[16:01:43.979] - queued futures: [n=2] TRUE, FALSE
[16:01:43.979]  - until=2
[16:01:43.979]  - relaying element #2
[16:01:43.979] result() for ClusterFuture ...
[16:01:43.979] - result already collected: FutureResult
[16:01:43.979] result() for ClusterFuture ... done
[16:01:43.979] result() for ClusterFuture ...
[16:01:43.979] - result already collected: FutureResult
[16:01:43.980] result() for ClusterFuture ... done
[16:01:43.980] result() for ClusterFuture ...
[16:01:43.980] - result already collected: FutureResult
[16:01:43.980] result() for ClusterFuture ... done
[16:01:43.980] result() for ClusterFuture ...
[16:01:43.980] - result already collected: FutureResult
[16:01:43.980] result() for ClusterFuture ... done
[16:01:43.980] - relayed: [n=2] TRUE, TRUE
[16:01:43.980] - queued futures: [n=2] TRUE, TRUE
[16:01:43.980] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:01:43.980]  length: 0 (resolved future 2)
[16:01:43.981] Relaying remaining futures
[16:01:43.981] signalConditionsASAP(NULL, pos=0) ...
[16:01:43.981] - nx: 2
[16:01:43.981] - relay: TRUE
[16:01:43.981] - stdout: TRUE
[16:01:43.981] - signal: TRUE
[16:01:43.981] - resignal: FALSE
[16:01:43.981] - force: TRUE
[16:01:43.981] - relayed: [n=2] TRUE, TRUE
[16:01:43.981] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:43.981] - relayed: [n=2] TRUE, TRUE
[16:01:43.982] - queued futures: [n=2] TRUE, TRUE
[16:01:43.982] signalConditionsASAP(NULL, pos=0) ... done
[16:01:43.982] resolve() on list ... DONE
[16:01:43.982] result() for ClusterFuture ...
[16:01:43.982] - result already collected: FutureResult
[16:01:43.982] result() for ClusterFuture ... done
[16:01:43.982] result() for ClusterFuture ...
[16:01:43.982] - result already collected: FutureResult
[16:01:43.982] result() for ClusterFuture ... done
[16:01:43.982] result() for ClusterFuture ...
[16:01:43.982] - result already collected: FutureResult
[16:01:43.983] result() for ClusterFuture ... done
[16:01:43.983] result() for ClusterFuture ...
[16:01:43.983] - result already collected: FutureResult
[16:01:43.983] result() for ClusterFuture ... done
[16:01:43.983]  - Number of value chunks collected: 2
[16:01:43.983] Resolving 2 futures (chunks) ... DONE
[16:01:43.983] Reducing values from 2 chunks ...
[16:01:43.983]  - Number of values collected after concatenation: 2
[16:01:43.983]  - Number of values expected: 2
[16:01:43.983] Reducing values from 2 chunks ... DONE
[16:01:43.984] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[16:01:43.984] getGlobalsAndPackagesXApply() ...
[16:01:43.984]  - future.globals: TRUE
[16:01:43.984] getGlobalsAndPackages() ...
[16:01:43.984] Searching for globals...
[16:01:43.987] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[16:01:43.987] Searching for globals ... DONE
[16:01:43.987] Resolving globals: FALSE
[16:01:43.987] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[16:01:43.988] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[16:01:43.988] - globals: [1] ‘FUN’
[16:01:43.988] 
[16:01:43.988] getGlobalsAndPackages() ... DONE
[16:01:43.988]  - globals found/used: [n=1] ‘FUN’
[16:01:43.988]  - needed namespaces: [n=0] 
[16:01:43.988] Finding globals ... DONE
[16:01:43.989]  - use_args: TRUE
[16:01:43.989]  - Getting '...' globals ...
[16:01:43.989] resolve() on list ...
[16:01:43.989]  recursive: 0
[16:01:43.989]  length: 1
[16:01:43.989]  elements: ‘...’
[16:01:43.989]  length: 0 (resolved future 1)
[16:01:43.989] resolve() on list ... DONE
[16:01:43.990]    - '...' content: [n=0] 
[16:01:43.990] List of 1
[16:01:43.990]  $ ...: list()
[16:01:43.990]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:43.990]  - attr(*, "where")=List of 1
[16:01:43.990]   ..$ ...:<environment: 0x55fb65c2dfb0> 
[16:01:43.990]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:43.990]  - attr(*, "resolved")= logi TRUE
[16:01:43.990]  - attr(*, "total_size")= num NA
[16:01:43.992]  - Getting '...' globals ... DONE
[16:01:43.992] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:43.993] List of 2
[16:01:43.993]  $ ...future.FUN:function (x)  
[16:01:43.993]  $ ...          : list()
[16:01:43.993]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:43.993]  - attr(*, "where")=List of 2
[16:01:43.993]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:43.993]   ..$ ...          :<environment: 0x55fb65c2dfb0> 
[16:01:43.993]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:43.993]  - attr(*, "resolved")= logi FALSE
[16:01:43.993]  - attr(*, "total_size")= num 9888
[16:01:43.995] Packages to be attached in all futures: [n=0] 
[16:01:43.995] getGlobalsAndPackagesXApply() ... DONE
[16:01:43.999] future_lapply() ...
[16:01:44.004] Number of chunks: 2
[16:01:44.004] getGlobalsAndPackagesXApply() ...
[16:01:44.004]  - future.globals: <name-value list> with names ‘list()’
[16:01:44.004]  - use_args: TRUE
[16:01:44.004] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:01:44.004] List of 2
[16:01:44.004]  $ ...          : list()
[16:01:44.004]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:44.004]  $ ...future.FUN:function (x)  
[16:01:44.004]  - attr(*, "where")=List of 2
[16:01:44.004]   ..$ ...          :<environment: 0x55fb65c2dfb0> 
[16:01:44.004]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[16:01:44.004]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:44.004]  - attr(*, "resolved")= logi FALSE
[16:01:44.004]  - attr(*, "total_size")= num NA
[16:01:44.007] Packages to be attached in all futures: [n=0] 
[16:01:44.007] getGlobalsAndPackagesXApply() ... DONE
[16:01:44.007] Number of futures (= number of chunks): 2
[16:01:44.008] Launching 2 futures (chunks) ...
[16:01:44.008] Chunk #1 of 2 ...
[16:01:44.008]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:44.008]  - seeds: <none>
[16:01:44.008]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:44.008] getGlobalsAndPackages() ...
[16:01:44.008] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:44.008] Resolving globals: FALSE
[16:01:44.008] Tweak future expression to call with '...' arguments ...
[16:01:44.009] {
[16:01:44.009]     do.call(function(...) {
[16:01:44.009]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:44.009]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:44.009]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:44.009]             on.exit(options(oopts), add = TRUE)
[16:01:44.009]         }
[16:01:44.009]         {
[16:01:44.009]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:44.009]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:44.009]                 ...future.FUN(...future.X_jj, ...)
[16:01:44.009]             })
[16:01:44.009]         }
[16:01:44.009]     }, args = future.call.arguments)
[16:01:44.009] }
[16:01:44.009] Tweak future expression to call with '...' arguments ... DONE
[16:01:44.009] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:44.009] 
[16:01:44.009] getGlobalsAndPackages() ... DONE
[16:01:44.010] run() for ‘Future’ ...
[16:01:44.010] - state: ‘created’
[16:01:44.010] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:44.024] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:44.024] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:44.024]   - Field: ‘node’
[16:01:44.024]   - Field: ‘label’
[16:01:44.024]   - Field: ‘local’
[16:01:44.024]   - Field: ‘owner’
[16:01:44.024]   - Field: ‘envir’
[16:01:44.025]   - Field: ‘workers’
[16:01:44.025]   - Field: ‘packages’
[16:01:44.025]   - Field: ‘gc’
[16:01:44.025]   - Field: ‘conditions’
[16:01:44.025]   - Field: ‘persistent’
[16:01:44.025]   - Field: ‘expr’
[16:01:44.025]   - Field: ‘uuid’
[16:01:44.025]   - Field: ‘seed’
[16:01:44.025]   - Field: ‘version’
[16:01:44.025]   - Field: ‘result’
[16:01:44.025]   - Field: ‘asynchronous’
[16:01:44.026]   - Field: ‘calls’
[16:01:44.026]   - Field: ‘globals’
[16:01:44.026]   - Field: ‘stdout’
[16:01:44.026]   - Field: ‘earlySignal’
[16:01:44.026]   - Field: ‘lazy’
[16:01:44.026]   - Field: ‘state’
[16:01:44.026] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:44.026] - Launch lazy future ...
[16:01:44.026] Packages needed by the future expression (n = 0): <none>
[16:01:44.027] Packages needed by future strategies (n = 0): <none>
[16:01:44.027] {
[16:01:44.027]     {
[16:01:44.027]         {
[16:01:44.027]             ...future.startTime <- base::Sys.time()
[16:01:44.027]             {
[16:01:44.027]                 {
[16:01:44.027]                   {
[16:01:44.027]                     {
[16:01:44.027]                       base::local({
[16:01:44.027]                         has_future <- base::requireNamespace("future", 
[16:01:44.027]                           quietly = TRUE)
[16:01:44.027]                         if (has_future) {
[16:01:44.027]                           ns <- base::getNamespace("future")
[16:01:44.027]                           version <- ns[[".package"]][["version"]]
[16:01:44.027]                           if (is.null(version)) 
[16:01:44.027]                             version <- utils::packageVersion("future")
[16:01:44.027]                         }
[16:01:44.027]                         else {
[16:01:44.027]                           version <- NULL
[16:01:44.027]                         }
[16:01:44.027]                         if (!has_future || version < "1.8.0") {
[16:01:44.027]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:44.027]                             "", base::R.version$version.string), 
[16:01:44.027]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:44.027]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:44.027]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:44.027]                               "release", "version")], collapse = " "), 
[16:01:44.027]                             hostname = base::Sys.info()[["nodename"]])
[16:01:44.027]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:44.027]                             info)
[16:01:44.027]                           info <- base::paste(info, collapse = "; ")
[16:01:44.027]                           if (!has_future) {
[16:01:44.027]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:44.027]                               info)
[16:01:44.027]                           }
[16:01:44.027]                           else {
[16:01:44.027]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:44.027]                               info, version)
[16:01:44.027]                           }
[16:01:44.027]                           base::stop(msg)
[16:01:44.027]                         }
[16:01:44.027]                       })
[16:01:44.027]                     }
[16:01:44.027]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:44.027]                     base::options(mc.cores = 1L)
[16:01:44.027]                   }
[16:01:44.027]                   options(future.plan = NULL)
[16:01:44.027]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:44.027]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:44.027]                 }
[16:01:44.027]                 ...future.workdir <- getwd()
[16:01:44.027]             }
[16:01:44.027]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:44.027]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:44.027]         }
[16:01:44.027]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:44.027]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:44.027]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:44.027]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:44.027]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:44.027]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:44.027]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:44.027]             base::names(...future.oldOptions))
[16:01:44.027]     }
[16:01:44.027]     if (FALSE) {
[16:01:44.027]     }
[16:01:44.027]     else {
[16:01:44.027]         if (TRUE) {
[16:01:44.027]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:44.027]                 open = "w")
[16:01:44.027]         }
[16:01:44.027]         else {
[16:01:44.027]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:44.027]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:44.027]         }
[16:01:44.027]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:44.027]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:44.027]             base::sink(type = "output", split = FALSE)
[16:01:44.027]             base::close(...future.stdout)
[16:01:44.027]         }, add = TRUE)
[16:01:44.027]     }
[16:01:44.027]     ...future.frame <- base::sys.nframe()
[16:01:44.027]     ...future.conditions <- base::list()
[16:01:44.027]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:44.027]     if (FALSE) {
[16:01:44.027]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:44.027]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:44.027]     }
[16:01:44.027]     ...future.result <- base::tryCatch({
[16:01:44.027]         base::withCallingHandlers({
[16:01:44.027]             ...future.value <- base::withVisible(base::local({
[16:01:44.027]                 ...future.makeSendCondition <- base::local({
[16:01:44.027]                   sendCondition <- NULL
[16:01:44.027]                   function(frame = 1L) {
[16:01:44.027]                     if (is.function(sendCondition)) 
[16:01:44.027]                       return(sendCondition)
[16:01:44.027]                     ns <- getNamespace("parallel")
[16:01:44.027]                     if (exists("sendData", mode = "function", 
[16:01:44.027]                       envir = ns)) {
[16:01:44.027]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:44.027]                         envir = ns)
[16:01:44.027]                       envir <- sys.frame(frame)
[16:01:44.027]                       master <- NULL
[16:01:44.027]                       while (!identical(envir, .GlobalEnv) && 
[16:01:44.027]                         !identical(envir, emptyenv())) {
[16:01:44.027]                         if (exists("master", mode = "list", envir = envir, 
[16:01:44.027]                           inherits = FALSE)) {
[16:01:44.027]                           master <- get("master", mode = "list", 
[16:01:44.027]                             envir = envir, inherits = FALSE)
[16:01:44.027]                           if (inherits(master, c("SOCKnode", 
[16:01:44.027]                             "SOCK0node"))) {
[16:01:44.027]                             sendCondition <<- function(cond) {
[16:01:44.027]                               data <- list(type = "VALUE", value = cond, 
[16:01:44.027]                                 success = TRUE)
[16:01:44.027]                               parallel_sendData(master, data)
[16:01:44.027]                             }
[16:01:44.027]                             return(sendCondition)
[16:01:44.027]                           }
[16:01:44.027]                         }
[16:01:44.027]                         frame <- frame + 1L
[16:01:44.027]                         envir <- sys.frame(frame)
[16:01:44.027]                       }
[16:01:44.027]                     }
[16:01:44.027]                     sendCondition <<- function(cond) NULL
[16:01:44.027]                   }
[16:01:44.027]                 })
[16:01:44.027]                 withCallingHandlers({
[16:01:44.027]                   {
[16:01:44.027]                     do.call(function(...) {
[16:01:44.027]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:44.027]                       if (!identical(...future.globals.maxSize.org, 
[16:01:44.027]                         ...future.globals.maxSize)) {
[16:01:44.027]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:44.027]                         on.exit(options(oopts), add = TRUE)
[16:01:44.027]                       }
[16:01:44.027]                       {
[16:01:44.027]                         lapply(seq_along(...future.elements_ii), 
[16:01:44.027]                           FUN = function(jj) {
[16:01:44.027]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:44.027]                             ...future.FUN(...future.X_jj, ...)
[16:01:44.027]                           })
[16:01:44.027]                       }
[16:01:44.027]                     }, args = future.call.arguments)
[16:01:44.027]                   }
[16:01:44.027]                 }, immediateCondition = function(cond) {
[16:01:44.027]                   sendCondition <- ...future.makeSendCondition()
[16:01:44.027]                   sendCondition(cond)
[16:01:44.027]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:44.027]                   {
[16:01:44.027]                     inherits <- base::inherits
[16:01:44.027]                     invokeRestart <- base::invokeRestart
[16:01:44.027]                     is.null <- base::is.null
[16:01:44.027]                     muffled <- FALSE
[16:01:44.027]                     if (inherits(cond, "message")) {
[16:01:44.027]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:44.027]                       if (muffled) 
[16:01:44.027]                         invokeRestart("muffleMessage")
[16:01:44.027]                     }
[16:01:44.027]                     else if (inherits(cond, "warning")) {
[16:01:44.027]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:44.027]                       if (muffled) 
[16:01:44.027]                         invokeRestart("muffleWarning")
[16:01:44.027]                     }
[16:01:44.027]                     else if (inherits(cond, "condition")) {
[16:01:44.027]                       if (!is.null(pattern)) {
[16:01:44.027]                         computeRestarts <- base::computeRestarts
[16:01:44.027]                         grepl <- base::grepl
[16:01:44.027]                         restarts <- computeRestarts(cond)
[16:01:44.027]                         for (restart in restarts) {
[16:01:44.027]                           name <- restart$name
[16:01:44.027]                           if (is.null(name)) 
[16:01:44.027]                             next
[16:01:44.027]                           if (!grepl(pattern, name)) 
[16:01:44.027]                             next
[16:01:44.027]                           invokeRestart(restart)
[16:01:44.027]                           muffled <- TRUE
[16:01:44.027]                           break
[16:01:44.027]                         }
[16:01:44.027]                       }
[16:01:44.027]                     }
[16:01:44.027]                     invisible(muffled)
[16:01:44.027]                   }
[16:01:44.027]                   muffleCondition(cond)
[16:01:44.027]                 })
[16:01:44.027]             }))
[16:01:44.027]             future::FutureResult(value = ...future.value$value, 
[16:01:44.027]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:44.027]                   ...future.rng), globalenv = if (FALSE) 
[16:01:44.027]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:44.027]                     ...future.globalenv.names))
[16:01:44.027]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:44.027]         }, condition = base::local({
[16:01:44.027]             c <- base::c
[16:01:44.027]             inherits <- base::inherits
[16:01:44.027]             invokeRestart <- base::invokeRestart
[16:01:44.027]             length <- base::length
[16:01:44.027]             list <- base::list
[16:01:44.027]             seq.int <- base::seq.int
[16:01:44.027]             signalCondition <- base::signalCondition
[16:01:44.027]             sys.calls <- base::sys.calls
[16:01:44.027]             `[[` <- base::`[[`
[16:01:44.027]             `+` <- base::`+`
[16:01:44.027]             `<<-` <- base::`<<-`
[16:01:44.027]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:44.027]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:44.027]                   3L)]
[16:01:44.027]             }
[16:01:44.027]             function(cond) {
[16:01:44.027]                 is_error <- inherits(cond, "error")
[16:01:44.027]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:44.027]                   NULL)
[16:01:44.027]                 if (is_error) {
[16:01:44.027]                   sessionInformation <- function() {
[16:01:44.027]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:44.027]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:44.027]                       search = base::search(), system = base::Sys.info())
[16:01:44.027]                   }
[16:01:44.027]                   ...future.conditions[[length(...future.conditions) + 
[16:01:44.027]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:44.027]                     cond$call), session = sessionInformation(), 
[16:01:44.027]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:44.027]                   signalCondition(cond)
[16:01:44.027]                 }
[16:01:44.027]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:44.027]                 "immediateCondition"))) {
[16:01:44.027]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:44.027]                   ...future.conditions[[length(...future.conditions) + 
[16:01:44.027]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:44.027]                   if (TRUE && !signal) {
[16:01:44.027]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:44.027]                     {
[16:01:44.027]                       inherits <- base::inherits
[16:01:44.027]                       invokeRestart <- base::invokeRestart
[16:01:44.027]                       is.null <- base::is.null
[16:01:44.027]                       muffled <- FALSE
[16:01:44.027]                       if (inherits(cond, "message")) {
[16:01:44.027]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:44.027]                         if (muffled) 
[16:01:44.027]                           invokeRestart("muffleMessage")
[16:01:44.027]                       }
[16:01:44.027]                       else if (inherits(cond, "warning")) {
[16:01:44.027]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:44.027]                         if (muffled) 
[16:01:44.027]                           invokeRestart("muffleWarning")
[16:01:44.027]                       }
[16:01:44.027]                       else if (inherits(cond, "condition")) {
[16:01:44.027]                         if (!is.null(pattern)) {
[16:01:44.027]                           computeRestarts <- base::computeRestarts
[16:01:44.027]                           grepl <- base::grepl
[16:01:44.027]                           restarts <- computeRestarts(cond)
[16:01:44.027]                           for (restart in restarts) {
[16:01:44.027]                             name <- restart$name
[16:01:44.027]                             if (is.null(name)) 
[16:01:44.027]                               next
[16:01:44.027]                             if (!grepl(pattern, name)) 
[16:01:44.027]                               next
[16:01:44.027]                             invokeRestart(restart)
[16:01:44.027]                             muffled <- TRUE
[16:01:44.027]                             break
[16:01:44.027]                           }
[16:01:44.027]                         }
[16:01:44.027]                       }
[16:01:44.027]                       invisible(muffled)
[16:01:44.027]                     }
[16:01:44.027]                     muffleCondition(cond, pattern = "^muffle")
[16:01:44.027]                   }
[16:01:44.027]                 }
[16:01:44.027]                 else {
[16:01:44.027]                   if (TRUE) {
[16:01:44.027]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:44.027]                     {
[16:01:44.027]                       inherits <- base::inherits
[16:01:44.027]                       invokeRestart <- base::invokeRestart
[16:01:44.027]                       is.null <- base::is.null
[16:01:44.027]                       muffled <- FALSE
[16:01:44.027]                       if (inherits(cond, "message")) {
[16:01:44.027]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:44.027]                         if (muffled) 
[16:01:44.027]                           invokeRestart("muffleMessage")
[16:01:44.027]                       }
[16:01:44.027]                       else if (inherits(cond, "warning")) {
[16:01:44.027]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:44.027]                         if (muffled) 
[16:01:44.027]                           invokeRestart("muffleWarning")
[16:01:44.027]                       }
[16:01:44.027]                       else if (inherits(cond, "condition")) {
[16:01:44.027]                         if (!is.null(pattern)) {
[16:01:44.027]                           computeRestarts <- base::computeRestarts
[16:01:44.027]                           grepl <- base::grepl
[16:01:44.027]                           restarts <- computeRestarts(cond)
[16:01:44.027]                           for (restart in restarts) {
[16:01:44.027]                             name <- restart$name
[16:01:44.027]                             if (is.null(name)) 
[16:01:44.027]                               next
[16:01:44.027]                             if (!grepl(pattern, name)) 
[16:01:44.027]                               next
[16:01:44.027]                             invokeRestart(restart)
[16:01:44.027]                             muffled <- TRUE
[16:01:44.027]                             break
[16:01:44.027]                           }
[16:01:44.027]                         }
[16:01:44.027]                       }
[16:01:44.027]                       invisible(muffled)
[16:01:44.027]                     }
[16:01:44.027]                     muffleCondition(cond, pattern = "^muffle")
[16:01:44.027]                   }
[16:01:44.027]                 }
[16:01:44.027]             }
[16:01:44.027]         }))
[16:01:44.027]     }, error = function(ex) {
[16:01:44.027]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:44.027]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:44.027]                 ...future.rng), started = ...future.startTime, 
[16:01:44.027]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:44.027]             version = "1.8"), class = "FutureResult")
[16:01:44.027]     }, finally = {
[16:01:44.027]         if (!identical(...future.workdir, getwd())) 
[16:01:44.027]             setwd(...future.workdir)
[16:01:44.027]         {
[16:01:44.027]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:44.027]                 ...future.oldOptions$nwarnings <- NULL
[16:01:44.027]             }
[16:01:44.027]             base::options(...future.oldOptions)
[16:01:44.027]             if (.Platform$OS.type == "windows") {
[16:01:44.027]                 old_names <- names(...future.oldEnvVars)
[16:01:44.027]                 envs <- base::Sys.getenv()
[16:01:44.027]                 names <- names(envs)
[16:01:44.027]                 common <- intersect(names, old_names)
[16:01:44.027]                 added <- setdiff(names, old_names)
[16:01:44.027]                 removed <- setdiff(old_names, names)
[16:01:44.027]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:44.027]                   envs[common]]
[16:01:44.027]                 NAMES <- toupper(changed)
[16:01:44.027]                 args <- list()
[16:01:44.027]                 for (kk in seq_along(NAMES)) {
[16:01:44.027]                   name <- changed[[kk]]
[16:01:44.027]                   NAME <- NAMES[[kk]]
[16:01:44.027]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:44.027]                     next
[16:01:44.027]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:44.027]                 }
[16:01:44.027]                 NAMES <- toupper(added)
[16:01:44.027]                 for (kk in seq_along(NAMES)) {
[16:01:44.027]                   name <- added[[kk]]
[16:01:44.027]                   NAME <- NAMES[[kk]]
[16:01:44.027]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:44.027]                     next
[16:01:44.027]                   args[[name]] <- ""
[16:01:44.027]                 }
[16:01:44.027]                 NAMES <- toupper(removed)
[16:01:44.027]                 for (kk in seq_along(NAMES)) {
[16:01:44.027]                   name <- removed[[kk]]
[16:01:44.027]                   NAME <- NAMES[[kk]]
[16:01:44.027]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:44.027]                     next
[16:01:44.027]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:44.027]                 }
[16:01:44.027]                 if (length(args) > 0) 
[16:01:44.027]                   base::do.call(base::Sys.setenv, args = args)
[16:01:44.027]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:44.027]             }
[16:01:44.027]             else {
[16:01:44.027]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:44.027]             }
[16:01:44.027]             {
[16:01:44.027]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:44.027]                   0L) {
[16:01:44.027]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:44.027]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:44.027]                   base::options(opts)
[16:01:44.027]                 }
[16:01:44.027]                 {
[16:01:44.027]                   {
[16:01:44.027]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:44.027]                     NULL
[16:01:44.027]                   }
[16:01:44.027]                   options(future.plan = NULL)
[16:01:44.027]                   if (is.na(NA_character_)) 
[16:01:44.027]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:44.027]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:44.027]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:44.027]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:44.027]                     envir = parent.frame()) 
[16:01:44.027]                   {
[16:01:44.027]                     if (is.function(workers)) 
[16:01:44.027]                       workers <- workers()
[16:01:44.027]                     workers <- structure(as.integer(workers), 
[16:01:44.027]                       class = class(workers))
[16:01:44.027]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:44.027]                       workers >= 1)
[16:01:44.027]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:44.027]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:44.027]                     }
[16:01:44.027]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:44.027]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:44.027]                       envir = envir)
[16:01:44.027]                     if (!future$lazy) 
[16:01:44.027]                       future <- run(future)
[16:01:44.027]                     invisible(future)
[16:01:44.027]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:44.027]                 }
[16:01:44.027]             }
[16:01:44.027]         }
[16:01:44.027]     })
[16:01:44.027]     if (TRUE) {
[16:01:44.027]         base::sink(type = "output", split = FALSE)
[16:01:44.027]         if (TRUE) {
[16:01:44.027]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:44.027]         }
[16:01:44.027]         else {
[16:01:44.027]             ...future.result["stdout"] <- base::list(NULL)
[16:01:44.027]         }
[16:01:44.027]         base::close(...future.stdout)
[16:01:44.027]         ...future.stdout <- NULL
[16:01:44.027]     }
[16:01:44.027]     ...future.result$conditions <- ...future.conditions
[16:01:44.027]     ...future.result$finished <- base::Sys.time()
[16:01:44.027]     ...future.result
[16:01:44.027] }
[16:01:44.030] Exporting 5 global objects (9.77 KiB) to cluster node #1 ...
[16:01:44.031] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:01:44.031] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:01:44.031] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #1 ...
[16:01:44.031] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #1 ... DONE
[16:01:44.032] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[16:01:44.032] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[16:01:44.032] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:01:44.032] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:01:44.032] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:01:44.033] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:01:44.033] Exporting 5 global objects (9.77 KiB) to cluster node #1 ... DONE
[16:01:44.033] MultisessionFuture started
[16:01:44.034] - Launch lazy future ... done
[16:01:44.034] run() for ‘MultisessionFuture’ ... done
[16:01:44.036] Created future:
[16:01:44.036] MultisessionFuture:
[16:01:44.036] Label: ‘future_apply-1’
[16:01:44.036] Expression:
[16:01:44.036] {
[16:01:44.036]     do.call(function(...) {
[16:01:44.036]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:44.036]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:44.036]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:44.036]             on.exit(options(oopts), add = TRUE)
[16:01:44.036]         }
[16:01:44.036]         {
[16:01:44.036]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:44.036]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:44.036]                 ...future.FUN(...future.X_jj, ...)
[16:01:44.036]             })
[16:01:44.036]         }
[16:01:44.036]     }, args = future.call.arguments)
[16:01:44.036] }
[16:01:44.036] Lazy evaluation: FALSE
[16:01:44.036] Asynchronous evaluation: TRUE
[16:01:44.036] Local evaluation: TRUE
[16:01:44.036] Environment: R_GlobalEnv
[16:01:44.036] Capture standard output: TRUE
[16:01:44.036] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:44.036] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:44.036] Packages: <none>
[16:01:44.036] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:44.036] Resolved: FALSE
[16:01:44.036] Value: <not collected>
[16:01:44.036] Conditions captured: <none>
[16:01:44.036] Early signaling: FALSE
[16:01:44.036] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:44.036] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:44.048] Chunk #1 of 2 ... DONE
[16:01:44.048] Chunk #2 of 2 ...
[16:01:44.048]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:44.048]  - seeds: <none>
[16:01:44.048]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:44.048] getGlobalsAndPackages() ...
[16:01:44.049] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:44.049] Resolving globals: FALSE
[16:01:44.049] Tweak future expression to call with '...' arguments ...
[16:01:44.049] {
[16:01:44.049]     do.call(function(...) {
[16:01:44.049]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:44.049]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:44.049]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:44.049]             on.exit(options(oopts), add = TRUE)
[16:01:44.049]         }
[16:01:44.049]         {
[16:01:44.049]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:44.049]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:44.049]                 ...future.FUN(...future.X_jj, ...)
[16:01:44.049]             })
[16:01:44.049]         }
[16:01:44.049]     }, args = future.call.arguments)
[16:01:44.049] }
[16:01:44.049] Tweak future expression to call with '...' arguments ... DONE
[16:01:44.050] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:44.050] 
[16:01:44.050] getGlobalsAndPackages() ... DONE
[16:01:44.050] run() for ‘Future’ ...
[16:01:44.050] - state: ‘created’
[16:01:44.050] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:44.065] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:44.065] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:44.065]   - Field: ‘node’
[16:01:44.066]   - Field: ‘label’
[16:01:44.066]   - Field: ‘local’
[16:01:44.066]   - Field: ‘owner’
[16:01:44.066]   - Field: ‘envir’
[16:01:44.066]   - Field: ‘workers’
[16:01:44.066]   - Field: ‘packages’
[16:01:44.066]   - Field: ‘gc’
[16:01:44.066]   - Field: ‘conditions’
[16:01:44.066]   - Field: ‘persistent’
[16:01:44.066]   - Field: ‘expr’
[16:01:44.066]   - Field: ‘uuid’
[16:01:44.067]   - Field: ‘seed’
[16:01:44.067]   - Field: ‘version’
[16:01:44.067]   - Field: ‘result’
[16:01:44.067]   - Field: ‘asynchronous’
[16:01:44.067]   - Field: ‘calls’
[16:01:44.067]   - Field: ‘globals’
[16:01:44.067]   - Field: ‘stdout’
[16:01:44.067]   - Field: ‘earlySignal’
[16:01:44.067]   - Field: ‘lazy’
[16:01:44.067]   - Field: ‘state’
[16:01:44.068] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:44.068] - Launch lazy future ...
[16:01:44.068] Packages needed by the future expression (n = 0): <none>
[16:01:44.068] Packages needed by future strategies (n = 0): <none>
[16:01:44.069] {
[16:01:44.069]     {
[16:01:44.069]         {
[16:01:44.069]             ...future.startTime <- base::Sys.time()
[16:01:44.069]             {
[16:01:44.069]                 {
[16:01:44.069]                   {
[16:01:44.069]                     {
[16:01:44.069]                       base::local({
[16:01:44.069]                         has_future <- base::requireNamespace("future", 
[16:01:44.069]                           quietly = TRUE)
[16:01:44.069]                         if (has_future) {
[16:01:44.069]                           ns <- base::getNamespace("future")
[16:01:44.069]                           version <- ns[[".package"]][["version"]]
[16:01:44.069]                           if (is.null(version)) 
[16:01:44.069]                             version <- utils::packageVersion("future")
[16:01:44.069]                         }
[16:01:44.069]                         else {
[16:01:44.069]                           version <- NULL
[16:01:44.069]                         }
[16:01:44.069]                         if (!has_future || version < "1.8.0") {
[16:01:44.069]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:44.069]                             "", base::R.version$version.string), 
[16:01:44.069]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:44.069]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:44.069]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:44.069]                               "release", "version")], collapse = " "), 
[16:01:44.069]                             hostname = base::Sys.info()[["nodename"]])
[16:01:44.069]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:44.069]                             info)
[16:01:44.069]                           info <- base::paste(info, collapse = "; ")
[16:01:44.069]                           if (!has_future) {
[16:01:44.069]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:44.069]                               info)
[16:01:44.069]                           }
[16:01:44.069]                           else {
[16:01:44.069]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:44.069]                               info, version)
[16:01:44.069]                           }
[16:01:44.069]                           base::stop(msg)
[16:01:44.069]                         }
[16:01:44.069]                       })
[16:01:44.069]                     }
[16:01:44.069]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:44.069]                     base::options(mc.cores = 1L)
[16:01:44.069]                   }
[16:01:44.069]                   options(future.plan = NULL)
[16:01:44.069]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:44.069]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:44.069]                 }
[16:01:44.069]                 ...future.workdir <- getwd()
[16:01:44.069]             }
[16:01:44.069]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:44.069]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:44.069]         }
[16:01:44.069]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:44.069]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:44.069]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:44.069]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:44.069]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:44.069]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:44.069]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:44.069]             base::names(...future.oldOptions))
[16:01:44.069]     }
[16:01:44.069]     if (FALSE) {
[16:01:44.069]     }
[16:01:44.069]     else {
[16:01:44.069]         if (TRUE) {
[16:01:44.069]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:44.069]                 open = "w")
[16:01:44.069]         }
[16:01:44.069]         else {
[16:01:44.069]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:44.069]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:44.069]         }
[16:01:44.069]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:44.069]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:44.069]             base::sink(type = "output", split = FALSE)
[16:01:44.069]             base::close(...future.stdout)
[16:01:44.069]         }, add = TRUE)
[16:01:44.069]     }
[16:01:44.069]     ...future.frame <- base::sys.nframe()
[16:01:44.069]     ...future.conditions <- base::list()
[16:01:44.069]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:44.069]     if (FALSE) {
[16:01:44.069]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:44.069]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:44.069]     }
[16:01:44.069]     ...future.result <- base::tryCatch({
[16:01:44.069]         base::withCallingHandlers({
[16:01:44.069]             ...future.value <- base::withVisible(base::local({
[16:01:44.069]                 ...future.makeSendCondition <- base::local({
[16:01:44.069]                   sendCondition <- NULL
[16:01:44.069]                   function(frame = 1L) {
[16:01:44.069]                     if (is.function(sendCondition)) 
[16:01:44.069]                       return(sendCondition)
[16:01:44.069]                     ns <- getNamespace("parallel")
[16:01:44.069]                     if (exists("sendData", mode = "function", 
[16:01:44.069]                       envir = ns)) {
[16:01:44.069]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:44.069]                         envir = ns)
[16:01:44.069]                       envir <- sys.frame(frame)
[16:01:44.069]                       master <- NULL
[16:01:44.069]                       while (!identical(envir, .GlobalEnv) && 
[16:01:44.069]                         !identical(envir, emptyenv())) {
[16:01:44.069]                         if (exists("master", mode = "list", envir = envir, 
[16:01:44.069]                           inherits = FALSE)) {
[16:01:44.069]                           master <- get("master", mode = "list", 
[16:01:44.069]                             envir = envir, inherits = FALSE)
[16:01:44.069]                           if (inherits(master, c("SOCKnode", 
[16:01:44.069]                             "SOCK0node"))) {
[16:01:44.069]                             sendCondition <<- function(cond) {
[16:01:44.069]                               data <- list(type = "VALUE", value = cond, 
[16:01:44.069]                                 success = TRUE)
[16:01:44.069]                               parallel_sendData(master, data)
[16:01:44.069]                             }
[16:01:44.069]                             return(sendCondition)
[16:01:44.069]                           }
[16:01:44.069]                         }
[16:01:44.069]                         frame <- frame + 1L
[16:01:44.069]                         envir <- sys.frame(frame)
[16:01:44.069]                       }
[16:01:44.069]                     }
[16:01:44.069]                     sendCondition <<- function(cond) NULL
[16:01:44.069]                   }
[16:01:44.069]                 })
[16:01:44.069]                 withCallingHandlers({
[16:01:44.069]                   {
[16:01:44.069]                     do.call(function(...) {
[16:01:44.069]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:44.069]                       if (!identical(...future.globals.maxSize.org, 
[16:01:44.069]                         ...future.globals.maxSize)) {
[16:01:44.069]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:44.069]                         on.exit(options(oopts), add = TRUE)
[16:01:44.069]                       }
[16:01:44.069]                       {
[16:01:44.069]                         lapply(seq_along(...future.elements_ii), 
[16:01:44.069]                           FUN = function(jj) {
[16:01:44.069]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:44.069]                             ...future.FUN(...future.X_jj, ...)
[16:01:44.069]                           })
[16:01:44.069]                       }
[16:01:44.069]                     }, args = future.call.arguments)
[16:01:44.069]                   }
[16:01:44.069]                 }, immediateCondition = function(cond) {
[16:01:44.069]                   sendCondition <- ...future.makeSendCondition()
[16:01:44.069]                   sendCondition(cond)
[16:01:44.069]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:44.069]                   {
[16:01:44.069]                     inherits <- base::inherits
[16:01:44.069]                     invokeRestart <- base::invokeRestart
[16:01:44.069]                     is.null <- base::is.null
[16:01:44.069]                     muffled <- FALSE
[16:01:44.069]                     if (inherits(cond, "message")) {
[16:01:44.069]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:44.069]                       if (muffled) 
[16:01:44.069]                         invokeRestart("muffleMessage")
[16:01:44.069]                     }
[16:01:44.069]                     else if (inherits(cond, "warning")) {
[16:01:44.069]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:44.069]                       if (muffled) 
[16:01:44.069]                         invokeRestart("muffleWarning")
[16:01:44.069]                     }
[16:01:44.069]                     else if (inherits(cond, "condition")) {
[16:01:44.069]                       if (!is.null(pattern)) {
[16:01:44.069]                         computeRestarts <- base::computeRestarts
[16:01:44.069]                         grepl <- base::grepl
[16:01:44.069]                         restarts <- computeRestarts(cond)
[16:01:44.069]                         for (restart in restarts) {
[16:01:44.069]                           name <- restart$name
[16:01:44.069]                           if (is.null(name)) 
[16:01:44.069]                             next
[16:01:44.069]                           if (!grepl(pattern, name)) 
[16:01:44.069]                             next
[16:01:44.069]                           invokeRestart(restart)
[16:01:44.069]                           muffled <- TRUE
[16:01:44.069]                           break
[16:01:44.069]                         }
[16:01:44.069]                       }
[16:01:44.069]                     }
[16:01:44.069]                     invisible(muffled)
[16:01:44.069]                   }
[16:01:44.069]                   muffleCondition(cond)
[16:01:44.069]                 })
[16:01:44.069]             }))
[16:01:44.069]             future::FutureResult(value = ...future.value$value, 
[16:01:44.069]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:44.069]                   ...future.rng), globalenv = if (FALSE) 
[16:01:44.069]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:44.069]                     ...future.globalenv.names))
[16:01:44.069]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:44.069]         }, condition = base::local({
[16:01:44.069]             c <- base::c
[16:01:44.069]             inherits <- base::inherits
[16:01:44.069]             invokeRestart <- base::invokeRestart
[16:01:44.069]             length <- base::length
[16:01:44.069]             list <- base::list
[16:01:44.069]             seq.int <- base::seq.int
[16:01:44.069]             signalCondition <- base::signalCondition
[16:01:44.069]             sys.calls <- base::sys.calls
[16:01:44.069]             `[[` <- base::`[[`
[16:01:44.069]             `+` <- base::`+`
[16:01:44.069]             `<<-` <- base::`<<-`
[16:01:44.069]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:44.069]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:44.069]                   3L)]
[16:01:44.069]             }
[16:01:44.069]             function(cond) {
[16:01:44.069]                 is_error <- inherits(cond, "error")
[16:01:44.069]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:44.069]                   NULL)
[16:01:44.069]                 if (is_error) {
[16:01:44.069]                   sessionInformation <- function() {
[16:01:44.069]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:44.069]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:44.069]                       search = base::search(), system = base::Sys.info())
[16:01:44.069]                   }
[16:01:44.069]                   ...future.conditions[[length(...future.conditions) + 
[16:01:44.069]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:44.069]                     cond$call), session = sessionInformation(), 
[16:01:44.069]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:44.069]                   signalCondition(cond)
[16:01:44.069]                 }
[16:01:44.069]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:01:44.069]                 "immediateCondition"))) {
[16:01:44.069]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:44.069]                   ...future.conditions[[length(...future.conditions) + 
[16:01:44.069]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:44.069]                   if (TRUE && !signal) {
[16:01:44.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:44.069]                     {
[16:01:44.069]                       inherits <- base::inherits
[16:01:44.069]                       invokeRestart <- base::invokeRestart
[16:01:44.069]                       is.null <- base::is.null
[16:01:44.069]                       muffled <- FALSE
[16:01:44.069]                       if (inherits(cond, "message")) {
[16:01:44.069]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:44.069]                         if (muffled) 
[16:01:44.069]                           invokeRestart("muffleMessage")
[16:01:44.069]                       }
[16:01:44.069]                       else if (inherits(cond, "warning")) {
[16:01:44.069]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:44.069]                         if (muffled) 
[16:01:44.069]                           invokeRestart("muffleWarning")
[16:01:44.069]                       }
[16:01:44.069]                       else if (inherits(cond, "condition")) {
[16:01:44.069]                         if (!is.null(pattern)) {
[16:01:44.069]                           computeRestarts <- base::computeRestarts
[16:01:44.069]                           grepl <- base::grepl
[16:01:44.069]                           restarts <- computeRestarts(cond)
[16:01:44.069]                           for (restart in restarts) {
[16:01:44.069]                             name <- restart$name
[16:01:44.069]                             if (is.null(name)) 
[16:01:44.069]                               next
[16:01:44.069]                             if (!grepl(pattern, name)) 
[16:01:44.069]                               next
[16:01:44.069]                             invokeRestart(restart)
[16:01:44.069]                             muffled <- TRUE
[16:01:44.069]                             break
[16:01:44.069]                           }
[16:01:44.069]                         }
[16:01:44.069]                       }
[16:01:44.069]                       invisible(muffled)
[16:01:44.069]                     }
[16:01:44.069]                     muffleCondition(cond, pattern = "^muffle")
[16:01:44.069]                   }
[16:01:44.069]                 }
[16:01:44.069]                 else {
[16:01:44.069]                   if (TRUE) {
[16:01:44.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:44.069]                     {
[16:01:44.069]                       inherits <- base::inherits
[16:01:44.069]                       invokeRestart <- base::invokeRestart
[16:01:44.069]                       is.null <- base::is.null
[16:01:44.069]                       muffled <- FALSE
[16:01:44.069]                       if (inherits(cond, "message")) {
[16:01:44.069]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:44.069]                         if (muffled) 
[16:01:44.069]                           invokeRestart("muffleMessage")
[16:01:44.069]                       }
[16:01:44.069]                       else if (inherits(cond, "warning")) {
[16:01:44.069]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:44.069]                         if (muffled) 
[16:01:44.069]                           invokeRestart("muffleWarning")
[16:01:44.069]                       }
[16:01:44.069]                       else if (inherits(cond, "condition")) {
[16:01:44.069]                         if (!is.null(pattern)) {
[16:01:44.069]                           computeRestarts <- base::computeRestarts
[16:01:44.069]                           grepl <- base::grepl
[16:01:44.069]                           restarts <- computeRestarts(cond)
[16:01:44.069]                           for (restart in restarts) {
[16:01:44.069]                             name <- restart$name
[16:01:44.069]                             if (is.null(name)) 
[16:01:44.069]                               next
[16:01:44.069]                             if (!grepl(pattern, name)) 
[16:01:44.069]                               next
[16:01:44.069]                             invokeRestart(restart)
[16:01:44.069]                             muffled <- TRUE
[16:01:44.069]                             break
[16:01:44.069]                           }
[16:01:44.069]                         }
[16:01:44.069]                       }
[16:01:44.069]                       invisible(muffled)
[16:01:44.069]                     }
[16:01:44.069]                     muffleCondition(cond, pattern = "^muffle")
[16:01:44.069]                   }
[16:01:44.069]                 }
[16:01:44.069]             }
[16:01:44.069]         }))
[16:01:44.069]     }, error = function(ex) {
[16:01:44.069]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:44.069]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:44.069]                 ...future.rng), started = ...future.startTime, 
[16:01:44.069]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:44.069]             version = "1.8"), class = "FutureResult")
[16:01:44.069]     }, finally = {
[16:01:44.069]         if (!identical(...future.workdir, getwd())) 
[16:01:44.069]             setwd(...future.workdir)
[16:01:44.069]         {
[16:01:44.069]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:44.069]                 ...future.oldOptions$nwarnings <- NULL
[16:01:44.069]             }
[16:01:44.069]             base::options(...future.oldOptions)
[16:01:44.069]             if (.Platform$OS.type == "windows") {
[16:01:44.069]                 old_names <- names(...future.oldEnvVars)
[16:01:44.069]                 envs <- base::Sys.getenv()
[16:01:44.069]                 names <- names(envs)
[16:01:44.069]                 common <- intersect(names, old_names)
[16:01:44.069]                 added <- setdiff(names, old_names)
[16:01:44.069]                 removed <- setdiff(old_names, names)
[16:01:44.069]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:44.069]                   envs[common]]
[16:01:44.069]                 NAMES <- toupper(changed)
[16:01:44.069]                 args <- list()
[16:01:44.069]                 for (kk in seq_along(NAMES)) {
[16:01:44.069]                   name <- changed[[kk]]
[16:01:44.069]                   NAME <- NAMES[[kk]]
[16:01:44.069]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:44.069]                     next
[16:01:44.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:44.069]                 }
[16:01:44.069]                 NAMES <- toupper(added)
[16:01:44.069]                 for (kk in seq_along(NAMES)) {
[16:01:44.069]                   name <- added[[kk]]
[16:01:44.069]                   NAME <- NAMES[[kk]]
[16:01:44.069]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:44.069]                     next
[16:01:44.069]                   args[[name]] <- ""
[16:01:44.069]                 }
[16:01:44.069]                 NAMES <- toupper(removed)
[16:01:44.069]                 for (kk in seq_along(NAMES)) {
[16:01:44.069]                   name <- removed[[kk]]
[16:01:44.069]                   NAME <- NAMES[[kk]]
[16:01:44.069]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:44.069]                     next
[16:01:44.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:44.069]                 }
[16:01:44.069]                 if (length(args) > 0) 
[16:01:44.069]                   base::do.call(base::Sys.setenv, args = args)
[16:01:44.069]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:44.069]             }
[16:01:44.069]             else {
[16:01:44.069]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:44.069]             }
[16:01:44.069]             {
[16:01:44.069]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:44.069]                   0L) {
[16:01:44.069]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:44.069]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:44.069]                   base::options(opts)
[16:01:44.069]                 }
[16:01:44.069]                 {
[16:01:44.069]                   {
[16:01:44.069]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:44.069]                     NULL
[16:01:44.069]                   }
[16:01:44.069]                   options(future.plan = NULL)
[16:01:44.069]                   if (is.na(NA_character_)) 
[16:01:44.069]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:44.069]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:44.069]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:44.069]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:44.069]                     envir = parent.frame()) 
[16:01:44.069]                   {
[16:01:44.069]                     if (is.function(workers)) 
[16:01:44.069]                       workers <- workers()
[16:01:44.069]                     workers <- structure(as.integer(workers), 
[16:01:44.069]                       class = class(workers))
[16:01:44.069]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:44.069]                       workers >= 1)
[16:01:44.069]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:44.069]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:44.069]                     }
[16:01:44.069]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:44.069]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:44.069]                       envir = envir)
[16:01:44.069]                     if (!future$lazy) 
[16:01:44.069]                       future <- run(future)
[16:01:44.069]                     invisible(future)
[16:01:44.069]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:44.069]                 }
[16:01:44.069]             }
[16:01:44.069]         }
[16:01:44.069]     })
[16:01:44.069]     if (TRUE) {
[16:01:44.069]         base::sink(type = "output", split = FALSE)
[16:01:44.069]         if (TRUE) {
[16:01:44.069]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:44.069]         }
[16:01:44.069]         else {
[16:01:44.069]             ...future.result["stdout"] <- base::list(NULL)
[16:01:44.069]         }
[16:01:44.069]         base::close(...future.stdout)
[16:01:44.069]         ...future.stdout <- NULL
[16:01:44.069]     }
[16:01:44.069]     ...future.result$conditions <- ...future.conditions
[16:01:44.069]     ...future.result$finished <- base::Sys.time()
[16:01:44.069]     ...future.result
[16:01:44.069] }
[16:01:44.072] Exporting 5 global objects (9.77 KiB) to cluster node #2 ...
[16:01:44.072] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:01:44.072] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:01:44.073] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #2 ...
[16:01:44.073] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #2 ... DONE
[16:01:44.073] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[16:01:44.073] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[16:01:44.074] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:01:44.074] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:01:44.074] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[16:01:44.074] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[16:01:44.074] Exporting 5 global objects (9.77 KiB) to cluster node #2 ... DONE
[16:01:44.075] MultisessionFuture started
[16:01:44.075] - Launch lazy future ... done
[16:01:44.075] run() for ‘MultisessionFuture’ ... done
[16:01:44.075] Created future:
[16:01:44.075] MultisessionFuture:
[16:01:44.075] Label: ‘future_apply-2’
[16:01:44.075] Expression:
[16:01:44.075] {
[16:01:44.075]     do.call(function(...) {
[16:01:44.075]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:44.075]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:44.075]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:44.075]             on.exit(options(oopts), add = TRUE)
[16:01:44.075]         }
[16:01:44.075]         {
[16:01:44.075]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:44.075]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:44.075]                 ...future.FUN(...future.X_jj, ...)
[16:01:44.075]             })
[16:01:44.075]         }
[16:01:44.075]     }, args = future.call.arguments)
[16:01:44.075] }
[16:01:44.075] Lazy evaluation: FALSE
[16:01:44.075] Asynchronous evaluation: TRUE
[16:01:44.075] Local evaluation: TRUE
[16:01:44.075] Environment: R_GlobalEnv
[16:01:44.075] Capture standard output: TRUE
[16:01:44.075] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:01:44.075] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:44.075] Packages: <none>
[16:01:44.075] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:01:44.075] Resolved: FALSE
[16:01:44.075] Value: <not collected>
[16:01:44.075] Conditions captured: <none>
[16:01:44.075] Early signaling: FALSE
[16:01:44.075] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:44.075] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:44.087] Chunk #2 of 2 ... DONE
[16:01:44.087] Launching 2 futures (chunks) ... DONE
[16:01:44.088] Resolving 2 futures (chunks) ...
[16:01:44.088] resolve() on list ...
[16:01:44.088]  recursive: 0
[16:01:44.088]  length: 2
[16:01:44.088] 
[16:01:44.089] receiveMessageFromWorker() for ClusterFuture ...
[16:01:44.089] - Validating connection of MultisessionFuture
[16:01:44.089] - received message: FutureResult
[16:01:44.089] - Received FutureResult
[16:01:44.089] - Erased future from FutureRegistry
[16:01:44.089] result() for ClusterFuture ...
[16:01:44.089] - result already collected: FutureResult
[16:01:44.090] result() for ClusterFuture ... done
[16:01:44.090] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:44.090] Future #1
[16:01:44.090] result() for ClusterFuture ...
[16:01:44.090] - result already collected: FutureResult
[16:01:44.090] result() for ClusterFuture ... done
[16:01:44.090] result() for ClusterFuture ...
[16:01:44.090] - result already collected: FutureResult
[16:01:44.090] result() for ClusterFuture ... done
[16:01:44.090] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:01:44.090] - nx: 2
[16:01:44.091] - relay: TRUE
[16:01:44.091] - stdout: TRUE
[16:01:44.091] - signal: TRUE
[16:01:44.091] - resignal: FALSE
[16:01:44.091] - force: TRUE
[16:01:44.091] - relayed: [n=2] FALSE, FALSE
[16:01:44.091] - queued futures: [n=2] FALSE, FALSE
[16:01:44.091]  - until=1
[16:01:44.091]  - relaying element #1
[16:01:44.091] result() for ClusterFuture ...
[16:01:44.092] - result already collected: FutureResult
[16:01:44.092] result() for ClusterFuture ... done
[16:01:44.092] result() for ClusterFuture ...
[16:01:44.092] - result already collected: FutureResult
[16:01:44.092] result() for ClusterFuture ... done
[16:01:44.092] result() for ClusterFuture ...
[16:01:44.092] - result already collected: FutureResult
[16:01:44.092] result() for ClusterFuture ... done
[16:01:44.092] result() for ClusterFuture ...
[16:01:44.092] - result already collected: FutureResult
[16:01:44.092] result() for ClusterFuture ... done
[16:01:44.093] - relayed: [n=2] TRUE, FALSE
[16:01:44.093] - queued futures: [n=2] TRUE, FALSE
[16:01:44.093] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:01:44.093]  length: 1 (resolved future 1)
[16:01:44.124] receiveMessageFromWorker() for ClusterFuture ...
[16:01:44.124] - Validating connection of MultisessionFuture
[16:01:44.125] - received message: FutureResult
[16:01:44.125] - Received FutureResult
[16:01:44.125] - Erased future from FutureRegistry
[16:01:44.125] result() for ClusterFuture ...
[16:01:44.125] - result already collected: FutureResult
[16:01:44.125] result() for ClusterFuture ... done
[16:01:44.125] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:44.125] Future #2
[16:01:44.126] result() for ClusterFuture ...
[16:01:44.126] - result already collected: FutureResult
[16:01:44.126] result() for ClusterFuture ... done
[16:01:44.126] result() for ClusterFuture ...
[16:01:44.126] - result already collected: FutureResult
[16:01:44.126] result() for ClusterFuture ... done
[16:01:44.126] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:01:44.126] - nx: 2
[16:01:44.126] - relay: TRUE
[16:01:44.126] - stdout: TRUE
[16:01:44.126] - signal: TRUE
[16:01:44.126] - resignal: FALSE
[16:01:44.127] - force: TRUE
[16:01:44.127] - relayed: [n=2] TRUE, FALSE
[16:01:44.127] - queued futures: [n=2] TRUE, FALSE
[16:01:44.127]  - until=2
[16:01:44.127]  - relaying element #2
[16:01:44.127] result() for ClusterFuture ...
[16:01:44.127] - result already collected: FutureResult
[16:01:44.127] result() for ClusterFuture ... done
[16:01:44.127] result() for ClusterFuture ...
[16:01:44.127] - result already collected: FutureResult
[16:01:44.128] result() for ClusterFuture ... done
[16:01:44.128] result() for ClusterFuture ...
[16:01:44.128] - result already collected: FutureResult
[16:01:44.128] result() for ClusterFuture ... done
[16:01:44.128] result() for ClusterFuture ...
[16:01:44.128] - result already collected: FutureResult
[16:01:44.128] result() for ClusterFuture ... done
[16:01:44.128] - relayed: [n=2] TRUE, TRUE
[16:01:44.128] - queued futures: [n=2] TRUE, TRUE
[16:01:44.128] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:01:44.128]  length: 0 (resolved future 2)
[16:01:44.129] Relaying remaining futures
[16:01:44.129] signalConditionsASAP(NULL, pos=0) ...
[16:01:44.129] - nx: 2
[16:01:44.129] - relay: TRUE
[16:01:44.129] - stdout: TRUE
[16:01:44.129] - signal: TRUE
[16:01:44.129] - resignal: FALSE
[16:01:44.129] - force: TRUE
[16:01:44.129] - relayed: [n=2] TRUE, TRUE
[16:01:44.129] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:44.129] - relayed: [n=2] TRUE, TRUE
[16:01:44.130] - queued futures: [n=2] TRUE, TRUE
[16:01:44.130] signalConditionsASAP(NULL, pos=0) ... done
[16:01:44.130] resolve() on list ... DONE
[16:01:44.130] result() for ClusterFuture ...
[16:01:44.130] - result already collected: FutureResult
[16:01:44.130] result() for ClusterFuture ... done
[16:01:44.130] result() for ClusterFuture ...
[16:01:44.130] - result already collected: FutureResult
[16:01:44.130] result() for ClusterFuture ... done
[16:01:44.130] result() for ClusterFuture ...
[16:01:44.130] - result already collected: FutureResult
[16:01:44.131] result() for ClusterFuture ... done
[16:01:44.131] result() for ClusterFuture ...
[16:01:44.131] - result already collected: FutureResult
[16:01:44.131] result() for ClusterFuture ... done
[16:01:44.131]  - Number of value chunks collected: 2
[16:01:44.131] Resolving 2 futures (chunks) ... DONE
[16:01:44.131] Reducing values from 2 chunks ...
[16:01:44.131]  - Number of values collected after concatenation: 2
[16:01:44.131]  - Number of values expected: 2
[16:01:44.131] Reducing values from 2 chunks ... DONE
[16:01:44.132] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[16:01:44.132] getGlobalsAndPackagesXApply() ...
[16:01:44.132]  - future.globals: TRUE
[16:01:44.132] getGlobalsAndPackages() ...
[16:01:44.132] Searching for globals...
[16:01:44.135] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[16:01:44.135] Searching for globals ... DONE
[16:01:44.135] Resolving globals: FALSE
[16:01:44.136] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[16:01:44.136] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[16:01:44.136] - globals: [1] ‘FUN’
[16:01:44.137] 
[16:01:44.137] getGlobalsAndPackages() ... DONE
[16:01:44.137]  - globals found/used: [n=1] ‘FUN’
[16:01:44.137]  - needed namespaces: [n=0] 
[16:01:44.137] Finding globals ... DONE
[16:01:44.137]  - use_args: TRUE
[16:01:44.137]  - Getting '...' globals ...
[16:01:44.137] resolve() on list ...
[16:01:44.138]  recursive: 0
[16:01:44.138]  length: 1
[16:01:44.138]  elements: ‘...’
[16:01:44.138]  length: 0 (resolved future 1)
[16:01:44.138] resolve() on list ... DONE
[16:01:44.138]    - '...' content: [n=0] 
[16:01:44.138] List of 1
[16:01:44.138]  $ ...: list()
[16:01:44.138]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:44.138]  - attr(*, "where")=List of 1
[16:01:44.138]   ..$ ...:<environment: 0x55fb655ccb30> 
[16:01:44.138]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:44.138]  - attr(*, "resolved")= logi TRUE
[16:01:44.138]  - attr(*, "total_size")= num NA
[16:01:44.141]  - Getting '...' globals ... DONE
[16:01:44.141] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:01:44.141] List of 2
[16:01:44.141]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[16:01:44.141]  $ ...          : list()
[16:01:44.141]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:44.141]  - attr(*, "where")=List of 2
[16:01:44.141]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:01:44.141]   ..$ ...          :<environment: 0x55fb655ccb30> 
[16:01:44.141]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:44.141]  - attr(*, "resolved")= logi FALSE
[16:01:44.141]  - attr(*, "total_size")= num 36296
[16:01:44.144] Packages to be attached in all futures: [n=0] 
[16:01:44.144] getGlobalsAndPackagesXApply() ... DONE
[16:01:44.148] future_lapply() ...
[16:01:44.150] Generating random seeds ...
[16:01:44.150] Generating random seed streams for 2 elements ...
[16:01:44.150] Generating random seed streams for 2 elements ... DONE
[16:01:44.150] Generating random seeds ... DONE
[16:01:44.150] Will set RNG state on exit: 10407, -227317540, 1310151549, -660457601, 1643107619, 675423661, -1369559488
[16:01:44.154] Number of chunks: 2
[16:01:44.154] getGlobalsAndPackagesXApply() ...
[16:01:44.154]  - future.globals: <name-value list> with names ‘list()’
[16:01:44.154]  - use_args: TRUE
[16:01:44.154] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:01:44.154] List of 2
[16:01:44.154]  $ ...          : list()
[16:01:44.154]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:01:44.154]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[16:01:44.154]  - attr(*, "where")=List of 2
[16:01:44.154]   ..$ ...          :<environment: 0x55fb655ccb30> 
[16:01:44.154]   ..$ ...future.FUN:<environment: namespace:base> 
[16:01:44.154]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:01:44.154]  - attr(*, "resolved")= logi FALSE
[16:01:44.154]  - attr(*, "total_size")= num NA
[16:01:44.158] Packages to be attached in all futures: [n=0] 
[16:01:44.158] getGlobalsAndPackagesXApply() ... DONE
[16:01:44.158] Number of futures (= number of chunks): 2
[16:01:44.158] Launching 2 futures (chunks) ...
[16:01:44.158] Chunk #1 of 2 ...
[16:01:44.158]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:44.159]  - seeds: [1] <seeds>
[16:01:44.159]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:44.159] getGlobalsAndPackages() ...
[16:01:44.159] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:44.159] Resolving globals: FALSE
[16:01:44.159] Tweak future expression to call with '...' arguments ...
[16:01:44.159] {
[16:01:44.159]     do.call(function(...) {
[16:01:44.159]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:44.159]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:44.159]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:44.159]             on.exit(options(oopts), add = TRUE)
[16:01:44.159]         }
[16:01:44.159]         {
[16:01:44.159]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:44.159]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:44.159]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:01:44.159]                   envir = globalenv(), inherits = FALSE)
[16:01:44.159]                 ...future.FUN(...future.X_jj, ...)
[16:01:44.159]             })
[16:01:44.159]         }
[16:01:44.159]     }, args = future.call.arguments)
[16:01:44.159] }
[16:01:44.160] Tweak future expression to call with '...' arguments ... DONE
[16:01:44.160] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:44.160] 
[16:01:44.160] getGlobalsAndPackages() ... DONE
[16:01:44.161] run() for ‘Future’ ...
[16:01:44.161] - state: ‘created’
[16:01:44.161] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:44.175] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:44.175] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:44.175]   - Field: ‘node’
[16:01:44.175]   - Field: ‘label’
[16:01:44.175]   - Field: ‘local’
[16:01:44.175]   - Field: ‘owner’
[16:01:44.175]   - Field: ‘envir’
[16:01:44.175]   - Field: ‘workers’
[16:01:44.176]   - Field: ‘packages’
[16:01:44.176]   - Field: ‘gc’
[16:01:44.176]   - Field: ‘conditions’
[16:01:44.176]   - Field: ‘persistent’
[16:01:44.176]   - Field: ‘expr’
[16:01:44.176]   - Field: ‘uuid’
[16:01:44.176]   - Field: ‘seed’
[16:01:44.176]   - Field: ‘version’
[16:01:44.176]   - Field: ‘result’
[16:01:44.176]   - Field: ‘asynchronous’
[16:01:44.176]   - Field: ‘calls’
[16:01:44.177]   - Field: ‘globals’
[16:01:44.177]   - Field: ‘stdout’
[16:01:44.177]   - Field: ‘earlySignal’
[16:01:44.177]   - Field: ‘lazy’
[16:01:44.177]   - Field: ‘state’
[16:01:44.177] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:44.177] - Launch lazy future ...
[16:01:44.177] Packages needed by the future expression (n = 0): <none>
[16:01:44.178] Packages needed by future strategies (n = 0): <none>
[16:01:44.178] {
[16:01:44.178]     {
[16:01:44.178]         {
[16:01:44.178]             ...future.startTime <- base::Sys.time()
[16:01:44.178]             {
[16:01:44.178]                 {
[16:01:44.178]                   {
[16:01:44.178]                     {
[16:01:44.178]                       base::local({
[16:01:44.178]                         has_future <- base::requireNamespace("future", 
[16:01:44.178]                           quietly = TRUE)
[16:01:44.178]                         if (has_future) {
[16:01:44.178]                           ns <- base::getNamespace("future")
[16:01:44.178]                           version <- ns[[".package"]][["version"]]
[16:01:44.178]                           if (is.null(version)) 
[16:01:44.178]                             version <- utils::packageVersion("future")
[16:01:44.178]                         }
[16:01:44.178]                         else {
[16:01:44.178]                           version <- NULL
[16:01:44.178]                         }
[16:01:44.178]                         if (!has_future || version < "1.8.0") {
[16:01:44.178]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:44.178]                             "", base::R.version$version.string), 
[16:01:44.178]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:44.178]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:44.178]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:44.178]                               "release", "version")], collapse = " "), 
[16:01:44.178]                             hostname = base::Sys.info()[["nodename"]])
[16:01:44.178]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:44.178]                             info)
[16:01:44.178]                           info <- base::paste(info, collapse = "; ")
[16:01:44.178]                           if (!has_future) {
[16:01:44.178]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:44.178]                               info)
[16:01:44.178]                           }
[16:01:44.178]                           else {
[16:01:44.178]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:44.178]                               info, version)
[16:01:44.178]                           }
[16:01:44.178]                           base::stop(msg)
[16:01:44.178]                         }
[16:01:44.178]                       })
[16:01:44.178]                     }
[16:01:44.178]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:44.178]                     base::options(mc.cores = 1L)
[16:01:44.178]                   }
[16:01:44.178]                   options(future.plan = NULL)
[16:01:44.178]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:44.178]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:44.178]                 }
[16:01:44.178]                 ...future.workdir <- getwd()
[16:01:44.178]             }
[16:01:44.178]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:44.178]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:44.178]         }
[16:01:44.178]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:44.178]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:44.178]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:44.178]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:44.178]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:44.178]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:44.178]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:44.178]             base::names(...future.oldOptions))
[16:01:44.178]     }
[16:01:44.178]     if (FALSE) {
[16:01:44.178]     }
[16:01:44.178]     else {
[16:01:44.178]         if (TRUE) {
[16:01:44.178]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:44.178]                 open = "w")
[16:01:44.178]         }
[16:01:44.178]         else {
[16:01:44.178]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:44.178]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:44.178]         }
[16:01:44.178]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:44.178]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:44.178]             base::sink(type = "output", split = FALSE)
[16:01:44.178]             base::close(...future.stdout)
[16:01:44.178]         }, add = TRUE)
[16:01:44.178]     }
[16:01:44.178]     ...future.frame <- base::sys.nframe()
[16:01:44.178]     ...future.conditions <- base::list()
[16:01:44.178]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:44.178]     if (FALSE) {
[16:01:44.178]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:44.178]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:44.178]     }
[16:01:44.178]     ...future.result <- base::tryCatch({
[16:01:44.178]         base::withCallingHandlers({
[16:01:44.178]             ...future.value <- base::withVisible(base::local({
[16:01:44.178]                 ...future.makeSendCondition <- base::local({
[16:01:44.178]                   sendCondition <- NULL
[16:01:44.178]                   function(frame = 1L) {
[16:01:44.178]                     if (is.function(sendCondition)) 
[16:01:44.178]                       return(sendCondition)
[16:01:44.178]                     ns <- getNamespace("parallel")
[16:01:44.178]                     if (exists("sendData", mode = "function", 
[16:01:44.178]                       envir = ns)) {
[16:01:44.178]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:44.178]                         envir = ns)
[16:01:44.178]                       envir <- sys.frame(frame)
[16:01:44.178]                       master <- NULL
[16:01:44.178]                       while (!identical(envir, .GlobalEnv) && 
[16:01:44.178]                         !identical(envir, emptyenv())) {
[16:01:44.178]                         if (exists("master", mode = "list", envir = envir, 
[16:01:44.178]                           inherits = FALSE)) {
[16:01:44.178]                           master <- get("master", mode = "list", 
[16:01:44.178]                             envir = envir, inherits = FALSE)
[16:01:44.178]                           if (inherits(master, c("SOCKnode", 
[16:01:44.178]                             "SOCK0node"))) {
[16:01:44.178]                             sendCondition <<- function(cond) {
[16:01:44.178]                               data <- list(type = "VALUE", value = cond, 
[16:01:44.178]                                 success = TRUE)
[16:01:44.178]                               parallel_sendData(master, data)
[16:01:44.178]                             }
[16:01:44.178]                             return(sendCondition)
[16:01:44.178]                           }
[16:01:44.178]                         }
[16:01:44.178]                         frame <- frame + 1L
[16:01:44.178]                         envir <- sys.frame(frame)
[16:01:44.178]                       }
[16:01:44.178]                     }
[16:01:44.178]                     sendCondition <<- function(cond) NULL
[16:01:44.178]                   }
[16:01:44.178]                 })
[16:01:44.178]                 withCallingHandlers({
[16:01:44.178]                   {
[16:01:44.178]                     do.call(function(...) {
[16:01:44.178]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:44.178]                       if (!identical(...future.globals.maxSize.org, 
[16:01:44.178]                         ...future.globals.maxSize)) {
[16:01:44.178]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:44.178]                         on.exit(options(oopts), add = TRUE)
[16:01:44.178]                       }
[16:01:44.178]                       {
[16:01:44.178]                         lapply(seq_along(...future.elements_ii), 
[16:01:44.178]                           FUN = function(jj) {
[16:01:44.178]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:44.178]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:01:44.178]                               envir = globalenv(), inherits = FALSE)
[16:01:44.178]                             ...future.FUN(...future.X_jj, ...)
[16:01:44.178]                           })
[16:01:44.178]                       }
[16:01:44.178]                     }, args = future.call.arguments)
[16:01:44.178]                   }
[16:01:44.178]                 }, immediateCondition = function(cond) {
[16:01:44.178]                   sendCondition <- ...future.makeSendCondition()
[16:01:44.178]                   sendCondition(cond)
[16:01:44.178]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:44.178]                   {
[16:01:44.178]                     inherits <- base::inherits
[16:01:44.178]                     invokeRestart <- base::invokeRestart
[16:01:44.178]                     is.null <- base::is.null
[16:01:44.178]                     muffled <- FALSE
[16:01:44.178]                     if (inherits(cond, "message")) {
[16:01:44.178]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:44.178]                       if (muffled) 
[16:01:44.178]                         invokeRestart("muffleMessage")
[16:01:44.178]                     }
[16:01:44.178]                     else if (inherits(cond, "warning")) {
[16:01:44.178]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:44.178]                       if (muffled) 
[16:01:44.178]                         invokeRestart("muffleWarning")
[16:01:44.178]                     }
[16:01:44.178]                     else if (inherits(cond, "condition")) {
[16:01:44.178]                       if (!is.null(pattern)) {
[16:01:44.178]                         computeRestarts <- base::computeRestarts
[16:01:44.178]                         grepl <- base::grepl
[16:01:44.178]                         restarts <- computeRestarts(cond)
[16:01:44.178]                         for (restart in restarts) {
[16:01:44.178]                           name <- restart$name
[16:01:44.178]                           if (is.null(name)) 
[16:01:44.178]                             next
[16:01:44.178]                           if (!grepl(pattern, name)) 
[16:01:44.178]                             next
[16:01:44.178]                           invokeRestart(restart)
[16:01:44.178]                           muffled <- TRUE
[16:01:44.178]                           break
[16:01:44.178]                         }
[16:01:44.178]                       }
[16:01:44.178]                     }
[16:01:44.178]                     invisible(muffled)
[16:01:44.178]                   }
[16:01:44.178]                   muffleCondition(cond)
[16:01:44.178]                 })
[16:01:44.178]             }))
[16:01:44.178]             future::FutureResult(value = ...future.value$value, 
[16:01:44.178]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:44.178]                   ...future.rng), globalenv = if (FALSE) 
[16:01:44.178]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:44.178]                     ...future.globalenv.names))
[16:01:44.178]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:44.178]         }, condition = base::local({
[16:01:44.178]             c <- base::c
[16:01:44.178]             inherits <- base::inherits
[16:01:44.178]             invokeRestart <- base::invokeRestart
[16:01:44.178]             length <- base::length
[16:01:44.178]             list <- base::list
[16:01:44.178]             seq.int <- base::seq.int
[16:01:44.178]             signalCondition <- base::signalCondition
[16:01:44.178]             sys.calls <- base::sys.calls
[16:01:44.178]             `[[` <- base::`[[`
[16:01:44.178]             `+` <- base::`+`
[16:01:44.178]             `<<-` <- base::`<<-`
[16:01:44.178]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:44.178]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:44.178]                   3L)]
[16:01:44.178]             }
[16:01:44.178]             function(cond) {
[16:01:44.178]                 is_error <- inherits(cond, "error")
[16:01:44.178]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:44.178]                   NULL)
[16:01:44.178]                 if (is_error) {
[16:01:44.178]                   sessionInformation <- function() {
[16:01:44.178]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:44.178]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:44.178]                       search = base::search(), system = base::Sys.info())
[16:01:44.178]                   }
[16:01:44.178]                   ...future.conditions[[length(...future.conditions) + 
[16:01:44.178]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:44.178]                     cond$call), session = sessionInformation(), 
[16:01:44.178]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:44.178]                   signalCondition(cond)
[16:01:44.178]                 }
[16:01:44.178]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[16:01:44.178]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:44.178]                   ...future.conditions[[length(...future.conditions) + 
[16:01:44.178]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:44.178]                   if (TRUE && !signal) {
[16:01:44.178]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:44.178]                     {
[16:01:44.178]                       inherits <- base::inherits
[16:01:44.178]                       invokeRestart <- base::invokeRestart
[16:01:44.178]                       is.null <- base::is.null
[16:01:44.178]                       muffled <- FALSE
[16:01:44.178]                       if (inherits(cond, "message")) {
[16:01:44.178]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:44.178]                         if (muffled) 
[16:01:44.178]                           invokeRestart("muffleMessage")
[16:01:44.178]                       }
[16:01:44.178]                       else if (inherits(cond, "warning")) {
[16:01:44.178]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:44.178]                         if (muffled) 
[16:01:44.178]                           invokeRestart("muffleWarning")
[16:01:44.178]                       }
[16:01:44.178]                       else if (inherits(cond, "condition")) {
[16:01:44.178]                         if (!is.null(pattern)) {
[16:01:44.178]                           computeRestarts <- base::computeRestarts
[16:01:44.178]                           grepl <- base::grepl
[16:01:44.178]                           restarts <- computeRestarts(cond)
[16:01:44.178]                           for (restart in restarts) {
[16:01:44.178]                             name <- restart$name
[16:01:44.178]                             if (is.null(name)) 
[16:01:44.178]                               next
[16:01:44.178]                             if (!grepl(pattern, name)) 
[16:01:44.178]                               next
[16:01:44.178]                             invokeRestart(restart)
[16:01:44.178]                             muffled <- TRUE
[16:01:44.178]                             break
[16:01:44.178]                           }
[16:01:44.178]                         }
[16:01:44.178]                       }
[16:01:44.178]                       invisible(muffled)
[16:01:44.178]                     }
[16:01:44.178]                     muffleCondition(cond, pattern = "^muffle")
[16:01:44.178]                   }
[16:01:44.178]                 }
[16:01:44.178]                 else {
[16:01:44.178]                   if (TRUE) {
[16:01:44.178]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:44.178]                     {
[16:01:44.178]                       inherits <- base::inherits
[16:01:44.178]                       invokeRestart <- base::invokeRestart
[16:01:44.178]                       is.null <- base::is.null
[16:01:44.178]                       muffled <- FALSE
[16:01:44.178]                       if (inherits(cond, "message")) {
[16:01:44.178]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:44.178]                         if (muffled) 
[16:01:44.178]                           invokeRestart("muffleMessage")
[16:01:44.178]                       }
[16:01:44.178]                       else if (inherits(cond, "warning")) {
[16:01:44.178]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:44.178]                         if (muffled) 
[16:01:44.178]                           invokeRestart("muffleWarning")
[16:01:44.178]                       }
[16:01:44.178]                       else if (inherits(cond, "condition")) {
[16:01:44.178]                         if (!is.null(pattern)) {
[16:01:44.178]                           computeRestarts <- base::computeRestarts
[16:01:44.178]                           grepl <- base::grepl
[16:01:44.178]                           restarts <- computeRestarts(cond)
[16:01:44.178]                           for (restart in restarts) {
[16:01:44.178]                             name <- restart$name
[16:01:44.178]                             if (is.null(name)) 
[16:01:44.178]                               next
[16:01:44.178]                             if (!grepl(pattern, name)) 
[16:01:44.178]                               next
[16:01:44.178]                             invokeRestart(restart)
[16:01:44.178]                             muffled <- TRUE
[16:01:44.178]                             break
[16:01:44.178]                           }
[16:01:44.178]                         }
[16:01:44.178]                       }
[16:01:44.178]                       invisible(muffled)
[16:01:44.178]                     }
[16:01:44.178]                     muffleCondition(cond, pattern = "^muffle")
[16:01:44.178]                   }
[16:01:44.178]                 }
[16:01:44.178]             }
[16:01:44.178]         }))
[16:01:44.178]     }, error = function(ex) {
[16:01:44.178]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:44.178]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:44.178]                 ...future.rng), started = ...future.startTime, 
[16:01:44.178]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:44.178]             version = "1.8"), class = "FutureResult")
[16:01:44.178]     }, finally = {
[16:01:44.178]         if (!identical(...future.workdir, getwd())) 
[16:01:44.178]             setwd(...future.workdir)
[16:01:44.178]         {
[16:01:44.178]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:44.178]                 ...future.oldOptions$nwarnings <- NULL
[16:01:44.178]             }
[16:01:44.178]             base::options(...future.oldOptions)
[16:01:44.178]             if (.Platform$OS.type == "windows") {
[16:01:44.178]                 old_names <- names(...future.oldEnvVars)
[16:01:44.178]                 envs <- base::Sys.getenv()
[16:01:44.178]                 names <- names(envs)
[16:01:44.178]                 common <- intersect(names, old_names)
[16:01:44.178]                 added <- setdiff(names, old_names)
[16:01:44.178]                 removed <- setdiff(old_names, names)
[16:01:44.178]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:44.178]                   envs[common]]
[16:01:44.178]                 NAMES <- toupper(changed)
[16:01:44.178]                 args <- list()
[16:01:44.178]                 for (kk in seq_along(NAMES)) {
[16:01:44.178]                   name <- changed[[kk]]
[16:01:44.178]                   NAME <- NAMES[[kk]]
[16:01:44.178]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:44.178]                     next
[16:01:44.178]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:44.178]                 }
[16:01:44.178]                 NAMES <- toupper(added)
[16:01:44.178]                 for (kk in seq_along(NAMES)) {
[16:01:44.178]                   name <- added[[kk]]
[16:01:44.178]                   NAME <- NAMES[[kk]]
[16:01:44.178]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:44.178]                     next
[16:01:44.178]                   args[[name]] <- ""
[16:01:44.178]                 }
[16:01:44.178]                 NAMES <- toupper(removed)
[16:01:44.178]                 for (kk in seq_along(NAMES)) {
[16:01:44.178]                   name <- removed[[kk]]
[16:01:44.178]                   NAME <- NAMES[[kk]]
[16:01:44.178]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:44.178]                     next
[16:01:44.178]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:44.178]                 }
[16:01:44.178]                 if (length(args) > 0) 
[16:01:44.178]                   base::do.call(base::Sys.setenv, args = args)
[16:01:44.178]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:44.178]             }
[16:01:44.178]             else {
[16:01:44.178]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:44.178]             }
[16:01:44.178]             {
[16:01:44.178]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:44.178]                   0L) {
[16:01:44.178]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:44.178]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:44.178]                   base::options(opts)
[16:01:44.178]                 }
[16:01:44.178]                 {
[16:01:44.178]                   {
[16:01:44.178]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:44.178]                     NULL
[16:01:44.178]                   }
[16:01:44.178]                   options(future.plan = NULL)
[16:01:44.178]                   if (is.na(NA_character_)) 
[16:01:44.178]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:44.178]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:44.178]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:44.178]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:44.178]                     envir = parent.frame()) 
[16:01:44.178]                   {
[16:01:44.178]                     if (is.function(workers)) 
[16:01:44.178]                       workers <- workers()
[16:01:44.178]                     workers <- structure(as.integer(workers), 
[16:01:44.178]                       class = class(workers))
[16:01:44.178]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:44.178]                       workers >= 1)
[16:01:44.178]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:44.178]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:44.178]                     }
[16:01:44.178]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:44.178]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:44.178]                       envir = envir)
[16:01:44.178]                     if (!future$lazy) 
[16:01:44.178]                       future <- run(future)
[16:01:44.178]                     invisible(future)
[16:01:44.178]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:44.178]                 }
[16:01:44.178]             }
[16:01:44.178]         }
[16:01:44.178]     })
[16:01:44.178]     if (TRUE) {
[16:01:44.178]         base::sink(type = "output", split = FALSE)
[16:01:44.178]         if (TRUE) {
[16:01:44.178]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:44.178]         }
[16:01:44.178]         else {
[16:01:44.178]             ...future.result["stdout"] <- base::list(NULL)
[16:01:44.178]         }
[16:01:44.178]         base::close(...future.stdout)
[16:01:44.178]         ...future.stdout <- NULL
[16:01:44.178]     }
[16:01:44.178]     ...future.result$conditions <- ...future.conditions
[16:01:44.178]     ...future.result$finished <- base::Sys.time()
[16:01:44.178]     ...future.result
[16:01:44.178] }
[16:01:44.181] Exporting 5 global objects (35.63 KiB) to cluster node #1 ...
[16:01:44.181] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:01:44.182] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:01:44.182] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ...
[16:01:44.223] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ... DONE
[16:01:44.224] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[16:01:44.224] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[16:01:44.224] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[16:01:44.225] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[16:01:44.225] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:01:44.225] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:01:44.225] Exporting 5 global objects (35.63 KiB) to cluster node #1 ... DONE
[16:01:44.226] MultisessionFuture started
[16:01:44.226] - Launch lazy future ... done
[16:01:44.226] run() for ‘MultisessionFuture’ ... done
[16:01:44.226] Created future:
[16:01:44.226] MultisessionFuture:
[16:01:44.226] Label: ‘future_apply-1’
[16:01:44.226] Expression:
[16:01:44.226] {
[16:01:44.226]     do.call(function(...) {
[16:01:44.226]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:44.226]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:44.226]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:44.226]             on.exit(options(oopts), add = TRUE)
[16:01:44.226]         }
[16:01:44.226]         {
[16:01:44.226]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:44.226]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:44.226]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:01:44.226]                   envir = globalenv(), inherits = FALSE)
[16:01:44.226]                 ...future.FUN(...future.X_jj, ...)
[16:01:44.226]             })
[16:01:44.226]         }
[16:01:44.226]     }, args = future.call.arguments)
[16:01:44.226] }
[16:01:44.226] Lazy evaluation: FALSE
[16:01:44.226] Asynchronous evaluation: TRUE
[16:01:44.226] Local evaluation: TRUE
[16:01:44.226] Environment: R_GlobalEnv
[16:01:44.226] Capture standard output: TRUE
[16:01:44.226] Capture condition classes: <none>
[16:01:44.226] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:44.226] Packages: <none>
[16:01:44.226] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[16:01:44.226] Resolved: FALSE
[16:01:44.226] Value: <not collected>
[16:01:44.226] Conditions captured: <none>
[16:01:44.226] Early signaling: FALSE
[16:01:44.226] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:44.226] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:44.238] Chunk #1 of 2 ... DONE
[16:01:44.238] Chunk #2 of 2 ...
[16:01:44.238]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:01:44.238]  - seeds: [1] <seeds>
[16:01:44.239]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:44.239] getGlobalsAndPackages() ...
[16:01:44.239] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:44.239] Resolving globals: FALSE
[16:01:44.239] Tweak future expression to call with '...' arguments ...
[16:01:44.239] {
[16:01:44.239]     do.call(function(...) {
[16:01:44.239]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:44.239]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:44.239]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:44.239]             on.exit(options(oopts), add = TRUE)
[16:01:44.239]         }
[16:01:44.239]         {
[16:01:44.239]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:44.239]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:44.239]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:01:44.239]                   envir = globalenv(), inherits = FALSE)
[16:01:44.239]                 ...future.FUN(...future.X_jj, ...)
[16:01:44.239]             })
[16:01:44.239]         }
[16:01:44.239]     }, args = future.call.arguments)
[16:01:44.239] }
[16:01:44.240] Tweak future expression to call with '...' arguments ... DONE
[16:01:44.240] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:01:44.240] 
[16:01:44.240] getGlobalsAndPackages() ... DONE
[16:01:44.241] run() for ‘Future’ ...
[16:01:44.241] - state: ‘created’
[16:01:44.241] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:01:44.255] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:44.255] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:01:44.255]   - Field: ‘node’
[16:01:44.255]   - Field: ‘label’
[16:01:44.256]   - Field: ‘local’
[16:01:44.256]   - Field: ‘owner’
[16:01:44.256]   - Field: ‘envir’
[16:01:44.256]   - Field: ‘workers’
[16:01:44.256]   - Field: ‘packages’
[16:01:44.256]   - Field: ‘gc’
[16:01:44.256]   - Field: ‘conditions’
[16:01:44.256]   - Field: ‘persistent’
[16:01:44.256]   - Field: ‘expr’
[16:01:44.256]   - Field: ‘uuid’
[16:01:44.257]   - Field: ‘seed’
[16:01:44.257]   - Field: ‘version’
[16:01:44.257]   - Field: ‘result’
[16:01:44.257]   - Field: ‘asynchronous’
[16:01:44.257]   - Field: ‘calls’
[16:01:44.257]   - Field: ‘globals’
[16:01:44.257]   - Field: ‘stdout’
[16:01:44.257]   - Field: ‘earlySignal’
[16:01:44.257]   - Field: ‘lazy’
[16:01:44.257]   - Field: ‘state’
[16:01:44.257] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:01:44.258] - Launch lazy future ...
[16:01:44.258] Packages needed by the future expression (n = 0): <none>
[16:01:44.258] Packages needed by future strategies (n = 0): <none>
[16:01:44.258] {
[16:01:44.258]     {
[16:01:44.258]         {
[16:01:44.258]             ...future.startTime <- base::Sys.time()
[16:01:44.258]             {
[16:01:44.258]                 {
[16:01:44.258]                   {
[16:01:44.258]                     {
[16:01:44.258]                       base::local({
[16:01:44.258]                         has_future <- base::requireNamespace("future", 
[16:01:44.258]                           quietly = TRUE)
[16:01:44.258]                         if (has_future) {
[16:01:44.258]                           ns <- base::getNamespace("future")
[16:01:44.258]                           version <- ns[[".package"]][["version"]]
[16:01:44.258]                           if (is.null(version)) 
[16:01:44.258]                             version <- utils::packageVersion("future")
[16:01:44.258]                         }
[16:01:44.258]                         else {
[16:01:44.258]                           version <- NULL
[16:01:44.258]                         }
[16:01:44.258]                         if (!has_future || version < "1.8.0") {
[16:01:44.258]                           info <- base::c(r_version = base::gsub("R version ", 
[16:01:44.258]                             "", base::R.version$version.string), 
[16:01:44.258]                             platform = base::sprintf("%s (%s-bit)", 
[16:01:44.258]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:01:44.258]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:01:44.258]                               "release", "version")], collapse = " "), 
[16:01:44.258]                             hostname = base::Sys.info()[["nodename"]])
[16:01:44.258]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:01:44.258]                             info)
[16:01:44.258]                           info <- base::paste(info, collapse = "; ")
[16:01:44.258]                           if (!has_future) {
[16:01:44.258]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:01:44.258]                               info)
[16:01:44.258]                           }
[16:01:44.258]                           else {
[16:01:44.258]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:01:44.258]                               info, version)
[16:01:44.258]                           }
[16:01:44.258]                           base::stop(msg)
[16:01:44.258]                         }
[16:01:44.258]                       })
[16:01:44.258]                     }
[16:01:44.258]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:01:44.258]                     base::options(mc.cores = 1L)
[16:01:44.258]                   }
[16:01:44.258]                   options(future.plan = NULL)
[16:01:44.258]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:01:44.258]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:01:44.258]                 }
[16:01:44.258]                 ...future.workdir <- getwd()
[16:01:44.258]             }
[16:01:44.258]             ...future.oldOptions <- base::as.list(base::.Options)
[16:01:44.258]             ...future.oldEnvVars <- base::Sys.getenv()
[16:01:44.258]         }
[16:01:44.258]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:01:44.258]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:01:44.258]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:01:44.258]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:01:44.258]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:01:44.258]             future.stdout.windows.reencode = NULL, width = 80L)
[16:01:44.258]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:01:44.258]             base::names(...future.oldOptions))
[16:01:44.258]     }
[16:01:44.258]     if (FALSE) {
[16:01:44.258]     }
[16:01:44.258]     else {
[16:01:44.258]         if (TRUE) {
[16:01:44.258]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:01:44.258]                 open = "w")
[16:01:44.258]         }
[16:01:44.258]         else {
[16:01:44.258]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:01:44.258]                 windows = "NUL", "/dev/null"), open = "w")
[16:01:44.258]         }
[16:01:44.258]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:01:44.258]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:01:44.258]             base::sink(type = "output", split = FALSE)
[16:01:44.258]             base::close(...future.stdout)
[16:01:44.258]         }, add = TRUE)
[16:01:44.258]     }
[16:01:44.258]     ...future.frame <- base::sys.nframe()
[16:01:44.258]     ...future.conditions <- base::list()
[16:01:44.258]     ...future.rng <- base::globalenv()$.Random.seed
[16:01:44.258]     if (FALSE) {
[16:01:44.258]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:01:44.258]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:01:44.258]     }
[16:01:44.258]     ...future.result <- base::tryCatch({
[16:01:44.258]         base::withCallingHandlers({
[16:01:44.258]             ...future.value <- base::withVisible(base::local({
[16:01:44.258]                 ...future.makeSendCondition <- base::local({
[16:01:44.258]                   sendCondition <- NULL
[16:01:44.258]                   function(frame = 1L) {
[16:01:44.258]                     if (is.function(sendCondition)) 
[16:01:44.258]                       return(sendCondition)
[16:01:44.258]                     ns <- getNamespace("parallel")
[16:01:44.258]                     if (exists("sendData", mode = "function", 
[16:01:44.258]                       envir = ns)) {
[16:01:44.258]                       parallel_sendData <- get("sendData", mode = "function", 
[16:01:44.258]                         envir = ns)
[16:01:44.258]                       envir <- sys.frame(frame)
[16:01:44.258]                       master <- NULL
[16:01:44.258]                       while (!identical(envir, .GlobalEnv) && 
[16:01:44.258]                         !identical(envir, emptyenv())) {
[16:01:44.258]                         if (exists("master", mode = "list", envir = envir, 
[16:01:44.258]                           inherits = FALSE)) {
[16:01:44.258]                           master <- get("master", mode = "list", 
[16:01:44.258]                             envir = envir, inherits = FALSE)
[16:01:44.258]                           if (inherits(master, c("SOCKnode", 
[16:01:44.258]                             "SOCK0node"))) {
[16:01:44.258]                             sendCondition <<- function(cond) {
[16:01:44.258]                               data <- list(type = "VALUE", value = cond, 
[16:01:44.258]                                 success = TRUE)
[16:01:44.258]                               parallel_sendData(master, data)
[16:01:44.258]                             }
[16:01:44.258]                             return(sendCondition)
[16:01:44.258]                           }
[16:01:44.258]                         }
[16:01:44.258]                         frame <- frame + 1L
[16:01:44.258]                         envir <- sys.frame(frame)
[16:01:44.258]                       }
[16:01:44.258]                     }
[16:01:44.258]                     sendCondition <<- function(cond) NULL
[16:01:44.258]                   }
[16:01:44.258]                 })
[16:01:44.258]                 withCallingHandlers({
[16:01:44.258]                   {
[16:01:44.258]                     do.call(function(...) {
[16:01:44.258]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:44.258]                       if (!identical(...future.globals.maxSize.org, 
[16:01:44.258]                         ...future.globals.maxSize)) {
[16:01:44.258]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:44.258]                         on.exit(options(oopts), add = TRUE)
[16:01:44.258]                       }
[16:01:44.258]                       {
[16:01:44.258]                         lapply(seq_along(...future.elements_ii), 
[16:01:44.258]                           FUN = function(jj) {
[16:01:44.258]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:44.258]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:01:44.258]                               envir = globalenv(), inherits = FALSE)
[16:01:44.258]                             ...future.FUN(...future.X_jj, ...)
[16:01:44.258]                           })
[16:01:44.258]                       }
[16:01:44.258]                     }, args = future.call.arguments)
[16:01:44.258]                   }
[16:01:44.258]                 }, immediateCondition = function(cond) {
[16:01:44.258]                   sendCondition <- ...future.makeSendCondition()
[16:01:44.258]                   sendCondition(cond)
[16:01:44.258]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:44.258]                   {
[16:01:44.258]                     inherits <- base::inherits
[16:01:44.258]                     invokeRestart <- base::invokeRestart
[16:01:44.258]                     is.null <- base::is.null
[16:01:44.258]                     muffled <- FALSE
[16:01:44.258]                     if (inherits(cond, "message")) {
[16:01:44.258]                       muffled <- grepl(pattern, "muffleMessage")
[16:01:44.258]                       if (muffled) 
[16:01:44.258]                         invokeRestart("muffleMessage")
[16:01:44.258]                     }
[16:01:44.258]                     else if (inherits(cond, "warning")) {
[16:01:44.258]                       muffled <- grepl(pattern, "muffleWarning")
[16:01:44.258]                       if (muffled) 
[16:01:44.258]                         invokeRestart("muffleWarning")
[16:01:44.258]                     }
[16:01:44.258]                     else if (inherits(cond, "condition")) {
[16:01:44.258]                       if (!is.null(pattern)) {
[16:01:44.258]                         computeRestarts <- base::computeRestarts
[16:01:44.258]                         grepl <- base::grepl
[16:01:44.258]                         restarts <- computeRestarts(cond)
[16:01:44.258]                         for (restart in restarts) {
[16:01:44.258]                           name <- restart$name
[16:01:44.258]                           if (is.null(name)) 
[16:01:44.258]                             next
[16:01:44.258]                           if (!grepl(pattern, name)) 
[16:01:44.258]                             next
[16:01:44.258]                           invokeRestart(restart)
[16:01:44.258]                           muffled <- TRUE
[16:01:44.258]                           break
[16:01:44.258]                         }
[16:01:44.258]                       }
[16:01:44.258]                     }
[16:01:44.258]                     invisible(muffled)
[16:01:44.258]                   }
[16:01:44.258]                   muffleCondition(cond)
[16:01:44.258]                 })
[16:01:44.258]             }))
[16:01:44.258]             future::FutureResult(value = ...future.value$value, 
[16:01:44.258]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:44.258]                   ...future.rng), globalenv = if (FALSE) 
[16:01:44.258]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:01:44.258]                     ...future.globalenv.names))
[16:01:44.258]                 else NULL, started = ...future.startTime, version = "1.8")
[16:01:44.258]         }, condition = base::local({
[16:01:44.258]             c <- base::c
[16:01:44.258]             inherits <- base::inherits
[16:01:44.258]             invokeRestart <- base::invokeRestart
[16:01:44.258]             length <- base::length
[16:01:44.258]             list <- base::list
[16:01:44.258]             seq.int <- base::seq.int
[16:01:44.258]             signalCondition <- base::signalCondition
[16:01:44.258]             sys.calls <- base::sys.calls
[16:01:44.258]             `[[` <- base::`[[`
[16:01:44.258]             `+` <- base::`+`
[16:01:44.258]             `<<-` <- base::`<<-`
[16:01:44.258]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:01:44.258]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:01:44.258]                   3L)]
[16:01:44.258]             }
[16:01:44.258]             function(cond) {
[16:01:44.258]                 is_error <- inherits(cond, "error")
[16:01:44.258]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:01:44.258]                   NULL)
[16:01:44.258]                 if (is_error) {
[16:01:44.258]                   sessionInformation <- function() {
[16:01:44.258]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:01:44.258]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:01:44.258]                       search = base::search(), system = base::Sys.info())
[16:01:44.258]                   }
[16:01:44.258]                   ...future.conditions[[length(...future.conditions) + 
[16:01:44.258]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:01:44.258]                     cond$call), session = sessionInformation(), 
[16:01:44.258]                     timestamp = base::Sys.time(), signaled = 0L)
[16:01:44.258]                   signalCondition(cond)
[16:01:44.258]                 }
[16:01:44.258]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[16:01:44.258]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:01:44.258]                   ...future.conditions[[length(...future.conditions) + 
[16:01:44.258]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:01:44.258]                   if (TRUE && !signal) {
[16:01:44.258]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:44.258]                     {
[16:01:44.258]                       inherits <- base::inherits
[16:01:44.258]                       invokeRestart <- base::invokeRestart
[16:01:44.258]                       is.null <- base::is.null
[16:01:44.258]                       muffled <- FALSE
[16:01:44.258]                       if (inherits(cond, "message")) {
[16:01:44.258]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:44.258]                         if (muffled) 
[16:01:44.258]                           invokeRestart("muffleMessage")
[16:01:44.258]                       }
[16:01:44.258]                       else if (inherits(cond, "warning")) {
[16:01:44.258]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:44.258]                         if (muffled) 
[16:01:44.258]                           invokeRestart("muffleWarning")
[16:01:44.258]                       }
[16:01:44.258]                       else if (inherits(cond, "condition")) {
[16:01:44.258]                         if (!is.null(pattern)) {
[16:01:44.258]                           computeRestarts <- base::computeRestarts
[16:01:44.258]                           grepl <- base::grepl
[16:01:44.258]                           restarts <- computeRestarts(cond)
[16:01:44.258]                           for (restart in restarts) {
[16:01:44.258]                             name <- restart$name
[16:01:44.258]                             if (is.null(name)) 
[16:01:44.258]                               next
[16:01:44.258]                             if (!grepl(pattern, name)) 
[16:01:44.258]                               next
[16:01:44.258]                             invokeRestart(restart)
[16:01:44.258]                             muffled <- TRUE
[16:01:44.258]                             break
[16:01:44.258]                           }
[16:01:44.258]                         }
[16:01:44.258]                       }
[16:01:44.258]                       invisible(muffled)
[16:01:44.258]                     }
[16:01:44.258]                     muffleCondition(cond, pattern = "^muffle")
[16:01:44.258]                   }
[16:01:44.258]                 }
[16:01:44.258]                 else {
[16:01:44.258]                   if (TRUE) {
[16:01:44.258]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:01:44.258]                     {
[16:01:44.258]                       inherits <- base::inherits
[16:01:44.258]                       invokeRestart <- base::invokeRestart
[16:01:44.258]                       is.null <- base::is.null
[16:01:44.258]                       muffled <- FALSE
[16:01:44.258]                       if (inherits(cond, "message")) {
[16:01:44.258]                         muffled <- grepl(pattern, "muffleMessage")
[16:01:44.258]                         if (muffled) 
[16:01:44.258]                           invokeRestart("muffleMessage")
[16:01:44.258]                       }
[16:01:44.258]                       else if (inherits(cond, "warning")) {
[16:01:44.258]                         muffled <- grepl(pattern, "muffleWarning")
[16:01:44.258]                         if (muffled) 
[16:01:44.258]                           invokeRestart("muffleWarning")
[16:01:44.258]                       }
[16:01:44.258]                       else if (inherits(cond, "condition")) {
[16:01:44.258]                         if (!is.null(pattern)) {
[16:01:44.258]                           computeRestarts <- base::computeRestarts
[16:01:44.258]                           grepl <- base::grepl
[16:01:44.258]                           restarts <- computeRestarts(cond)
[16:01:44.258]                           for (restart in restarts) {
[16:01:44.258]                             name <- restart$name
[16:01:44.258]                             if (is.null(name)) 
[16:01:44.258]                               next
[16:01:44.258]                             if (!grepl(pattern, name)) 
[16:01:44.258]                               next
[16:01:44.258]                             invokeRestart(restart)
[16:01:44.258]                             muffled <- TRUE
[16:01:44.258]                             break
[16:01:44.258]                           }
[16:01:44.258]                         }
[16:01:44.258]                       }
[16:01:44.258]                       invisible(muffled)
[16:01:44.258]                     }
[16:01:44.258]                     muffleCondition(cond, pattern = "^muffle")
[16:01:44.258]                   }
[16:01:44.258]                 }
[16:01:44.258]             }
[16:01:44.258]         }))
[16:01:44.258]     }, error = function(ex) {
[16:01:44.258]         base::structure(base::list(value = NULL, visible = NULL, 
[16:01:44.258]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:01:44.258]                 ...future.rng), started = ...future.startTime, 
[16:01:44.258]             finished = Sys.time(), session_uuid = NA_character_, 
[16:01:44.258]             version = "1.8"), class = "FutureResult")
[16:01:44.258]     }, finally = {
[16:01:44.258]         if (!identical(...future.workdir, getwd())) 
[16:01:44.258]             setwd(...future.workdir)
[16:01:44.258]         {
[16:01:44.258]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:01:44.258]                 ...future.oldOptions$nwarnings <- NULL
[16:01:44.258]             }
[16:01:44.258]             base::options(...future.oldOptions)
[16:01:44.258]             if (.Platform$OS.type == "windows") {
[16:01:44.258]                 old_names <- names(...future.oldEnvVars)
[16:01:44.258]                 envs <- base::Sys.getenv()
[16:01:44.258]                 names <- names(envs)
[16:01:44.258]                 common <- intersect(names, old_names)
[16:01:44.258]                 added <- setdiff(names, old_names)
[16:01:44.258]                 removed <- setdiff(old_names, names)
[16:01:44.258]                 changed <- common[...future.oldEnvVars[common] != 
[16:01:44.258]                   envs[common]]
[16:01:44.258]                 NAMES <- toupper(changed)
[16:01:44.258]                 args <- list()
[16:01:44.258]                 for (kk in seq_along(NAMES)) {
[16:01:44.258]                   name <- changed[[kk]]
[16:01:44.258]                   NAME <- NAMES[[kk]]
[16:01:44.258]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:44.258]                     next
[16:01:44.258]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:44.258]                 }
[16:01:44.258]                 NAMES <- toupper(added)
[16:01:44.258]                 for (kk in seq_along(NAMES)) {
[16:01:44.258]                   name <- added[[kk]]
[16:01:44.258]                   NAME <- NAMES[[kk]]
[16:01:44.258]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:44.258]                     next
[16:01:44.258]                   args[[name]] <- ""
[16:01:44.258]                 }
[16:01:44.258]                 NAMES <- toupper(removed)
[16:01:44.258]                 for (kk in seq_along(NAMES)) {
[16:01:44.258]                   name <- removed[[kk]]
[16:01:44.258]                   NAME <- NAMES[[kk]]
[16:01:44.258]                   if (name != NAME && is.element(NAME, old_names)) 
[16:01:44.258]                     next
[16:01:44.258]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:01:44.258]                 }
[16:01:44.258]                 if (length(args) > 0) 
[16:01:44.258]                   base::do.call(base::Sys.setenv, args = args)
[16:01:44.258]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:01:44.258]             }
[16:01:44.258]             else {
[16:01:44.258]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:01:44.258]             }
[16:01:44.258]             {
[16:01:44.258]                 if (base::length(...future.futureOptionsAdded) > 
[16:01:44.258]                   0L) {
[16:01:44.258]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:01:44.258]                   base::names(opts) <- ...future.futureOptionsAdded
[16:01:44.258]                   base::options(opts)
[16:01:44.258]                 }
[16:01:44.258]                 {
[16:01:44.258]                   {
[16:01:44.258]                     base::options(mc.cores = ...future.mc.cores.old)
[16:01:44.258]                     NULL
[16:01:44.258]                   }
[16:01:44.258]                   options(future.plan = NULL)
[16:01:44.258]                   if (is.na(NA_character_)) 
[16:01:44.258]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:01:44.258]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:01:44.258]                   future::plan(list(function (..., workers = availableCores(), 
[16:01:44.258]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:01:44.258]                     envir = parent.frame()) 
[16:01:44.258]                   {
[16:01:44.258]                     if (is.function(workers)) 
[16:01:44.258]                       workers <- workers()
[16:01:44.258]                     workers <- structure(as.integer(workers), 
[16:01:44.258]                       class = class(workers))
[16:01:44.258]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:01:44.258]                       workers >= 1)
[16:01:44.258]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:01:44.258]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:01:44.258]                     }
[16:01:44.258]                     future <- MultisessionFuture(..., workers = workers, 
[16:01:44.258]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:01:44.258]                       envir = envir)
[16:01:44.258]                     if (!future$lazy) 
[16:01:44.258]                       future <- run(future)
[16:01:44.258]                     invisible(future)
[16:01:44.258]                   }), .cleanup = FALSE, .init = FALSE)
[16:01:44.258]                 }
[16:01:44.258]             }
[16:01:44.258]         }
[16:01:44.258]     })
[16:01:44.258]     if (TRUE) {
[16:01:44.258]         base::sink(type = "output", split = FALSE)
[16:01:44.258]         if (TRUE) {
[16:01:44.258]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:01:44.258]         }
[16:01:44.258]         else {
[16:01:44.258]             ...future.result["stdout"] <- base::list(NULL)
[16:01:44.258]         }
[16:01:44.258]         base::close(...future.stdout)
[16:01:44.258]         ...future.stdout <- NULL
[16:01:44.258]     }
[16:01:44.258]     ...future.result$conditions <- ...future.conditions
[16:01:44.258]     ...future.result$finished <- base::Sys.time()
[16:01:44.258]     ...future.result
[16:01:44.258] }
[16:01:44.262] Exporting 5 global objects (35.63 KiB) to cluster node #2 ...
[16:01:44.262] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:01:44.262] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:01:44.262] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #2 ...
[16:01:44.303] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #2 ... DONE
[16:01:44.304] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[16:01:44.304] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[16:01:44.304] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[16:01:44.305] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[16:01:44.305] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[16:01:44.305] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[16:01:44.305] Exporting 5 global objects (35.63 KiB) to cluster node #2 ... DONE
[16:01:44.306] MultisessionFuture started
[16:01:44.306] - Launch lazy future ... done
[16:01:44.306] run() for ‘MultisessionFuture’ ... done
[16:01:44.306] Created future:
[16:01:44.306] MultisessionFuture:
[16:01:44.306] Label: ‘future_apply-2’
[16:01:44.306] Expression:
[16:01:44.306] {
[16:01:44.306]     do.call(function(...) {
[16:01:44.306]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:01:44.306]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:01:44.306]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:01:44.306]             on.exit(options(oopts), add = TRUE)
[16:01:44.306]         }
[16:01:44.306]         {
[16:01:44.306]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:01:44.306]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:01:44.306]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:01:44.306]                   envir = globalenv(), inherits = FALSE)
[16:01:44.306]                 ...future.FUN(...future.X_jj, ...)
[16:01:44.306]             })
[16:01:44.306]         }
[16:01:44.306]     }, args = future.call.arguments)
[16:01:44.306] }
[16:01:44.306] Lazy evaluation: FALSE
[16:01:44.306] Asynchronous evaluation: TRUE
[16:01:44.306] Local evaluation: TRUE
[16:01:44.306] Environment: R_GlobalEnv
[16:01:44.306] Capture standard output: TRUE
[16:01:44.306] Capture condition classes: <none>
[16:01:44.306] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:01:44.306] Packages: <none>
[16:01:44.306] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[16:01:44.306] Resolved: FALSE
[16:01:44.306] Value: <not collected>
[16:01:44.306] Conditions captured: <none>
[16:01:44.306] Early signaling: FALSE
[16:01:44.306] Owner process: f235cec0-f70a-17a0-6469-bcc71fd236e1
[16:01:44.306] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:01:44.320] Chunk #2 of 2 ... DONE
[16:01:44.320] Launching 2 futures (chunks) ... DONE
[16:01:44.321] Resolving 2 futures (chunks) ...
[16:01:44.321] resolve() on list ...
[16:01:44.321]  recursive: 0
[16:01:44.321]  length: 2
[16:01:44.321] 
[16:01:44.321] receiveMessageFromWorker() for ClusterFuture ...
[16:01:44.322] - Validating connection of MultisessionFuture
[16:01:44.322] - received message: FutureResult
[16:01:44.322] - Received FutureResult
[16:01:44.322] - Erased future from FutureRegistry
[16:01:44.322] result() for ClusterFuture ...
[16:01:44.322] - result already collected: FutureResult
[16:01:44.322] result() for ClusterFuture ... done
[16:01:44.322] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:44.322] Future #1
[16:01:44.322] result() for ClusterFuture ...
[16:01:44.323] - result already collected: FutureResult
[16:01:44.323] result() for ClusterFuture ... done
[16:01:44.323] result() for ClusterFuture ...
[16:01:44.323] - result already collected: FutureResult
[16:01:44.323] result() for ClusterFuture ... done
[16:01:44.323] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:01:44.323] - nx: 2
[16:01:44.323] - relay: TRUE
[16:01:44.323] - stdout: TRUE
[16:01:44.323] - signal: TRUE
[16:01:44.323] - resignal: FALSE
[16:01:44.324] - force: TRUE
[16:01:44.324] - relayed: [n=2] FALSE, FALSE
[16:01:44.324] - queued futures: [n=2] FALSE, FALSE
[16:01:44.324]  - until=1
[16:01:44.324]  - relaying element #1
[16:01:44.324] result() for ClusterFuture ...
[16:01:44.324] - result already collected: FutureResult
[16:01:44.324] result() for ClusterFuture ... done
[16:01:44.324] result() for ClusterFuture ...
[16:01:44.324] - result already collected: FutureResult
[16:01:44.324] result() for ClusterFuture ... done
[16:01:44.325] result() for ClusterFuture ...
[16:01:44.325] - result already collected: FutureResult
[16:01:44.325] result() for ClusterFuture ... done
[16:01:44.325] result() for ClusterFuture ...
[16:01:44.325] - result already collected: FutureResult
[16:01:44.325] result() for ClusterFuture ... done
[16:01:44.325] - relayed: [n=2] TRUE, FALSE
[16:01:44.325] - queued futures: [n=2] TRUE, FALSE
[16:01:44.325] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:01:44.325]  length: 1 (resolved future 1)
[16:01:44.352] receiveMessageFromWorker() for ClusterFuture ...
[16:01:44.353] - Validating connection of MultisessionFuture
[16:01:44.353] - received message: FutureResult
[16:01:44.353] - Received FutureResult
[16:01:44.353] - Erased future from FutureRegistry
[16:01:44.353] result() for ClusterFuture ...
[16:01:44.353] - result already collected: FutureResult
[16:01:44.353] result() for ClusterFuture ... done
[16:01:44.353] receiveMessageFromWorker() for ClusterFuture ... done
[16:01:44.354] Future #2
[16:01:44.354] result() for ClusterFuture ...
[16:01:44.354] - result already collected: FutureResult
[16:01:44.354] result() for ClusterFuture ... done
[16:01:44.354] result() for ClusterFuture ...
[16:01:44.354] - result already collected: FutureResult
[16:01:44.354] result() for ClusterFuture ... done
[16:01:44.354] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:01:44.354] - nx: 2
[16:01:44.354] - relay: TRUE
[16:01:44.354] - stdout: TRUE
[16:01:44.355] - signal: TRUE
[16:01:44.355] - resignal: FALSE
[16:01:44.355] - force: TRUE
[16:01:44.355] - relayed: [n=2] TRUE, FALSE
[16:01:44.355] - queued futures: [n=2] TRUE, FALSE
[16:01:44.355]  - until=2
[16:01:44.355]  - relaying element #2
[16:01:44.355] result() for ClusterFuture ...
[16:01:44.355] - result already collected: FutureResult
[16:01:44.355] result() for ClusterFuture ... done
[16:01:44.355] result() for ClusterFuture ...
[16:01:44.356] - result already collected: FutureResult
[16:01:44.356] result() for ClusterFuture ... done
[16:01:44.356] result() for ClusterFuture ...
[16:01:44.356] - result already collected: FutureResult
[16:01:44.356] result() for ClusterFuture ... done
[16:01:44.356] result() for ClusterFuture ...
[16:01:44.356] - result already collected: FutureResult
[16:01:44.356] result() for ClusterFuture ... done
[16:01:44.356] - relayed: [n=2] TRUE, TRUE
[16:01:44.356] - queued futures: [n=2] TRUE, TRUE
[16:01:44.356] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:01:44.357]  length: 0 (resolved future 2)
[16:01:44.357] Relaying remaining futures
[16:01:44.357] signalConditionsASAP(NULL, pos=0) ...
[16:01:44.357] - nx: 2
[16:01:44.357] - relay: TRUE
[16:01:44.357] - stdout: TRUE
[16:01:44.357] - signal: TRUE
[16:01:44.357] - resignal: FALSE
[16:01:44.357] - force: TRUE
[16:01:44.357] - relayed: [n=2] TRUE, TRUE
[16:01:44.357] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:01:44.358] - relayed: [n=2] TRUE, TRUE
[16:01:44.358] - queued futures: [n=2] TRUE, TRUE
[16:01:44.358] signalConditionsASAP(NULL, pos=0) ... done
[16:01:44.358] resolve() on list ... DONE
[16:01:44.358] result() for ClusterFuture ...
[16:01:44.358] - result already collected: FutureResult
[16:01:44.358] result() for ClusterFuture ... done
[16:01:44.358] result() for ClusterFuture ...
[16:01:44.358] - result already collected: FutureResult
[16:01:44.358] result() for ClusterFuture ... done
[16:01:44.359] result() for ClusterFuture ...
[16:01:44.359] - result already collected: FutureResult
[16:01:44.359] result() for ClusterFuture ... done
[16:01:44.359] result() for ClusterFuture ...
[16:01:44.359] - result already collected: FutureResult
[16:01:44.359] result() for ClusterFuture ... done
[16:01:44.359]  - Number of value chunks collected: 2
[16:01:44.359] Resolving 2 futures (chunks) ... DONE
[16:01:44.359] Reducing values from 2 chunks ...
[16:01:44.359]  - Number of values collected after concatenation: 2
[16:01:44.360]  - Number of values expected: 2
[16:01:44.360] Reducing values from 2 chunks ... DONE
[16:01:44.360] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[16:01:44.360] plan(): Setting new future strategy stack:
[16:01:44.360] List of future strategies:
[16:01:44.360] 1. sequential:
[16:01:44.360]    - args: function (..., envir = parent.frame())
[16:01:44.360]    - tweaked: FALSE
[16:01:44.360]    - call: plan(sequential)
[16:01:44.361] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...")
*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...
> X <- matrix(nrow = 0L, ncol = 2L)
> y0 <- apply(X, MARGIN = 1L, FUN = identity)
> y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
> print(y1)
logical(0)
> stopifnot(identical(y1, y0))
>   
> 
> message("*** exceptions ...")
*** exceptions ...
> 
> ## Error: dim(X) must have a positive length
> res <- tryCatch({
+   y <- future_apply(1L, MARGIN = 1L, FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: 'X' must have named dimnames
> X <- matrix(1:2, nrow = 2L, ncol = 1L)
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "rows", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: not all elements of 'MARGIN' are names of dimensions
> X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "cols", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> 
> message("*** future_apply() ... DONE")
*** future_apply() ... DONE
> 
> source("incl/end.R")
[16:01:44.363] plan(): Setting new future strategy stack:
[16:01:44.363] List of future strategies:
[16:01:44.363] 1. FutureStrategy:
[16:01:44.363]    - args: function (..., envir = parent.frame())
[16:01:44.363]    - tweaked: FALSE
[16:01:44.363]    - call: future::plan(oplan)
[16:01:44.364] plan(): nbrOfWorkers() = 1
> 
