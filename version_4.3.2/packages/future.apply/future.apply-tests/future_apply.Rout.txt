
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[10:22:43.585] plan(): Setting new future strategy stack:
[10:22:43.586] List of future strategies:
[10:22:43.586] 1. sequential:
[10:22:43.586]    - args: function (..., envir = parent.frame())
[10:22:43.586]    - tweaked: FALSE
[10:22:43.586]    - call: future::plan("sequential")
[10:22:43.601] plan(): nbrOfWorkers() = 1
> 
> message("*** future_apply() ...")
*** future_apply() ...
> 
> z0 <- NULL
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+ 
+   message("- From example(apply) ...")
+   X <- matrix(c(1:4, 1, 6:8), nrow = 2L)
+   
+   Y0 <- apply(X, MARGIN = 1L, FUN = table)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = table)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0, check.attributes = FALSE)) ## FIXME
+ 
+   Y2 <- future_apply(X, MARGIN = 1L, FUN = "table")
+   print(Y2)
+   stopifnot(identical(Y2, Y1))
+ 
+   Y0 <- apply(X, MARGIN = 1L, FUN = stats::quantile)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = stats::quantile)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0))
+ 
+   x <- cbind(x1 = 3, x2 = c(4:1, 2:5))
+   names(dimnames(x)) <- c("row", "col")
+   x3 <- array(x, dim = c(dim(x), 3),
+               dimnames = c(dimnames(x), list(C = paste0("cop.", 1:3))))
+   
+   y0 <- apply(x, MARGIN = 2L, FUN = identity)
+   stopifnot(identical(y0, x))
+   y1 <- future_apply(x, MARGIN = 2L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+   
+   y0 <- apply(x3, MARGIN = 2:3, FUN = identity)
+   stopifnot(identical(y0, x3))
+   y1 <- future_apply(x3, MARGIN = 2:3, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   z <- array(1:24, dim = 2:4)
+   y0 <- apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   y1 <- future_apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, MARGIN = <character>, ...) ...")
+   X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
+   y0 <- apply(X, MARGIN = "rows", FUN = identity)
+   y1 <- future_apply(X, MARGIN = "rows", FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - dim(X) > 2 ...")
+   X <- array(1:12, dim = c(2, 2, 3))
+   y0 <- apply(X, MARGIN = 1L, FUN = identity)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - not all same names ...")
+   FUN <- function(x) {
+     if (x[1] == 1L) names(x) <- letters[seq_along(x)]
+     x
+   }
+   X <- matrix(1:4, nrow = 2L, ncol = 2L)
+   y0 <- apply(X, MARGIN = 1L, FUN = FUN)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = FUN)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- example(future_apply) - reproducible RNG ...")
+   z1 <- future_apply(X, MARGIN = 1L, FUN = sample,
+           future.seed = 0xBEEF,
+           ## Test also all other 'future.*' arguments
+           future.stdout     = TRUE,
+           future.conditions = NULL,
+           future.globals    = TRUE,
+           future.packages   = NULL,
+           future.scheduling = 1.0,
+           future.chunk.size = NULL,
+           future.label      = "future_apply-%d"
+         )
+   print(z1)
+   if (is.null(z0)) {
+     z0 <- z1
+   } else {
+     stopifnot(identical(z1, z0))
+   }
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[10:22:43.660] plan(): Setting new future strategy stack:
[10:22:43.661] List of future strategies:
[10:22:43.661] 1. sequential:
[10:22:43.661]    - args: function (..., envir = parent.frame())
[10:22:43.661]    - tweaked: FALSE
[10:22:43.661]    - call: plan(strategy)
[10:22:43.671] plan(): nbrOfWorkers() = 1
- From example(apply) ...
[10:22:43.673] getGlobalsAndPackagesXApply() ...
[10:22:43.673]  - future.globals: TRUE
[10:22:43.673] getGlobalsAndPackages() ...
[10:22:43.674] Searching for globals...
[10:22:43.716] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[10:22:43.716] Searching for globals ... DONE
[10:22:43.716] Resolving globals: FALSE
[10:22:43.719] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[10:22:43.719] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[10:22:43.719] - globals: [1] ‘FUN’
[10:22:43.719] 
[10:22:43.720] getGlobalsAndPackages() ... DONE
[10:22:43.720]  - globals found/used: [n=1] ‘FUN’
[10:22:43.720]  - needed namespaces: [n=0] 
[10:22:43.720] Finding globals ... DONE
[10:22:43.720]  - use_args: TRUE
[10:22:43.720]  - Getting '...' globals ...
[10:22:43.721] resolve() on list ...
[10:22:43.721]  recursive: 0
[10:22:43.721]  length: 1
[10:22:43.721]  elements: ‘...’
[10:22:43.722]  length: 0 (resolved future 1)
[10:22:43.722] resolve() on list ... DONE
[10:22:43.722]    - '...' content: [n=0] 
[10:22:43.722] List of 1
[10:22:43.722]  $ ...: list()
[10:22:43.722]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:43.722]  - attr(*, "where")=List of 1
[10:22:43.722]   ..$ ...:<environment: 0x55ca4cd2a850> 
[10:22:43.722]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:43.722]  - attr(*, "resolved")= logi TRUE
[10:22:43.722]  - attr(*, "total_size")= num NA
[10:22:43.727]  - Getting '...' globals ... DONE
[10:22:43.727] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:43.727] List of 2
[10:22:43.727]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:22:43.727]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:22:43.727]  $ ...          : list()
[10:22:43.727]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:43.727]  - attr(*, "where")=List of 2
[10:22:43.727]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:43.727]   ..$ ...          :<environment: 0x55ca4cd2a850> 
[10:22:43.727]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:43.727]  - attr(*, "resolved")= logi FALSE
[10:22:43.727]  - attr(*, "total_size")= num 354224
[10:22:43.730] Packages to be attached in all futures: [n=0] 
[10:22:43.730] getGlobalsAndPackagesXApply() ... DONE
[10:22:43.731] future_lapply() ...
[10:22:43.766] Number of chunks: 1
[10:22:43.766] getGlobalsAndPackagesXApply() ...
[10:22:43.767]  - future.globals: <name-value list> with names ‘list()’
[10:22:43.767]  - use_args: TRUE
[10:22:43.767] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:22:43.767] List of 2
[10:22:43.767]  $ ...          : list()
[10:22:43.767]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:43.767]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:22:43.767]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:22:43.767]  - attr(*, "where")=List of 2
[10:22:43.767]   ..$ ...          :<environment: 0x55ca4cd2a850> 
[10:22:43.767]   ..$ ...future.FUN:<environment: namespace:base> 
[10:22:43.767]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:43.767]  - attr(*, "resolved")= logi FALSE
[10:22:43.767]  - attr(*, "total_size")= num NA
[10:22:43.771] Packages to be attached in all futures: [n=0] 
[10:22:43.771] getGlobalsAndPackagesXApply() ... DONE
[10:22:43.771] Number of futures (= number of chunks): 1
[10:22:43.771] Launching 1 futures (chunks) ...
[10:22:43.771] Chunk #1 of 1 ...
[10:22:43.772]  - seeds: <none>
[10:22:43.772]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:43.772] getGlobalsAndPackages() ...
[10:22:43.772] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:43.772] Resolving globals: FALSE
[10:22:43.772] Tweak future expression to call with '...' arguments ...
[10:22:43.773] {
[10:22:43.773]     do.call(function(...) {
[10:22:43.773]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:43.773]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:43.773]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:43.773]             on.exit(options(oopts), add = TRUE)
[10:22:43.773]         }
[10:22:43.773]         {
[10:22:43.773]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:43.773]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:43.773]                 ...future.FUN(...future.X_jj, ...)
[10:22:43.773]             })
[10:22:43.773]         }
[10:22:43.773]     }, args = future.call.arguments)
[10:22:43.773] }
[10:22:43.773] Tweak future expression to call with '...' arguments ... DONE
[10:22:43.773] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:43.773] 
[10:22:43.773] getGlobalsAndPackages() ... DONE
[10:22:43.774] run() for ‘Future’ ...
[10:22:43.774] - state: ‘created’
[10:22:43.775] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:43.775] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:43.775] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:43.775]   - Field: ‘label’
[10:22:43.775]   - Field: ‘local’
[10:22:43.775]   - Field: ‘owner’
[10:22:43.775]   - Field: ‘envir’
[10:22:43.775]   - Field: ‘packages’
[10:22:43.776]   - Field: ‘gc’
[10:22:43.776]   - Field: ‘conditions’
[10:22:43.776]   - Field: ‘expr’
[10:22:43.776]   - Field: ‘uuid’
[10:22:43.776]   - Field: ‘seed’
[10:22:43.776]   - Field: ‘version’
[10:22:43.776]   - Field: ‘result’
[10:22:43.776]   - Field: ‘asynchronous’
[10:22:43.776]   - Field: ‘calls’
[10:22:43.776]   - Field: ‘globals’
[10:22:43.776]   - Field: ‘stdout’
[10:22:43.777]   - Field: ‘earlySignal’
[10:22:43.777]   - Field: ‘lazy’
[10:22:43.777]   - Field: ‘state’
[10:22:43.777] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:43.777] - Launch lazy future ...
[10:22:43.778] Packages needed by the future expression (n = 0): <none>
[10:22:43.778] Packages needed by future strategies (n = 0): <none>
[10:22:43.779] {
[10:22:43.779]     {
[10:22:43.779]         {
[10:22:43.779]             ...future.startTime <- base::Sys.time()
[10:22:43.779]             {
[10:22:43.779]                 {
[10:22:43.779]                   {
[10:22:43.779]                     base::local({
[10:22:43.779]                       has_future <- base::requireNamespace("future", 
[10:22:43.779]                         quietly = TRUE)
[10:22:43.779]                       if (has_future) {
[10:22:43.779]                         ns <- base::getNamespace("future")
[10:22:43.779]                         version <- ns[[".package"]][["version"]]
[10:22:43.779]                         if (is.null(version)) 
[10:22:43.779]                           version <- utils::packageVersion("future")
[10:22:43.779]                       }
[10:22:43.779]                       else {
[10:22:43.779]                         version <- NULL
[10:22:43.779]                       }
[10:22:43.779]                       if (!has_future || version < "1.8.0") {
[10:22:43.779]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:43.779]                           "", base::R.version$version.string), 
[10:22:43.779]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:43.779]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:43.779]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:43.779]                             "release", "version")], collapse = " "), 
[10:22:43.779]                           hostname = base::Sys.info()[["nodename"]])
[10:22:43.779]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:43.779]                           info)
[10:22:43.779]                         info <- base::paste(info, collapse = "; ")
[10:22:43.779]                         if (!has_future) {
[10:22:43.779]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:43.779]                             info)
[10:22:43.779]                         }
[10:22:43.779]                         else {
[10:22:43.779]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:43.779]                             info, version)
[10:22:43.779]                         }
[10:22:43.779]                         base::stop(msg)
[10:22:43.779]                       }
[10:22:43.779]                     })
[10:22:43.779]                   }
[10:22:43.779]                   options(future.plan = NULL)
[10:22:43.779]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:43.779]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:43.779]                 }
[10:22:43.779]                 ...future.workdir <- getwd()
[10:22:43.779]             }
[10:22:43.779]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:43.779]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:43.779]         }
[10:22:43.779]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:43.779]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:43.779]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:43.779]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:43.779]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:43.779]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:43.779]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:43.779]             base::names(...future.oldOptions))
[10:22:43.779]     }
[10:22:43.779]     if (FALSE) {
[10:22:43.779]     }
[10:22:43.779]     else {
[10:22:43.779]         if (TRUE) {
[10:22:43.779]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:43.779]                 open = "w")
[10:22:43.779]         }
[10:22:43.779]         else {
[10:22:43.779]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:43.779]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:43.779]         }
[10:22:43.779]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:43.779]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:43.779]             base::sink(type = "output", split = FALSE)
[10:22:43.779]             base::close(...future.stdout)
[10:22:43.779]         }, add = TRUE)
[10:22:43.779]     }
[10:22:43.779]     ...future.frame <- base::sys.nframe()
[10:22:43.779]     ...future.conditions <- base::list()
[10:22:43.779]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:43.779]     if (FALSE) {
[10:22:43.779]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:43.779]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:43.779]     }
[10:22:43.779]     ...future.result <- base::tryCatch({
[10:22:43.779]         base::withCallingHandlers({
[10:22:43.779]             ...future.value <- base::withVisible(base::local({
[10:22:43.779]                 do.call(function(...) {
[10:22:43.779]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:43.779]                   if (!identical(...future.globals.maxSize.org, 
[10:22:43.779]                     ...future.globals.maxSize)) {
[10:22:43.779]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:43.779]                     on.exit(options(oopts), add = TRUE)
[10:22:43.779]                   }
[10:22:43.779]                   {
[10:22:43.779]                     lapply(seq_along(...future.elements_ii), 
[10:22:43.779]                       FUN = function(jj) {
[10:22:43.779]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:43.779]                         ...future.FUN(...future.X_jj, ...)
[10:22:43.779]                       })
[10:22:43.779]                   }
[10:22:43.779]                 }, args = future.call.arguments)
[10:22:43.779]             }))
[10:22:43.779]             future::FutureResult(value = ...future.value$value, 
[10:22:43.779]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:43.779]                   ...future.rng), globalenv = if (FALSE) 
[10:22:43.779]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:43.779]                     ...future.globalenv.names))
[10:22:43.779]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:43.779]         }, condition = base::local({
[10:22:43.779]             c <- base::c
[10:22:43.779]             inherits <- base::inherits
[10:22:43.779]             invokeRestart <- base::invokeRestart
[10:22:43.779]             length <- base::length
[10:22:43.779]             list <- base::list
[10:22:43.779]             seq.int <- base::seq.int
[10:22:43.779]             signalCondition <- base::signalCondition
[10:22:43.779]             sys.calls <- base::sys.calls
[10:22:43.779]             `[[` <- base::`[[`
[10:22:43.779]             `+` <- base::`+`
[10:22:43.779]             `<<-` <- base::`<<-`
[10:22:43.779]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:43.779]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:43.779]                   3L)]
[10:22:43.779]             }
[10:22:43.779]             function(cond) {
[10:22:43.779]                 is_error <- inherits(cond, "error")
[10:22:43.779]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:43.779]                   NULL)
[10:22:43.779]                 if (is_error) {
[10:22:43.779]                   sessionInformation <- function() {
[10:22:43.779]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:43.779]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:43.779]                       search = base::search(), system = base::Sys.info())
[10:22:43.779]                   }
[10:22:43.779]                   ...future.conditions[[length(...future.conditions) + 
[10:22:43.779]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:43.779]                     cond$call), session = sessionInformation(), 
[10:22:43.779]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:43.779]                   signalCondition(cond)
[10:22:43.779]                 }
[10:22:43.779]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:43.779]                 "immediateCondition"))) {
[10:22:43.779]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:43.779]                   ...future.conditions[[length(...future.conditions) + 
[10:22:43.779]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:43.779]                   if (TRUE && !signal) {
[10:22:43.779]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:43.779]                     {
[10:22:43.779]                       inherits <- base::inherits
[10:22:43.779]                       invokeRestart <- base::invokeRestart
[10:22:43.779]                       is.null <- base::is.null
[10:22:43.779]                       muffled <- FALSE
[10:22:43.779]                       if (inherits(cond, "message")) {
[10:22:43.779]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:43.779]                         if (muffled) 
[10:22:43.779]                           invokeRestart("muffleMessage")
[10:22:43.779]                       }
[10:22:43.779]                       else if (inherits(cond, "warning")) {
[10:22:43.779]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:43.779]                         if (muffled) 
[10:22:43.779]                           invokeRestart("muffleWarning")
[10:22:43.779]                       }
[10:22:43.779]                       else if (inherits(cond, "condition")) {
[10:22:43.779]                         if (!is.null(pattern)) {
[10:22:43.779]                           computeRestarts <- base::computeRestarts
[10:22:43.779]                           grepl <- base::grepl
[10:22:43.779]                           restarts <- computeRestarts(cond)
[10:22:43.779]                           for (restart in restarts) {
[10:22:43.779]                             name <- restart$name
[10:22:43.779]                             if (is.null(name)) 
[10:22:43.779]                               next
[10:22:43.779]                             if (!grepl(pattern, name)) 
[10:22:43.779]                               next
[10:22:43.779]                             invokeRestart(restart)
[10:22:43.779]                             muffled <- TRUE
[10:22:43.779]                             break
[10:22:43.779]                           }
[10:22:43.779]                         }
[10:22:43.779]                       }
[10:22:43.779]                       invisible(muffled)
[10:22:43.779]                     }
[10:22:43.779]                     muffleCondition(cond, pattern = "^muffle")
[10:22:43.779]                   }
[10:22:43.779]                 }
[10:22:43.779]                 else {
[10:22:43.779]                   if (TRUE) {
[10:22:43.779]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:43.779]                     {
[10:22:43.779]                       inherits <- base::inherits
[10:22:43.779]                       invokeRestart <- base::invokeRestart
[10:22:43.779]                       is.null <- base::is.null
[10:22:43.779]                       muffled <- FALSE
[10:22:43.779]                       if (inherits(cond, "message")) {
[10:22:43.779]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:43.779]                         if (muffled) 
[10:22:43.779]                           invokeRestart("muffleMessage")
[10:22:43.779]                       }
[10:22:43.779]                       else if (inherits(cond, "warning")) {
[10:22:43.779]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:43.779]                         if (muffled) 
[10:22:43.779]                           invokeRestart("muffleWarning")
[10:22:43.779]                       }
[10:22:43.779]                       else if (inherits(cond, "condition")) {
[10:22:43.779]                         if (!is.null(pattern)) {
[10:22:43.779]                           computeRestarts <- base::computeRestarts
[10:22:43.779]                           grepl <- base::grepl
[10:22:43.779]                           restarts <- computeRestarts(cond)
[10:22:43.779]                           for (restart in restarts) {
[10:22:43.779]                             name <- restart$name
[10:22:43.779]                             if (is.null(name)) 
[10:22:43.779]                               next
[10:22:43.779]                             if (!grepl(pattern, name)) 
[10:22:43.779]                               next
[10:22:43.779]                             invokeRestart(restart)
[10:22:43.779]                             muffled <- TRUE
[10:22:43.779]                             break
[10:22:43.779]                           }
[10:22:43.779]                         }
[10:22:43.779]                       }
[10:22:43.779]                       invisible(muffled)
[10:22:43.779]                     }
[10:22:43.779]                     muffleCondition(cond, pattern = "^muffle")
[10:22:43.779]                   }
[10:22:43.779]                 }
[10:22:43.779]             }
[10:22:43.779]         }))
[10:22:43.779]     }, error = function(ex) {
[10:22:43.779]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:43.779]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:43.779]                 ...future.rng), started = ...future.startTime, 
[10:22:43.779]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:43.779]             version = "1.8"), class = "FutureResult")
[10:22:43.779]     }, finally = {
[10:22:43.779]         if (!identical(...future.workdir, getwd())) 
[10:22:43.779]             setwd(...future.workdir)
[10:22:43.779]         {
[10:22:43.779]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:43.779]                 ...future.oldOptions$nwarnings <- NULL
[10:22:43.779]             }
[10:22:43.779]             base::options(...future.oldOptions)
[10:22:43.779]             if (.Platform$OS.type == "windows") {
[10:22:43.779]                 old_names <- names(...future.oldEnvVars)
[10:22:43.779]                 envs <- base::Sys.getenv()
[10:22:43.779]                 names <- names(envs)
[10:22:43.779]                 common <- intersect(names, old_names)
[10:22:43.779]                 added <- setdiff(names, old_names)
[10:22:43.779]                 removed <- setdiff(old_names, names)
[10:22:43.779]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:43.779]                   envs[common]]
[10:22:43.779]                 NAMES <- toupper(changed)
[10:22:43.779]                 args <- list()
[10:22:43.779]                 for (kk in seq_along(NAMES)) {
[10:22:43.779]                   name <- changed[[kk]]
[10:22:43.779]                   NAME <- NAMES[[kk]]
[10:22:43.779]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:43.779]                     next
[10:22:43.779]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:43.779]                 }
[10:22:43.779]                 NAMES <- toupper(added)
[10:22:43.779]                 for (kk in seq_along(NAMES)) {
[10:22:43.779]                   name <- added[[kk]]
[10:22:43.779]                   NAME <- NAMES[[kk]]
[10:22:43.779]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:43.779]                     next
[10:22:43.779]                   args[[name]] <- ""
[10:22:43.779]                 }
[10:22:43.779]                 NAMES <- toupper(removed)
[10:22:43.779]                 for (kk in seq_along(NAMES)) {
[10:22:43.779]                   name <- removed[[kk]]
[10:22:43.779]                   NAME <- NAMES[[kk]]
[10:22:43.779]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:43.779]                     next
[10:22:43.779]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:43.779]                 }
[10:22:43.779]                 if (length(args) > 0) 
[10:22:43.779]                   base::do.call(base::Sys.setenv, args = args)
[10:22:43.779]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:43.779]             }
[10:22:43.779]             else {
[10:22:43.779]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:43.779]             }
[10:22:43.779]             {
[10:22:43.779]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:43.779]                   0L) {
[10:22:43.779]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:43.779]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:43.779]                   base::options(opts)
[10:22:43.779]                 }
[10:22:43.779]                 {
[10:22:43.779]                   {
[10:22:43.779]                     NULL
[10:22:43.779]                     RNGkind("Mersenne-Twister")
[10:22:43.779]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:43.779]                       inherits = FALSE)
[10:22:43.779]                   }
[10:22:43.779]                   options(future.plan = NULL)
[10:22:43.779]                   if (is.na(NA_character_)) 
[10:22:43.779]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:43.779]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:43.779]                   future::plan(list(function (..., envir = parent.frame()) 
[10:22:43.779]                   {
[10:22:43.779]                     future <- SequentialFuture(..., envir = envir)
[10:22:43.779]                     if (!future$lazy) 
[10:22:43.779]                       future <- run(future)
[10:22:43.779]                     invisible(future)
[10:22:43.779]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:43.779]                 }
[10:22:43.779]             }
[10:22:43.779]         }
[10:22:43.779]     })
[10:22:43.779]     if (TRUE) {
[10:22:43.779]         base::sink(type = "output", split = FALSE)
[10:22:43.779]         if (TRUE) {
[10:22:43.779]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:43.779]         }
[10:22:43.779]         else {
[10:22:43.779]             ...future.result["stdout"] <- base::list(NULL)
[10:22:43.779]         }
[10:22:43.779]         base::close(...future.stdout)
[10:22:43.779]         ...future.stdout <- NULL
[10:22:43.779]     }
[10:22:43.779]     ...future.result$conditions <- ...future.conditions
[10:22:43.779]     ...future.result$finished <- base::Sys.time()
[10:22:43.779]     ...future.result
[10:22:43.779] }
[10:22:43.781] assign_globals() ...
[10:22:43.781] List of 5
[10:22:43.781]  $ future.call.arguments    : list()
[10:22:43.781]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:43.781]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:22:43.781]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:22:43.781]  $ ...future.elements_ii    :List of 2
[10:22:43.781]   ..$ : num [1:4] 1 3 1 7
[10:22:43.781]   ..$ : num [1:4] 2 4 6 8
[10:22:43.781]  $ ...future.seeds_ii       : NULL
[10:22:43.781]  $ ...future.globals.maxSize: num Inf
[10:22:43.781]  - attr(*, "resolved")= logi FALSE
[10:22:43.781]  - attr(*, "total_size")= num NA
[10:22:43.781]  - attr(*, "where")=List of 5
[10:22:43.781]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:43.781]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:43.781]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:43.781]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:43.781]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:43.781]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:43.781]  - attr(*, "already-done")= logi TRUE
[10:22:43.786] - copied ‘future.call.arguments’ to environment
[10:22:43.786] - copied ‘...future.FUN’ to environment
[10:22:43.786] - copied ‘...future.elements_ii’ to environment
[10:22:43.786] - copied ‘...future.seeds_ii’ to environment
[10:22:43.786] - copied ‘...future.globals.maxSize’ to environment
[10:22:43.786] assign_globals() ... done
[10:22:43.786] plan(): Setting new future strategy stack:
[10:22:43.787] List of future strategies:
[10:22:43.787] 1. sequential:
[10:22:43.787]    - args: function (..., envir = parent.frame())
[10:22:43.787]    - tweaked: FALSE
[10:22:43.787]    - call: NULL
[10:22:43.787] plan(): nbrOfWorkers() = 1
[10:22:43.788] plan(): Setting new future strategy stack:
[10:22:43.788] List of future strategies:
[10:22:43.788] 1. sequential:
[10:22:43.788]    - args: function (..., envir = parent.frame())
[10:22:43.788]    - tweaked: FALSE
[10:22:43.788]    - call: plan(strategy)
[10:22:43.789] plan(): nbrOfWorkers() = 1
[10:22:43.789] SequentialFuture started (and completed)
[10:22:43.789] - Launch lazy future ... done
[10:22:43.790] run() for ‘SequentialFuture’ ... done
[10:22:43.790] Created future:
[10:22:43.790] SequentialFuture:
[10:22:43.790] Label: ‘future_apply-1’
[10:22:43.790] Expression:
[10:22:43.790] {
[10:22:43.790]     do.call(function(...) {
[10:22:43.790]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:43.790]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:43.790]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:43.790]             on.exit(options(oopts), add = TRUE)
[10:22:43.790]         }
[10:22:43.790]         {
[10:22:43.790]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:43.790]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:43.790]                 ...future.FUN(...future.X_jj, ...)
[10:22:43.790]             })
[10:22:43.790]         }
[10:22:43.790]     }, args = future.call.arguments)
[10:22:43.790] }
[10:22:43.790] Lazy evaluation: FALSE
[10:22:43.790] Asynchronous evaluation: FALSE
[10:22:43.790] Local evaluation: TRUE
[10:22:43.790] Environment: R_GlobalEnv
[10:22:43.790] Capture standard output: TRUE
[10:22:43.790] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:43.790] Globals: 5 objects totaling 346.13 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:43.790] Packages: <none>
[10:22:43.790] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:43.790] Resolved: TRUE
[10:22:43.790] Value: 2.21 KiB of class ‘list’
[10:22:43.790] Early signaling: FALSE
[10:22:43.790] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:43.790] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:43.793] Chunk #1 of 1 ... DONE
[10:22:43.793] Launching 1 futures (chunks) ... DONE
[10:22:43.793] Resolving 1 futures (chunks) ...
[10:22:43.793] resolve() on list ...
[10:22:43.794]  recursive: 0
[10:22:43.794]  length: 1
[10:22:43.794] 
[10:22:43.794] resolved() for ‘SequentialFuture’ ...
[10:22:43.794] - state: ‘finished’
[10:22:43.794] - run: TRUE
[10:22:43.794] - result: ‘FutureResult’
[10:22:43.794] resolved() for ‘SequentialFuture’ ... done
[10:22:43.794] Future #1
[10:22:43.795] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:43.795] - nx: 1
[10:22:43.795] - relay: TRUE
[10:22:43.795] - stdout: TRUE
[10:22:43.795] - signal: TRUE
[10:22:43.795] - resignal: FALSE
[10:22:43.795] - force: TRUE
[10:22:43.795] - relayed: [n=1] FALSE
[10:22:43.796] - queued futures: [n=1] FALSE
[10:22:43.796]  - until=1
[10:22:43.796]  - relaying element #1
[10:22:43.796] - relayed: [n=1] TRUE
[10:22:43.796] - queued futures: [n=1] TRUE
[10:22:43.796] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:43.796]  length: 0 (resolved future 1)
[10:22:43.796] Relaying remaining futures
[10:22:43.796] signalConditionsASAP(NULL, pos=0) ...
[10:22:43.797] - nx: 1
[10:22:43.797] - relay: TRUE
[10:22:43.797] - stdout: TRUE
[10:22:43.797] - signal: TRUE
[10:22:43.797] - resignal: FALSE
[10:22:43.797] - force: TRUE
[10:22:43.797] - relayed: [n=1] TRUE
[10:22:43.797] - queued futures: [n=1] TRUE
 - flush all
[10:22:43.797] - relayed: [n=1] TRUE
[10:22:43.797] - queued futures: [n=1] TRUE
[10:22:43.798] signalConditionsASAP(NULL, pos=0) ... done
[10:22:43.798] resolve() on list ... DONE
[10:22:43.798]  - Number of value chunks collected: 1
[10:22:43.798] Resolving 1 futures (chunks) ... DONE
[10:22:43.798] Reducing values from 1 chunks ...
[10:22:43.798]  - Number of values collected after concatenation: 2
[10:22:43.798]  - Number of values expected: 2
[10:22:43.798] Reducing values from 1 chunks ... DONE
[10:22:43.798] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[10:22:43.799] getGlobalsAndPackagesXApply() ...
[10:22:43.799]  - future.globals: TRUE
[10:22:43.800] getGlobalsAndPackages() ...
[10:22:43.800] Searching for globals...
[10:22:43.832] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[10:22:43.832] Searching for globals ... DONE
[10:22:43.832] Resolving globals: FALSE
[10:22:43.834] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[10:22:43.834] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[10:22:43.835] - globals: [1] ‘FUN’
[10:22:43.835] 
[10:22:43.835] getGlobalsAndPackages() ... DONE
[10:22:43.835]  - globals found/used: [n=1] ‘FUN’
[10:22:43.835]  - needed namespaces: [n=0] 
[10:22:43.835] Finding globals ... DONE
[10:22:43.835]  - use_args: TRUE
[10:22:43.835]  - Getting '...' globals ...
[10:22:43.836] resolve() on list ...
[10:22:43.836]  recursive: 0
[10:22:43.836]  length: 1
[10:22:43.836]  elements: ‘...’
[10:22:43.836]  length: 0 (resolved future 1)
[10:22:43.836] resolve() on list ... DONE
[10:22:43.836]    - '...' content: [n=0] 
[10:22:43.836] List of 1
[10:22:43.836]  $ ...: list()
[10:22:43.836]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:43.836]  - attr(*, "where")=List of 1
[10:22:43.836]   ..$ ...:<environment: 0x55ca4ab7d170> 
[10:22:43.836]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:43.836]  - attr(*, "resolved")= logi TRUE
[10:22:43.836]  - attr(*, "total_size")= num NA
[10:22:43.839]  - Getting '...' globals ... DONE
[10:22:43.839] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:43.839] List of 2
[10:22:43.839]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:22:43.839]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:22:43.839]  $ ...          : list()
[10:22:43.839]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:43.839]  - attr(*, "where")=List of 2
[10:22:43.839]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:43.839]   ..$ ...          :<environment: 0x55ca4ab7d170> 
[10:22:43.839]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:43.839]  - attr(*, "resolved")= logi FALSE
[10:22:43.839]  - attr(*, "total_size")= num 354224
[10:22:43.842] Packages to be attached in all futures: [n=0] 
[10:22:43.842] getGlobalsAndPackagesXApply() ... DONE
[10:22:43.842] future_lapply() ...
[10:22:43.874] Number of chunks: 1
[10:22:43.874] getGlobalsAndPackagesXApply() ...
[10:22:43.874]  - future.globals: <name-value list> with names ‘list()’
[10:22:43.874]  - use_args: TRUE
[10:22:43.874] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:22:43.874] List of 2
[10:22:43.874]  $ ...          : list()
[10:22:43.874]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:43.874]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:22:43.874]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:22:43.874]  - attr(*, "where")=List of 2
[10:22:43.874]   ..$ ...          :<environment: 0x55ca4ab7d170> 
[10:22:43.874]   ..$ ...future.FUN:<environment: namespace:base> 
[10:22:43.874]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:43.874]  - attr(*, "resolved")= logi FALSE
[10:22:43.874]  - attr(*, "total_size")= num NA
[10:22:43.878] Packages to be attached in all futures: [n=0] 
[10:22:43.878] getGlobalsAndPackagesXApply() ... DONE
[10:22:43.878] Number of futures (= number of chunks): 1
[10:22:43.878] Launching 1 futures (chunks) ...
[10:22:43.878] Chunk #1 of 1 ...
[10:22:43.878]  - seeds: <none>
[10:22:43.878]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:43.878] getGlobalsAndPackages() ...
[10:22:43.879] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:43.879] Resolving globals: FALSE
[10:22:43.879] Tweak future expression to call with '...' arguments ...
[10:22:43.879] {
[10:22:43.879]     do.call(function(...) {
[10:22:43.879]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:43.879]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:43.879]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:43.879]             on.exit(options(oopts), add = TRUE)
[10:22:43.879]         }
[10:22:43.879]         {
[10:22:43.879]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:43.879]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:43.879]                 ...future.FUN(...future.X_jj, ...)
[10:22:43.879]             })
[10:22:43.879]         }
[10:22:43.879]     }, args = future.call.arguments)
[10:22:43.879] }
[10:22:43.879] Tweak future expression to call with '...' arguments ... DONE
[10:22:43.879] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:43.880] 
[10:22:43.880] getGlobalsAndPackages() ... DONE
[10:22:43.880] run() for ‘Future’ ...
[10:22:43.880] - state: ‘created’
[10:22:43.880] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:43.880] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:43.881] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:43.881]   - Field: ‘label’
[10:22:43.881]   - Field: ‘local’
[10:22:43.881]   - Field: ‘owner’
[10:22:43.881]   - Field: ‘envir’
[10:22:43.881]   - Field: ‘packages’
[10:22:43.881]   - Field: ‘gc’
[10:22:43.881]   - Field: ‘conditions’
[10:22:43.881]   - Field: ‘expr’
[10:22:43.881]   - Field: ‘uuid’
[10:22:43.882]   - Field: ‘seed’
[10:22:43.882]   - Field: ‘version’
[10:22:43.882]   - Field: ‘result’
[10:22:43.882]   - Field: ‘asynchronous’
[10:22:43.882]   - Field: ‘calls’
[10:22:43.882]   - Field: ‘globals’
[10:22:43.882]   - Field: ‘stdout’
[10:22:43.882]   - Field: ‘earlySignal’
[10:22:43.882]   - Field: ‘lazy’
[10:22:43.882]   - Field: ‘state’
[10:22:43.882] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:43.883] - Launch lazy future ...
[10:22:43.883] Packages needed by the future expression (n = 0): <none>
[10:22:43.883] Packages needed by future strategies (n = 0): <none>
[10:22:43.883] {
[10:22:43.883]     {
[10:22:43.883]         {
[10:22:43.883]             ...future.startTime <- base::Sys.time()
[10:22:43.883]             {
[10:22:43.883]                 {
[10:22:43.883]                   {
[10:22:43.883]                     base::local({
[10:22:43.883]                       has_future <- base::requireNamespace("future", 
[10:22:43.883]                         quietly = TRUE)
[10:22:43.883]                       if (has_future) {
[10:22:43.883]                         ns <- base::getNamespace("future")
[10:22:43.883]                         version <- ns[[".package"]][["version"]]
[10:22:43.883]                         if (is.null(version)) 
[10:22:43.883]                           version <- utils::packageVersion("future")
[10:22:43.883]                       }
[10:22:43.883]                       else {
[10:22:43.883]                         version <- NULL
[10:22:43.883]                       }
[10:22:43.883]                       if (!has_future || version < "1.8.0") {
[10:22:43.883]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:43.883]                           "", base::R.version$version.string), 
[10:22:43.883]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:43.883]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:43.883]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:43.883]                             "release", "version")], collapse = " "), 
[10:22:43.883]                           hostname = base::Sys.info()[["nodename"]])
[10:22:43.883]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:43.883]                           info)
[10:22:43.883]                         info <- base::paste(info, collapse = "; ")
[10:22:43.883]                         if (!has_future) {
[10:22:43.883]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:43.883]                             info)
[10:22:43.883]                         }
[10:22:43.883]                         else {
[10:22:43.883]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:43.883]                             info, version)
[10:22:43.883]                         }
[10:22:43.883]                         base::stop(msg)
[10:22:43.883]                       }
[10:22:43.883]                     })
[10:22:43.883]                   }
[10:22:43.883]                   options(future.plan = NULL)
[10:22:43.883]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:43.883]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:43.883]                 }
[10:22:43.883]                 ...future.workdir <- getwd()
[10:22:43.883]             }
[10:22:43.883]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:43.883]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:43.883]         }
[10:22:43.883]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:43.883]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:43.883]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:43.883]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:43.883]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:43.883]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:43.883]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:43.883]             base::names(...future.oldOptions))
[10:22:43.883]     }
[10:22:43.883]     if (FALSE) {
[10:22:43.883]     }
[10:22:43.883]     else {
[10:22:43.883]         if (TRUE) {
[10:22:43.883]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:43.883]                 open = "w")
[10:22:43.883]         }
[10:22:43.883]         else {
[10:22:43.883]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:43.883]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:43.883]         }
[10:22:43.883]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:43.883]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:43.883]             base::sink(type = "output", split = FALSE)
[10:22:43.883]             base::close(...future.stdout)
[10:22:43.883]         }, add = TRUE)
[10:22:43.883]     }
[10:22:43.883]     ...future.frame <- base::sys.nframe()
[10:22:43.883]     ...future.conditions <- base::list()
[10:22:43.883]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:43.883]     if (FALSE) {
[10:22:43.883]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:43.883]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:43.883]     }
[10:22:43.883]     ...future.result <- base::tryCatch({
[10:22:43.883]         base::withCallingHandlers({
[10:22:43.883]             ...future.value <- base::withVisible(base::local({
[10:22:43.883]                 do.call(function(...) {
[10:22:43.883]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:43.883]                   if (!identical(...future.globals.maxSize.org, 
[10:22:43.883]                     ...future.globals.maxSize)) {
[10:22:43.883]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:43.883]                     on.exit(options(oopts), add = TRUE)
[10:22:43.883]                   }
[10:22:43.883]                   {
[10:22:43.883]                     lapply(seq_along(...future.elements_ii), 
[10:22:43.883]                       FUN = function(jj) {
[10:22:43.883]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:43.883]                         ...future.FUN(...future.X_jj, ...)
[10:22:43.883]                       })
[10:22:43.883]                   }
[10:22:43.883]                 }, args = future.call.arguments)
[10:22:43.883]             }))
[10:22:43.883]             future::FutureResult(value = ...future.value$value, 
[10:22:43.883]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:43.883]                   ...future.rng), globalenv = if (FALSE) 
[10:22:43.883]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:43.883]                     ...future.globalenv.names))
[10:22:43.883]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:43.883]         }, condition = base::local({
[10:22:43.883]             c <- base::c
[10:22:43.883]             inherits <- base::inherits
[10:22:43.883]             invokeRestart <- base::invokeRestart
[10:22:43.883]             length <- base::length
[10:22:43.883]             list <- base::list
[10:22:43.883]             seq.int <- base::seq.int
[10:22:43.883]             signalCondition <- base::signalCondition
[10:22:43.883]             sys.calls <- base::sys.calls
[10:22:43.883]             `[[` <- base::`[[`
[10:22:43.883]             `+` <- base::`+`
[10:22:43.883]             `<<-` <- base::`<<-`
[10:22:43.883]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:43.883]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:43.883]                   3L)]
[10:22:43.883]             }
[10:22:43.883]             function(cond) {
[10:22:43.883]                 is_error <- inherits(cond, "error")
[10:22:43.883]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:43.883]                   NULL)
[10:22:43.883]                 if (is_error) {
[10:22:43.883]                   sessionInformation <- function() {
[10:22:43.883]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:43.883]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:43.883]                       search = base::search(), system = base::Sys.info())
[10:22:43.883]                   }
[10:22:43.883]                   ...future.conditions[[length(...future.conditions) + 
[10:22:43.883]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:43.883]                     cond$call), session = sessionInformation(), 
[10:22:43.883]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:43.883]                   signalCondition(cond)
[10:22:43.883]                 }
[10:22:43.883]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:43.883]                 "immediateCondition"))) {
[10:22:43.883]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:43.883]                   ...future.conditions[[length(...future.conditions) + 
[10:22:43.883]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:43.883]                   if (TRUE && !signal) {
[10:22:43.883]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:43.883]                     {
[10:22:43.883]                       inherits <- base::inherits
[10:22:43.883]                       invokeRestart <- base::invokeRestart
[10:22:43.883]                       is.null <- base::is.null
[10:22:43.883]                       muffled <- FALSE
[10:22:43.883]                       if (inherits(cond, "message")) {
[10:22:43.883]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:43.883]                         if (muffled) 
[10:22:43.883]                           invokeRestart("muffleMessage")
[10:22:43.883]                       }
[10:22:43.883]                       else if (inherits(cond, "warning")) {
[10:22:43.883]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:43.883]                         if (muffled) 
[10:22:43.883]                           invokeRestart("muffleWarning")
[10:22:43.883]                       }
[10:22:43.883]                       else if (inherits(cond, "condition")) {
[10:22:43.883]                         if (!is.null(pattern)) {
[10:22:43.883]                           computeRestarts <- base::computeRestarts
[10:22:43.883]                           grepl <- base::grepl
[10:22:43.883]                           restarts <- computeRestarts(cond)
[10:22:43.883]                           for (restart in restarts) {
[10:22:43.883]                             name <- restart$name
[10:22:43.883]                             if (is.null(name)) 
[10:22:43.883]                               next
[10:22:43.883]                             if (!grepl(pattern, name)) 
[10:22:43.883]                               next
[10:22:43.883]                             invokeRestart(restart)
[10:22:43.883]                             muffled <- TRUE
[10:22:43.883]                             break
[10:22:43.883]                           }
[10:22:43.883]                         }
[10:22:43.883]                       }
[10:22:43.883]                       invisible(muffled)
[10:22:43.883]                     }
[10:22:43.883]                     muffleCondition(cond, pattern = "^muffle")
[10:22:43.883]                   }
[10:22:43.883]                 }
[10:22:43.883]                 else {
[10:22:43.883]                   if (TRUE) {
[10:22:43.883]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:43.883]                     {
[10:22:43.883]                       inherits <- base::inherits
[10:22:43.883]                       invokeRestart <- base::invokeRestart
[10:22:43.883]                       is.null <- base::is.null
[10:22:43.883]                       muffled <- FALSE
[10:22:43.883]                       if (inherits(cond, "message")) {
[10:22:43.883]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:43.883]                         if (muffled) 
[10:22:43.883]                           invokeRestart("muffleMessage")
[10:22:43.883]                       }
[10:22:43.883]                       else if (inherits(cond, "warning")) {
[10:22:43.883]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:43.883]                         if (muffled) 
[10:22:43.883]                           invokeRestart("muffleWarning")
[10:22:43.883]                       }
[10:22:43.883]                       else if (inherits(cond, "condition")) {
[10:22:43.883]                         if (!is.null(pattern)) {
[10:22:43.883]                           computeRestarts <- base::computeRestarts
[10:22:43.883]                           grepl <- base::grepl
[10:22:43.883]                           restarts <- computeRestarts(cond)
[10:22:43.883]                           for (restart in restarts) {
[10:22:43.883]                             name <- restart$name
[10:22:43.883]                             if (is.null(name)) 
[10:22:43.883]                               next
[10:22:43.883]                             if (!grepl(pattern, name)) 
[10:22:43.883]                               next
[10:22:43.883]                             invokeRestart(restart)
[10:22:43.883]                             muffled <- TRUE
[10:22:43.883]                             break
[10:22:43.883]                           }
[10:22:43.883]                         }
[10:22:43.883]                       }
[10:22:43.883]                       invisible(muffled)
[10:22:43.883]                     }
[10:22:43.883]                     muffleCondition(cond, pattern = "^muffle")
[10:22:43.883]                   }
[10:22:43.883]                 }
[10:22:43.883]             }
[10:22:43.883]         }))
[10:22:43.883]     }, error = function(ex) {
[10:22:43.883]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:43.883]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:43.883]                 ...future.rng), started = ...future.startTime, 
[10:22:43.883]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:43.883]             version = "1.8"), class = "FutureResult")
[10:22:43.883]     }, finally = {
[10:22:43.883]         if (!identical(...future.workdir, getwd())) 
[10:22:43.883]             setwd(...future.workdir)
[10:22:43.883]         {
[10:22:43.883]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:43.883]                 ...future.oldOptions$nwarnings <- NULL
[10:22:43.883]             }
[10:22:43.883]             base::options(...future.oldOptions)
[10:22:43.883]             if (.Platform$OS.type == "windows") {
[10:22:43.883]                 old_names <- names(...future.oldEnvVars)
[10:22:43.883]                 envs <- base::Sys.getenv()
[10:22:43.883]                 names <- names(envs)
[10:22:43.883]                 common <- intersect(names, old_names)
[10:22:43.883]                 added <- setdiff(names, old_names)
[10:22:43.883]                 removed <- setdiff(old_names, names)
[10:22:43.883]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:43.883]                   envs[common]]
[10:22:43.883]                 NAMES <- toupper(changed)
[10:22:43.883]                 args <- list()
[10:22:43.883]                 for (kk in seq_along(NAMES)) {
[10:22:43.883]                   name <- changed[[kk]]
[10:22:43.883]                   NAME <- NAMES[[kk]]
[10:22:43.883]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:43.883]                     next
[10:22:43.883]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:43.883]                 }
[10:22:43.883]                 NAMES <- toupper(added)
[10:22:43.883]                 for (kk in seq_along(NAMES)) {
[10:22:43.883]                   name <- added[[kk]]
[10:22:43.883]                   NAME <- NAMES[[kk]]
[10:22:43.883]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:43.883]                     next
[10:22:43.883]                   args[[name]] <- ""
[10:22:43.883]                 }
[10:22:43.883]                 NAMES <- toupper(removed)
[10:22:43.883]                 for (kk in seq_along(NAMES)) {
[10:22:43.883]                   name <- removed[[kk]]
[10:22:43.883]                   NAME <- NAMES[[kk]]
[10:22:43.883]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:43.883]                     next
[10:22:43.883]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:43.883]                 }
[10:22:43.883]                 if (length(args) > 0) 
[10:22:43.883]                   base::do.call(base::Sys.setenv, args = args)
[10:22:43.883]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:43.883]             }
[10:22:43.883]             else {
[10:22:43.883]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:43.883]             }
[10:22:43.883]             {
[10:22:43.883]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:43.883]                   0L) {
[10:22:43.883]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:43.883]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:43.883]                   base::options(opts)
[10:22:43.883]                 }
[10:22:43.883]                 {
[10:22:43.883]                   {
[10:22:43.883]                     NULL
[10:22:43.883]                     RNGkind("Mersenne-Twister")
[10:22:43.883]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:43.883]                       inherits = FALSE)
[10:22:43.883]                   }
[10:22:43.883]                   options(future.plan = NULL)
[10:22:43.883]                   if (is.na(NA_character_)) 
[10:22:43.883]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:43.883]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:43.883]                   future::plan(list(function (..., envir = parent.frame()) 
[10:22:43.883]                   {
[10:22:43.883]                     future <- SequentialFuture(..., envir = envir)
[10:22:43.883]                     if (!future$lazy) 
[10:22:43.883]                       future <- run(future)
[10:22:43.883]                     invisible(future)
[10:22:43.883]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:43.883]                 }
[10:22:43.883]             }
[10:22:43.883]         }
[10:22:43.883]     })
[10:22:43.883]     if (TRUE) {
[10:22:43.883]         base::sink(type = "output", split = FALSE)
[10:22:43.883]         if (TRUE) {
[10:22:43.883]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:43.883]         }
[10:22:43.883]         else {
[10:22:43.883]             ...future.result["stdout"] <- base::list(NULL)
[10:22:43.883]         }
[10:22:43.883]         base::close(...future.stdout)
[10:22:43.883]         ...future.stdout <- NULL
[10:22:43.883]     }
[10:22:43.883]     ...future.result$conditions <- ...future.conditions
[10:22:43.883]     ...future.result$finished <- base::Sys.time()
[10:22:43.883]     ...future.result
[10:22:43.883] }
[10:22:43.885] assign_globals() ...
[10:22:43.885] List of 5
[10:22:43.885]  $ future.call.arguments    : list()
[10:22:43.885]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:43.885]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:22:43.885]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:22:43.885]  $ ...future.elements_ii    :List of 2
[10:22:43.885]   ..$ : num [1:4] 1 3 1 7
[10:22:43.885]   ..$ : num [1:4] 2 4 6 8
[10:22:43.885]  $ ...future.seeds_ii       : NULL
[10:22:43.885]  $ ...future.globals.maxSize: num Inf
[10:22:43.885]  - attr(*, "resolved")= logi FALSE
[10:22:43.885]  - attr(*, "total_size")= num NA
[10:22:43.885]  - attr(*, "where")=List of 5
[10:22:43.885]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:43.885]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:43.885]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:43.885]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:43.885]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:43.885]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:43.885]  - attr(*, "already-done")= logi TRUE
[10:22:43.891] - copied ‘future.call.arguments’ to environment
[10:22:43.891] - copied ‘...future.FUN’ to environment
[10:22:43.891] - copied ‘...future.elements_ii’ to environment
[10:22:43.891] - copied ‘...future.seeds_ii’ to environment
[10:22:43.891] - copied ‘...future.globals.maxSize’ to environment
[10:22:43.892] assign_globals() ... done
[10:22:43.892] plan(): Setting new future strategy stack:
[10:22:43.892] List of future strategies:
[10:22:43.892] 1. sequential:
[10:22:43.892]    - args: function (..., envir = parent.frame())
[10:22:43.892]    - tweaked: FALSE
[10:22:43.892]    - call: NULL
[10:22:43.892] plan(): nbrOfWorkers() = 1
[10:22:43.893] plan(): Setting new future strategy stack:
[10:22:43.893] List of future strategies:
[10:22:43.893] 1. sequential:
[10:22:43.893]    - args: function (..., envir = parent.frame())
[10:22:43.893]    - tweaked: FALSE
[10:22:43.893]    - call: plan(strategy)
[10:22:43.894] plan(): nbrOfWorkers() = 1
[10:22:43.894] SequentialFuture started (and completed)
[10:22:43.894] - Launch lazy future ... done
[10:22:43.894] run() for ‘SequentialFuture’ ... done
[10:22:43.894] Created future:
[10:22:43.894] SequentialFuture:
[10:22:43.894] Label: ‘future_apply-1’
[10:22:43.894] Expression:
[10:22:43.894] {
[10:22:43.894]     do.call(function(...) {
[10:22:43.894]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:43.894]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:43.894]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:43.894]             on.exit(options(oopts), add = TRUE)
[10:22:43.894]         }
[10:22:43.894]         {
[10:22:43.894]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:43.894]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:43.894]                 ...future.FUN(...future.X_jj, ...)
[10:22:43.894]             })
[10:22:43.894]         }
[10:22:43.894]     }, args = future.call.arguments)
[10:22:43.894] }
[10:22:43.894] Lazy evaluation: FALSE
[10:22:43.894] Asynchronous evaluation: FALSE
[10:22:43.894] Local evaluation: TRUE
[10:22:43.894] Environment: R_GlobalEnv
[10:22:43.894] Capture standard output: TRUE
[10:22:43.894] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:43.894] Globals: 5 objects totaling 346.13 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:43.894] Packages: <none>
[10:22:43.894] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:43.894] Resolved: TRUE
[10:22:43.894] Value: 2.21 KiB of class ‘list’
[10:22:43.894] Early signaling: FALSE
[10:22:43.894] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:43.894] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:43.895] Chunk #1 of 1 ... DONE
[10:22:43.895] Launching 1 futures (chunks) ... DONE
[10:22:43.895] Resolving 1 futures (chunks) ...
[10:22:43.896] resolve() on list ...
[10:22:43.896]  recursive: 0
[10:22:43.896]  length: 1
[10:22:43.896] 
[10:22:43.896] resolved() for ‘SequentialFuture’ ...
[10:22:43.896] - state: ‘finished’
[10:22:43.896] - run: TRUE
[10:22:43.896] - result: ‘FutureResult’
[10:22:43.896] resolved() for ‘SequentialFuture’ ... done
[10:22:43.896] Future #1
[10:22:43.897] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:43.897] - nx: 1
[10:22:43.897] - relay: TRUE
[10:22:43.897] - stdout: TRUE
[10:22:43.897] - signal: TRUE
[10:22:43.897] - resignal: FALSE
[10:22:43.897] - force: TRUE
[10:22:43.897] - relayed: [n=1] FALSE
[10:22:43.897] - queued futures: [n=1] FALSE
[10:22:43.897]  - until=1
[10:22:43.897]  - relaying element #1
[10:22:43.898] - relayed: [n=1] TRUE
[10:22:43.898] - queued futures: [n=1] TRUE
[10:22:43.898] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:43.898]  length: 0 (resolved future 1)
[10:22:43.898] Relaying remaining futures
[10:22:43.898] signalConditionsASAP(NULL, pos=0) ...
[10:22:43.898] - nx: 1
[10:22:43.898] - relay: TRUE
[10:22:43.898] - stdout: TRUE
[10:22:43.898] - signal: TRUE
[10:22:43.898] - resignal: FALSE
[10:22:43.899] - force: TRUE
[10:22:43.899] - relayed: [n=1] TRUE
[10:22:43.899] - queued futures: [n=1] TRUE
 - flush all
[10:22:43.899] - relayed: [n=1] TRUE
[10:22:43.899] - queued futures: [n=1] TRUE
[10:22:43.899] signalConditionsASAP(NULL, pos=0) ... done
[10:22:43.899] resolve() on list ... DONE
[10:22:43.899]  - Number of value chunks collected: 1
[10:22:43.899] Resolving 1 futures (chunks) ... DONE
[10:22:43.899] Reducing values from 1 chunks ...
[10:22:43.899]  - Number of values collected after concatenation: 2
[10:22:43.900]  - Number of values expected: 2
[10:22:43.900] Reducing values from 1 chunks ... DONE
[10:22:43.900] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[10:22:43.902] getGlobalsAndPackagesXApply() ...
[10:22:43.902]  - future.globals: TRUE
[10:22:43.902] getGlobalsAndPackages() ...
[10:22:43.902] Searching for globals...
[10:22:43.904] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:22:43.904] Searching for globals ... DONE
[10:22:43.904] Resolving globals: FALSE
[10:22:43.904] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[10:22:43.904] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[10:22:43.905] - globals: [1] ‘FUN’
[10:22:43.905] - packages: [1] ‘stats’
[10:22:43.905] getGlobalsAndPackages() ... DONE
[10:22:43.905]  - globals found/used: [n=1] ‘FUN’
[10:22:43.905]  - needed namespaces: [n=1] ‘stats’
[10:22:43.905] Finding globals ... DONE
[10:22:43.905]  - use_args: TRUE
[10:22:43.905]  - Getting '...' globals ...
[10:22:43.906] resolve() on list ...
[10:22:43.906]  recursive: 0
[10:22:43.906]  length: 1
[10:22:43.906]  elements: ‘...’
[10:22:43.906]  length: 0 (resolved future 1)
[10:22:43.906] resolve() on list ... DONE
[10:22:43.906]    - '...' content: [n=0] 
[10:22:43.906] List of 1
[10:22:43.906]  $ ...: list()
[10:22:43.906]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:43.906]  - attr(*, "where")=List of 1
[10:22:43.906]   ..$ ...:<environment: 0x55ca4c7fbd50> 
[10:22:43.906]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:43.906]  - attr(*, "resolved")= logi TRUE
[10:22:43.906]  - attr(*, "total_size")= num NA
[10:22:43.909]  - Getting '...' globals ... DONE
[10:22:43.909] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:43.909] List of 2
[10:22:43.909]  $ ...future.FUN:function (x, ...)  
[10:22:43.909]  $ ...          : list()
[10:22:43.909]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:43.909]  - attr(*, "where")=List of 2
[10:22:43.909]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:43.909]   ..$ ...          :<environment: 0x55ca4c7fbd50> 
[10:22:43.909]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:43.909]  - attr(*, "resolved")= logi FALSE
[10:22:43.909]  - attr(*, "total_size")= num 1248
[10:22:43.912] Packages to be attached in all futures: [n=1] ‘stats’
[10:22:43.912] getGlobalsAndPackagesXApply() ... DONE
[10:22:43.912] future_lapply() ...
[10:22:43.913] Number of chunks: 1
[10:22:43.913] getGlobalsAndPackagesXApply() ...
[10:22:43.913]  - future.globals: <name-value list> with names ‘list()’
[10:22:43.913]  - use_args: TRUE
[10:22:43.915] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:22:43.915] List of 2
[10:22:43.915]  $ ...          : list()
[10:22:43.915]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:43.915]  $ ...future.FUN:function (x, ...)  
[10:22:43.915]  - attr(*, "where")=List of 2
[10:22:43.915]   ..$ ...          :<environment: 0x55ca4c7fbd50> 
[10:22:43.915]   ..$ ...future.FUN:<environment: namespace:stats> 
[10:22:43.915]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:43.915]  - attr(*, "resolved")= logi FALSE
[10:22:43.915]  - attr(*, "total_size")= num NA
[10:22:43.918] Packages to be attached in all futures: [n=1] ‘stats’
[10:22:43.918] getGlobalsAndPackagesXApply() ... DONE
[10:22:43.918] Number of futures (= number of chunks): 1
[10:22:43.918] Launching 1 futures (chunks) ...
[10:22:43.918] Chunk #1 of 1 ...
[10:22:43.918]  - seeds: <none>
[10:22:43.919]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:43.919] getGlobalsAndPackages() ...
[10:22:43.919] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:43.919] Resolving globals: FALSE
[10:22:43.919] Tweak future expression to call with '...' arguments ...
[10:22:43.919] {
[10:22:43.919]     do.call(function(...) {
[10:22:43.919]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:43.919]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:43.919]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:43.919]             on.exit(options(oopts), add = TRUE)
[10:22:43.919]         }
[10:22:43.919]         {
[10:22:43.919]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:43.919]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:43.919]                 ...future.FUN(...future.X_jj, ...)
[10:22:43.919]             })
[10:22:43.919]         }
[10:22:43.919]     }, args = future.call.arguments)
[10:22:43.919] }
[10:22:43.919] Tweak future expression to call with '...' arguments ... DONE
[10:22:43.920] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:43.920] - packages: [1] ‘stats’
[10:22:43.920] getGlobalsAndPackages() ... DONE
[10:22:43.920] run() for ‘Future’ ...
[10:22:43.920] - state: ‘created’
[10:22:43.921] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:43.921] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:43.921] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:43.921]   - Field: ‘label’
[10:22:43.921]   - Field: ‘local’
[10:22:43.921]   - Field: ‘owner’
[10:22:43.921]   - Field: ‘envir’
[10:22:43.922]   - Field: ‘packages’
[10:22:43.922]   - Field: ‘gc’
[10:22:43.922]   - Field: ‘conditions’
[10:22:43.922]   - Field: ‘expr’
[10:22:43.922]   - Field: ‘uuid’
[10:22:43.922]   - Field: ‘seed’
[10:22:43.922]   - Field: ‘version’
[10:22:43.922]   - Field: ‘result’
[10:22:43.922]   - Field: ‘asynchronous’
[10:22:43.922]   - Field: ‘calls’
[10:22:43.922]   - Field: ‘globals’
[10:22:43.923]   - Field: ‘stdout’
[10:22:43.923]   - Field: ‘earlySignal’
[10:22:43.923]   - Field: ‘lazy’
[10:22:43.923]   - Field: ‘state’
[10:22:43.923] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:43.923] - Launch lazy future ...
[10:22:43.923] Packages needed by the future expression (n = 1): ‘stats’
[10:22:43.923] Packages needed by future strategies (n = 0): <none>
[10:22:43.924] {
[10:22:43.924]     {
[10:22:43.924]         {
[10:22:43.924]             ...future.startTime <- base::Sys.time()
[10:22:43.924]             {
[10:22:43.924]                 {
[10:22:43.924]                   {
[10:22:43.924]                     {
[10:22:43.924]                       base::local({
[10:22:43.924]                         has_future <- base::requireNamespace("future", 
[10:22:43.924]                           quietly = TRUE)
[10:22:43.924]                         if (has_future) {
[10:22:43.924]                           ns <- base::getNamespace("future")
[10:22:43.924]                           version <- ns[[".package"]][["version"]]
[10:22:43.924]                           if (is.null(version)) 
[10:22:43.924]                             version <- utils::packageVersion("future")
[10:22:43.924]                         }
[10:22:43.924]                         else {
[10:22:43.924]                           version <- NULL
[10:22:43.924]                         }
[10:22:43.924]                         if (!has_future || version < "1.8.0") {
[10:22:43.924]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:43.924]                             "", base::R.version$version.string), 
[10:22:43.924]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:43.924]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:43.924]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:43.924]                               "release", "version")], collapse = " "), 
[10:22:43.924]                             hostname = base::Sys.info()[["nodename"]])
[10:22:43.924]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:43.924]                             info)
[10:22:43.924]                           info <- base::paste(info, collapse = "; ")
[10:22:43.924]                           if (!has_future) {
[10:22:43.924]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:43.924]                               info)
[10:22:43.924]                           }
[10:22:43.924]                           else {
[10:22:43.924]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:43.924]                               info, version)
[10:22:43.924]                           }
[10:22:43.924]                           base::stop(msg)
[10:22:43.924]                         }
[10:22:43.924]                       })
[10:22:43.924]                     }
[10:22:43.924]                     base::local({
[10:22:43.924]                       for (pkg in "stats") {
[10:22:43.924]                         base::loadNamespace(pkg)
[10:22:43.924]                         base::library(pkg, character.only = TRUE)
[10:22:43.924]                       }
[10:22:43.924]                     })
[10:22:43.924]                   }
[10:22:43.924]                   options(future.plan = NULL)
[10:22:43.924]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:43.924]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:43.924]                 }
[10:22:43.924]                 ...future.workdir <- getwd()
[10:22:43.924]             }
[10:22:43.924]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:43.924]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:43.924]         }
[10:22:43.924]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:43.924]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:43.924]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:43.924]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:43.924]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:43.924]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:43.924]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:43.924]             base::names(...future.oldOptions))
[10:22:43.924]     }
[10:22:43.924]     if (FALSE) {
[10:22:43.924]     }
[10:22:43.924]     else {
[10:22:43.924]         if (TRUE) {
[10:22:43.924]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:43.924]                 open = "w")
[10:22:43.924]         }
[10:22:43.924]         else {
[10:22:43.924]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:43.924]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:43.924]         }
[10:22:43.924]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:43.924]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:43.924]             base::sink(type = "output", split = FALSE)
[10:22:43.924]             base::close(...future.stdout)
[10:22:43.924]         }, add = TRUE)
[10:22:43.924]     }
[10:22:43.924]     ...future.frame <- base::sys.nframe()
[10:22:43.924]     ...future.conditions <- base::list()
[10:22:43.924]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:43.924]     if (FALSE) {
[10:22:43.924]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:43.924]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:43.924]     }
[10:22:43.924]     ...future.result <- base::tryCatch({
[10:22:43.924]         base::withCallingHandlers({
[10:22:43.924]             ...future.value <- base::withVisible(base::local({
[10:22:43.924]                 do.call(function(...) {
[10:22:43.924]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:43.924]                   if (!identical(...future.globals.maxSize.org, 
[10:22:43.924]                     ...future.globals.maxSize)) {
[10:22:43.924]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:43.924]                     on.exit(options(oopts), add = TRUE)
[10:22:43.924]                   }
[10:22:43.924]                   {
[10:22:43.924]                     lapply(seq_along(...future.elements_ii), 
[10:22:43.924]                       FUN = function(jj) {
[10:22:43.924]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:43.924]                         ...future.FUN(...future.X_jj, ...)
[10:22:43.924]                       })
[10:22:43.924]                   }
[10:22:43.924]                 }, args = future.call.arguments)
[10:22:43.924]             }))
[10:22:43.924]             future::FutureResult(value = ...future.value$value, 
[10:22:43.924]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:43.924]                   ...future.rng), globalenv = if (FALSE) 
[10:22:43.924]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:43.924]                     ...future.globalenv.names))
[10:22:43.924]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:43.924]         }, condition = base::local({
[10:22:43.924]             c <- base::c
[10:22:43.924]             inherits <- base::inherits
[10:22:43.924]             invokeRestart <- base::invokeRestart
[10:22:43.924]             length <- base::length
[10:22:43.924]             list <- base::list
[10:22:43.924]             seq.int <- base::seq.int
[10:22:43.924]             signalCondition <- base::signalCondition
[10:22:43.924]             sys.calls <- base::sys.calls
[10:22:43.924]             `[[` <- base::`[[`
[10:22:43.924]             `+` <- base::`+`
[10:22:43.924]             `<<-` <- base::`<<-`
[10:22:43.924]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:43.924]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:43.924]                   3L)]
[10:22:43.924]             }
[10:22:43.924]             function(cond) {
[10:22:43.924]                 is_error <- inherits(cond, "error")
[10:22:43.924]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:43.924]                   NULL)
[10:22:43.924]                 if (is_error) {
[10:22:43.924]                   sessionInformation <- function() {
[10:22:43.924]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:43.924]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:43.924]                       search = base::search(), system = base::Sys.info())
[10:22:43.924]                   }
[10:22:43.924]                   ...future.conditions[[length(...future.conditions) + 
[10:22:43.924]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:43.924]                     cond$call), session = sessionInformation(), 
[10:22:43.924]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:43.924]                   signalCondition(cond)
[10:22:43.924]                 }
[10:22:43.924]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:43.924]                 "immediateCondition"))) {
[10:22:43.924]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:43.924]                   ...future.conditions[[length(...future.conditions) + 
[10:22:43.924]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:43.924]                   if (TRUE && !signal) {
[10:22:43.924]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:43.924]                     {
[10:22:43.924]                       inherits <- base::inherits
[10:22:43.924]                       invokeRestart <- base::invokeRestart
[10:22:43.924]                       is.null <- base::is.null
[10:22:43.924]                       muffled <- FALSE
[10:22:43.924]                       if (inherits(cond, "message")) {
[10:22:43.924]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:43.924]                         if (muffled) 
[10:22:43.924]                           invokeRestart("muffleMessage")
[10:22:43.924]                       }
[10:22:43.924]                       else if (inherits(cond, "warning")) {
[10:22:43.924]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:43.924]                         if (muffled) 
[10:22:43.924]                           invokeRestart("muffleWarning")
[10:22:43.924]                       }
[10:22:43.924]                       else if (inherits(cond, "condition")) {
[10:22:43.924]                         if (!is.null(pattern)) {
[10:22:43.924]                           computeRestarts <- base::computeRestarts
[10:22:43.924]                           grepl <- base::grepl
[10:22:43.924]                           restarts <- computeRestarts(cond)
[10:22:43.924]                           for (restart in restarts) {
[10:22:43.924]                             name <- restart$name
[10:22:43.924]                             if (is.null(name)) 
[10:22:43.924]                               next
[10:22:43.924]                             if (!grepl(pattern, name)) 
[10:22:43.924]                               next
[10:22:43.924]                             invokeRestart(restart)
[10:22:43.924]                             muffled <- TRUE
[10:22:43.924]                             break
[10:22:43.924]                           }
[10:22:43.924]                         }
[10:22:43.924]                       }
[10:22:43.924]                       invisible(muffled)
[10:22:43.924]                     }
[10:22:43.924]                     muffleCondition(cond, pattern = "^muffle")
[10:22:43.924]                   }
[10:22:43.924]                 }
[10:22:43.924]                 else {
[10:22:43.924]                   if (TRUE) {
[10:22:43.924]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:43.924]                     {
[10:22:43.924]                       inherits <- base::inherits
[10:22:43.924]                       invokeRestart <- base::invokeRestart
[10:22:43.924]                       is.null <- base::is.null
[10:22:43.924]                       muffled <- FALSE
[10:22:43.924]                       if (inherits(cond, "message")) {
[10:22:43.924]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:43.924]                         if (muffled) 
[10:22:43.924]                           invokeRestart("muffleMessage")
[10:22:43.924]                       }
[10:22:43.924]                       else if (inherits(cond, "warning")) {
[10:22:43.924]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:43.924]                         if (muffled) 
[10:22:43.924]                           invokeRestart("muffleWarning")
[10:22:43.924]                       }
[10:22:43.924]                       else if (inherits(cond, "condition")) {
[10:22:43.924]                         if (!is.null(pattern)) {
[10:22:43.924]                           computeRestarts <- base::computeRestarts
[10:22:43.924]                           grepl <- base::grepl
[10:22:43.924]                           restarts <- computeRestarts(cond)
[10:22:43.924]                           for (restart in restarts) {
[10:22:43.924]                             name <- restart$name
[10:22:43.924]                             if (is.null(name)) 
[10:22:43.924]                               next
[10:22:43.924]                             if (!grepl(pattern, name)) 
[10:22:43.924]                               next
[10:22:43.924]                             invokeRestart(restart)
[10:22:43.924]                             muffled <- TRUE
[10:22:43.924]                             break
[10:22:43.924]                           }
[10:22:43.924]                         }
[10:22:43.924]                       }
[10:22:43.924]                       invisible(muffled)
[10:22:43.924]                     }
[10:22:43.924]                     muffleCondition(cond, pattern = "^muffle")
[10:22:43.924]                   }
[10:22:43.924]                 }
[10:22:43.924]             }
[10:22:43.924]         }))
[10:22:43.924]     }, error = function(ex) {
[10:22:43.924]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:43.924]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:43.924]                 ...future.rng), started = ...future.startTime, 
[10:22:43.924]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:43.924]             version = "1.8"), class = "FutureResult")
[10:22:43.924]     }, finally = {
[10:22:43.924]         if (!identical(...future.workdir, getwd())) 
[10:22:43.924]             setwd(...future.workdir)
[10:22:43.924]         {
[10:22:43.924]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:43.924]                 ...future.oldOptions$nwarnings <- NULL
[10:22:43.924]             }
[10:22:43.924]             base::options(...future.oldOptions)
[10:22:43.924]             if (.Platform$OS.type == "windows") {
[10:22:43.924]                 old_names <- names(...future.oldEnvVars)
[10:22:43.924]                 envs <- base::Sys.getenv()
[10:22:43.924]                 names <- names(envs)
[10:22:43.924]                 common <- intersect(names, old_names)
[10:22:43.924]                 added <- setdiff(names, old_names)
[10:22:43.924]                 removed <- setdiff(old_names, names)
[10:22:43.924]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:43.924]                   envs[common]]
[10:22:43.924]                 NAMES <- toupper(changed)
[10:22:43.924]                 args <- list()
[10:22:43.924]                 for (kk in seq_along(NAMES)) {
[10:22:43.924]                   name <- changed[[kk]]
[10:22:43.924]                   NAME <- NAMES[[kk]]
[10:22:43.924]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:43.924]                     next
[10:22:43.924]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:43.924]                 }
[10:22:43.924]                 NAMES <- toupper(added)
[10:22:43.924]                 for (kk in seq_along(NAMES)) {
[10:22:43.924]                   name <- added[[kk]]
[10:22:43.924]                   NAME <- NAMES[[kk]]
[10:22:43.924]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:43.924]                     next
[10:22:43.924]                   args[[name]] <- ""
[10:22:43.924]                 }
[10:22:43.924]                 NAMES <- toupper(removed)
[10:22:43.924]                 for (kk in seq_along(NAMES)) {
[10:22:43.924]                   name <- removed[[kk]]
[10:22:43.924]                   NAME <- NAMES[[kk]]
[10:22:43.924]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:43.924]                     next
[10:22:43.924]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:43.924]                 }
[10:22:43.924]                 if (length(args) > 0) 
[10:22:43.924]                   base::do.call(base::Sys.setenv, args = args)
[10:22:43.924]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:43.924]             }
[10:22:43.924]             else {
[10:22:43.924]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:43.924]             }
[10:22:43.924]             {
[10:22:43.924]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:43.924]                   0L) {
[10:22:43.924]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:43.924]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:43.924]                   base::options(opts)
[10:22:43.924]                 }
[10:22:43.924]                 {
[10:22:43.924]                   {
[10:22:43.924]                     NULL
[10:22:43.924]                     RNGkind("Mersenne-Twister")
[10:22:43.924]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:43.924]                       inherits = FALSE)
[10:22:43.924]                   }
[10:22:43.924]                   options(future.plan = NULL)
[10:22:43.924]                   if (is.na(NA_character_)) 
[10:22:43.924]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:43.924]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:43.924]                   future::plan(list(function (..., envir = parent.frame()) 
[10:22:43.924]                   {
[10:22:43.924]                     future <- SequentialFuture(..., envir = envir)
[10:22:43.924]                     if (!future$lazy) 
[10:22:43.924]                       future <- run(future)
[10:22:43.924]                     invisible(future)
[10:22:43.924]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:43.924]                 }
[10:22:43.924]             }
[10:22:43.924]         }
[10:22:43.924]     })
[10:22:43.924]     if (TRUE) {
[10:22:43.924]         base::sink(type = "output", split = FALSE)
[10:22:43.924]         if (TRUE) {
[10:22:43.924]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:43.924]         }
[10:22:43.924]         else {
[10:22:43.924]             ...future.result["stdout"] <- base::list(NULL)
[10:22:43.924]         }
[10:22:43.924]         base::close(...future.stdout)
[10:22:43.924]         ...future.stdout <- NULL
[10:22:43.924]     }
[10:22:43.924]     ...future.result$conditions <- ...future.conditions
[10:22:43.924]     ...future.result$finished <- base::Sys.time()
[10:22:43.924]     ...future.result
[10:22:43.924] }
[10:22:43.926] assign_globals() ...
[10:22:43.926] List of 5
[10:22:43.926]  $ future.call.arguments    : list()
[10:22:43.926]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:43.926]  $ ...future.FUN            :function (x, ...)  
[10:22:43.926]  $ ...future.elements_ii    :List of 2
[10:22:43.926]   ..$ : num [1:4] 1 3 1 7
[10:22:43.926]   ..$ : num [1:4] 2 4 6 8
[10:22:43.926]  $ ...future.seeds_ii       : NULL
[10:22:43.926]  $ ...future.globals.maxSize: num Inf
[10:22:43.926]  - attr(*, "resolved")= logi FALSE
[10:22:43.926]  - attr(*, "total_size")= num NA
[10:22:43.926]  - attr(*, "where")=List of 5
[10:22:43.926]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:43.926]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:43.926]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:43.926]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:43.926]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:43.926]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:43.926]  - attr(*, "already-done")= logi TRUE
[10:22:43.931] - copied ‘future.call.arguments’ to environment
[10:22:43.931] - copied ‘...future.FUN’ to environment
[10:22:43.931] - copied ‘...future.elements_ii’ to environment
[10:22:43.932] - copied ‘...future.seeds_ii’ to environment
[10:22:43.932] - copied ‘...future.globals.maxSize’ to environment
[10:22:43.932] assign_globals() ... done
[10:22:43.932] plan(): Setting new future strategy stack:
[10:22:43.932] List of future strategies:
[10:22:43.932] 1. sequential:
[10:22:43.932]    - args: function (..., envir = parent.frame())
[10:22:43.932]    - tweaked: FALSE
[10:22:43.932]    - call: NULL
[10:22:43.933] plan(): nbrOfWorkers() = 1
[10:22:43.934] plan(): Setting new future strategy stack:
[10:22:43.934] List of future strategies:
[10:22:43.934] 1. sequential:
[10:22:43.934]    - args: function (..., envir = parent.frame())
[10:22:43.934]    - tweaked: FALSE
[10:22:43.934]    - call: plan(strategy)
[10:22:43.934] plan(): nbrOfWorkers() = 1
[10:22:43.935] SequentialFuture started (and completed)
[10:22:43.935] - Launch lazy future ... done
[10:22:43.935] run() for ‘SequentialFuture’ ... done
[10:22:43.935] Created future:
[10:22:43.935] SequentialFuture:
[10:22:43.935] Label: ‘future_apply-1’
[10:22:43.935] Expression:
[10:22:43.935] {
[10:22:43.935]     do.call(function(...) {
[10:22:43.935]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:43.935]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:43.935]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:43.935]             on.exit(options(oopts), add = TRUE)
[10:22:43.935]         }
[10:22:43.935]         {
[10:22:43.935]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:43.935]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:43.935]                 ...future.FUN(...future.X_jj, ...)
[10:22:43.935]             })
[10:22:43.935]         }
[10:22:43.935]     }, args = future.call.arguments)
[10:22:43.935] }
[10:22:43.935] Lazy evaluation: FALSE
[10:22:43.935] Asynchronous evaluation: FALSE
[10:22:43.935] Local evaluation: TRUE
[10:22:43.935] Environment: R_GlobalEnv
[10:22:43.935] Capture standard output: TRUE
[10:22:43.935] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:43.935] Globals: 5 objects totaling 1.43 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:43.935] Packages: 1 packages (‘stats’)
[10:22:43.935] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:43.935] Resolved: TRUE
[10:22:43.935] Value: 1.14 KiB of class ‘list’
[10:22:43.935] Early signaling: FALSE
[10:22:43.935] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:43.935] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:43.936] Chunk #1 of 1 ... DONE
[10:22:43.936] Launching 1 futures (chunks) ... DONE
[10:22:43.936] Resolving 1 futures (chunks) ...
[10:22:43.936] resolve() on list ...
[10:22:43.936]  recursive: 0
[10:22:43.937]  length: 1
[10:22:43.937] 
[10:22:43.937] resolved() for ‘SequentialFuture’ ...
[10:22:43.937] - state: ‘finished’
[10:22:43.937] - run: TRUE
[10:22:43.937] - result: ‘FutureResult’
[10:22:43.937] resolved() for ‘SequentialFuture’ ... done
[10:22:43.937] Future #1
[10:22:43.937] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:43.937] - nx: 1
[10:22:43.938] - relay: TRUE
[10:22:43.938] - stdout: TRUE
[10:22:43.938] - signal: TRUE
[10:22:43.938] - resignal: FALSE
[10:22:43.938] - force: TRUE
[10:22:43.938] - relayed: [n=1] FALSE
[10:22:43.938] - queued futures: [n=1] FALSE
[10:22:43.938]  - until=1
[10:22:43.938]  - relaying element #1
[10:22:43.940] - relayed: [n=1] TRUE
[10:22:43.940] - queued futures: [n=1] TRUE
[10:22:43.940] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:43.940]  length: 0 (resolved future 1)
[10:22:43.940] Relaying remaining futures
[10:22:43.941] signalConditionsASAP(NULL, pos=0) ...
[10:22:43.941] - nx: 1
[10:22:43.941] - relay: TRUE
[10:22:43.941] - stdout: TRUE
[10:22:43.941] - signal: TRUE
[10:22:43.941] - resignal: FALSE
[10:22:43.941] - force: TRUE
[10:22:43.941] - relayed: [n=1] TRUE
[10:22:43.941] - queued futures: [n=1] TRUE
 - flush all
[10:22:43.941] - relayed: [n=1] TRUE
[10:22:43.942] - queued futures: [n=1] TRUE
[10:22:43.942] signalConditionsASAP(NULL, pos=0) ... done
[10:22:43.942] resolve() on list ... DONE
[10:22:43.942]  - Number of value chunks collected: 1
[10:22:43.942] Resolving 1 futures (chunks) ... DONE
[10:22:43.942] Reducing values from 1 chunks ...
[10:22:43.942]  - Number of values collected after concatenation: 2
[10:22:43.942]  - Number of values expected: 2
[10:22:43.942] Reducing values from 1 chunks ... DONE
[10:22:43.942] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[10:22:43.943] getGlobalsAndPackagesXApply() ...
[10:22:43.943]  - future.globals: TRUE
[10:22:43.943] getGlobalsAndPackages() ...
[10:22:43.943] Searching for globals...
[10:22:43.944] - globals found: [1] ‘FUN’
[10:22:43.945] Searching for globals ... DONE
[10:22:43.945] Resolving globals: FALSE
[10:22:43.945] The total size of the 1 globals is 848 bytes (848 bytes)
[10:22:43.945] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:22:43.945] - globals: [1] ‘FUN’
[10:22:43.946] 
[10:22:43.946] getGlobalsAndPackages() ... DONE
[10:22:43.946]  - globals found/used: [n=1] ‘FUN’
[10:22:43.946]  - needed namespaces: [n=0] 
[10:22:43.946] Finding globals ... DONE
[10:22:43.946]  - use_args: TRUE
[10:22:43.946]  - Getting '...' globals ...
[10:22:43.946] resolve() on list ...
[10:22:43.946]  recursive: 0
[10:22:43.947]  length: 1
[10:22:43.947]  elements: ‘...’
[10:22:43.947]  length: 0 (resolved future 1)
[10:22:43.947] resolve() on list ... DONE
[10:22:43.947]    - '...' content: [n=0] 
[10:22:43.947] List of 1
[10:22:43.947]  $ ...: list()
[10:22:43.947]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:43.947]  - attr(*, "where")=List of 1
[10:22:43.947]   ..$ ...:<environment: 0x55ca4b796bc8> 
[10:22:43.947]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:43.947]  - attr(*, "resolved")= logi TRUE
[10:22:43.947]  - attr(*, "total_size")= num NA
[10:22:43.950]  - Getting '...' globals ... DONE
[10:22:43.950] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:43.950] List of 2
[10:22:43.950]  $ ...future.FUN:function (x)  
[10:22:43.950]  $ ...          : list()
[10:22:43.950]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:43.950]  - attr(*, "where")=List of 2
[10:22:43.950]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:43.950]   ..$ ...          :<environment: 0x55ca4b796bc8> 
[10:22:43.950]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:43.950]  - attr(*, "resolved")= logi FALSE
[10:22:43.950]  - attr(*, "total_size")= num 848
[10:22:43.952] Packages to be attached in all futures: [n=0] 
[10:22:43.953] getGlobalsAndPackagesXApply() ... DONE
[10:22:43.953] future_lapply() ...
[10:22:43.953] Number of chunks: 1
[10:22:43.953] getGlobalsAndPackagesXApply() ...
[10:22:43.953]  - future.globals: <name-value list> with names ‘list()’
[10:22:43.954]  - use_args: TRUE
[10:22:43.954] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:22:43.954] List of 2
[10:22:43.954]  $ ...          : list()
[10:22:43.954]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:43.954]  $ ...future.FUN:function (x)  
[10:22:43.954]  - attr(*, "where")=List of 2
[10:22:43.954]   ..$ ...          :<environment: 0x55ca4b796bc8> 
[10:22:43.954]   ..$ ...future.FUN:<environment: namespace:base> 
[10:22:43.954]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:43.954]  - attr(*, "resolved")= logi FALSE
[10:22:43.954]  - attr(*, "total_size")= num NA
[10:22:43.957] Packages to be attached in all futures: [n=0] 
[10:22:43.957] getGlobalsAndPackagesXApply() ... DONE
[10:22:43.957] Number of futures (= number of chunks): 1
[10:22:43.957] Launching 1 futures (chunks) ...
[10:22:43.957] Chunk #1 of 1 ...
[10:22:43.958]  - seeds: <none>
[10:22:43.958]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:43.958] getGlobalsAndPackages() ...
[10:22:43.958] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:43.958] Resolving globals: FALSE
[10:22:43.958] Tweak future expression to call with '...' arguments ...
[10:22:43.958] {
[10:22:43.958]     do.call(function(...) {
[10:22:43.958]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:43.958]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:43.958]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:43.958]             on.exit(options(oopts), add = TRUE)
[10:22:43.958]         }
[10:22:43.958]         {
[10:22:43.958]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:43.958]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:43.958]                 ...future.FUN(...future.X_jj, ...)
[10:22:43.958]             })
[10:22:43.958]         }
[10:22:43.958]     }, args = future.call.arguments)
[10:22:43.958] }
[10:22:43.958] Tweak future expression to call with '...' arguments ... DONE
[10:22:43.959] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:43.959] 
[10:22:43.959] getGlobalsAndPackages() ... DONE
[10:22:43.959] run() for ‘Future’ ...
[10:22:43.959] - state: ‘created’
[10:22:43.960] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:43.960] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:43.960] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:43.960]   - Field: ‘label’
[10:22:43.960]   - Field: ‘local’
[10:22:43.960]   - Field: ‘owner’
[10:22:43.960]   - Field: ‘envir’
[10:22:43.960]   - Field: ‘packages’
[10:22:43.960]   - Field: ‘gc’
[10:22:43.961]   - Field: ‘conditions’
[10:22:43.961]   - Field: ‘expr’
[10:22:43.961]   - Field: ‘uuid’
[10:22:43.961]   - Field: ‘seed’
[10:22:43.961]   - Field: ‘version’
[10:22:43.962]   - Field: ‘result’
[10:22:43.962]   - Field: ‘asynchronous’
[10:22:43.962]   - Field: ‘calls’
[10:22:43.962]   - Field: ‘globals’
[10:22:43.962]   - Field: ‘stdout’
[10:22:43.962]   - Field: ‘earlySignal’
[10:22:43.963]   - Field: ‘lazy’
[10:22:43.963]   - Field: ‘state’
[10:22:43.963] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:43.963] - Launch lazy future ...
[10:22:43.963] Packages needed by the future expression (n = 0): <none>
[10:22:43.963] Packages needed by future strategies (n = 0): <none>
[10:22:43.964] {
[10:22:43.964]     {
[10:22:43.964]         {
[10:22:43.964]             ...future.startTime <- base::Sys.time()
[10:22:43.964]             {
[10:22:43.964]                 {
[10:22:43.964]                   {
[10:22:43.964]                     base::local({
[10:22:43.964]                       has_future <- base::requireNamespace("future", 
[10:22:43.964]                         quietly = TRUE)
[10:22:43.964]                       if (has_future) {
[10:22:43.964]                         ns <- base::getNamespace("future")
[10:22:43.964]                         version <- ns[[".package"]][["version"]]
[10:22:43.964]                         if (is.null(version)) 
[10:22:43.964]                           version <- utils::packageVersion("future")
[10:22:43.964]                       }
[10:22:43.964]                       else {
[10:22:43.964]                         version <- NULL
[10:22:43.964]                       }
[10:22:43.964]                       if (!has_future || version < "1.8.0") {
[10:22:43.964]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:43.964]                           "", base::R.version$version.string), 
[10:22:43.964]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:43.964]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:43.964]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:43.964]                             "release", "version")], collapse = " "), 
[10:22:43.964]                           hostname = base::Sys.info()[["nodename"]])
[10:22:43.964]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:43.964]                           info)
[10:22:43.964]                         info <- base::paste(info, collapse = "; ")
[10:22:43.964]                         if (!has_future) {
[10:22:43.964]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:43.964]                             info)
[10:22:43.964]                         }
[10:22:43.964]                         else {
[10:22:43.964]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:43.964]                             info, version)
[10:22:43.964]                         }
[10:22:43.964]                         base::stop(msg)
[10:22:43.964]                       }
[10:22:43.964]                     })
[10:22:43.964]                   }
[10:22:43.964]                   options(future.plan = NULL)
[10:22:43.964]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:43.964]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:43.964]                 }
[10:22:43.964]                 ...future.workdir <- getwd()
[10:22:43.964]             }
[10:22:43.964]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:43.964]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:43.964]         }
[10:22:43.964]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:43.964]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:43.964]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:43.964]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:43.964]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:43.964]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:43.964]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:43.964]             base::names(...future.oldOptions))
[10:22:43.964]     }
[10:22:43.964]     if (FALSE) {
[10:22:43.964]     }
[10:22:43.964]     else {
[10:22:43.964]         if (TRUE) {
[10:22:43.964]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:43.964]                 open = "w")
[10:22:43.964]         }
[10:22:43.964]         else {
[10:22:43.964]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:43.964]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:43.964]         }
[10:22:43.964]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:43.964]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:43.964]             base::sink(type = "output", split = FALSE)
[10:22:43.964]             base::close(...future.stdout)
[10:22:43.964]         }, add = TRUE)
[10:22:43.964]     }
[10:22:43.964]     ...future.frame <- base::sys.nframe()
[10:22:43.964]     ...future.conditions <- base::list()
[10:22:43.964]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:43.964]     if (FALSE) {
[10:22:43.964]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:43.964]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:43.964]     }
[10:22:43.964]     ...future.result <- base::tryCatch({
[10:22:43.964]         base::withCallingHandlers({
[10:22:43.964]             ...future.value <- base::withVisible(base::local({
[10:22:43.964]                 do.call(function(...) {
[10:22:43.964]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:43.964]                   if (!identical(...future.globals.maxSize.org, 
[10:22:43.964]                     ...future.globals.maxSize)) {
[10:22:43.964]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:43.964]                     on.exit(options(oopts), add = TRUE)
[10:22:43.964]                   }
[10:22:43.964]                   {
[10:22:43.964]                     lapply(seq_along(...future.elements_ii), 
[10:22:43.964]                       FUN = function(jj) {
[10:22:43.964]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:43.964]                         ...future.FUN(...future.X_jj, ...)
[10:22:43.964]                       })
[10:22:43.964]                   }
[10:22:43.964]                 }, args = future.call.arguments)
[10:22:43.964]             }))
[10:22:43.964]             future::FutureResult(value = ...future.value$value, 
[10:22:43.964]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:43.964]                   ...future.rng), globalenv = if (FALSE) 
[10:22:43.964]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:43.964]                     ...future.globalenv.names))
[10:22:43.964]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:43.964]         }, condition = base::local({
[10:22:43.964]             c <- base::c
[10:22:43.964]             inherits <- base::inherits
[10:22:43.964]             invokeRestart <- base::invokeRestart
[10:22:43.964]             length <- base::length
[10:22:43.964]             list <- base::list
[10:22:43.964]             seq.int <- base::seq.int
[10:22:43.964]             signalCondition <- base::signalCondition
[10:22:43.964]             sys.calls <- base::sys.calls
[10:22:43.964]             `[[` <- base::`[[`
[10:22:43.964]             `+` <- base::`+`
[10:22:43.964]             `<<-` <- base::`<<-`
[10:22:43.964]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:43.964]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:43.964]                   3L)]
[10:22:43.964]             }
[10:22:43.964]             function(cond) {
[10:22:43.964]                 is_error <- inherits(cond, "error")
[10:22:43.964]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:43.964]                   NULL)
[10:22:43.964]                 if (is_error) {
[10:22:43.964]                   sessionInformation <- function() {
[10:22:43.964]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:43.964]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:43.964]                       search = base::search(), system = base::Sys.info())
[10:22:43.964]                   }
[10:22:43.964]                   ...future.conditions[[length(...future.conditions) + 
[10:22:43.964]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:43.964]                     cond$call), session = sessionInformation(), 
[10:22:43.964]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:43.964]                   signalCondition(cond)
[10:22:43.964]                 }
[10:22:43.964]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:43.964]                 "immediateCondition"))) {
[10:22:43.964]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:43.964]                   ...future.conditions[[length(...future.conditions) + 
[10:22:43.964]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:43.964]                   if (TRUE && !signal) {
[10:22:43.964]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:43.964]                     {
[10:22:43.964]                       inherits <- base::inherits
[10:22:43.964]                       invokeRestart <- base::invokeRestart
[10:22:43.964]                       is.null <- base::is.null
[10:22:43.964]                       muffled <- FALSE
[10:22:43.964]                       if (inherits(cond, "message")) {
[10:22:43.964]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:43.964]                         if (muffled) 
[10:22:43.964]                           invokeRestart("muffleMessage")
[10:22:43.964]                       }
[10:22:43.964]                       else if (inherits(cond, "warning")) {
[10:22:43.964]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:43.964]                         if (muffled) 
[10:22:43.964]                           invokeRestart("muffleWarning")
[10:22:43.964]                       }
[10:22:43.964]                       else if (inherits(cond, "condition")) {
[10:22:43.964]                         if (!is.null(pattern)) {
[10:22:43.964]                           computeRestarts <- base::computeRestarts
[10:22:43.964]                           grepl <- base::grepl
[10:22:43.964]                           restarts <- computeRestarts(cond)
[10:22:43.964]                           for (restart in restarts) {
[10:22:43.964]                             name <- restart$name
[10:22:43.964]                             if (is.null(name)) 
[10:22:43.964]                               next
[10:22:43.964]                             if (!grepl(pattern, name)) 
[10:22:43.964]                               next
[10:22:43.964]                             invokeRestart(restart)
[10:22:43.964]                             muffled <- TRUE
[10:22:43.964]                             break
[10:22:43.964]                           }
[10:22:43.964]                         }
[10:22:43.964]                       }
[10:22:43.964]                       invisible(muffled)
[10:22:43.964]                     }
[10:22:43.964]                     muffleCondition(cond, pattern = "^muffle")
[10:22:43.964]                   }
[10:22:43.964]                 }
[10:22:43.964]                 else {
[10:22:43.964]                   if (TRUE) {
[10:22:43.964]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:43.964]                     {
[10:22:43.964]                       inherits <- base::inherits
[10:22:43.964]                       invokeRestart <- base::invokeRestart
[10:22:43.964]                       is.null <- base::is.null
[10:22:43.964]                       muffled <- FALSE
[10:22:43.964]                       if (inherits(cond, "message")) {
[10:22:43.964]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:43.964]                         if (muffled) 
[10:22:43.964]                           invokeRestart("muffleMessage")
[10:22:43.964]                       }
[10:22:43.964]                       else if (inherits(cond, "warning")) {
[10:22:43.964]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:43.964]                         if (muffled) 
[10:22:43.964]                           invokeRestart("muffleWarning")
[10:22:43.964]                       }
[10:22:43.964]                       else if (inherits(cond, "condition")) {
[10:22:43.964]                         if (!is.null(pattern)) {
[10:22:43.964]                           computeRestarts <- base::computeRestarts
[10:22:43.964]                           grepl <- base::grepl
[10:22:43.964]                           restarts <- computeRestarts(cond)
[10:22:43.964]                           for (restart in restarts) {
[10:22:43.964]                             name <- restart$name
[10:22:43.964]                             if (is.null(name)) 
[10:22:43.964]                               next
[10:22:43.964]                             if (!grepl(pattern, name)) 
[10:22:43.964]                               next
[10:22:43.964]                             invokeRestart(restart)
[10:22:43.964]                             muffled <- TRUE
[10:22:43.964]                             break
[10:22:43.964]                           }
[10:22:43.964]                         }
[10:22:43.964]                       }
[10:22:43.964]                       invisible(muffled)
[10:22:43.964]                     }
[10:22:43.964]                     muffleCondition(cond, pattern = "^muffle")
[10:22:43.964]                   }
[10:22:43.964]                 }
[10:22:43.964]             }
[10:22:43.964]         }))
[10:22:43.964]     }, error = function(ex) {
[10:22:43.964]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:43.964]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:43.964]                 ...future.rng), started = ...future.startTime, 
[10:22:43.964]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:43.964]             version = "1.8"), class = "FutureResult")
[10:22:43.964]     }, finally = {
[10:22:43.964]         if (!identical(...future.workdir, getwd())) 
[10:22:43.964]             setwd(...future.workdir)
[10:22:43.964]         {
[10:22:43.964]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:43.964]                 ...future.oldOptions$nwarnings <- NULL
[10:22:43.964]             }
[10:22:43.964]             base::options(...future.oldOptions)
[10:22:43.964]             if (.Platform$OS.type == "windows") {
[10:22:43.964]                 old_names <- names(...future.oldEnvVars)
[10:22:43.964]                 envs <- base::Sys.getenv()
[10:22:43.964]                 names <- names(envs)
[10:22:43.964]                 common <- intersect(names, old_names)
[10:22:43.964]                 added <- setdiff(names, old_names)
[10:22:43.964]                 removed <- setdiff(old_names, names)
[10:22:43.964]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:43.964]                   envs[common]]
[10:22:43.964]                 NAMES <- toupper(changed)
[10:22:43.964]                 args <- list()
[10:22:43.964]                 for (kk in seq_along(NAMES)) {
[10:22:43.964]                   name <- changed[[kk]]
[10:22:43.964]                   NAME <- NAMES[[kk]]
[10:22:43.964]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:43.964]                     next
[10:22:43.964]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:43.964]                 }
[10:22:43.964]                 NAMES <- toupper(added)
[10:22:43.964]                 for (kk in seq_along(NAMES)) {
[10:22:43.964]                   name <- added[[kk]]
[10:22:43.964]                   NAME <- NAMES[[kk]]
[10:22:43.964]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:43.964]                     next
[10:22:43.964]                   args[[name]] <- ""
[10:22:43.964]                 }
[10:22:43.964]                 NAMES <- toupper(removed)
[10:22:43.964]                 for (kk in seq_along(NAMES)) {
[10:22:43.964]                   name <- removed[[kk]]
[10:22:43.964]                   NAME <- NAMES[[kk]]
[10:22:43.964]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:43.964]                     next
[10:22:43.964]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:43.964]                 }
[10:22:43.964]                 if (length(args) > 0) 
[10:22:43.964]                   base::do.call(base::Sys.setenv, args = args)
[10:22:43.964]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:43.964]             }
[10:22:43.964]             else {
[10:22:43.964]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:43.964]             }
[10:22:43.964]             {
[10:22:43.964]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:43.964]                   0L) {
[10:22:43.964]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:43.964]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:43.964]                   base::options(opts)
[10:22:43.964]                 }
[10:22:43.964]                 {
[10:22:43.964]                   {
[10:22:43.964]                     NULL
[10:22:43.964]                     RNGkind("Mersenne-Twister")
[10:22:43.964]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:43.964]                       inherits = FALSE)
[10:22:43.964]                   }
[10:22:43.964]                   options(future.plan = NULL)
[10:22:43.964]                   if (is.na(NA_character_)) 
[10:22:43.964]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:43.964]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:43.964]                   future::plan(list(function (..., envir = parent.frame()) 
[10:22:43.964]                   {
[10:22:43.964]                     future <- SequentialFuture(..., envir = envir)
[10:22:43.964]                     if (!future$lazy) 
[10:22:43.964]                       future <- run(future)
[10:22:43.964]                     invisible(future)
[10:22:43.964]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:43.964]                 }
[10:22:43.964]             }
[10:22:43.964]         }
[10:22:43.964]     })
[10:22:43.964]     if (TRUE) {
[10:22:43.964]         base::sink(type = "output", split = FALSE)
[10:22:43.964]         if (TRUE) {
[10:22:43.964]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:43.964]         }
[10:22:43.964]         else {
[10:22:43.964]             ...future.result["stdout"] <- base::list(NULL)
[10:22:43.964]         }
[10:22:43.964]         base::close(...future.stdout)
[10:22:43.964]         ...future.stdout <- NULL
[10:22:43.964]     }
[10:22:43.964]     ...future.result$conditions <- ...future.conditions
[10:22:43.964]     ...future.result$finished <- base::Sys.time()
[10:22:43.964]     ...future.result
[10:22:43.964] }
[10:22:43.965] assign_globals() ...
[10:22:43.965] List of 5
[10:22:43.965]  $ future.call.arguments    : list()
[10:22:43.965]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:43.965]  $ ...future.FUN            :function (x)  
[10:22:43.965]  $ ...future.elements_ii    :List of 2
[10:22:43.965]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[10:22:43.965]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[10:22:43.965]  $ ...future.seeds_ii       : NULL
[10:22:43.965]  $ ...future.globals.maxSize: num Inf
[10:22:43.965]  - attr(*, "resolved")= logi FALSE
[10:22:43.965]  - attr(*, "total_size")= num NA
[10:22:43.965]  - attr(*, "where")=List of 5
[10:22:43.965]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:43.965]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:43.965]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:43.965]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:43.965]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:43.965]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:43.965]  - attr(*, "already-done")= logi TRUE
[10:22:43.970] - copied ‘future.call.arguments’ to environment
[10:22:43.970] - copied ‘...future.FUN’ to environment
[10:22:43.970] - copied ‘...future.elements_ii’ to environment
[10:22:43.971] - copied ‘...future.seeds_ii’ to environment
[10:22:43.971] - copied ‘...future.globals.maxSize’ to environment
[10:22:43.971] assign_globals() ... done
[10:22:43.971] plan(): Setting new future strategy stack:
[10:22:43.971] List of future strategies:
[10:22:43.971] 1. sequential:
[10:22:43.971]    - args: function (..., envir = parent.frame())
[10:22:43.971]    - tweaked: FALSE
[10:22:43.971]    - call: NULL
[10:22:43.971] plan(): nbrOfWorkers() = 1
[10:22:43.972] plan(): Setting new future strategy stack:
[10:22:43.972] List of future strategies:
[10:22:43.972] 1. sequential:
[10:22:43.972]    - args: function (..., envir = parent.frame())
[10:22:43.972]    - tweaked: FALSE
[10:22:43.972]    - call: plan(strategy)
[10:22:43.973] plan(): nbrOfWorkers() = 1
[10:22:43.973] SequentialFuture started (and completed)
[10:22:43.973] - Launch lazy future ... done
[10:22:43.973] run() for ‘SequentialFuture’ ... done
[10:22:43.973] Created future:
[10:22:43.973] SequentialFuture:
[10:22:43.973] Label: ‘future_apply-1’
[10:22:43.973] Expression:
[10:22:43.973] {
[10:22:43.973]     do.call(function(...) {
[10:22:43.973]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:43.973]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:43.973]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:43.973]             on.exit(options(oopts), add = TRUE)
[10:22:43.973]         }
[10:22:43.973]         {
[10:22:43.973]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:43.973]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:43.973]                 ...future.FUN(...future.X_jj, ...)
[10:22:43.973]             })
[10:22:43.973]         }
[10:22:43.973]     }, args = future.call.arguments)
[10:22:43.973] }
[10:22:43.973] Lazy evaluation: FALSE
[10:22:43.973] Asynchronous evaluation: FALSE
[10:22:43.973] Local evaluation: TRUE
[10:22:43.973] Environment: R_GlobalEnv
[10:22:43.973] Capture standard output: TRUE
[10:22:43.973] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:43.973] Globals: 5 objects totaling 1.10 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:43.973] Packages: <none>
[10:22:43.973] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:43.973] Resolved: TRUE
[10:22:43.973] Value: 224 bytes of class ‘list’
[10:22:43.973] Early signaling: FALSE
[10:22:43.973] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:43.973] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:43.974] Chunk #1 of 1 ... DONE
[10:22:43.974] Launching 1 futures (chunks) ... DONE
[10:22:43.974] Resolving 1 futures (chunks) ...
[10:22:43.974] resolve() on list ...
[10:22:43.974]  recursive: 0
[10:22:43.975]  length: 1
[10:22:43.975] 
[10:22:43.975] resolved() for ‘SequentialFuture’ ...
[10:22:43.975] - state: ‘finished’
[10:22:43.975] - run: TRUE
[10:22:43.975] - result: ‘FutureResult’
[10:22:43.975] resolved() for ‘SequentialFuture’ ... done
[10:22:43.975] Future #1
[10:22:43.975] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:43.975] - nx: 1
[10:22:43.976] - relay: TRUE
[10:22:43.976] - stdout: TRUE
[10:22:43.976] - signal: TRUE
[10:22:43.976] - resignal: FALSE
[10:22:43.976] - force: TRUE
[10:22:43.976] - relayed: [n=1] FALSE
[10:22:43.976] - queued futures: [n=1] FALSE
[10:22:43.976]  - until=1
[10:22:43.976]  - relaying element #1
[10:22:43.976] - relayed: [n=1] TRUE
[10:22:43.976] - queued futures: [n=1] TRUE
[10:22:43.977] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:43.977]  length: 0 (resolved future 1)
[10:22:43.977] Relaying remaining futures
[10:22:43.977] signalConditionsASAP(NULL, pos=0) ...
[10:22:43.977] - nx: 1
[10:22:43.977] - relay: TRUE
[10:22:43.977] - stdout: TRUE
[10:22:43.977] - signal: TRUE
[10:22:43.977] - resignal: FALSE
[10:22:43.977] - force: TRUE
[10:22:43.977] - relayed: [n=1] TRUE
[10:22:43.977] - queued futures: [n=1] TRUE
 - flush all
[10:22:43.978] - relayed: [n=1] TRUE
[10:22:43.978] - queued futures: [n=1] TRUE
[10:22:43.978] signalConditionsASAP(NULL, pos=0) ... done
[10:22:43.978] resolve() on list ... DONE
[10:22:43.978]  - Number of value chunks collected: 1
[10:22:43.978] Resolving 1 futures (chunks) ... DONE
[10:22:43.978] Reducing values from 1 chunks ...
[10:22:43.978]  - Number of values collected after concatenation: 2
[10:22:43.978]  - Number of values expected: 2
[10:22:43.978] Reducing values from 1 chunks ... DONE
[10:22:43.978] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[10:22:43.979] getGlobalsAndPackagesXApply() ...
[10:22:43.979]  - future.globals: TRUE
[10:22:43.979] getGlobalsAndPackages() ...
[10:22:43.979] Searching for globals...
[10:22:43.980] - globals found: [1] ‘FUN’
[10:22:43.980] Searching for globals ... DONE
[10:22:43.980] Resolving globals: FALSE
[10:22:43.980] The total size of the 1 globals is 848 bytes (848 bytes)
[10:22:43.981] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:22:43.981] - globals: [1] ‘FUN’
[10:22:43.981] 
[10:22:43.981] getGlobalsAndPackages() ... DONE
[10:22:43.981]  - globals found/used: [n=1] ‘FUN’
[10:22:43.981]  - needed namespaces: [n=0] 
[10:22:43.981] Finding globals ... DONE
[10:22:43.982]  - use_args: TRUE
[10:22:43.982]  - Getting '...' globals ...
[10:22:43.982] resolve() on list ...
[10:22:43.982]  recursive: 0
[10:22:43.982]  length: 1
[10:22:43.982]  elements: ‘...’
[10:22:43.982]  length: 0 (resolved future 1)
[10:22:43.982] resolve() on list ... DONE
[10:22:43.982]    - '...' content: [n=0] 
[10:22:43.983] List of 1
[10:22:43.983]  $ ...: list()
[10:22:43.983]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:43.983]  - attr(*, "where")=List of 1
[10:22:43.983]   ..$ ...:<environment: 0x55ca4d16e960> 
[10:22:43.983]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:43.983]  - attr(*, "resolved")= logi TRUE
[10:22:43.983]  - attr(*, "total_size")= num NA
[10:22:43.986]  - Getting '...' globals ... DONE
[10:22:43.986] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:43.986] List of 2
[10:22:43.986]  $ ...future.FUN:function (x)  
[10:22:43.986]  $ ...          : list()
[10:22:43.986]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:43.986]  - attr(*, "where")=List of 2
[10:22:43.986]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:43.986]   ..$ ...          :<environment: 0x55ca4d16e960> 
[10:22:43.986]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:43.986]  - attr(*, "resolved")= logi FALSE
[10:22:43.986]  - attr(*, "total_size")= num 848
[10:22:43.989] Packages to be attached in all futures: [n=0] 
[10:22:43.989] getGlobalsAndPackagesXApply() ... DONE
[10:22:43.989] future_lapply() ...
[10:22:43.990] Number of chunks: 1
[10:22:43.990] getGlobalsAndPackagesXApply() ...
[10:22:43.990]  - future.globals: <name-value list> with names ‘list()’
[10:22:43.990]  - use_args: TRUE
[10:22:43.990] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:22:43.990] List of 2
[10:22:43.990]  $ ...          : list()
[10:22:43.990]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:43.990]  $ ...future.FUN:function (x)  
[10:22:43.990]  - attr(*, "where")=List of 2
[10:22:43.990]   ..$ ...          :<environment: 0x55ca4d16e960> 
[10:22:43.990]   ..$ ...future.FUN:<environment: namespace:base> 
[10:22:43.990]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:43.990]  - attr(*, "resolved")= logi FALSE
[10:22:43.990]  - attr(*, "total_size")= num NA
[10:22:43.993] Packages to be attached in all futures: [n=0] 
[10:22:43.993] getGlobalsAndPackagesXApply() ... DONE
[10:22:43.993] Number of futures (= number of chunks): 1
[10:22:43.994] Launching 1 futures (chunks) ...
[10:22:43.994] Chunk #1 of 1 ...
[10:22:43.994]  - seeds: <none>
[10:22:43.994]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:43.994] getGlobalsAndPackages() ...
[10:22:43.994] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:43.994] Resolving globals: FALSE
[10:22:43.994] Tweak future expression to call with '...' arguments ...
[10:22:43.994] {
[10:22:43.994]     do.call(function(...) {
[10:22:43.994]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:43.994]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:43.994]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:43.994]             on.exit(options(oopts), add = TRUE)
[10:22:43.994]         }
[10:22:43.994]         {
[10:22:43.994]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:43.994]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:43.994]                 ...future.FUN(...future.X_jj, ...)
[10:22:43.994]             })
[10:22:43.994]         }
[10:22:43.994]     }, args = future.call.arguments)
[10:22:43.994] }
[10:22:43.995] Tweak future expression to call with '...' arguments ... DONE
[10:22:43.995] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:43.995] 
[10:22:43.995] getGlobalsAndPackages() ... DONE
[10:22:43.995] run() for ‘Future’ ...
[10:22:43.996] - state: ‘created’
[10:22:43.996] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:43.996] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:43.996] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:43.996]   - Field: ‘label’
[10:22:43.996]   - Field: ‘local’
[10:22:43.996]   - Field: ‘owner’
[10:22:43.996]   - Field: ‘envir’
[10:22:43.997]   - Field: ‘packages’
[10:22:43.997]   - Field: ‘gc’
[10:22:43.997]   - Field: ‘conditions’
[10:22:43.997]   - Field: ‘expr’
[10:22:43.997]   - Field: ‘uuid’
[10:22:43.997]   - Field: ‘seed’
[10:22:43.997]   - Field: ‘version’
[10:22:43.997]   - Field: ‘result’
[10:22:43.997]   - Field: ‘asynchronous’
[10:22:43.997]   - Field: ‘calls’
[10:22:43.997]   - Field: ‘globals’
[10:22:43.998]   - Field: ‘stdout’
[10:22:43.998]   - Field: ‘earlySignal’
[10:22:43.998]   - Field: ‘lazy’
[10:22:43.998]   - Field: ‘state’
[10:22:43.998] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:43.998] - Launch lazy future ...
[10:22:43.998] Packages needed by the future expression (n = 0): <none>
[10:22:43.998] Packages needed by future strategies (n = 0): <none>
[10:22:43.999] {
[10:22:43.999]     {
[10:22:43.999]         {
[10:22:43.999]             ...future.startTime <- base::Sys.time()
[10:22:43.999]             {
[10:22:43.999]                 {
[10:22:43.999]                   {
[10:22:43.999]                     base::local({
[10:22:43.999]                       has_future <- base::requireNamespace("future", 
[10:22:43.999]                         quietly = TRUE)
[10:22:43.999]                       if (has_future) {
[10:22:43.999]                         ns <- base::getNamespace("future")
[10:22:43.999]                         version <- ns[[".package"]][["version"]]
[10:22:43.999]                         if (is.null(version)) 
[10:22:43.999]                           version <- utils::packageVersion("future")
[10:22:43.999]                       }
[10:22:43.999]                       else {
[10:22:43.999]                         version <- NULL
[10:22:43.999]                       }
[10:22:43.999]                       if (!has_future || version < "1.8.0") {
[10:22:43.999]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:43.999]                           "", base::R.version$version.string), 
[10:22:43.999]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:43.999]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:43.999]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:43.999]                             "release", "version")], collapse = " "), 
[10:22:43.999]                           hostname = base::Sys.info()[["nodename"]])
[10:22:43.999]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:43.999]                           info)
[10:22:43.999]                         info <- base::paste(info, collapse = "; ")
[10:22:43.999]                         if (!has_future) {
[10:22:43.999]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:43.999]                             info)
[10:22:43.999]                         }
[10:22:43.999]                         else {
[10:22:43.999]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:43.999]                             info, version)
[10:22:43.999]                         }
[10:22:43.999]                         base::stop(msg)
[10:22:43.999]                       }
[10:22:43.999]                     })
[10:22:43.999]                   }
[10:22:43.999]                   options(future.plan = NULL)
[10:22:43.999]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:43.999]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:43.999]                 }
[10:22:43.999]                 ...future.workdir <- getwd()
[10:22:43.999]             }
[10:22:43.999]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:43.999]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:43.999]         }
[10:22:43.999]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:43.999]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:43.999]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:43.999]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:43.999]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:43.999]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:43.999]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:43.999]             base::names(...future.oldOptions))
[10:22:43.999]     }
[10:22:43.999]     if (FALSE) {
[10:22:43.999]     }
[10:22:43.999]     else {
[10:22:43.999]         if (TRUE) {
[10:22:43.999]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:43.999]                 open = "w")
[10:22:43.999]         }
[10:22:43.999]         else {
[10:22:43.999]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:43.999]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:43.999]         }
[10:22:43.999]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:43.999]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:43.999]             base::sink(type = "output", split = FALSE)
[10:22:43.999]             base::close(...future.stdout)
[10:22:43.999]         }, add = TRUE)
[10:22:43.999]     }
[10:22:43.999]     ...future.frame <- base::sys.nframe()
[10:22:43.999]     ...future.conditions <- base::list()
[10:22:43.999]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:43.999]     if (FALSE) {
[10:22:43.999]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:43.999]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:43.999]     }
[10:22:43.999]     ...future.result <- base::tryCatch({
[10:22:43.999]         base::withCallingHandlers({
[10:22:43.999]             ...future.value <- base::withVisible(base::local({
[10:22:43.999]                 do.call(function(...) {
[10:22:43.999]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:43.999]                   if (!identical(...future.globals.maxSize.org, 
[10:22:43.999]                     ...future.globals.maxSize)) {
[10:22:43.999]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:43.999]                     on.exit(options(oopts), add = TRUE)
[10:22:43.999]                   }
[10:22:43.999]                   {
[10:22:43.999]                     lapply(seq_along(...future.elements_ii), 
[10:22:43.999]                       FUN = function(jj) {
[10:22:43.999]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:43.999]                         ...future.FUN(...future.X_jj, ...)
[10:22:43.999]                       })
[10:22:43.999]                   }
[10:22:43.999]                 }, args = future.call.arguments)
[10:22:43.999]             }))
[10:22:43.999]             future::FutureResult(value = ...future.value$value, 
[10:22:43.999]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:43.999]                   ...future.rng), globalenv = if (FALSE) 
[10:22:43.999]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:43.999]                     ...future.globalenv.names))
[10:22:43.999]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:43.999]         }, condition = base::local({
[10:22:43.999]             c <- base::c
[10:22:43.999]             inherits <- base::inherits
[10:22:43.999]             invokeRestart <- base::invokeRestart
[10:22:43.999]             length <- base::length
[10:22:43.999]             list <- base::list
[10:22:43.999]             seq.int <- base::seq.int
[10:22:43.999]             signalCondition <- base::signalCondition
[10:22:43.999]             sys.calls <- base::sys.calls
[10:22:43.999]             `[[` <- base::`[[`
[10:22:43.999]             `+` <- base::`+`
[10:22:43.999]             `<<-` <- base::`<<-`
[10:22:43.999]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:43.999]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:43.999]                   3L)]
[10:22:43.999]             }
[10:22:43.999]             function(cond) {
[10:22:43.999]                 is_error <- inherits(cond, "error")
[10:22:43.999]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:43.999]                   NULL)
[10:22:43.999]                 if (is_error) {
[10:22:43.999]                   sessionInformation <- function() {
[10:22:43.999]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:43.999]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:43.999]                       search = base::search(), system = base::Sys.info())
[10:22:43.999]                   }
[10:22:43.999]                   ...future.conditions[[length(...future.conditions) + 
[10:22:43.999]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:43.999]                     cond$call), session = sessionInformation(), 
[10:22:43.999]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:43.999]                   signalCondition(cond)
[10:22:43.999]                 }
[10:22:43.999]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:43.999]                 "immediateCondition"))) {
[10:22:43.999]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:43.999]                   ...future.conditions[[length(...future.conditions) + 
[10:22:43.999]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:43.999]                   if (TRUE && !signal) {
[10:22:43.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:43.999]                     {
[10:22:43.999]                       inherits <- base::inherits
[10:22:43.999]                       invokeRestart <- base::invokeRestart
[10:22:43.999]                       is.null <- base::is.null
[10:22:43.999]                       muffled <- FALSE
[10:22:43.999]                       if (inherits(cond, "message")) {
[10:22:43.999]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:43.999]                         if (muffled) 
[10:22:43.999]                           invokeRestart("muffleMessage")
[10:22:43.999]                       }
[10:22:43.999]                       else if (inherits(cond, "warning")) {
[10:22:43.999]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:43.999]                         if (muffled) 
[10:22:43.999]                           invokeRestart("muffleWarning")
[10:22:43.999]                       }
[10:22:43.999]                       else if (inherits(cond, "condition")) {
[10:22:43.999]                         if (!is.null(pattern)) {
[10:22:43.999]                           computeRestarts <- base::computeRestarts
[10:22:43.999]                           grepl <- base::grepl
[10:22:43.999]                           restarts <- computeRestarts(cond)
[10:22:43.999]                           for (restart in restarts) {
[10:22:43.999]                             name <- restart$name
[10:22:43.999]                             if (is.null(name)) 
[10:22:43.999]                               next
[10:22:43.999]                             if (!grepl(pattern, name)) 
[10:22:43.999]                               next
[10:22:43.999]                             invokeRestart(restart)
[10:22:43.999]                             muffled <- TRUE
[10:22:43.999]                             break
[10:22:43.999]                           }
[10:22:43.999]                         }
[10:22:43.999]                       }
[10:22:43.999]                       invisible(muffled)
[10:22:43.999]                     }
[10:22:43.999]                     muffleCondition(cond, pattern = "^muffle")
[10:22:43.999]                   }
[10:22:43.999]                 }
[10:22:43.999]                 else {
[10:22:43.999]                   if (TRUE) {
[10:22:43.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:43.999]                     {
[10:22:43.999]                       inherits <- base::inherits
[10:22:43.999]                       invokeRestart <- base::invokeRestart
[10:22:43.999]                       is.null <- base::is.null
[10:22:43.999]                       muffled <- FALSE
[10:22:43.999]                       if (inherits(cond, "message")) {
[10:22:43.999]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:43.999]                         if (muffled) 
[10:22:43.999]                           invokeRestart("muffleMessage")
[10:22:43.999]                       }
[10:22:43.999]                       else if (inherits(cond, "warning")) {
[10:22:43.999]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:43.999]                         if (muffled) 
[10:22:43.999]                           invokeRestart("muffleWarning")
[10:22:43.999]                       }
[10:22:43.999]                       else if (inherits(cond, "condition")) {
[10:22:43.999]                         if (!is.null(pattern)) {
[10:22:43.999]                           computeRestarts <- base::computeRestarts
[10:22:43.999]                           grepl <- base::grepl
[10:22:43.999]                           restarts <- computeRestarts(cond)
[10:22:43.999]                           for (restart in restarts) {
[10:22:43.999]                             name <- restart$name
[10:22:43.999]                             if (is.null(name)) 
[10:22:43.999]                               next
[10:22:43.999]                             if (!grepl(pattern, name)) 
[10:22:43.999]                               next
[10:22:43.999]                             invokeRestart(restart)
[10:22:43.999]                             muffled <- TRUE
[10:22:43.999]                             break
[10:22:43.999]                           }
[10:22:43.999]                         }
[10:22:43.999]                       }
[10:22:43.999]                       invisible(muffled)
[10:22:43.999]                     }
[10:22:43.999]                     muffleCondition(cond, pattern = "^muffle")
[10:22:43.999]                   }
[10:22:43.999]                 }
[10:22:43.999]             }
[10:22:43.999]         }))
[10:22:43.999]     }, error = function(ex) {
[10:22:43.999]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:43.999]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:43.999]                 ...future.rng), started = ...future.startTime, 
[10:22:43.999]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:43.999]             version = "1.8"), class = "FutureResult")
[10:22:43.999]     }, finally = {
[10:22:43.999]         if (!identical(...future.workdir, getwd())) 
[10:22:43.999]             setwd(...future.workdir)
[10:22:43.999]         {
[10:22:43.999]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:43.999]                 ...future.oldOptions$nwarnings <- NULL
[10:22:43.999]             }
[10:22:43.999]             base::options(...future.oldOptions)
[10:22:43.999]             if (.Platform$OS.type == "windows") {
[10:22:43.999]                 old_names <- names(...future.oldEnvVars)
[10:22:43.999]                 envs <- base::Sys.getenv()
[10:22:43.999]                 names <- names(envs)
[10:22:43.999]                 common <- intersect(names, old_names)
[10:22:43.999]                 added <- setdiff(names, old_names)
[10:22:43.999]                 removed <- setdiff(old_names, names)
[10:22:43.999]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:43.999]                   envs[common]]
[10:22:43.999]                 NAMES <- toupper(changed)
[10:22:43.999]                 args <- list()
[10:22:43.999]                 for (kk in seq_along(NAMES)) {
[10:22:43.999]                   name <- changed[[kk]]
[10:22:43.999]                   NAME <- NAMES[[kk]]
[10:22:43.999]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:43.999]                     next
[10:22:43.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:43.999]                 }
[10:22:43.999]                 NAMES <- toupper(added)
[10:22:43.999]                 for (kk in seq_along(NAMES)) {
[10:22:43.999]                   name <- added[[kk]]
[10:22:43.999]                   NAME <- NAMES[[kk]]
[10:22:43.999]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:43.999]                     next
[10:22:43.999]                   args[[name]] <- ""
[10:22:43.999]                 }
[10:22:43.999]                 NAMES <- toupper(removed)
[10:22:43.999]                 for (kk in seq_along(NAMES)) {
[10:22:43.999]                   name <- removed[[kk]]
[10:22:43.999]                   NAME <- NAMES[[kk]]
[10:22:43.999]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:43.999]                     next
[10:22:43.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:43.999]                 }
[10:22:43.999]                 if (length(args) > 0) 
[10:22:43.999]                   base::do.call(base::Sys.setenv, args = args)
[10:22:43.999]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:43.999]             }
[10:22:43.999]             else {
[10:22:43.999]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:43.999]             }
[10:22:43.999]             {
[10:22:43.999]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:43.999]                   0L) {
[10:22:43.999]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:43.999]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:43.999]                   base::options(opts)
[10:22:43.999]                 }
[10:22:43.999]                 {
[10:22:43.999]                   {
[10:22:43.999]                     NULL
[10:22:43.999]                     RNGkind("Mersenne-Twister")
[10:22:43.999]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:43.999]                       inherits = FALSE)
[10:22:43.999]                   }
[10:22:43.999]                   options(future.plan = NULL)
[10:22:43.999]                   if (is.na(NA_character_)) 
[10:22:43.999]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:43.999]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:43.999]                   future::plan(list(function (..., envir = parent.frame()) 
[10:22:43.999]                   {
[10:22:43.999]                     future <- SequentialFuture(..., envir = envir)
[10:22:43.999]                     if (!future$lazy) 
[10:22:43.999]                       future <- run(future)
[10:22:43.999]                     invisible(future)
[10:22:43.999]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:43.999]                 }
[10:22:43.999]             }
[10:22:43.999]         }
[10:22:43.999]     })
[10:22:43.999]     if (TRUE) {
[10:22:43.999]         base::sink(type = "output", split = FALSE)
[10:22:43.999]         if (TRUE) {
[10:22:43.999]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:43.999]         }
[10:22:43.999]         else {
[10:22:43.999]             ...future.result["stdout"] <- base::list(NULL)
[10:22:43.999]         }
[10:22:43.999]         base::close(...future.stdout)
[10:22:43.999]         ...future.stdout <- NULL
[10:22:43.999]     }
[10:22:43.999]     ...future.result$conditions <- ...future.conditions
[10:22:43.999]     ...future.result$finished <- base::Sys.time()
[10:22:43.999]     ...future.result
[10:22:43.999] }
[10:22:44.000] assign_globals() ...
[10:22:44.000] List of 5
[10:22:44.000]  $ future.call.arguments    : list()
[10:22:44.000]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.000]  $ ...future.FUN            :function (x)  
[10:22:44.000]  $ ...future.elements_ii    :List of 6
[10:22:44.000]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[10:22:44.000]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[10:22:44.000]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[10:22:44.000]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[10:22:44.000]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[10:22:44.000]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[10:22:44.000]  $ ...future.seeds_ii       : NULL
[10:22:44.000]  $ ...future.globals.maxSize: num Inf
[10:22:44.000]  - attr(*, "resolved")= logi FALSE
[10:22:44.000]  - attr(*, "total_size")= num NA
[10:22:44.000]  - attr(*, "where")=List of 5
[10:22:44.000]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:44.000]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:44.000]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:44.000]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:44.000]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:44.000]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.000]  - attr(*, "already-done")= logi TRUE
[10:22:44.007] - copied ‘future.call.arguments’ to environment
[10:22:44.007] - copied ‘...future.FUN’ to environment
[10:22:44.007] - copied ‘...future.elements_ii’ to environment
[10:22:44.007] - copied ‘...future.seeds_ii’ to environment
[10:22:44.008] - copied ‘...future.globals.maxSize’ to environment
[10:22:44.008] assign_globals() ... done
[10:22:44.008] plan(): Setting new future strategy stack:
[10:22:44.008] List of future strategies:
[10:22:44.008] 1. sequential:
[10:22:44.008]    - args: function (..., envir = parent.frame())
[10:22:44.008]    - tweaked: FALSE
[10:22:44.008]    - call: NULL
[10:22:44.008] plan(): nbrOfWorkers() = 1
[10:22:44.009] plan(): Setting new future strategy stack:
[10:22:44.009] List of future strategies:
[10:22:44.009] 1. sequential:
[10:22:44.009]    - args: function (..., envir = parent.frame())
[10:22:44.009]    - tweaked: FALSE
[10:22:44.009]    - call: plan(strategy)
[10:22:44.009] plan(): nbrOfWorkers() = 1
[10:22:44.010] SequentialFuture started (and completed)
[10:22:44.010] - Launch lazy future ... done
[10:22:44.010] run() for ‘SequentialFuture’ ... done
[10:22:44.010] Created future:
[10:22:44.010] SequentialFuture:
[10:22:44.010] Label: ‘future_apply-1’
[10:22:44.010] Expression:
[10:22:44.010] {
[10:22:44.010]     do.call(function(...) {
[10:22:44.010]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.010]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:44.010]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.010]             on.exit(options(oopts), add = TRUE)
[10:22:44.010]         }
[10:22:44.010]         {
[10:22:44.010]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:44.010]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.010]                 ...future.FUN(...future.X_jj, ...)
[10:22:44.010]             })
[10:22:44.010]         }
[10:22:44.010]     }, args = future.call.arguments)
[10:22:44.010] }
[10:22:44.010] Lazy evaluation: FALSE
[10:22:44.010] Asynchronous evaluation: FALSE
[10:22:44.010] Local evaluation: TRUE
[10:22:44.010] Environment: R_GlobalEnv
[10:22:44.010] Capture standard output: TRUE
[10:22:44.010] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:44.010] Globals: 5 objects totaling 1.54 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 672 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:44.010] Packages: <none>
[10:22:44.010] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:44.010] Resolved: TRUE
[10:22:44.010] Value: 672 bytes of class ‘list’
[10:22:44.010] Early signaling: FALSE
[10:22:44.010] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:44.010] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:44.011] Chunk #1 of 1 ... DONE
[10:22:44.011] Launching 1 futures (chunks) ... DONE
[10:22:44.011] Resolving 1 futures (chunks) ...
[10:22:44.011] resolve() on list ...
[10:22:44.011]  recursive: 0
[10:22:44.011]  length: 1
[10:22:44.011] 
[10:22:44.012] resolved() for ‘SequentialFuture’ ...
[10:22:44.012] - state: ‘finished’
[10:22:44.012] - run: TRUE
[10:22:44.012] - result: ‘FutureResult’
[10:22:44.012] resolved() for ‘SequentialFuture’ ... done
[10:22:44.012] Future #1
[10:22:44.012] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:44.012] - nx: 1
[10:22:44.012] - relay: TRUE
[10:22:44.012] - stdout: TRUE
[10:22:44.012] - signal: TRUE
[10:22:44.013] - resignal: FALSE
[10:22:44.013] - force: TRUE
[10:22:44.013] - relayed: [n=1] FALSE
[10:22:44.013] - queued futures: [n=1] FALSE
[10:22:44.013]  - until=1
[10:22:44.013]  - relaying element #1
[10:22:44.013] - relayed: [n=1] TRUE
[10:22:44.013] - queued futures: [n=1] TRUE
[10:22:44.013] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:44.013]  length: 0 (resolved future 1)
[10:22:44.013] Relaying remaining futures
[10:22:44.014] signalConditionsASAP(NULL, pos=0) ...
[10:22:44.014] - nx: 1
[10:22:44.014] - relay: TRUE
[10:22:44.014] - stdout: TRUE
[10:22:44.014] - signal: TRUE
[10:22:44.014] - resignal: FALSE
[10:22:44.014] - force: TRUE
[10:22:44.014] - relayed: [n=1] TRUE
[10:22:44.014] - queued futures: [n=1] TRUE
 - flush all
[10:22:44.014] - relayed: [n=1] TRUE
[10:22:44.014] - queued futures: [n=1] TRUE
[10:22:44.014] signalConditionsASAP(NULL, pos=0) ... done
[10:22:44.015] resolve() on list ... DONE
[10:22:44.015]  - Number of value chunks collected: 1
[10:22:44.015] Resolving 1 futures (chunks) ... DONE
[10:22:44.015] Reducing values from 1 chunks ...
[10:22:44.015]  - Number of values collected after concatenation: 6
[10:22:44.015]  - Number of values expected: 6
[10:22:44.015] Reducing values from 1 chunks ... DONE
[10:22:44.015] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[10:22:44.016] getGlobalsAndPackagesXApply() ...
[10:22:44.016]  - future.globals: TRUE
[10:22:44.016] getGlobalsAndPackages() ...
[10:22:44.016] Searching for globals...
[10:22:44.017] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[10:22:44.017] Searching for globals ... DONE
[10:22:44.017] Resolving globals: FALSE
[10:22:44.018] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[10:22:44.018] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[10:22:44.018] - globals: [1] ‘FUN’
[10:22:44.018] 
[10:22:44.018] getGlobalsAndPackages() ... DONE
[10:22:44.018]  - globals found/used: [n=1] ‘FUN’
[10:22:44.018]  - needed namespaces: [n=0] 
[10:22:44.018] Finding globals ... DONE
[10:22:44.019]  - use_args: TRUE
[10:22:44.019]  - Getting '...' globals ...
[10:22:44.019] resolve() on list ...
[10:22:44.019]  recursive: 0
[10:22:44.019]  length: 1
[10:22:44.019]  elements: ‘...’
[10:22:44.019]  length: 0 (resolved future 1)
[10:22:44.019] resolve() on list ... DONE
[10:22:44.019]    - '...' content: [n=0] 
[10:22:44.020] List of 1
[10:22:44.020]  $ ...: list()
[10:22:44.020]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.020]  - attr(*, "where")=List of 1
[10:22:44.020]   ..$ ...:<environment: 0x55ca4cc52f40> 
[10:22:44.020]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.020]  - attr(*, "resolved")= logi TRUE
[10:22:44.020]  - attr(*, "total_size")= num NA
[10:22:44.022]  - Getting '...' globals ... DONE
[10:22:44.022] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:44.022] List of 2
[10:22:44.022]  $ ...future.FUN:function (x)  
[10:22:44.022]  $ ...          : list()
[10:22:44.022]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.022]  - attr(*, "where")=List of 2
[10:22:44.022]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:44.022]   ..$ ...          :<environment: 0x55ca4cc52f40> 
[10:22:44.022]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.022]  - attr(*, "resolved")= logi FALSE
[10:22:44.022]  - attr(*, "total_size")= num 1768
[10:22:44.025] Packages to be attached in all futures: [n=0] 
[10:22:44.026] getGlobalsAndPackagesXApply() ... DONE
[10:22:44.026] future_lapply() ...
[10:22:44.026] Number of chunks: 1
[10:22:44.026] getGlobalsAndPackagesXApply() ...
[10:22:44.027]  - future.globals: <name-value list> with names ‘list()’
[10:22:44.027]  - use_args: TRUE
[10:22:44.027] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:22:44.027] List of 2
[10:22:44.027]  $ ...          : list()
[10:22:44.027]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.027]  $ ...future.FUN:function (x)  
[10:22:44.027]  - attr(*, "where")=List of 2
[10:22:44.027]   ..$ ...          :<environment: 0x55ca4cc52f40> 
[10:22:44.027]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[10:22:44.027]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.027]  - attr(*, "resolved")= logi FALSE
[10:22:44.027]  - attr(*, "total_size")= num NA
[10:22:44.029] Packages to be attached in all futures: [n=0] 
[10:22:44.030] getGlobalsAndPackagesXApply() ... DONE
[10:22:44.030] Number of futures (= number of chunks): 1
[10:22:44.030] Launching 1 futures (chunks) ...
[10:22:44.030] Chunk #1 of 1 ...
[10:22:44.030]  - seeds: <none>
[10:22:44.030]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.030] getGlobalsAndPackages() ...
[10:22:44.030] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.030] Resolving globals: FALSE
[10:22:44.031] Tweak future expression to call with '...' arguments ...
[10:22:44.031] {
[10:22:44.031]     do.call(function(...) {
[10:22:44.031]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.031]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:44.031]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.031]             on.exit(options(oopts), add = TRUE)
[10:22:44.031]         }
[10:22:44.031]         {
[10:22:44.031]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:44.031]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.031]                 ...future.FUN(...future.X_jj, ...)
[10:22:44.031]             })
[10:22:44.031]         }
[10:22:44.031]     }, args = future.call.arguments)
[10:22:44.031] }
[10:22:44.031] Tweak future expression to call with '...' arguments ... DONE
[10:22:44.031] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.031] 
[10:22:44.031] getGlobalsAndPackages() ... DONE
[10:22:44.032] run() for ‘Future’ ...
[10:22:44.032] - state: ‘created’
[10:22:44.032] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:44.032] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:44.032] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:44.032]   - Field: ‘label’
[10:22:44.032]   - Field: ‘local’
[10:22:44.033]   - Field: ‘owner’
[10:22:44.033]   - Field: ‘envir’
[10:22:44.033]   - Field: ‘packages’
[10:22:44.033]   - Field: ‘gc’
[10:22:44.033]   - Field: ‘conditions’
[10:22:44.033]   - Field: ‘expr’
[10:22:44.033]   - Field: ‘uuid’
[10:22:44.033]   - Field: ‘seed’
[10:22:44.033]   - Field: ‘version’
[10:22:44.033]   - Field: ‘result’
[10:22:44.033]   - Field: ‘asynchronous’
[10:22:44.034]   - Field: ‘calls’
[10:22:44.034]   - Field: ‘globals’
[10:22:44.034]   - Field: ‘stdout’
[10:22:44.034]   - Field: ‘earlySignal’
[10:22:44.034]   - Field: ‘lazy’
[10:22:44.034]   - Field: ‘state’
[10:22:44.034] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:44.034] - Launch lazy future ...
[10:22:44.034] Packages needed by the future expression (n = 0): <none>
[10:22:44.034] Packages needed by future strategies (n = 0): <none>
[10:22:44.035] {
[10:22:44.035]     {
[10:22:44.035]         {
[10:22:44.035]             ...future.startTime <- base::Sys.time()
[10:22:44.035]             {
[10:22:44.035]                 {
[10:22:44.035]                   {
[10:22:44.035]                     base::local({
[10:22:44.035]                       has_future <- base::requireNamespace("future", 
[10:22:44.035]                         quietly = TRUE)
[10:22:44.035]                       if (has_future) {
[10:22:44.035]                         ns <- base::getNamespace("future")
[10:22:44.035]                         version <- ns[[".package"]][["version"]]
[10:22:44.035]                         if (is.null(version)) 
[10:22:44.035]                           version <- utils::packageVersion("future")
[10:22:44.035]                       }
[10:22:44.035]                       else {
[10:22:44.035]                         version <- NULL
[10:22:44.035]                       }
[10:22:44.035]                       if (!has_future || version < "1.8.0") {
[10:22:44.035]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:44.035]                           "", base::R.version$version.string), 
[10:22:44.035]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:44.035]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:44.035]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:44.035]                             "release", "version")], collapse = " "), 
[10:22:44.035]                           hostname = base::Sys.info()[["nodename"]])
[10:22:44.035]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:44.035]                           info)
[10:22:44.035]                         info <- base::paste(info, collapse = "; ")
[10:22:44.035]                         if (!has_future) {
[10:22:44.035]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:44.035]                             info)
[10:22:44.035]                         }
[10:22:44.035]                         else {
[10:22:44.035]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:44.035]                             info, version)
[10:22:44.035]                         }
[10:22:44.035]                         base::stop(msg)
[10:22:44.035]                       }
[10:22:44.035]                     })
[10:22:44.035]                   }
[10:22:44.035]                   options(future.plan = NULL)
[10:22:44.035]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.035]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:44.035]                 }
[10:22:44.035]                 ...future.workdir <- getwd()
[10:22:44.035]             }
[10:22:44.035]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:44.035]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:44.035]         }
[10:22:44.035]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:44.035]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:44.035]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:44.035]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:44.035]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:44.035]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:44.035]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:44.035]             base::names(...future.oldOptions))
[10:22:44.035]     }
[10:22:44.035]     if (FALSE) {
[10:22:44.035]     }
[10:22:44.035]     else {
[10:22:44.035]         if (TRUE) {
[10:22:44.035]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:44.035]                 open = "w")
[10:22:44.035]         }
[10:22:44.035]         else {
[10:22:44.035]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:44.035]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:44.035]         }
[10:22:44.035]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:44.035]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:44.035]             base::sink(type = "output", split = FALSE)
[10:22:44.035]             base::close(...future.stdout)
[10:22:44.035]         }, add = TRUE)
[10:22:44.035]     }
[10:22:44.035]     ...future.frame <- base::sys.nframe()
[10:22:44.035]     ...future.conditions <- base::list()
[10:22:44.035]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:44.035]     if (FALSE) {
[10:22:44.035]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:44.035]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:44.035]     }
[10:22:44.035]     ...future.result <- base::tryCatch({
[10:22:44.035]         base::withCallingHandlers({
[10:22:44.035]             ...future.value <- base::withVisible(base::local({
[10:22:44.035]                 do.call(function(...) {
[10:22:44.035]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.035]                   if (!identical(...future.globals.maxSize.org, 
[10:22:44.035]                     ...future.globals.maxSize)) {
[10:22:44.035]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.035]                     on.exit(options(oopts), add = TRUE)
[10:22:44.035]                   }
[10:22:44.035]                   {
[10:22:44.035]                     lapply(seq_along(...future.elements_ii), 
[10:22:44.035]                       FUN = function(jj) {
[10:22:44.035]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.035]                         ...future.FUN(...future.X_jj, ...)
[10:22:44.035]                       })
[10:22:44.035]                   }
[10:22:44.035]                 }, args = future.call.arguments)
[10:22:44.035]             }))
[10:22:44.035]             future::FutureResult(value = ...future.value$value, 
[10:22:44.035]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.035]                   ...future.rng), globalenv = if (FALSE) 
[10:22:44.035]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:44.035]                     ...future.globalenv.names))
[10:22:44.035]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:44.035]         }, condition = base::local({
[10:22:44.035]             c <- base::c
[10:22:44.035]             inherits <- base::inherits
[10:22:44.035]             invokeRestart <- base::invokeRestart
[10:22:44.035]             length <- base::length
[10:22:44.035]             list <- base::list
[10:22:44.035]             seq.int <- base::seq.int
[10:22:44.035]             signalCondition <- base::signalCondition
[10:22:44.035]             sys.calls <- base::sys.calls
[10:22:44.035]             `[[` <- base::`[[`
[10:22:44.035]             `+` <- base::`+`
[10:22:44.035]             `<<-` <- base::`<<-`
[10:22:44.035]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:44.035]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:44.035]                   3L)]
[10:22:44.035]             }
[10:22:44.035]             function(cond) {
[10:22:44.035]                 is_error <- inherits(cond, "error")
[10:22:44.035]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:44.035]                   NULL)
[10:22:44.035]                 if (is_error) {
[10:22:44.035]                   sessionInformation <- function() {
[10:22:44.035]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:44.035]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:44.035]                       search = base::search(), system = base::Sys.info())
[10:22:44.035]                   }
[10:22:44.035]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.035]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:44.035]                     cond$call), session = sessionInformation(), 
[10:22:44.035]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:44.035]                   signalCondition(cond)
[10:22:44.035]                 }
[10:22:44.035]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:44.035]                 "immediateCondition"))) {
[10:22:44.035]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:44.035]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.035]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:44.035]                   if (TRUE && !signal) {
[10:22:44.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.035]                     {
[10:22:44.035]                       inherits <- base::inherits
[10:22:44.035]                       invokeRestart <- base::invokeRestart
[10:22:44.035]                       is.null <- base::is.null
[10:22:44.035]                       muffled <- FALSE
[10:22:44.035]                       if (inherits(cond, "message")) {
[10:22:44.035]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.035]                         if (muffled) 
[10:22:44.035]                           invokeRestart("muffleMessage")
[10:22:44.035]                       }
[10:22:44.035]                       else if (inherits(cond, "warning")) {
[10:22:44.035]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.035]                         if (muffled) 
[10:22:44.035]                           invokeRestart("muffleWarning")
[10:22:44.035]                       }
[10:22:44.035]                       else if (inherits(cond, "condition")) {
[10:22:44.035]                         if (!is.null(pattern)) {
[10:22:44.035]                           computeRestarts <- base::computeRestarts
[10:22:44.035]                           grepl <- base::grepl
[10:22:44.035]                           restarts <- computeRestarts(cond)
[10:22:44.035]                           for (restart in restarts) {
[10:22:44.035]                             name <- restart$name
[10:22:44.035]                             if (is.null(name)) 
[10:22:44.035]                               next
[10:22:44.035]                             if (!grepl(pattern, name)) 
[10:22:44.035]                               next
[10:22:44.035]                             invokeRestart(restart)
[10:22:44.035]                             muffled <- TRUE
[10:22:44.035]                             break
[10:22:44.035]                           }
[10:22:44.035]                         }
[10:22:44.035]                       }
[10:22:44.035]                       invisible(muffled)
[10:22:44.035]                     }
[10:22:44.035]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.035]                   }
[10:22:44.035]                 }
[10:22:44.035]                 else {
[10:22:44.035]                   if (TRUE) {
[10:22:44.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.035]                     {
[10:22:44.035]                       inherits <- base::inherits
[10:22:44.035]                       invokeRestart <- base::invokeRestart
[10:22:44.035]                       is.null <- base::is.null
[10:22:44.035]                       muffled <- FALSE
[10:22:44.035]                       if (inherits(cond, "message")) {
[10:22:44.035]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.035]                         if (muffled) 
[10:22:44.035]                           invokeRestart("muffleMessage")
[10:22:44.035]                       }
[10:22:44.035]                       else if (inherits(cond, "warning")) {
[10:22:44.035]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.035]                         if (muffled) 
[10:22:44.035]                           invokeRestart("muffleWarning")
[10:22:44.035]                       }
[10:22:44.035]                       else if (inherits(cond, "condition")) {
[10:22:44.035]                         if (!is.null(pattern)) {
[10:22:44.035]                           computeRestarts <- base::computeRestarts
[10:22:44.035]                           grepl <- base::grepl
[10:22:44.035]                           restarts <- computeRestarts(cond)
[10:22:44.035]                           for (restart in restarts) {
[10:22:44.035]                             name <- restart$name
[10:22:44.035]                             if (is.null(name)) 
[10:22:44.035]                               next
[10:22:44.035]                             if (!grepl(pattern, name)) 
[10:22:44.035]                               next
[10:22:44.035]                             invokeRestart(restart)
[10:22:44.035]                             muffled <- TRUE
[10:22:44.035]                             break
[10:22:44.035]                           }
[10:22:44.035]                         }
[10:22:44.035]                       }
[10:22:44.035]                       invisible(muffled)
[10:22:44.035]                     }
[10:22:44.035]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.035]                   }
[10:22:44.035]                 }
[10:22:44.035]             }
[10:22:44.035]         }))
[10:22:44.035]     }, error = function(ex) {
[10:22:44.035]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:44.035]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.035]                 ...future.rng), started = ...future.startTime, 
[10:22:44.035]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:44.035]             version = "1.8"), class = "FutureResult")
[10:22:44.035]     }, finally = {
[10:22:44.035]         if (!identical(...future.workdir, getwd())) 
[10:22:44.035]             setwd(...future.workdir)
[10:22:44.035]         {
[10:22:44.035]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:44.035]                 ...future.oldOptions$nwarnings <- NULL
[10:22:44.035]             }
[10:22:44.035]             base::options(...future.oldOptions)
[10:22:44.035]             if (.Platform$OS.type == "windows") {
[10:22:44.035]                 old_names <- names(...future.oldEnvVars)
[10:22:44.035]                 envs <- base::Sys.getenv()
[10:22:44.035]                 names <- names(envs)
[10:22:44.035]                 common <- intersect(names, old_names)
[10:22:44.035]                 added <- setdiff(names, old_names)
[10:22:44.035]                 removed <- setdiff(old_names, names)
[10:22:44.035]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:44.035]                   envs[common]]
[10:22:44.035]                 NAMES <- toupper(changed)
[10:22:44.035]                 args <- list()
[10:22:44.035]                 for (kk in seq_along(NAMES)) {
[10:22:44.035]                   name <- changed[[kk]]
[10:22:44.035]                   NAME <- NAMES[[kk]]
[10:22:44.035]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.035]                     next
[10:22:44.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.035]                 }
[10:22:44.035]                 NAMES <- toupper(added)
[10:22:44.035]                 for (kk in seq_along(NAMES)) {
[10:22:44.035]                   name <- added[[kk]]
[10:22:44.035]                   NAME <- NAMES[[kk]]
[10:22:44.035]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.035]                     next
[10:22:44.035]                   args[[name]] <- ""
[10:22:44.035]                 }
[10:22:44.035]                 NAMES <- toupper(removed)
[10:22:44.035]                 for (kk in seq_along(NAMES)) {
[10:22:44.035]                   name <- removed[[kk]]
[10:22:44.035]                   NAME <- NAMES[[kk]]
[10:22:44.035]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.035]                     next
[10:22:44.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.035]                 }
[10:22:44.035]                 if (length(args) > 0) 
[10:22:44.035]                   base::do.call(base::Sys.setenv, args = args)
[10:22:44.035]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:44.035]             }
[10:22:44.035]             else {
[10:22:44.035]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:44.035]             }
[10:22:44.035]             {
[10:22:44.035]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:44.035]                   0L) {
[10:22:44.035]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:44.035]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:44.035]                   base::options(opts)
[10:22:44.035]                 }
[10:22:44.035]                 {
[10:22:44.035]                   {
[10:22:44.035]                     NULL
[10:22:44.035]                     RNGkind("Mersenne-Twister")
[10:22:44.035]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:44.035]                       inherits = FALSE)
[10:22:44.035]                   }
[10:22:44.035]                   options(future.plan = NULL)
[10:22:44.035]                   if (is.na(NA_character_)) 
[10:22:44.035]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.035]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:44.035]                   future::plan(list(function (..., envir = parent.frame()) 
[10:22:44.035]                   {
[10:22:44.035]                     future <- SequentialFuture(..., envir = envir)
[10:22:44.035]                     if (!future$lazy) 
[10:22:44.035]                       future <- run(future)
[10:22:44.035]                     invisible(future)
[10:22:44.035]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:44.035]                 }
[10:22:44.035]             }
[10:22:44.035]         }
[10:22:44.035]     })
[10:22:44.035]     if (TRUE) {
[10:22:44.035]         base::sink(type = "output", split = FALSE)
[10:22:44.035]         if (TRUE) {
[10:22:44.035]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:44.035]         }
[10:22:44.035]         else {
[10:22:44.035]             ...future.result["stdout"] <- base::list(NULL)
[10:22:44.035]         }
[10:22:44.035]         base::close(...future.stdout)
[10:22:44.035]         ...future.stdout <- NULL
[10:22:44.035]     }
[10:22:44.035]     ...future.result$conditions <- ...future.conditions
[10:22:44.035]     ...future.result$finished <- base::Sys.time()
[10:22:44.035]     ...future.result
[10:22:44.035] }
[10:22:44.037] assign_globals() ...
[10:22:44.037] List of 5
[10:22:44.037]  $ future.call.arguments    : list()
[10:22:44.037]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.037]  $ ...future.FUN            :function (x)  
[10:22:44.037]  $ ...future.elements_ii    :List of 6
[10:22:44.037]   ..$ : int [1:4] 1 7 13 19
[10:22:44.037]   ..$ : int [1:4] 2 8 14 20
[10:22:44.037]   ..$ : int [1:4] 3 9 15 21
[10:22:44.037]   ..$ : int [1:4] 4 10 16 22
[10:22:44.037]   ..$ : int [1:4] 5 11 17 23
[10:22:44.037]   ..$ : int [1:4] 6 12 18 24
[10:22:44.037]  $ ...future.seeds_ii       : NULL
[10:22:44.037]  $ ...future.globals.maxSize: num Inf
[10:22:44.037]  - attr(*, "resolved")= logi FALSE
[10:22:44.037]  - attr(*, "total_size")= num NA
[10:22:44.037]  - attr(*, "where")=List of 5
[10:22:44.037]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:44.037]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:44.037]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:44.037]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:44.037]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:44.037]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.037]  - attr(*, "already-done")= logi TRUE
[10:22:44.043] - copied ‘future.call.arguments’ to environment
[10:22:44.043] - reassign environment for ‘...future.FUN’
[10:22:44.043] - copied ‘...future.FUN’ to environment
[10:22:44.043] - copied ‘...future.elements_ii’ to environment
[10:22:44.043] - copied ‘...future.seeds_ii’ to environment
[10:22:44.043] - copied ‘...future.globals.maxSize’ to environment
[10:22:44.043] assign_globals() ... done
[10:22:44.044] plan(): Setting new future strategy stack:
[10:22:44.044] List of future strategies:
[10:22:44.044] 1. sequential:
[10:22:44.044]    - args: function (..., envir = parent.frame())
[10:22:44.044]    - tweaked: FALSE
[10:22:44.044]    - call: NULL
[10:22:44.044] plan(): nbrOfWorkers() = 1
[10:22:44.045] plan(): Setting new future strategy stack:
[10:22:44.045] List of future strategies:
[10:22:44.045] 1. sequential:
[10:22:44.045]    - args: function (..., envir = parent.frame())
[10:22:44.045]    - tweaked: FALSE
[10:22:44.045]    - call: plan(strategy)
[10:22:44.045] plan(): nbrOfWorkers() = 1
[10:22:44.045] SequentialFuture started (and completed)
[10:22:44.046] - Launch lazy future ... done
[10:22:44.046] run() for ‘SequentialFuture’ ... done
[10:22:44.046] Created future:
[10:22:44.046] SequentialFuture:
[10:22:44.046] Label: ‘future_apply-1’
[10:22:44.046] Expression:
[10:22:44.046] {
[10:22:44.046]     do.call(function(...) {
[10:22:44.046]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.046]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:44.046]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.046]             on.exit(options(oopts), add = TRUE)
[10:22:44.046]         }
[10:22:44.046]         {
[10:22:44.046]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:44.046]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.046]                 ...future.FUN(...future.X_jj, ...)
[10:22:44.046]             })
[10:22:44.046]         }
[10:22:44.046]     }, args = future.call.arguments)
[10:22:44.046] }
[10:22:44.046] Lazy evaluation: FALSE
[10:22:44.046] Asynchronous evaluation: FALSE
[10:22:44.046] Local evaluation: TRUE
[10:22:44.046] Environment: R_GlobalEnv
[10:22:44.046] Capture standard output: TRUE
[10:22:44.046] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:44.046] Globals: 5 objects totaling 2.16 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 384 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:44.046] Packages: <none>
[10:22:44.046] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:44.046] Resolved: TRUE
[10:22:44.046] Value: 1.03 KiB of class ‘list’
[10:22:44.046] Early signaling: FALSE
[10:22:44.046] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:44.046] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:44.076] Chunk #1 of 1 ... DONE
[10:22:44.077] Launching 1 futures (chunks) ... DONE
[10:22:44.077] Resolving 1 futures (chunks) ...
[10:22:44.077] resolve() on list ...
[10:22:44.077]  recursive: 0
[10:22:44.077]  length: 1
[10:22:44.077] 
[10:22:44.077] resolved() for ‘SequentialFuture’ ...
[10:22:44.077] - state: ‘finished’
[10:22:44.078] - run: TRUE
[10:22:44.078] - result: ‘FutureResult’
[10:22:44.078] resolved() for ‘SequentialFuture’ ... done
[10:22:44.078] Future #1
[10:22:44.078] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:44.078] - nx: 1
[10:22:44.078] - relay: TRUE
[10:22:44.078] - stdout: TRUE
[10:22:44.078] - signal: TRUE
[10:22:44.078] - resignal: FALSE
[10:22:44.079] - force: TRUE
[10:22:44.079] - relayed: [n=1] FALSE
[10:22:44.079] - queued futures: [n=1] FALSE
[10:22:44.079]  - until=1
[10:22:44.079]  - relaying element #1
[10:22:44.079] - relayed: [n=1] TRUE
[10:22:44.079] - queued futures: [n=1] TRUE
[10:22:44.079] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:44.079]  length: 0 (resolved future 1)
[10:22:44.079] Relaying remaining futures
[10:22:44.080] signalConditionsASAP(NULL, pos=0) ...
[10:22:44.080] - nx: 1
[10:22:44.080] - relay: TRUE
[10:22:44.080] - stdout: TRUE
[10:22:44.080] - signal: TRUE
[10:22:44.080] - resignal: FALSE
[10:22:44.080] - force: TRUE
[10:22:44.080] - relayed: [n=1] TRUE
[10:22:44.080] - queued futures: [n=1] TRUE
 - flush all
[10:22:44.080] - relayed: [n=1] TRUE
[10:22:44.080] - queued futures: [n=1] TRUE
[10:22:44.081] signalConditionsASAP(NULL, pos=0) ... done
[10:22:44.081] resolve() on list ... DONE
[10:22:44.081]  - Number of value chunks collected: 1
[10:22:44.081] Resolving 1 futures (chunks) ... DONE
[10:22:44.081] Reducing values from 1 chunks ...
[10:22:44.081]  - Number of values collected after concatenation: 6
[10:22:44.081]  - Number of values expected: 6
[10:22:44.081] Reducing values from 1 chunks ... DONE
[10:22:44.081] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[10:22:44.082] getGlobalsAndPackagesXApply() ...
[10:22:44.082]  - future.globals: TRUE
[10:22:44.082] getGlobalsAndPackages() ...
[10:22:44.082] Searching for globals...
[10:22:44.083] - globals found: [1] ‘FUN’
[10:22:44.083] Searching for globals ... DONE
[10:22:44.083] Resolving globals: FALSE
[10:22:44.083] The total size of the 1 globals is 848 bytes (848 bytes)
[10:22:44.084] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:22:44.084] - globals: [1] ‘FUN’
[10:22:44.084] 
[10:22:44.084] getGlobalsAndPackages() ... DONE
[10:22:44.084]  - globals found/used: [n=1] ‘FUN’
[10:22:44.084]  - needed namespaces: [n=0] 
[10:22:44.084] Finding globals ... DONE
[10:22:44.084]  - use_args: TRUE
[10:22:44.084]  - Getting '...' globals ...
[10:22:44.085] resolve() on list ...
[10:22:44.085]  recursive: 0
[10:22:44.085]  length: 1
[10:22:44.085]  elements: ‘...’
[10:22:44.085]  length: 0 (resolved future 1)
[10:22:44.085] resolve() on list ... DONE
[10:22:44.085]    - '...' content: [n=0] 
[10:22:44.085] List of 1
[10:22:44.085]  $ ...: list()
[10:22:44.085]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.085]  - attr(*, "where")=List of 1
[10:22:44.085]   ..$ ...:<environment: 0x55ca4b1e3a90> 
[10:22:44.085]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.085]  - attr(*, "resolved")= logi TRUE
[10:22:44.085]  - attr(*, "total_size")= num NA
[10:22:44.088]  - Getting '...' globals ... DONE
[10:22:44.088] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:44.088] List of 2
[10:22:44.088]  $ ...future.FUN:function (x)  
[10:22:44.088]  $ ...          : list()
[10:22:44.088]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.088]  - attr(*, "where")=List of 2
[10:22:44.088]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:44.088]   ..$ ...          :<environment: 0x55ca4b1e3a90> 
[10:22:44.088]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.088]  - attr(*, "resolved")= logi FALSE
[10:22:44.088]  - attr(*, "total_size")= num 848
[10:22:44.091] Packages to be attached in all futures: [n=0] 
[10:22:44.091] getGlobalsAndPackagesXApply() ... DONE
[10:22:44.091] future_lapply() ...
[10:22:44.092] Number of chunks: 1
[10:22:44.092] getGlobalsAndPackagesXApply() ...
[10:22:44.092]  - future.globals: <name-value list> with names ‘list()’
[10:22:44.092]  - use_args: TRUE
[10:22:44.092] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:22:44.092] List of 2
[10:22:44.092]  $ ...          : list()
[10:22:44.092]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.092]  $ ...future.FUN:function (x)  
[10:22:44.092]  - attr(*, "where")=List of 2
[10:22:44.092]   ..$ ...          :<environment: 0x55ca4b1e3a90> 
[10:22:44.092]   ..$ ...future.FUN:<environment: namespace:base> 
[10:22:44.092]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.092]  - attr(*, "resolved")= logi FALSE
[10:22:44.092]  - attr(*, "total_size")= num NA
[10:22:44.095] Packages to be attached in all futures: [n=0] 
[10:22:44.096] getGlobalsAndPackagesXApply() ... DONE
[10:22:44.096] Number of futures (= number of chunks): 1
[10:22:44.096] Launching 1 futures (chunks) ...
[10:22:44.096] Chunk #1 of 1 ...
[10:22:44.096]  - seeds: <none>
[10:22:44.096]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.096] getGlobalsAndPackages() ...
[10:22:44.096] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.096] Resolving globals: FALSE
[10:22:44.097] Tweak future expression to call with '...' arguments ...
[10:22:44.097] {
[10:22:44.097]     do.call(function(...) {
[10:22:44.097]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.097]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:44.097]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.097]             on.exit(options(oopts), add = TRUE)
[10:22:44.097]         }
[10:22:44.097]         {
[10:22:44.097]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:44.097]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.097]                 ...future.FUN(...future.X_jj, ...)
[10:22:44.097]             })
[10:22:44.097]         }
[10:22:44.097]     }, args = future.call.arguments)
[10:22:44.097] }
[10:22:44.097] Tweak future expression to call with '...' arguments ... DONE
[10:22:44.097] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.097] 
[10:22:44.098] getGlobalsAndPackages() ... DONE
[10:22:44.098] run() for ‘Future’ ...
[10:22:44.098] - state: ‘created’
[10:22:44.098] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:44.098] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:44.098] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:44.099]   - Field: ‘label’
[10:22:44.099]   - Field: ‘local’
[10:22:44.100]   - Field: ‘owner’
[10:22:44.100]   - Field: ‘envir’
[10:22:44.100]   - Field: ‘packages’
[10:22:44.100]   - Field: ‘gc’
[10:22:44.100]   - Field: ‘conditions’
[10:22:44.100]   - Field: ‘expr’
[10:22:44.100]   - Field: ‘uuid’
[10:22:44.100]   - Field: ‘seed’
[10:22:44.100]   - Field: ‘version’
[10:22:44.101]   - Field: ‘result’
[10:22:44.101]   - Field: ‘asynchronous’
[10:22:44.101]   - Field: ‘calls’
[10:22:44.101]   - Field: ‘globals’
[10:22:44.101]   - Field: ‘stdout’
[10:22:44.101]   - Field: ‘earlySignal’
[10:22:44.101]   - Field: ‘lazy’
[10:22:44.101]   - Field: ‘state’
[10:22:44.101] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:44.101] - Launch lazy future ...
[10:22:44.102] Packages needed by the future expression (n = 0): <none>
[10:22:44.102] Packages needed by future strategies (n = 0): <none>
[10:22:44.102] {
[10:22:44.102]     {
[10:22:44.102]         {
[10:22:44.102]             ...future.startTime <- base::Sys.time()
[10:22:44.102]             {
[10:22:44.102]                 {
[10:22:44.102]                   {
[10:22:44.102]                     base::local({
[10:22:44.102]                       has_future <- base::requireNamespace("future", 
[10:22:44.102]                         quietly = TRUE)
[10:22:44.102]                       if (has_future) {
[10:22:44.102]                         ns <- base::getNamespace("future")
[10:22:44.102]                         version <- ns[[".package"]][["version"]]
[10:22:44.102]                         if (is.null(version)) 
[10:22:44.102]                           version <- utils::packageVersion("future")
[10:22:44.102]                       }
[10:22:44.102]                       else {
[10:22:44.102]                         version <- NULL
[10:22:44.102]                       }
[10:22:44.102]                       if (!has_future || version < "1.8.0") {
[10:22:44.102]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:44.102]                           "", base::R.version$version.string), 
[10:22:44.102]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:44.102]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:44.102]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:44.102]                             "release", "version")], collapse = " "), 
[10:22:44.102]                           hostname = base::Sys.info()[["nodename"]])
[10:22:44.102]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:44.102]                           info)
[10:22:44.102]                         info <- base::paste(info, collapse = "; ")
[10:22:44.102]                         if (!has_future) {
[10:22:44.102]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:44.102]                             info)
[10:22:44.102]                         }
[10:22:44.102]                         else {
[10:22:44.102]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:44.102]                             info, version)
[10:22:44.102]                         }
[10:22:44.102]                         base::stop(msg)
[10:22:44.102]                       }
[10:22:44.102]                     })
[10:22:44.102]                   }
[10:22:44.102]                   options(future.plan = NULL)
[10:22:44.102]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.102]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:44.102]                 }
[10:22:44.102]                 ...future.workdir <- getwd()
[10:22:44.102]             }
[10:22:44.102]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:44.102]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:44.102]         }
[10:22:44.102]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:44.102]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:44.102]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:44.102]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:44.102]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:44.102]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:44.102]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:44.102]             base::names(...future.oldOptions))
[10:22:44.102]     }
[10:22:44.102]     if (FALSE) {
[10:22:44.102]     }
[10:22:44.102]     else {
[10:22:44.102]         if (TRUE) {
[10:22:44.102]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:44.102]                 open = "w")
[10:22:44.102]         }
[10:22:44.102]         else {
[10:22:44.102]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:44.102]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:44.102]         }
[10:22:44.102]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:44.102]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:44.102]             base::sink(type = "output", split = FALSE)
[10:22:44.102]             base::close(...future.stdout)
[10:22:44.102]         }, add = TRUE)
[10:22:44.102]     }
[10:22:44.102]     ...future.frame <- base::sys.nframe()
[10:22:44.102]     ...future.conditions <- base::list()
[10:22:44.102]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:44.102]     if (FALSE) {
[10:22:44.102]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:44.102]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:44.102]     }
[10:22:44.102]     ...future.result <- base::tryCatch({
[10:22:44.102]         base::withCallingHandlers({
[10:22:44.102]             ...future.value <- base::withVisible(base::local({
[10:22:44.102]                 do.call(function(...) {
[10:22:44.102]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.102]                   if (!identical(...future.globals.maxSize.org, 
[10:22:44.102]                     ...future.globals.maxSize)) {
[10:22:44.102]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.102]                     on.exit(options(oopts), add = TRUE)
[10:22:44.102]                   }
[10:22:44.102]                   {
[10:22:44.102]                     lapply(seq_along(...future.elements_ii), 
[10:22:44.102]                       FUN = function(jj) {
[10:22:44.102]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.102]                         ...future.FUN(...future.X_jj, ...)
[10:22:44.102]                       })
[10:22:44.102]                   }
[10:22:44.102]                 }, args = future.call.arguments)
[10:22:44.102]             }))
[10:22:44.102]             future::FutureResult(value = ...future.value$value, 
[10:22:44.102]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.102]                   ...future.rng), globalenv = if (FALSE) 
[10:22:44.102]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:44.102]                     ...future.globalenv.names))
[10:22:44.102]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:44.102]         }, condition = base::local({
[10:22:44.102]             c <- base::c
[10:22:44.102]             inherits <- base::inherits
[10:22:44.102]             invokeRestart <- base::invokeRestart
[10:22:44.102]             length <- base::length
[10:22:44.102]             list <- base::list
[10:22:44.102]             seq.int <- base::seq.int
[10:22:44.102]             signalCondition <- base::signalCondition
[10:22:44.102]             sys.calls <- base::sys.calls
[10:22:44.102]             `[[` <- base::`[[`
[10:22:44.102]             `+` <- base::`+`
[10:22:44.102]             `<<-` <- base::`<<-`
[10:22:44.102]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:44.102]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:44.102]                   3L)]
[10:22:44.102]             }
[10:22:44.102]             function(cond) {
[10:22:44.102]                 is_error <- inherits(cond, "error")
[10:22:44.102]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:44.102]                   NULL)
[10:22:44.102]                 if (is_error) {
[10:22:44.102]                   sessionInformation <- function() {
[10:22:44.102]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:44.102]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:44.102]                       search = base::search(), system = base::Sys.info())
[10:22:44.102]                   }
[10:22:44.102]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.102]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:44.102]                     cond$call), session = sessionInformation(), 
[10:22:44.102]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:44.102]                   signalCondition(cond)
[10:22:44.102]                 }
[10:22:44.102]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:44.102]                 "immediateCondition"))) {
[10:22:44.102]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:44.102]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.102]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:44.102]                   if (TRUE && !signal) {
[10:22:44.102]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.102]                     {
[10:22:44.102]                       inherits <- base::inherits
[10:22:44.102]                       invokeRestart <- base::invokeRestart
[10:22:44.102]                       is.null <- base::is.null
[10:22:44.102]                       muffled <- FALSE
[10:22:44.102]                       if (inherits(cond, "message")) {
[10:22:44.102]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.102]                         if (muffled) 
[10:22:44.102]                           invokeRestart("muffleMessage")
[10:22:44.102]                       }
[10:22:44.102]                       else if (inherits(cond, "warning")) {
[10:22:44.102]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.102]                         if (muffled) 
[10:22:44.102]                           invokeRestart("muffleWarning")
[10:22:44.102]                       }
[10:22:44.102]                       else if (inherits(cond, "condition")) {
[10:22:44.102]                         if (!is.null(pattern)) {
[10:22:44.102]                           computeRestarts <- base::computeRestarts
[10:22:44.102]                           grepl <- base::grepl
[10:22:44.102]                           restarts <- computeRestarts(cond)
[10:22:44.102]                           for (restart in restarts) {
[10:22:44.102]                             name <- restart$name
[10:22:44.102]                             if (is.null(name)) 
[10:22:44.102]                               next
[10:22:44.102]                             if (!grepl(pattern, name)) 
[10:22:44.102]                               next
[10:22:44.102]                             invokeRestart(restart)
[10:22:44.102]                             muffled <- TRUE
[10:22:44.102]                             break
[10:22:44.102]                           }
[10:22:44.102]                         }
[10:22:44.102]                       }
[10:22:44.102]                       invisible(muffled)
[10:22:44.102]                     }
[10:22:44.102]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.102]                   }
[10:22:44.102]                 }
[10:22:44.102]                 else {
[10:22:44.102]                   if (TRUE) {
[10:22:44.102]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.102]                     {
[10:22:44.102]                       inherits <- base::inherits
[10:22:44.102]                       invokeRestart <- base::invokeRestart
[10:22:44.102]                       is.null <- base::is.null
[10:22:44.102]                       muffled <- FALSE
[10:22:44.102]                       if (inherits(cond, "message")) {
[10:22:44.102]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.102]                         if (muffled) 
[10:22:44.102]                           invokeRestart("muffleMessage")
[10:22:44.102]                       }
[10:22:44.102]                       else if (inherits(cond, "warning")) {
[10:22:44.102]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.102]                         if (muffled) 
[10:22:44.102]                           invokeRestart("muffleWarning")
[10:22:44.102]                       }
[10:22:44.102]                       else if (inherits(cond, "condition")) {
[10:22:44.102]                         if (!is.null(pattern)) {
[10:22:44.102]                           computeRestarts <- base::computeRestarts
[10:22:44.102]                           grepl <- base::grepl
[10:22:44.102]                           restarts <- computeRestarts(cond)
[10:22:44.102]                           for (restart in restarts) {
[10:22:44.102]                             name <- restart$name
[10:22:44.102]                             if (is.null(name)) 
[10:22:44.102]                               next
[10:22:44.102]                             if (!grepl(pattern, name)) 
[10:22:44.102]                               next
[10:22:44.102]                             invokeRestart(restart)
[10:22:44.102]                             muffled <- TRUE
[10:22:44.102]                             break
[10:22:44.102]                           }
[10:22:44.102]                         }
[10:22:44.102]                       }
[10:22:44.102]                       invisible(muffled)
[10:22:44.102]                     }
[10:22:44.102]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.102]                   }
[10:22:44.102]                 }
[10:22:44.102]             }
[10:22:44.102]         }))
[10:22:44.102]     }, error = function(ex) {
[10:22:44.102]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:44.102]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.102]                 ...future.rng), started = ...future.startTime, 
[10:22:44.102]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:44.102]             version = "1.8"), class = "FutureResult")
[10:22:44.102]     }, finally = {
[10:22:44.102]         if (!identical(...future.workdir, getwd())) 
[10:22:44.102]             setwd(...future.workdir)
[10:22:44.102]         {
[10:22:44.102]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:44.102]                 ...future.oldOptions$nwarnings <- NULL
[10:22:44.102]             }
[10:22:44.102]             base::options(...future.oldOptions)
[10:22:44.102]             if (.Platform$OS.type == "windows") {
[10:22:44.102]                 old_names <- names(...future.oldEnvVars)
[10:22:44.102]                 envs <- base::Sys.getenv()
[10:22:44.102]                 names <- names(envs)
[10:22:44.102]                 common <- intersect(names, old_names)
[10:22:44.102]                 added <- setdiff(names, old_names)
[10:22:44.102]                 removed <- setdiff(old_names, names)
[10:22:44.102]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:44.102]                   envs[common]]
[10:22:44.102]                 NAMES <- toupper(changed)
[10:22:44.102]                 args <- list()
[10:22:44.102]                 for (kk in seq_along(NAMES)) {
[10:22:44.102]                   name <- changed[[kk]]
[10:22:44.102]                   NAME <- NAMES[[kk]]
[10:22:44.102]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.102]                     next
[10:22:44.102]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.102]                 }
[10:22:44.102]                 NAMES <- toupper(added)
[10:22:44.102]                 for (kk in seq_along(NAMES)) {
[10:22:44.102]                   name <- added[[kk]]
[10:22:44.102]                   NAME <- NAMES[[kk]]
[10:22:44.102]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.102]                     next
[10:22:44.102]                   args[[name]] <- ""
[10:22:44.102]                 }
[10:22:44.102]                 NAMES <- toupper(removed)
[10:22:44.102]                 for (kk in seq_along(NAMES)) {
[10:22:44.102]                   name <- removed[[kk]]
[10:22:44.102]                   NAME <- NAMES[[kk]]
[10:22:44.102]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.102]                     next
[10:22:44.102]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.102]                 }
[10:22:44.102]                 if (length(args) > 0) 
[10:22:44.102]                   base::do.call(base::Sys.setenv, args = args)
[10:22:44.102]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:44.102]             }
[10:22:44.102]             else {
[10:22:44.102]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:44.102]             }
[10:22:44.102]             {
[10:22:44.102]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:44.102]                   0L) {
[10:22:44.102]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:44.102]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:44.102]                   base::options(opts)
[10:22:44.102]                 }
[10:22:44.102]                 {
[10:22:44.102]                   {
[10:22:44.102]                     NULL
[10:22:44.102]                     RNGkind("Mersenne-Twister")
[10:22:44.102]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:44.102]                       inherits = FALSE)
[10:22:44.102]                   }
[10:22:44.102]                   options(future.plan = NULL)
[10:22:44.102]                   if (is.na(NA_character_)) 
[10:22:44.102]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.102]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:44.102]                   future::plan(list(function (..., envir = parent.frame()) 
[10:22:44.102]                   {
[10:22:44.102]                     future <- SequentialFuture(..., envir = envir)
[10:22:44.102]                     if (!future$lazy) 
[10:22:44.102]                       future <- run(future)
[10:22:44.102]                     invisible(future)
[10:22:44.102]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:44.102]                 }
[10:22:44.102]             }
[10:22:44.102]         }
[10:22:44.102]     })
[10:22:44.102]     if (TRUE) {
[10:22:44.102]         base::sink(type = "output", split = FALSE)
[10:22:44.102]         if (TRUE) {
[10:22:44.102]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:44.102]         }
[10:22:44.102]         else {
[10:22:44.102]             ...future.result["stdout"] <- base::list(NULL)
[10:22:44.102]         }
[10:22:44.102]         base::close(...future.stdout)
[10:22:44.102]         ...future.stdout <- NULL
[10:22:44.102]     }
[10:22:44.102]     ...future.result$conditions <- ...future.conditions
[10:22:44.102]     ...future.result$finished <- base::Sys.time()
[10:22:44.102]     ...future.result
[10:22:44.102] }
[10:22:44.104] assign_globals() ...
[10:22:44.104] List of 5
[10:22:44.104]  $ future.call.arguments    : list()
[10:22:44.104]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.104]  $ ...future.FUN            :function (x)  
[10:22:44.104]  $ ...future.elements_ii    :List of 2
[10:22:44.104]   ..$ : int 1
[10:22:44.104]   ..$ : int 2
[10:22:44.104]  $ ...future.seeds_ii       : NULL
[10:22:44.104]  $ ...future.globals.maxSize: num Inf
[10:22:44.104]  - attr(*, "resolved")= logi FALSE
[10:22:44.104]  - attr(*, "total_size")= num NA
[10:22:44.104]  - attr(*, "where")=List of 5
[10:22:44.104]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:44.104]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:44.104]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:44.104]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:44.104]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:44.104]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.104]  - attr(*, "already-done")= logi TRUE
[10:22:44.109] - copied ‘future.call.arguments’ to environment
[10:22:44.109] - copied ‘...future.FUN’ to environment
[10:22:44.109] - copied ‘...future.elements_ii’ to environment
[10:22:44.109] - copied ‘...future.seeds_ii’ to environment
[10:22:44.109] - copied ‘...future.globals.maxSize’ to environment
[10:22:44.109] assign_globals() ... done
[10:22:44.110] plan(): Setting new future strategy stack:
[10:22:44.110] List of future strategies:
[10:22:44.110] 1. sequential:
[10:22:44.110]    - args: function (..., envir = parent.frame())
[10:22:44.110]    - tweaked: FALSE
[10:22:44.110]    - call: NULL
[10:22:44.110] plan(): nbrOfWorkers() = 1
[10:22:44.111] plan(): Setting new future strategy stack:
[10:22:44.111] List of future strategies:
[10:22:44.111] 1. sequential:
[10:22:44.111]    - args: function (..., envir = parent.frame())
[10:22:44.111]    - tweaked: FALSE
[10:22:44.111]    - call: plan(strategy)
[10:22:44.111] plan(): nbrOfWorkers() = 1
[10:22:44.111] SequentialFuture started (and completed)
[10:22:44.111] - Launch lazy future ... done
[10:22:44.111] run() for ‘SequentialFuture’ ... done
[10:22:44.112] Created future:
[10:22:44.112] SequentialFuture:
[10:22:44.112] Label: ‘future_apply-1’
[10:22:44.112] Expression:
[10:22:44.112] {
[10:22:44.112]     do.call(function(...) {
[10:22:44.112]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.112]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:44.112]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.112]             on.exit(options(oopts), add = TRUE)
[10:22:44.112]         }
[10:22:44.112]         {
[10:22:44.112]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:44.112]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.112]                 ...future.FUN(...future.X_jj, ...)
[10:22:44.112]             })
[10:22:44.112]         }
[10:22:44.112]     }, args = future.call.arguments)
[10:22:44.112] }
[10:22:44.112] Lazy evaluation: FALSE
[10:22:44.112] Asynchronous evaluation: FALSE
[10:22:44.112] Local evaluation: TRUE
[10:22:44.112] Environment: R_GlobalEnv
[10:22:44.112] Capture standard output: TRUE
[10:22:44.112] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:44.112] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:44.112] Packages: <none>
[10:22:44.112] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:44.112] Resolved: TRUE
[10:22:44.112] Value: 112 bytes of class ‘list’
[10:22:44.112] Early signaling: FALSE
[10:22:44.112] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:44.112] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:44.113] Chunk #1 of 1 ... DONE
[10:22:44.113] Launching 1 futures (chunks) ... DONE
[10:22:44.113] Resolving 1 futures (chunks) ...
[10:22:44.113] resolve() on list ...
[10:22:44.113]  recursive: 0
[10:22:44.113]  length: 1
[10:22:44.113] 
[10:22:44.113] resolved() for ‘SequentialFuture’ ...
[10:22:44.113] - state: ‘finished’
[10:22:44.114] - run: TRUE
[10:22:44.114] - result: ‘FutureResult’
[10:22:44.114] resolved() for ‘SequentialFuture’ ... done
[10:22:44.114] Future #1
[10:22:44.114] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:44.114] - nx: 1
[10:22:44.114] - relay: TRUE
[10:22:44.114] - stdout: TRUE
[10:22:44.114] - signal: TRUE
[10:22:44.114] - resignal: FALSE
[10:22:44.114] - force: TRUE
[10:22:44.115] - relayed: [n=1] FALSE
[10:22:44.115] - queued futures: [n=1] FALSE
[10:22:44.115]  - until=1
[10:22:44.115]  - relaying element #1
[10:22:44.115] - relayed: [n=1] TRUE
[10:22:44.115] - queued futures: [n=1] TRUE
[10:22:44.115] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:44.115]  length: 0 (resolved future 1)
[10:22:44.115] Relaying remaining futures
[10:22:44.115] signalConditionsASAP(NULL, pos=0) ...
[10:22:44.116] - nx: 1
[10:22:44.116] - relay: TRUE
[10:22:44.116] - stdout: TRUE
[10:22:44.116] - signal: TRUE
[10:22:44.116] - resignal: FALSE
[10:22:44.116] - force: TRUE
[10:22:44.116] - relayed: [n=1] TRUE
[10:22:44.116] - queued futures: [n=1] TRUE
 - flush all
[10:22:44.116] - relayed: [n=1] TRUE
[10:22:44.116] - queued futures: [n=1] TRUE
[10:22:44.116] signalConditionsASAP(NULL, pos=0) ... done
[10:22:44.116] resolve() on list ... DONE
[10:22:44.117]  - Number of value chunks collected: 1
[10:22:44.117] Resolving 1 futures (chunks) ... DONE
[10:22:44.117] Reducing values from 1 chunks ...
[10:22:44.117]  - Number of values collected after concatenation: 2
[10:22:44.117]  - Number of values expected: 2
[10:22:44.117] Reducing values from 1 chunks ... DONE
[10:22:44.117] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[10:22:44.117] getGlobalsAndPackagesXApply() ...
[10:22:44.117]  - future.globals: TRUE
[10:22:44.118] getGlobalsAndPackages() ...
[10:22:44.118] Searching for globals...
[10:22:44.119] - globals found: [1] ‘FUN’
[10:22:44.119] Searching for globals ... DONE
[10:22:44.119] Resolving globals: FALSE
[10:22:44.119] The total size of the 1 globals is 848 bytes (848 bytes)
[10:22:44.119] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:22:44.119] - globals: [1] ‘FUN’
[10:22:44.120] 
[10:22:44.120] getGlobalsAndPackages() ... DONE
[10:22:44.120]  - globals found/used: [n=1] ‘FUN’
[10:22:44.120]  - needed namespaces: [n=0] 
[10:22:44.120] Finding globals ... DONE
[10:22:44.120]  - use_args: TRUE
[10:22:44.120]  - Getting '...' globals ...
[10:22:44.120] resolve() on list ...
[10:22:44.120]  recursive: 0
[10:22:44.121]  length: 1
[10:22:44.121]  elements: ‘...’
[10:22:44.121]  length: 0 (resolved future 1)
[10:22:44.121] resolve() on list ... DONE
[10:22:44.121]    - '...' content: [n=0] 
[10:22:44.121] List of 1
[10:22:44.121]  $ ...: list()
[10:22:44.121]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.121]  - attr(*, "where")=List of 1
[10:22:44.121]   ..$ ...:<environment: 0x55ca4d12ed18> 
[10:22:44.121]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.121]  - attr(*, "resolved")= logi TRUE
[10:22:44.121]  - attr(*, "total_size")= num NA
[10:22:44.124]  - Getting '...' globals ... DONE
[10:22:44.124] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:44.125] List of 2
[10:22:44.125]  $ ...future.FUN:function (x)  
[10:22:44.125]  $ ...          : list()
[10:22:44.125]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.125]  - attr(*, "where")=List of 2
[10:22:44.125]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:44.125]   ..$ ...          :<environment: 0x55ca4d12ed18> 
[10:22:44.125]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.125]  - attr(*, "resolved")= logi FALSE
[10:22:44.125]  - attr(*, "total_size")= num 848
[10:22:44.127] Packages to be attached in all futures: [n=0] 
[10:22:44.127] getGlobalsAndPackagesXApply() ... DONE
[10:22:44.127] future_lapply() ...
[10:22:44.128] Number of chunks: 1
[10:22:44.128] getGlobalsAndPackagesXApply() ...
[10:22:44.128]  - future.globals: <name-value list> with names ‘list()’
[10:22:44.128]  - use_args: TRUE
[10:22:44.128] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:22:44.128] List of 2
[10:22:44.128]  $ ...          : list()
[10:22:44.128]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.128]  $ ...future.FUN:function (x)  
[10:22:44.128]  - attr(*, "where")=List of 2
[10:22:44.128]   ..$ ...          :<environment: 0x55ca4d12ed18> 
[10:22:44.128]   ..$ ...future.FUN:<environment: namespace:base> 
[10:22:44.128]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.128]  - attr(*, "resolved")= logi FALSE
[10:22:44.128]  - attr(*, "total_size")= num NA
[10:22:44.131] Packages to be attached in all futures: [n=0] 
[10:22:44.131] getGlobalsAndPackagesXApply() ... DONE
[10:22:44.132] Number of futures (= number of chunks): 1
[10:22:44.132] Launching 1 futures (chunks) ...
[10:22:44.132] Chunk #1 of 1 ...
[10:22:44.132]  - seeds: <none>
[10:22:44.132]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.132] getGlobalsAndPackages() ...
[10:22:44.132] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.132] Resolving globals: FALSE
[10:22:44.132] Tweak future expression to call with '...' arguments ...
[10:22:44.132] {
[10:22:44.132]     do.call(function(...) {
[10:22:44.132]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.132]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:44.132]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.132]             on.exit(options(oopts), add = TRUE)
[10:22:44.132]         }
[10:22:44.132]         {
[10:22:44.132]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:44.132]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.132]                 ...future.FUN(...future.X_jj, ...)
[10:22:44.132]             })
[10:22:44.132]         }
[10:22:44.132]     }, args = future.call.arguments)
[10:22:44.132] }
[10:22:44.133] Tweak future expression to call with '...' arguments ... DONE
[10:22:44.133] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.133] 
[10:22:44.133] getGlobalsAndPackages() ... DONE
[10:22:44.134] run() for ‘Future’ ...
[10:22:44.134] - state: ‘created’
[10:22:44.134] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:44.134] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:44.134] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:44.134]   - Field: ‘label’
[10:22:44.134]   - Field: ‘local’
[10:22:44.134]   - Field: ‘owner’
[10:22:44.135]   - Field: ‘envir’
[10:22:44.135]   - Field: ‘packages’
[10:22:44.135]   - Field: ‘gc’
[10:22:44.135]   - Field: ‘conditions’
[10:22:44.135]   - Field: ‘expr’
[10:22:44.135]   - Field: ‘uuid’
[10:22:44.135]   - Field: ‘seed’
[10:22:44.135]   - Field: ‘version’
[10:22:44.135]   - Field: ‘result’
[10:22:44.135]   - Field: ‘asynchronous’
[10:22:44.135]   - Field: ‘calls’
[10:22:44.135]   - Field: ‘globals’
[10:22:44.136]   - Field: ‘stdout’
[10:22:44.136]   - Field: ‘earlySignal’
[10:22:44.136]   - Field: ‘lazy’
[10:22:44.136]   - Field: ‘state’
[10:22:44.136] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:44.136] - Launch lazy future ...
[10:22:44.136] Packages needed by the future expression (n = 0): <none>
[10:22:44.136] Packages needed by future strategies (n = 0): <none>
[10:22:44.137] {
[10:22:44.137]     {
[10:22:44.137]         {
[10:22:44.137]             ...future.startTime <- base::Sys.time()
[10:22:44.137]             {
[10:22:44.137]                 {
[10:22:44.137]                   {
[10:22:44.137]                     base::local({
[10:22:44.137]                       has_future <- base::requireNamespace("future", 
[10:22:44.137]                         quietly = TRUE)
[10:22:44.137]                       if (has_future) {
[10:22:44.137]                         ns <- base::getNamespace("future")
[10:22:44.137]                         version <- ns[[".package"]][["version"]]
[10:22:44.137]                         if (is.null(version)) 
[10:22:44.137]                           version <- utils::packageVersion("future")
[10:22:44.137]                       }
[10:22:44.137]                       else {
[10:22:44.137]                         version <- NULL
[10:22:44.137]                       }
[10:22:44.137]                       if (!has_future || version < "1.8.0") {
[10:22:44.137]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:44.137]                           "", base::R.version$version.string), 
[10:22:44.137]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:44.137]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:44.137]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:44.137]                             "release", "version")], collapse = " "), 
[10:22:44.137]                           hostname = base::Sys.info()[["nodename"]])
[10:22:44.137]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:44.137]                           info)
[10:22:44.137]                         info <- base::paste(info, collapse = "; ")
[10:22:44.137]                         if (!has_future) {
[10:22:44.137]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:44.137]                             info)
[10:22:44.137]                         }
[10:22:44.137]                         else {
[10:22:44.137]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:44.137]                             info, version)
[10:22:44.137]                         }
[10:22:44.137]                         base::stop(msg)
[10:22:44.137]                       }
[10:22:44.137]                     })
[10:22:44.137]                   }
[10:22:44.137]                   options(future.plan = NULL)
[10:22:44.137]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.137]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:44.137]                 }
[10:22:44.137]                 ...future.workdir <- getwd()
[10:22:44.137]             }
[10:22:44.137]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:44.137]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:44.137]         }
[10:22:44.137]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:44.137]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:44.137]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:44.137]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:44.137]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:44.137]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:44.137]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:44.137]             base::names(...future.oldOptions))
[10:22:44.137]     }
[10:22:44.137]     if (FALSE) {
[10:22:44.137]     }
[10:22:44.137]     else {
[10:22:44.137]         if (TRUE) {
[10:22:44.137]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:44.137]                 open = "w")
[10:22:44.137]         }
[10:22:44.137]         else {
[10:22:44.137]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:44.137]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:44.137]         }
[10:22:44.137]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:44.137]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:44.137]             base::sink(type = "output", split = FALSE)
[10:22:44.137]             base::close(...future.stdout)
[10:22:44.137]         }, add = TRUE)
[10:22:44.137]     }
[10:22:44.137]     ...future.frame <- base::sys.nframe()
[10:22:44.137]     ...future.conditions <- base::list()
[10:22:44.137]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:44.137]     if (FALSE) {
[10:22:44.137]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:44.137]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:44.137]     }
[10:22:44.137]     ...future.result <- base::tryCatch({
[10:22:44.137]         base::withCallingHandlers({
[10:22:44.137]             ...future.value <- base::withVisible(base::local({
[10:22:44.137]                 do.call(function(...) {
[10:22:44.137]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.137]                   if (!identical(...future.globals.maxSize.org, 
[10:22:44.137]                     ...future.globals.maxSize)) {
[10:22:44.137]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.137]                     on.exit(options(oopts), add = TRUE)
[10:22:44.137]                   }
[10:22:44.137]                   {
[10:22:44.137]                     lapply(seq_along(...future.elements_ii), 
[10:22:44.137]                       FUN = function(jj) {
[10:22:44.137]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.137]                         ...future.FUN(...future.X_jj, ...)
[10:22:44.137]                       })
[10:22:44.137]                   }
[10:22:44.137]                 }, args = future.call.arguments)
[10:22:44.137]             }))
[10:22:44.137]             future::FutureResult(value = ...future.value$value, 
[10:22:44.137]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.137]                   ...future.rng), globalenv = if (FALSE) 
[10:22:44.137]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:44.137]                     ...future.globalenv.names))
[10:22:44.137]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:44.137]         }, condition = base::local({
[10:22:44.137]             c <- base::c
[10:22:44.137]             inherits <- base::inherits
[10:22:44.137]             invokeRestart <- base::invokeRestart
[10:22:44.137]             length <- base::length
[10:22:44.137]             list <- base::list
[10:22:44.137]             seq.int <- base::seq.int
[10:22:44.137]             signalCondition <- base::signalCondition
[10:22:44.137]             sys.calls <- base::sys.calls
[10:22:44.137]             `[[` <- base::`[[`
[10:22:44.137]             `+` <- base::`+`
[10:22:44.137]             `<<-` <- base::`<<-`
[10:22:44.137]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:44.137]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:44.137]                   3L)]
[10:22:44.137]             }
[10:22:44.137]             function(cond) {
[10:22:44.137]                 is_error <- inherits(cond, "error")
[10:22:44.137]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:44.137]                   NULL)
[10:22:44.137]                 if (is_error) {
[10:22:44.137]                   sessionInformation <- function() {
[10:22:44.137]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:44.137]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:44.137]                       search = base::search(), system = base::Sys.info())
[10:22:44.137]                   }
[10:22:44.137]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.137]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:44.137]                     cond$call), session = sessionInformation(), 
[10:22:44.137]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:44.137]                   signalCondition(cond)
[10:22:44.137]                 }
[10:22:44.137]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:44.137]                 "immediateCondition"))) {
[10:22:44.137]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:44.137]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.137]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:44.137]                   if (TRUE && !signal) {
[10:22:44.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.137]                     {
[10:22:44.137]                       inherits <- base::inherits
[10:22:44.137]                       invokeRestart <- base::invokeRestart
[10:22:44.137]                       is.null <- base::is.null
[10:22:44.137]                       muffled <- FALSE
[10:22:44.137]                       if (inherits(cond, "message")) {
[10:22:44.137]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.137]                         if (muffled) 
[10:22:44.137]                           invokeRestart("muffleMessage")
[10:22:44.137]                       }
[10:22:44.137]                       else if (inherits(cond, "warning")) {
[10:22:44.137]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.137]                         if (muffled) 
[10:22:44.137]                           invokeRestart("muffleWarning")
[10:22:44.137]                       }
[10:22:44.137]                       else if (inherits(cond, "condition")) {
[10:22:44.137]                         if (!is.null(pattern)) {
[10:22:44.137]                           computeRestarts <- base::computeRestarts
[10:22:44.137]                           grepl <- base::grepl
[10:22:44.137]                           restarts <- computeRestarts(cond)
[10:22:44.137]                           for (restart in restarts) {
[10:22:44.137]                             name <- restart$name
[10:22:44.137]                             if (is.null(name)) 
[10:22:44.137]                               next
[10:22:44.137]                             if (!grepl(pattern, name)) 
[10:22:44.137]                               next
[10:22:44.137]                             invokeRestart(restart)
[10:22:44.137]                             muffled <- TRUE
[10:22:44.137]                             break
[10:22:44.137]                           }
[10:22:44.137]                         }
[10:22:44.137]                       }
[10:22:44.137]                       invisible(muffled)
[10:22:44.137]                     }
[10:22:44.137]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.137]                   }
[10:22:44.137]                 }
[10:22:44.137]                 else {
[10:22:44.137]                   if (TRUE) {
[10:22:44.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.137]                     {
[10:22:44.137]                       inherits <- base::inherits
[10:22:44.137]                       invokeRestart <- base::invokeRestart
[10:22:44.137]                       is.null <- base::is.null
[10:22:44.137]                       muffled <- FALSE
[10:22:44.137]                       if (inherits(cond, "message")) {
[10:22:44.137]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.137]                         if (muffled) 
[10:22:44.137]                           invokeRestart("muffleMessage")
[10:22:44.137]                       }
[10:22:44.137]                       else if (inherits(cond, "warning")) {
[10:22:44.137]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.137]                         if (muffled) 
[10:22:44.137]                           invokeRestart("muffleWarning")
[10:22:44.137]                       }
[10:22:44.137]                       else if (inherits(cond, "condition")) {
[10:22:44.137]                         if (!is.null(pattern)) {
[10:22:44.137]                           computeRestarts <- base::computeRestarts
[10:22:44.137]                           grepl <- base::grepl
[10:22:44.137]                           restarts <- computeRestarts(cond)
[10:22:44.137]                           for (restart in restarts) {
[10:22:44.137]                             name <- restart$name
[10:22:44.137]                             if (is.null(name)) 
[10:22:44.137]                               next
[10:22:44.137]                             if (!grepl(pattern, name)) 
[10:22:44.137]                               next
[10:22:44.137]                             invokeRestart(restart)
[10:22:44.137]                             muffled <- TRUE
[10:22:44.137]                             break
[10:22:44.137]                           }
[10:22:44.137]                         }
[10:22:44.137]                       }
[10:22:44.137]                       invisible(muffled)
[10:22:44.137]                     }
[10:22:44.137]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.137]                   }
[10:22:44.137]                 }
[10:22:44.137]             }
[10:22:44.137]         }))
[10:22:44.137]     }, error = function(ex) {
[10:22:44.137]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:44.137]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.137]                 ...future.rng), started = ...future.startTime, 
[10:22:44.137]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:44.137]             version = "1.8"), class = "FutureResult")
[10:22:44.137]     }, finally = {
[10:22:44.137]         if (!identical(...future.workdir, getwd())) 
[10:22:44.137]             setwd(...future.workdir)
[10:22:44.137]         {
[10:22:44.137]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:44.137]                 ...future.oldOptions$nwarnings <- NULL
[10:22:44.137]             }
[10:22:44.137]             base::options(...future.oldOptions)
[10:22:44.137]             if (.Platform$OS.type == "windows") {
[10:22:44.137]                 old_names <- names(...future.oldEnvVars)
[10:22:44.137]                 envs <- base::Sys.getenv()
[10:22:44.137]                 names <- names(envs)
[10:22:44.137]                 common <- intersect(names, old_names)
[10:22:44.137]                 added <- setdiff(names, old_names)
[10:22:44.137]                 removed <- setdiff(old_names, names)
[10:22:44.137]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:44.137]                   envs[common]]
[10:22:44.137]                 NAMES <- toupper(changed)
[10:22:44.137]                 args <- list()
[10:22:44.137]                 for (kk in seq_along(NAMES)) {
[10:22:44.137]                   name <- changed[[kk]]
[10:22:44.137]                   NAME <- NAMES[[kk]]
[10:22:44.137]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.137]                     next
[10:22:44.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.137]                 }
[10:22:44.137]                 NAMES <- toupper(added)
[10:22:44.137]                 for (kk in seq_along(NAMES)) {
[10:22:44.137]                   name <- added[[kk]]
[10:22:44.137]                   NAME <- NAMES[[kk]]
[10:22:44.137]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.137]                     next
[10:22:44.137]                   args[[name]] <- ""
[10:22:44.137]                 }
[10:22:44.137]                 NAMES <- toupper(removed)
[10:22:44.137]                 for (kk in seq_along(NAMES)) {
[10:22:44.137]                   name <- removed[[kk]]
[10:22:44.137]                   NAME <- NAMES[[kk]]
[10:22:44.137]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.137]                     next
[10:22:44.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.137]                 }
[10:22:44.137]                 if (length(args) > 0) 
[10:22:44.137]                   base::do.call(base::Sys.setenv, args = args)
[10:22:44.137]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:44.137]             }
[10:22:44.137]             else {
[10:22:44.137]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:44.137]             }
[10:22:44.137]             {
[10:22:44.137]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:44.137]                   0L) {
[10:22:44.137]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:44.137]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:44.137]                   base::options(opts)
[10:22:44.137]                 }
[10:22:44.137]                 {
[10:22:44.137]                   {
[10:22:44.137]                     NULL
[10:22:44.137]                     RNGkind("Mersenne-Twister")
[10:22:44.137]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:44.137]                       inherits = FALSE)
[10:22:44.137]                   }
[10:22:44.137]                   options(future.plan = NULL)
[10:22:44.137]                   if (is.na(NA_character_)) 
[10:22:44.137]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.137]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:44.137]                   future::plan(list(function (..., envir = parent.frame()) 
[10:22:44.137]                   {
[10:22:44.137]                     future <- SequentialFuture(..., envir = envir)
[10:22:44.137]                     if (!future$lazy) 
[10:22:44.137]                       future <- run(future)
[10:22:44.137]                     invisible(future)
[10:22:44.137]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:44.137]                 }
[10:22:44.137]             }
[10:22:44.137]         }
[10:22:44.137]     })
[10:22:44.137]     if (TRUE) {
[10:22:44.137]         base::sink(type = "output", split = FALSE)
[10:22:44.137]         if (TRUE) {
[10:22:44.137]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:44.137]         }
[10:22:44.137]         else {
[10:22:44.137]             ...future.result["stdout"] <- base::list(NULL)
[10:22:44.137]         }
[10:22:44.137]         base::close(...future.stdout)
[10:22:44.137]         ...future.stdout <- NULL
[10:22:44.137]     }
[10:22:44.137]     ...future.result$conditions <- ...future.conditions
[10:22:44.137]     ...future.result$finished <- base::Sys.time()
[10:22:44.137]     ...future.result
[10:22:44.137] }
[10:22:44.138] assign_globals() ...
[10:22:44.138] List of 5
[10:22:44.138]  $ future.call.arguments    : list()
[10:22:44.138]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.138]  $ ...future.FUN            :function (x)  
[10:22:44.138]  $ ...future.elements_ii    :List of 2
[10:22:44.138]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[10:22:44.138]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[10:22:44.138]  $ ...future.seeds_ii       : NULL
[10:22:44.138]  $ ...future.globals.maxSize: num Inf
[10:22:44.138]  - attr(*, "resolved")= logi FALSE
[10:22:44.138]  - attr(*, "total_size")= num NA
[10:22:44.138]  - attr(*, "where")=List of 5
[10:22:44.138]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:44.138]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:44.138]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:44.138]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:44.138]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:44.138]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.138]  - attr(*, "already-done")= logi TRUE
[10:22:44.143] - copied ‘future.call.arguments’ to environment
[10:22:44.143] - copied ‘...future.FUN’ to environment
[10:22:44.144] - copied ‘...future.elements_ii’ to environment
[10:22:44.144] - copied ‘...future.seeds_ii’ to environment
[10:22:44.144] - copied ‘...future.globals.maxSize’ to environment
[10:22:44.144] assign_globals() ... done
[10:22:44.144] plan(): Setting new future strategy stack:
[10:22:44.144] List of future strategies:
[10:22:44.144] 1. sequential:
[10:22:44.144]    - args: function (..., envir = parent.frame())
[10:22:44.144]    - tweaked: FALSE
[10:22:44.144]    - call: NULL
[10:22:44.144] plan(): nbrOfWorkers() = 1
[10:22:44.145] plan(): Setting new future strategy stack:
[10:22:44.145] List of future strategies:
[10:22:44.145] 1. sequential:
[10:22:44.145]    - args: function (..., envir = parent.frame())
[10:22:44.145]    - tweaked: FALSE
[10:22:44.145]    - call: plan(strategy)
[10:22:44.146] plan(): nbrOfWorkers() = 1
[10:22:44.147] SequentialFuture started (and completed)
[10:22:44.147] - Launch lazy future ... done
[10:22:44.147] run() for ‘SequentialFuture’ ... done
[10:22:44.147] Created future:
[10:22:44.147] SequentialFuture:
[10:22:44.147] Label: ‘future_apply-1’
[10:22:44.147] Expression:
[10:22:44.147] {
[10:22:44.147]     do.call(function(...) {
[10:22:44.147]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.147]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:44.147]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.147]             on.exit(options(oopts), add = TRUE)
[10:22:44.147]         }
[10:22:44.147]         {
[10:22:44.147]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:44.147]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.147]                 ...future.FUN(...future.X_jj, ...)
[10:22:44.147]             })
[10:22:44.147]         }
[10:22:44.147]     }, args = future.call.arguments)
[10:22:44.147] }
[10:22:44.147] Lazy evaluation: FALSE
[10:22:44.147] Asynchronous evaluation: FALSE
[10:22:44.147] Local evaluation: TRUE
[10:22:44.147] Environment: R_GlobalEnv
[10:22:44.147] Capture standard output: TRUE
[10:22:44.147] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:44.147] Globals: 5 objects totaling 1.37 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 496 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:44.147] Packages: <none>
[10:22:44.147] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:44.147] Resolved: TRUE
[10:22:44.147] Value: 496 bytes of class ‘list’
[10:22:44.147] Early signaling: FALSE
[10:22:44.147] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:44.147] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:44.148] Chunk #1 of 1 ... DONE
[10:22:44.148] Launching 1 futures (chunks) ... DONE
[10:22:44.148] Resolving 1 futures (chunks) ...
[10:22:44.148] resolve() on list ...
[10:22:44.148]  recursive: 0
[10:22:44.149]  length: 1
[10:22:44.149] 
[10:22:44.149] resolved() for ‘SequentialFuture’ ...
[10:22:44.149] - state: ‘finished’
[10:22:44.149] - run: TRUE
[10:22:44.149] - result: ‘FutureResult’
[10:22:44.149] resolved() for ‘SequentialFuture’ ... done
[10:22:44.149] Future #1
[10:22:44.149] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:44.149] - nx: 1
[10:22:44.149] - relay: TRUE
[10:22:44.150] - stdout: TRUE
[10:22:44.150] - signal: TRUE
[10:22:44.150] - resignal: FALSE
[10:22:44.150] - force: TRUE
[10:22:44.150] - relayed: [n=1] FALSE
[10:22:44.150] - queued futures: [n=1] FALSE
[10:22:44.150]  - until=1
[10:22:44.150]  - relaying element #1
[10:22:44.150] - relayed: [n=1] TRUE
[10:22:44.150] - queued futures: [n=1] TRUE
[10:22:44.150] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:44.151]  length: 0 (resolved future 1)
[10:22:44.151] Relaying remaining futures
[10:22:44.151] signalConditionsASAP(NULL, pos=0) ...
[10:22:44.151] - nx: 1
[10:22:44.151] - relay: TRUE
[10:22:44.151] - stdout: TRUE
[10:22:44.151] - signal: TRUE
[10:22:44.151] - resignal: FALSE
[10:22:44.151] - force: TRUE
[10:22:44.151] - relayed: [n=1] TRUE
[10:22:44.151] - queued futures: [n=1] TRUE
 - flush all
[10:22:44.152] - relayed: [n=1] TRUE
[10:22:44.152] - queued futures: [n=1] TRUE
[10:22:44.152] signalConditionsASAP(NULL, pos=0) ... done
[10:22:44.152] resolve() on list ... DONE
[10:22:44.152]  - Number of value chunks collected: 1
[10:22:44.152] Resolving 1 futures (chunks) ... DONE
[10:22:44.152] Reducing values from 1 chunks ...
[10:22:44.152]  - Number of values collected after concatenation: 2
[10:22:44.152]  - Number of values expected: 2
[10:22:44.152] Reducing values from 1 chunks ... DONE
[10:22:44.152] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[10:22:44.153] getGlobalsAndPackagesXApply() ...
[10:22:44.153]  - future.globals: TRUE
[10:22:44.153] getGlobalsAndPackages() ...
[10:22:44.153] Searching for globals...
[10:22:44.155] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[10:22:44.155] Searching for globals ... DONE
[10:22:44.156] Resolving globals: FALSE
[10:22:44.156] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[10:22:44.156] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[10:22:44.156] - globals: [1] ‘FUN’
[10:22:44.157] 
[10:22:44.157] getGlobalsAndPackages() ... DONE
[10:22:44.157]  - globals found/used: [n=1] ‘FUN’
[10:22:44.157]  - needed namespaces: [n=0] 
[10:22:44.157] Finding globals ... DONE
[10:22:44.157]  - use_args: TRUE
[10:22:44.157]  - Getting '...' globals ...
[10:22:44.157] resolve() on list ...
[10:22:44.157]  recursive: 0
[10:22:44.158]  length: 1
[10:22:44.158]  elements: ‘...’
[10:22:44.158]  length: 0 (resolved future 1)
[10:22:44.158] resolve() on list ... DONE
[10:22:44.158]    - '...' content: [n=0] 
[10:22:44.158] List of 1
[10:22:44.158]  $ ...: list()
[10:22:44.158]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.158]  - attr(*, "where")=List of 1
[10:22:44.158]   ..$ ...:<environment: 0x55ca4acf3628> 
[10:22:44.158]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.158]  - attr(*, "resolved")= logi TRUE
[10:22:44.158]  - attr(*, "total_size")= num NA
[10:22:44.160]  - Getting '...' globals ... DONE
[10:22:44.161] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:44.161] List of 2
[10:22:44.161]  $ ...future.FUN:function (x)  
[10:22:44.161]  $ ...          : list()
[10:22:44.161]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.161]  - attr(*, "where")=List of 2
[10:22:44.161]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:44.161]   ..$ ...          :<environment: 0x55ca4acf3628> 
[10:22:44.161]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.161]  - attr(*, "resolved")= logi FALSE
[10:22:44.161]  - attr(*, "total_size")= num 9888
[10:22:44.163] Packages to be attached in all futures: [n=0] 
[10:22:44.163] getGlobalsAndPackagesXApply() ... DONE
[10:22:44.163] future_lapply() ...
[10:22:44.165] Number of chunks: 1
[10:22:44.165] getGlobalsAndPackagesXApply() ...
[10:22:44.165]  - future.globals: <name-value list> with names ‘list()’
[10:22:44.165]  - use_args: TRUE
[10:22:44.165] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:22:44.165] List of 2
[10:22:44.165]  $ ...          : list()
[10:22:44.165]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.165]  $ ...future.FUN:function (x)  
[10:22:44.165]  - attr(*, "where")=List of 2
[10:22:44.165]   ..$ ...          :<environment: 0x55ca4acf3628> 
[10:22:44.165]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[10:22:44.165]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.165]  - attr(*, "resolved")= logi FALSE
[10:22:44.165]  - attr(*, "total_size")= num NA
[10:22:44.169] Packages to be attached in all futures: [n=0] 
[10:22:44.169] getGlobalsAndPackagesXApply() ... DONE
[10:22:44.169] Number of futures (= number of chunks): 1
[10:22:44.169] Launching 1 futures (chunks) ...
[10:22:44.170] Chunk #1 of 1 ...
[10:22:44.170]  - seeds: <none>
[10:22:44.170]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.170] getGlobalsAndPackages() ...
[10:22:44.170] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.170] Resolving globals: FALSE
[10:22:44.170] Tweak future expression to call with '...' arguments ...
[10:22:44.170] {
[10:22:44.170]     do.call(function(...) {
[10:22:44.170]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.170]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:44.170]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.170]             on.exit(options(oopts), add = TRUE)
[10:22:44.170]         }
[10:22:44.170]         {
[10:22:44.170]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:44.170]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.170]                 ...future.FUN(...future.X_jj, ...)
[10:22:44.170]             })
[10:22:44.170]         }
[10:22:44.170]     }, args = future.call.arguments)
[10:22:44.170] }
[10:22:44.171] Tweak future expression to call with '...' arguments ... DONE
[10:22:44.171] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.171] 
[10:22:44.171] getGlobalsAndPackages() ... DONE
[10:22:44.171] run() for ‘Future’ ...
[10:22:44.171] - state: ‘created’
[10:22:44.172] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:44.172] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:44.172] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:44.172]   - Field: ‘label’
[10:22:44.172]   - Field: ‘local’
[10:22:44.172]   - Field: ‘owner’
[10:22:44.172]   - Field: ‘envir’
[10:22:44.172]   - Field: ‘packages’
[10:22:44.173]   - Field: ‘gc’
[10:22:44.173]   - Field: ‘conditions’
[10:22:44.173]   - Field: ‘expr’
[10:22:44.173]   - Field: ‘uuid’
[10:22:44.173]   - Field: ‘seed’
[10:22:44.173]   - Field: ‘version’
[10:22:44.173]   - Field: ‘result’
[10:22:44.173]   - Field: ‘asynchronous’
[10:22:44.173]   - Field: ‘calls’
[10:22:44.173]   - Field: ‘globals’
[10:22:44.173]   - Field: ‘stdout’
[10:22:44.174]   - Field: ‘earlySignal’
[10:22:44.174]   - Field: ‘lazy’
[10:22:44.174]   - Field: ‘state’
[10:22:44.174] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:44.174] - Launch lazy future ...
[10:22:44.174] Packages needed by the future expression (n = 0): <none>
[10:22:44.174] Packages needed by future strategies (n = 0): <none>
[10:22:44.175] {
[10:22:44.175]     {
[10:22:44.175]         {
[10:22:44.175]             ...future.startTime <- base::Sys.time()
[10:22:44.175]             {
[10:22:44.175]                 {
[10:22:44.175]                   {
[10:22:44.175]                     base::local({
[10:22:44.175]                       has_future <- base::requireNamespace("future", 
[10:22:44.175]                         quietly = TRUE)
[10:22:44.175]                       if (has_future) {
[10:22:44.175]                         ns <- base::getNamespace("future")
[10:22:44.175]                         version <- ns[[".package"]][["version"]]
[10:22:44.175]                         if (is.null(version)) 
[10:22:44.175]                           version <- utils::packageVersion("future")
[10:22:44.175]                       }
[10:22:44.175]                       else {
[10:22:44.175]                         version <- NULL
[10:22:44.175]                       }
[10:22:44.175]                       if (!has_future || version < "1.8.0") {
[10:22:44.175]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:44.175]                           "", base::R.version$version.string), 
[10:22:44.175]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:44.175]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:44.175]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:44.175]                             "release", "version")], collapse = " "), 
[10:22:44.175]                           hostname = base::Sys.info()[["nodename"]])
[10:22:44.175]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:44.175]                           info)
[10:22:44.175]                         info <- base::paste(info, collapse = "; ")
[10:22:44.175]                         if (!has_future) {
[10:22:44.175]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:44.175]                             info)
[10:22:44.175]                         }
[10:22:44.175]                         else {
[10:22:44.175]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:44.175]                             info, version)
[10:22:44.175]                         }
[10:22:44.175]                         base::stop(msg)
[10:22:44.175]                       }
[10:22:44.175]                     })
[10:22:44.175]                   }
[10:22:44.175]                   options(future.plan = NULL)
[10:22:44.175]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.175]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:44.175]                 }
[10:22:44.175]                 ...future.workdir <- getwd()
[10:22:44.175]             }
[10:22:44.175]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:44.175]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:44.175]         }
[10:22:44.175]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:44.175]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:44.175]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:44.175]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:44.175]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:44.175]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:44.175]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:44.175]             base::names(...future.oldOptions))
[10:22:44.175]     }
[10:22:44.175]     if (FALSE) {
[10:22:44.175]     }
[10:22:44.175]     else {
[10:22:44.175]         if (TRUE) {
[10:22:44.175]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:44.175]                 open = "w")
[10:22:44.175]         }
[10:22:44.175]         else {
[10:22:44.175]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:44.175]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:44.175]         }
[10:22:44.175]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:44.175]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:44.175]             base::sink(type = "output", split = FALSE)
[10:22:44.175]             base::close(...future.stdout)
[10:22:44.175]         }, add = TRUE)
[10:22:44.175]     }
[10:22:44.175]     ...future.frame <- base::sys.nframe()
[10:22:44.175]     ...future.conditions <- base::list()
[10:22:44.175]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:44.175]     if (FALSE) {
[10:22:44.175]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:44.175]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:44.175]     }
[10:22:44.175]     ...future.result <- base::tryCatch({
[10:22:44.175]         base::withCallingHandlers({
[10:22:44.175]             ...future.value <- base::withVisible(base::local({
[10:22:44.175]                 do.call(function(...) {
[10:22:44.175]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.175]                   if (!identical(...future.globals.maxSize.org, 
[10:22:44.175]                     ...future.globals.maxSize)) {
[10:22:44.175]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.175]                     on.exit(options(oopts), add = TRUE)
[10:22:44.175]                   }
[10:22:44.175]                   {
[10:22:44.175]                     lapply(seq_along(...future.elements_ii), 
[10:22:44.175]                       FUN = function(jj) {
[10:22:44.175]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.175]                         ...future.FUN(...future.X_jj, ...)
[10:22:44.175]                       })
[10:22:44.175]                   }
[10:22:44.175]                 }, args = future.call.arguments)
[10:22:44.175]             }))
[10:22:44.175]             future::FutureResult(value = ...future.value$value, 
[10:22:44.175]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.175]                   ...future.rng), globalenv = if (FALSE) 
[10:22:44.175]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:44.175]                     ...future.globalenv.names))
[10:22:44.175]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:44.175]         }, condition = base::local({
[10:22:44.175]             c <- base::c
[10:22:44.175]             inherits <- base::inherits
[10:22:44.175]             invokeRestart <- base::invokeRestart
[10:22:44.175]             length <- base::length
[10:22:44.175]             list <- base::list
[10:22:44.175]             seq.int <- base::seq.int
[10:22:44.175]             signalCondition <- base::signalCondition
[10:22:44.175]             sys.calls <- base::sys.calls
[10:22:44.175]             `[[` <- base::`[[`
[10:22:44.175]             `+` <- base::`+`
[10:22:44.175]             `<<-` <- base::`<<-`
[10:22:44.175]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:44.175]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:44.175]                   3L)]
[10:22:44.175]             }
[10:22:44.175]             function(cond) {
[10:22:44.175]                 is_error <- inherits(cond, "error")
[10:22:44.175]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:44.175]                   NULL)
[10:22:44.175]                 if (is_error) {
[10:22:44.175]                   sessionInformation <- function() {
[10:22:44.175]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:44.175]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:44.175]                       search = base::search(), system = base::Sys.info())
[10:22:44.175]                   }
[10:22:44.175]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.175]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:44.175]                     cond$call), session = sessionInformation(), 
[10:22:44.175]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:44.175]                   signalCondition(cond)
[10:22:44.175]                 }
[10:22:44.175]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:44.175]                 "immediateCondition"))) {
[10:22:44.175]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:44.175]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.175]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:44.175]                   if (TRUE && !signal) {
[10:22:44.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.175]                     {
[10:22:44.175]                       inherits <- base::inherits
[10:22:44.175]                       invokeRestart <- base::invokeRestart
[10:22:44.175]                       is.null <- base::is.null
[10:22:44.175]                       muffled <- FALSE
[10:22:44.175]                       if (inherits(cond, "message")) {
[10:22:44.175]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.175]                         if (muffled) 
[10:22:44.175]                           invokeRestart("muffleMessage")
[10:22:44.175]                       }
[10:22:44.175]                       else if (inherits(cond, "warning")) {
[10:22:44.175]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.175]                         if (muffled) 
[10:22:44.175]                           invokeRestart("muffleWarning")
[10:22:44.175]                       }
[10:22:44.175]                       else if (inherits(cond, "condition")) {
[10:22:44.175]                         if (!is.null(pattern)) {
[10:22:44.175]                           computeRestarts <- base::computeRestarts
[10:22:44.175]                           grepl <- base::grepl
[10:22:44.175]                           restarts <- computeRestarts(cond)
[10:22:44.175]                           for (restart in restarts) {
[10:22:44.175]                             name <- restart$name
[10:22:44.175]                             if (is.null(name)) 
[10:22:44.175]                               next
[10:22:44.175]                             if (!grepl(pattern, name)) 
[10:22:44.175]                               next
[10:22:44.175]                             invokeRestart(restart)
[10:22:44.175]                             muffled <- TRUE
[10:22:44.175]                             break
[10:22:44.175]                           }
[10:22:44.175]                         }
[10:22:44.175]                       }
[10:22:44.175]                       invisible(muffled)
[10:22:44.175]                     }
[10:22:44.175]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.175]                   }
[10:22:44.175]                 }
[10:22:44.175]                 else {
[10:22:44.175]                   if (TRUE) {
[10:22:44.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.175]                     {
[10:22:44.175]                       inherits <- base::inherits
[10:22:44.175]                       invokeRestart <- base::invokeRestart
[10:22:44.175]                       is.null <- base::is.null
[10:22:44.175]                       muffled <- FALSE
[10:22:44.175]                       if (inherits(cond, "message")) {
[10:22:44.175]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.175]                         if (muffled) 
[10:22:44.175]                           invokeRestart("muffleMessage")
[10:22:44.175]                       }
[10:22:44.175]                       else if (inherits(cond, "warning")) {
[10:22:44.175]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.175]                         if (muffled) 
[10:22:44.175]                           invokeRestart("muffleWarning")
[10:22:44.175]                       }
[10:22:44.175]                       else if (inherits(cond, "condition")) {
[10:22:44.175]                         if (!is.null(pattern)) {
[10:22:44.175]                           computeRestarts <- base::computeRestarts
[10:22:44.175]                           grepl <- base::grepl
[10:22:44.175]                           restarts <- computeRestarts(cond)
[10:22:44.175]                           for (restart in restarts) {
[10:22:44.175]                             name <- restart$name
[10:22:44.175]                             if (is.null(name)) 
[10:22:44.175]                               next
[10:22:44.175]                             if (!grepl(pattern, name)) 
[10:22:44.175]                               next
[10:22:44.175]                             invokeRestart(restart)
[10:22:44.175]                             muffled <- TRUE
[10:22:44.175]                             break
[10:22:44.175]                           }
[10:22:44.175]                         }
[10:22:44.175]                       }
[10:22:44.175]                       invisible(muffled)
[10:22:44.175]                     }
[10:22:44.175]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.175]                   }
[10:22:44.175]                 }
[10:22:44.175]             }
[10:22:44.175]         }))
[10:22:44.175]     }, error = function(ex) {
[10:22:44.175]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:44.175]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.175]                 ...future.rng), started = ...future.startTime, 
[10:22:44.175]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:44.175]             version = "1.8"), class = "FutureResult")
[10:22:44.175]     }, finally = {
[10:22:44.175]         if (!identical(...future.workdir, getwd())) 
[10:22:44.175]             setwd(...future.workdir)
[10:22:44.175]         {
[10:22:44.175]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:44.175]                 ...future.oldOptions$nwarnings <- NULL
[10:22:44.175]             }
[10:22:44.175]             base::options(...future.oldOptions)
[10:22:44.175]             if (.Platform$OS.type == "windows") {
[10:22:44.175]                 old_names <- names(...future.oldEnvVars)
[10:22:44.175]                 envs <- base::Sys.getenv()
[10:22:44.175]                 names <- names(envs)
[10:22:44.175]                 common <- intersect(names, old_names)
[10:22:44.175]                 added <- setdiff(names, old_names)
[10:22:44.175]                 removed <- setdiff(old_names, names)
[10:22:44.175]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:44.175]                   envs[common]]
[10:22:44.175]                 NAMES <- toupper(changed)
[10:22:44.175]                 args <- list()
[10:22:44.175]                 for (kk in seq_along(NAMES)) {
[10:22:44.175]                   name <- changed[[kk]]
[10:22:44.175]                   NAME <- NAMES[[kk]]
[10:22:44.175]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.175]                     next
[10:22:44.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.175]                 }
[10:22:44.175]                 NAMES <- toupper(added)
[10:22:44.175]                 for (kk in seq_along(NAMES)) {
[10:22:44.175]                   name <- added[[kk]]
[10:22:44.175]                   NAME <- NAMES[[kk]]
[10:22:44.175]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.175]                     next
[10:22:44.175]                   args[[name]] <- ""
[10:22:44.175]                 }
[10:22:44.175]                 NAMES <- toupper(removed)
[10:22:44.175]                 for (kk in seq_along(NAMES)) {
[10:22:44.175]                   name <- removed[[kk]]
[10:22:44.175]                   NAME <- NAMES[[kk]]
[10:22:44.175]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.175]                     next
[10:22:44.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.175]                 }
[10:22:44.175]                 if (length(args) > 0) 
[10:22:44.175]                   base::do.call(base::Sys.setenv, args = args)
[10:22:44.175]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:44.175]             }
[10:22:44.175]             else {
[10:22:44.175]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:44.175]             }
[10:22:44.175]             {
[10:22:44.175]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:44.175]                   0L) {
[10:22:44.175]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:44.175]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:44.175]                   base::options(opts)
[10:22:44.175]                 }
[10:22:44.175]                 {
[10:22:44.175]                   {
[10:22:44.175]                     NULL
[10:22:44.175]                     RNGkind("Mersenne-Twister")
[10:22:44.175]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:44.175]                       inherits = FALSE)
[10:22:44.175]                   }
[10:22:44.175]                   options(future.plan = NULL)
[10:22:44.175]                   if (is.na(NA_character_)) 
[10:22:44.175]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.175]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:44.175]                   future::plan(list(function (..., envir = parent.frame()) 
[10:22:44.175]                   {
[10:22:44.175]                     future <- SequentialFuture(..., envir = envir)
[10:22:44.175]                     if (!future$lazy) 
[10:22:44.175]                       future <- run(future)
[10:22:44.175]                     invisible(future)
[10:22:44.175]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:44.175]                 }
[10:22:44.175]             }
[10:22:44.175]         }
[10:22:44.175]     })
[10:22:44.175]     if (TRUE) {
[10:22:44.175]         base::sink(type = "output", split = FALSE)
[10:22:44.175]         if (TRUE) {
[10:22:44.175]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:44.175]         }
[10:22:44.175]         else {
[10:22:44.175]             ...future.result["stdout"] <- base::list(NULL)
[10:22:44.175]         }
[10:22:44.175]         base::close(...future.stdout)
[10:22:44.175]         ...future.stdout <- NULL
[10:22:44.175]     }
[10:22:44.175]     ...future.result$conditions <- ...future.conditions
[10:22:44.175]     ...future.result$finished <- base::Sys.time()
[10:22:44.175]     ...future.result
[10:22:44.175] }
[10:22:44.176] assign_globals() ...
[10:22:44.176] List of 5
[10:22:44.176]  $ future.call.arguments    : list()
[10:22:44.176]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.176]  $ ...future.FUN            :function (x)  
[10:22:44.176]  $ ...future.elements_ii    :List of 2
[10:22:44.176]   ..$ : int [1:2] 1 3
[10:22:44.176]   ..$ : int [1:2] 2 4
[10:22:44.176]  $ ...future.seeds_ii       : NULL
[10:22:44.176]  $ ...future.globals.maxSize: num Inf
[10:22:44.176]  - attr(*, "resolved")= logi FALSE
[10:22:44.176]  - attr(*, "total_size")= num NA
[10:22:44.176]  - attr(*, "where")=List of 5
[10:22:44.176]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:44.176]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:44.176]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:44.176]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:44.176]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:44.176]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.176]  - attr(*, "already-done")= logi TRUE
[10:22:44.181] - copied ‘future.call.arguments’ to environment
[10:22:44.181] - reassign environment for ‘...future.FUN’
[10:22:44.181] - copied ‘...future.FUN’ to environment
[10:22:44.182] - copied ‘...future.elements_ii’ to environment
[10:22:44.182] - copied ‘...future.seeds_ii’ to environment
[10:22:44.182] - copied ‘...future.globals.maxSize’ to environment
[10:22:44.182] assign_globals() ... done
[10:22:44.182] plan(): Setting new future strategy stack:
[10:22:44.182] List of future strategies:
[10:22:44.182] 1. sequential:
[10:22:44.182]    - args: function (..., envir = parent.frame())
[10:22:44.182]    - tweaked: FALSE
[10:22:44.182]    - call: NULL
[10:22:44.182] plan(): nbrOfWorkers() = 1
[10:22:44.183] plan(): Setting new future strategy stack:
[10:22:44.183] List of future strategies:
[10:22:44.183] 1. sequential:
[10:22:44.183]    - args: function (..., envir = parent.frame())
[10:22:44.183]    - tweaked: FALSE
[10:22:44.183]    - call: plan(strategy)
[10:22:44.184] plan(): nbrOfWorkers() = 1
[10:22:44.184] SequentialFuture started (and completed)
[10:22:44.184] - Launch lazy future ... done
[10:22:44.184] run() for ‘SequentialFuture’ ... done
[10:22:44.184] Created future:
[10:22:44.184] SequentialFuture:
[10:22:44.184] Label: ‘future_apply-1’
[10:22:44.184] Expression:
[10:22:44.184] {
[10:22:44.184]     do.call(function(...) {
[10:22:44.184]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.184]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:44.184]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.184]             on.exit(options(oopts), add = TRUE)
[10:22:44.184]         }
[10:22:44.184]         {
[10:22:44.184]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:44.184]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.184]                 ...future.FUN(...future.X_jj, ...)
[10:22:44.184]             })
[10:22:44.184]         }
[10:22:44.184]     }, args = future.call.arguments)
[10:22:44.184] }
[10:22:44.184] Lazy evaluation: FALSE
[10:22:44.184] Asynchronous evaluation: FALSE
[10:22:44.184] Local evaluation: TRUE
[10:22:44.184] Environment: R_GlobalEnv
[10:22:44.184] Capture standard output: TRUE
[10:22:44.184] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:44.184] Globals: 5 objects totaling 9.82 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:44.184] Packages: <none>
[10:22:44.184] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:44.184] Resolved: TRUE
[10:22:44.184] Value: 400 bytes of class ‘list’
[10:22:44.184] Early signaling: FALSE
[10:22:44.184] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:44.184] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:44.185] Chunk #1 of 1 ... DONE
[10:22:44.185] Launching 1 futures (chunks) ... DONE
[10:22:44.185] Resolving 1 futures (chunks) ...
[10:22:44.185] resolve() on list ...
[10:22:44.186]  recursive: 0
[10:22:44.186]  length: 1
[10:22:44.186] 
[10:22:44.186] resolved() for ‘SequentialFuture’ ...
[10:22:44.186] - state: ‘finished’
[10:22:44.186] - run: TRUE
[10:22:44.186] - result: ‘FutureResult’
[10:22:44.186] resolved() for ‘SequentialFuture’ ... done
[10:22:44.186] Future #1
[10:22:44.186] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:44.186] - nx: 1
[10:22:44.187] - relay: TRUE
[10:22:44.187] - stdout: TRUE
[10:22:44.187] - signal: TRUE
[10:22:44.187] - resignal: FALSE
[10:22:44.187] - force: TRUE
[10:22:44.187] - relayed: [n=1] FALSE
[10:22:44.187] - queued futures: [n=1] FALSE
[10:22:44.187]  - until=1
[10:22:44.187]  - relaying element #1
[10:22:44.187] - relayed: [n=1] TRUE
[10:22:44.187] - queued futures: [n=1] TRUE
[10:22:44.188] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:44.188]  length: 0 (resolved future 1)
[10:22:44.188] Relaying remaining futures
[10:22:44.188] signalConditionsASAP(NULL, pos=0) ...
[10:22:44.188] - nx: 1
[10:22:44.188] - relay: TRUE
[10:22:44.188] - stdout: TRUE
[10:22:44.188] - signal: TRUE
[10:22:44.188] - resignal: FALSE
[10:22:44.188] - force: TRUE
[10:22:44.188] - relayed: [n=1] TRUE
[10:22:44.188] - queued futures: [n=1] TRUE
 - flush all
[10:22:44.189] - relayed: [n=1] TRUE
[10:22:44.189] - queued futures: [n=1] TRUE
[10:22:44.189] signalConditionsASAP(NULL, pos=0) ... done
[10:22:44.189] resolve() on list ... DONE
[10:22:44.189]  - Number of value chunks collected: 1
[10:22:44.189] Resolving 1 futures (chunks) ... DONE
[10:22:44.189] Reducing values from 1 chunks ...
[10:22:44.189]  - Number of values collected after concatenation: 2
[10:22:44.189]  - Number of values expected: 2
[10:22:44.189] Reducing values from 1 chunks ... DONE
[10:22:44.190] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[10:22:44.191] getGlobalsAndPackagesXApply() ...
[10:22:44.191]  - future.globals: TRUE
[10:22:44.191] getGlobalsAndPackages() ...
[10:22:44.191] Searching for globals...
[10:22:44.194] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[10:22:44.194] Searching for globals ... DONE
[10:22:44.194] Resolving globals: FALSE
[10:22:44.195] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[10:22:44.195] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[10:22:44.195] - globals: [1] ‘FUN’
[10:22:44.195] 
[10:22:44.195] getGlobalsAndPackages() ... DONE
[10:22:44.195]  - globals found/used: [n=1] ‘FUN’
[10:22:44.196]  - needed namespaces: [n=0] 
[10:22:44.196] Finding globals ... DONE
[10:22:44.196]  - use_args: TRUE
[10:22:44.196]  - Getting '...' globals ...
[10:22:44.196] resolve() on list ...
[10:22:44.196]  recursive: 0
[10:22:44.196]  length: 1
[10:22:44.196]  elements: ‘...’
[10:22:44.196]  length: 0 (resolved future 1)
[10:22:44.197] resolve() on list ... DONE
[10:22:44.197]    - '...' content: [n=0] 
[10:22:44.197] List of 1
[10:22:44.197]  $ ...: list()
[10:22:44.197]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.197]  - attr(*, "where")=List of 1
[10:22:44.197]   ..$ ...:<environment: 0x55ca4d5148d0> 
[10:22:44.197]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.197]  - attr(*, "resolved")= logi TRUE
[10:22:44.197]  - attr(*, "total_size")= num NA
[10:22:44.199]  - Getting '...' globals ... DONE
[10:22:44.199] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:44.199] List of 2
[10:22:44.199]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[10:22:44.199]  $ ...          : list()
[10:22:44.199]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.199]  - attr(*, "where")=List of 2
[10:22:44.199]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:44.199]   ..$ ...          :<environment: 0x55ca4d5148d0> 
[10:22:44.199]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.199]  - attr(*, "resolved")= logi FALSE
[10:22:44.199]  - attr(*, "total_size")= num 36296
[10:22:44.202] Packages to be attached in all futures: [n=0] 
[10:22:44.202] getGlobalsAndPackagesXApply() ... DONE
[10:22:44.202] future_lapply() ...
[10:22:44.204] Generating random seeds ...
[10:22:44.204] Generating random seed streams for 2 elements ...
[10:22:44.205] Generating random seed streams for 2 elements ... DONE
[10:22:44.205] Generating random seeds ... DONE
[10:22:44.205] Will set RNG state on exit: 10407, -1291008175, 2077645032, -1638519490, 352845148, 798731598, 2079890645
[10:22:44.205] Number of chunks: 1
[10:22:44.205] getGlobalsAndPackagesXApply() ...
[10:22:44.205]  - future.globals: <name-value list> with names ‘list()’
[10:22:44.205]  - use_args: TRUE
[10:22:44.205] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:22:44.205] List of 2
[10:22:44.205]  $ ...          : list()
[10:22:44.205]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.205]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[10:22:44.205]  - attr(*, "where")=List of 2
[10:22:44.205]   ..$ ...          :<environment: 0x55ca4d5148d0> 
[10:22:44.205]   ..$ ...future.FUN:<environment: namespace:base> 
[10:22:44.205]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.205]  - attr(*, "resolved")= logi FALSE
[10:22:44.205]  - attr(*, "total_size")= num NA
[10:22:44.208] Packages to be attached in all futures: [n=0] 
[10:22:44.209] getGlobalsAndPackagesXApply() ... DONE
[10:22:44.209] Number of futures (= number of chunks): 1
[10:22:44.209] Launching 1 futures (chunks) ...
[10:22:44.209] Chunk #1 of 1 ...
[10:22:44.209]  - seeds: [2] <seeds>
[10:22:44.209]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.209] getGlobalsAndPackages() ...
[10:22:44.209] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.209] Resolving globals: FALSE
[10:22:44.210] Tweak future expression to call with '...' arguments ...
[10:22:44.210] {
[10:22:44.210]     do.call(function(...) {
[10:22:44.210]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.210]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:44.210]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.210]             on.exit(options(oopts), add = TRUE)
[10:22:44.210]         }
[10:22:44.210]         {
[10:22:44.210]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:44.210]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.210]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:22:44.210]                   envir = globalenv(), inherits = FALSE)
[10:22:44.210]                 ...future.FUN(...future.X_jj, ...)
[10:22:44.210]             })
[10:22:44.210]         }
[10:22:44.210]     }, args = future.call.arguments)
[10:22:44.210] }
[10:22:44.210] Tweak future expression to call with '...' arguments ... DONE
[10:22:44.210] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.210] 
[10:22:44.211] getGlobalsAndPackages() ... DONE
[10:22:44.211] run() for ‘Future’ ...
[10:22:44.211] - state: ‘created’
[10:22:44.211] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:44.212] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:44.212] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:44.212]   - Field: ‘label’
[10:22:44.212]   - Field: ‘local’
[10:22:44.212]   - Field: ‘owner’
[10:22:44.213]   - Field: ‘envir’
[10:22:44.213]   - Field: ‘packages’
[10:22:44.213]   - Field: ‘gc’
[10:22:44.213]   - Field: ‘conditions’
[10:22:44.213]   - Field: ‘expr’
[10:22:44.213]   - Field: ‘uuid’
[10:22:44.213]   - Field: ‘seed’
[10:22:44.213]   - Field: ‘version’
[10:22:44.213]   - Field: ‘result’
[10:22:44.213]   - Field: ‘asynchronous’
[10:22:44.213]   - Field: ‘calls’
[10:22:44.214]   - Field: ‘globals’
[10:22:44.214]   - Field: ‘stdout’
[10:22:44.214]   - Field: ‘earlySignal’
[10:22:44.214]   - Field: ‘lazy’
[10:22:44.214]   - Field: ‘state’
[10:22:44.214] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:44.214] - Launch lazy future ...
[10:22:44.214] Packages needed by the future expression (n = 0): <none>
[10:22:44.214] Packages needed by future strategies (n = 0): <none>
[10:22:44.215] {
[10:22:44.215]     {
[10:22:44.215]         {
[10:22:44.215]             ...future.startTime <- base::Sys.time()
[10:22:44.215]             {
[10:22:44.215]                 {
[10:22:44.215]                   {
[10:22:44.215]                     base::local({
[10:22:44.215]                       has_future <- base::requireNamespace("future", 
[10:22:44.215]                         quietly = TRUE)
[10:22:44.215]                       if (has_future) {
[10:22:44.215]                         ns <- base::getNamespace("future")
[10:22:44.215]                         version <- ns[[".package"]][["version"]]
[10:22:44.215]                         if (is.null(version)) 
[10:22:44.215]                           version <- utils::packageVersion("future")
[10:22:44.215]                       }
[10:22:44.215]                       else {
[10:22:44.215]                         version <- NULL
[10:22:44.215]                       }
[10:22:44.215]                       if (!has_future || version < "1.8.0") {
[10:22:44.215]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:44.215]                           "", base::R.version$version.string), 
[10:22:44.215]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:44.215]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:44.215]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:44.215]                             "release", "version")], collapse = " "), 
[10:22:44.215]                           hostname = base::Sys.info()[["nodename"]])
[10:22:44.215]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:44.215]                           info)
[10:22:44.215]                         info <- base::paste(info, collapse = "; ")
[10:22:44.215]                         if (!has_future) {
[10:22:44.215]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:44.215]                             info)
[10:22:44.215]                         }
[10:22:44.215]                         else {
[10:22:44.215]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:44.215]                             info, version)
[10:22:44.215]                         }
[10:22:44.215]                         base::stop(msg)
[10:22:44.215]                       }
[10:22:44.215]                     })
[10:22:44.215]                   }
[10:22:44.215]                   options(future.plan = NULL)
[10:22:44.215]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.215]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:44.215]                 }
[10:22:44.215]                 ...future.workdir <- getwd()
[10:22:44.215]             }
[10:22:44.215]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:44.215]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:44.215]         }
[10:22:44.215]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:44.215]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:44.215]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:44.215]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:44.215]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:44.215]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:44.215]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:44.215]             base::names(...future.oldOptions))
[10:22:44.215]     }
[10:22:44.215]     if (FALSE) {
[10:22:44.215]     }
[10:22:44.215]     else {
[10:22:44.215]         if (TRUE) {
[10:22:44.215]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:44.215]                 open = "w")
[10:22:44.215]         }
[10:22:44.215]         else {
[10:22:44.215]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:44.215]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:44.215]         }
[10:22:44.215]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:44.215]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:44.215]             base::sink(type = "output", split = FALSE)
[10:22:44.215]             base::close(...future.stdout)
[10:22:44.215]         }, add = TRUE)
[10:22:44.215]     }
[10:22:44.215]     ...future.frame <- base::sys.nframe()
[10:22:44.215]     ...future.conditions <- base::list()
[10:22:44.215]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:44.215]     if (FALSE) {
[10:22:44.215]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:44.215]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:44.215]     }
[10:22:44.215]     ...future.result <- base::tryCatch({
[10:22:44.215]         base::withCallingHandlers({
[10:22:44.215]             ...future.value <- base::withVisible(base::local({
[10:22:44.215]                 do.call(function(...) {
[10:22:44.215]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.215]                   if (!identical(...future.globals.maxSize.org, 
[10:22:44.215]                     ...future.globals.maxSize)) {
[10:22:44.215]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.215]                     on.exit(options(oopts), add = TRUE)
[10:22:44.215]                   }
[10:22:44.215]                   {
[10:22:44.215]                     lapply(seq_along(...future.elements_ii), 
[10:22:44.215]                       FUN = function(jj) {
[10:22:44.215]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.215]                         assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:22:44.215]                           envir = globalenv(), inherits = FALSE)
[10:22:44.215]                         ...future.FUN(...future.X_jj, ...)
[10:22:44.215]                       })
[10:22:44.215]                   }
[10:22:44.215]                 }, args = future.call.arguments)
[10:22:44.215]             }))
[10:22:44.215]             future::FutureResult(value = ...future.value$value, 
[10:22:44.215]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.215]                   ...future.rng), globalenv = if (FALSE) 
[10:22:44.215]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:44.215]                     ...future.globalenv.names))
[10:22:44.215]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:44.215]         }, condition = base::local({
[10:22:44.215]             c <- base::c
[10:22:44.215]             inherits <- base::inherits
[10:22:44.215]             invokeRestart <- base::invokeRestart
[10:22:44.215]             length <- base::length
[10:22:44.215]             list <- base::list
[10:22:44.215]             seq.int <- base::seq.int
[10:22:44.215]             signalCondition <- base::signalCondition
[10:22:44.215]             sys.calls <- base::sys.calls
[10:22:44.215]             `[[` <- base::`[[`
[10:22:44.215]             `+` <- base::`+`
[10:22:44.215]             `<<-` <- base::`<<-`
[10:22:44.215]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:44.215]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:44.215]                   3L)]
[10:22:44.215]             }
[10:22:44.215]             function(cond) {
[10:22:44.215]                 is_error <- inherits(cond, "error")
[10:22:44.215]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:44.215]                   NULL)
[10:22:44.215]                 if (is_error) {
[10:22:44.215]                   sessionInformation <- function() {
[10:22:44.215]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:44.215]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:44.215]                       search = base::search(), system = base::Sys.info())
[10:22:44.215]                   }
[10:22:44.215]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.215]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:44.215]                     cond$call), session = sessionInformation(), 
[10:22:44.215]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:44.215]                   signalCondition(cond)
[10:22:44.215]                 }
[10:22:44.215]                 else if (!ignore && FALSE && inherits(cond, NULL)) {
[10:22:44.215]                   signal <- TRUE && inherits(cond, character(0))
[10:22:44.215]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.215]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:44.215]                   if (TRUE && !signal) {
[10:22:44.215]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.215]                     {
[10:22:44.215]                       inherits <- base::inherits
[10:22:44.215]                       invokeRestart <- base::invokeRestart
[10:22:44.215]                       is.null <- base::is.null
[10:22:44.215]                       muffled <- FALSE
[10:22:44.215]                       if (inherits(cond, "message")) {
[10:22:44.215]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.215]                         if (muffled) 
[10:22:44.215]                           invokeRestart("muffleMessage")
[10:22:44.215]                       }
[10:22:44.215]                       else if (inherits(cond, "warning")) {
[10:22:44.215]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.215]                         if (muffled) 
[10:22:44.215]                           invokeRestart("muffleWarning")
[10:22:44.215]                       }
[10:22:44.215]                       else if (inherits(cond, "condition")) {
[10:22:44.215]                         if (!is.null(pattern)) {
[10:22:44.215]                           computeRestarts <- base::computeRestarts
[10:22:44.215]                           grepl <- base::grepl
[10:22:44.215]                           restarts <- computeRestarts(cond)
[10:22:44.215]                           for (restart in restarts) {
[10:22:44.215]                             name <- restart$name
[10:22:44.215]                             if (is.null(name)) 
[10:22:44.215]                               next
[10:22:44.215]                             if (!grepl(pattern, name)) 
[10:22:44.215]                               next
[10:22:44.215]                             invokeRestart(restart)
[10:22:44.215]                             muffled <- TRUE
[10:22:44.215]                             break
[10:22:44.215]                           }
[10:22:44.215]                         }
[10:22:44.215]                       }
[10:22:44.215]                       invisible(muffled)
[10:22:44.215]                     }
[10:22:44.215]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.215]                   }
[10:22:44.215]                 }
[10:22:44.215]                 else {
[10:22:44.215]                   if (FALSE) {
[10:22:44.215]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.215]                     {
[10:22:44.215]                       inherits <- base::inherits
[10:22:44.215]                       invokeRestart <- base::invokeRestart
[10:22:44.215]                       is.null <- base::is.null
[10:22:44.215]                       muffled <- FALSE
[10:22:44.215]                       if (inherits(cond, "message")) {
[10:22:44.215]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.215]                         if (muffled) 
[10:22:44.215]                           invokeRestart("muffleMessage")
[10:22:44.215]                       }
[10:22:44.215]                       else if (inherits(cond, "warning")) {
[10:22:44.215]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.215]                         if (muffled) 
[10:22:44.215]                           invokeRestart("muffleWarning")
[10:22:44.215]                       }
[10:22:44.215]                       else if (inherits(cond, "condition")) {
[10:22:44.215]                         if (!is.null(pattern)) {
[10:22:44.215]                           computeRestarts <- base::computeRestarts
[10:22:44.215]                           grepl <- base::grepl
[10:22:44.215]                           restarts <- computeRestarts(cond)
[10:22:44.215]                           for (restart in restarts) {
[10:22:44.215]                             name <- restart$name
[10:22:44.215]                             if (is.null(name)) 
[10:22:44.215]                               next
[10:22:44.215]                             if (!grepl(pattern, name)) 
[10:22:44.215]                               next
[10:22:44.215]                             invokeRestart(restart)
[10:22:44.215]                             muffled <- TRUE
[10:22:44.215]                             break
[10:22:44.215]                           }
[10:22:44.215]                         }
[10:22:44.215]                       }
[10:22:44.215]                       invisible(muffled)
[10:22:44.215]                     }
[10:22:44.215]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.215]                   }
[10:22:44.215]                 }
[10:22:44.215]             }
[10:22:44.215]         }))
[10:22:44.215]     }, error = function(ex) {
[10:22:44.215]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:44.215]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.215]                 ...future.rng), started = ...future.startTime, 
[10:22:44.215]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:44.215]             version = "1.8"), class = "FutureResult")
[10:22:44.215]     }, finally = {
[10:22:44.215]         if (!identical(...future.workdir, getwd())) 
[10:22:44.215]             setwd(...future.workdir)
[10:22:44.215]         {
[10:22:44.215]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:44.215]                 ...future.oldOptions$nwarnings <- NULL
[10:22:44.215]             }
[10:22:44.215]             base::options(...future.oldOptions)
[10:22:44.215]             if (.Platform$OS.type == "windows") {
[10:22:44.215]                 old_names <- names(...future.oldEnvVars)
[10:22:44.215]                 envs <- base::Sys.getenv()
[10:22:44.215]                 names <- names(envs)
[10:22:44.215]                 common <- intersect(names, old_names)
[10:22:44.215]                 added <- setdiff(names, old_names)
[10:22:44.215]                 removed <- setdiff(old_names, names)
[10:22:44.215]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:44.215]                   envs[common]]
[10:22:44.215]                 NAMES <- toupper(changed)
[10:22:44.215]                 args <- list()
[10:22:44.215]                 for (kk in seq_along(NAMES)) {
[10:22:44.215]                   name <- changed[[kk]]
[10:22:44.215]                   NAME <- NAMES[[kk]]
[10:22:44.215]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.215]                     next
[10:22:44.215]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.215]                 }
[10:22:44.215]                 NAMES <- toupper(added)
[10:22:44.215]                 for (kk in seq_along(NAMES)) {
[10:22:44.215]                   name <- added[[kk]]
[10:22:44.215]                   NAME <- NAMES[[kk]]
[10:22:44.215]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.215]                     next
[10:22:44.215]                   args[[name]] <- ""
[10:22:44.215]                 }
[10:22:44.215]                 NAMES <- toupper(removed)
[10:22:44.215]                 for (kk in seq_along(NAMES)) {
[10:22:44.215]                   name <- removed[[kk]]
[10:22:44.215]                   NAME <- NAMES[[kk]]
[10:22:44.215]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.215]                     next
[10:22:44.215]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.215]                 }
[10:22:44.215]                 if (length(args) > 0) 
[10:22:44.215]                   base::do.call(base::Sys.setenv, args = args)
[10:22:44.215]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:44.215]             }
[10:22:44.215]             else {
[10:22:44.215]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:44.215]             }
[10:22:44.215]             {
[10:22:44.215]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:44.215]                   0L) {
[10:22:44.215]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:44.215]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:44.215]                   base::options(opts)
[10:22:44.215]                 }
[10:22:44.215]                 {
[10:22:44.215]                   {
[10:22:44.215]                     base::assign(".Random.seed", c(10407L, -1291008175L, 
[10:22:44.215]                     2077645032L, -1638519490L, 352845148L, 798731598L, 
[10:22:44.215]                     2079890645L), envir = base::globalenv(), 
[10:22:44.215]                       inherits = FALSE)
[10:22:44.215]                     NULL
[10:22:44.215]                   }
[10:22:44.215]                   options(future.plan = NULL)
[10:22:44.215]                   if (is.na(NA_character_)) 
[10:22:44.215]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.215]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:44.215]                   future::plan(list(function (..., envir = parent.frame()) 
[10:22:44.215]                   {
[10:22:44.215]                     future <- SequentialFuture(..., envir = envir)
[10:22:44.215]                     if (!future$lazy) 
[10:22:44.215]                       future <- run(future)
[10:22:44.215]                     invisible(future)
[10:22:44.215]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:44.215]                 }
[10:22:44.215]             }
[10:22:44.215]         }
[10:22:44.215]     })
[10:22:44.215]     if (TRUE) {
[10:22:44.215]         base::sink(type = "output", split = FALSE)
[10:22:44.215]         if (TRUE) {
[10:22:44.215]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:44.215]         }
[10:22:44.215]         else {
[10:22:44.215]             ...future.result["stdout"] <- base::list(NULL)
[10:22:44.215]         }
[10:22:44.215]         base::close(...future.stdout)
[10:22:44.215]         ...future.stdout <- NULL
[10:22:44.215]     }
[10:22:44.215]     ...future.result$conditions <- ...future.conditions
[10:22:44.215]     ...future.result$finished <- base::Sys.time()
[10:22:44.215]     ...future.result
[10:22:44.215] }
[10:22:44.216] assign_globals() ...
[10:22:44.216] List of 5
[10:22:44.216]  $ future.call.arguments    : list()
[10:22:44.216]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.216]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[10:22:44.216]  $ ...future.elements_ii    :List of 2
[10:22:44.216]   ..$ : int [1:2] 1 3
[10:22:44.216]   ..$ : int [1:2] 2 4
[10:22:44.216]  $ ...future.seeds_ii       :List of 2
[10:22:44.216]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[10:22:44.216]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[10:22:44.216]  $ ...future.globals.maxSize: num Inf
[10:22:44.216]  - attr(*, "resolved")= logi FALSE
[10:22:44.216]  - attr(*, "total_size")= num NA
[10:22:44.216]  - attr(*, "where")=List of 5
[10:22:44.216]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:44.216]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:44.216]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:44.216]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:44.216]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:44.216]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.216]  - attr(*, "already-done")= logi TRUE
[10:22:44.222] - copied ‘future.call.arguments’ to environment
[10:22:44.222] - copied ‘...future.FUN’ to environment
[10:22:44.222] - copied ‘...future.elements_ii’ to environment
[10:22:44.222] - copied ‘...future.seeds_ii’ to environment
[10:22:44.222] - copied ‘...future.globals.maxSize’ to environment
[10:22:44.222] assign_globals() ... done
[10:22:44.222] plan(): Setting new future strategy stack:
[10:22:44.223] List of future strategies:
[10:22:44.223] 1. sequential:
[10:22:44.223]    - args: function (..., envir = parent.frame())
[10:22:44.223]    - tweaked: FALSE
[10:22:44.223]    - call: NULL
[10:22:44.223] plan(): nbrOfWorkers() = 1
[10:22:44.224] plan(): Setting new future strategy stack:
[10:22:44.224] List of future strategies:
[10:22:44.224] 1. sequential:
[10:22:44.224]    - args: function (..., envir = parent.frame())
[10:22:44.224]    - tweaked: FALSE
[10:22:44.224]    - call: plan(strategy)
[10:22:44.224] plan(): nbrOfWorkers() = 1
[10:22:44.224] SequentialFuture started (and completed)
[10:22:44.224] - Launch lazy future ... done
[10:22:44.224] run() for ‘SequentialFuture’ ... done
[10:22:44.224] Created future:
[10:22:44.225] SequentialFuture:
[10:22:44.225] Label: ‘future_apply-1’
[10:22:44.225] Expression:
[10:22:44.225] {
[10:22:44.225]     do.call(function(...) {
[10:22:44.225]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.225]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:44.225]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.225]             on.exit(options(oopts), add = TRUE)
[10:22:44.225]         }
[10:22:44.225]         {
[10:22:44.225]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:44.225]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.225]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:22:44.225]                   envir = globalenv(), inherits = FALSE)
[10:22:44.225]                 ...future.FUN(...future.X_jj, ...)
[10:22:44.225]             })
[10:22:44.225]         }
[10:22:44.225]     }, args = future.call.arguments)
[10:22:44.225] }
[10:22:44.225] Lazy evaluation: FALSE
[10:22:44.225] Asynchronous evaluation: FALSE
[10:22:44.225] Local evaluation: TRUE
[10:22:44.225] Environment: R_GlobalEnv
[10:22:44.225] Capture standard output: TRUE
[10:22:44.225] Capture condition classes: <none>
[10:22:44.225] Globals: 5 objects totaling 35.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 112 bytes, list ‘...future.seeds_ii’ of 160 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:44.225] Packages: <none>
[10:22:44.225] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:22:44.225] Resolved: TRUE
[10:22:44.225] Value: 112 bytes of class ‘list’
[10:22:44.225] Early signaling: FALSE
[10:22:44.225] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:44.225] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:44.225] Chunk #1 of 1 ... DONE
[10:22:44.226] Launching 1 futures (chunks) ... DONE
[10:22:44.226] Resolving 1 futures (chunks) ...
[10:22:44.226] resolve() on list ...
[10:22:44.226]  recursive: 0
[10:22:44.226]  length: 1
[10:22:44.226] 
[10:22:44.226] resolved() for ‘SequentialFuture’ ...
[10:22:44.226] - state: ‘finished’
[10:22:44.226] - run: TRUE
[10:22:44.226] - result: ‘FutureResult’
[10:22:44.226] resolved() for ‘SequentialFuture’ ... done
[10:22:44.227] Future #1
[10:22:44.227] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:22:44.227] - nx: 1
[10:22:44.227] - relay: TRUE
[10:22:44.227] - stdout: TRUE
[10:22:44.227] - signal: TRUE
[10:22:44.227] - resignal: FALSE
[10:22:44.227] - force: TRUE
[10:22:44.227] - relayed: [n=1] FALSE
[10:22:44.227] - queued futures: [n=1] FALSE
[10:22:44.227]  - until=1
[10:22:44.227]  - relaying element #1
[10:22:44.228] - relayed: [n=1] TRUE
[10:22:44.228] - queued futures: [n=1] TRUE
[10:22:44.228] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:22:44.228]  length: 0 (resolved future 1)
[10:22:44.228] Relaying remaining futures
[10:22:44.228] signalConditionsASAP(NULL, pos=0) ...
[10:22:44.228] - nx: 1
[10:22:44.228] - relay: TRUE
[10:22:44.228] - stdout: TRUE
[10:22:44.228] - signal: TRUE
[10:22:44.228] - resignal: FALSE
[10:22:44.229] - force: TRUE
[10:22:44.229] - relayed: [n=1] TRUE
[10:22:44.229] - queued futures: [n=1] TRUE
 - flush all
[10:22:44.229] - relayed: [n=1] TRUE
[10:22:44.229] - queued futures: [n=1] TRUE
[10:22:44.229] signalConditionsASAP(NULL, pos=0) ... done
[10:22:44.229] resolve() on list ... DONE
[10:22:44.229]  - Number of value chunks collected: 1
[10:22:44.229] Resolving 1 futures (chunks) ... DONE
[10:22:44.229] Reducing values from 1 chunks ...
[10:22:44.229]  - Number of values collected after concatenation: 2
[10:22:44.230]  - Number of values expected: 2
[10:22:44.230] Reducing values from 1 chunks ... DONE
[10:22:44.230] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[10:22:44.230] plan(): Setting new future strategy stack:
[10:22:44.230] List of future strategies:
[10:22:44.230] 1. sequential:
[10:22:44.230]    - args: function (..., envir = parent.frame())
[10:22:44.230]    - tweaked: FALSE
[10:22:44.230]    - call: plan(sequential)
[10:22:44.230] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[10:22:44.231] plan(): Setting new future strategy stack:
[10:22:44.231] List of future strategies:
[10:22:44.231] 1. multicore:
[10:22:44.231]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:44.231]    - tweaked: FALSE
[10:22:44.231]    - call: plan(strategy)
[10:22:44.235] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[10:22:44.235] getGlobalsAndPackagesXApply() ...
[10:22:44.235]  - future.globals: TRUE
[10:22:44.236] getGlobalsAndPackages() ...
[10:22:44.236] Searching for globals...
[10:22:44.269] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[10:22:44.269] Searching for globals ... DONE
[10:22:44.269] Resolving globals: FALSE
[10:22:44.272] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[10:22:44.272] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[10:22:44.272] - globals: [1] ‘FUN’
[10:22:44.272] 
[10:22:44.272] getGlobalsAndPackages() ... DONE
[10:22:44.272]  - globals found/used: [n=1] ‘FUN’
[10:22:44.272]  - needed namespaces: [n=0] 
[10:22:44.273] Finding globals ... DONE
[10:22:44.273]  - use_args: TRUE
[10:22:44.273]  - Getting '...' globals ...
[10:22:44.273] resolve() on list ...
[10:22:44.273]  recursive: 0
[10:22:44.273]  length: 1
[10:22:44.273]  elements: ‘...’
[10:22:44.273]  length: 0 (resolved future 1)
[10:22:44.274] resolve() on list ... DONE
[10:22:44.274]    - '...' content: [n=0] 
[10:22:44.274] List of 1
[10:22:44.274]  $ ...: list()
[10:22:44.274]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.274]  - attr(*, "where")=List of 1
[10:22:44.274]   ..$ ...:<environment: 0x55ca4d42c340> 
[10:22:44.274]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.274]  - attr(*, "resolved")= logi TRUE
[10:22:44.274]  - attr(*, "total_size")= num NA
[10:22:44.276]  - Getting '...' globals ... DONE
[10:22:44.276] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:44.276] List of 2
[10:22:44.276]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:22:44.276]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:22:44.276]  $ ...          : list()
[10:22:44.276]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.276]  - attr(*, "where")=List of 2
[10:22:44.276]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:44.276]   ..$ ...          :<environment: 0x55ca4d42c340> 
[10:22:44.276]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.276]  - attr(*, "resolved")= logi FALSE
[10:22:44.276]  - attr(*, "total_size")= num 354224
[10:22:44.279] Packages to be attached in all futures: [n=0] 
[10:22:44.279] getGlobalsAndPackagesXApply() ... DONE
[10:22:44.283] future_lapply() ...
[10:22:44.319] Number of chunks: 2
[10:22:44.319] getGlobalsAndPackagesXApply() ...
[10:22:44.319]  - future.globals: <name-value list> with names ‘list()’
[10:22:44.319]  - use_args: TRUE
[10:22:44.319] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:22:44.319] List of 2
[10:22:44.319]  $ ...          : list()
[10:22:44.319]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.319]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:22:44.319]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:22:44.319]  - attr(*, "where")=List of 2
[10:22:44.319]   ..$ ...          :<environment: 0x55ca4d42c340> 
[10:22:44.319]   ..$ ...future.FUN:<environment: namespace:base> 
[10:22:44.319]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.319]  - attr(*, "resolved")= logi FALSE
[10:22:44.319]  - attr(*, "total_size")= num NA
[10:22:44.323] Packages to be attached in all futures: [n=0] 
[10:22:44.323] getGlobalsAndPackagesXApply() ... DONE
[10:22:44.323] Number of futures (= number of chunks): 2
[10:22:44.323] Launching 2 futures (chunks) ...
[10:22:44.323] Chunk #1 of 2 ...
[10:22:44.323]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:44.323]  - seeds: <none>
[10:22:44.323]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.324] getGlobalsAndPackages() ...
[10:22:44.324] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.324] Resolving globals: FALSE
[10:22:44.324] Tweak future expression to call with '...' arguments ...
[10:22:44.324] {
[10:22:44.324]     do.call(function(...) {
[10:22:44.324]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.324]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:44.324]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.324]             on.exit(options(oopts), add = TRUE)
[10:22:44.324]         }
[10:22:44.324]         {
[10:22:44.324]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:44.324]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.324]                 ...future.FUN(...future.X_jj, ...)
[10:22:44.324]             })
[10:22:44.324]         }
[10:22:44.324]     }, args = future.call.arguments)
[10:22:44.324] }
[10:22:44.324] Tweak future expression to call with '...' arguments ... DONE
[10:22:44.325] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.325] 
[10:22:44.325] getGlobalsAndPackages() ... DONE
[10:22:44.325] run() for ‘Future’ ...
[10:22:44.325] - state: ‘created’
[10:22:44.325] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:44.329] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:44.329] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:44.329]   - Field: ‘label’
[10:22:44.329]   - Field: ‘local’
[10:22:44.329]   - Field: ‘owner’
[10:22:44.329]   - Field: ‘envir’
[10:22:44.329]   - Field: ‘workers’
[10:22:44.330]   - Field: ‘packages’
[10:22:44.330]   - Field: ‘gc’
[10:22:44.330]   - Field: ‘job’
[10:22:44.330]   - Field: ‘conditions’
[10:22:44.330]   - Field: ‘expr’
[10:22:44.330]   - Field: ‘uuid’
[10:22:44.330]   - Field: ‘seed’
[10:22:44.330]   - Field: ‘version’
[10:22:44.330]   - Field: ‘result’
[10:22:44.330]   - Field: ‘asynchronous’
[10:22:44.330]   - Field: ‘calls’
[10:22:44.331]   - Field: ‘globals’
[10:22:44.331]   - Field: ‘stdout’
[10:22:44.331]   - Field: ‘earlySignal’
[10:22:44.331]   - Field: ‘lazy’
[10:22:44.331]   - Field: ‘state’
[10:22:44.331] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:44.331] - Launch lazy future ...
[10:22:44.332] Packages needed by the future expression (n = 0): <none>
[10:22:44.332] Packages needed by future strategies (n = 0): <none>
[10:22:44.333] {
[10:22:44.333]     {
[10:22:44.333]         {
[10:22:44.333]             ...future.startTime <- base::Sys.time()
[10:22:44.333]             {
[10:22:44.333]                 {
[10:22:44.333]                   {
[10:22:44.333]                     {
[10:22:44.333]                       base::local({
[10:22:44.333]                         has_future <- base::requireNamespace("future", 
[10:22:44.333]                           quietly = TRUE)
[10:22:44.333]                         if (has_future) {
[10:22:44.333]                           ns <- base::getNamespace("future")
[10:22:44.333]                           version <- ns[[".package"]][["version"]]
[10:22:44.333]                           if (is.null(version)) 
[10:22:44.333]                             version <- utils::packageVersion("future")
[10:22:44.333]                         }
[10:22:44.333]                         else {
[10:22:44.333]                           version <- NULL
[10:22:44.333]                         }
[10:22:44.333]                         if (!has_future || version < "1.8.0") {
[10:22:44.333]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:44.333]                             "", base::R.version$version.string), 
[10:22:44.333]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:44.333]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:44.333]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:44.333]                               "release", "version")], collapse = " "), 
[10:22:44.333]                             hostname = base::Sys.info()[["nodename"]])
[10:22:44.333]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:44.333]                             info)
[10:22:44.333]                           info <- base::paste(info, collapse = "; ")
[10:22:44.333]                           if (!has_future) {
[10:22:44.333]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:44.333]                               info)
[10:22:44.333]                           }
[10:22:44.333]                           else {
[10:22:44.333]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:44.333]                               info, version)
[10:22:44.333]                           }
[10:22:44.333]                           base::stop(msg)
[10:22:44.333]                         }
[10:22:44.333]                       })
[10:22:44.333]                     }
[10:22:44.333]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:44.333]                     base::options(mc.cores = 1L)
[10:22:44.333]                   }
[10:22:44.333]                   options(future.plan = NULL)
[10:22:44.333]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.333]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:44.333]                 }
[10:22:44.333]                 ...future.workdir <- getwd()
[10:22:44.333]             }
[10:22:44.333]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:44.333]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:44.333]         }
[10:22:44.333]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:44.333]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:44.333]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:44.333]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:44.333]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:44.333]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:44.333]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:44.333]             base::names(...future.oldOptions))
[10:22:44.333]     }
[10:22:44.333]     if (FALSE) {
[10:22:44.333]     }
[10:22:44.333]     else {
[10:22:44.333]         if (TRUE) {
[10:22:44.333]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:44.333]                 open = "w")
[10:22:44.333]         }
[10:22:44.333]         else {
[10:22:44.333]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:44.333]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:44.333]         }
[10:22:44.333]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:44.333]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:44.333]             base::sink(type = "output", split = FALSE)
[10:22:44.333]             base::close(...future.stdout)
[10:22:44.333]         }, add = TRUE)
[10:22:44.333]     }
[10:22:44.333]     ...future.frame <- base::sys.nframe()
[10:22:44.333]     ...future.conditions <- base::list()
[10:22:44.333]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:44.333]     if (FALSE) {
[10:22:44.333]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:44.333]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:44.333]     }
[10:22:44.333]     ...future.result <- base::tryCatch({
[10:22:44.333]         base::withCallingHandlers({
[10:22:44.333]             ...future.value <- base::withVisible(base::local({
[10:22:44.333]                 withCallingHandlers({
[10:22:44.333]                   {
[10:22:44.333]                     do.call(function(...) {
[10:22:44.333]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.333]                       if (!identical(...future.globals.maxSize.org, 
[10:22:44.333]                         ...future.globals.maxSize)) {
[10:22:44.333]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.333]                         on.exit(options(oopts), add = TRUE)
[10:22:44.333]                       }
[10:22:44.333]                       {
[10:22:44.333]                         lapply(seq_along(...future.elements_ii), 
[10:22:44.333]                           FUN = function(jj) {
[10:22:44.333]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.333]                             ...future.FUN(...future.X_jj, ...)
[10:22:44.333]                           })
[10:22:44.333]                       }
[10:22:44.333]                     }, args = future.call.arguments)
[10:22:44.333]                   }
[10:22:44.333]                 }, immediateCondition = function(cond) {
[10:22:44.333]                   save_rds <- function (object, pathname, ...) 
[10:22:44.333]                   {
[10:22:44.333]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:44.333]                     if (file_test("-f", pathname_tmp)) {
[10:22:44.333]                       fi_tmp <- file.info(pathname_tmp)
[10:22:44.333]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:44.333]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:44.333]                         fi_tmp[["mtime"]])
[10:22:44.333]                     }
[10:22:44.333]                     tryCatch({
[10:22:44.333]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:44.333]                     }, error = function(ex) {
[10:22:44.333]                       msg <- conditionMessage(ex)
[10:22:44.333]                       fi_tmp <- file.info(pathname_tmp)
[10:22:44.333]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:44.333]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:44.333]                         fi_tmp[["mtime"]], msg)
[10:22:44.333]                       ex$message <- msg
[10:22:44.333]                       stop(ex)
[10:22:44.333]                     })
[10:22:44.333]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:44.333]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:44.333]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:44.333]                       fi_tmp <- file.info(pathname_tmp)
[10:22:44.333]                       fi <- file.info(pathname)
[10:22:44.333]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:44.333]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:44.333]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:44.333]                         fi[["size"]], fi[["mtime"]])
[10:22:44.333]                       stop(msg)
[10:22:44.333]                     }
[10:22:44.333]                     invisible(pathname)
[10:22:44.333]                   }
[10:22:44.333]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:44.333]                     rootPath = tempdir()) 
[10:22:44.333]                   {
[10:22:44.333]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:44.333]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:44.333]                       tmpdir = path, fileext = ".rds")
[10:22:44.333]                     save_rds(obj, file)
[10:22:44.333]                   }
[10:22:44.333]                   saveImmediateCondition(cond, path = "/tmp/RtmpTHXGJm/.future/immediateConditions")
[10:22:44.333]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.333]                   {
[10:22:44.333]                     inherits <- base::inherits
[10:22:44.333]                     invokeRestart <- base::invokeRestart
[10:22:44.333]                     is.null <- base::is.null
[10:22:44.333]                     muffled <- FALSE
[10:22:44.333]                     if (inherits(cond, "message")) {
[10:22:44.333]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:44.333]                       if (muffled) 
[10:22:44.333]                         invokeRestart("muffleMessage")
[10:22:44.333]                     }
[10:22:44.333]                     else if (inherits(cond, "warning")) {
[10:22:44.333]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:44.333]                       if (muffled) 
[10:22:44.333]                         invokeRestart("muffleWarning")
[10:22:44.333]                     }
[10:22:44.333]                     else if (inherits(cond, "condition")) {
[10:22:44.333]                       if (!is.null(pattern)) {
[10:22:44.333]                         computeRestarts <- base::computeRestarts
[10:22:44.333]                         grepl <- base::grepl
[10:22:44.333]                         restarts <- computeRestarts(cond)
[10:22:44.333]                         for (restart in restarts) {
[10:22:44.333]                           name <- restart$name
[10:22:44.333]                           if (is.null(name)) 
[10:22:44.333]                             next
[10:22:44.333]                           if (!grepl(pattern, name)) 
[10:22:44.333]                             next
[10:22:44.333]                           invokeRestart(restart)
[10:22:44.333]                           muffled <- TRUE
[10:22:44.333]                           break
[10:22:44.333]                         }
[10:22:44.333]                       }
[10:22:44.333]                     }
[10:22:44.333]                     invisible(muffled)
[10:22:44.333]                   }
[10:22:44.333]                   muffleCondition(cond)
[10:22:44.333]                 })
[10:22:44.333]             }))
[10:22:44.333]             future::FutureResult(value = ...future.value$value, 
[10:22:44.333]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.333]                   ...future.rng), globalenv = if (FALSE) 
[10:22:44.333]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:44.333]                     ...future.globalenv.names))
[10:22:44.333]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:44.333]         }, condition = base::local({
[10:22:44.333]             c <- base::c
[10:22:44.333]             inherits <- base::inherits
[10:22:44.333]             invokeRestart <- base::invokeRestart
[10:22:44.333]             length <- base::length
[10:22:44.333]             list <- base::list
[10:22:44.333]             seq.int <- base::seq.int
[10:22:44.333]             signalCondition <- base::signalCondition
[10:22:44.333]             sys.calls <- base::sys.calls
[10:22:44.333]             `[[` <- base::`[[`
[10:22:44.333]             `+` <- base::`+`
[10:22:44.333]             `<<-` <- base::`<<-`
[10:22:44.333]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:44.333]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:44.333]                   3L)]
[10:22:44.333]             }
[10:22:44.333]             function(cond) {
[10:22:44.333]                 is_error <- inherits(cond, "error")
[10:22:44.333]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:44.333]                   NULL)
[10:22:44.333]                 if (is_error) {
[10:22:44.333]                   sessionInformation <- function() {
[10:22:44.333]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:44.333]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:44.333]                       search = base::search(), system = base::Sys.info())
[10:22:44.333]                   }
[10:22:44.333]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.333]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:44.333]                     cond$call), session = sessionInformation(), 
[10:22:44.333]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:44.333]                   signalCondition(cond)
[10:22:44.333]                 }
[10:22:44.333]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:44.333]                 "immediateCondition"))) {
[10:22:44.333]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:44.333]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.333]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:44.333]                   if (TRUE && !signal) {
[10:22:44.333]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.333]                     {
[10:22:44.333]                       inherits <- base::inherits
[10:22:44.333]                       invokeRestart <- base::invokeRestart
[10:22:44.333]                       is.null <- base::is.null
[10:22:44.333]                       muffled <- FALSE
[10:22:44.333]                       if (inherits(cond, "message")) {
[10:22:44.333]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.333]                         if (muffled) 
[10:22:44.333]                           invokeRestart("muffleMessage")
[10:22:44.333]                       }
[10:22:44.333]                       else if (inherits(cond, "warning")) {
[10:22:44.333]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.333]                         if (muffled) 
[10:22:44.333]                           invokeRestart("muffleWarning")
[10:22:44.333]                       }
[10:22:44.333]                       else if (inherits(cond, "condition")) {
[10:22:44.333]                         if (!is.null(pattern)) {
[10:22:44.333]                           computeRestarts <- base::computeRestarts
[10:22:44.333]                           grepl <- base::grepl
[10:22:44.333]                           restarts <- computeRestarts(cond)
[10:22:44.333]                           for (restart in restarts) {
[10:22:44.333]                             name <- restart$name
[10:22:44.333]                             if (is.null(name)) 
[10:22:44.333]                               next
[10:22:44.333]                             if (!grepl(pattern, name)) 
[10:22:44.333]                               next
[10:22:44.333]                             invokeRestart(restart)
[10:22:44.333]                             muffled <- TRUE
[10:22:44.333]                             break
[10:22:44.333]                           }
[10:22:44.333]                         }
[10:22:44.333]                       }
[10:22:44.333]                       invisible(muffled)
[10:22:44.333]                     }
[10:22:44.333]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.333]                   }
[10:22:44.333]                 }
[10:22:44.333]                 else {
[10:22:44.333]                   if (TRUE) {
[10:22:44.333]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.333]                     {
[10:22:44.333]                       inherits <- base::inherits
[10:22:44.333]                       invokeRestart <- base::invokeRestart
[10:22:44.333]                       is.null <- base::is.null
[10:22:44.333]                       muffled <- FALSE
[10:22:44.333]                       if (inherits(cond, "message")) {
[10:22:44.333]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.333]                         if (muffled) 
[10:22:44.333]                           invokeRestart("muffleMessage")
[10:22:44.333]                       }
[10:22:44.333]                       else if (inherits(cond, "warning")) {
[10:22:44.333]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.333]                         if (muffled) 
[10:22:44.333]                           invokeRestart("muffleWarning")
[10:22:44.333]                       }
[10:22:44.333]                       else if (inherits(cond, "condition")) {
[10:22:44.333]                         if (!is.null(pattern)) {
[10:22:44.333]                           computeRestarts <- base::computeRestarts
[10:22:44.333]                           grepl <- base::grepl
[10:22:44.333]                           restarts <- computeRestarts(cond)
[10:22:44.333]                           for (restart in restarts) {
[10:22:44.333]                             name <- restart$name
[10:22:44.333]                             if (is.null(name)) 
[10:22:44.333]                               next
[10:22:44.333]                             if (!grepl(pattern, name)) 
[10:22:44.333]                               next
[10:22:44.333]                             invokeRestart(restart)
[10:22:44.333]                             muffled <- TRUE
[10:22:44.333]                             break
[10:22:44.333]                           }
[10:22:44.333]                         }
[10:22:44.333]                       }
[10:22:44.333]                       invisible(muffled)
[10:22:44.333]                     }
[10:22:44.333]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.333]                   }
[10:22:44.333]                 }
[10:22:44.333]             }
[10:22:44.333]         }))
[10:22:44.333]     }, error = function(ex) {
[10:22:44.333]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:44.333]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.333]                 ...future.rng), started = ...future.startTime, 
[10:22:44.333]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:44.333]             version = "1.8"), class = "FutureResult")
[10:22:44.333]     }, finally = {
[10:22:44.333]         if (!identical(...future.workdir, getwd())) 
[10:22:44.333]             setwd(...future.workdir)
[10:22:44.333]         {
[10:22:44.333]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:44.333]                 ...future.oldOptions$nwarnings <- NULL
[10:22:44.333]             }
[10:22:44.333]             base::options(...future.oldOptions)
[10:22:44.333]             if (.Platform$OS.type == "windows") {
[10:22:44.333]                 old_names <- names(...future.oldEnvVars)
[10:22:44.333]                 envs <- base::Sys.getenv()
[10:22:44.333]                 names <- names(envs)
[10:22:44.333]                 common <- intersect(names, old_names)
[10:22:44.333]                 added <- setdiff(names, old_names)
[10:22:44.333]                 removed <- setdiff(old_names, names)
[10:22:44.333]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:44.333]                   envs[common]]
[10:22:44.333]                 NAMES <- toupper(changed)
[10:22:44.333]                 args <- list()
[10:22:44.333]                 for (kk in seq_along(NAMES)) {
[10:22:44.333]                   name <- changed[[kk]]
[10:22:44.333]                   NAME <- NAMES[[kk]]
[10:22:44.333]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.333]                     next
[10:22:44.333]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.333]                 }
[10:22:44.333]                 NAMES <- toupper(added)
[10:22:44.333]                 for (kk in seq_along(NAMES)) {
[10:22:44.333]                   name <- added[[kk]]
[10:22:44.333]                   NAME <- NAMES[[kk]]
[10:22:44.333]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.333]                     next
[10:22:44.333]                   args[[name]] <- ""
[10:22:44.333]                 }
[10:22:44.333]                 NAMES <- toupper(removed)
[10:22:44.333]                 for (kk in seq_along(NAMES)) {
[10:22:44.333]                   name <- removed[[kk]]
[10:22:44.333]                   NAME <- NAMES[[kk]]
[10:22:44.333]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.333]                     next
[10:22:44.333]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.333]                 }
[10:22:44.333]                 if (length(args) > 0) 
[10:22:44.333]                   base::do.call(base::Sys.setenv, args = args)
[10:22:44.333]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:44.333]             }
[10:22:44.333]             else {
[10:22:44.333]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:44.333]             }
[10:22:44.333]             {
[10:22:44.333]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:44.333]                   0L) {
[10:22:44.333]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:44.333]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:44.333]                   base::options(opts)
[10:22:44.333]                 }
[10:22:44.333]                 {
[10:22:44.333]                   {
[10:22:44.333]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:44.333]                     NULL
[10:22:44.333]                   }
[10:22:44.333]                   options(future.plan = NULL)
[10:22:44.333]                   if (is.na(NA_character_)) 
[10:22:44.333]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.333]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:44.333]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:44.333]                     envir = parent.frame()) 
[10:22:44.333]                   {
[10:22:44.333]                     default_workers <- missing(workers)
[10:22:44.333]                     if (is.function(workers)) 
[10:22:44.333]                       workers <- workers()
[10:22:44.333]                     workers <- structure(as.integer(workers), 
[10:22:44.333]                       class = class(workers))
[10:22:44.333]                     stop_if_not(is.finite(workers), workers >= 
[10:22:44.333]                       1L)
[10:22:44.333]                     if ((workers == 1L && !inherits(workers, 
[10:22:44.333]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:44.333]                       if (default_workers) 
[10:22:44.333]                         supportsMulticore(warn = TRUE)
[10:22:44.333]                       return(sequential(..., envir = envir))
[10:22:44.333]                     }
[10:22:44.333]                     oopts <- options(mc.cores = workers)
[10:22:44.333]                     on.exit(options(oopts))
[10:22:44.333]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:44.333]                       envir = envir)
[10:22:44.333]                     if (!future$lazy) 
[10:22:44.333]                       future <- run(future)
[10:22:44.333]                     invisible(future)
[10:22:44.333]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:44.333]                 }
[10:22:44.333]             }
[10:22:44.333]         }
[10:22:44.333]     })
[10:22:44.333]     if (TRUE) {
[10:22:44.333]         base::sink(type = "output", split = FALSE)
[10:22:44.333]         if (TRUE) {
[10:22:44.333]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:44.333]         }
[10:22:44.333]         else {
[10:22:44.333]             ...future.result["stdout"] <- base::list(NULL)
[10:22:44.333]         }
[10:22:44.333]         base::close(...future.stdout)
[10:22:44.333]         ...future.stdout <- NULL
[10:22:44.333]     }
[10:22:44.333]     ...future.result$conditions <- ...future.conditions
[10:22:44.333]     ...future.result$finished <- base::Sys.time()
[10:22:44.333]     ...future.result
[10:22:44.333] }
[10:22:44.335] assign_globals() ...
[10:22:44.335] List of 5
[10:22:44.335]  $ future.call.arguments    : list()
[10:22:44.335]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.335]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:22:44.335]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:22:44.335]  $ ...future.elements_ii    :List of 1
[10:22:44.335]   ..$ : num [1:4] 1 3 1 7
[10:22:44.335]  $ ...future.seeds_ii       : NULL
[10:22:44.335]  $ ...future.globals.maxSize: num Inf
[10:22:44.335]  - attr(*, "resolved")= logi FALSE
[10:22:44.335]  - attr(*, "total_size")= num NA
[10:22:44.335]  - attr(*, "where")=List of 5
[10:22:44.335]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:44.335]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:44.335]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:44.335]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:44.335]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:44.335]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.335]  - attr(*, "already-done")= logi TRUE
[10:22:44.341] - copied ‘future.call.arguments’ to environment
[10:22:44.341] - copied ‘...future.FUN’ to environment
[10:22:44.341] - copied ‘...future.elements_ii’ to environment
[10:22:44.341] - copied ‘...future.seeds_ii’ to environment
[10:22:44.341] - copied ‘...future.globals.maxSize’ to environment
[10:22:44.341] assign_globals() ... done
[10:22:44.342] requestCore(): workers = 2
[10:22:44.345] MulticoreFuture started
[10:22:44.345] - Launch lazy future ... done
[10:22:44.346] plan(): Setting new future strategy stack:
[10:22:44.346] run() for ‘MulticoreFuture’ ... done
[10:22:44.346] Created future:
[10:22:44.346] List of future strategies:
[10:22:44.346] 1. sequential:
[10:22:44.346]    - args: function (..., envir = parent.frame())
[10:22:44.346]    - tweaked: FALSE
[10:22:44.346]    - call: NULL
[10:22:44.347] plan(): nbrOfWorkers() = 1
[10:22:44.350] plan(): Setting new future strategy stack:
[10:22:44.350] List of future strategies:
[10:22:44.350] 1. multicore:
[10:22:44.350]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:44.350]    - tweaked: FALSE
[10:22:44.350]    - call: plan(strategy)
[10:22:44.355] plan(): nbrOfWorkers() = 2
[10:22:44.347] MulticoreFuture:
[10:22:44.347] Label: ‘future_apply-1’
[10:22:44.347] Expression:
[10:22:44.347] {
[10:22:44.347]     do.call(function(...) {
[10:22:44.347]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.347]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:44.347]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.347]             on.exit(options(oopts), add = TRUE)
[10:22:44.347]         }
[10:22:44.347]         {
[10:22:44.347]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:44.347]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.347]                 ...future.FUN(...future.X_jj, ...)
[10:22:44.347]             })
[10:22:44.347]         }
[10:22:44.347]     }, args = future.call.arguments)
[10:22:44.347] }
[10:22:44.347] Lazy evaluation: FALSE
[10:22:44.347] Asynchronous evaluation: TRUE
[10:22:44.347] Local evaluation: TRUE
[10:22:44.347] Environment: R_GlobalEnv
[10:22:44.347] Capture standard output: TRUE
[10:22:44.347] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:44.347] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:44.347] Packages: <none>
[10:22:44.347] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:44.347] Resolved: TRUE
[10:22:44.347] Value: <not collected>
[10:22:44.347] Conditions captured: <none>
[10:22:44.347] Early signaling: FALSE
[10:22:44.347] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:44.347] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:44.356] Chunk #1 of 2 ... DONE
[10:22:44.356] Chunk #2 of 2 ...
[10:22:44.357]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:44.357]  - seeds: <none>
[10:22:44.357]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.357] getGlobalsAndPackages() ...
[10:22:44.357] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.358] Resolving globals: FALSE
[10:22:44.358] Tweak future expression to call with '...' arguments ...
[10:22:44.358] {
[10:22:44.358]     do.call(function(...) {
[10:22:44.358]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.358]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:44.358]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.358]             on.exit(options(oopts), add = TRUE)
[10:22:44.358]         }
[10:22:44.358]         {
[10:22:44.358]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:44.358]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.358]                 ...future.FUN(...future.X_jj, ...)
[10:22:44.358]             })
[10:22:44.358]         }
[10:22:44.358]     }, args = future.call.arguments)
[10:22:44.358] }
[10:22:44.358] Tweak future expression to call with '...' arguments ... DONE
[10:22:44.359] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.359] 
[10:22:44.359] getGlobalsAndPackages() ... DONE
[10:22:44.360] run() for ‘Future’ ...
[10:22:44.360] - state: ‘created’
[10:22:44.360] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:44.365] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:44.365] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:44.365]   - Field: ‘label’
[10:22:44.365]   - Field: ‘local’
[10:22:44.365]   - Field: ‘owner’
[10:22:44.366]   - Field: ‘envir’
[10:22:44.366]   - Field: ‘workers’
[10:22:44.366]   - Field: ‘packages’
[10:22:44.366]   - Field: ‘gc’
[10:22:44.366]   - Field: ‘job’
[10:22:44.366]   - Field: ‘conditions’
[10:22:44.366]   - Field: ‘expr’
[10:22:44.367]   - Field: ‘uuid’
[10:22:44.367]   - Field: ‘seed’
[10:22:44.367]   - Field: ‘version’
[10:22:44.367]   - Field: ‘result’
[10:22:44.367]   - Field: ‘asynchronous’
[10:22:44.367]   - Field: ‘calls’
[10:22:44.368]   - Field: ‘globals’
[10:22:44.368]   - Field: ‘stdout’
[10:22:44.368]   - Field: ‘earlySignal’
[10:22:44.368]   - Field: ‘lazy’
[10:22:44.368]   - Field: ‘state’
[10:22:44.368] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:44.368] - Launch lazy future ...
[10:22:44.369] Packages needed by the future expression (n = 0): <none>
[10:22:44.369] Packages needed by future strategies (n = 0): <none>
[10:22:44.370] {
[10:22:44.370]     {
[10:22:44.370]         {
[10:22:44.370]             ...future.startTime <- base::Sys.time()
[10:22:44.370]             {
[10:22:44.370]                 {
[10:22:44.370]                   {
[10:22:44.370]                     {
[10:22:44.370]                       base::local({
[10:22:44.370]                         has_future <- base::requireNamespace("future", 
[10:22:44.370]                           quietly = TRUE)
[10:22:44.370]                         if (has_future) {
[10:22:44.370]                           ns <- base::getNamespace("future")
[10:22:44.370]                           version <- ns[[".package"]][["version"]]
[10:22:44.370]                           if (is.null(version)) 
[10:22:44.370]                             version <- utils::packageVersion("future")
[10:22:44.370]                         }
[10:22:44.370]                         else {
[10:22:44.370]                           version <- NULL
[10:22:44.370]                         }
[10:22:44.370]                         if (!has_future || version < "1.8.0") {
[10:22:44.370]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:44.370]                             "", base::R.version$version.string), 
[10:22:44.370]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:44.370]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:44.370]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:44.370]                               "release", "version")], collapse = " "), 
[10:22:44.370]                             hostname = base::Sys.info()[["nodename"]])
[10:22:44.370]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:44.370]                             info)
[10:22:44.370]                           info <- base::paste(info, collapse = "; ")
[10:22:44.370]                           if (!has_future) {
[10:22:44.370]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:44.370]                               info)
[10:22:44.370]                           }
[10:22:44.370]                           else {
[10:22:44.370]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:44.370]                               info, version)
[10:22:44.370]                           }
[10:22:44.370]                           base::stop(msg)
[10:22:44.370]                         }
[10:22:44.370]                       })
[10:22:44.370]                     }
[10:22:44.370]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:44.370]                     base::options(mc.cores = 1L)
[10:22:44.370]                   }
[10:22:44.370]                   options(future.plan = NULL)
[10:22:44.370]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.370]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:44.370]                 }
[10:22:44.370]                 ...future.workdir <- getwd()
[10:22:44.370]             }
[10:22:44.370]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:44.370]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:44.370]         }
[10:22:44.370]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:44.370]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:44.370]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:44.370]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:44.370]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:44.370]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:44.370]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:44.370]             base::names(...future.oldOptions))
[10:22:44.370]     }
[10:22:44.370]     if (FALSE) {
[10:22:44.370]     }
[10:22:44.370]     else {
[10:22:44.370]         if (TRUE) {
[10:22:44.370]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:44.370]                 open = "w")
[10:22:44.370]         }
[10:22:44.370]         else {
[10:22:44.370]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:44.370]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:44.370]         }
[10:22:44.370]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:44.370]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:44.370]             base::sink(type = "output", split = FALSE)
[10:22:44.370]             base::close(...future.stdout)
[10:22:44.370]         }, add = TRUE)
[10:22:44.370]     }
[10:22:44.370]     ...future.frame <- base::sys.nframe()
[10:22:44.370]     ...future.conditions <- base::list()
[10:22:44.370]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:44.370]     if (FALSE) {
[10:22:44.370]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:44.370]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:44.370]     }
[10:22:44.370]     ...future.result <- base::tryCatch({
[10:22:44.370]         base::withCallingHandlers({
[10:22:44.370]             ...future.value <- base::withVisible(base::local({
[10:22:44.370]                 withCallingHandlers({
[10:22:44.370]                   {
[10:22:44.370]                     do.call(function(...) {
[10:22:44.370]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.370]                       if (!identical(...future.globals.maxSize.org, 
[10:22:44.370]                         ...future.globals.maxSize)) {
[10:22:44.370]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.370]                         on.exit(options(oopts), add = TRUE)
[10:22:44.370]                       }
[10:22:44.370]                       {
[10:22:44.370]                         lapply(seq_along(...future.elements_ii), 
[10:22:44.370]                           FUN = function(jj) {
[10:22:44.370]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.370]                             ...future.FUN(...future.X_jj, ...)
[10:22:44.370]                           })
[10:22:44.370]                       }
[10:22:44.370]                     }, args = future.call.arguments)
[10:22:44.370]                   }
[10:22:44.370]                 }, immediateCondition = function(cond) {
[10:22:44.370]                   save_rds <- function (object, pathname, ...) 
[10:22:44.370]                   {
[10:22:44.370]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:44.370]                     if (file_test("-f", pathname_tmp)) {
[10:22:44.370]                       fi_tmp <- file.info(pathname_tmp)
[10:22:44.370]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:44.370]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:44.370]                         fi_tmp[["mtime"]])
[10:22:44.370]                     }
[10:22:44.370]                     tryCatch({
[10:22:44.370]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:44.370]                     }, error = function(ex) {
[10:22:44.370]                       msg <- conditionMessage(ex)
[10:22:44.370]                       fi_tmp <- file.info(pathname_tmp)
[10:22:44.370]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:44.370]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:44.370]                         fi_tmp[["mtime"]], msg)
[10:22:44.370]                       ex$message <- msg
[10:22:44.370]                       stop(ex)
[10:22:44.370]                     })
[10:22:44.370]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:44.370]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:44.370]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:44.370]                       fi_tmp <- file.info(pathname_tmp)
[10:22:44.370]                       fi <- file.info(pathname)
[10:22:44.370]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:44.370]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:44.370]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:44.370]                         fi[["size"]], fi[["mtime"]])
[10:22:44.370]                       stop(msg)
[10:22:44.370]                     }
[10:22:44.370]                     invisible(pathname)
[10:22:44.370]                   }
[10:22:44.370]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:44.370]                     rootPath = tempdir()) 
[10:22:44.370]                   {
[10:22:44.370]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:44.370]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:44.370]                       tmpdir = path, fileext = ".rds")
[10:22:44.370]                     save_rds(obj, file)
[10:22:44.370]                   }
[10:22:44.370]                   saveImmediateCondition(cond, path = "/tmp/RtmpTHXGJm/.future/immediateConditions")
[10:22:44.370]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.370]                   {
[10:22:44.370]                     inherits <- base::inherits
[10:22:44.370]                     invokeRestart <- base::invokeRestart
[10:22:44.370]                     is.null <- base::is.null
[10:22:44.370]                     muffled <- FALSE
[10:22:44.370]                     if (inherits(cond, "message")) {
[10:22:44.370]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:44.370]                       if (muffled) 
[10:22:44.370]                         invokeRestart("muffleMessage")
[10:22:44.370]                     }
[10:22:44.370]                     else if (inherits(cond, "warning")) {
[10:22:44.370]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:44.370]                       if (muffled) 
[10:22:44.370]                         invokeRestart("muffleWarning")
[10:22:44.370]                     }
[10:22:44.370]                     else if (inherits(cond, "condition")) {
[10:22:44.370]                       if (!is.null(pattern)) {
[10:22:44.370]                         computeRestarts <- base::computeRestarts
[10:22:44.370]                         grepl <- base::grepl
[10:22:44.370]                         restarts <- computeRestarts(cond)
[10:22:44.370]                         for (restart in restarts) {
[10:22:44.370]                           name <- restart$name
[10:22:44.370]                           if (is.null(name)) 
[10:22:44.370]                             next
[10:22:44.370]                           if (!grepl(pattern, name)) 
[10:22:44.370]                             next
[10:22:44.370]                           invokeRestart(restart)
[10:22:44.370]                           muffled <- TRUE
[10:22:44.370]                           break
[10:22:44.370]                         }
[10:22:44.370]                       }
[10:22:44.370]                     }
[10:22:44.370]                     invisible(muffled)
[10:22:44.370]                   }
[10:22:44.370]                   muffleCondition(cond)
[10:22:44.370]                 })
[10:22:44.370]             }))
[10:22:44.370]             future::FutureResult(value = ...future.value$value, 
[10:22:44.370]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.370]                   ...future.rng), globalenv = if (FALSE) 
[10:22:44.370]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:44.370]                     ...future.globalenv.names))
[10:22:44.370]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:44.370]         }, condition = base::local({
[10:22:44.370]             c <- base::c
[10:22:44.370]             inherits <- base::inherits
[10:22:44.370]             invokeRestart <- base::invokeRestart
[10:22:44.370]             length <- base::length
[10:22:44.370]             list <- base::list
[10:22:44.370]             seq.int <- base::seq.int
[10:22:44.370]             signalCondition <- base::signalCondition
[10:22:44.370]             sys.calls <- base::sys.calls
[10:22:44.370]             `[[` <- base::`[[`
[10:22:44.370]             `+` <- base::`+`
[10:22:44.370]             `<<-` <- base::`<<-`
[10:22:44.370]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:44.370]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:44.370]                   3L)]
[10:22:44.370]             }
[10:22:44.370]             function(cond) {
[10:22:44.370]                 is_error <- inherits(cond, "error")
[10:22:44.370]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:44.370]                   NULL)
[10:22:44.370]                 if (is_error) {
[10:22:44.370]                   sessionInformation <- function() {
[10:22:44.370]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:44.370]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:44.370]                       search = base::search(), system = base::Sys.info())
[10:22:44.370]                   }
[10:22:44.370]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.370]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:44.370]                     cond$call), session = sessionInformation(), 
[10:22:44.370]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:44.370]                   signalCondition(cond)
[10:22:44.370]                 }
[10:22:44.370]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:44.370]                 "immediateCondition"))) {
[10:22:44.370]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:44.370]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.370]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:44.370]                   if (TRUE && !signal) {
[10:22:44.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.370]                     {
[10:22:44.370]                       inherits <- base::inherits
[10:22:44.370]                       invokeRestart <- base::invokeRestart
[10:22:44.370]                       is.null <- base::is.null
[10:22:44.370]                       muffled <- FALSE
[10:22:44.370]                       if (inherits(cond, "message")) {
[10:22:44.370]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.370]                         if (muffled) 
[10:22:44.370]                           invokeRestart("muffleMessage")
[10:22:44.370]                       }
[10:22:44.370]                       else if (inherits(cond, "warning")) {
[10:22:44.370]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.370]                         if (muffled) 
[10:22:44.370]                           invokeRestart("muffleWarning")
[10:22:44.370]                       }
[10:22:44.370]                       else if (inherits(cond, "condition")) {
[10:22:44.370]                         if (!is.null(pattern)) {
[10:22:44.370]                           computeRestarts <- base::computeRestarts
[10:22:44.370]                           grepl <- base::grepl
[10:22:44.370]                           restarts <- computeRestarts(cond)
[10:22:44.370]                           for (restart in restarts) {
[10:22:44.370]                             name <- restart$name
[10:22:44.370]                             if (is.null(name)) 
[10:22:44.370]                               next
[10:22:44.370]                             if (!grepl(pattern, name)) 
[10:22:44.370]                               next
[10:22:44.370]                             invokeRestart(restart)
[10:22:44.370]                             muffled <- TRUE
[10:22:44.370]                             break
[10:22:44.370]                           }
[10:22:44.370]                         }
[10:22:44.370]                       }
[10:22:44.370]                       invisible(muffled)
[10:22:44.370]                     }
[10:22:44.370]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.370]                   }
[10:22:44.370]                 }
[10:22:44.370]                 else {
[10:22:44.370]                   if (TRUE) {
[10:22:44.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.370]                     {
[10:22:44.370]                       inherits <- base::inherits
[10:22:44.370]                       invokeRestart <- base::invokeRestart
[10:22:44.370]                       is.null <- base::is.null
[10:22:44.370]                       muffled <- FALSE
[10:22:44.370]                       if (inherits(cond, "message")) {
[10:22:44.370]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.370]                         if (muffled) 
[10:22:44.370]                           invokeRestart("muffleMessage")
[10:22:44.370]                       }
[10:22:44.370]                       else if (inherits(cond, "warning")) {
[10:22:44.370]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.370]                         if (muffled) 
[10:22:44.370]                           invokeRestart("muffleWarning")
[10:22:44.370]                       }
[10:22:44.370]                       else if (inherits(cond, "condition")) {
[10:22:44.370]                         if (!is.null(pattern)) {
[10:22:44.370]                           computeRestarts <- base::computeRestarts
[10:22:44.370]                           grepl <- base::grepl
[10:22:44.370]                           restarts <- computeRestarts(cond)
[10:22:44.370]                           for (restart in restarts) {
[10:22:44.370]                             name <- restart$name
[10:22:44.370]                             if (is.null(name)) 
[10:22:44.370]                               next
[10:22:44.370]                             if (!grepl(pattern, name)) 
[10:22:44.370]                               next
[10:22:44.370]                             invokeRestart(restart)
[10:22:44.370]                             muffled <- TRUE
[10:22:44.370]                             break
[10:22:44.370]                           }
[10:22:44.370]                         }
[10:22:44.370]                       }
[10:22:44.370]                       invisible(muffled)
[10:22:44.370]                     }
[10:22:44.370]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.370]                   }
[10:22:44.370]                 }
[10:22:44.370]             }
[10:22:44.370]         }))
[10:22:44.370]     }, error = function(ex) {
[10:22:44.370]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:44.370]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.370]                 ...future.rng), started = ...future.startTime, 
[10:22:44.370]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:44.370]             version = "1.8"), class = "FutureResult")
[10:22:44.370]     }, finally = {
[10:22:44.370]         if (!identical(...future.workdir, getwd())) 
[10:22:44.370]             setwd(...future.workdir)
[10:22:44.370]         {
[10:22:44.370]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:44.370]                 ...future.oldOptions$nwarnings <- NULL
[10:22:44.370]             }
[10:22:44.370]             base::options(...future.oldOptions)
[10:22:44.370]             if (.Platform$OS.type == "windows") {
[10:22:44.370]                 old_names <- names(...future.oldEnvVars)
[10:22:44.370]                 envs <- base::Sys.getenv()
[10:22:44.370]                 names <- names(envs)
[10:22:44.370]                 common <- intersect(names, old_names)
[10:22:44.370]                 added <- setdiff(names, old_names)
[10:22:44.370]                 removed <- setdiff(old_names, names)
[10:22:44.370]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:44.370]                   envs[common]]
[10:22:44.370]                 NAMES <- toupper(changed)
[10:22:44.370]                 args <- list()
[10:22:44.370]                 for (kk in seq_along(NAMES)) {
[10:22:44.370]                   name <- changed[[kk]]
[10:22:44.370]                   NAME <- NAMES[[kk]]
[10:22:44.370]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.370]                     next
[10:22:44.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.370]                 }
[10:22:44.370]                 NAMES <- toupper(added)
[10:22:44.370]                 for (kk in seq_along(NAMES)) {
[10:22:44.370]                   name <- added[[kk]]
[10:22:44.370]                   NAME <- NAMES[[kk]]
[10:22:44.370]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.370]                     next
[10:22:44.370]                   args[[name]] <- ""
[10:22:44.370]                 }
[10:22:44.370]                 NAMES <- toupper(removed)
[10:22:44.370]                 for (kk in seq_along(NAMES)) {
[10:22:44.370]                   name <- removed[[kk]]
[10:22:44.370]                   NAME <- NAMES[[kk]]
[10:22:44.370]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.370]                     next
[10:22:44.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.370]                 }
[10:22:44.370]                 if (length(args) > 0) 
[10:22:44.370]                   base::do.call(base::Sys.setenv, args = args)
[10:22:44.370]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:44.370]             }
[10:22:44.370]             else {
[10:22:44.370]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:44.370]             }
[10:22:44.370]             {
[10:22:44.370]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:44.370]                   0L) {
[10:22:44.370]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:44.370]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:44.370]                   base::options(opts)
[10:22:44.370]                 }
[10:22:44.370]                 {
[10:22:44.370]                   {
[10:22:44.370]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:44.370]                     NULL
[10:22:44.370]                   }
[10:22:44.370]                   options(future.plan = NULL)
[10:22:44.370]                   if (is.na(NA_character_)) 
[10:22:44.370]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.370]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:44.370]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:44.370]                     envir = parent.frame()) 
[10:22:44.370]                   {
[10:22:44.370]                     default_workers <- missing(workers)
[10:22:44.370]                     if (is.function(workers)) 
[10:22:44.370]                       workers <- workers()
[10:22:44.370]                     workers <- structure(as.integer(workers), 
[10:22:44.370]                       class = class(workers))
[10:22:44.370]                     stop_if_not(is.finite(workers), workers >= 
[10:22:44.370]                       1L)
[10:22:44.370]                     if ((workers == 1L && !inherits(workers, 
[10:22:44.370]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:44.370]                       if (default_workers) 
[10:22:44.370]                         supportsMulticore(warn = TRUE)
[10:22:44.370]                       return(sequential(..., envir = envir))
[10:22:44.370]                     }
[10:22:44.370]                     oopts <- options(mc.cores = workers)
[10:22:44.370]                     on.exit(options(oopts))
[10:22:44.370]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:44.370]                       envir = envir)
[10:22:44.370]                     if (!future$lazy) 
[10:22:44.370]                       future <- run(future)
[10:22:44.370]                     invisible(future)
[10:22:44.370]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:44.370]                 }
[10:22:44.370]             }
[10:22:44.370]         }
[10:22:44.370]     })
[10:22:44.370]     if (TRUE) {
[10:22:44.370]         base::sink(type = "output", split = FALSE)
[10:22:44.370]         if (TRUE) {
[10:22:44.370]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:44.370]         }
[10:22:44.370]         else {
[10:22:44.370]             ...future.result["stdout"] <- base::list(NULL)
[10:22:44.370]         }
[10:22:44.370]         base::close(...future.stdout)
[10:22:44.370]         ...future.stdout <- NULL
[10:22:44.370]     }
[10:22:44.370]     ...future.result$conditions <- ...future.conditions
[10:22:44.370]     ...future.result$finished <- base::Sys.time()
[10:22:44.370]     ...future.result
[10:22:44.370] }
[10:22:44.373] assign_globals() ...
[10:22:44.373] List of 5
[10:22:44.373]  $ future.call.arguments    : list()
[10:22:44.373]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.373]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:22:44.373]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:22:44.373]  $ ...future.elements_ii    :List of 1
[10:22:44.373]   ..$ : num [1:4] 2 4 6 8
[10:22:44.373]  $ ...future.seeds_ii       : NULL
[10:22:44.373]  $ ...future.globals.maxSize: num Inf
[10:22:44.373]  - attr(*, "resolved")= logi FALSE
[10:22:44.373]  - attr(*, "total_size")= num NA
[10:22:44.373]  - attr(*, "where")=List of 5
[10:22:44.373]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:44.373]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:44.373]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:44.373]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:44.373]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:44.373]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.373]  - attr(*, "already-done")= logi TRUE
[10:22:44.380] - copied ‘future.call.arguments’ to environment
[10:22:44.381] - copied ‘...future.FUN’ to environment
[10:22:44.381] - copied ‘...future.elements_ii’ to environment
[10:22:44.381] - copied ‘...future.seeds_ii’ to environment
[10:22:44.381] - copied ‘...future.globals.maxSize’ to environment
[10:22:44.381] assign_globals() ... done
[10:22:44.381] requestCore(): workers = 2
[10:22:44.390] MulticoreFuture started
[10:22:44.391] - Launch lazy future ... done
[10:22:44.392] plan(): Setting new future strategy stack:
[10:22:44.392] run() for ‘MulticoreFuture’ ... done
[10:22:44.392] Created future:
[10:22:44.392] List of future strategies:
[10:22:44.392] 1. sequential:
[10:22:44.392]    - args: function (..., envir = parent.frame())
[10:22:44.392]    - tweaked: FALSE
[10:22:44.392]    - call: NULL
[10:22:44.393] plan(): nbrOfWorkers() = 1
[10:22:44.396] plan(): Setting new future strategy stack:
[10:22:44.396] List of future strategies:
[10:22:44.396] 1. multicore:
[10:22:44.396]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:44.396]    - tweaked: FALSE
[10:22:44.396]    - call: plan(strategy)
[10:22:44.402] plan(): nbrOfWorkers() = 2
[10:22:44.393] MulticoreFuture:
[10:22:44.393] Label: ‘future_apply-2’
[10:22:44.393] Expression:
[10:22:44.393] {
[10:22:44.393]     do.call(function(...) {
[10:22:44.393]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.393]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:44.393]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.393]             on.exit(options(oopts), add = TRUE)
[10:22:44.393]         }
[10:22:44.393]         {
[10:22:44.393]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:44.393]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.393]                 ...future.FUN(...future.X_jj, ...)
[10:22:44.393]             })
[10:22:44.393]         }
[10:22:44.393]     }, args = future.call.arguments)
[10:22:44.393] }
[10:22:44.393] Lazy evaluation: FALSE
[10:22:44.393] Asynchronous evaluation: TRUE
[10:22:44.393] Local evaluation: TRUE
[10:22:44.393] Environment: R_GlobalEnv
[10:22:44.393] Capture standard output: TRUE
[10:22:44.393] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:44.393] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:44.393] Packages: <none>
[10:22:44.393] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:44.393] Resolved: TRUE
[10:22:44.393] Value: <not collected>
[10:22:44.393] Conditions captured: <none>
[10:22:44.393] Early signaling: FALSE
[10:22:44.393] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:44.393] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:44.403] Chunk #2 of 2 ... DONE
[10:22:44.404] Launching 2 futures (chunks) ... DONE
[10:22:44.404] Resolving 2 futures (chunks) ...
[10:22:44.404] resolve() on list ...
[10:22:44.404]  recursive: 0
[10:22:44.404]  length: 2
[10:22:44.405] 
[10:22:44.405] Future #1
[10:22:44.406] result() for MulticoreFuture ...
[10:22:44.408] result() for MulticoreFuture ...
[10:22:44.408] result() for MulticoreFuture ... done
[10:22:44.409] result() for MulticoreFuture ... done
[10:22:44.409] result() for MulticoreFuture ...
[10:22:44.409] result() for MulticoreFuture ... done
[10:22:44.409] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:22:44.409] - nx: 2
[10:22:44.410] - relay: TRUE
[10:22:44.410] - stdout: TRUE
[10:22:44.410] - signal: TRUE
[10:22:44.410] - resignal: FALSE
[10:22:44.410] - force: TRUE
[10:22:44.410] - relayed: [n=2] FALSE, FALSE
[10:22:44.411] - queued futures: [n=2] FALSE, FALSE
[10:22:44.411]  - until=1
[10:22:44.411]  - relaying element #1
[10:22:44.411] result() for MulticoreFuture ...
[10:22:44.411] result() for MulticoreFuture ... done
[10:22:44.412] result() for MulticoreFuture ...
[10:22:44.412] result() for MulticoreFuture ... done
[10:22:44.412] result() for MulticoreFuture ...
[10:22:44.412] result() for MulticoreFuture ... done
[10:22:44.412] result() for MulticoreFuture ...
[10:22:44.412] result() for MulticoreFuture ... done
[10:22:44.413] - relayed: [n=2] TRUE, FALSE
[10:22:44.413] - queued futures: [n=2] TRUE, FALSE
[10:22:44.413] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:22:44.413]  length: 1 (resolved future 1)
[10:22:44.414] Future #2
[10:22:44.414] result() for MulticoreFuture ...
[10:22:44.414] result() for MulticoreFuture ...
[10:22:44.415] result() for MulticoreFuture ... done
[10:22:44.415] result() for MulticoreFuture ... done
[10:22:44.415] result() for MulticoreFuture ...
[10:22:44.415] result() for MulticoreFuture ... done
[10:22:44.415] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:22:44.415] - nx: 2
[10:22:44.416] - relay: TRUE
[10:22:44.416] - stdout: TRUE
[10:22:44.416] - signal: TRUE
[10:22:44.416] - resignal: FALSE
[10:22:44.416] - force: TRUE
[10:22:44.416] - relayed: [n=2] TRUE, FALSE
[10:22:44.416] - queued futures: [n=2] TRUE, FALSE
[10:22:44.416]  - until=2
[10:22:44.417]  - relaying element #2
[10:22:44.417] result() for MulticoreFuture ...
[10:22:44.417] result() for MulticoreFuture ... done
[10:22:44.417] result() for MulticoreFuture ...
[10:22:44.417] result() for MulticoreFuture ... done
[10:22:44.417] result() for MulticoreFuture ...
[10:22:44.417] result() for MulticoreFuture ... done
[10:22:44.418] result() for MulticoreFuture ...
[10:22:44.418] result() for MulticoreFuture ... done
[10:22:44.418] - relayed: [n=2] TRUE, TRUE
[10:22:44.418] - queued futures: [n=2] TRUE, TRUE
[10:22:44.418] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:22:44.418]  length: 0 (resolved future 2)
[10:22:44.418] Relaying remaining futures
[10:22:44.418] signalConditionsASAP(NULL, pos=0) ...
[10:22:44.418] - nx: 2
[10:22:44.419] - relay: TRUE
[10:22:44.419] - stdout: TRUE
[10:22:44.419] - signal: TRUE
[10:22:44.419] - resignal: FALSE
[10:22:44.419] - force: TRUE
[10:22:44.419] - relayed: [n=2] TRUE, TRUE
[10:22:44.419] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:22:44.419] - relayed: [n=2] TRUE, TRUE
[10:22:44.419] - queued futures: [n=2] TRUE, TRUE
[10:22:44.420] signalConditionsASAP(NULL, pos=0) ... done
[10:22:44.420] resolve() on list ... DONE
[10:22:44.420] result() for MulticoreFuture ...
[10:22:44.420] result() for MulticoreFuture ... done
[10:22:44.420] result() for MulticoreFuture ...
[10:22:44.420] result() for MulticoreFuture ... done
[10:22:44.420] result() for MulticoreFuture ...
[10:22:44.420] result() for MulticoreFuture ... done
[10:22:44.420] result() for MulticoreFuture ...
[10:22:44.421] result() for MulticoreFuture ... done
[10:22:44.421]  - Number of value chunks collected: 2
[10:22:44.421] Resolving 2 futures (chunks) ... DONE
[10:22:44.421] Reducing values from 2 chunks ...
[10:22:44.421]  - Number of values collected after concatenation: 2
[10:22:44.421]  - Number of values expected: 2
[10:22:44.421] Reducing values from 2 chunks ... DONE
[10:22:44.421] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[10:22:44.422] getGlobalsAndPackagesXApply() ...
[10:22:44.422]  - future.globals: TRUE
[10:22:44.422] getGlobalsAndPackages() ...
[10:22:44.422] Searching for globals...
[10:22:44.460] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[10:22:44.460] Searching for globals ... DONE
[10:22:44.461] Resolving globals: FALSE
[10:22:44.462] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[10:22:44.463] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[10:22:44.463] - globals: [1] ‘FUN’
[10:22:44.463] 
[10:22:44.463] getGlobalsAndPackages() ... DONE
[10:22:44.463]  - globals found/used: [n=1] ‘FUN’
[10:22:44.463]  - needed namespaces: [n=0] 
[10:22:44.463] Finding globals ... DONE
[10:22:44.463]  - use_args: TRUE
[10:22:44.463]  - Getting '...' globals ...
[10:22:44.464] resolve() on list ...
[10:22:44.464]  recursive: 0
[10:22:44.464]  length: 1
[10:22:44.464]  elements: ‘...’
[10:22:44.464]  length: 0 (resolved future 1)
[10:22:44.464] resolve() on list ... DONE
[10:22:44.464]    - '...' content: [n=0] 
[10:22:44.464] List of 1
[10:22:44.464]  $ ...: list()
[10:22:44.464]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.464]  - attr(*, "where")=List of 1
[10:22:44.464]   ..$ ...:<environment: 0x55ca4ce64618> 
[10:22:44.464]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.464]  - attr(*, "resolved")= logi TRUE
[10:22:44.464]  - attr(*, "total_size")= num NA
[10:22:44.469]  - Getting '...' globals ... DONE
[10:22:44.469] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:44.469] List of 2
[10:22:44.469]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:22:44.469]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:22:44.469]  $ ...          : list()
[10:22:44.469]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.469]  - attr(*, "where")=List of 2
[10:22:44.469]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:44.469]   ..$ ...          :<environment: 0x55ca4ce64618> 
[10:22:44.469]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.469]  - attr(*, "resolved")= logi FALSE
[10:22:44.469]  - attr(*, "total_size")= num 354224
[10:22:44.472] Packages to be attached in all futures: [n=0] 
[10:22:44.472] getGlobalsAndPackagesXApply() ... DONE
[10:22:44.476] future_lapply() ...
[10:22:44.512] Number of chunks: 2
[10:22:44.512] getGlobalsAndPackagesXApply() ...
[10:22:44.512]  - future.globals: <name-value list> with names ‘list()’
[10:22:44.513]  - use_args: TRUE
[10:22:44.513] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:22:44.513] List of 2
[10:22:44.513]  $ ...          : list()
[10:22:44.513]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.513]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:22:44.513]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:22:44.513]  - attr(*, "where")=List of 2
[10:22:44.513]   ..$ ...          :<environment: 0x55ca4ce64618> 
[10:22:44.513]   ..$ ...future.FUN:<environment: namespace:base> 
[10:22:44.513]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.513]  - attr(*, "resolved")= logi FALSE
[10:22:44.513]  - attr(*, "total_size")= num NA
[10:22:44.516] Packages to be attached in all futures: [n=0] 
[10:22:44.516] getGlobalsAndPackagesXApply() ... DONE
[10:22:44.516] Number of futures (= number of chunks): 2
[10:22:44.517] Launching 2 futures (chunks) ...
[10:22:44.517] Chunk #1 of 2 ...
[10:22:44.517]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:44.517]  - seeds: <none>
[10:22:44.517]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.517] getGlobalsAndPackages() ...
[10:22:44.517] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.517] Resolving globals: FALSE
[10:22:44.518] Tweak future expression to call with '...' arguments ...
[10:22:44.518] {
[10:22:44.518]     do.call(function(...) {
[10:22:44.518]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.518]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:44.518]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.518]             on.exit(options(oopts), add = TRUE)
[10:22:44.518]         }
[10:22:44.518]         {
[10:22:44.518]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:44.518]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.518]                 ...future.FUN(...future.X_jj, ...)
[10:22:44.518]             })
[10:22:44.518]         }
[10:22:44.518]     }, args = future.call.arguments)
[10:22:44.518] }
[10:22:44.518] Tweak future expression to call with '...' arguments ... DONE
[10:22:44.518] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.518] 
[10:22:44.518] getGlobalsAndPackages() ... DONE
[10:22:44.519] run() for ‘Future’ ...
[10:22:44.519] - state: ‘created’
[10:22:44.519] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:44.522] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:44.523] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:44.523]   - Field: ‘label’
[10:22:44.523]   - Field: ‘local’
[10:22:44.523]   - Field: ‘owner’
[10:22:44.523]   - Field: ‘envir’
[10:22:44.523]   - Field: ‘workers’
[10:22:44.523]   - Field: ‘packages’
[10:22:44.523]   - Field: ‘gc’
[10:22:44.523]   - Field: ‘job’
[10:22:44.523]   - Field: ‘conditions’
[10:22:44.524]   - Field: ‘expr’
[10:22:44.524]   - Field: ‘uuid’
[10:22:44.524]   - Field: ‘seed’
[10:22:44.524]   - Field: ‘version’
[10:22:44.524]   - Field: ‘result’
[10:22:44.524]   - Field: ‘asynchronous’
[10:22:44.524]   - Field: ‘calls’
[10:22:44.524]   - Field: ‘globals’
[10:22:44.524]   - Field: ‘stdout’
[10:22:44.524]   - Field: ‘earlySignal’
[10:22:44.524]   - Field: ‘lazy’
[10:22:44.525]   - Field: ‘state’
[10:22:44.525] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:44.525] - Launch lazy future ...
[10:22:44.525] Packages needed by the future expression (n = 0): <none>
[10:22:44.525] Packages needed by future strategies (n = 0): <none>
[10:22:44.526] {
[10:22:44.526]     {
[10:22:44.526]         {
[10:22:44.526]             ...future.startTime <- base::Sys.time()
[10:22:44.526]             {
[10:22:44.526]                 {
[10:22:44.526]                   {
[10:22:44.526]                     {
[10:22:44.526]                       base::local({
[10:22:44.526]                         has_future <- base::requireNamespace("future", 
[10:22:44.526]                           quietly = TRUE)
[10:22:44.526]                         if (has_future) {
[10:22:44.526]                           ns <- base::getNamespace("future")
[10:22:44.526]                           version <- ns[[".package"]][["version"]]
[10:22:44.526]                           if (is.null(version)) 
[10:22:44.526]                             version <- utils::packageVersion("future")
[10:22:44.526]                         }
[10:22:44.526]                         else {
[10:22:44.526]                           version <- NULL
[10:22:44.526]                         }
[10:22:44.526]                         if (!has_future || version < "1.8.0") {
[10:22:44.526]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:44.526]                             "", base::R.version$version.string), 
[10:22:44.526]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:44.526]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:44.526]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:44.526]                               "release", "version")], collapse = " "), 
[10:22:44.526]                             hostname = base::Sys.info()[["nodename"]])
[10:22:44.526]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:44.526]                             info)
[10:22:44.526]                           info <- base::paste(info, collapse = "; ")
[10:22:44.526]                           if (!has_future) {
[10:22:44.526]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:44.526]                               info)
[10:22:44.526]                           }
[10:22:44.526]                           else {
[10:22:44.526]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:44.526]                               info, version)
[10:22:44.526]                           }
[10:22:44.526]                           base::stop(msg)
[10:22:44.526]                         }
[10:22:44.526]                       })
[10:22:44.526]                     }
[10:22:44.526]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:44.526]                     base::options(mc.cores = 1L)
[10:22:44.526]                   }
[10:22:44.526]                   options(future.plan = NULL)
[10:22:44.526]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.526]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:44.526]                 }
[10:22:44.526]                 ...future.workdir <- getwd()
[10:22:44.526]             }
[10:22:44.526]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:44.526]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:44.526]         }
[10:22:44.526]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:44.526]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:44.526]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:44.526]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:44.526]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:44.526]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:44.526]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:44.526]             base::names(...future.oldOptions))
[10:22:44.526]     }
[10:22:44.526]     if (FALSE) {
[10:22:44.526]     }
[10:22:44.526]     else {
[10:22:44.526]         if (TRUE) {
[10:22:44.526]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:44.526]                 open = "w")
[10:22:44.526]         }
[10:22:44.526]         else {
[10:22:44.526]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:44.526]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:44.526]         }
[10:22:44.526]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:44.526]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:44.526]             base::sink(type = "output", split = FALSE)
[10:22:44.526]             base::close(...future.stdout)
[10:22:44.526]         }, add = TRUE)
[10:22:44.526]     }
[10:22:44.526]     ...future.frame <- base::sys.nframe()
[10:22:44.526]     ...future.conditions <- base::list()
[10:22:44.526]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:44.526]     if (FALSE) {
[10:22:44.526]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:44.526]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:44.526]     }
[10:22:44.526]     ...future.result <- base::tryCatch({
[10:22:44.526]         base::withCallingHandlers({
[10:22:44.526]             ...future.value <- base::withVisible(base::local({
[10:22:44.526]                 withCallingHandlers({
[10:22:44.526]                   {
[10:22:44.526]                     do.call(function(...) {
[10:22:44.526]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.526]                       if (!identical(...future.globals.maxSize.org, 
[10:22:44.526]                         ...future.globals.maxSize)) {
[10:22:44.526]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.526]                         on.exit(options(oopts), add = TRUE)
[10:22:44.526]                       }
[10:22:44.526]                       {
[10:22:44.526]                         lapply(seq_along(...future.elements_ii), 
[10:22:44.526]                           FUN = function(jj) {
[10:22:44.526]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.526]                             ...future.FUN(...future.X_jj, ...)
[10:22:44.526]                           })
[10:22:44.526]                       }
[10:22:44.526]                     }, args = future.call.arguments)
[10:22:44.526]                   }
[10:22:44.526]                 }, immediateCondition = function(cond) {
[10:22:44.526]                   save_rds <- function (object, pathname, ...) 
[10:22:44.526]                   {
[10:22:44.526]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:44.526]                     if (file_test("-f", pathname_tmp)) {
[10:22:44.526]                       fi_tmp <- file.info(pathname_tmp)
[10:22:44.526]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:44.526]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:44.526]                         fi_tmp[["mtime"]])
[10:22:44.526]                     }
[10:22:44.526]                     tryCatch({
[10:22:44.526]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:44.526]                     }, error = function(ex) {
[10:22:44.526]                       msg <- conditionMessage(ex)
[10:22:44.526]                       fi_tmp <- file.info(pathname_tmp)
[10:22:44.526]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:44.526]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:44.526]                         fi_tmp[["mtime"]], msg)
[10:22:44.526]                       ex$message <- msg
[10:22:44.526]                       stop(ex)
[10:22:44.526]                     })
[10:22:44.526]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:44.526]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:44.526]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:44.526]                       fi_tmp <- file.info(pathname_tmp)
[10:22:44.526]                       fi <- file.info(pathname)
[10:22:44.526]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:44.526]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:44.526]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:44.526]                         fi[["size"]], fi[["mtime"]])
[10:22:44.526]                       stop(msg)
[10:22:44.526]                     }
[10:22:44.526]                     invisible(pathname)
[10:22:44.526]                   }
[10:22:44.526]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:44.526]                     rootPath = tempdir()) 
[10:22:44.526]                   {
[10:22:44.526]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:44.526]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:44.526]                       tmpdir = path, fileext = ".rds")
[10:22:44.526]                     save_rds(obj, file)
[10:22:44.526]                   }
[10:22:44.526]                   saveImmediateCondition(cond, path = "/tmp/RtmpTHXGJm/.future/immediateConditions")
[10:22:44.526]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.526]                   {
[10:22:44.526]                     inherits <- base::inherits
[10:22:44.526]                     invokeRestart <- base::invokeRestart
[10:22:44.526]                     is.null <- base::is.null
[10:22:44.526]                     muffled <- FALSE
[10:22:44.526]                     if (inherits(cond, "message")) {
[10:22:44.526]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:44.526]                       if (muffled) 
[10:22:44.526]                         invokeRestart("muffleMessage")
[10:22:44.526]                     }
[10:22:44.526]                     else if (inherits(cond, "warning")) {
[10:22:44.526]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:44.526]                       if (muffled) 
[10:22:44.526]                         invokeRestart("muffleWarning")
[10:22:44.526]                     }
[10:22:44.526]                     else if (inherits(cond, "condition")) {
[10:22:44.526]                       if (!is.null(pattern)) {
[10:22:44.526]                         computeRestarts <- base::computeRestarts
[10:22:44.526]                         grepl <- base::grepl
[10:22:44.526]                         restarts <- computeRestarts(cond)
[10:22:44.526]                         for (restart in restarts) {
[10:22:44.526]                           name <- restart$name
[10:22:44.526]                           if (is.null(name)) 
[10:22:44.526]                             next
[10:22:44.526]                           if (!grepl(pattern, name)) 
[10:22:44.526]                             next
[10:22:44.526]                           invokeRestart(restart)
[10:22:44.526]                           muffled <- TRUE
[10:22:44.526]                           break
[10:22:44.526]                         }
[10:22:44.526]                       }
[10:22:44.526]                     }
[10:22:44.526]                     invisible(muffled)
[10:22:44.526]                   }
[10:22:44.526]                   muffleCondition(cond)
[10:22:44.526]                 })
[10:22:44.526]             }))
[10:22:44.526]             future::FutureResult(value = ...future.value$value, 
[10:22:44.526]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.526]                   ...future.rng), globalenv = if (FALSE) 
[10:22:44.526]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:44.526]                     ...future.globalenv.names))
[10:22:44.526]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:44.526]         }, condition = base::local({
[10:22:44.526]             c <- base::c
[10:22:44.526]             inherits <- base::inherits
[10:22:44.526]             invokeRestart <- base::invokeRestart
[10:22:44.526]             length <- base::length
[10:22:44.526]             list <- base::list
[10:22:44.526]             seq.int <- base::seq.int
[10:22:44.526]             signalCondition <- base::signalCondition
[10:22:44.526]             sys.calls <- base::sys.calls
[10:22:44.526]             `[[` <- base::`[[`
[10:22:44.526]             `+` <- base::`+`
[10:22:44.526]             `<<-` <- base::`<<-`
[10:22:44.526]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:44.526]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:44.526]                   3L)]
[10:22:44.526]             }
[10:22:44.526]             function(cond) {
[10:22:44.526]                 is_error <- inherits(cond, "error")
[10:22:44.526]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:44.526]                   NULL)
[10:22:44.526]                 if (is_error) {
[10:22:44.526]                   sessionInformation <- function() {
[10:22:44.526]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:44.526]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:44.526]                       search = base::search(), system = base::Sys.info())
[10:22:44.526]                   }
[10:22:44.526]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.526]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:44.526]                     cond$call), session = sessionInformation(), 
[10:22:44.526]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:44.526]                   signalCondition(cond)
[10:22:44.526]                 }
[10:22:44.526]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:44.526]                 "immediateCondition"))) {
[10:22:44.526]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:44.526]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.526]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:44.526]                   if (TRUE && !signal) {
[10:22:44.526]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.526]                     {
[10:22:44.526]                       inherits <- base::inherits
[10:22:44.526]                       invokeRestart <- base::invokeRestart
[10:22:44.526]                       is.null <- base::is.null
[10:22:44.526]                       muffled <- FALSE
[10:22:44.526]                       if (inherits(cond, "message")) {
[10:22:44.526]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.526]                         if (muffled) 
[10:22:44.526]                           invokeRestart("muffleMessage")
[10:22:44.526]                       }
[10:22:44.526]                       else if (inherits(cond, "warning")) {
[10:22:44.526]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.526]                         if (muffled) 
[10:22:44.526]                           invokeRestart("muffleWarning")
[10:22:44.526]                       }
[10:22:44.526]                       else if (inherits(cond, "condition")) {
[10:22:44.526]                         if (!is.null(pattern)) {
[10:22:44.526]                           computeRestarts <- base::computeRestarts
[10:22:44.526]                           grepl <- base::grepl
[10:22:44.526]                           restarts <- computeRestarts(cond)
[10:22:44.526]                           for (restart in restarts) {
[10:22:44.526]                             name <- restart$name
[10:22:44.526]                             if (is.null(name)) 
[10:22:44.526]                               next
[10:22:44.526]                             if (!grepl(pattern, name)) 
[10:22:44.526]                               next
[10:22:44.526]                             invokeRestart(restart)
[10:22:44.526]                             muffled <- TRUE
[10:22:44.526]                             break
[10:22:44.526]                           }
[10:22:44.526]                         }
[10:22:44.526]                       }
[10:22:44.526]                       invisible(muffled)
[10:22:44.526]                     }
[10:22:44.526]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.526]                   }
[10:22:44.526]                 }
[10:22:44.526]                 else {
[10:22:44.526]                   if (TRUE) {
[10:22:44.526]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.526]                     {
[10:22:44.526]                       inherits <- base::inherits
[10:22:44.526]                       invokeRestart <- base::invokeRestart
[10:22:44.526]                       is.null <- base::is.null
[10:22:44.526]                       muffled <- FALSE
[10:22:44.526]                       if (inherits(cond, "message")) {
[10:22:44.526]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.526]                         if (muffled) 
[10:22:44.526]                           invokeRestart("muffleMessage")
[10:22:44.526]                       }
[10:22:44.526]                       else if (inherits(cond, "warning")) {
[10:22:44.526]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.526]                         if (muffled) 
[10:22:44.526]                           invokeRestart("muffleWarning")
[10:22:44.526]                       }
[10:22:44.526]                       else if (inherits(cond, "condition")) {
[10:22:44.526]                         if (!is.null(pattern)) {
[10:22:44.526]                           computeRestarts <- base::computeRestarts
[10:22:44.526]                           grepl <- base::grepl
[10:22:44.526]                           restarts <- computeRestarts(cond)
[10:22:44.526]                           for (restart in restarts) {
[10:22:44.526]                             name <- restart$name
[10:22:44.526]                             if (is.null(name)) 
[10:22:44.526]                               next
[10:22:44.526]                             if (!grepl(pattern, name)) 
[10:22:44.526]                               next
[10:22:44.526]                             invokeRestart(restart)
[10:22:44.526]                             muffled <- TRUE
[10:22:44.526]                             break
[10:22:44.526]                           }
[10:22:44.526]                         }
[10:22:44.526]                       }
[10:22:44.526]                       invisible(muffled)
[10:22:44.526]                     }
[10:22:44.526]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.526]                   }
[10:22:44.526]                 }
[10:22:44.526]             }
[10:22:44.526]         }))
[10:22:44.526]     }, error = function(ex) {
[10:22:44.526]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:44.526]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.526]                 ...future.rng), started = ...future.startTime, 
[10:22:44.526]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:44.526]             version = "1.8"), class = "FutureResult")
[10:22:44.526]     }, finally = {
[10:22:44.526]         if (!identical(...future.workdir, getwd())) 
[10:22:44.526]             setwd(...future.workdir)
[10:22:44.526]         {
[10:22:44.526]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:44.526]                 ...future.oldOptions$nwarnings <- NULL
[10:22:44.526]             }
[10:22:44.526]             base::options(...future.oldOptions)
[10:22:44.526]             if (.Platform$OS.type == "windows") {
[10:22:44.526]                 old_names <- names(...future.oldEnvVars)
[10:22:44.526]                 envs <- base::Sys.getenv()
[10:22:44.526]                 names <- names(envs)
[10:22:44.526]                 common <- intersect(names, old_names)
[10:22:44.526]                 added <- setdiff(names, old_names)
[10:22:44.526]                 removed <- setdiff(old_names, names)
[10:22:44.526]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:44.526]                   envs[common]]
[10:22:44.526]                 NAMES <- toupper(changed)
[10:22:44.526]                 args <- list()
[10:22:44.526]                 for (kk in seq_along(NAMES)) {
[10:22:44.526]                   name <- changed[[kk]]
[10:22:44.526]                   NAME <- NAMES[[kk]]
[10:22:44.526]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.526]                     next
[10:22:44.526]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.526]                 }
[10:22:44.526]                 NAMES <- toupper(added)
[10:22:44.526]                 for (kk in seq_along(NAMES)) {
[10:22:44.526]                   name <- added[[kk]]
[10:22:44.526]                   NAME <- NAMES[[kk]]
[10:22:44.526]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.526]                     next
[10:22:44.526]                   args[[name]] <- ""
[10:22:44.526]                 }
[10:22:44.526]                 NAMES <- toupper(removed)
[10:22:44.526]                 for (kk in seq_along(NAMES)) {
[10:22:44.526]                   name <- removed[[kk]]
[10:22:44.526]                   NAME <- NAMES[[kk]]
[10:22:44.526]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.526]                     next
[10:22:44.526]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.526]                 }
[10:22:44.526]                 if (length(args) > 0) 
[10:22:44.526]                   base::do.call(base::Sys.setenv, args = args)
[10:22:44.526]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:44.526]             }
[10:22:44.526]             else {
[10:22:44.526]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:44.526]             }
[10:22:44.526]             {
[10:22:44.526]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:44.526]                   0L) {
[10:22:44.526]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:44.526]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:44.526]                   base::options(opts)
[10:22:44.526]                 }
[10:22:44.526]                 {
[10:22:44.526]                   {
[10:22:44.526]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:44.526]                     NULL
[10:22:44.526]                   }
[10:22:44.526]                   options(future.plan = NULL)
[10:22:44.526]                   if (is.na(NA_character_)) 
[10:22:44.526]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.526]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:44.526]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:44.526]                     envir = parent.frame()) 
[10:22:44.526]                   {
[10:22:44.526]                     default_workers <- missing(workers)
[10:22:44.526]                     if (is.function(workers)) 
[10:22:44.526]                       workers <- workers()
[10:22:44.526]                     workers <- structure(as.integer(workers), 
[10:22:44.526]                       class = class(workers))
[10:22:44.526]                     stop_if_not(is.finite(workers), workers >= 
[10:22:44.526]                       1L)
[10:22:44.526]                     if ((workers == 1L && !inherits(workers, 
[10:22:44.526]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:44.526]                       if (default_workers) 
[10:22:44.526]                         supportsMulticore(warn = TRUE)
[10:22:44.526]                       return(sequential(..., envir = envir))
[10:22:44.526]                     }
[10:22:44.526]                     oopts <- options(mc.cores = workers)
[10:22:44.526]                     on.exit(options(oopts))
[10:22:44.526]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:44.526]                       envir = envir)
[10:22:44.526]                     if (!future$lazy) 
[10:22:44.526]                       future <- run(future)
[10:22:44.526]                     invisible(future)
[10:22:44.526]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:44.526]                 }
[10:22:44.526]             }
[10:22:44.526]         }
[10:22:44.526]     })
[10:22:44.526]     if (TRUE) {
[10:22:44.526]         base::sink(type = "output", split = FALSE)
[10:22:44.526]         if (TRUE) {
[10:22:44.526]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:44.526]         }
[10:22:44.526]         else {
[10:22:44.526]             ...future.result["stdout"] <- base::list(NULL)
[10:22:44.526]         }
[10:22:44.526]         base::close(...future.stdout)
[10:22:44.526]         ...future.stdout <- NULL
[10:22:44.526]     }
[10:22:44.526]     ...future.result$conditions <- ...future.conditions
[10:22:44.526]     ...future.result$finished <- base::Sys.time()
[10:22:44.526]     ...future.result
[10:22:44.526] }
[10:22:44.528] assign_globals() ...
[10:22:44.528] List of 5
[10:22:44.528]  $ future.call.arguments    : list()
[10:22:44.528]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.528]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:22:44.528]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:22:44.528]  $ ...future.elements_ii    :List of 1
[10:22:44.528]   ..$ : num [1:4] 1 3 1 7
[10:22:44.528]  $ ...future.seeds_ii       : NULL
[10:22:44.528]  $ ...future.globals.maxSize: num Inf
[10:22:44.528]  - attr(*, "resolved")= logi FALSE
[10:22:44.528]  - attr(*, "total_size")= num NA
[10:22:44.528]  - attr(*, "where")=List of 5
[10:22:44.528]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:44.528]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:44.528]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:44.528]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:44.528]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:44.528]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.528]  - attr(*, "already-done")= logi TRUE
[10:22:44.534] - copied ‘future.call.arguments’ to environment
[10:22:44.534] - copied ‘...future.FUN’ to environment
[10:22:44.534] - copied ‘...future.elements_ii’ to environment
[10:22:44.534] - copied ‘...future.seeds_ii’ to environment
[10:22:44.534] - copied ‘...future.globals.maxSize’ to environment
[10:22:44.534] assign_globals() ... done
[10:22:44.534] requestCore(): workers = 2
[10:22:44.537] MulticoreFuture started
[10:22:44.537] - Launch lazy future ... done
[10:22:44.537] run() for ‘MulticoreFuture’ ... done
[10:22:44.538] Created future:
[10:22:44.538] plan(): Setting new future strategy stack:
[10:22:44.538] List of future strategies:
[10:22:44.538] 1. sequential:
[10:22:44.538]    - args: function (..., envir = parent.frame())
[10:22:44.538]    - tweaked: FALSE
[10:22:44.538]    - call: NULL
[10:22:44.539] plan(): nbrOfWorkers() = 1
[10:22:44.541] plan(): Setting new future strategy stack:
[10:22:44.541] List of future strategies:
[10:22:44.541] 1. multicore:
[10:22:44.541]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:44.541]    - tweaked: FALSE
[10:22:44.541]    - call: plan(strategy)
[10:22:44.546] plan(): nbrOfWorkers() = 2
[10:22:44.538] MulticoreFuture:
[10:22:44.538] Label: ‘future_apply-1’
[10:22:44.538] Expression:
[10:22:44.538] {
[10:22:44.538]     do.call(function(...) {
[10:22:44.538]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.538]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:44.538]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.538]             on.exit(options(oopts), add = TRUE)
[10:22:44.538]         }
[10:22:44.538]         {
[10:22:44.538]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:44.538]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.538]                 ...future.FUN(...future.X_jj, ...)
[10:22:44.538]             })
[10:22:44.538]         }
[10:22:44.538]     }, args = future.call.arguments)
[10:22:44.538] }
[10:22:44.538] Lazy evaluation: FALSE
[10:22:44.538] Asynchronous evaluation: TRUE
[10:22:44.538] Local evaluation: TRUE
[10:22:44.538] Environment: R_GlobalEnv
[10:22:44.538] Capture standard output: TRUE
[10:22:44.538] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:44.538] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:44.538] Packages: <none>
[10:22:44.538] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:44.538] Resolved: TRUE
[10:22:44.538] Value: <not collected>
[10:22:44.538] Conditions captured: <none>
[10:22:44.538] Early signaling: FALSE
[10:22:44.538] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:44.538] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:44.547] Chunk #1 of 2 ... DONE
[10:22:44.547] Chunk #2 of 2 ...
[10:22:44.548]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:44.548]  - seeds: <none>
[10:22:44.548]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.548] getGlobalsAndPackages() ...
[10:22:44.548] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.549] Resolving globals: FALSE
[10:22:44.549] Tweak future expression to call with '...' arguments ...
[10:22:44.549] {
[10:22:44.549]     do.call(function(...) {
[10:22:44.549]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.549]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:44.549]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.549]             on.exit(options(oopts), add = TRUE)
[10:22:44.549]         }
[10:22:44.549]         {
[10:22:44.549]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:44.549]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.549]                 ...future.FUN(...future.X_jj, ...)
[10:22:44.549]             })
[10:22:44.549]         }
[10:22:44.549]     }, args = future.call.arguments)
[10:22:44.549] }
[10:22:44.549] Tweak future expression to call with '...' arguments ... DONE
[10:22:44.550] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.550] 
[10:22:44.550] getGlobalsAndPackages() ... DONE
[10:22:44.551] run() for ‘Future’ ...
[10:22:44.551] - state: ‘created’
[10:22:44.551] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:44.556] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:44.556] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:44.556]   - Field: ‘label’
[10:22:44.556]   - Field: ‘local’
[10:22:44.556]   - Field: ‘owner’
[10:22:44.557]   - Field: ‘envir’
[10:22:44.557]   - Field: ‘workers’
[10:22:44.557]   - Field: ‘packages’
[10:22:44.557]   - Field: ‘gc’
[10:22:44.557]   - Field: ‘job’
[10:22:44.557]   - Field: ‘conditions’
[10:22:44.558]   - Field: ‘expr’
[10:22:44.558]   - Field: ‘uuid’
[10:22:44.558]   - Field: ‘seed’
[10:22:44.558]   - Field: ‘version’
[10:22:44.558]   - Field: ‘result’
[10:22:44.559]   - Field: ‘asynchronous’
[10:22:44.559]   - Field: ‘calls’
[10:22:44.559]   - Field: ‘globals’
[10:22:44.559]   - Field: ‘stdout’
[10:22:44.559]   - Field: ‘earlySignal’
[10:22:44.559]   - Field: ‘lazy’
[10:22:44.559]   - Field: ‘state’
[10:22:44.560] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:44.560] - Launch lazy future ...
[10:22:44.560] Packages needed by the future expression (n = 0): <none>
[10:22:44.560] Packages needed by future strategies (n = 0): <none>
[10:22:44.561] {
[10:22:44.561]     {
[10:22:44.561]         {
[10:22:44.561]             ...future.startTime <- base::Sys.time()
[10:22:44.561]             {
[10:22:44.561]                 {
[10:22:44.561]                   {
[10:22:44.561]                     {
[10:22:44.561]                       base::local({
[10:22:44.561]                         has_future <- base::requireNamespace("future", 
[10:22:44.561]                           quietly = TRUE)
[10:22:44.561]                         if (has_future) {
[10:22:44.561]                           ns <- base::getNamespace("future")
[10:22:44.561]                           version <- ns[[".package"]][["version"]]
[10:22:44.561]                           if (is.null(version)) 
[10:22:44.561]                             version <- utils::packageVersion("future")
[10:22:44.561]                         }
[10:22:44.561]                         else {
[10:22:44.561]                           version <- NULL
[10:22:44.561]                         }
[10:22:44.561]                         if (!has_future || version < "1.8.0") {
[10:22:44.561]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:44.561]                             "", base::R.version$version.string), 
[10:22:44.561]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:44.561]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:44.561]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:44.561]                               "release", "version")], collapse = " "), 
[10:22:44.561]                             hostname = base::Sys.info()[["nodename"]])
[10:22:44.561]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:44.561]                             info)
[10:22:44.561]                           info <- base::paste(info, collapse = "; ")
[10:22:44.561]                           if (!has_future) {
[10:22:44.561]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:44.561]                               info)
[10:22:44.561]                           }
[10:22:44.561]                           else {
[10:22:44.561]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:44.561]                               info, version)
[10:22:44.561]                           }
[10:22:44.561]                           base::stop(msg)
[10:22:44.561]                         }
[10:22:44.561]                       })
[10:22:44.561]                     }
[10:22:44.561]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:44.561]                     base::options(mc.cores = 1L)
[10:22:44.561]                   }
[10:22:44.561]                   options(future.plan = NULL)
[10:22:44.561]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.561]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:44.561]                 }
[10:22:44.561]                 ...future.workdir <- getwd()
[10:22:44.561]             }
[10:22:44.561]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:44.561]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:44.561]         }
[10:22:44.561]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:44.561]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:44.561]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:44.561]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:44.561]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:44.561]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:44.561]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:44.561]             base::names(...future.oldOptions))
[10:22:44.561]     }
[10:22:44.561]     if (FALSE) {
[10:22:44.561]     }
[10:22:44.561]     else {
[10:22:44.561]         if (TRUE) {
[10:22:44.561]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:44.561]                 open = "w")
[10:22:44.561]         }
[10:22:44.561]         else {
[10:22:44.561]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:44.561]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:44.561]         }
[10:22:44.561]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:44.561]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:44.561]             base::sink(type = "output", split = FALSE)
[10:22:44.561]             base::close(...future.stdout)
[10:22:44.561]         }, add = TRUE)
[10:22:44.561]     }
[10:22:44.561]     ...future.frame <- base::sys.nframe()
[10:22:44.561]     ...future.conditions <- base::list()
[10:22:44.561]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:44.561]     if (FALSE) {
[10:22:44.561]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:44.561]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:44.561]     }
[10:22:44.561]     ...future.result <- base::tryCatch({
[10:22:44.561]         base::withCallingHandlers({
[10:22:44.561]             ...future.value <- base::withVisible(base::local({
[10:22:44.561]                 withCallingHandlers({
[10:22:44.561]                   {
[10:22:44.561]                     do.call(function(...) {
[10:22:44.561]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.561]                       if (!identical(...future.globals.maxSize.org, 
[10:22:44.561]                         ...future.globals.maxSize)) {
[10:22:44.561]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.561]                         on.exit(options(oopts), add = TRUE)
[10:22:44.561]                       }
[10:22:44.561]                       {
[10:22:44.561]                         lapply(seq_along(...future.elements_ii), 
[10:22:44.561]                           FUN = function(jj) {
[10:22:44.561]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.561]                             ...future.FUN(...future.X_jj, ...)
[10:22:44.561]                           })
[10:22:44.561]                       }
[10:22:44.561]                     }, args = future.call.arguments)
[10:22:44.561]                   }
[10:22:44.561]                 }, immediateCondition = function(cond) {
[10:22:44.561]                   save_rds <- function (object, pathname, ...) 
[10:22:44.561]                   {
[10:22:44.561]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:44.561]                     if (file_test("-f", pathname_tmp)) {
[10:22:44.561]                       fi_tmp <- file.info(pathname_tmp)
[10:22:44.561]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:44.561]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:44.561]                         fi_tmp[["mtime"]])
[10:22:44.561]                     }
[10:22:44.561]                     tryCatch({
[10:22:44.561]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:44.561]                     }, error = function(ex) {
[10:22:44.561]                       msg <- conditionMessage(ex)
[10:22:44.561]                       fi_tmp <- file.info(pathname_tmp)
[10:22:44.561]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:44.561]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:44.561]                         fi_tmp[["mtime"]], msg)
[10:22:44.561]                       ex$message <- msg
[10:22:44.561]                       stop(ex)
[10:22:44.561]                     })
[10:22:44.561]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:44.561]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:44.561]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:44.561]                       fi_tmp <- file.info(pathname_tmp)
[10:22:44.561]                       fi <- file.info(pathname)
[10:22:44.561]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:44.561]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:44.561]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:44.561]                         fi[["size"]], fi[["mtime"]])
[10:22:44.561]                       stop(msg)
[10:22:44.561]                     }
[10:22:44.561]                     invisible(pathname)
[10:22:44.561]                   }
[10:22:44.561]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:44.561]                     rootPath = tempdir()) 
[10:22:44.561]                   {
[10:22:44.561]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:44.561]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:44.561]                       tmpdir = path, fileext = ".rds")
[10:22:44.561]                     save_rds(obj, file)
[10:22:44.561]                   }
[10:22:44.561]                   saveImmediateCondition(cond, path = "/tmp/RtmpTHXGJm/.future/immediateConditions")
[10:22:44.561]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.561]                   {
[10:22:44.561]                     inherits <- base::inherits
[10:22:44.561]                     invokeRestart <- base::invokeRestart
[10:22:44.561]                     is.null <- base::is.null
[10:22:44.561]                     muffled <- FALSE
[10:22:44.561]                     if (inherits(cond, "message")) {
[10:22:44.561]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:44.561]                       if (muffled) 
[10:22:44.561]                         invokeRestart("muffleMessage")
[10:22:44.561]                     }
[10:22:44.561]                     else if (inherits(cond, "warning")) {
[10:22:44.561]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:44.561]                       if (muffled) 
[10:22:44.561]                         invokeRestart("muffleWarning")
[10:22:44.561]                     }
[10:22:44.561]                     else if (inherits(cond, "condition")) {
[10:22:44.561]                       if (!is.null(pattern)) {
[10:22:44.561]                         computeRestarts <- base::computeRestarts
[10:22:44.561]                         grepl <- base::grepl
[10:22:44.561]                         restarts <- computeRestarts(cond)
[10:22:44.561]                         for (restart in restarts) {
[10:22:44.561]                           name <- restart$name
[10:22:44.561]                           if (is.null(name)) 
[10:22:44.561]                             next
[10:22:44.561]                           if (!grepl(pattern, name)) 
[10:22:44.561]                             next
[10:22:44.561]                           invokeRestart(restart)
[10:22:44.561]                           muffled <- TRUE
[10:22:44.561]                           break
[10:22:44.561]                         }
[10:22:44.561]                       }
[10:22:44.561]                     }
[10:22:44.561]                     invisible(muffled)
[10:22:44.561]                   }
[10:22:44.561]                   muffleCondition(cond)
[10:22:44.561]                 })
[10:22:44.561]             }))
[10:22:44.561]             future::FutureResult(value = ...future.value$value, 
[10:22:44.561]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.561]                   ...future.rng), globalenv = if (FALSE) 
[10:22:44.561]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:44.561]                     ...future.globalenv.names))
[10:22:44.561]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:44.561]         }, condition = base::local({
[10:22:44.561]             c <- base::c
[10:22:44.561]             inherits <- base::inherits
[10:22:44.561]             invokeRestart <- base::invokeRestart
[10:22:44.561]             length <- base::length
[10:22:44.561]             list <- base::list
[10:22:44.561]             seq.int <- base::seq.int
[10:22:44.561]             signalCondition <- base::signalCondition
[10:22:44.561]             sys.calls <- base::sys.calls
[10:22:44.561]             `[[` <- base::`[[`
[10:22:44.561]             `+` <- base::`+`
[10:22:44.561]             `<<-` <- base::`<<-`
[10:22:44.561]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:44.561]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:44.561]                   3L)]
[10:22:44.561]             }
[10:22:44.561]             function(cond) {
[10:22:44.561]                 is_error <- inherits(cond, "error")
[10:22:44.561]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:44.561]                   NULL)
[10:22:44.561]                 if (is_error) {
[10:22:44.561]                   sessionInformation <- function() {
[10:22:44.561]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:44.561]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:44.561]                       search = base::search(), system = base::Sys.info())
[10:22:44.561]                   }
[10:22:44.561]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.561]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:44.561]                     cond$call), session = sessionInformation(), 
[10:22:44.561]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:44.561]                   signalCondition(cond)
[10:22:44.561]                 }
[10:22:44.561]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:44.561]                 "immediateCondition"))) {
[10:22:44.561]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:44.561]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.561]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:44.561]                   if (TRUE && !signal) {
[10:22:44.561]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.561]                     {
[10:22:44.561]                       inherits <- base::inherits
[10:22:44.561]                       invokeRestart <- base::invokeRestart
[10:22:44.561]                       is.null <- base::is.null
[10:22:44.561]                       muffled <- FALSE
[10:22:44.561]                       if (inherits(cond, "message")) {
[10:22:44.561]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.561]                         if (muffled) 
[10:22:44.561]                           invokeRestart("muffleMessage")
[10:22:44.561]                       }
[10:22:44.561]                       else if (inherits(cond, "warning")) {
[10:22:44.561]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.561]                         if (muffled) 
[10:22:44.561]                           invokeRestart("muffleWarning")
[10:22:44.561]                       }
[10:22:44.561]                       else if (inherits(cond, "condition")) {
[10:22:44.561]                         if (!is.null(pattern)) {
[10:22:44.561]                           computeRestarts <- base::computeRestarts
[10:22:44.561]                           grepl <- base::grepl
[10:22:44.561]                           restarts <- computeRestarts(cond)
[10:22:44.561]                           for (restart in restarts) {
[10:22:44.561]                             name <- restart$name
[10:22:44.561]                             if (is.null(name)) 
[10:22:44.561]                               next
[10:22:44.561]                             if (!grepl(pattern, name)) 
[10:22:44.561]                               next
[10:22:44.561]                             invokeRestart(restart)
[10:22:44.561]                             muffled <- TRUE
[10:22:44.561]                             break
[10:22:44.561]                           }
[10:22:44.561]                         }
[10:22:44.561]                       }
[10:22:44.561]                       invisible(muffled)
[10:22:44.561]                     }
[10:22:44.561]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.561]                   }
[10:22:44.561]                 }
[10:22:44.561]                 else {
[10:22:44.561]                   if (TRUE) {
[10:22:44.561]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.561]                     {
[10:22:44.561]                       inherits <- base::inherits
[10:22:44.561]                       invokeRestart <- base::invokeRestart
[10:22:44.561]                       is.null <- base::is.null
[10:22:44.561]                       muffled <- FALSE
[10:22:44.561]                       if (inherits(cond, "message")) {
[10:22:44.561]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.561]                         if (muffled) 
[10:22:44.561]                           invokeRestart("muffleMessage")
[10:22:44.561]                       }
[10:22:44.561]                       else if (inherits(cond, "warning")) {
[10:22:44.561]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.561]                         if (muffled) 
[10:22:44.561]                           invokeRestart("muffleWarning")
[10:22:44.561]                       }
[10:22:44.561]                       else if (inherits(cond, "condition")) {
[10:22:44.561]                         if (!is.null(pattern)) {
[10:22:44.561]                           computeRestarts <- base::computeRestarts
[10:22:44.561]                           grepl <- base::grepl
[10:22:44.561]                           restarts <- computeRestarts(cond)
[10:22:44.561]                           for (restart in restarts) {
[10:22:44.561]                             name <- restart$name
[10:22:44.561]                             if (is.null(name)) 
[10:22:44.561]                               next
[10:22:44.561]                             if (!grepl(pattern, name)) 
[10:22:44.561]                               next
[10:22:44.561]                             invokeRestart(restart)
[10:22:44.561]                             muffled <- TRUE
[10:22:44.561]                             break
[10:22:44.561]                           }
[10:22:44.561]                         }
[10:22:44.561]                       }
[10:22:44.561]                       invisible(muffled)
[10:22:44.561]                     }
[10:22:44.561]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.561]                   }
[10:22:44.561]                 }
[10:22:44.561]             }
[10:22:44.561]         }))
[10:22:44.561]     }, error = function(ex) {
[10:22:44.561]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:44.561]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.561]                 ...future.rng), started = ...future.startTime, 
[10:22:44.561]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:44.561]             version = "1.8"), class = "FutureResult")
[10:22:44.561]     }, finally = {
[10:22:44.561]         if (!identical(...future.workdir, getwd())) 
[10:22:44.561]             setwd(...future.workdir)
[10:22:44.561]         {
[10:22:44.561]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:44.561]                 ...future.oldOptions$nwarnings <- NULL
[10:22:44.561]             }
[10:22:44.561]             base::options(...future.oldOptions)
[10:22:44.561]             if (.Platform$OS.type == "windows") {
[10:22:44.561]                 old_names <- names(...future.oldEnvVars)
[10:22:44.561]                 envs <- base::Sys.getenv()
[10:22:44.561]                 names <- names(envs)
[10:22:44.561]                 common <- intersect(names, old_names)
[10:22:44.561]                 added <- setdiff(names, old_names)
[10:22:44.561]                 removed <- setdiff(old_names, names)
[10:22:44.561]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:44.561]                   envs[common]]
[10:22:44.561]                 NAMES <- toupper(changed)
[10:22:44.561]                 args <- list()
[10:22:44.561]                 for (kk in seq_along(NAMES)) {
[10:22:44.561]                   name <- changed[[kk]]
[10:22:44.561]                   NAME <- NAMES[[kk]]
[10:22:44.561]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.561]                     next
[10:22:44.561]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.561]                 }
[10:22:44.561]                 NAMES <- toupper(added)
[10:22:44.561]                 for (kk in seq_along(NAMES)) {
[10:22:44.561]                   name <- added[[kk]]
[10:22:44.561]                   NAME <- NAMES[[kk]]
[10:22:44.561]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.561]                     next
[10:22:44.561]                   args[[name]] <- ""
[10:22:44.561]                 }
[10:22:44.561]                 NAMES <- toupper(removed)
[10:22:44.561]                 for (kk in seq_along(NAMES)) {
[10:22:44.561]                   name <- removed[[kk]]
[10:22:44.561]                   NAME <- NAMES[[kk]]
[10:22:44.561]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.561]                     next
[10:22:44.561]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.561]                 }
[10:22:44.561]                 if (length(args) > 0) 
[10:22:44.561]                   base::do.call(base::Sys.setenv, args = args)
[10:22:44.561]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:44.561]             }
[10:22:44.561]             else {
[10:22:44.561]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:44.561]             }
[10:22:44.561]             {
[10:22:44.561]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:44.561]                   0L) {
[10:22:44.561]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:44.561]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:44.561]                   base::options(opts)
[10:22:44.561]                 }
[10:22:44.561]                 {
[10:22:44.561]                   {
[10:22:44.561]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:44.561]                     NULL
[10:22:44.561]                   }
[10:22:44.561]                   options(future.plan = NULL)
[10:22:44.561]                   if (is.na(NA_character_)) 
[10:22:44.561]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.561]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:44.561]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:44.561]                     envir = parent.frame()) 
[10:22:44.561]                   {
[10:22:44.561]                     default_workers <- missing(workers)
[10:22:44.561]                     if (is.function(workers)) 
[10:22:44.561]                       workers <- workers()
[10:22:44.561]                     workers <- structure(as.integer(workers), 
[10:22:44.561]                       class = class(workers))
[10:22:44.561]                     stop_if_not(is.finite(workers), workers >= 
[10:22:44.561]                       1L)
[10:22:44.561]                     if ((workers == 1L && !inherits(workers, 
[10:22:44.561]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:44.561]                       if (default_workers) 
[10:22:44.561]                         supportsMulticore(warn = TRUE)
[10:22:44.561]                       return(sequential(..., envir = envir))
[10:22:44.561]                     }
[10:22:44.561]                     oopts <- options(mc.cores = workers)
[10:22:44.561]                     on.exit(options(oopts))
[10:22:44.561]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:44.561]                       envir = envir)
[10:22:44.561]                     if (!future$lazy) 
[10:22:44.561]                       future <- run(future)
[10:22:44.561]                     invisible(future)
[10:22:44.561]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:44.561]                 }
[10:22:44.561]             }
[10:22:44.561]         }
[10:22:44.561]     })
[10:22:44.561]     if (TRUE) {
[10:22:44.561]         base::sink(type = "output", split = FALSE)
[10:22:44.561]         if (TRUE) {
[10:22:44.561]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:44.561]         }
[10:22:44.561]         else {
[10:22:44.561]             ...future.result["stdout"] <- base::list(NULL)
[10:22:44.561]         }
[10:22:44.561]         base::close(...future.stdout)
[10:22:44.561]         ...future.stdout <- NULL
[10:22:44.561]     }
[10:22:44.561]     ...future.result$conditions <- ...future.conditions
[10:22:44.561]     ...future.result$finished <- base::Sys.time()
[10:22:44.561]     ...future.result
[10:22:44.561] }
[10:22:44.565] assign_globals() ...
[10:22:44.565] List of 5
[10:22:44.565]  $ future.call.arguments    : list()
[10:22:44.565]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.565]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:22:44.565]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:22:44.565]  $ ...future.elements_ii    :List of 1
[10:22:44.565]   ..$ : num [1:4] 2 4 6 8
[10:22:44.565]  $ ...future.seeds_ii       : NULL
[10:22:44.565]  $ ...future.globals.maxSize: num Inf
[10:22:44.565]  - attr(*, "resolved")= logi FALSE
[10:22:44.565]  - attr(*, "total_size")= num NA
[10:22:44.565]  - attr(*, "where")=List of 5
[10:22:44.565]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:44.565]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:44.565]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:44.565]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:44.565]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:44.565]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.565]  - attr(*, "already-done")= logi TRUE
[10:22:44.574] - copied ‘future.call.arguments’ to environment
[10:22:44.575] - copied ‘...future.FUN’ to environment
[10:22:44.575] - copied ‘...future.elements_ii’ to environment
[10:22:44.575] - copied ‘...future.seeds_ii’ to environment
[10:22:44.575] - copied ‘...future.globals.maxSize’ to environment
[10:22:44.576] assign_globals() ... done
[10:22:44.576] requestCore(): workers = 2
[10:22:44.579] MulticoreFuture started
[10:22:44.579] - Launch lazy future ... done
[10:22:44.580] plan(): Setting new future strategy stack:
[10:22:44.580] run() for ‘MulticoreFuture’ ... done
[10:22:44.580] Created future:
[10:22:44.580] List of future strategies:
[10:22:44.580] 1. sequential:
[10:22:44.580]    - args: function (..., envir = parent.frame())
[10:22:44.580]    - tweaked: FALSE
[10:22:44.580]    - call: NULL
[10:22:44.581] plan(): nbrOfWorkers() = 1
[10:22:44.584] plan(): Setting new future strategy stack:
[10:22:44.584] List of future strategies:
[10:22:44.584] 1. multicore:
[10:22:44.584]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:44.584]    - tweaked: FALSE
[10:22:44.584]    - call: plan(strategy)
[10:22:44.590] plan(): nbrOfWorkers() = 2
[10:22:44.581] MulticoreFuture:
[10:22:44.581] Label: ‘future_apply-2’
[10:22:44.581] Expression:
[10:22:44.581] {
[10:22:44.581]     do.call(function(...) {
[10:22:44.581]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.581]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:44.581]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.581]             on.exit(options(oopts), add = TRUE)
[10:22:44.581]         }
[10:22:44.581]         {
[10:22:44.581]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:44.581]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.581]                 ...future.FUN(...future.X_jj, ...)
[10:22:44.581]             })
[10:22:44.581]         }
[10:22:44.581]     }, args = future.call.arguments)
[10:22:44.581] }
[10:22:44.581] Lazy evaluation: FALSE
[10:22:44.581] Asynchronous evaluation: TRUE
[10:22:44.581] Local evaluation: TRUE
[10:22:44.581] Environment: R_GlobalEnv
[10:22:44.581] Capture standard output: TRUE
[10:22:44.581] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:44.581] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:44.581] Packages: <none>
[10:22:44.581] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:44.581] Resolved: TRUE
[10:22:44.581] Value: <not collected>
[10:22:44.581] Conditions captured: <none>
[10:22:44.581] Early signaling: FALSE
[10:22:44.581] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:44.581] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:44.591] Chunk #2 of 2 ... DONE
[10:22:44.591] Launching 2 futures (chunks) ... DONE
[10:22:44.591] Resolving 2 futures (chunks) ...
[10:22:44.591] resolve() on list ...
[10:22:44.592]  recursive: 0
[10:22:44.592]  length: 2
[10:22:44.592] 
[10:22:44.592] Future #1
[10:22:44.593] result() for MulticoreFuture ...
[10:22:44.594] result() for MulticoreFuture ...
[10:22:44.594] result() for MulticoreFuture ... done
[10:22:44.594] result() for MulticoreFuture ... done
[10:22:44.594] result() for MulticoreFuture ...
[10:22:44.594] result() for MulticoreFuture ... done
[10:22:44.595] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:22:44.595] - nx: 2
[10:22:44.595] - relay: TRUE
[10:22:44.595] - stdout: TRUE
[10:22:44.595] - signal: TRUE
[10:22:44.595] - resignal: FALSE
[10:22:44.595] - force: TRUE
[10:22:44.596] - relayed: [n=2] FALSE, FALSE
[10:22:44.596] - queued futures: [n=2] FALSE, FALSE
[10:22:44.596]  - until=1
[10:22:44.596]  - relaying element #1
[10:22:44.596] result() for MulticoreFuture ...
[10:22:44.596] result() for MulticoreFuture ... done
[10:22:44.597] result() for MulticoreFuture ...
[10:22:44.597] result() for MulticoreFuture ... done
[10:22:44.597] result() for MulticoreFuture ...
[10:22:44.597] result() for MulticoreFuture ... done
[10:22:44.597] result() for MulticoreFuture ...
[10:22:44.597] result() for MulticoreFuture ... done
[10:22:44.598] - relayed: [n=2] TRUE, FALSE
[10:22:44.598] - queued futures: [n=2] TRUE, FALSE
[10:22:44.598] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:22:44.598]  length: 1 (resolved future 1)
[10:22:44.598] Future #2
[10:22:44.598] result() for MulticoreFuture ...
[10:22:44.599] result() for MulticoreFuture ...
[10:22:44.599] result() for MulticoreFuture ... done
[10:22:44.599] result() for MulticoreFuture ... done
[10:22:44.600] result() for MulticoreFuture ...
[10:22:44.600] result() for MulticoreFuture ... done
[10:22:44.600] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:22:44.600] - nx: 2
[10:22:44.600] - relay: TRUE
[10:22:44.600] - stdout: TRUE
[10:22:44.600] - signal: TRUE
[10:22:44.601] - resignal: FALSE
[10:22:44.601] - force: TRUE
[10:22:44.601] - relayed: [n=2] TRUE, FALSE
[10:22:44.601] - queued futures: [n=2] TRUE, FALSE
[10:22:44.601]  - until=2
[10:22:44.601]  - relaying element #2
[10:22:44.601] result() for MulticoreFuture ...
[10:22:44.601] result() for MulticoreFuture ... done
[10:22:44.601] result() for MulticoreFuture ...
[10:22:44.602] result() for MulticoreFuture ... done
[10:22:44.602] result() for MulticoreFuture ...
[10:22:44.602] result() for MulticoreFuture ... done
[10:22:44.602] result() for MulticoreFuture ...
[10:22:44.602] result() for MulticoreFuture ... done
[10:22:44.602] - relayed: [n=2] TRUE, TRUE
[10:22:44.602] - queued futures: [n=2] TRUE, TRUE
[10:22:44.602] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:22:44.602]  length: 0 (resolved future 2)
[10:22:44.603] Relaying remaining futures
[10:22:44.603] signalConditionsASAP(NULL, pos=0) ...
[10:22:44.603] - nx: 2
[10:22:44.603] - relay: TRUE
[10:22:44.603] - stdout: TRUE
[10:22:44.603] - signal: TRUE
[10:22:44.603] - resignal: FALSE
[10:22:44.603] - force: TRUE
[10:22:44.603] - relayed: [n=2] TRUE, TRUE
[10:22:44.603] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:22:44.604] - relayed: [n=2] TRUE, TRUE
[10:22:44.604] - queued futures: [n=2] TRUE, TRUE
[10:22:44.604] signalConditionsASAP(NULL, pos=0) ... done
[10:22:44.604] resolve() on list ... DONE
[10:22:44.604] result() for MulticoreFuture ...
[10:22:44.604] result() for MulticoreFuture ... done
[10:22:44.604] result() for MulticoreFuture ...
[10:22:44.604] result() for MulticoreFuture ... done
[10:22:44.605] result() for MulticoreFuture ...
[10:22:44.605] result() for MulticoreFuture ... done
[10:22:44.605] result() for MulticoreFuture ...
[10:22:44.605] result() for MulticoreFuture ... done
[10:22:44.605]  - Number of value chunks collected: 2
[10:22:44.605] Resolving 2 futures (chunks) ... DONE
[10:22:44.605] Reducing values from 2 chunks ...
[10:22:44.605]  - Number of values collected after concatenation: 2
[10:22:44.606]  - Number of values expected: 2
[10:22:44.606] Reducing values from 2 chunks ... DONE
[10:22:44.606] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[10:22:44.607] getGlobalsAndPackagesXApply() ...
[10:22:44.607]  - future.globals: TRUE
[10:22:44.607] getGlobalsAndPackages() ...
[10:22:44.607] Searching for globals...
[10:22:44.608] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:22:44.609] Searching for globals ... DONE
[10:22:44.609] Resolving globals: FALSE
[10:22:44.609] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[10:22:44.610] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[10:22:44.610] - globals: [1] ‘FUN’
[10:22:44.610] - packages: [1] ‘stats’
[10:22:44.610] getGlobalsAndPackages() ... DONE
[10:22:44.610]  - globals found/used: [n=1] ‘FUN’
[10:22:44.610]  - needed namespaces: [n=1] ‘stats’
[10:22:44.610] Finding globals ... DONE
[10:22:44.610]  - use_args: TRUE
[10:22:44.611]  - Getting '...' globals ...
[10:22:44.611] resolve() on list ...
[10:22:44.611]  recursive: 0
[10:22:44.611]  length: 1
[10:22:44.611]  elements: ‘...’
[10:22:44.611]  length: 0 (resolved future 1)
[10:22:44.611] resolve() on list ... DONE
[10:22:44.612]    - '...' content: [n=0] 
[10:22:44.612] List of 1
[10:22:44.612]  $ ...: list()
[10:22:44.612]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.612]  - attr(*, "where")=List of 1
[10:22:44.612]   ..$ ...:<environment: 0x55ca4cf7b3d8> 
[10:22:44.612]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.612]  - attr(*, "resolved")= logi TRUE
[10:22:44.612]  - attr(*, "total_size")= num NA
[10:22:44.618]  - Getting '...' globals ... DONE
[10:22:44.619] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:44.619] List of 2
[10:22:44.619]  $ ...future.FUN:function (x, ...)  
[10:22:44.619]  $ ...          : list()
[10:22:44.619]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.619]  - attr(*, "where")=List of 2
[10:22:44.619]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:44.619]   ..$ ...          :<environment: 0x55ca4cf7b3d8> 
[10:22:44.619]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.619]  - attr(*, "resolved")= logi FALSE
[10:22:44.619]  - attr(*, "total_size")= num 1248
[10:22:44.622] Packages to be attached in all futures: [n=1] ‘stats’
[10:22:44.622] getGlobalsAndPackagesXApply() ... DONE
[10:22:44.626] future_lapply() ...
[10:22:44.629] Number of chunks: 2
[10:22:44.630] getGlobalsAndPackagesXApply() ...
[10:22:44.630]  - future.globals: <name-value list> with names ‘list()’
[10:22:44.630]  - use_args: TRUE
[10:22:44.630] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:22:44.630] List of 2
[10:22:44.630]  $ ...          : list()
[10:22:44.630]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.630]  $ ...future.FUN:function (x, ...)  
[10:22:44.630]  - attr(*, "where")=List of 2
[10:22:44.630]   ..$ ...          :<environment: 0x55ca4cf7b3d8> 
[10:22:44.630]   ..$ ...future.FUN:<environment: namespace:stats> 
[10:22:44.630]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.630]  - attr(*, "resolved")= logi FALSE
[10:22:44.630]  - attr(*, "total_size")= num NA
[10:22:44.633] Packages to be attached in all futures: [n=1] ‘stats’
[10:22:44.633] getGlobalsAndPackagesXApply() ... DONE
[10:22:44.633] Number of futures (= number of chunks): 2
[10:22:44.633] Launching 2 futures (chunks) ...
[10:22:44.633] Chunk #1 of 2 ...
[10:22:44.634]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:44.634]  - seeds: <none>
[10:22:44.634]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.634] getGlobalsAndPackages() ...
[10:22:44.634] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.634] Resolving globals: FALSE
[10:22:44.634] Tweak future expression to call with '...' arguments ...
[10:22:44.634] {
[10:22:44.634]     do.call(function(...) {
[10:22:44.634]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.634]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:44.634]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.634]             on.exit(options(oopts), add = TRUE)
[10:22:44.634]         }
[10:22:44.634]         {
[10:22:44.634]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:44.634]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.634]                 ...future.FUN(...future.X_jj, ...)
[10:22:44.634]             })
[10:22:44.634]         }
[10:22:44.634]     }, args = future.call.arguments)
[10:22:44.634] }
[10:22:44.635] Tweak future expression to call with '...' arguments ... DONE
[10:22:44.635] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.635] - packages: [1] ‘stats’
[10:22:44.635] getGlobalsAndPackages() ... DONE
[10:22:44.635] run() for ‘Future’ ...
[10:22:44.636] - state: ‘created’
[10:22:44.636] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:44.639] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:44.639] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:44.639]   - Field: ‘label’
[10:22:44.640]   - Field: ‘local’
[10:22:44.640]   - Field: ‘owner’
[10:22:44.640]   - Field: ‘envir’
[10:22:44.640]   - Field: ‘workers’
[10:22:44.640]   - Field: ‘packages’
[10:22:44.640]   - Field: ‘gc’
[10:22:44.640]   - Field: ‘job’
[10:22:44.640]   - Field: ‘conditions’
[10:22:44.640]   - Field: ‘expr’
[10:22:44.640]   - Field: ‘uuid’
[10:22:44.640]   - Field: ‘seed’
[10:22:44.641]   - Field: ‘version’
[10:22:44.641]   - Field: ‘result’
[10:22:44.641]   - Field: ‘asynchronous’
[10:22:44.641]   - Field: ‘calls’
[10:22:44.641]   - Field: ‘globals’
[10:22:44.641]   - Field: ‘stdout’
[10:22:44.641]   - Field: ‘earlySignal’
[10:22:44.641]   - Field: ‘lazy’
[10:22:44.641]   - Field: ‘state’
[10:22:44.641] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:44.642] - Launch lazy future ...
[10:22:44.642] Packages needed by the future expression (n = 1): ‘stats’
[10:22:44.642] Packages needed by future strategies (n = 0): <none>
[10:22:44.642] {
[10:22:44.642]     {
[10:22:44.642]         {
[10:22:44.642]             ...future.startTime <- base::Sys.time()
[10:22:44.642]             {
[10:22:44.642]                 {
[10:22:44.642]                   {
[10:22:44.642]                     {
[10:22:44.642]                       {
[10:22:44.642]                         base::local({
[10:22:44.642]                           has_future <- base::requireNamespace("future", 
[10:22:44.642]                             quietly = TRUE)
[10:22:44.642]                           if (has_future) {
[10:22:44.642]                             ns <- base::getNamespace("future")
[10:22:44.642]                             version <- ns[[".package"]][["version"]]
[10:22:44.642]                             if (is.null(version)) 
[10:22:44.642]                               version <- utils::packageVersion("future")
[10:22:44.642]                           }
[10:22:44.642]                           else {
[10:22:44.642]                             version <- NULL
[10:22:44.642]                           }
[10:22:44.642]                           if (!has_future || version < "1.8.0") {
[10:22:44.642]                             info <- base::c(r_version = base::gsub("R version ", 
[10:22:44.642]                               "", base::R.version$version.string), 
[10:22:44.642]                               platform = base::sprintf("%s (%s-bit)", 
[10:22:44.642]                                 base::R.version$platform, 8 * 
[10:22:44.642]                                   base::.Machine$sizeof.pointer), 
[10:22:44.642]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:44.642]                                 "release", "version")], collapse = " "), 
[10:22:44.642]                               hostname = base::Sys.info()[["nodename"]])
[10:22:44.642]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:22:44.642]                               info)
[10:22:44.642]                             info <- base::paste(info, collapse = "; ")
[10:22:44.642]                             if (!has_future) {
[10:22:44.642]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:44.642]                                 info)
[10:22:44.642]                             }
[10:22:44.642]                             else {
[10:22:44.642]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:44.642]                                 info, version)
[10:22:44.642]                             }
[10:22:44.642]                             base::stop(msg)
[10:22:44.642]                           }
[10:22:44.642]                         })
[10:22:44.642]                       }
[10:22:44.642]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:44.642]                       base::options(mc.cores = 1L)
[10:22:44.642]                     }
[10:22:44.642]                     base::local({
[10:22:44.642]                       for (pkg in "stats") {
[10:22:44.642]                         base::loadNamespace(pkg)
[10:22:44.642]                         base::library(pkg, character.only = TRUE)
[10:22:44.642]                       }
[10:22:44.642]                     })
[10:22:44.642]                   }
[10:22:44.642]                   options(future.plan = NULL)
[10:22:44.642]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.642]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:44.642]                 }
[10:22:44.642]                 ...future.workdir <- getwd()
[10:22:44.642]             }
[10:22:44.642]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:44.642]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:44.642]         }
[10:22:44.642]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:44.642]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:44.642]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:44.642]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:44.642]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:44.642]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:44.642]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:44.642]             base::names(...future.oldOptions))
[10:22:44.642]     }
[10:22:44.642]     if (FALSE) {
[10:22:44.642]     }
[10:22:44.642]     else {
[10:22:44.642]         if (TRUE) {
[10:22:44.642]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:44.642]                 open = "w")
[10:22:44.642]         }
[10:22:44.642]         else {
[10:22:44.642]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:44.642]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:44.642]         }
[10:22:44.642]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:44.642]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:44.642]             base::sink(type = "output", split = FALSE)
[10:22:44.642]             base::close(...future.stdout)
[10:22:44.642]         }, add = TRUE)
[10:22:44.642]     }
[10:22:44.642]     ...future.frame <- base::sys.nframe()
[10:22:44.642]     ...future.conditions <- base::list()
[10:22:44.642]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:44.642]     if (FALSE) {
[10:22:44.642]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:44.642]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:44.642]     }
[10:22:44.642]     ...future.result <- base::tryCatch({
[10:22:44.642]         base::withCallingHandlers({
[10:22:44.642]             ...future.value <- base::withVisible(base::local({
[10:22:44.642]                 withCallingHandlers({
[10:22:44.642]                   {
[10:22:44.642]                     do.call(function(...) {
[10:22:44.642]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.642]                       if (!identical(...future.globals.maxSize.org, 
[10:22:44.642]                         ...future.globals.maxSize)) {
[10:22:44.642]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.642]                         on.exit(options(oopts), add = TRUE)
[10:22:44.642]                       }
[10:22:44.642]                       {
[10:22:44.642]                         lapply(seq_along(...future.elements_ii), 
[10:22:44.642]                           FUN = function(jj) {
[10:22:44.642]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.642]                             ...future.FUN(...future.X_jj, ...)
[10:22:44.642]                           })
[10:22:44.642]                       }
[10:22:44.642]                     }, args = future.call.arguments)
[10:22:44.642]                   }
[10:22:44.642]                 }, immediateCondition = function(cond) {
[10:22:44.642]                   save_rds <- function (object, pathname, ...) 
[10:22:44.642]                   {
[10:22:44.642]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:44.642]                     if (file_test("-f", pathname_tmp)) {
[10:22:44.642]                       fi_tmp <- file.info(pathname_tmp)
[10:22:44.642]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:44.642]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:44.642]                         fi_tmp[["mtime"]])
[10:22:44.642]                     }
[10:22:44.642]                     tryCatch({
[10:22:44.642]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:44.642]                     }, error = function(ex) {
[10:22:44.642]                       msg <- conditionMessage(ex)
[10:22:44.642]                       fi_tmp <- file.info(pathname_tmp)
[10:22:44.642]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:44.642]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:44.642]                         fi_tmp[["mtime"]], msg)
[10:22:44.642]                       ex$message <- msg
[10:22:44.642]                       stop(ex)
[10:22:44.642]                     })
[10:22:44.642]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:44.642]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:44.642]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:44.642]                       fi_tmp <- file.info(pathname_tmp)
[10:22:44.642]                       fi <- file.info(pathname)
[10:22:44.642]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:44.642]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:44.642]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:44.642]                         fi[["size"]], fi[["mtime"]])
[10:22:44.642]                       stop(msg)
[10:22:44.642]                     }
[10:22:44.642]                     invisible(pathname)
[10:22:44.642]                   }
[10:22:44.642]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:44.642]                     rootPath = tempdir()) 
[10:22:44.642]                   {
[10:22:44.642]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:44.642]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:44.642]                       tmpdir = path, fileext = ".rds")
[10:22:44.642]                     save_rds(obj, file)
[10:22:44.642]                   }
[10:22:44.642]                   saveImmediateCondition(cond, path = "/tmp/RtmpTHXGJm/.future/immediateConditions")
[10:22:44.642]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.642]                   {
[10:22:44.642]                     inherits <- base::inherits
[10:22:44.642]                     invokeRestart <- base::invokeRestart
[10:22:44.642]                     is.null <- base::is.null
[10:22:44.642]                     muffled <- FALSE
[10:22:44.642]                     if (inherits(cond, "message")) {
[10:22:44.642]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:44.642]                       if (muffled) 
[10:22:44.642]                         invokeRestart("muffleMessage")
[10:22:44.642]                     }
[10:22:44.642]                     else if (inherits(cond, "warning")) {
[10:22:44.642]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:44.642]                       if (muffled) 
[10:22:44.642]                         invokeRestart("muffleWarning")
[10:22:44.642]                     }
[10:22:44.642]                     else if (inherits(cond, "condition")) {
[10:22:44.642]                       if (!is.null(pattern)) {
[10:22:44.642]                         computeRestarts <- base::computeRestarts
[10:22:44.642]                         grepl <- base::grepl
[10:22:44.642]                         restarts <- computeRestarts(cond)
[10:22:44.642]                         for (restart in restarts) {
[10:22:44.642]                           name <- restart$name
[10:22:44.642]                           if (is.null(name)) 
[10:22:44.642]                             next
[10:22:44.642]                           if (!grepl(pattern, name)) 
[10:22:44.642]                             next
[10:22:44.642]                           invokeRestart(restart)
[10:22:44.642]                           muffled <- TRUE
[10:22:44.642]                           break
[10:22:44.642]                         }
[10:22:44.642]                       }
[10:22:44.642]                     }
[10:22:44.642]                     invisible(muffled)
[10:22:44.642]                   }
[10:22:44.642]                   muffleCondition(cond)
[10:22:44.642]                 })
[10:22:44.642]             }))
[10:22:44.642]             future::FutureResult(value = ...future.value$value, 
[10:22:44.642]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.642]                   ...future.rng), globalenv = if (FALSE) 
[10:22:44.642]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:44.642]                     ...future.globalenv.names))
[10:22:44.642]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:44.642]         }, condition = base::local({
[10:22:44.642]             c <- base::c
[10:22:44.642]             inherits <- base::inherits
[10:22:44.642]             invokeRestart <- base::invokeRestart
[10:22:44.642]             length <- base::length
[10:22:44.642]             list <- base::list
[10:22:44.642]             seq.int <- base::seq.int
[10:22:44.642]             signalCondition <- base::signalCondition
[10:22:44.642]             sys.calls <- base::sys.calls
[10:22:44.642]             `[[` <- base::`[[`
[10:22:44.642]             `+` <- base::`+`
[10:22:44.642]             `<<-` <- base::`<<-`
[10:22:44.642]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:44.642]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:44.642]                   3L)]
[10:22:44.642]             }
[10:22:44.642]             function(cond) {
[10:22:44.642]                 is_error <- inherits(cond, "error")
[10:22:44.642]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:44.642]                   NULL)
[10:22:44.642]                 if (is_error) {
[10:22:44.642]                   sessionInformation <- function() {
[10:22:44.642]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:44.642]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:44.642]                       search = base::search(), system = base::Sys.info())
[10:22:44.642]                   }
[10:22:44.642]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.642]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:44.642]                     cond$call), session = sessionInformation(), 
[10:22:44.642]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:44.642]                   signalCondition(cond)
[10:22:44.642]                 }
[10:22:44.642]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:44.642]                 "immediateCondition"))) {
[10:22:44.642]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:44.642]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.642]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:44.642]                   if (TRUE && !signal) {
[10:22:44.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.642]                     {
[10:22:44.642]                       inherits <- base::inherits
[10:22:44.642]                       invokeRestart <- base::invokeRestart
[10:22:44.642]                       is.null <- base::is.null
[10:22:44.642]                       muffled <- FALSE
[10:22:44.642]                       if (inherits(cond, "message")) {
[10:22:44.642]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.642]                         if (muffled) 
[10:22:44.642]                           invokeRestart("muffleMessage")
[10:22:44.642]                       }
[10:22:44.642]                       else if (inherits(cond, "warning")) {
[10:22:44.642]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.642]                         if (muffled) 
[10:22:44.642]                           invokeRestart("muffleWarning")
[10:22:44.642]                       }
[10:22:44.642]                       else if (inherits(cond, "condition")) {
[10:22:44.642]                         if (!is.null(pattern)) {
[10:22:44.642]                           computeRestarts <- base::computeRestarts
[10:22:44.642]                           grepl <- base::grepl
[10:22:44.642]                           restarts <- computeRestarts(cond)
[10:22:44.642]                           for (restart in restarts) {
[10:22:44.642]                             name <- restart$name
[10:22:44.642]                             if (is.null(name)) 
[10:22:44.642]                               next
[10:22:44.642]                             if (!grepl(pattern, name)) 
[10:22:44.642]                               next
[10:22:44.642]                             invokeRestart(restart)
[10:22:44.642]                             muffled <- TRUE
[10:22:44.642]                             break
[10:22:44.642]                           }
[10:22:44.642]                         }
[10:22:44.642]                       }
[10:22:44.642]                       invisible(muffled)
[10:22:44.642]                     }
[10:22:44.642]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.642]                   }
[10:22:44.642]                 }
[10:22:44.642]                 else {
[10:22:44.642]                   if (TRUE) {
[10:22:44.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.642]                     {
[10:22:44.642]                       inherits <- base::inherits
[10:22:44.642]                       invokeRestart <- base::invokeRestart
[10:22:44.642]                       is.null <- base::is.null
[10:22:44.642]                       muffled <- FALSE
[10:22:44.642]                       if (inherits(cond, "message")) {
[10:22:44.642]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.642]                         if (muffled) 
[10:22:44.642]                           invokeRestart("muffleMessage")
[10:22:44.642]                       }
[10:22:44.642]                       else if (inherits(cond, "warning")) {
[10:22:44.642]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.642]                         if (muffled) 
[10:22:44.642]                           invokeRestart("muffleWarning")
[10:22:44.642]                       }
[10:22:44.642]                       else if (inherits(cond, "condition")) {
[10:22:44.642]                         if (!is.null(pattern)) {
[10:22:44.642]                           computeRestarts <- base::computeRestarts
[10:22:44.642]                           grepl <- base::grepl
[10:22:44.642]                           restarts <- computeRestarts(cond)
[10:22:44.642]                           for (restart in restarts) {
[10:22:44.642]                             name <- restart$name
[10:22:44.642]                             if (is.null(name)) 
[10:22:44.642]                               next
[10:22:44.642]                             if (!grepl(pattern, name)) 
[10:22:44.642]                               next
[10:22:44.642]                             invokeRestart(restart)
[10:22:44.642]                             muffled <- TRUE
[10:22:44.642]                             break
[10:22:44.642]                           }
[10:22:44.642]                         }
[10:22:44.642]                       }
[10:22:44.642]                       invisible(muffled)
[10:22:44.642]                     }
[10:22:44.642]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.642]                   }
[10:22:44.642]                 }
[10:22:44.642]             }
[10:22:44.642]         }))
[10:22:44.642]     }, error = function(ex) {
[10:22:44.642]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:44.642]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.642]                 ...future.rng), started = ...future.startTime, 
[10:22:44.642]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:44.642]             version = "1.8"), class = "FutureResult")
[10:22:44.642]     }, finally = {
[10:22:44.642]         if (!identical(...future.workdir, getwd())) 
[10:22:44.642]             setwd(...future.workdir)
[10:22:44.642]         {
[10:22:44.642]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:44.642]                 ...future.oldOptions$nwarnings <- NULL
[10:22:44.642]             }
[10:22:44.642]             base::options(...future.oldOptions)
[10:22:44.642]             if (.Platform$OS.type == "windows") {
[10:22:44.642]                 old_names <- names(...future.oldEnvVars)
[10:22:44.642]                 envs <- base::Sys.getenv()
[10:22:44.642]                 names <- names(envs)
[10:22:44.642]                 common <- intersect(names, old_names)
[10:22:44.642]                 added <- setdiff(names, old_names)
[10:22:44.642]                 removed <- setdiff(old_names, names)
[10:22:44.642]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:44.642]                   envs[common]]
[10:22:44.642]                 NAMES <- toupper(changed)
[10:22:44.642]                 args <- list()
[10:22:44.642]                 for (kk in seq_along(NAMES)) {
[10:22:44.642]                   name <- changed[[kk]]
[10:22:44.642]                   NAME <- NAMES[[kk]]
[10:22:44.642]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.642]                     next
[10:22:44.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.642]                 }
[10:22:44.642]                 NAMES <- toupper(added)
[10:22:44.642]                 for (kk in seq_along(NAMES)) {
[10:22:44.642]                   name <- added[[kk]]
[10:22:44.642]                   NAME <- NAMES[[kk]]
[10:22:44.642]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.642]                     next
[10:22:44.642]                   args[[name]] <- ""
[10:22:44.642]                 }
[10:22:44.642]                 NAMES <- toupper(removed)
[10:22:44.642]                 for (kk in seq_along(NAMES)) {
[10:22:44.642]                   name <- removed[[kk]]
[10:22:44.642]                   NAME <- NAMES[[kk]]
[10:22:44.642]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.642]                     next
[10:22:44.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.642]                 }
[10:22:44.642]                 if (length(args) > 0) 
[10:22:44.642]                   base::do.call(base::Sys.setenv, args = args)
[10:22:44.642]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:44.642]             }
[10:22:44.642]             else {
[10:22:44.642]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:44.642]             }
[10:22:44.642]             {
[10:22:44.642]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:44.642]                   0L) {
[10:22:44.642]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:44.642]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:44.642]                   base::options(opts)
[10:22:44.642]                 }
[10:22:44.642]                 {
[10:22:44.642]                   {
[10:22:44.642]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:44.642]                     NULL
[10:22:44.642]                   }
[10:22:44.642]                   options(future.plan = NULL)
[10:22:44.642]                   if (is.na(NA_character_)) 
[10:22:44.642]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.642]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:44.642]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:44.642]                     envir = parent.frame()) 
[10:22:44.642]                   {
[10:22:44.642]                     default_workers <- missing(workers)
[10:22:44.642]                     if (is.function(workers)) 
[10:22:44.642]                       workers <- workers()
[10:22:44.642]                     workers <- structure(as.integer(workers), 
[10:22:44.642]                       class = class(workers))
[10:22:44.642]                     stop_if_not(is.finite(workers), workers >= 
[10:22:44.642]                       1L)
[10:22:44.642]                     if ((workers == 1L && !inherits(workers, 
[10:22:44.642]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:44.642]                       if (default_workers) 
[10:22:44.642]                         supportsMulticore(warn = TRUE)
[10:22:44.642]                       return(sequential(..., envir = envir))
[10:22:44.642]                     }
[10:22:44.642]                     oopts <- options(mc.cores = workers)
[10:22:44.642]                     on.exit(options(oopts))
[10:22:44.642]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:44.642]                       envir = envir)
[10:22:44.642]                     if (!future$lazy) 
[10:22:44.642]                       future <- run(future)
[10:22:44.642]                     invisible(future)
[10:22:44.642]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:44.642]                 }
[10:22:44.642]             }
[10:22:44.642]         }
[10:22:44.642]     })
[10:22:44.642]     if (TRUE) {
[10:22:44.642]         base::sink(type = "output", split = FALSE)
[10:22:44.642]         if (TRUE) {
[10:22:44.642]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:44.642]         }
[10:22:44.642]         else {
[10:22:44.642]             ...future.result["stdout"] <- base::list(NULL)
[10:22:44.642]         }
[10:22:44.642]         base::close(...future.stdout)
[10:22:44.642]         ...future.stdout <- NULL
[10:22:44.642]     }
[10:22:44.642]     ...future.result$conditions <- ...future.conditions
[10:22:44.642]     ...future.result$finished <- base::Sys.time()
[10:22:44.642]     ...future.result
[10:22:44.642] }
[10:22:44.645] assign_globals() ...
[10:22:44.645] List of 5
[10:22:44.645]  $ future.call.arguments    : list()
[10:22:44.645]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.645]  $ ...future.FUN            :function (x, ...)  
[10:22:44.645]  $ ...future.elements_ii    :List of 1
[10:22:44.645]   ..$ : num [1:4] 1 3 1 7
[10:22:44.645]  $ ...future.seeds_ii       : NULL
[10:22:44.645]  $ ...future.globals.maxSize: num Inf
[10:22:44.645]  - attr(*, "resolved")= logi FALSE
[10:22:44.645]  - attr(*, "total_size")= num NA
[10:22:44.645]  - attr(*, "where")=List of 5
[10:22:44.645]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:44.645]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:44.645]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:44.645]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:44.645]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:44.645]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.645]  - attr(*, "already-done")= logi TRUE
[10:22:44.651] - copied ‘future.call.arguments’ to environment
[10:22:44.651] - copied ‘...future.FUN’ to environment
[10:22:44.651] - copied ‘...future.elements_ii’ to environment
[10:22:44.652] - copied ‘...future.seeds_ii’ to environment
[10:22:44.652] - copied ‘...future.globals.maxSize’ to environment
[10:22:44.652] assign_globals() ... done
[10:22:44.652] requestCore(): workers = 2
[10:22:44.654] MulticoreFuture started
[10:22:44.655] - Launch lazy future ... done
[10:22:44.655] run() for ‘MulticoreFuture’ ... done
[10:22:44.655] Created future:
[10:22:44.656] plan(): Setting new future strategy stack:
[10:22:44.656] List of future strategies:
[10:22:44.656] 1. sequential:
[10:22:44.656]    - args: function (..., envir = parent.frame())
[10:22:44.656]    - tweaked: FALSE
[10:22:44.656]    - call: NULL
[10:22:44.657] plan(): nbrOfWorkers() = 1
[10:22:44.660] plan(): Setting new future strategy stack:
[10:22:44.660] List of future strategies:
[10:22:44.660] 1. multicore:
[10:22:44.660]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:44.660]    - tweaked: FALSE
[10:22:44.660]    - call: plan(strategy)
[10:22:44.665] plan(): nbrOfWorkers() = 2
[10:22:44.656] MulticoreFuture:
[10:22:44.656] Label: ‘future_apply-1’
[10:22:44.656] Expression:
[10:22:44.656] {
[10:22:44.656]     do.call(function(...) {
[10:22:44.656]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.656]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:44.656]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.656]             on.exit(options(oopts), add = TRUE)
[10:22:44.656]         }
[10:22:44.656]         {
[10:22:44.656]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:44.656]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.656]                 ...future.FUN(...future.X_jj, ...)
[10:22:44.656]             })
[10:22:44.656]         }
[10:22:44.656]     }, args = future.call.arguments)
[10:22:44.656] }
[10:22:44.656] Lazy evaluation: FALSE
[10:22:44.656] Asynchronous evaluation: TRUE
[10:22:44.656] Local evaluation: TRUE
[10:22:44.656] Environment: R_GlobalEnv
[10:22:44.656] Capture standard output: TRUE
[10:22:44.656] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:44.656] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:44.656] Packages: 1 packages (‘stats’)
[10:22:44.656] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:44.656] Resolved: TRUE
[10:22:44.656] Value: <not collected>
[10:22:44.656] Conditions captured: <none>
[10:22:44.656] Early signaling: FALSE
[10:22:44.656] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:44.656] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:44.666] Chunk #1 of 2 ... DONE
[10:22:44.667] Chunk #2 of 2 ...
[10:22:44.667]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:44.667]  - seeds: <none>
[10:22:44.667]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.667] getGlobalsAndPackages() ...
[10:22:44.668] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.668] Resolving globals: FALSE
[10:22:44.668] Tweak future expression to call with '...' arguments ...
[10:22:44.668] {
[10:22:44.668]     do.call(function(...) {
[10:22:44.668]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.668]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:44.668]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.668]             on.exit(options(oopts), add = TRUE)
[10:22:44.668]         }
[10:22:44.668]         {
[10:22:44.668]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:44.668]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.668]                 ...future.FUN(...future.X_jj, ...)
[10:22:44.668]             })
[10:22:44.668]         }
[10:22:44.668]     }, args = future.call.arguments)
[10:22:44.668] }
[10:22:44.669] Tweak future expression to call with '...' arguments ... DONE
[10:22:44.669] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.670] - packages: [1] ‘stats’
[10:22:44.670] getGlobalsAndPackages() ... DONE
[10:22:44.670] run() for ‘Future’ ...
[10:22:44.671] - state: ‘created’
[10:22:44.671] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:44.675] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:44.676] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:44.676]   - Field: ‘label’
[10:22:44.676]   - Field: ‘local’
[10:22:44.676]   - Field: ‘owner’
[10:22:44.676]   - Field: ‘envir’
[10:22:44.676]   - Field: ‘workers’
[10:22:44.677]   - Field: ‘packages’
[10:22:44.677]   - Field: ‘gc’
[10:22:44.677]   - Field: ‘job’
[10:22:44.677]   - Field: ‘conditions’
[10:22:44.677]   - Field: ‘expr’
[10:22:44.677]   - Field: ‘uuid’
[10:22:44.677]   - Field: ‘seed’
[10:22:44.678]   - Field: ‘version’
[10:22:44.678]   - Field: ‘result’
[10:22:44.678]   - Field: ‘asynchronous’
[10:22:44.678]   - Field: ‘calls’
[10:22:44.678]   - Field: ‘globals’
[10:22:44.678]   - Field: ‘stdout’
[10:22:44.678]   - Field: ‘earlySignal’
[10:22:44.679]   - Field: ‘lazy’
[10:22:44.679]   - Field: ‘state’
[10:22:44.679] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:44.679] - Launch lazy future ...
[10:22:44.679] Packages needed by the future expression (n = 1): ‘stats’
[10:22:44.680] Packages needed by future strategies (n = 0): <none>
[10:22:44.680] {
[10:22:44.680]     {
[10:22:44.680]         {
[10:22:44.680]             ...future.startTime <- base::Sys.time()
[10:22:44.680]             {
[10:22:44.680]                 {
[10:22:44.680]                   {
[10:22:44.680]                     {
[10:22:44.680]                       {
[10:22:44.680]                         base::local({
[10:22:44.680]                           has_future <- base::requireNamespace("future", 
[10:22:44.680]                             quietly = TRUE)
[10:22:44.680]                           if (has_future) {
[10:22:44.680]                             ns <- base::getNamespace("future")
[10:22:44.680]                             version <- ns[[".package"]][["version"]]
[10:22:44.680]                             if (is.null(version)) 
[10:22:44.680]                               version <- utils::packageVersion("future")
[10:22:44.680]                           }
[10:22:44.680]                           else {
[10:22:44.680]                             version <- NULL
[10:22:44.680]                           }
[10:22:44.680]                           if (!has_future || version < "1.8.0") {
[10:22:44.680]                             info <- base::c(r_version = base::gsub("R version ", 
[10:22:44.680]                               "", base::R.version$version.string), 
[10:22:44.680]                               platform = base::sprintf("%s (%s-bit)", 
[10:22:44.680]                                 base::R.version$platform, 8 * 
[10:22:44.680]                                   base::.Machine$sizeof.pointer), 
[10:22:44.680]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:44.680]                                 "release", "version")], collapse = " "), 
[10:22:44.680]                               hostname = base::Sys.info()[["nodename"]])
[10:22:44.680]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:22:44.680]                               info)
[10:22:44.680]                             info <- base::paste(info, collapse = "; ")
[10:22:44.680]                             if (!has_future) {
[10:22:44.680]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:44.680]                                 info)
[10:22:44.680]                             }
[10:22:44.680]                             else {
[10:22:44.680]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:44.680]                                 info, version)
[10:22:44.680]                             }
[10:22:44.680]                             base::stop(msg)
[10:22:44.680]                           }
[10:22:44.680]                         })
[10:22:44.680]                       }
[10:22:44.680]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:44.680]                       base::options(mc.cores = 1L)
[10:22:44.680]                     }
[10:22:44.680]                     base::local({
[10:22:44.680]                       for (pkg in "stats") {
[10:22:44.680]                         base::loadNamespace(pkg)
[10:22:44.680]                         base::library(pkg, character.only = TRUE)
[10:22:44.680]                       }
[10:22:44.680]                     })
[10:22:44.680]                   }
[10:22:44.680]                   options(future.plan = NULL)
[10:22:44.680]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.680]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:44.680]                 }
[10:22:44.680]                 ...future.workdir <- getwd()
[10:22:44.680]             }
[10:22:44.680]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:44.680]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:44.680]         }
[10:22:44.680]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:44.680]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:44.680]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:44.680]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:44.680]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:44.680]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:44.680]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:44.680]             base::names(...future.oldOptions))
[10:22:44.680]     }
[10:22:44.680]     if (FALSE) {
[10:22:44.680]     }
[10:22:44.680]     else {
[10:22:44.680]         if (TRUE) {
[10:22:44.680]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:44.680]                 open = "w")
[10:22:44.680]         }
[10:22:44.680]         else {
[10:22:44.680]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:44.680]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:44.680]         }
[10:22:44.680]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:44.680]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:44.680]             base::sink(type = "output", split = FALSE)
[10:22:44.680]             base::close(...future.stdout)
[10:22:44.680]         }, add = TRUE)
[10:22:44.680]     }
[10:22:44.680]     ...future.frame <- base::sys.nframe()
[10:22:44.680]     ...future.conditions <- base::list()
[10:22:44.680]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:44.680]     if (FALSE) {
[10:22:44.680]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:44.680]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:44.680]     }
[10:22:44.680]     ...future.result <- base::tryCatch({
[10:22:44.680]         base::withCallingHandlers({
[10:22:44.680]             ...future.value <- base::withVisible(base::local({
[10:22:44.680]                 withCallingHandlers({
[10:22:44.680]                   {
[10:22:44.680]                     do.call(function(...) {
[10:22:44.680]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.680]                       if (!identical(...future.globals.maxSize.org, 
[10:22:44.680]                         ...future.globals.maxSize)) {
[10:22:44.680]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.680]                         on.exit(options(oopts), add = TRUE)
[10:22:44.680]                       }
[10:22:44.680]                       {
[10:22:44.680]                         lapply(seq_along(...future.elements_ii), 
[10:22:44.680]                           FUN = function(jj) {
[10:22:44.680]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.680]                             ...future.FUN(...future.X_jj, ...)
[10:22:44.680]                           })
[10:22:44.680]                       }
[10:22:44.680]                     }, args = future.call.arguments)
[10:22:44.680]                   }
[10:22:44.680]                 }, immediateCondition = function(cond) {
[10:22:44.680]                   save_rds <- function (object, pathname, ...) 
[10:22:44.680]                   {
[10:22:44.680]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:44.680]                     if (file_test("-f", pathname_tmp)) {
[10:22:44.680]                       fi_tmp <- file.info(pathname_tmp)
[10:22:44.680]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:44.680]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:44.680]                         fi_tmp[["mtime"]])
[10:22:44.680]                     }
[10:22:44.680]                     tryCatch({
[10:22:44.680]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:44.680]                     }, error = function(ex) {
[10:22:44.680]                       msg <- conditionMessage(ex)
[10:22:44.680]                       fi_tmp <- file.info(pathname_tmp)
[10:22:44.680]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:44.680]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:44.680]                         fi_tmp[["mtime"]], msg)
[10:22:44.680]                       ex$message <- msg
[10:22:44.680]                       stop(ex)
[10:22:44.680]                     })
[10:22:44.680]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:44.680]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:44.680]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:44.680]                       fi_tmp <- file.info(pathname_tmp)
[10:22:44.680]                       fi <- file.info(pathname)
[10:22:44.680]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:44.680]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:44.680]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:44.680]                         fi[["size"]], fi[["mtime"]])
[10:22:44.680]                       stop(msg)
[10:22:44.680]                     }
[10:22:44.680]                     invisible(pathname)
[10:22:44.680]                   }
[10:22:44.680]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:44.680]                     rootPath = tempdir()) 
[10:22:44.680]                   {
[10:22:44.680]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:44.680]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:44.680]                       tmpdir = path, fileext = ".rds")
[10:22:44.680]                     save_rds(obj, file)
[10:22:44.680]                   }
[10:22:44.680]                   saveImmediateCondition(cond, path = "/tmp/RtmpTHXGJm/.future/immediateConditions")
[10:22:44.680]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.680]                   {
[10:22:44.680]                     inherits <- base::inherits
[10:22:44.680]                     invokeRestart <- base::invokeRestart
[10:22:44.680]                     is.null <- base::is.null
[10:22:44.680]                     muffled <- FALSE
[10:22:44.680]                     if (inherits(cond, "message")) {
[10:22:44.680]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:44.680]                       if (muffled) 
[10:22:44.680]                         invokeRestart("muffleMessage")
[10:22:44.680]                     }
[10:22:44.680]                     else if (inherits(cond, "warning")) {
[10:22:44.680]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:44.680]                       if (muffled) 
[10:22:44.680]                         invokeRestart("muffleWarning")
[10:22:44.680]                     }
[10:22:44.680]                     else if (inherits(cond, "condition")) {
[10:22:44.680]                       if (!is.null(pattern)) {
[10:22:44.680]                         computeRestarts <- base::computeRestarts
[10:22:44.680]                         grepl <- base::grepl
[10:22:44.680]                         restarts <- computeRestarts(cond)
[10:22:44.680]                         for (restart in restarts) {
[10:22:44.680]                           name <- restart$name
[10:22:44.680]                           if (is.null(name)) 
[10:22:44.680]                             next
[10:22:44.680]                           if (!grepl(pattern, name)) 
[10:22:44.680]                             next
[10:22:44.680]                           invokeRestart(restart)
[10:22:44.680]                           muffled <- TRUE
[10:22:44.680]                           break
[10:22:44.680]                         }
[10:22:44.680]                       }
[10:22:44.680]                     }
[10:22:44.680]                     invisible(muffled)
[10:22:44.680]                   }
[10:22:44.680]                   muffleCondition(cond)
[10:22:44.680]                 })
[10:22:44.680]             }))
[10:22:44.680]             future::FutureResult(value = ...future.value$value, 
[10:22:44.680]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.680]                   ...future.rng), globalenv = if (FALSE) 
[10:22:44.680]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:44.680]                     ...future.globalenv.names))
[10:22:44.680]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:44.680]         }, condition = base::local({
[10:22:44.680]             c <- base::c
[10:22:44.680]             inherits <- base::inherits
[10:22:44.680]             invokeRestart <- base::invokeRestart
[10:22:44.680]             length <- base::length
[10:22:44.680]             list <- base::list
[10:22:44.680]             seq.int <- base::seq.int
[10:22:44.680]             signalCondition <- base::signalCondition
[10:22:44.680]             sys.calls <- base::sys.calls
[10:22:44.680]             `[[` <- base::`[[`
[10:22:44.680]             `+` <- base::`+`
[10:22:44.680]             `<<-` <- base::`<<-`
[10:22:44.680]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:44.680]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:44.680]                   3L)]
[10:22:44.680]             }
[10:22:44.680]             function(cond) {
[10:22:44.680]                 is_error <- inherits(cond, "error")
[10:22:44.680]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:44.680]                   NULL)
[10:22:44.680]                 if (is_error) {
[10:22:44.680]                   sessionInformation <- function() {
[10:22:44.680]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:44.680]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:44.680]                       search = base::search(), system = base::Sys.info())
[10:22:44.680]                   }
[10:22:44.680]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.680]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:44.680]                     cond$call), session = sessionInformation(), 
[10:22:44.680]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:44.680]                   signalCondition(cond)
[10:22:44.680]                 }
[10:22:44.680]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:44.680]                 "immediateCondition"))) {
[10:22:44.680]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:44.680]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.680]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:44.680]                   if (TRUE && !signal) {
[10:22:44.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.680]                     {
[10:22:44.680]                       inherits <- base::inherits
[10:22:44.680]                       invokeRestart <- base::invokeRestart
[10:22:44.680]                       is.null <- base::is.null
[10:22:44.680]                       muffled <- FALSE
[10:22:44.680]                       if (inherits(cond, "message")) {
[10:22:44.680]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.680]                         if (muffled) 
[10:22:44.680]                           invokeRestart("muffleMessage")
[10:22:44.680]                       }
[10:22:44.680]                       else if (inherits(cond, "warning")) {
[10:22:44.680]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.680]                         if (muffled) 
[10:22:44.680]                           invokeRestart("muffleWarning")
[10:22:44.680]                       }
[10:22:44.680]                       else if (inherits(cond, "condition")) {
[10:22:44.680]                         if (!is.null(pattern)) {
[10:22:44.680]                           computeRestarts <- base::computeRestarts
[10:22:44.680]                           grepl <- base::grepl
[10:22:44.680]                           restarts <- computeRestarts(cond)
[10:22:44.680]                           for (restart in restarts) {
[10:22:44.680]                             name <- restart$name
[10:22:44.680]                             if (is.null(name)) 
[10:22:44.680]                               next
[10:22:44.680]                             if (!grepl(pattern, name)) 
[10:22:44.680]                               next
[10:22:44.680]                             invokeRestart(restart)
[10:22:44.680]                             muffled <- TRUE
[10:22:44.680]                             break
[10:22:44.680]                           }
[10:22:44.680]                         }
[10:22:44.680]                       }
[10:22:44.680]                       invisible(muffled)
[10:22:44.680]                     }
[10:22:44.680]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.680]                   }
[10:22:44.680]                 }
[10:22:44.680]                 else {
[10:22:44.680]                   if (TRUE) {
[10:22:44.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.680]                     {
[10:22:44.680]                       inherits <- base::inherits
[10:22:44.680]                       invokeRestart <- base::invokeRestart
[10:22:44.680]                       is.null <- base::is.null
[10:22:44.680]                       muffled <- FALSE
[10:22:44.680]                       if (inherits(cond, "message")) {
[10:22:44.680]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.680]                         if (muffled) 
[10:22:44.680]                           invokeRestart("muffleMessage")
[10:22:44.680]                       }
[10:22:44.680]                       else if (inherits(cond, "warning")) {
[10:22:44.680]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.680]                         if (muffled) 
[10:22:44.680]                           invokeRestart("muffleWarning")
[10:22:44.680]                       }
[10:22:44.680]                       else if (inherits(cond, "condition")) {
[10:22:44.680]                         if (!is.null(pattern)) {
[10:22:44.680]                           computeRestarts <- base::computeRestarts
[10:22:44.680]                           grepl <- base::grepl
[10:22:44.680]                           restarts <- computeRestarts(cond)
[10:22:44.680]                           for (restart in restarts) {
[10:22:44.680]                             name <- restart$name
[10:22:44.680]                             if (is.null(name)) 
[10:22:44.680]                               next
[10:22:44.680]                             if (!grepl(pattern, name)) 
[10:22:44.680]                               next
[10:22:44.680]                             invokeRestart(restart)
[10:22:44.680]                             muffled <- TRUE
[10:22:44.680]                             break
[10:22:44.680]                           }
[10:22:44.680]                         }
[10:22:44.680]                       }
[10:22:44.680]                       invisible(muffled)
[10:22:44.680]                     }
[10:22:44.680]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.680]                   }
[10:22:44.680]                 }
[10:22:44.680]             }
[10:22:44.680]         }))
[10:22:44.680]     }, error = function(ex) {
[10:22:44.680]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:44.680]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.680]                 ...future.rng), started = ...future.startTime, 
[10:22:44.680]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:44.680]             version = "1.8"), class = "FutureResult")
[10:22:44.680]     }, finally = {
[10:22:44.680]         if (!identical(...future.workdir, getwd())) 
[10:22:44.680]             setwd(...future.workdir)
[10:22:44.680]         {
[10:22:44.680]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:44.680]                 ...future.oldOptions$nwarnings <- NULL
[10:22:44.680]             }
[10:22:44.680]             base::options(...future.oldOptions)
[10:22:44.680]             if (.Platform$OS.type == "windows") {
[10:22:44.680]                 old_names <- names(...future.oldEnvVars)
[10:22:44.680]                 envs <- base::Sys.getenv()
[10:22:44.680]                 names <- names(envs)
[10:22:44.680]                 common <- intersect(names, old_names)
[10:22:44.680]                 added <- setdiff(names, old_names)
[10:22:44.680]                 removed <- setdiff(old_names, names)
[10:22:44.680]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:44.680]                   envs[common]]
[10:22:44.680]                 NAMES <- toupper(changed)
[10:22:44.680]                 args <- list()
[10:22:44.680]                 for (kk in seq_along(NAMES)) {
[10:22:44.680]                   name <- changed[[kk]]
[10:22:44.680]                   NAME <- NAMES[[kk]]
[10:22:44.680]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.680]                     next
[10:22:44.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.680]                 }
[10:22:44.680]                 NAMES <- toupper(added)
[10:22:44.680]                 for (kk in seq_along(NAMES)) {
[10:22:44.680]                   name <- added[[kk]]
[10:22:44.680]                   NAME <- NAMES[[kk]]
[10:22:44.680]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.680]                     next
[10:22:44.680]                   args[[name]] <- ""
[10:22:44.680]                 }
[10:22:44.680]                 NAMES <- toupper(removed)
[10:22:44.680]                 for (kk in seq_along(NAMES)) {
[10:22:44.680]                   name <- removed[[kk]]
[10:22:44.680]                   NAME <- NAMES[[kk]]
[10:22:44.680]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.680]                     next
[10:22:44.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.680]                 }
[10:22:44.680]                 if (length(args) > 0) 
[10:22:44.680]                   base::do.call(base::Sys.setenv, args = args)
[10:22:44.680]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:44.680]             }
[10:22:44.680]             else {
[10:22:44.680]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:44.680]             }
[10:22:44.680]             {
[10:22:44.680]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:44.680]                   0L) {
[10:22:44.680]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:44.680]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:44.680]                   base::options(opts)
[10:22:44.680]                 }
[10:22:44.680]                 {
[10:22:44.680]                   {
[10:22:44.680]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:44.680]                     NULL
[10:22:44.680]                   }
[10:22:44.680]                   options(future.plan = NULL)
[10:22:44.680]                   if (is.na(NA_character_)) 
[10:22:44.680]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.680]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:44.680]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:44.680]                     envir = parent.frame()) 
[10:22:44.680]                   {
[10:22:44.680]                     default_workers <- missing(workers)
[10:22:44.680]                     if (is.function(workers)) 
[10:22:44.680]                       workers <- workers()
[10:22:44.680]                     workers <- structure(as.integer(workers), 
[10:22:44.680]                       class = class(workers))
[10:22:44.680]                     stop_if_not(is.finite(workers), workers >= 
[10:22:44.680]                       1L)
[10:22:44.680]                     if ((workers == 1L && !inherits(workers, 
[10:22:44.680]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:44.680]                       if (default_workers) 
[10:22:44.680]                         supportsMulticore(warn = TRUE)
[10:22:44.680]                       return(sequential(..., envir = envir))
[10:22:44.680]                     }
[10:22:44.680]                     oopts <- options(mc.cores = workers)
[10:22:44.680]                     on.exit(options(oopts))
[10:22:44.680]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:44.680]                       envir = envir)
[10:22:44.680]                     if (!future$lazy) 
[10:22:44.680]                       future <- run(future)
[10:22:44.680]                     invisible(future)
[10:22:44.680]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:44.680]                 }
[10:22:44.680]             }
[10:22:44.680]         }
[10:22:44.680]     })
[10:22:44.680]     if (TRUE) {
[10:22:44.680]         base::sink(type = "output", split = FALSE)
[10:22:44.680]         if (TRUE) {
[10:22:44.680]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:44.680]         }
[10:22:44.680]         else {
[10:22:44.680]             ...future.result["stdout"] <- base::list(NULL)
[10:22:44.680]         }
[10:22:44.680]         base::close(...future.stdout)
[10:22:44.680]         ...future.stdout <- NULL
[10:22:44.680]     }
[10:22:44.680]     ...future.result$conditions <- ...future.conditions
[10:22:44.680]     ...future.result$finished <- base::Sys.time()
[10:22:44.680]     ...future.result
[10:22:44.680] }
[10:22:44.684] assign_globals() ...
[10:22:44.684] List of 5
[10:22:44.684]  $ future.call.arguments    : list()
[10:22:44.684]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.684]  $ ...future.FUN            :function (x, ...)  
[10:22:44.684]  $ ...future.elements_ii    :List of 1
[10:22:44.684]   ..$ : num [1:4] 2 4 6 8
[10:22:44.684]  $ ...future.seeds_ii       : NULL
[10:22:44.684]  $ ...future.globals.maxSize: num Inf
[10:22:44.684]  - attr(*, "resolved")= logi FALSE
[10:22:44.684]  - attr(*, "total_size")= num NA
[10:22:44.684]  - attr(*, "where")=List of 5
[10:22:44.684]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:44.684]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:44.684]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:44.684]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:44.684]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:44.684]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.684]  - attr(*, "already-done")= logi TRUE
[10:22:44.691] - copied ‘future.call.arguments’ to environment
[10:22:44.692] - copied ‘...future.FUN’ to environment
[10:22:44.692] - copied ‘...future.elements_ii’ to environment
[10:22:44.692] - copied ‘...future.seeds_ii’ to environment
[10:22:44.692] - copied ‘...future.globals.maxSize’ to environment
[10:22:44.692] assign_globals() ... done
[10:22:44.692] requestCore(): workers = 2
[10:22:44.694] MulticoreFuture started
[10:22:44.695] - Launch lazy future ... done
[10:22:44.695] run() for ‘MulticoreFuture’ ... done
[10:22:44.695] Created future:
[10:22:44.696] plan(): Setting new future strategy stack:
[10:22:44.696] List of future strategies:
[10:22:44.696] 1. sequential:
[10:22:44.696]    - args: function (..., envir = parent.frame())
[10:22:44.696]    - tweaked: FALSE
[10:22:44.696]    - call: NULL
[10:22:44.697] plan(): nbrOfWorkers() = 1
[10:22:44.699] plan(): Setting new future strategy stack:
[10:22:44.700] List of future strategies:
[10:22:44.700] 1. multicore:
[10:22:44.700]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:44.700]    - tweaked: FALSE
[10:22:44.700]    - call: plan(strategy)
[10:22:44.695] MulticoreFuture:
[10:22:44.695] Label: ‘future_apply-2’
[10:22:44.695] Expression:
[10:22:44.695] {
[10:22:44.695]     do.call(function(...) {
[10:22:44.695]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.695]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:44.695]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.695]             on.exit(options(oopts), add = TRUE)
[10:22:44.695]         }
[10:22:44.695]         {
[10:22:44.695]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:44.695]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.695]                 ...future.FUN(...future.X_jj, ...)
[10:22:44.695]             })
[10:22:44.695]         }
[10:22:44.695]     }, args = future.call.arguments)
[10:22:44.695] }
[10:22:44.695] Lazy evaluation: FALSE
[10:22:44.695] Asynchronous evaluation: TRUE
[10:22:44.695] Local evaluation: TRUE
[10:22:44.695] Environment: R_GlobalEnv
[10:22:44.695] Capture standard output: TRUE
[10:22:44.695] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:44.695] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:44.695] Packages: 1 packages (‘stats’)
[10:22:44.695] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:44.695] Resolved: FALSE
[10:22:44.695] Value: <not collected>
[10:22:44.695] Conditions captured: <none>
[10:22:44.695] Early signaling: FALSE
[10:22:44.695] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:44.695] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:44.708] Chunk #2 of 2 ... DONE
[10:22:44.708] Launching 2 futures (chunks) ... DONE
[10:22:44.709] Resolving 2 futures (chunks) ...
[10:22:44.708] plan(): nbrOfWorkers() = 2
[10:22:44.709] resolve() on list ...
[10:22:44.709]  recursive: 0
[10:22:44.709]  length: 2
[10:22:44.709] 
[10:22:44.710] Future #1
[10:22:44.710] result() for MulticoreFuture ...
[10:22:44.711] result() for MulticoreFuture ...
[10:22:44.711] result() for MulticoreFuture ... done
[10:22:44.713] result() for MulticoreFuture ... done
[10:22:44.714] result() for MulticoreFuture ...
[10:22:44.714] result() for MulticoreFuture ... done
[10:22:44.714] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:22:44.715] - nx: 2
[10:22:44.715] - relay: TRUE
[10:22:44.715] - stdout: TRUE
[10:22:44.715] - signal: TRUE
[10:22:44.716] - resignal: FALSE
[10:22:44.716] - force: TRUE
[10:22:44.716] - relayed: [n=2] FALSE, FALSE
[10:22:44.716] - queued futures: [n=2] FALSE, FALSE
[10:22:44.717]  - until=1
[10:22:44.717]  - relaying element #1
[10:22:44.717] result() for MulticoreFuture ...
[10:22:44.718] result() for MulticoreFuture ... done
[10:22:44.718] result() for MulticoreFuture ...
[10:22:44.718] result() for MulticoreFuture ... done
[10:22:44.719] result() for MulticoreFuture ...
[10:22:44.719] result() for MulticoreFuture ... done
[10:22:44.719] result() for MulticoreFuture ...
[10:22:44.719] result() for MulticoreFuture ... done
[10:22:44.720] - relayed: [n=2] TRUE, FALSE
[10:22:44.720] - queued futures: [n=2] TRUE, FALSE
[10:22:44.720] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:22:44.721]  length: 1 (resolved future 1)
[10:22:44.721] Future #2
[10:22:44.721] result() for MulticoreFuture ...
[10:22:44.722] result() for MulticoreFuture ...
[10:22:44.723] result() for MulticoreFuture ... done
[10:22:44.723] result() for MulticoreFuture ... done
[10:22:44.723] result() for MulticoreFuture ...
[10:22:44.723] result() for MulticoreFuture ... done
[10:22:44.723] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:22:44.723] - nx: 2
[10:22:44.723] - relay: TRUE
[10:22:44.724] - stdout: TRUE
[10:22:44.724] - signal: TRUE
[10:22:44.724] - resignal: FALSE
[10:22:44.724] - force: TRUE
[10:22:44.724] - relayed: [n=2] TRUE, FALSE
[10:22:44.724] - queued futures: [n=2] TRUE, FALSE
[10:22:44.724]  - until=2
[10:22:44.724]  - relaying element #2
[10:22:44.725] result() for MulticoreFuture ...
[10:22:44.725] result() for MulticoreFuture ... done
[10:22:44.725] result() for MulticoreFuture ...
[10:22:44.725] result() for MulticoreFuture ... done
[10:22:44.725] result() for MulticoreFuture ...
[10:22:44.725] result() for MulticoreFuture ... done
[10:22:44.725] result() for MulticoreFuture ...
[10:22:44.726] result() for MulticoreFuture ... done
[10:22:44.726] - relayed: [n=2] TRUE, TRUE
[10:22:44.726] - queued futures: [n=2] TRUE, TRUE
[10:22:44.726] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:22:44.726]  length: 0 (resolved future 2)
[10:22:44.726] Relaying remaining futures
[10:22:44.726] signalConditionsASAP(NULL, pos=0) ...
[10:22:44.726] - nx: 2
[10:22:44.726] - relay: TRUE
[10:22:44.726] - stdout: TRUE
[10:22:44.727] - signal: TRUE
[10:22:44.727] - resignal: FALSE
[10:22:44.727] - force: TRUE
[10:22:44.727] - relayed: [n=2] TRUE, TRUE
[10:22:44.727] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:22:44.727] - relayed: [n=2] TRUE, TRUE
[10:22:44.727] - queued futures: [n=2] TRUE, TRUE
[10:22:44.727] signalConditionsASAP(NULL, pos=0) ... done
[10:22:44.727] resolve() on list ... DONE
[10:22:44.728] result() for MulticoreFuture ...
[10:22:44.728] result() for MulticoreFuture ... done
[10:22:44.728] result() for MulticoreFuture ...
[10:22:44.728] result() for MulticoreFuture ... done
[10:22:44.728] result() for MulticoreFuture ...
[10:22:44.728] result() for MulticoreFuture ... done
[10:22:44.728] result() for MulticoreFuture ...
[10:22:44.728] result() for MulticoreFuture ... done
[10:22:44.728]  - Number of value chunks collected: 2
[10:22:44.729] Resolving 2 futures (chunks) ... DONE
[10:22:44.729] Reducing values from 2 chunks ...
[10:22:44.729]  - Number of values collected after concatenation: 2
[10:22:44.729]  - Number of values expected: 2
[10:22:44.729] Reducing values from 2 chunks ... DONE
[10:22:44.729] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[10:22:44.730] getGlobalsAndPackagesXApply() ...
[10:22:44.730]  - future.globals: TRUE
[10:22:44.730] getGlobalsAndPackages() ...
[10:22:44.730] Searching for globals...
[10:22:44.731] - globals found: [1] ‘FUN’
[10:22:44.732] Searching for globals ... DONE
[10:22:44.732] Resolving globals: FALSE
[10:22:44.732] The total size of the 1 globals is 848 bytes (848 bytes)
[10:22:44.732] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:22:44.733] - globals: [1] ‘FUN’
[10:22:44.733] 
[10:22:44.733] getGlobalsAndPackages() ... DONE
[10:22:44.733]  - globals found/used: [n=1] ‘FUN’
[10:22:44.733]  - needed namespaces: [n=0] 
[10:22:44.733] Finding globals ... DONE
[10:22:44.733]  - use_args: TRUE
[10:22:44.733]  - Getting '...' globals ...
[10:22:44.734] resolve() on list ...
[10:22:44.734]  recursive: 0
[10:22:44.734]  length: 1
[10:22:44.734]  elements: ‘...’
[10:22:44.734]  length: 0 (resolved future 1)
[10:22:44.734] resolve() on list ... DONE
[10:22:44.734]    - '...' content: [n=0] 
[10:22:44.735] List of 1
[10:22:44.735]  $ ...: list()
[10:22:44.735]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.735]  - attr(*, "where")=List of 1
[10:22:44.735]   ..$ ...:<environment: 0x55ca4bbb89e8> 
[10:22:44.735]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.735]  - attr(*, "resolved")= logi TRUE
[10:22:44.735]  - attr(*, "total_size")= num NA
[10:22:44.737]  - Getting '...' globals ... DONE
[10:22:44.738] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:44.738] List of 2
[10:22:44.738]  $ ...future.FUN:function (x)  
[10:22:44.738]  $ ...          : list()
[10:22:44.738]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.738]  - attr(*, "where")=List of 2
[10:22:44.738]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:44.738]   ..$ ...          :<environment: 0x55ca4bbb89e8> 
[10:22:44.738]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.738]  - attr(*, "resolved")= logi FALSE
[10:22:44.738]  - attr(*, "total_size")= num 848
[10:22:44.740] Packages to be attached in all futures: [n=0] 
[10:22:44.741] getGlobalsAndPackagesXApply() ... DONE
[10:22:44.744] future_lapply() ...
[10:22:44.750] Number of chunks: 2
[10:22:44.750] getGlobalsAndPackagesXApply() ...
[10:22:44.750]  - future.globals: <name-value list> with names ‘list()’
[10:22:44.751]  - use_args: TRUE
[10:22:44.751] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:22:44.751] List of 2
[10:22:44.751]  $ ...          : list()
[10:22:44.751]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.751]  $ ...future.FUN:function (x)  
[10:22:44.751]  - attr(*, "where")=List of 2
[10:22:44.751]   ..$ ...          :<environment: 0x55ca4bbb89e8> 
[10:22:44.751]   ..$ ...future.FUN:<environment: namespace:base> 
[10:22:44.751]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.751]  - attr(*, "resolved")= logi FALSE
[10:22:44.751]  - attr(*, "total_size")= num NA
[10:22:44.754] Packages to be attached in all futures: [n=0] 
[10:22:44.755] getGlobalsAndPackagesXApply() ... DONE
[10:22:44.755] Number of futures (= number of chunks): 2
[10:22:44.755] Launching 2 futures (chunks) ...
[10:22:44.755] Chunk #1 of 2 ...
[10:22:44.755]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:44.755]  - seeds: <none>
[10:22:44.755]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.755] getGlobalsAndPackages() ...
[10:22:44.756] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.756] Resolving globals: FALSE
[10:22:44.756] Tweak future expression to call with '...' arguments ...
[10:22:44.756] {
[10:22:44.756]     do.call(function(...) {
[10:22:44.756]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.756]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:44.756]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.756]             on.exit(options(oopts), add = TRUE)
[10:22:44.756]         }
[10:22:44.756]         {
[10:22:44.756]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:44.756]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.756]                 ...future.FUN(...future.X_jj, ...)
[10:22:44.756]             })
[10:22:44.756]         }
[10:22:44.756]     }, args = future.call.arguments)
[10:22:44.756] }
[10:22:44.756] Tweak future expression to call with '...' arguments ... DONE
[10:22:44.757] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.757] 
[10:22:44.757] getGlobalsAndPackages() ... DONE
[10:22:44.757] run() for ‘Future’ ...
[10:22:44.757] - state: ‘created’
[10:22:44.757] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:44.761] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:44.761] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:44.761]   - Field: ‘label’
[10:22:44.761]   - Field: ‘local’
[10:22:44.761]   - Field: ‘owner’
[10:22:44.761]   - Field: ‘envir’
[10:22:44.761]   - Field: ‘workers’
[10:22:44.761]   - Field: ‘packages’
[10:22:44.762]   - Field: ‘gc’
[10:22:44.762]   - Field: ‘job’
[10:22:44.762]   - Field: ‘conditions’
[10:22:44.762]   - Field: ‘expr’
[10:22:44.762]   - Field: ‘uuid’
[10:22:44.762]   - Field: ‘seed’
[10:22:44.762]   - Field: ‘version’
[10:22:44.762]   - Field: ‘result’
[10:22:44.762]   - Field: ‘asynchronous’
[10:22:44.762]   - Field: ‘calls’
[10:22:44.763]   - Field: ‘globals’
[10:22:44.763]   - Field: ‘stdout’
[10:22:44.763]   - Field: ‘earlySignal’
[10:22:44.763]   - Field: ‘lazy’
[10:22:44.763]   - Field: ‘state’
[10:22:44.763] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:44.763] - Launch lazy future ...
[10:22:44.763] Packages needed by the future expression (n = 0): <none>
[10:22:44.764] Packages needed by future strategies (n = 0): <none>
[10:22:44.764] {
[10:22:44.764]     {
[10:22:44.764]         {
[10:22:44.764]             ...future.startTime <- base::Sys.time()
[10:22:44.764]             {
[10:22:44.764]                 {
[10:22:44.764]                   {
[10:22:44.764]                     {
[10:22:44.764]                       base::local({
[10:22:44.764]                         has_future <- base::requireNamespace("future", 
[10:22:44.764]                           quietly = TRUE)
[10:22:44.764]                         if (has_future) {
[10:22:44.764]                           ns <- base::getNamespace("future")
[10:22:44.764]                           version <- ns[[".package"]][["version"]]
[10:22:44.764]                           if (is.null(version)) 
[10:22:44.764]                             version <- utils::packageVersion("future")
[10:22:44.764]                         }
[10:22:44.764]                         else {
[10:22:44.764]                           version <- NULL
[10:22:44.764]                         }
[10:22:44.764]                         if (!has_future || version < "1.8.0") {
[10:22:44.764]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:44.764]                             "", base::R.version$version.string), 
[10:22:44.764]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:44.764]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:44.764]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:44.764]                               "release", "version")], collapse = " "), 
[10:22:44.764]                             hostname = base::Sys.info()[["nodename"]])
[10:22:44.764]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:44.764]                             info)
[10:22:44.764]                           info <- base::paste(info, collapse = "; ")
[10:22:44.764]                           if (!has_future) {
[10:22:44.764]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:44.764]                               info)
[10:22:44.764]                           }
[10:22:44.764]                           else {
[10:22:44.764]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:44.764]                               info, version)
[10:22:44.764]                           }
[10:22:44.764]                           base::stop(msg)
[10:22:44.764]                         }
[10:22:44.764]                       })
[10:22:44.764]                     }
[10:22:44.764]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:44.764]                     base::options(mc.cores = 1L)
[10:22:44.764]                   }
[10:22:44.764]                   options(future.plan = NULL)
[10:22:44.764]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.764]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:44.764]                 }
[10:22:44.764]                 ...future.workdir <- getwd()
[10:22:44.764]             }
[10:22:44.764]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:44.764]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:44.764]         }
[10:22:44.764]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:44.764]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:44.764]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:44.764]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:44.764]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:44.764]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:44.764]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:44.764]             base::names(...future.oldOptions))
[10:22:44.764]     }
[10:22:44.764]     if (FALSE) {
[10:22:44.764]     }
[10:22:44.764]     else {
[10:22:44.764]         if (TRUE) {
[10:22:44.764]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:44.764]                 open = "w")
[10:22:44.764]         }
[10:22:44.764]         else {
[10:22:44.764]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:44.764]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:44.764]         }
[10:22:44.764]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:44.764]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:44.764]             base::sink(type = "output", split = FALSE)
[10:22:44.764]             base::close(...future.stdout)
[10:22:44.764]         }, add = TRUE)
[10:22:44.764]     }
[10:22:44.764]     ...future.frame <- base::sys.nframe()
[10:22:44.764]     ...future.conditions <- base::list()
[10:22:44.764]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:44.764]     if (FALSE) {
[10:22:44.764]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:44.764]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:44.764]     }
[10:22:44.764]     ...future.result <- base::tryCatch({
[10:22:44.764]         base::withCallingHandlers({
[10:22:44.764]             ...future.value <- base::withVisible(base::local({
[10:22:44.764]                 withCallingHandlers({
[10:22:44.764]                   {
[10:22:44.764]                     do.call(function(...) {
[10:22:44.764]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.764]                       if (!identical(...future.globals.maxSize.org, 
[10:22:44.764]                         ...future.globals.maxSize)) {
[10:22:44.764]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.764]                         on.exit(options(oopts), add = TRUE)
[10:22:44.764]                       }
[10:22:44.764]                       {
[10:22:44.764]                         lapply(seq_along(...future.elements_ii), 
[10:22:44.764]                           FUN = function(jj) {
[10:22:44.764]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.764]                             ...future.FUN(...future.X_jj, ...)
[10:22:44.764]                           })
[10:22:44.764]                       }
[10:22:44.764]                     }, args = future.call.arguments)
[10:22:44.764]                   }
[10:22:44.764]                 }, immediateCondition = function(cond) {
[10:22:44.764]                   save_rds <- function (object, pathname, ...) 
[10:22:44.764]                   {
[10:22:44.764]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:44.764]                     if (file_test("-f", pathname_tmp)) {
[10:22:44.764]                       fi_tmp <- file.info(pathname_tmp)
[10:22:44.764]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:44.764]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:44.764]                         fi_tmp[["mtime"]])
[10:22:44.764]                     }
[10:22:44.764]                     tryCatch({
[10:22:44.764]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:44.764]                     }, error = function(ex) {
[10:22:44.764]                       msg <- conditionMessage(ex)
[10:22:44.764]                       fi_tmp <- file.info(pathname_tmp)
[10:22:44.764]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:44.764]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:44.764]                         fi_tmp[["mtime"]], msg)
[10:22:44.764]                       ex$message <- msg
[10:22:44.764]                       stop(ex)
[10:22:44.764]                     })
[10:22:44.764]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:44.764]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:44.764]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:44.764]                       fi_tmp <- file.info(pathname_tmp)
[10:22:44.764]                       fi <- file.info(pathname)
[10:22:44.764]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:44.764]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:44.764]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:44.764]                         fi[["size"]], fi[["mtime"]])
[10:22:44.764]                       stop(msg)
[10:22:44.764]                     }
[10:22:44.764]                     invisible(pathname)
[10:22:44.764]                   }
[10:22:44.764]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:44.764]                     rootPath = tempdir()) 
[10:22:44.764]                   {
[10:22:44.764]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:44.764]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:44.764]                       tmpdir = path, fileext = ".rds")
[10:22:44.764]                     save_rds(obj, file)
[10:22:44.764]                   }
[10:22:44.764]                   saveImmediateCondition(cond, path = "/tmp/RtmpTHXGJm/.future/immediateConditions")
[10:22:44.764]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.764]                   {
[10:22:44.764]                     inherits <- base::inherits
[10:22:44.764]                     invokeRestart <- base::invokeRestart
[10:22:44.764]                     is.null <- base::is.null
[10:22:44.764]                     muffled <- FALSE
[10:22:44.764]                     if (inherits(cond, "message")) {
[10:22:44.764]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:44.764]                       if (muffled) 
[10:22:44.764]                         invokeRestart("muffleMessage")
[10:22:44.764]                     }
[10:22:44.764]                     else if (inherits(cond, "warning")) {
[10:22:44.764]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:44.764]                       if (muffled) 
[10:22:44.764]                         invokeRestart("muffleWarning")
[10:22:44.764]                     }
[10:22:44.764]                     else if (inherits(cond, "condition")) {
[10:22:44.764]                       if (!is.null(pattern)) {
[10:22:44.764]                         computeRestarts <- base::computeRestarts
[10:22:44.764]                         grepl <- base::grepl
[10:22:44.764]                         restarts <- computeRestarts(cond)
[10:22:44.764]                         for (restart in restarts) {
[10:22:44.764]                           name <- restart$name
[10:22:44.764]                           if (is.null(name)) 
[10:22:44.764]                             next
[10:22:44.764]                           if (!grepl(pattern, name)) 
[10:22:44.764]                             next
[10:22:44.764]                           invokeRestart(restart)
[10:22:44.764]                           muffled <- TRUE
[10:22:44.764]                           break
[10:22:44.764]                         }
[10:22:44.764]                       }
[10:22:44.764]                     }
[10:22:44.764]                     invisible(muffled)
[10:22:44.764]                   }
[10:22:44.764]                   muffleCondition(cond)
[10:22:44.764]                 })
[10:22:44.764]             }))
[10:22:44.764]             future::FutureResult(value = ...future.value$value, 
[10:22:44.764]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.764]                   ...future.rng), globalenv = if (FALSE) 
[10:22:44.764]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:44.764]                     ...future.globalenv.names))
[10:22:44.764]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:44.764]         }, condition = base::local({
[10:22:44.764]             c <- base::c
[10:22:44.764]             inherits <- base::inherits
[10:22:44.764]             invokeRestart <- base::invokeRestart
[10:22:44.764]             length <- base::length
[10:22:44.764]             list <- base::list
[10:22:44.764]             seq.int <- base::seq.int
[10:22:44.764]             signalCondition <- base::signalCondition
[10:22:44.764]             sys.calls <- base::sys.calls
[10:22:44.764]             `[[` <- base::`[[`
[10:22:44.764]             `+` <- base::`+`
[10:22:44.764]             `<<-` <- base::`<<-`
[10:22:44.764]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:44.764]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:44.764]                   3L)]
[10:22:44.764]             }
[10:22:44.764]             function(cond) {
[10:22:44.764]                 is_error <- inherits(cond, "error")
[10:22:44.764]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:44.764]                   NULL)
[10:22:44.764]                 if (is_error) {
[10:22:44.764]                   sessionInformation <- function() {
[10:22:44.764]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:44.764]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:44.764]                       search = base::search(), system = base::Sys.info())
[10:22:44.764]                   }
[10:22:44.764]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.764]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:44.764]                     cond$call), session = sessionInformation(), 
[10:22:44.764]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:44.764]                   signalCondition(cond)
[10:22:44.764]                 }
[10:22:44.764]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:44.764]                 "immediateCondition"))) {
[10:22:44.764]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:44.764]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.764]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:44.764]                   if (TRUE && !signal) {
[10:22:44.764]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.764]                     {
[10:22:44.764]                       inherits <- base::inherits
[10:22:44.764]                       invokeRestart <- base::invokeRestart
[10:22:44.764]                       is.null <- base::is.null
[10:22:44.764]                       muffled <- FALSE
[10:22:44.764]                       if (inherits(cond, "message")) {
[10:22:44.764]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.764]                         if (muffled) 
[10:22:44.764]                           invokeRestart("muffleMessage")
[10:22:44.764]                       }
[10:22:44.764]                       else if (inherits(cond, "warning")) {
[10:22:44.764]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.764]                         if (muffled) 
[10:22:44.764]                           invokeRestart("muffleWarning")
[10:22:44.764]                       }
[10:22:44.764]                       else if (inherits(cond, "condition")) {
[10:22:44.764]                         if (!is.null(pattern)) {
[10:22:44.764]                           computeRestarts <- base::computeRestarts
[10:22:44.764]                           grepl <- base::grepl
[10:22:44.764]                           restarts <- computeRestarts(cond)
[10:22:44.764]                           for (restart in restarts) {
[10:22:44.764]                             name <- restart$name
[10:22:44.764]                             if (is.null(name)) 
[10:22:44.764]                               next
[10:22:44.764]                             if (!grepl(pattern, name)) 
[10:22:44.764]                               next
[10:22:44.764]                             invokeRestart(restart)
[10:22:44.764]                             muffled <- TRUE
[10:22:44.764]                             break
[10:22:44.764]                           }
[10:22:44.764]                         }
[10:22:44.764]                       }
[10:22:44.764]                       invisible(muffled)
[10:22:44.764]                     }
[10:22:44.764]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.764]                   }
[10:22:44.764]                 }
[10:22:44.764]                 else {
[10:22:44.764]                   if (TRUE) {
[10:22:44.764]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.764]                     {
[10:22:44.764]                       inherits <- base::inherits
[10:22:44.764]                       invokeRestart <- base::invokeRestart
[10:22:44.764]                       is.null <- base::is.null
[10:22:44.764]                       muffled <- FALSE
[10:22:44.764]                       if (inherits(cond, "message")) {
[10:22:44.764]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.764]                         if (muffled) 
[10:22:44.764]                           invokeRestart("muffleMessage")
[10:22:44.764]                       }
[10:22:44.764]                       else if (inherits(cond, "warning")) {
[10:22:44.764]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.764]                         if (muffled) 
[10:22:44.764]                           invokeRestart("muffleWarning")
[10:22:44.764]                       }
[10:22:44.764]                       else if (inherits(cond, "condition")) {
[10:22:44.764]                         if (!is.null(pattern)) {
[10:22:44.764]                           computeRestarts <- base::computeRestarts
[10:22:44.764]                           grepl <- base::grepl
[10:22:44.764]                           restarts <- computeRestarts(cond)
[10:22:44.764]                           for (restart in restarts) {
[10:22:44.764]                             name <- restart$name
[10:22:44.764]                             if (is.null(name)) 
[10:22:44.764]                               next
[10:22:44.764]                             if (!grepl(pattern, name)) 
[10:22:44.764]                               next
[10:22:44.764]                             invokeRestart(restart)
[10:22:44.764]                             muffled <- TRUE
[10:22:44.764]                             break
[10:22:44.764]                           }
[10:22:44.764]                         }
[10:22:44.764]                       }
[10:22:44.764]                       invisible(muffled)
[10:22:44.764]                     }
[10:22:44.764]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.764]                   }
[10:22:44.764]                 }
[10:22:44.764]             }
[10:22:44.764]         }))
[10:22:44.764]     }, error = function(ex) {
[10:22:44.764]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:44.764]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.764]                 ...future.rng), started = ...future.startTime, 
[10:22:44.764]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:44.764]             version = "1.8"), class = "FutureResult")
[10:22:44.764]     }, finally = {
[10:22:44.764]         if (!identical(...future.workdir, getwd())) 
[10:22:44.764]             setwd(...future.workdir)
[10:22:44.764]         {
[10:22:44.764]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:44.764]                 ...future.oldOptions$nwarnings <- NULL
[10:22:44.764]             }
[10:22:44.764]             base::options(...future.oldOptions)
[10:22:44.764]             if (.Platform$OS.type == "windows") {
[10:22:44.764]                 old_names <- names(...future.oldEnvVars)
[10:22:44.764]                 envs <- base::Sys.getenv()
[10:22:44.764]                 names <- names(envs)
[10:22:44.764]                 common <- intersect(names, old_names)
[10:22:44.764]                 added <- setdiff(names, old_names)
[10:22:44.764]                 removed <- setdiff(old_names, names)
[10:22:44.764]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:44.764]                   envs[common]]
[10:22:44.764]                 NAMES <- toupper(changed)
[10:22:44.764]                 args <- list()
[10:22:44.764]                 for (kk in seq_along(NAMES)) {
[10:22:44.764]                   name <- changed[[kk]]
[10:22:44.764]                   NAME <- NAMES[[kk]]
[10:22:44.764]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.764]                     next
[10:22:44.764]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.764]                 }
[10:22:44.764]                 NAMES <- toupper(added)
[10:22:44.764]                 for (kk in seq_along(NAMES)) {
[10:22:44.764]                   name <- added[[kk]]
[10:22:44.764]                   NAME <- NAMES[[kk]]
[10:22:44.764]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.764]                     next
[10:22:44.764]                   args[[name]] <- ""
[10:22:44.764]                 }
[10:22:44.764]                 NAMES <- toupper(removed)
[10:22:44.764]                 for (kk in seq_along(NAMES)) {
[10:22:44.764]                   name <- removed[[kk]]
[10:22:44.764]                   NAME <- NAMES[[kk]]
[10:22:44.764]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.764]                     next
[10:22:44.764]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.764]                 }
[10:22:44.764]                 if (length(args) > 0) 
[10:22:44.764]                   base::do.call(base::Sys.setenv, args = args)
[10:22:44.764]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:44.764]             }
[10:22:44.764]             else {
[10:22:44.764]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:44.764]             }
[10:22:44.764]             {
[10:22:44.764]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:44.764]                   0L) {
[10:22:44.764]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:44.764]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:44.764]                   base::options(opts)
[10:22:44.764]                 }
[10:22:44.764]                 {
[10:22:44.764]                   {
[10:22:44.764]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:44.764]                     NULL
[10:22:44.764]                   }
[10:22:44.764]                   options(future.plan = NULL)
[10:22:44.764]                   if (is.na(NA_character_)) 
[10:22:44.764]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.764]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:44.764]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:44.764]                     envir = parent.frame()) 
[10:22:44.764]                   {
[10:22:44.764]                     default_workers <- missing(workers)
[10:22:44.764]                     if (is.function(workers)) 
[10:22:44.764]                       workers <- workers()
[10:22:44.764]                     workers <- structure(as.integer(workers), 
[10:22:44.764]                       class = class(workers))
[10:22:44.764]                     stop_if_not(is.finite(workers), workers >= 
[10:22:44.764]                       1L)
[10:22:44.764]                     if ((workers == 1L && !inherits(workers, 
[10:22:44.764]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:44.764]                       if (default_workers) 
[10:22:44.764]                         supportsMulticore(warn = TRUE)
[10:22:44.764]                       return(sequential(..., envir = envir))
[10:22:44.764]                     }
[10:22:44.764]                     oopts <- options(mc.cores = workers)
[10:22:44.764]                     on.exit(options(oopts))
[10:22:44.764]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:44.764]                       envir = envir)
[10:22:44.764]                     if (!future$lazy) 
[10:22:44.764]                       future <- run(future)
[10:22:44.764]                     invisible(future)
[10:22:44.764]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:44.764]                 }
[10:22:44.764]             }
[10:22:44.764]         }
[10:22:44.764]     })
[10:22:44.764]     if (TRUE) {
[10:22:44.764]         base::sink(type = "output", split = FALSE)
[10:22:44.764]         if (TRUE) {
[10:22:44.764]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:44.764]         }
[10:22:44.764]         else {
[10:22:44.764]             ...future.result["stdout"] <- base::list(NULL)
[10:22:44.764]         }
[10:22:44.764]         base::close(...future.stdout)
[10:22:44.764]         ...future.stdout <- NULL
[10:22:44.764]     }
[10:22:44.764]     ...future.result$conditions <- ...future.conditions
[10:22:44.764]     ...future.result$finished <- base::Sys.time()
[10:22:44.764]     ...future.result
[10:22:44.764] }
[10:22:44.766] assign_globals() ...
[10:22:44.766] List of 5
[10:22:44.766]  $ future.call.arguments    : list()
[10:22:44.766]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.766]  $ ...future.FUN            :function (x)  
[10:22:44.766]  $ ...future.elements_ii    :List of 1
[10:22:44.766]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[10:22:44.766]  $ ...future.seeds_ii       : NULL
[10:22:44.766]  $ ...future.globals.maxSize: num Inf
[10:22:44.766]  - attr(*, "resolved")= logi FALSE
[10:22:44.766]  - attr(*, "total_size")= num NA
[10:22:44.766]  - attr(*, "where")=List of 5
[10:22:44.766]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:44.766]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:44.766]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:44.766]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:44.766]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:44.766]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.766]  - attr(*, "already-done")= logi TRUE
[10:22:44.771] - copied ‘future.call.arguments’ to environment
[10:22:44.771] - copied ‘...future.FUN’ to environment
[10:22:44.771] - copied ‘...future.elements_ii’ to environment
[10:22:44.772] - copied ‘...future.seeds_ii’ to environment
[10:22:44.772] - copied ‘...future.globals.maxSize’ to environment
[10:22:44.772] assign_globals() ... done
[10:22:44.772] requestCore(): workers = 2
[10:22:44.774] MulticoreFuture started
[10:22:44.774] - Launch lazy future ... done
[10:22:44.775] run() for ‘MulticoreFuture’ ... done
[10:22:44.775] Created future:
[10:22:44.775] plan(): Setting new future strategy stack:
[10:22:44.775] List of future strategies:
[10:22:44.775] 1. sequential:
[10:22:44.775]    - args: function (..., envir = parent.frame())
[10:22:44.775]    - tweaked: FALSE
[10:22:44.775]    - call: NULL
[10:22:44.776] plan(): nbrOfWorkers() = 1
[10:22:44.778] plan(): Setting new future strategy stack:
[10:22:44.778] List of future strategies:
[10:22:44.778] 1. multicore:
[10:22:44.778]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:44.778]    - tweaked: FALSE
[10:22:44.778]    - call: plan(strategy)
[10:22:44.775] MulticoreFuture:
[10:22:44.775] Label: ‘future_apply-1’
[10:22:44.775] Expression:
[10:22:44.775] {
[10:22:44.775]     do.call(function(...) {
[10:22:44.775]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.775]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:44.775]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.775]             on.exit(options(oopts), add = TRUE)
[10:22:44.775]         }
[10:22:44.775]         {
[10:22:44.775]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:44.775]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.775]                 ...future.FUN(...future.X_jj, ...)
[10:22:44.775]             })
[10:22:44.775]         }
[10:22:44.775]     }, args = future.call.arguments)
[10:22:44.775] }
[10:22:44.775] Lazy evaluation: FALSE
[10:22:44.775] Asynchronous evaluation: TRUE
[10:22:44.775] Local evaluation: TRUE
[10:22:44.775] Environment: R_GlobalEnv
[10:22:44.775] Capture standard output: TRUE
[10:22:44.775] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:44.775] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:44.775] Packages: <none>
[10:22:44.775] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:44.775] Resolved: FALSE
[10:22:44.775] Value: <not collected>
[10:22:44.775] Conditions captured: <none>
[10:22:44.775] Early signaling: FALSE
[10:22:44.775] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:44.775] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:44.788] Chunk #1 of 2 ... DONE
[10:22:44.788] Chunk #2 of 2 ...
[10:22:44.789]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:44.789]  - seeds: <none>
[10:22:44.789]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.789] plan(): nbrOfWorkers() = 2
[10:22:44.789] getGlobalsAndPackages() ...
[10:22:44.792] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.792] Resolving globals: FALSE
[10:22:44.793] Tweak future expression to call with '...' arguments ...
[10:22:44.793] {
[10:22:44.793]     do.call(function(...) {
[10:22:44.793]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.793]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:44.793]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.793]             on.exit(options(oopts), add = TRUE)
[10:22:44.793]         }
[10:22:44.793]         {
[10:22:44.793]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:44.793]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.793]                 ...future.FUN(...future.X_jj, ...)
[10:22:44.793]             })
[10:22:44.793]         }
[10:22:44.793]     }, args = future.call.arguments)
[10:22:44.793] }
[10:22:44.794] Tweak future expression to call with '...' arguments ... DONE
[10:22:44.795] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.795] 
[10:22:44.795] getGlobalsAndPackages() ... DONE
[10:22:44.796] run() for ‘Future’ ...
[10:22:44.796] - state: ‘created’
[10:22:44.797] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:44.803] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:44.803] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:44.803]   - Field: ‘label’
[10:22:44.804]   - Field: ‘local’
[10:22:44.804]   - Field: ‘owner’
[10:22:44.804]   - Field: ‘envir’
[10:22:44.804]   - Field: ‘workers’
[10:22:44.804]   - Field: ‘packages’
[10:22:44.804]   - Field: ‘gc’
[10:22:44.805]   - Field: ‘job’
[10:22:44.805]   - Field: ‘conditions’
[10:22:44.805]   - Field: ‘expr’
[10:22:44.805]   - Field: ‘uuid’
[10:22:44.805]   - Field: ‘seed’
[10:22:44.805]   - Field: ‘version’
[10:22:44.806]   - Field: ‘result’
[10:22:44.806]   - Field: ‘asynchronous’
[10:22:44.806]   - Field: ‘calls’
[10:22:44.806]   - Field: ‘globals’
[10:22:44.806]   - Field: ‘stdout’
[10:22:44.807]   - Field: ‘earlySignal’
[10:22:44.807]   - Field: ‘lazy’
[10:22:44.807]   - Field: ‘state’
[10:22:44.807] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:44.807] - Launch lazy future ...
[10:22:44.808] Packages needed by the future expression (n = 0): <none>
[10:22:44.808] Packages needed by future strategies (n = 0): <none>
[10:22:44.809] {
[10:22:44.809]     {
[10:22:44.809]         {
[10:22:44.809]             ...future.startTime <- base::Sys.time()
[10:22:44.809]             {
[10:22:44.809]                 {
[10:22:44.809]                   {
[10:22:44.809]                     {
[10:22:44.809]                       base::local({
[10:22:44.809]                         has_future <- base::requireNamespace("future", 
[10:22:44.809]                           quietly = TRUE)
[10:22:44.809]                         if (has_future) {
[10:22:44.809]                           ns <- base::getNamespace("future")
[10:22:44.809]                           version <- ns[[".package"]][["version"]]
[10:22:44.809]                           if (is.null(version)) 
[10:22:44.809]                             version <- utils::packageVersion("future")
[10:22:44.809]                         }
[10:22:44.809]                         else {
[10:22:44.809]                           version <- NULL
[10:22:44.809]                         }
[10:22:44.809]                         if (!has_future || version < "1.8.0") {
[10:22:44.809]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:44.809]                             "", base::R.version$version.string), 
[10:22:44.809]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:44.809]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:44.809]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:44.809]                               "release", "version")], collapse = " "), 
[10:22:44.809]                             hostname = base::Sys.info()[["nodename"]])
[10:22:44.809]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:44.809]                             info)
[10:22:44.809]                           info <- base::paste(info, collapse = "; ")
[10:22:44.809]                           if (!has_future) {
[10:22:44.809]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:44.809]                               info)
[10:22:44.809]                           }
[10:22:44.809]                           else {
[10:22:44.809]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:44.809]                               info, version)
[10:22:44.809]                           }
[10:22:44.809]                           base::stop(msg)
[10:22:44.809]                         }
[10:22:44.809]                       })
[10:22:44.809]                     }
[10:22:44.809]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:44.809]                     base::options(mc.cores = 1L)
[10:22:44.809]                   }
[10:22:44.809]                   options(future.plan = NULL)
[10:22:44.809]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.809]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:44.809]                 }
[10:22:44.809]                 ...future.workdir <- getwd()
[10:22:44.809]             }
[10:22:44.809]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:44.809]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:44.809]         }
[10:22:44.809]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:44.809]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:44.809]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:44.809]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:44.809]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:44.809]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:44.809]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:44.809]             base::names(...future.oldOptions))
[10:22:44.809]     }
[10:22:44.809]     if (FALSE) {
[10:22:44.809]     }
[10:22:44.809]     else {
[10:22:44.809]         if (TRUE) {
[10:22:44.809]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:44.809]                 open = "w")
[10:22:44.809]         }
[10:22:44.809]         else {
[10:22:44.809]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:44.809]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:44.809]         }
[10:22:44.809]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:44.809]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:44.809]             base::sink(type = "output", split = FALSE)
[10:22:44.809]             base::close(...future.stdout)
[10:22:44.809]         }, add = TRUE)
[10:22:44.809]     }
[10:22:44.809]     ...future.frame <- base::sys.nframe()
[10:22:44.809]     ...future.conditions <- base::list()
[10:22:44.809]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:44.809]     if (FALSE) {
[10:22:44.809]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:44.809]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:44.809]     }
[10:22:44.809]     ...future.result <- base::tryCatch({
[10:22:44.809]         base::withCallingHandlers({
[10:22:44.809]             ...future.value <- base::withVisible(base::local({
[10:22:44.809]                 withCallingHandlers({
[10:22:44.809]                   {
[10:22:44.809]                     do.call(function(...) {
[10:22:44.809]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.809]                       if (!identical(...future.globals.maxSize.org, 
[10:22:44.809]                         ...future.globals.maxSize)) {
[10:22:44.809]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.809]                         on.exit(options(oopts), add = TRUE)
[10:22:44.809]                       }
[10:22:44.809]                       {
[10:22:44.809]                         lapply(seq_along(...future.elements_ii), 
[10:22:44.809]                           FUN = function(jj) {
[10:22:44.809]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.809]                             ...future.FUN(...future.X_jj, ...)
[10:22:44.809]                           })
[10:22:44.809]                       }
[10:22:44.809]                     }, args = future.call.arguments)
[10:22:44.809]                   }
[10:22:44.809]                 }, immediateCondition = function(cond) {
[10:22:44.809]                   save_rds <- function (object, pathname, ...) 
[10:22:44.809]                   {
[10:22:44.809]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:44.809]                     if (file_test("-f", pathname_tmp)) {
[10:22:44.809]                       fi_tmp <- file.info(pathname_tmp)
[10:22:44.809]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:44.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:44.809]                         fi_tmp[["mtime"]])
[10:22:44.809]                     }
[10:22:44.809]                     tryCatch({
[10:22:44.809]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:44.809]                     }, error = function(ex) {
[10:22:44.809]                       msg <- conditionMessage(ex)
[10:22:44.809]                       fi_tmp <- file.info(pathname_tmp)
[10:22:44.809]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:44.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:44.809]                         fi_tmp[["mtime"]], msg)
[10:22:44.809]                       ex$message <- msg
[10:22:44.809]                       stop(ex)
[10:22:44.809]                     })
[10:22:44.809]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:44.809]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:44.809]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:44.809]                       fi_tmp <- file.info(pathname_tmp)
[10:22:44.809]                       fi <- file.info(pathname)
[10:22:44.809]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:44.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:44.809]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:44.809]                         fi[["size"]], fi[["mtime"]])
[10:22:44.809]                       stop(msg)
[10:22:44.809]                     }
[10:22:44.809]                     invisible(pathname)
[10:22:44.809]                   }
[10:22:44.809]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:44.809]                     rootPath = tempdir()) 
[10:22:44.809]                   {
[10:22:44.809]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:44.809]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:44.809]                       tmpdir = path, fileext = ".rds")
[10:22:44.809]                     save_rds(obj, file)
[10:22:44.809]                   }
[10:22:44.809]                   saveImmediateCondition(cond, path = "/tmp/RtmpTHXGJm/.future/immediateConditions")
[10:22:44.809]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.809]                   {
[10:22:44.809]                     inherits <- base::inherits
[10:22:44.809]                     invokeRestart <- base::invokeRestart
[10:22:44.809]                     is.null <- base::is.null
[10:22:44.809]                     muffled <- FALSE
[10:22:44.809]                     if (inherits(cond, "message")) {
[10:22:44.809]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:44.809]                       if (muffled) 
[10:22:44.809]                         invokeRestart("muffleMessage")
[10:22:44.809]                     }
[10:22:44.809]                     else if (inherits(cond, "warning")) {
[10:22:44.809]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:44.809]                       if (muffled) 
[10:22:44.809]                         invokeRestart("muffleWarning")
[10:22:44.809]                     }
[10:22:44.809]                     else if (inherits(cond, "condition")) {
[10:22:44.809]                       if (!is.null(pattern)) {
[10:22:44.809]                         computeRestarts <- base::computeRestarts
[10:22:44.809]                         grepl <- base::grepl
[10:22:44.809]                         restarts <- computeRestarts(cond)
[10:22:44.809]                         for (restart in restarts) {
[10:22:44.809]                           name <- restart$name
[10:22:44.809]                           if (is.null(name)) 
[10:22:44.809]                             next
[10:22:44.809]                           if (!grepl(pattern, name)) 
[10:22:44.809]                             next
[10:22:44.809]                           invokeRestart(restart)
[10:22:44.809]                           muffled <- TRUE
[10:22:44.809]                           break
[10:22:44.809]                         }
[10:22:44.809]                       }
[10:22:44.809]                     }
[10:22:44.809]                     invisible(muffled)
[10:22:44.809]                   }
[10:22:44.809]                   muffleCondition(cond)
[10:22:44.809]                 })
[10:22:44.809]             }))
[10:22:44.809]             future::FutureResult(value = ...future.value$value, 
[10:22:44.809]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.809]                   ...future.rng), globalenv = if (FALSE) 
[10:22:44.809]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:44.809]                     ...future.globalenv.names))
[10:22:44.809]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:44.809]         }, condition = base::local({
[10:22:44.809]             c <- base::c
[10:22:44.809]             inherits <- base::inherits
[10:22:44.809]             invokeRestart <- base::invokeRestart
[10:22:44.809]             length <- base::length
[10:22:44.809]             list <- base::list
[10:22:44.809]             seq.int <- base::seq.int
[10:22:44.809]             signalCondition <- base::signalCondition
[10:22:44.809]             sys.calls <- base::sys.calls
[10:22:44.809]             `[[` <- base::`[[`
[10:22:44.809]             `+` <- base::`+`
[10:22:44.809]             `<<-` <- base::`<<-`
[10:22:44.809]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:44.809]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:44.809]                   3L)]
[10:22:44.809]             }
[10:22:44.809]             function(cond) {
[10:22:44.809]                 is_error <- inherits(cond, "error")
[10:22:44.809]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:44.809]                   NULL)
[10:22:44.809]                 if (is_error) {
[10:22:44.809]                   sessionInformation <- function() {
[10:22:44.809]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:44.809]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:44.809]                       search = base::search(), system = base::Sys.info())
[10:22:44.809]                   }
[10:22:44.809]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.809]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:44.809]                     cond$call), session = sessionInformation(), 
[10:22:44.809]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:44.809]                   signalCondition(cond)
[10:22:44.809]                 }
[10:22:44.809]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:44.809]                 "immediateCondition"))) {
[10:22:44.809]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:44.809]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.809]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:44.809]                   if (TRUE && !signal) {
[10:22:44.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.809]                     {
[10:22:44.809]                       inherits <- base::inherits
[10:22:44.809]                       invokeRestart <- base::invokeRestart
[10:22:44.809]                       is.null <- base::is.null
[10:22:44.809]                       muffled <- FALSE
[10:22:44.809]                       if (inherits(cond, "message")) {
[10:22:44.809]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.809]                         if (muffled) 
[10:22:44.809]                           invokeRestart("muffleMessage")
[10:22:44.809]                       }
[10:22:44.809]                       else if (inherits(cond, "warning")) {
[10:22:44.809]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.809]                         if (muffled) 
[10:22:44.809]                           invokeRestart("muffleWarning")
[10:22:44.809]                       }
[10:22:44.809]                       else if (inherits(cond, "condition")) {
[10:22:44.809]                         if (!is.null(pattern)) {
[10:22:44.809]                           computeRestarts <- base::computeRestarts
[10:22:44.809]                           grepl <- base::grepl
[10:22:44.809]                           restarts <- computeRestarts(cond)
[10:22:44.809]                           for (restart in restarts) {
[10:22:44.809]                             name <- restart$name
[10:22:44.809]                             if (is.null(name)) 
[10:22:44.809]                               next
[10:22:44.809]                             if (!grepl(pattern, name)) 
[10:22:44.809]                               next
[10:22:44.809]                             invokeRestart(restart)
[10:22:44.809]                             muffled <- TRUE
[10:22:44.809]                             break
[10:22:44.809]                           }
[10:22:44.809]                         }
[10:22:44.809]                       }
[10:22:44.809]                       invisible(muffled)
[10:22:44.809]                     }
[10:22:44.809]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.809]                   }
[10:22:44.809]                 }
[10:22:44.809]                 else {
[10:22:44.809]                   if (TRUE) {
[10:22:44.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.809]                     {
[10:22:44.809]                       inherits <- base::inherits
[10:22:44.809]                       invokeRestart <- base::invokeRestart
[10:22:44.809]                       is.null <- base::is.null
[10:22:44.809]                       muffled <- FALSE
[10:22:44.809]                       if (inherits(cond, "message")) {
[10:22:44.809]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.809]                         if (muffled) 
[10:22:44.809]                           invokeRestart("muffleMessage")
[10:22:44.809]                       }
[10:22:44.809]                       else if (inherits(cond, "warning")) {
[10:22:44.809]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.809]                         if (muffled) 
[10:22:44.809]                           invokeRestart("muffleWarning")
[10:22:44.809]                       }
[10:22:44.809]                       else if (inherits(cond, "condition")) {
[10:22:44.809]                         if (!is.null(pattern)) {
[10:22:44.809]                           computeRestarts <- base::computeRestarts
[10:22:44.809]                           grepl <- base::grepl
[10:22:44.809]                           restarts <- computeRestarts(cond)
[10:22:44.809]                           for (restart in restarts) {
[10:22:44.809]                             name <- restart$name
[10:22:44.809]                             if (is.null(name)) 
[10:22:44.809]                               next
[10:22:44.809]                             if (!grepl(pattern, name)) 
[10:22:44.809]                               next
[10:22:44.809]                             invokeRestart(restart)
[10:22:44.809]                             muffled <- TRUE
[10:22:44.809]                             break
[10:22:44.809]                           }
[10:22:44.809]                         }
[10:22:44.809]                       }
[10:22:44.809]                       invisible(muffled)
[10:22:44.809]                     }
[10:22:44.809]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.809]                   }
[10:22:44.809]                 }
[10:22:44.809]             }
[10:22:44.809]         }))
[10:22:44.809]     }, error = function(ex) {
[10:22:44.809]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:44.809]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.809]                 ...future.rng), started = ...future.startTime, 
[10:22:44.809]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:44.809]             version = "1.8"), class = "FutureResult")
[10:22:44.809]     }, finally = {
[10:22:44.809]         if (!identical(...future.workdir, getwd())) 
[10:22:44.809]             setwd(...future.workdir)
[10:22:44.809]         {
[10:22:44.809]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:44.809]                 ...future.oldOptions$nwarnings <- NULL
[10:22:44.809]             }
[10:22:44.809]             base::options(...future.oldOptions)
[10:22:44.809]             if (.Platform$OS.type == "windows") {
[10:22:44.809]                 old_names <- names(...future.oldEnvVars)
[10:22:44.809]                 envs <- base::Sys.getenv()
[10:22:44.809]                 names <- names(envs)
[10:22:44.809]                 common <- intersect(names, old_names)
[10:22:44.809]                 added <- setdiff(names, old_names)
[10:22:44.809]                 removed <- setdiff(old_names, names)
[10:22:44.809]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:44.809]                   envs[common]]
[10:22:44.809]                 NAMES <- toupper(changed)
[10:22:44.809]                 args <- list()
[10:22:44.809]                 for (kk in seq_along(NAMES)) {
[10:22:44.809]                   name <- changed[[kk]]
[10:22:44.809]                   NAME <- NAMES[[kk]]
[10:22:44.809]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.809]                     next
[10:22:44.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.809]                 }
[10:22:44.809]                 NAMES <- toupper(added)
[10:22:44.809]                 for (kk in seq_along(NAMES)) {
[10:22:44.809]                   name <- added[[kk]]
[10:22:44.809]                   NAME <- NAMES[[kk]]
[10:22:44.809]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.809]                     next
[10:22:44.809]                   args[[name]] <- ""
[10:22:44.809]                 }
[10:22:44.809]                 NAMES <- toupper(removed)
[10:22:44.809]                 for (kk in seq_along(NAMES)) {
[10:22:44.809]                   name <- removed[[kk]]
[10:22:44.809]                   NAME <- NAMES[[kk]]
[10:22:44.809]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.809]                     next
[10:22:44.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.809]                 }
[10:22:44.809]                 if (length(args) > 0) 
[10:22:44.809]                   base::do.call(base::Sys.setenv, args = args)
[10:22:44.809]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:44.809]             }
[10:22:44.809]             else {
[10:22:44.809]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:44.809]             }
[10:22:44.809]             {
[10:22:44.809]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:44.809]                   0L) {
[10:22:44.809]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:44.809]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:44.809]                   base::options(opts)
[10:22:44.809]                 }
[10:22:44.809]                 {
[10:22:44.809]                   {
[10:22:44.809]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:44.809]                     NULL
[10:22:44.809]                   }
[10:22:44.809]                   options(future.plan = NULL)
[10:22:44.809]                   if (is.na(NA_character_)) 
[10:22:44.809]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.809]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:44.809]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:44.809]                     envir = parent.frame()) 
[10:22:44.809]                   {
[10:22:44.809]                     default_workers <- missing(workers)
[10:22:44.809]                     if (is.function(workers)) 
[10:22:44.809]                       workers <- workers()
[10:22:44.809]                     workers <- structure(as.integer(workers), 
[10:22:44.809]                       class = class(workers))
[10:22:44.809]                     stop_if_not(is.finite(workers), workers >= 
[10:22:44.809]                       1L)
[10:22:44.809]                     if ((workers == 1L && !inherits(workers, 
[10:22:44.809]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:44.809]                       if (default_workers) 
[10:22:44.809]                         supportsMulticore(warn = TRUE)
[10:22:44.809]                       return(sequential(..., envir = envir))
[10:22:44.809]                     }
[10:22:44.809]                     oopts <- options(mc.cores = workers)
[10:22:44.809]                     on.exit(options(oopts))
[10:22:44.809]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:44.809]                       envir = envir)
[10:22:44.809]                     if (!future$lazy) 
[10:22:44.809]                       future <- run(future)
[10:22:44.809]                     invisible(future)
[10:22:44.809]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:44.809]                 }
[10:22:44.809]             }
[10:22:44.809]         }
[10:22:44.809]     })
[10:22:44.809]     if (TRUE) {
[10:22:44.809]         base::sink(type = "output", split = FALSE)
[10:22:44.809]         if (TRUE) {
[10:22:44.809]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:44.809]         }
[10:22:44.809]         else {
[10:22:44.809]             ...future.result["stdout"] <- base::list(NULL)
[10:22:44.809]         }
[10:22:44.809]         base::close(...future.stdout)
[10:22:44.809]         ...future.stdout <- NULL
[10:22:44.809]     }
[10:22:44.809]     ...future.result$conditions <- ...future.conditions
[10:22:44.809]     ...future.result$finished <- base::Sys.time()
[10:22:44.809]     ...future.result
[10:22:44.809] }
[10:22:44.811] assign_globals() ...
[10:22:44.811] List of 5
[10:22:44.811]  $ future.call.arguments    : list()
[10:22:44.811]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.811]  $ ...future.FUN            :function (x)  
[10:22:44.811]  $ ...future.elements_ii    :List of 1
[10:22:44.811]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[10:22:44.811]  $ ...future.seeds_ii       : NULL
[10:22:44.811]  $ ...future.globals.maxSize: num Inf
[10:22:44.811]  - attr(*, "resolved")= logi FALSE
[10:22:44.811]  - attr(*, "total_size")= num NA
[10:22:44.811]  - attr(*, "where")=List of 5
[10:22:44.811]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:44.811]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:44.811]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:44.811]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:44.811]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:44.811]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.811]  - attr(*, "already-done")= logi TRUE
[10:22:44.818] - copied ‘future.call.arguments’ to environment
[10:22:44.818] - copied ‘...future.FUN’ to environment
[10:22:44.818] - copied ‘...future.elements_ii’ to environment
[10:22:44.818] - copied ‘...future.seeds_ii’ to environment
[10:22:44.819] - copied ‘...future.globals.maxSize’ to environment
[10:22:44.819] assign_globals() ... done
[10:22:44.819] requestCore(): workers = 2
[10:22:44.821] MulticoreFuture started
[10:22:44.822] - Launch lazy future ... done
[10:22:44.822] run() for ‘MulticoreFuture’ ... done
[10:22:44.822] Created future:
[10:22:44.822] plan(): Setting new future strategy stack:
[10:22:44.822] List of future strategies:
[10:22:44.822] 1. sequential:
[10:22:44.822]    - args: function (..., envir = parent.frame())
[10:22:44.822]    - tweaked: FALSE
[10:22:44.822]    - call: NULL
[10:22:44.823] plan(): nbrOfWorkers() = 1
[10:22:44.825] plan(): Setting new future strategy stack:
[10:22:44.826] List of future strategies:
[10:22:44.826] 1. multicore:
[10:22:44.826]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:44.826]    - tweaked: FALSE
[10:22:44.826]    - call: plan(strategy)
[10:22:44.831] plan(): nbrOfWorkers() = 2
[10:22:44.822] MulticoreFuture:
[10:22:44.822] Label: ‘future_apply-2’
[10:22:44.822] Expression:
[10:22:44.822] {
[10:22:44.822]     do.call(function(...) {
[10:22:44.822]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.822]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:44.822]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.822]             on.exit(options(oopts), add = TRUE)
[10:22:44.822]         }
[10:22:44.822]         {
[10:22:44.822]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:44.822]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.822]                 ...future.FUN(...future.X_jj, ...)
[10:22:44.822]             })
[10:22:44.822]         }
[10:22:44.822]     }, args = future.call.arguments)
[10:22:44.822] }
[10:22:44.822] Lazy evaluation: FALSE
[10:22:44.822] Asynchronous evaluation: TRUE
[10:22:44.822] Local evaluation: TRUE
[10:22:44.822] Environment: R_GlobalEnv
[10:22:44.822] Capture standard output: TRUE
[10:22:44.822] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:44.822] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:44.822] Packages: <none>
[10:22:44.822] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:44.822] Resolved: TRUE
[10:22:44.822] Value: <not collected>
[10:22:44.822] Conditions captured: <none>
[10:22:44.822] Early signaling: FALSE
[10:22:44.822] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:44.822] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:44.832] Chunk #2 of 2 ... DONE
[10:22:44.832] Launching 2 futures (chunks) ... DONE
[10:22:44.832] Resolving 2 futures (chunks) ...
[10:22:44.832] resolve() on list ...
[10:22:44.833]  recursive: 0
[10:22:44.833]  length: 2
[10:22:44.833] 
[10:22:44.833] Future #1
[10:22:44.833] result() for MulticoreFuture ...
[10:22:44.834] result() for MulticoreFuture ...
[10:22:44.834] result() for MulticoreFuture ... done
[10:22:44.835] result() for MulticoreFuture ... done
[10:22:44.835] result() for MulticoreFuture ...
[10:22:44.835] result() for MulticoreFuture ... done
[10:22:44.835] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:22:44.835] - nx: 2
[10:22:44.835] - relay: TRUE
[10:22:44.836] - stdout: TRUE
[10:22:44.836] - signal: TRUE
[10:22:44.836] - resignal: FALSE
[10:22:44.836] - force: TRUE
[10:22:44.836] - relayed: [n=2] FALSE, FALSE
[10:22:44.836] - queued futures: [n=2] FALSE, FALSE
[10:22:44.836]  - until=1
[10:22:44.837]  - relaying element #1
[10:22:44.837] result() for MulticoreFuture ...
[10:22:44.837] result() for MulticoreFuture ... done
[10:22:44.837] result() for MulticoreFuture ...
[10:22:44.837] result() for MulticoreFuture ... done
[10:22:44.837] result() for MulticoreFuture ...
[10:22:44.838] result() for MulticoreFuture ... done
[10:22:44.838] result() for MulticoreFuture ...
[10:22:44.838] result() for MulticoreFuture ... done
[10:22:44.838] - relayed: [n=2] TRUE, FALSE
[10:22:44.838] - queued futures: [n=2] TRUE, FALSE
[10:22:44.838] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:22:44.838]  length: 1 (resolved future 1)
[10:22:44.839] Future #2
[10:22:44.839] result() for MulticoreFuture ...
[10:22:44.840] result() for MulticoreFuture ...
[10:22:44.840] result() for MulticoreFuture ... done
[10:22:44.840] result() for MulticoreFuture ... done
[10:22:44.840] result() for MulticoreFuture ...
[10:22:44.840] result() for MulticoreFuture ... done
[10:22:44.840] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:22:44.840] - nx: 2
[10:22:44.841] - relay: TRUE
[10:22:44.841] - stdout: TRUE
[10:22:44.841] - signal: TRUE
[10:22:44.841] - resignal: FALSE
[10:22:44.841] - force: TRUE
[10:22:44.841] - relayed: [n=2] TRUE, FALSE
[10:22:44.841] - queued futures: [n=2] TRUE, FALSE
[10:22:44.841]  - until=2
[10:22:44.842]  - relaying element #2
[10:22:44.842] result() for MulticoreFuture ...
[10:22:44.842] result() for MulticoreFuture ... done
[10:22:44.842] result() for MulticoreFuture ...
[10:22:44.845] result() for MulticoreFuture ... done
[10:22:44.845] result() for MulticoreFuture ...
[10:22:44.845] result() for MulticoreFuture ... done
[10:22:44.845] result() for MulticoreFuture ...
[10:22:44.845] result() for MulticoreFuture ... done
[10:22:44.846] - relayed: [n=2] TRUE, TRUE
[10:22:44.846] - queued futures: [n=2] TRUE, TRUE
[10:22:44.846] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:22:44.846]  length: 0 (resolved future 2)
[10:22:44.846] Relaying remaining futures
[10:22:44.846] signalConditionsASAP(NULL, pos=0) ...
[10:22:44.847] - nx: 2
[10:22:44.847] - relay: TRUE
[10:22:44.847] - stdout: TRUE
[10:22:44.847] - signal: TRUE
[10:22:44.847] - resignal: FALSE
[10:22:44.847] - force: TRUE
[10:22:44.847] - relayed: [n=2] TRUE, TRUE
[10:22:44.848] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:22:44.848] - relayed: [n=2] TRUE, TRUE
[10:22:44.848] - queued futures: [n=2] TRUE, TRUE
[10:22:44.848] signalConditionsASAP(NULL, pos=0) ... done
[10:22:44.848] resolve() on list ... DONE
[10:22:44.849] result() for MulticoreFuture ...
[10:22:44.849] result() for MulticoreFuture ... done
[10:22:44.849] result() for MulticoreFuture ...
[10:22:44.849] result() for MulticoreFuture ... done
[10:22:44.849] result() for MulticoreFuture ...
[10:22:44.849] result() for MulticoreFuture ... done
[10:22:44.849] result() for MulticoreFuture ...
[10:22:44.850] result() for MulticoreFuture ... done
[10:22:44.850]  - Number of value chunks collected: 2
[10:22:44.850] Resolving 2 futures (chunks) ... DONE
[10:22:44.850] Reducing values from 2 chunks ...
[10:22:44.850]  - Number of values collected after concatenation: 2
[10:22:44.850]  - Number of values expected: 2
[10:22:44.850] Reducing values from 2 chunks ... DONE
[10:22:44.850] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[10:22:44.851] getGlobalsAndPackagesXApply() ...
[10:22:44.851]  - future.globals: TRUE
[10:22:44.851] getGlobalsAndPackages() ...
[10:22:44.851] Searching for globals...
[10:22:44.853] - globals found: [1] ‘FUN’
[10:22:44.853] Searching for globals ... DONE
[10:22:44.853] Resolving globals: FALSE
[10:22:44.853] The total size of the 1 globals is 848 bytes (848 bytes)
[10:22:44.854] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:22:44.854] - globals: [1] ‘FUN’
[10:22:44.854] 
[10:22:44.854] getGlobalsAndPackages() ... DONE
[10:22:44.854]  - globals found/used: [n=1] ‘FUN’
[10:22:44.854]  - needed namespaces: [n=0] 
[10:22:44.855] Finding globals ... DONE
[10:22:44.855]  - use_args: TRUE
[10:22:44.855]  - Getting '...' globals ...
[10:22:44.855] resolve() on list ...
[10:22:44.855]  recursive: 0
[10:22:44.855]  length: 1
[10:22:44.855]  elements: ‘...’
[10:22:44.856]  length: 0 (resolved future 1)
[10:22:44.856] resolve() on list ... DONE
[10:22:44.856]    - '...' content: [n=0] 
[10:22:44.856] List of 1
[10:22:44.856]  $ ...: list()
[10:22:44.856]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.856]  - attr(*, "where")=List of 1
[10:22:44.856]   ..$ ...:<environment: 0x55ca4c36b790> 
[10:22:44.856]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.856]  - attr(*, "resolved")= logi TRUE
[10:22:44.856]  - attr(*, "total_size")= num NA
[10:22:44.859]  - Getting '...' globals ... DONE
[10:22:44.859] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:44.859] List of 2
[10:22:44.859]  $ ...future.FUN:function (x)  
[10:22:44.859]  $ ...          : list()
[10:22:44.859]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.859]  - attr(*, "where")=List of 2
[10:22:44.859]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:44.859]   ..$ ...          :<environment: 0x55ca4c36b790> 
[10:22:44.859]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.859]  - attr(*, "resolved")= logi FALSE
[10:22:44.859]  - attr(*, "total_size")= num 848
[10:22:44.862] Packages to be attached in all futures: [n=0] 
[10:22:44.862] getGlobalsAndPackagesXApply() ... DONE
[10:22:44.866] future_lapply() ...
[10:22:44.869] Number of chunks: 2
[10:22:44.869] getGlobalsAndPackagesXApply() ...
[10:22:44.870]  - future.globals: <name-value list> with names ‘list()’
[10:22:44.870]  - use_args: TRUE
[10:22:44.870] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:22:44.870] List of 2
[10:22:44.870]  $ ...          : list()
[10:22:44.870]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.870]  $ ...future.FUN:function (x)  
[10:22:44.870]  - attr(*, "where")=List of 2
[10:22:44.870]   ..$ ...          :<environment: 0x55ca4c36b790> 
[10:22:44.870]   ..$ ...future.FUN:<environment: namespace:base> 
[10:22:44.870]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.870]  - attr(*, "resolved")= logi FALSE
[10:22:44.870]  - attr(*, "total_size")= num NA
[10:22:44.875] Packages to be attached in all futures: [n=0] 
[10:22:44.875] getGlobalsAndPackagesXApply() ... DONE
[10:22:44.875] Number of futures (= number of chunks): 2
[10:22:44.875] Launching 2 futures (chunks) ...
[10:22:44.876] Chunk #1 of 2 ...
[10:22:44.876]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:44.876]  - seeds: <none>
[10:22:44.876]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.876] getGlobalsAndPackages() ...
[10:22:44.876] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.876] Resolving globals: FALSE
[10:22:44.876] Tweak future expression to call with '...' arguments ...
[10:22:44.877] {
[10:22:44.877]     do.call(function(...) {
[10:22:44.877]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.877]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:44.877]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.877]             on.exit(options(oopts), add = TRUE)
[10:22:44.877]         }
[10:22:44.877]         {
[10:22:44.877]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:44.877]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.877]                 ...future.FUN(...future.X_jj, ...)
[10:22:44.877]             })
[10:22:44.877]         }
[10:22:44.877]     }, args = future.call.arguments)
[10:22:44.877] }
[10:22:44.877] Tweak future expression to call with '...' arguments ... DONE
[10:22:44.877] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.877] 
[10:22:44.878] getGlobalsAndPackages() ... DONE
[10:22:44.878] run() for ‘Future’ ...
[10:22:44.878] - state: ‘created’
[10:22:44.878] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:44.882] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:44.882] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:44.882]   - Field: ‘label’
[10:22:44.882]   - Field: ‘local’
[10:22:44.882]   - Field: ‘owner’
[10:22:44.882]   - Field: ‘envir’
[10:22:44.882]   - Field: ‘workers’
[10:22:44.882]   - Field: ‘packages’
[10:22:44.882]   - Field: ‘gc’
[10:22:44.883]   - Field: ‘job’
[10:22:44.883]   - Field: ‘conditions’
[10:22:44.883]   - Field: ‘expr’
[10:22:44.883]   - Field: ‘uuid’
[10:22:44.883]   - Field: ‘seed’
[10:22:44.883]   - Field: ‘version’
[10:22:44.883]   - Field: ‘result’
[10:22:44.883]   - Field: ‘asynchronous’
[10:22:44.883]   - Field: ‘calls’
[10:22:44.883]   - Field: ‘globals’
[10:22:44.883]   - Field: ‘stdout’
[10:22:44.884]   - Field: ‘earlySignal’
[10:22:44.884]   - Field: ‘lazy’
[10:22:44.884]   - Field: ‘state’
[10:22:44.884] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:44.884] - Launch lazy future ...
[10:22:44.884] Packages needed by the future expression (n = 0): <none>
[10:22:44.884] Packages needed by future strategies (n = 0): <none>
[10:22:44.885] {
[10:22:44.885]     {
[10:22:44.885]         {
[10:22:44.885]             ...future.startTime <- base::Sys.time()
[10:22:44.885]             {
[10:22:44.885]                 {
[10:22:44.885]                   {
[10:22:44.885]                     {
[10:22:44.885]                       base::local({
[10:22:44.885]                         has_future <- base::requireNamespace("future", 
[10:22:44.885]                           quietly = TRUE)
[10:22:44.885]                         if (has_future) {
[10:22:44.885]                           ns <- base::getNamespace("future")
[10:22:44.885]                           version <- ns[[".package"]][["version"]]
[10:22:44.885]                           if (is.null(version)) 
[10:22:44.885]                             version <- utils::packageVersion("future")
[10:22:44.885]                         }
[10:22:44.885]                         else {
[10:22:44.885]                           version <- NULL
[10:22:44.885]                         }
[10:22:44.885]                         if (!has_future || version < "1.8.0") {
[10:22:44.885]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:44.885]                             "", base::R.version$version.string), 
[10:22:44.885]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:44.885]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:44.885]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:44.885]                               "release", "version")], collapse = " "), 
[10:22:44.885]                             hostname = base::Sys.info()[["nodename"]])
[10:22:44.885]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:44.885]                             info)
[10:22:44.885]                           info <- base::paste(info, collapse = "; ")
[10:22:44.885]                           if (!has_future) {
[10:22:44.885]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:44.885]                               info)
[10:22:44.885]                           }
[10:22:44.885]                           else {
[10:22:44.885]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:44.885]                               info, version)
[10:22:44.885]                           }
[10:22:44.885]                           base::stop(msg)
[10:22:44.885]                         }
[10:22:44.885]                       })
[10:22:44.885]                     }
[10:22:44.885]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:44.885]                     base::options(mc.cores = 1L)
[10:22:44.885]                   }
[10:22:44.885]                   options(future.plan = NULL)
[10:22:44.885]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.885]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:44.885]                 }
[10:22:44.885]                 ...future.workdir <- getwd()
[10:22:44.885]             }
[10:22:44.885]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:44.885]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:44.885]         }
[10:22:44.885]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:44.885]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:44.885]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:44.885]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:44.885]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:44.885]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:44.885]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:44.885]             base::names(...future.oldOptions))
[10:22:44.885]     }
[10:22:44.885]     if (FALSE) {
[10:22:44.885]     }
[10:22:44.885]     else {
[10:22:44.885]         if (TRUE) {
[10:22:44.885]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:44.885]                 open = "w")
[10:22:44.885]         }
[10:22:44.885]         else {
[10:22:44.885]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:44.885]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:44.885]         }
[10:22:44.885]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:44.885]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:44.885]             base::sink(type = "output", split = FALSE)
[10:22:44.885]             base::close(...future.stdout)
[10:22:44.885]         }, add = TRUE)
[10:22:44.885]     }
[10:22:44.885]     ...future.frame <- base::sys.nframe()
[10:22:44.885]     ...future.conditions <- base::list()
[10:22:44.885]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:44.885]     if (FALSE) {
[10:22:44.885]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:44.885]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:44.885]     }
[10:22:44.885]     ...future.result <- base::tryCatch({
[10:22:44.885]         base::withCallingHandlers({
[10:22:44.885]             ...future.value <- base::withVisible(base::local({
[10:22:44.885]                 withCallingHandlers({
[10:22:44.885]                   {
[10:22:44.885]                     do.call(function(...) {
[10:22:44.885]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.885]                       if (!identical(...future.globals.maxSize.org, 
[10:22:44.885]                         ...future.globals.maxSize)) {
[10:22:44.885]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.885]                         on.exit(options(oopts), add = TRUE)
[10:22:44.885]                       }
[10:22:44.885]                       {
[10:22:44.885]                         lapply(seq_along(...future.elements_ii), 
[10:22:44.885]                           FUN = function(jj) {
[10:22:44.885]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.885]                             ...future.FUN(...future.X_jj, ...)
[10:22:44.885]                           })
[10:22:44.885]                       }
[10:22:44.885]                     }, args = future.call.arguments)
[10:22:44.885]                   }
[10:22:44.885]                 }, immediateCondition = function(cond) {
[10:22:44.885]                   save_rds <- function (object, pathname, ...) 
[10:22:44.885]                   {
[10:22:44.885]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:44.885]                     if (file_test("-f", pathname_tmp)) {
[10:22:44.885]                       fi_tmp <- file.info(pathname_tmp)
[10:22:44.885]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:44.885]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:44.885]                         fi_tmp[["mtime"]])
[10:22:44.885]                     }
[10:22:44.885]                     tryCatch({
[10:22:44.885]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:44.885]                     }, error = function(ex) {
[10:22:44.885]                       msg <- conditionMessage(ex)
[10:22:44.885]                       fi_tmp <- file.info(pathname_tmp)
[10:22:44.885]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:44.885]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:44.885]                         fi_tmp[["mtime"]], msg)
[10:22:44.885]                       ex$message <- msg
[10:22:44.885]                       stop(ex)
[10:22:44.885]                     })
[10:22:44.885]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:44.885]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:44.885]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:44.885]                       fi_tmp <- file.info(pathname_tmp)
[10:22:44.885]                       fi <- file.info(pathname)
[10:22:44.885]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:44.885]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:44.885]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:44.885]                         fi[["size"]], fi[["mtime"]])
[10:22:44.885]                       stop(msg)
[10:22:44.885]                     }
[10:22:44.885]                     invisible(pathname)
[10:22:44.885]                   }
[10:22:44.885]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:44.885]                     rootPath = tempdir()) 
[10:22:44.885]                   {
[10:22:44.885]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:44.885]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:44.885]                       tmpdir = path, fileext = ".rds")
[10:22:44.885]                     save_rds(obj, file)
[10:22:44.885]                   }
[10:22:44.885]                   saveImmediateCondition(cond, path = "/tmp/RtmpTHXGJm/.future/immediateConditions")
[10:22:44.885]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.885]                   {
[10:22:44.885]                     inherits <- base::inherits
[10:22:44.885]                     invokeRestart <- base::invokeRestart
[10:22:44.885]                     is.null <- base::is.null
[10:22:44.885]                     muffled <- FALSE
[10:22:44.885]                     if (inherits(cond, "message")) {
[10:22:44.885]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:44.885]                       if (muffled) 
[10:22:44.885]                         invokeRestart("muffleMessage")
[10:22:44.885]                     }
[10:22:44.885]                     else if (inherits(cond, "warning")) {
[10:22:44.885]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:44.885]                       if (muffled) 
[10:22:44.885]                         invokeRestart("muffleWarning")
[10:22:44.885]                     }
[10:22:44.885]                     else if (inherits(cond, "condition")) {
[10:22:44.885]                       if (!is.null(pattern)) {
[10:22:44.885]                         computeRestarts <- base::computeRestarts
[10:22:44.885]                         grepl <- base::grepl
[10:22:44.885]                         restarts <- computeRestarts(cond)
[10:22:44.885]                         for (restart in restarts) {
[10:22:44.885]                           name <- restart$name
[10:22:44.885]                           if (is.null(name)) 
[10:22:44.885]                             next
[10:22:44.885]                           if (!grepl(pattern, name)) 
[10:22:44.885]                             next
[10:22:44.885]                           invokeRestart(restart)
[10:22:44.885]                           muffled <- TRUE
[10:22:44.885]                           break
[10:22:44.885]                         }
[10:22:44.885]                       }
[10:22:44.885]                     }
[10:22:44.885]                     invisible(muffled)
[10:22:44.885]                   }
[10:22:44.885]                   muffleCondition(cond)
[10:22:44.885]                 })
[10:22:44.885]             }))
[10:22:44.885]             future::FutureResult(value = ...future.value$value, 
[10:22:44.885]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.885]                   ...future.rng), globalenv = if (FALSE) 
[10:22:44.885]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:44.885]                     ...future.globalenv.names))
[10:22:44.885]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:44.885]         }, condition = base::local({
[10:22:44.885]             c <- base::c
[10:22:44.885]             inherits <- base::inherits
[10:22:44.885]             invokeRestart <- base::invokeRestart
[10:22:44.885]             length <- base::length
[10:22:44.885]             list <- base::list
[10:22:44.885]             seq.int <- base::seq.int
[10:22:44.885]             signalCondition <- base::signalCondition
[10:22:44.885]             sys.calls <- base::sys.calls
[10:22:44.885]             `[[` <- base::`[[`
[10:22:44.885]             `+` <- base::`+`
[10:22:44.885]             `<<-` <- base::`<<-`
[10:22:44.885]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:44.885]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:44.885]                   3L)]
[10:22:44.885]             }
[10:22:44.885]             function(cond) {
[10:22:44.885]                 is_error <- inherits(cond, "error")
[10:22:44.885]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:44.885]                   NULL)
[10:22:44.885]                 if (is_error) {
[10:22:44.885]                   sessionInformation <- function() {
[10:22:44.885]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:44.885]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:44.885]                       search = base::search(), system = base::Sys.info())
[10:22:44.885]                   }
[10:22:44.885]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.885]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:44.885]                     cond$call), session = sessionInformation(), 
[10:22:44.885]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:44.885]                   signalCondition(cond)
[10:22:44.885]                 }
[10:22:44.885]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:44.885]                 "immediateCondition"))) {
[10:22:44.885]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:44.885]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.885]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:44.885]                   if (TRUE && !signal) {
[10:22:44.885]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.885]                     {
[10:22:44.885]                       inherits <- base::inherits
[10:22:44.885]                       invokeRestart <- base::invokeRestart
[10:22:44.885]                       is.null <- base::is.null
[10:22:44.885]                       muffled <- FALSE
[10:22:44.885]                       if (inherits(cond, "message")) {
[10:22:44.885]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.885]                         if (muffled) 
[10:22:44.885]                           invokeRestart("muffleMessage")
[10:22:44.885]                       }
[10:22:44.885]                       else if (inherits(cond, "warning")) {
[10:22:44.885]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.885]                         if (muffled) 
[10:22:44.885]                           invokeRestart("muffleWarning")
[10:22:44.885]                       }
[10:22:44.885]                       else if (inherits(cond, "condition")) {
[10:22:44.885]                         if (!is.null(pattern)) {
[10:22:44.885]                           computeRestarts <- base::computeRestarts
[10:22:44.885]                           grepl <- base::grepl
[10:22:44.885]                           restarts <- computeRestarts(cond)
[10:22:44.885]                           for (restart in restarts) {
[10:22:44.885]                             name <- restart$name
[10:22:44.885]                             if (is.null(name)) 
[10:22:44.885]                               next
[10:22:44.885]                             if (!grepl(pattern, name)) 
[10:22:44.885]                               next
[10:22:44.885]                             invokeRestart(restart)
[10:22:44.885]                             muffled <- TRUE
[10:22:44.885]                             break
[10:22:44.885]                           }
[10:22:44.885]                         }
[10:22:44.885]                       }
[10:22:44.885]                       invisible(muffled)
[10:22:44.885]                     }
[10:22:44.885]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.885]                   }
[10:22:44.885]                 }
[10:22:44.885]                 else {
[10:22:44.885]                   if (TRUE) {
[10:22:44.885]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.885]                     {
[10:22:44.885]                       inherits <- base::inherits
[10:22:44.885]                       invokeRestart <- base::invokeRestart
[10:22:44.885]                       is.null <- base::is.null
[10:22:44.885]                       muffled <- FALSE
[10:22:44.885]                       if (inherits(cond, "message")) {
[10:22:44.885]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.885]                         if (muffled) 
[10:22:44.885]                           invokeRestart("muffleMessage")
[10:22:44.885]                       }
[10:22:44.885]                       else if (inherits(cond, "warning")) {
[10:22:44.885]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.885]                         if (muffled) 
[10:22:44.885]                           invokeRestart("muffleWarning")
[10:22:44.885]                       }
[10:22:44.885]                       else if (inherits(cond, "condition")) {
[10:22:44.885]                         if (!is.null(pattern)) {
[10:22:44.885]                           computeRestarts <- base::computeRestarts
[10:22:44.885]                           grepl <- base::grepl
[10:22:44.885]                           restarts <- computeRestarts(cond)
[10:22:44.885]                           for (restart in restarts) {
[10:22:44.885]                             name <- restart$name
[10:22:44.885]                             if (is.null(name)) 
[10:22:44.885]                               next
[10:22:44.885]                             if (!grepl(pattern, name)) 
[10:22:44.885]                               next
[10:22:44.885]                             invokeRestart(restart)
[10:22:44.885]                             muffled <- TRUE
[10:22:44.885]                             break
[10:22:44.885]                           }
[10:22:44.885]                         }
[10:22:44.885]                       }
[10:22:44.885]                       invisible(muffled)
[10:22:44.885]                     }
[10:22:44.885]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.885]                   }
[10:22:44.885]                 }
[10:22:44.885]             }
[10:22:44.885]         }))
[10:22:44.885]     }, error = function(ex) {
[10:22:44.885]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:44.885]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.885]                 ...future.rng), started = ...future.startTime, 
[10:22:44.885]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:44.885]             version = "1.8"), class = "FutureResult")
[10:22:44.885]     }, finally = {
[10:22:44.885]         if (!identical(...future.workdir, getwd())) 
[10:22:44.885]             setwd(...future.workdir)
[10:22:44.885]         {
[10:22:44.885]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:44.885]                 ...future.oldOptions$nwarnings <- NULL
[10:22:44.885]             }
[10:22:44.885]             base::options(...future.oldOptions)
[10:22:44.885]             if (.Platform$OS.type == "windows") {
[10:22:44.885]                 old_names <- names(...future.oldEnvVars)
[10:22:44.885]                 envs <- base::Sys.getenv()
[10:22:44.885]                 names <- names(envs)
[10:22:44.885]                 common <- intersect(names, old_names)
[10:22:44.885]                 added <- setdiff(names, old_names)
[10:22:44.885]                 removed <- setdiff(old_names, names)
[10:22:44.885]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:44.885]                   envs[common]]
[10:22:44.885]                 NAMES <- toupper(changed)
[10:22:44.885]                 args <- list()
[10:22:44.885]                 for (kk in seq_along(NAMES)) {
[10:22:44.885]                   name <- changed[[kk]]
[10:22:44.885]                   NAME <- NAMES[[kk]]
[10:22:44.885]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.885]                     next
[10:22:44.885]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.885]                 }
[10:22:44.885]                 NAMES <- toupper(added)
[10:22:44.885]                 for (kk in seq_along(NAMES)) {
[10:22:44.885]                   name <- added[[kk]]
[10:22:44.885]                   NAME <- NAMES[[kk]]
[10:22:44.885]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.885]                     next
[10:22:44.885]                   args[[name]] <- ""
[10:22:44.885]                 }
[10:22:44.885]                 NAMES <- toupper(removed)
[10:22:44.885]                 for (kk in seq_along(NAMES)) {
[10:22:44.885]                   name <- removed[[kk]]
[10:22:44.885]                   NAME <- NAMES[[kk]]
[10:22:44.885]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.885]                     next
[10:22:44.885]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.885]                 }
[10:22:44.885]                 if (length(args) > 0) 
[10:22:44.885]                   base::do.call(base::Sys.setenv, args = args)
[10:22:44.885]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:44.885]             }
[10:22:44.885]             else {
[10:22:44.885]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:44.885]             }
[10:22:44.885]             {
[10:22:44.885]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:44.885]                   0L) {
[10:22:44.885]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:44.885]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:44.885]                   base::options(opts)
[10:22:44.885]                 }
[10:22:44.885]                 {
[10:22:44.885]                   {
[10:22:44.885]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:44.885]                     NULL
[10:22:44.885]                   }
[10:22:44.885]                   options(future.plan = NULL)
[10:22:44.885]                   if (is.na(NA_character_)) 
[10:22:44.885]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.885]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:44.885]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:44.885]                     envir = parent.frame()) 
[10:22:44.885]                   {
[10:22:44.885]                     default_workers <- missing(workers)
[10:22:44.885]                     if (is.function(workers)) 
[10:22:44.885]                       workers <- workers()
[10:22:44.885]                     workers <- structure(as.integer(workers), 
[10:22:44.885]                       class = class(workers))
[10:22:44.885]                     stop_if_not(is.finite(workers), workers >= 
[10:22:44.885]                       1L)
[10:22:44.885]                     if ((workers == 1L && !inherits(workers, 
[10:22:44.885]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:44.885]                       if (default_workers) 
[10:22:44.885]                         supportsMulticore(warn = TRUE)
[10:22:44.885]                       return(sequential(..., envir = envir))
[10:22:44.885]                     }
[10:22:44.885]                     oopts <- options(mc.cores = workers)
[10:22:44.885]                     on.exit(options(oopts))
[10:22:44.885]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:44.885]                       envir = envir)
[10:22:44.885]                     if (!future$lazy) 
[10:22:44.885]                       future <- run(future)
[10:22:44.885]                     invisible(future)
[10:22:44.885]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:44.885]                 }
[10:22:44.885]             }
[10:22:44.885]         }
[10:22:44.885]     })
[10:22:44.885]     if (TRUE) {
[10:22:44.885]         base::sink(type = "output", split = FALSE)
[10:22:44.885]         if (TRUE) {
[10:22:44.885]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:44.885]         }
[10:22:44.885]         else {
[10:22:44.885]             ...future.result["stdout"] <- base::list(NULL)
[10:22:44.885]         }
[10:22:44.885]         base::close(...future.stdout)
[10:22:44.885]         ...future.stdout <- NULL
[10:22:44.885]     }
[10:22:44.885]     ...future.result$conditions <- ...future.conditions
[10:22:44.885]     ...future.result$finished <- base::Sys.time()
[10:22:44.885]     ...future.result
[10:22:44.885] }
[10:22:44.887] assign_globals() ...
[10:22:44.887] List of 5
[10:22:44.887]  $ future.call.arguments    : list()
[10:22:44.887]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.887]  $ ...future.FUN            :function (x)  
[10:22:44.887]  $ ...future.elements_ii    :List of 3
[10:22:44.887]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[10:22:44.887]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[10:22:44.887]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[10:22:44.887]  $ ...future.seeds_ii       : NULL
[10:22:44.887]  $ ...future.globals.maxSize: num Inf
[10:22:44.887]  - attr(*, "resolved")= logi FALSE
[10:22:44.887]  - attr(*, "total_size")= num NA
[10:22:44.887]  - attr(*, "where")=List of 5
[10:22:44.887]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:44.887]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:44.887]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:44.887]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:44.887]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:44.887]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.887]  - attr(*, "already-done")= logi TRUE
[10:22:44.892] - copied ‘future.call.arguments’ to environment
[10:22:44.893] - copied ‘...future.FUN’ to environment
[10:22:44.893] - copied ‘...future.elements_ii’ to environment
[10:22:44.893] - copied ‘...future.seeds_ii’ to environment
[10:22:44.893] - copied ‘...future.globals.maxSize’ to environment
[10:22:44.893] assign_globals() ... done
[10:22:44.893] requestCore(): workers = 2
[10:22:44.895] MulticoreFuture started
[10:22:44.895] - Launch lazy future ... done
[10:22:44.896] run() for ‘MulticoreFuture’ ... done
[10:22:44.896] Created future:
[10:22:44.896] plan(): Setting new future strategy stack:
[10:22:44.896] List of future strategies:
[10:22:44.896] 1. sequential:
[10:22:44.896]    - args: function (..., envir = parent.frame())
[10:22:44.896]    - tweaked: FALSE
[10:22:44.896]    - call: NULL
[10:22:44.897] plan(): nbrOfWorkers() = 1
[10:22:44.899] plan(): Setting new future strategy stack:
[10:22:44.899] List of future strategies:
[10:22:44.899] 1. multicore:
[10:22:44.899]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:44.899]    - tweaked: FALSE
[10:22:44.899]    - call: plan(strategy)
[10:22:44.904] plan(): nbrOfWorkers() = 2
[10:22:44.896] MulticoreFuture:
[10:22:44.896] Label: ‘future_apply-1’
[10:22:44.896] Expression:
[10:22:44.896] {
[10:22:44.896]     do.call(function(...) {
[10:22:44.896]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.896]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:44.896]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.896]             on.exit(options(oopts), add = TRUE)
[10:22:44.896]         }
[10:22:44.896]         {
[10:22:44.896]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:44.896]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.896]                 ...future.FUN(...future.X_jj, ...)
[10:22:44.896]             })
[10:22:44.896]         }
[10:22:44.896]     }, args = future.call.arguments)
[10:22:44.896] }
[10:22:44.896] Lazy evaluation: FALSE
[10:22:44.896] Asynchronous evaluation: TRUE
[10:22:44.896] Local evaluation: TRUE
[10:22:44.896] Environment: R_GlobalEnv
[10:22:44.896] Capture standard output: TRUE
[10:22:44.896] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:44.896] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:44.896] Packages: <none>
[10:22:44.896] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:44.896] Resolved: TRUE
[10:22:44.896] Value: <not collected>
[10:22:44.896] Conditions captured: <none>
[10:22:44.896] Early signaling: FALSE
[10:22:44.896] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:44.896] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:44.905] Chunk #1 of 2 ... DONE
[10:22:44.905] Chunk #2 of 2 ...
[10:22:44.906]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:44.906]  - seeds: <none>
[10:22:44.906]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.906] getGlobalsAndPackages() ...
[10:22:44.906] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.906] Resolving globals: FALSE
[10:22:44.907] Tweak future expression to call with '...' arguments ...
[10:22:44.907] {
[10:22:44.907]     do.call(function(...) {
[10:22:44.907]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.907]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:44.907]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.907]             on.exit(options(oopts), add = TRUE)
[10:22:44.907]         }
[10:22:44.907]         {
[10:22:44.907]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:44.907]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.907]                 ...future.FUN(...future.X_jj, ...)
[10:22:44.907]             })
[10:22:44.907]         }
[10:22:44.907]     }, args = future.call.arguments)
[10:22:44.907] }
[10:22:44.907] Tweak future expression to call with '...' arguments ... DONE
[10:22:44.908] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.908] 
[10:22:44.908] getGlobalsAndPackages() ... DONE
[10:22:44.909] run() for ‘Future’ ...
[10:22:44.909] - state: ‘created’
[10:22:44.909] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:44.914] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:44.914] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:44.914]   - Field: ‘label’
[10:22:44.914]   - Field: ‘local’
[10:22:44.914]   - Field: ‘owner’
[10:22:44.914]   - Field: ‘envir’
[10:22:44.915]   - Field: ‘workers’
[10:22:44.915]   - Field: ‘packages’
[10:22:44.915]   - Field: ‘gc’
[10:22:44.918]   - Field: ‘job’
[10:22:44.919]   - Field: ‘conditions’
[10:22:44.919]   - Field: ‘expr’
[10:22:44.919]   - Field: ‘uuid’
[10:22:44.920]   - Field: ‘seed’
[10:22:44.920]   - Field: ‘version’
[10:22:44.920]   - Field: ‘result’
[10:22:44.921]   - Field: ‘asynchronous’
[10:22:44.921]   - Field: ‘calls’
[10:22:44.921]   - Field: ‘globals’
[10:22:44.921]   - Field: ‘stdout’
[10:22:44.922]   - Field: ‘earlySignal’
[10:22:44.922]   - Field: ‘lazy’
[10:22:44.922]   - Field: ‘state’
[10:22:44.922] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:44.923] - Launch lazy future ...
[10:22:44.923] Packages needed by the future expression (n = 0): <none>
[10:22:44.924] Packages needed by future strategies (n = 0): <none>
[10:22:44.925] {
[10:22:44.925]     {
[10:22:44.925]         {
[10:22:44.925]             ...future.startTime <- base::Sys.time()
[10:22:44.925]             {
[10:22:44.925]                 {
[10:22:44.925]                   {
[10:22:44.925]                     {
[10:22:44.925]                       base::local({
[10:22:44.925]                         has_future <- base::requireNamespace("future", 
[10:22:44.925]                           quietly = TRUE)
[10:22:44.925]                         if (has_future) {
[10:22:44.925]                           ns <- base::getNamespace("future")
[10:22:44.925]                           version <- ns[[".package"]][["version"]]
[10:22:44.925]                           if (is.null(version)) 
[10:22:44.925]                             version <- utils::packageVersion("future")
[10:22:44.925]                         }
[10:22:44.925]                         else {
[10:22:44.925]                           version <- NULL
[10:22:44.925]                         }
[10:22:44.925]                         if (!has_future || version < "1.8.0") {
[10:22:44.925]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:44.925]                             "", base::R.version$version.string), 
[10:22:44.925]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:44.925]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:44.925]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:44.925]                               "release", "version")], collapse = " "), 
[10:22:44.925]                             hostname = base::Sys.info()[["nodename"]])
[10:22:44.925]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:44.925]                             info)
[10:22:44.925]                           info <- base::paste(info, collapse = "; ")
[10:22:44.925]                           if (!has_future) {
[10:22:44.925]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:44.925]                               info)
[10:22:44.925]                           }
[10:22:44.925]                           else {
[10:22:44.925]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:44.925]                               info, version)
[10:22:44.925]                           }
[10:22:44.925]                           base::stop(msg)
[10:22:44.925]                         }
[10:22:44.925]                       })
[10:22:44.925]                     }
[10:22:44.925]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:44.925]                     base::options(mc.cores = 1L)
[10:22:44.925]                   }
[10:22:44.925]                   options(future.plan = NULL)
[10:22:44.925]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.925]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:44.925]                 }
[10:22:44.925]                 ...future.workdir <- getwd()
[10:22:44.925]             }
[10:22:44.925]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:44.925]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:44.925]         }
[10:22:44.925]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:44.925]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:44.925]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:44.925]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:44.925]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:44.925]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:44.925]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:44.925]             base::names(...future.oldOptions))
[10:22:44.925]     }
[10:22:44.925]     if (FALSE) {
[10:22:44.925]     }
[10:22:44.925]     else {
[10:22:44.925]         if (TRUE) {
[10:22:44.925]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:44.925]                 open = "w")
[10:22:44.925]         }
[10:22:44.925]         else {
[10:22:44.925]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:44.925]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:44.925]         }
[10:22:44.925]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:44.925]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:44.925]             base::sink(type = "output", split = FALSE)
[10:22:44.925]             base::close(...future.stdout)
[10:22:44.925]         }, add = TRUE)
[10:22:44.925]     }
[10:22:44.925]     ...future.frame <- base::sys.nframe()
[10:22:44.925]     ...future.conditions <- base::list()
[10:22:44.925]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:44.925]     if (FALSE) {
[10:22:44.925]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:44.925]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:44.925]     }
[10:22:44.925]     ...future.result <- base::tryCatch({
[10:22:44.925]         base::withCallingHandlers({
[10:22:44.925]             ...future.value <- base::withVisible(base::local({
[10:22:44.925]                 withCallingHandlers({
[10:22:44.925]                   {
[10:22:44.925]                     do.call(function(...) {
[10:22:44.925]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.925]                       if (!identical(...future.globals.maxSize.org, 
[10:22:44.925]                         ...future.globals.maxSize)) {
[10:22:44.925]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.925]                         on.exit(options(oopts), add = TRUE)
[10:22:44.925]                       }
[10:22:44.925]                       {
[10:22:44.925]                         lapply(seq_along(...future.elements_ii), 
[10:22:44.925]                           FUN = function(jj) {
[10:22:44.925]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.925]                             ...future.FUN(...future.X_jj, ...)
[10:22:44.925]                           })
[10:22:44.925]                       }
[10:22:44.925]                     }, args = future.call.arguments)
[10:22:44.925]                   }
[10:22:44.925]                 }, immediateCondition = function(cond) {
[10:22:44.925]                   save_rds <- function (object, pathname, ...) 
[10:22:44.925]                   {
[10:22:44.925]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:44.925]                     if (file_test("-f", pathname_tmp)) {
[10:22:44.925]                       fi_tmp <- file.info(pathname_tmp)
[10:22:44.925]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:44.925]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:44.925]                         fi_tmp[["mtime"]])
[10:22:44.925]                     }
[10:22:44.925]                     tryCatch({
[10:22:44.925]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:44.925]                     }, error = function(ex) {
[10:22:44.925]                       msg <- conditionMessage(ex)
[10:22:44.925]                       fi_tmp <- file.info(pathname_tmp)
[10:22:44.925]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:44.925]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:44.925]                         fi_tmp[["mtime"]], msg)
[10:22:44.925]                       ex$message <- msg
[10:22:44.925]                       stop(ex)
[10:22:44.925]                     })
[10:22:44.925]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:44.925]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:44.925]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:44.925]                       fi_tmp <- file.info(pathname_tmp)
[10:22:44.925]                       fi <- file.info(pathname)
[10:22:44.925]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:44.925]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:44.925]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:44.925]                         fi[["size"]], fi[["mtime"]])
[10:22:44.925]                       stop(msg)
[10:22:44.925]                     }
[10:22:44.925]                     invisible(pathname)
[10:22:44.925]                   }
[10:22:44.925]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:44.925]                     rootPath = tempdir()) 
[10:22:44.925]                   {
[10:22:44.925]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:44.925]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:44.925]                       tmpdir = path, fileext = ".rds")
[10:22:44.925]                     save_rds(obj, file)
[10:22:44.925]                   }
[10:22:44.925]                   saveImmediateCondition(cond, path = "/tmp/RtmpTHXGJm/.future/immediateConditions")
[10:22:44.925]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.925]                   {
[10:22:44.925]                     inherits <- base::inherits
[10:22:44.925]                     invokeRestart <- base::invokeRestart
[10:22:44.925]                     is.null <- base::is.null
[10:22:44.925]                     muffled <- FALSE
[10:22:44.925]                     if (inherits(cond, "message")) {
[10:22:44.925]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:44.925]                       if (muffled) 
[10:22:44.925]                         invokeRestart("muffleMessage")
[10:22:44.925]                     }
[10:22:44.925]                     else if (inherits(cond, "warning")) {
[10:22:44.925]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:44.925]                       if (muffled) 
[10:22:44.925]                         invokeRestart("muffleWarning")
[10:22:44.925]                     }
[10:22:44.925]                     else if (inherits(cond, "condition")) {
[10:22:44.925]                       if (!is.null(pattern)) {
[10:22:44.925]                         computeRestarts <- base::computeRestarts
[10:22:44.925]                         grepl <- base::grepl
[10:22:44.925]                         restarts <- computeRestarts(cond)
[10:22:44.925]                         for (restart in restarts) {
[10:22:44.925]                           name <- restart$name
[10:22:44.925]                           if (is.null(name)) 
[10:22:44.925]                             next
[10:22:44.925]                           if (!grepl(pattern, name)) 
[10:22:44.925]                             next
[10:22:44.925]                           invokeRestart(restart)
[10:22:44.925]                           muffled <- TRUE
[10:22:44.925]                           break
[10:22:44.925]                         }
[10:22:44.925]                       }
[10:22:44.925]                     }
[10:22:44.925]                     invisible(muffled)
[10:22:44.925]                   }
[10:22:44.925]                   muffleCondition(cond)
[10:22:44.925]                 })
[10:22:44.925]             }))
[10:22:44.925]             future::FutureResult(value = ...future.value$value, 
[10:22:44.925]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.925]                   ...future.rng), globalenv = if (FALSE) 
[10:22:44.925]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:44.925]                     ...future.globalenv.names))
[10:22:44.925]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:44.925]         }, condition = base::local({
[10:22:44.925]             c <- base::c
[10:22:44.925]             inherits <- base::inherits
[10:22:44.925]             invokeRestart <- base::invokeRestart
[10:22:44.925]             length <- base::length
[10:22:44.925]             list <- base::list
[10:22:44.925]             seq.int <- base::seq.int
[10:22:44.925]             signalCondition <- base::signalCondition
[10:22:44.925]             sys.calls <- base::sys.calls
[10:22:44.925]             `[[` <- base::`[[`
[10:22:44.925]             `+` <- base::`+`
[10:22:44.925]             `<<-` <- base::`<<-`
[10:22:44.925]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:44.925]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:44.925]                   3L)]
[10:22:44.925]             }
[10:22:44.925]             function(cond) {
[10:22:44.925]                 is_error <- inherits(cond, "error")
[10:22:44.925]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:44.925]                   NULL)
[10:22:44.925]                 if (is_error) {
[10:22:44.925]                   sessionInformation <- function() {
[10:22:44.925]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:44.925]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:44.925]                       search = base::search(), system = base::Sys.info())
[10:22:44.925]                   }
[10:22:44.925]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.925]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:44.925]                     cond$call), session = sessionInformation(), 
[10:22:44.925]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:44.925]                   signalCondition(cond)
[10:22:44.925]                 }
[10:22:44.925]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:44.925]                 "immediateCondition"))) {
[10:22:44.925]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:44.925]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.925]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:44.925]                   if (TRUE && !signal) {
[10:22:44.925]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.925]                     {
[10:22:44.925]                       inherits <- base::inherits
[10:22:44.925]                       invokeRestart <- base::invokeRestart
[10:22:44.925]                       is.null <- base::is.null
[10:22:44.925]                       muffled <- FALSE
[10:22:44.925]                       if (inherits(cond, "message")) {
[10:22:44.925]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.925]                         if (muffled) 
[10:22:44.925]                           invokeRestart("muffleMessage")
[10:22:44.925]                       }
[10:22:44.925]                       else if (inherits(cond, "warning")) {
[10:22:44.925]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.925]                         if (muffled) 
[10:22:44.925]                           invokeRestart("muffleWarning")
[10:22:44.925]                       }
[10:22:44.925]                       else if (inherits(cond, "condition")) {
[10:22:44.925]                         if (!is.null(pattern)) {
[10:22:44.925]                           computeRestarts <- base::computeRestarts
[10:22:44.925]                           grepl <- base::grepl
[10:22:44.925]                           restarts <- computeRestarts(cond)
[10:22:44.925]                           for (restart in restarts) {
[10:22:44.925]                             name <- restart$name
[10:22:44.925]                             if (is.null(name)) 
[10:22:44.925]                               next
[10:22:44.925]                             if (!grepl(pattern, name)) 
[10:22:44.925]                               next
[10:22:44.925]                             invokeRestart(restart)
[10:22:44.925]                             muffled <- TRUE
[10:22:44.925]                             break
[10:22:44.925]                           }
[10:22:44.925]                         }
[10:22:44.925]                       }
[10:22:44.925]                       invisible(muffled)
[10:22:44.925]                     }
[10:22:44.925]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.925]                   }
[10:22:44.925]                 }
[10:22:44.925]                 else {
[10:22:44.925]                   if (TRUE) {
[10:22:44.925]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.925]                     {
[10:22:44.925]                       inherits <- base::inherits
[10:22:44.925]                       invokeRestart <- base::invokeRestart
[10:22:44.925]                       is.null <- base::is.null
[10:22:44.925]                       muffled <- FALSE
[10:22:44.925]                       if (inherits(cond, "message")) {
[10:22:44.925]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.925]                         if (muffled) 
[10:22:44.925]                           invokeRestart("muffleMessage")
[10:22:44.925]                       }
[10:22:44.925]                       else if (inherits(cond, "warning")) {
[10:22:44.925]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.925]                         if (muffled) 
[10:22:44.925]                           invokeRestart("muffleWarning")
[10:22:44.925]                       }
[10:22:44.925]                       else if (inherits(cond, "condition")) {
[10:22:44.925]                         if (!is.null(pattern)) {
[10:22:44.925]                           computeRestarts <- base::computeRestarts
[10:22:44.925]                           grepl <- base::grepl
[10:22:44.925]                           restarts <- computeRestarts(cond)
[10:22:44.925]                           for (restart in restarts) {
[10:22:44.925]                             name <- restart$name
[10:22:44.925]                             if (is.null(name)) 
[10:22:44.925]                               next
[10:22:44.925]                             if (!grepl(pattern, name)) 
[10:22:44.925]                               next
[10:22:44.925]                             invokeRestart(restart)
[10:22:44.925]                             muffled <- TRUE
[10:22:44.925]                             break
[10:22:44.925]                           }
[10:22:44.925]                         }
[10:22:44.925]                       }
[10:22:44.925]                       invisible(muffled)
[10:22:44.925]                     }
[10:22:44.925]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.925]                   }
[10:22:44.925]                 }
[10:22:44.925]             }
[10:22:44.925]         }))
[10:22:44.925]     }, error = function(ex) {
[10:22:44.925]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:44.925]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.925]                 ...future.rng), started = ...future.startTime, 
[10:22:44.925]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:44.925]             version = "1.8"), class = "FutureResult")
[10:22:44.925]     }, finally = {
[10:22:44.925]         if (!identical(...future.workdir, getwd())) 
[10:22:44.925]             setwd(...future.workdir)
[10:22:44.925]         {
[10:22:44.925]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:44.925]                 ...future.oldOptions$nwarnings <- NULL
[10:22:44.925]             }
[10:22:44.925]             base::options(...future.oldOptions)
[10:22:44.925]             if (.Platform$OS.type == "windows") {
[10:22:44.925]                 old_names <- names(...future.oldEnvVars)
[10:22:44.925]                 envs <- base::Sys.getenv()
[10:22:44.925]                 names <- names(envs)
[10:22:44.925]                 common <- intersect(names, old_names)
[10:22:44.925]                 added <- setdiff(names, old_names)
[10:22:44.925]                 removed <- setdiff(old_names, names)
[10:22:44.925]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:44.925]                   envs[common]]
[10:22:44.925]                 NAMES <- toupper(changed)
[10:22:44.925]                 args <- list()
[10:22:44.925]                 for (kk in seq_along(NAMES)) {
[10:22:44.925]                   name <- changed[[kk]]
[10:22:44.925]                   NAME <- NAMES[[kk]]
[10:22:44.925]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.925]                     next
[10:22:44.925]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.925]                 }
[10:22:44.925]                 NAMES <- toupper(added)
[10:22:44.925]                 for (kk in seq_along(NAMES)) {
[10:22:44.925]                   name <- added[[kk]]
[10:22:44.925]                   NAME <- NAMES[[kk]]
[10:22:44.925]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.925]                     next
[10:22:44.925]                   args[[name]] <- ""
[10:22:44.925]                 }
[10:22:44.925]                 NAMES <- toupper(removed)
[10:22:44.925]                 for (kk in seq_along(NAMES)) {
[10:22:44.925]                   name <- removed[[kk]]
[10:22:44.925]                   NAME <- NAMES[[kk]]
[10:22:44.925]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.925]                     next
[10:22:44.925]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.925]                 }
[10:22:44.925]                 if (length(args) > 0) 
[10:22:44.925]                   base::do.call(base::Sys.setenv, args = args)
[10:22:44.925]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:44.925]             }
[10:22:44.925]             else {
[10:22:44.925]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:44.925]             }
[10:22:44.925]             {
[10:22:44.925]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:44.925]                   0L) {
[10:22:44.925]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:44.925]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:44.925]                   base::options(opts)
[10:22:44.925]                 }
[10:22:44.925]                 {
[10:22:44.925]                   {
[10:22:44.925]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:44.925]                     NULL
[10:22:44.925]                   }
[10:22:44.925]                   options(future.plan = NULL)
[10:22:44.925]                   if (is.na(NA_character_)) 
[10:22:44.925]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.925]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:44.925]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:44.925]                     envir = parent.frame()) 
[10:22:44.925]                   {
[10:22:44.925]                     default_workers <- missing(workers)
[10:22:44.925]                     if (is.function(workers)) 
[10:22:44.925]                       workers <- workers()
[10:22:44.925]                     workers <- structure(as.integer(workers), 
[10:22:44.925]                       class = class(workers))
[10:22:44.925]                     stop_if_not(is.finite(workers), workers >= 
[10:22:44.925]                       1L)
[10:22:44.925]                     if ((workers == 1L && !inherits(workers, 
[10:22:44.925]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:44.925]                       if (default_workers) 
[10:22:44.925]                         supportsMulticore(warn = TRUE)
[10:22:44.925]                       return(sequential(..., envir = envir))
[10:22:44.925]                     }
[10:22:44.925]                     oopts <- options(mc.cores = workers)
[10:22:44.925]                     on.exit(options(oopts))
[10:22:44.925]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:44.925]                       envir = envir)
[10:22:44.925]                     if (!future$lazy) 
[10:22:44.925]                       future <- run(future)
[10:22:44.925]                     invisible(future)
[10:22:44.925]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:44.925]                 }
[10:22:44.925]             }
[10:22:44.925]         }
[10:22:44.925]     })
[10:22:44.925]     if (TRUE) {
[10:22:44.925]         base::sink(type = "output", split = FALSE)
[10:22:44.925]         if (TRUE) {
[10:22:44.925]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:44.925]         }
[10:22:44.925]         else {
[10:22:44.925]             ...future.result["stdout"] <- base::list(NULL)
[10:22:44.925]         }
[10:22:44.925]         base::close(...future.stdout)
[10:22:44.925]         ...future.stdout <- NULL
[10:22:44.925]     }
[10:22:44.925]     ...future.result$conditions <- ...future.conditions
[10:22:44.925]     ...future.result$finished <- base::Sys.time()
[10:22:44.925]     ...future.result
[10:22:44.925] }
[10:22:44.928] assign_globals() ...
[10:22:44.928] List of 5
[10:22:44.928]  $ future.call.arguments    : list()
[10:22:44.928]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.928]  $ ...future.FUN            :function (x)  
[10:22:44.928]  $ ...future.elements_ii    :List of 3
[10:22:44.928]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[10:22:44.928]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[10:22:44.928]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[10:22:44.928]  $ ...future.seeds_ii       : NULL
[10:22:44.928]  $ ...future.globals.maxSize: num Inf
[10:22:44.928]  - attr(*, "resolved")= logi FALSE
[10:22:44.928]  - attr(*, "total_size")= num NA
[10:22:44.928]  - attr(*, "where")=List of 5
[10:22:44.928]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:44.928]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:44.928]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:44.928]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:44.928]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:44.928]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.928]  - attr(*, "already-done")= logi TRUE
[10:22:44.936] - copied ‘future.call.arguments’ to environment
[10:22:44.937] - copied ‘...future.FUN’ to environment
[10:22:44.937] - copied ‘...future.elements_ii’ to environment
[10:22:44.937] - copied ‘...future.seeds_ii’ to environment
[10:22:44.937] - copied ‘...future.globals.maxSize’ to environment
[10:22:44.937] assign_globals() ... done
[10:22:44.937] requestCore(): workers = 2
[10:22:44.939] MulticoreFuture started
[10:22:44.940] - Launch lazy future ... done
[10:22:44.940] run() for ‘MulticoreFuture’ ... done
[10:22:44.940] Created future:
[10:22:44.940] plan(): Setting new future strategy stack:
[10:22:44.941] List of future strategies:
[10:22:44.941] 1. sequential:
[10:22:44.941]    - args: function (..., envir = parent.frame())
[10:22:44.941]    - tweaked: FALSE
[10:22:44.941]    - call: NULL
[10:22:44.941] plan(): nbrOfWorkers() = 1
[10:22:44.943] plan(): Setting new future strategy stack:
[10:22:44.943] List of future strategies:
[10:22:44.943] 1. multicore:
[10:22:44.943]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:44.943]    - tweaked: FALSE
[10:22:44.943]    - call: plan(strategy)
[10:22:44.948] plan(): nbrOfWorkers() = 2
[10:22:44.940] MulticoreFuture:
[10:22:44.940] Label: ‘future_apply-2’
[10:22:44.940] Expression:
[10:22:44.940] {
[10:22:44.940]     do.call(function(...) {
[10:22:44.940]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.940]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:44.940]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.940]             on.exit(options(oopts), add = TRUE)
[10:22:44.940]         }
[10:22:44.940]         {
[10:22:44.940]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:44.940]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.940]                 ...future.FUN(...future.X_jj, ...)
[10:22:44.940]             })
[10:22:44.940]         }
[10:22:44.940]     }, args = future.call.arguments)
[10:22:44.940] }
[10:22:44.940] Lazy evaluation: FALSE
[10:22:44.940] Asynchronous evaluation: TRUE
[10:22:44.940] Local evaluation: TRUE
[10:22:44.940] Environment: R_GlobalEnv
[10:22:44.940] Capture standard output: TRUE
[10:22:44.940] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:44.940] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:44.940] Packages: <none>
[10:22:44.940] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:44.940] Resolved: TRUE
[10:22:44.940] Value: <not collected>
[10:22:44.940] Conditions captured: <none>
[10:22:44.940] Early signaling: FALSE
[10:22:44.940] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:44.940] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:44.950] Chunk #2 of 2 ... DONE
[10:22:44.950] Launching 2 futures (chunks) ... DONE
[10:22:44.950] Resolving 2 futures (chunks) ...
[10:22:44.950] resolve() on list ...
[10:22:44.950]  recursive: 0
[10:22:44.951]  length: 2
[10:22:44.951] 
[10:22:44.951] Future #1
[10:22:44.951] result() for MulticoreFuture ...
[10:22:44.952] result() for MulticoreFuture ...
[10:22:44.952] result() for MulticoreFuture ... done
[10:22:44.952] result() for MulticoreFuture ... done
[10:22:44.953] result() for MulticoreFuture ...
[10:22:44.953] result() for MulticoreFuture ... done
[10:22:44.953] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:22:44.953] - nx: 2
[10:22:44.953] - relay: TRUE
[10:22:44.953] - stdout: TRUE
[10:22:44.954] - signal: TRUE
[10:22:44.954] - resignal: FALSE
[10:22:44.954] - force: TRUE
[10:22:44.954] - relayed: [n=2] FALSE, FALSE
[10:22:44.954] - queued futures: [n=2] FALSE, FALSE
[10:22:44.954]  - until=1
[10:22:44.955]  - relaying element #1
[10:22:44.955] result() for MulticoreFuture ...
[10:22:44.955] result() for MulticoreFuture ... done
[10:22:44.955] result() for MulticoreFuture ...
[10:22:44.955] result() for MulticoreFuture ... done
[10:22:44.955] result() for MulticoreFuture ...
[10:22:44.956] result() for MulticoreFuture ... done
[10:22:44.956] result() for MulticoreFuture ...
[10:22:44.956] result() for MulticoreFuture ... done
[10:22:44.956] - relayed: [n=2] TRUE, FALSE
[10:22:44.956] - queued futures: [n=2] TRUE, FALSE
[10:22:44.956] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:22:44.957]  length: 1 (resolved future 1)
[10:22:44.957] Future #2
[10:22:44.957] result() for MulticoreFuture ...
[10:22:44.958] result() for MulticoreFuture ...
[10:22:44.958] result() for MulticoreFuture ... done
[10:22:44.958] result() for MulticoreFuture ... done
[10:22:44.958] result() for MulticoreFuture ...
[10:22:44.958] result() for MulticoreFuture ... done
[10:22:44.958] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:22:44.959] - nx: 2
[10:22:44.959] - relay: TRUE
[10:22:44.959] - stdout: TRUE
[10:22:44.959] - signal: TRUE
[10:22:44.959] - resignal: FALSE
[10:22:44.959] - force: TRUE
[10:22:44.959] - relayed: [n=2] TRUE, FALSE
[10:22:44.959] - queued futures: [n=2] TRUE, FALSE
[10:22:44.960]  - until=2
[10:22:44.960]  - relaying element #2
[10:22:44.960] result() for MulticoreFuture ...
[10:22:44.960] result() for MulticoreFuture ... done
[10:22:44.960] result() for MulticoreFuture ...
[10:22:44.960] result() for MulticoreFuture ... done
[10:22:44.960] result() for MulticoreFuture ...
[10:22:44.960] result() for MulticoreFuture ... done
[10:22:44.961] result() for MulticoreFuture ...
[10:22:44.961] result() for MulticoreFuture ... done
[10:22:44.961] - relayed: [n=2] TRUE, TRUE
[10:22:44.961] - queued futures: [n=2] TRUE, TRUE
[10:22:44.961] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:22:44.961]  length: 0 (resolved future 2)
[10:22:44.961] Relaying remaining futures
[10:22:44.961] signalConditionsASAP(NULL, pos=0) ...
[10:22:44.961] - nx: 2
[10:22:44.962] - relay: TRUE
[10:22:44.962] - stdout: TRUE
[10:22:44.962] - signal: TRUE
[10:22:44.962] - resignal: FALSE
[10:22:44.962] - force: TRUE
[10:22:44.962] - relayed: [n=2] TRUE, TRUE
[10:22:44.962] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:22:44.962] - relayed: [n=2] TRUE, TRUE
[10:22:44.962] - queued futures: [n=2] TRUE, TRUE
[10:22:44.963] signalConditionsASAP(NULL, pos=0) ... done
[10:22:44.963] resolve() on list ... DONE
[10:22:44.963] result() for MulticoreFuture ...
[10:22:44.963] result() for MulticoreFuture ... done
[10:22:44.965] result() for MulticoreFuture ...
[10:22:44.966] result() for MulticoreFuture ... done
[10:22:44.966] result() for MulticoreFuture ...
[10:22:44.966] result() for MulticoreFuture ... done
[10:22:44.966] result() for MulticoreFuture ...
[10:22:44.966] result() for MulticoreFuture ... done
[10:22:44.967]  - Number of value chunks collected: 2
[10:22:44.967] Resolving 2 futures (chunks) ... DONE
[10:22:44.967] Reducing values from 2 chunks ...
[10:22:44.967]  - Number of values collected after concatenation: 6
[10:22:44.967]  - Number of values expected: 6
[10:22:44.967] Reducing values from 2 chunks ... DONE
[10:22:44.968] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[10:22:44.968] getGlobalsAndPackagesXApply() ...
[10:22:44.968]  - future.globals: TRUE
[10:22:44.969] getGlobalsAndPackages() ...
[10:22:44.969] Searching for globals...
[10:22:44.971] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[10:22:44.971] Searching for globals ... DONE
[10:22:44.971] Resolving globals: FALSE
[10:22:44.972] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[10:22:44.972] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[10:22:44.972] - globals: [1] ‘FUN’
[10:22:44.972] 
[10:22:44.972] getGlobalsAndPackages() ... DONE
[10:22:44.973]  - globals found/used: [n=1] ‘FUN’
[10:22:44.973]  - needed namespaces: [n=0] 
[10:22:44.973] Finding globals ... DONE
[10:22:44.973]  - use_args: TRUE
[10:22:44.973]  - Getting '...' globals ...
[10:22:44.973] resolve() on list ...
[10:22:44.974]  recursive: 0
[10:22:44.974]  length: 1
[10:22:44.974]  elements: ‘...’
[10:22:44.974]  length: 0 (resolved future 1)
[10:22:44.974] resolve() on list ... DONE
[10:22:44.974]    - '...' content: [n=0] 
[10:22:44.974] List of 1
[10:22:44.974]  $ ...: list()
[10:22:44.974]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.974]  - attr(*, "where")=List of 1
[10:22:44.974]   ..$ ...:<environment: 0x55ca4d009dc0> 
[10:22:44.974]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.974]  - attr(*, "resolved")= logi TRUE
[10:22:44.974]  - attr(*, "total_size")= num NA
[10:22:44.977]  - Getting '...' globals ... DONE
[10:22:44.978] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:44.978] List of 2
[10:22:44.978]  $ ...future.FUN:function (x)  
[10:22:44.978]  $ ...          : list()
[10:22:44.978]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.978]  - attr(*, "where")=List of 2
[10:22:44.978]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:44.978]   ..$ ...          :<environment: 0x55ca4d009dc0> 
[10:22:44.978]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.978]  - attr(*, "resolved")= logi FALSE
[10:22:44.978]  - attr(*, "total_size")= num 1768
[10:22:44.981] Packages to be attached in all futures: [n=0] 
[10:22:44.981] getGlobalsAndPackagesXApply() ... DONE
[10:22:44.984] future_lapply() ...
[10:22:44.988] Number of chunks: 2
[10:22:44.988] getGlobalsAndPackagesXApply() ...
[10:22:44.988]  - future.globals: <name-value list> with names ‘list()’
[10:22:44.989]  - use_args: TRUE
[10:22:44.989] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:22:44.989] List of 2
[10:22:44.989]  $ ...          : list()
[10:22:44.989]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:44.989]  $ ...future.FUN:function (x)  
[10:22:44.989]  - attr(*, "where")=List of 2
[10:22:44.989]   ..$ ...          :<environment: 0x55ca4d009dc0> 
[10:22:44.989]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[10:22:44.989]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:44.989]  - attr(*, "resolved")= logi FALSE
[10:22:44.989]  - attr(*, "total_size")= num NA
[10:22:44.992] Packages to be attached in all futures: [n=0] 
[10:22:44.992] getGlobalsAndPackagesXApply() ... DONE
[10:22:44.992] Number of futures (= number of chunks): 2
[10:22:44.992] Launching 2 futures (chunks) ...
[10:22:44.992] Chunk #1 of 2 ...
[10:22:44.992]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:44.992]  - seeds: <none>
[10:22:44.993]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.993] getGlobalsAndPackages() ...
[10:22:44.993] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.993] Resolving globals: FALSE
[10:22:44.993] Tweak future expression to call with '...' arguments ...
[10:22:44.993] {
[10:22:44.993]     do.call(function(...) {
[10:22:44.993]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:44.993]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:44.993]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:44.993]             on.exit(options(oopts), add = TRUE)
[10:22:44.993]         }
[10:22:44.993]         {
[10:22:44.993]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:44.993]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:44.993]                 ...future.FUN(...future.X_jj, ...)
[10:22:44.993]             })
[10:22:44.993]         }
[10:22:44.993]     }, args = future.call.arguments)
[10:22:44.993] }
[10:22:44.993] Tweak future expression to call with '...' arguments ... DONE
[10:22:44.995] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:44.996] 
[10:22:44.996] getGlobalsAndPackages() ... DONE
[10:22:44.996] run() for ‘Future’ ...
[10:22:44.996] - state: ‘created’
[10:22:44.996] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:45.000] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:45.000] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:45.000]   - Field: ‘label’
[10:22:45.000]   - Field: ‘local’
[10:22:45.000]   - Field: ‘owner’
[10:22:45.000]   - Field: ‘envir’
[10:22:45.001]   - Field: ‘workers’
[10:22:45.001]   - Field: ‘packages’
[10:22:45.001]   - Field: ‘gc’
[10:22:45.001]   - Field: ‘job’
[10:22:45.001]   - Field: ‘conditions’
[10:22:45.001]   - Field: ‘expr’
[10:22:45.001]   - Field: ‘uuid’
[10:22:45.001]   - Field: ‘seed’
[10:22:45.001]   - Field: ‘version’
[10:22:45.002]   - Field: ‘result’
[10:22:45.002]   - Field: ‘asynchronous’
[10:22:45.002]   - Field: ‘calls’
[10:22:45.002]   - Field: ‘globals’
[10:22:45.002]   - Field: ‘stdout’
[10:22:45.002]   - Field: ‘earlySignal’
[10:22:45.002]   - Field: ‘lazy’
[10:22:45.002]   - Field: ‘state’
[10:22:45.002] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:45.002] - Launch lazy future ...
[10:22:45.003] Packages needed by the future expression (n = 0): <none>
[10:22:45.003] Packages needed by future strategies (n = 0): <none>
[10:22:45.003] {
[10:22:45.003]     {
[10:22:45.003]         {
[10:22:45.003]             ...future.startTime <- base::Sys.time()
[10:22:45.003]             {
[10:22:45.003]                 {
[10:22:45.003]                   {
[10:22:45.003]                     {
[10:22:45.003]                       base::local({
[10:22:45.003]                         has_future <- base::requireNamespace("future", 
[10:22:45.003]                           quietly = TRUE)
[10:22:45.003]                         if (has_future) {
[10:22:45.003]                           ns <- base::getNamespace("future")
[10:22:45.003]                           version <- ns[[".package"]][["version"]]
[10:22:45.003]                           if (is.null(version)) 
[10:22:45.003]                             version <- utils::packageVersion("future")
[10:22:45.003]                         }
[10:22:45.003]                         else {
[10:22:45.003]                           version <- NULL
[10:22:45.003]                         }
[10:22:45.003]                         if (!has_future || version < "1.8.0") {
[10:22:45.003]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:45.003]                             "", base::R.version$version.string), 
[10:22:45.003]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:45.003]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:45.003]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:45.003]                               "release", "version")], collapse = " "), 
[10:22:45.003]                             hostname = base::Sys.info()[["nodename"]])
[10:22:45.003]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:45.003]                             info)
[10:22:45.003]                           info <- base::paste(info, collapse = "; ")
[10:22:45.003]                           if (!has_future) {
[10:22:45.003]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:45.003]                               info)
[10:22:45.003]                           }
[10:22:45.003]                           else {
[10:22:45.003]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:45.003]                               info, version)
[10:22:45.003]                           }
[10:22:45.003]                           base::stop(msg)
[10:22:45.003]                         }
[10:22:45.003]                       })
[10:22:45.003]                     }
[10:22:45.003]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:45.003]                     base::options(mc.cores = 1L)
[10:22:45.003]                   }
[10:22:45.003]                   options(future.plan = NULL)
[10:22:45.003]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:45.003]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:45.003]                 }
[10:22:45.003]                 ...future.workdir <- getwd()
[10:22:45.003]             }
[10:22:45.003]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:45.003]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:45.003]         }
[10:22:45.003]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:45.003]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:45.003]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:45.003]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:45.003]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:45.003]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:45.003]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:45.003]             base::names(...future.oldOptions))
[10:22:45.003]     }
[10:22:45.003]     if (FALSE) {
[10:22:45.003]     }
[10:22:45.003]     else {
[10:22:45.003]         if (TRUE) {
[10:22:45.003]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:45.003]                 open = "w")
[10:22:45.003]         }
[10:22:45.003]         else {
[10:22:45.003]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:45.003]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:45.003]         }
[10:22:45.003]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:45.003]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:45.003]             base::sink(type = "output", split = FALSE)
[10:22:45.003]             base::close(...future.stdout)
[10:22:45.003]         }, add = TRUE)
[10:22:45.003]     }
[10:22:45.003]     ...future.frame <- base::sys.nframe()
[10:22:45.003]     ...future.conditions <- base::list()
[10:22:45.003]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:45.003]     if (FALSE) {
[10:22:45.003]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:45.003]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:45.003]     }
[10:22:45.003]     ...future.result <- base::tryCatch({
[10:22:45.003]         base::withCallingHandlers({
[10:22:45.003]             ...future.value <- base::withVisible(base::local({
[10:22:45.003]                 withCallingHandlers({
[10:22:45.003]                   {
[10:22:45.003]                     do.call(function(...) {
[10:22:45.003]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:45.003]                       if (!identical(...future.globals.maxSize.org, 
[10:22:45.003]                         ...future.globals.maxSize)) {
[10:22:45.003]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:45.003]                         on.exit(options(oopts), add = TRUE)
[10:22:45.003]                       }
[10:22:45.003]                       {
[10:22:45.003]                         lapply(seq_along(...future.elements_ii), 
[10:22:45.003]                           FUN = function(jj) {
[10:22:45.003]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:45.003]                             ...future.FUN(...future.X_jj, ...)
[10:22:45.003]                           })
[10:22:45.003]                       }
[10:22:45.003]                     }, args = future.call.arguments)
[10:22:45.003]                   }
[10:22:45.003]                 }, immediateCondition = function(cond) {
[10:22:45.003]                   save_rds <- function (object, pathname, ...) 
[10:22:45.003]                   {
[10:22:45.003]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:45.003]                     if (file_test("-f", pathname_tmp)) {
[10:22:45.003]                       fi_tmp <- file.info(pathname_tmp)
[10:22:45.003]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:45.003]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:45.003]                         fi_tmp[["mtime"]])
[10:22:45.003]                     }
[10:22:45.003]                     tryCatch({
[10:22:45.003]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:45.003]                     }, error = function(ex) {
[10:22:45.003]                       msg <- conditionMessage(ex)
[10:22:45.003]                       fi_tmp <- file.info(pathname_tmp)
[10:22:45.003]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:45.003]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:45.003]                         fi_tmp[["mtime"]], msg)
[10:22:45.003]                       ex$message <- msg
[10:22:45.003]                       stop(ex)
[10:22:45.003]                     })
[10:22:45.003]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:45.003]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:45.003]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:45.003]                       fi_tmp <- file.info(pathname_tmp)
[10:22:45.003]                       fi <- file.info(pathname)
[10:22:45.003]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:45.003]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:45.003]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:45.003]                         fi[["size"]], fi[["mtime"]])
[10:22:45.003]                       stop(msg)
[10:22:45.003]                     }
[10:22:45.003]                     invisible(pathname)
[10:22:45.003]                   }
[10:22:45.003]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:45.003]                     rootPath = tempdir()) 
[10:22:45.003]                   {
[10:22:45.003]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:45.003]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:45.003]                       tmpdir = path, fileext = ".rds")
[10:22:45.003]                     save_rds(obj, file)
[10:22:45.003]                   }
[10:22:45.003]                   saveImmediateCondition(cond, path = "/tmp/RtmpTHXGJm/.future/immediateConditions")
[10:22:45.003]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.003]                   {
[10:22:45.003]                     inherits <- base::inherits
[10:22:45.003]                     invokeRestart <- base::invokeRestart
[10:22:45.003]                     is.null <- base::is.null
[10:22:45.003]                     muffled <- FALSE
[10:22:45.003]                     if (inherits(cond, "message")) {
[10:22:45.003]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:45.003]                       if (muffled) 
[10:22:45.003]                         invokeRestart("muffleMessage")
[10:22:45.003]                     }
[10:22:45.003]                     else if (inherits(cond, "warning")) {
[10:22:45.003]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:45.003]                       if (muffled) 
[10:22:45.003]                         invokeRestart("muffleWarning")
[10:22:45.003]                     }
[10:22:45.003]                     else if (inherits(cond, "condition")) {
[10:22:45.003]                       if (!is.null(pattern)) {
[10:22:45.003]                         computeRestarts <- base::computeRestarts
[10:22:45.003]                         grepl <- base::grepl
[10:22:45.003]                         restarts <- computeRestarts(cond)
[10:22:45.003]                         for (restart in restarts) {
[10:22:45.003]                           name <- restart$name
[10:22:45.003]                           if (is.null(name)) 
[10:22:45.003]                             next
[10:22:45.003]                           if (!grepl(pattern, name)) 
[10:22:45.003]                             next
[10:22:45.003]                           invokeRestart(restart)
[10:22:45.003]                           muffled <- TRUE
[10:22:45.003]                           break
[10:22:45.003]                         }
[10:22:45.003]                       }
[10:22:45.003]                     }
[10:22:45.003]                     invisible(muffled)
[10:22:45.003]                   }
[10:22:45.003]                   muffleCondition(cond)
[10:22:45.003]                 })
[10:22:45.003]             }))
[10:22:45.003]             future::FutureResult(value = ...future.value$value, 
[10:22:45.003]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:45.003]                   ...future.rng), globalenv = if (FALSE) 
[10:22:45.003]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:45.003]                     ...future.globalenv.names))
[10:22:45.003]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:45.003]         }, condition = base::local({
[10:22:45.003]             c <- base::c
[10:22:45.003]             inherits <- base::inherits
[10:22:45.003]             invokeRestart <- base::invokeRestart
[10:22:45.003]             length <- base::length
[10:22:45.003]             list <- base::list
[10:22:45.003]             seq.int <- base::seq.int
[10:22:45.003]             signalCondition <- base::signalCondition
[10:22:45.003]             sys.calls <- base::sys.calls
[10:22:45.003]             `[[` <- base::`[[`
[10:22:45.003]             `+` <- base::`+`
[10:22:45.003]             `<<-` <- base::`<<-`
[10:22:45.003]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:45.003]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:45.003]                   3L)]
[10:22:45.003]             }
[10:22:45.003]             function(cond) {
[10:22:45.003]                 is_error <- inherits(cond, "error")
[10:22:45.003]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:45.003]                   NULL)
[10:22:45.003]                 if (is_error) {
[10:22:45.003]                   sessionInformation <- function() {
[10:22:45.003]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:45.003]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:45.003]                       search = base::search(), system = base::Sys.info())
[10:22:45.003]                   }
[10:22:45.003]                   ...future.conditions[[length(...future.conditions) + 
[10:22:45.003]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:45.003]                     cond$call), session = sessionInformation(), 
[10:22:45.003]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:45.003]                   signalCondition(cond)
[10:22:45.003]                 }
[10:22:45.003]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:45.003]                 "immediateCondition"))) {
[10:22:45.003]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:45.003]                   ...future.conditions[[length(...future.conditions) + 
[10:22:45.003]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:45.003]                   if (TRUE && !signal) {
[10:22:45.003]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.003]                     {
[10:22:45.003]                       inherits <- base::inherits
[10:22:45.003]                       invokeRestart <- base::invokeRestart
[10:22:45.003]                       is.null <- base::is.null
[10:22:45.003]                       muffled <- FALSE
[10:22:45.003]                       if (inherits(cond, "message")) {
[10:22:45.003]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:45.003]                         if (muffled) 
[10:22:45.003]                           invokeRestart("muffleMessage")
[10:22:45.003]                       }
[10:22:45.003]                       else if (inherits(cond, "warning")) {
[10:22:45.003]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:45.003]                         if (muffled) 
[10:22:45.003]                           invokeRestart("muffleWarning")
[10:22:45.003]                       }
[10:22:45.003]                       else if (inherits(cond, "condition")) {
[10:22:45.003]                         if (!is.null(pattern)) {
[10:22:45.003]                           computeRestarts <- base::computeRestarts
[10:22:45.003]                           grepl <- base::grepl
[10:22:45.003]                           restarts <- computeRestarts(cond)
[10:22:45.003]                           for (restart in restarts) {
[10:22:45.003]                             name <- restart$name
[10:22:45.003]                             if (is.null(name)) 
[10:22:45.003]                               next
[10:22:45.003]                             if (!grepl(pattern, name)) 
[10:22:45.003]                               next
[10:22:45.003]                             invokeRestart(restart)
[10:22:45.003]                             muffled <- TRUE
[10:22:45.003]                             break
[10:22:45.003]                           }
[10:22:45.003]                         }
[10:22:45.003]                       }
[10:22:45.003]                       invisible(muffled)
[10:22:45.003]                     }
[10:22:45.003]                     muffleCondition(cond, pattern = "^muffle")
[10:22:45.003]                   }
[10:22:45.003]                 }
[10:22:45.003]                 else {
[10:22:45.003]                   if (TRUE) {
[10:22:45.003]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.003]                     {
[10:22:45.003]                       inherits <- base::inherits
[10:22:45.003]                       invokeRestart <- base::invokeRestart
[10:22:45.003]                       is.null <- base::is.null
[10:22:45.003]                       muffled <- FALSE
[10:22:45.003]                       if (inherits(cond, "message")) {
[10:22:45.003]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:45.003]                         if (muffled) 
[10:22:45.003]                           invokeRestart("muffleMessage")
[10:22:45.003]                       }
[10:22:45.003]                       else if (inherits(cond, "warning")) {
[10:22:45.003]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:45.003]                         if (muffled) 
[10:22:45.003]                           invokeRestart("muffleWarning")
[10:22:45.003]                       }
[10:22:45.003]                       else if (inherits(cond, "condition")) {
[10:22:45.003]                         if (!is.null(pattern)) {
[10:22:45.003]                           computeRestarts <- base::computeRestarts
[10:22:45.003]                           grepl <- base::grepl
[10:22:45.003]                           restarts <- computeRestarts(cond)
[10:22:45.003]                           for (restart in restarts) {
[10:22:45.003]                             name <- restart$name
[10:22:45.003]                             if (is.null(name)) 
[10:22:45.003]                               next
[10:22:45.003]                             if (!grepl(pattern, name)) 
[10:22:45.003]                               next
[10:22:45.003]                             invokeRestart(restart)
[10:22:45.003]                             muffled <- TRUE
[10:22:45.003]                             break
[10:22:45.003]                           }
[10:22:45.003]                         }
[10:22:45.003]                       }
[10:22:45.003]                       invisible(muffled)
[10:22:45.003]                     }
[10:22:45.003]                     muffleCondition(cond, pattern = "^muffle")
[10:22:45.003]                   }
[10:22:45.003]                 }
[10:22:45.003]             }
[10:22:45.003]         }))
[10:22:45.003]     }, error = function(ex) {
[10:22:45.003]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:45.003]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:45.003]                 ...future.rng), started = ...future.startTime, 
[10:22:45.003]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:45.003]             version = "1.8"), class = "FutureResult")
[10:22:45.003]     }, finally = {
[10:22:45.003]         if (!identical(...future.workdir, getwd())) 
[10:22:45.003]             setwd(...future.workdir)
[10:22:45.003]         {
[10:22:45.003]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:45.003]                 ...future.oldOptions$nwarnings <- NULL
[10:22:45.003]             }
[10:22:45.003]             base::options(...future.oldOptions)
[10:22:45.003]             if (.Platform$OS.type == "windows") {
[10:22:45.003]                 old_names <- names(...future.oldEnvVars)
[10:22:45.003]                 envs <- base::Sys.getenv()
[10:22:45.003]                 names <- names(envs)
[10:22:45.003]                 common <- intersect(names, old_names)
[10:22:45.003]                 added <- setdiff(names, old_names)
[10:22:45.003]                 removed <- setdiff(old_names, names)
[10:22:45.003]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:45.003]                   envs[common]]
[10:22:45.003]                 NAMES <- toupper(changed)
[10:22:45.003]                 args <- list()
[10:22:45.003]                 for (kk in seq_along(NAMES)) {
[10:22:45.003]                   name <- changed[[kk]]
[10:22:45.003]                   NAME <- NAMES[[kk]]
[10:22:45.003]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.003]                     next
[10:22:45.003]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:45.003]                 }
[10:22:45.003]                 NAMES <- toupper(added)
[10:22:45.003]                 for (kk in seq_along(NAMES)) {
[10:22:45.003]                   name <- added[[kk]]
[10:22:45.003]                   NAME <- NAMES[[kk]]
[10:22:45.003]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.003]                     next
[10:22:45.003]                   args[[name]] <- ""
[10:22:45.003]                 }
[10:22:45.003]                 NAMES <- toupper(removed)
[10:22:45.003]                 for (kk in seq_along(NAMES)) {
[10:22:45.003]                   name <- removed[[kk]]
[10:22:45.003]                   NAME <- NAMES[[kk]]
[10:22:45.003]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.003]                     next
[10:22:45.003]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:45.003]                 }
[10:22:45.003]                 if (length(args) > 0) 
[10:22:45.003]                   base::do.call(base::Sys.setenv, args = args)
[10:22:45.003]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:45.003]             }
[10:22:45.003]             else {
[10:22:45.003]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:45.003]             }
[10:22:45.003]             {
[10:22:45.003]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:45.003]                   0L) {
[10:22:45.003]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:45.003]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:45.003]                   base::options(opts)
[10:22:45.003]                 }
[10:22:45.003]                 {
[10:22:45.003]                   {
[10:22:45.003]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:45.003]                     NULL
[10:22:45.003]                   }
[10:22:45.003]                   options(future.plan = NULL)
[10:22:45.003]                   if (is.na(NA_character_)) 
[10:22:45.003]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:45.003]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:45.003]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:45.003]                     envir = parent.frame()) 
[10:22:45.003]                   {
[10:22:45.003]                     default_workers <- missing(workers)
[10:22:45.003]                     if (is.function(workers)) 
[10:22:45.003]                       workers <- workers()
[10:22:45.003]                     workers <- structure(as.integer(workers), 
[10:22:45.003]                       class = class(workers))
[10:22:45.003]                     stop_if_not(is.finite(workers), workers >= 
[10:22:45.003]                       1L)
[10:22:45.003]                     if ((workers == 1L && !inherits(workers, 
[10:22:45.003]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:45.003]                       if (default_workers) 
[10:22:45.003]                         supportsMulticore(warn = TRUE)
[10:22:45.003]                       return(sequential(..., envir = envir))
[10:22:45.003]                     }
[10:22:45.003]                     oopts <- options(mc.cores = workers)
[10:22:45.003]                     on.exit(options(oopts))
[10:22:45.003]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:45.003]                       envir = envir)
[10:22:45.003]                     if (!future$lazy) 
[10:22:45.003]                       future <- run(future)
[10:22:45.003]                     invisible(future)
[10:22:45.003]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:45.003]                 }
[10:22:45.003]             }
[10:22:45.003]         }
[10:22:45.003]     })
[10:22:45.003]     if (TRUE) {
[10:22:45.003]         base::sink(type = "output", split = FALSE)
[10:22:45.003]         if (TRUE) {
[10:22:45.003]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:45.003]         }
[10:22:45.003]         else {
[10:22:45.003]             ...future.result["stdout"] <- base::list(NULL)
[10:22:45.003]         }
[10:22:45.003]         base::close(...future.stdout)
[10:22:45.003]         ...future.stdout <- NULL
[10:22:45.003]     }
[10:22:45.003]     ...future.result$conditions <- ...future.conditions
[10:22:45.003]     ...future.result$finished <- base::Sys.time()
[10:22:45.003]     ...future.result
[10:22:45.003] }
[10:22:45.006] assign_globals() ...
[10:22:45.006] List of 5
[10:22:45.006]  $ future.call.arguments    : list()
[10:22:45.006]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:45.006]  $ ...future.FUN            :function (x)  
[10:22:45.006]  $ ...future.elements_ii    :List of 3
[10:22:45.006]   ..$ : int [1:4] 1 7 13 19
[10:22:45.006]   ..$ : int [1:4] 2 8 14 20
[10:22:45.006]   ..$ : int [1:4] 3 9 15 21
[10:22:45.006]  $ ...future.seeds_ii       : NULL
[10:22:45.006]  $ ...future.globals.maxSize: num Inf
[10:22:45.006]  - attr(*, "resolved")= logi FALSE
[10:22:45.006]  - attr(*, "total_size")= num NA
[10:22:45.006]  - attr(*, "where")=List of 5
[10:22:45.006]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:45.006]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:45.006]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:45.006]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:45.006]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:45.006]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:45.006]  - attr(*, "already-done")= logi TRUE
[10:22:45.011] - copied ‘future.call.arguments’ to environment
[10:22:45.011] - reassign environment for ‘...future.FUN’
[10:22:45.011] - copied ‘...future.FUN’ to environment
[10:22:45.011] - copied ‘...future.elements_ii’ to environment
[10:22:45.011] - copied ‘...future.seeds_ii’ to environment
[10:22:45.011] - copied ‘...future.globals.maxSize’ to environment
[10:22:45.012] assign_globals() ... done
[10:22:45.012] requestCore(): workers = 2
[10:22:45.014] MulticoreFuture started
[10:22:45.014] - Launch lazy future ... done
[10:22:45.014] run() for ‘MulticoreFuture’ ... done
[10:22:45.015] Created future:
[10:22:45.015] plan(): Setting new future strategy stack:
[10:22:45.015] List of future strategies:
[10:22:45.015] 1. sequential:
[10:22:45.015]    - args: function (..., envir = parent.frame())
[10:22:45.015]    - tweaked: FALSE
[10:22:45.015]    - call: NULL
[10:22:45.016] plan(): nbrOfWorkers() = 1
[10:22:45.018] plan(): Setting new future strategy stack:
[10:22:45.018] List of future strategies:
[10:22:45.018] 1. multicore:
[10:22:45.018]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:45.018]    - tweaked: FALSE
[10:22:45.018]    - call: plan(strategy)
[10:22:45.023] plan(): nbrOfWorkers() = 2
[10:22:45.015] MulticoreFuture:
[10:22:45.015] Label: ‘future_apply-1’
[10:22:45.015] Expression:
[10:22:45.015] {
[10:22:45.015]     do.call(function(...) {
[10:22:45.015]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:45.015]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:45.015]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:45.015]             on.exit(options(oopts), add = TRUE)
[10:22:45.015]         }
[10:22:45.015]         {
[10:22:45.015]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:45.015]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:45.015]                 ...future.FUN(...future.X_jj, ...)
[10:22:45.015]             })
[10:22:45.015]         }
[10:22:45.015]     }, args = future.call.arguments)
[10:22:45.015] }
[10:22:45.015] Lazy evaluation: FALSE
[10:22:45.015] Asynchronous evaluation: TRUE
[10:22:45.015] Local evaluation: TRUE
[10:22:45.015] Environment: R_GlobalEnv
[10:22:45.015] Capture standard output: TRUE
[10:22:45.015] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:45.015] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:45.015] Packages: <none>
[10:22:45.015] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:45.015] Resolved: TRUE
[10:22:45.015] Value: <not collected>
[10:22:45.015] Conditions captured: <none>
[10:22:45.015] Early signaling: FALSE
[10:22:45.015] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:45.015] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:45.024] Chunk #1 of 2 ... DONE
[10:22:45.025] Chunk #2 of 2 ...
[10:22:45.025]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:45.025]  - seeds: <none>
[10:22:45.025]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:45.025] getGlobalsAndPackages() ...
[10:22:45.025] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:45.026] Resolving globals: FALSE
[10:22:45.026] Tweak future expression to call with '...' arguments ...
[10:22:45.026] {
[10:22:45.026]     do.call(function(...) {
[10:22:45.026]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:45.026]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:45.026]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:45.026]             on.exit(options(oopts), add = TRUE)
[10:22:45.026]         }
[10:22:45.026]         {
[10:22:45.026]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:45.026]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:45.026]                 ...future.FUN(...future.X_jj, ...)
[10:22:45.026]             })
[10:22:45.026]         }
[10:22:45.026]     }, args = future.call.arguments)
[10:22:45.026] }
[10:22:45.026] Tweak future expression to call with '...' arguments ... DONE
[10:22:45.027] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:45.027] 
[10:22:45.027] getGlobalsAndPackages() ... DONE
[10:22:45.028] run() for ‘Future’ ...
[10:22:45.028] - state: ‘created’
[10:22:45.028] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:45.033] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:45.033] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:45.033]   - Field: ‘label’
[10:22:45.033]   - Field: ‘local’
[10:22:45.033]   - Field: ‘owner’
[10:22:45.034]   - Field: ‘envir’
[10:22:45.034]   - Field: ‘workers’
[10:22:45.034]   - Field: ‘packages’
[10:22:45.034]   - Field: ‘gc’
[10:22:45.034]   - Field: ‘job’
[10:22:45.034]   - Field: ‘conditions’
[10:22:45.034]   - Field: ‘expr’
[10:22:45.034]   - Field: ‘uuid’
[10:22:45.035]   - Field: ‘seed’
[10:22:45.035]   - Field: ‘version’
[10:22:45.035]   - Field: ‘result’
[10:22:45.035]   - Field: ‘asynchronous’
[10:22:45.035]   - Field: ‘calls’
[10:22:45.035]   - Field: ‘globals’
[10:22:45.035]   - Field: ‘stdout’
[10:22:45.036]   - Field: ‘earlySignal’
[10:22:45.036]   - Field: ‘lazy’
[10:22:45.039]   - Field: ‘state’
[10:22:45.039] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:45.040] - Launch lazy future ...
[10:22:45.040] Packages needed by the future expression (n = 0): <none>
[10:22:45.041] Packages needed by future strategies (n = 0): <none>
[10:22:45.042] {
[10:22:45.042]     {
[10:22:45.042]         {
[10:22:45.042]             ...future.startTime <- base::Sys.time()
[10:22:45.042]             {
[10:22:45.042]                 {
[10:22:45.042]                   {
[10:22:45.042]                     {
[10:22:45.042]                       base::local({
[10:22:45.042]                         has_future <- base::requireNamespace("future", 
[10:22:45.042]                           quietly = TRUE)
[10:22:45.042]                         if (has_future) {
[10:22:45.042]                           ns <- base::getNamespace("future")
[10:22:45.042]                           version <- ns[[".package"]][["version"]]
[10:22:45.042]                           if (is.null(version)) 
[10:22:45.042]                             version <- utils::packageVersion("future")
[10:22:45.042]                         }
[10:22:45.042]                         else {
[10:22:45.042]                           version <- NULL
[10:22:45.042]                         }
[10:22:45.042]                         if (!has_future || version < "1.8.0") {
[10:22:45.042]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:45.042]                             "", base::R.version$version.string), 
[10:22:45.042]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:45.042]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:45.042]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:45.042]                               "release", "version")], collapse = " "), 
[10:22:45.042]                             hostname = base::Sys.info()[["nodename"]])
[10:22:45.042]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:45.042]                             info)
[10:22:45.042]                           info <- base::paste(info, collapse = "; ")
[10:22:45.042]                           if (!has_future) {
[10:22:45.042]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:45.042]                               info)
[10:22:45.042]                           }
[10:22:45.042]                           else {
[10:22:45.042]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:45.042]                               info, version)
[10:22:45.042]                           }
[10:22:45.042]                           base::stop(msg)
[10:22:45.042]                         }
[10:22:45.042]                       })
[10:22:45.042]                     }
[10:22:45.042]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:45.042]                     base::options(mc.cores = 1L)
[10:22:45.042]                   }
[10:22:45.042]                   options(future.plan = NULL)
[10:22:45.042]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:45.042]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:45.042]                 }
[10:22:45.042]                 ...future.workdir <- getwd()
[10:22:45.042]             }
[10:22:45.042]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:45.042]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:45.042]         }
[10:22:45.042]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:45.042]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:45.042]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:45.042]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:45.042]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:45.042]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:45.042]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:45.042]             base::names(...future.oldOptions))
[10:22:45.042]     }
[10:22:45.042]     if (FALSE) {
[10:22:45.042]     }
[10:22:45.042]     else {
[10:22:45.042]         if (TRUE) {
[10:22:45.042]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:45.042]                 open = "w")
[10:22:45.042]         }
[10:22:45.042]         else {
[10:22:45.042]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:45.042]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:45.042]         }
[10:22:45.042]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:45.042]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:45.042]             base::sink(type = "output", split = FALSE)
[10:22:45.042]             base::close(...future.stdout)
[10:22:45.042]         }, add = TRUE)
[10:22:45.042]     }
[10:22:45.042]     ...future.frame <- base::sys.nframe()
[10:22:45.042]     ...future.conditions <- base::list()
[10:22:45.042]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:45.042]     if (FALSE) {
[10:22:45.042]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:45.042]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:45.042]     }
[10:22:45.042]     ...future.result <- base::tryCatch({
[10:22:45.042]         base::withCallingHandlers({
[10:22:45.042]             ...future.value <- base::withVisible(base::local({
[10:22:45.042]                 withCallingHandlers({
[10:22:45.042]                   {
[10:22:45.042]                     do.call(function(...) {
[10:22:45.042]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:45.042]                       if (!identical(...future.globals.maxSize.org, 
[10:22:45.042]                         ...future.globals.maxSize)) {
[10:22:45.042]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:45.042]                         on.exit(options(oopts), add = TRUE)
[10:22:45.042]                       }
[10:22:45.042]                       {
[10:22:45.042]                         lapply(seq_along(...future.elements_ii), 
[10:22:45.042]                           FUN = function(jj) {
[10:22:45.042]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:45.042]                             ...future.FUN(...future.X_jj, ...)
[10:22:45.042]                           })
[10:22:45.042]                       }
[10:22:45.042]                     }, args = future.call.arguments)
[10:22:45.042]                   }
[10:22:45.042]                 }, immediateCondition = function(cond) {
[10:22:45.042]                   save_rds <- function (object, pathname, ...) 
[10:22:45.042]                   {
[10:22:45.042]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:45.042]                     if (file_test("-f", pathname_tmp)) {
[10:22:45.042]                       fi_tmp <- file.info(pathname_tmp)
[10:22:45.042]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:45.042]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:45.042]                         fi_tmp[["mtime"]])
[10:22:45.042]                     }
[10:22:45.042]                     tryCatch({
[10:22:45.042]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:45.042]                     }, error = function(ex) {
[10:22:45.042]                       msg <- conditionMessage(ex)
[10:22:45.042]                       fi_tmp <- file.info(pathname_tmp)
[10:22:45.042]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:45.042]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:45.042]                         fi_tmp[["mtime"]], msg)
[10:22:45.042]                       ex$message <- msg
[10:22:45.042]                       stop(ex)
[10:22:45.042]                     })
[10:22:45.042]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:45.042]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:45.042]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:45.042]                       fi_tmp <- file.info(pathname_tmp)
[10:22:45.042]                       fi <- file.info(pathname)
[10:22:45.042]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:45.042]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:45.042]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:45.042]                         fi[["size"]], fi[["mtime"]])
[10:22:45.042]                       stop(msg)
[10:22:45.042]                     }
[10:22:45.042]                     invisible(pathname)
[10:22:45.042]                   }
[10:22:45.042]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:45.042]                     rootPath = tempdir()) 
[10:22:45.042]                   {
[10:22:45.042]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:45.042]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:45.042]                       tmpdir = path, fileext = ".rds")
[10:22:45.042]                     save_rds(obj, file)
[10:22:45.042]                   }
[10:22:45.042]                   saveImmediateCondition(cond, path = "/tmp/RtmpTHXGJm/.future/immediateConditions")
[10:22:45.042]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.042]                   {
[10:22:45.042]                     inherits <- base::inherits
[10:22:45.042]                     invokeRestart <- base::invokeRestart
[10:22:45.042]                     is.null <- base::is.null
[10:22:45.042]                     muffled <- FALSE
[10:22:45.042]                     if (inherits(cond, "message")) {
[10:22:45.042]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:45.042]                       if (muffled) 
[10:22:45.042]                         invokeRestart("muffleMessage")
[10:22:45.042]                     }
[10:22:45.042]                     else if (inherits(cond, "warning")) {
[10:22:45.042]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:45.042]                       if (muffled) 
[10:22:45.042]                         invokeRestart("muffleWarning")
[10:22:45.042]                     }
[10:22:45.042]                     else if (inherits(cond, "condition")) {
[10:22:45.042]                       if (!is.null(pattern)) {
[10:22:45.042]                         computeRestarts <- base::computeRestarts
[10:22:45.042]                         grepl <- base::grepl
[10:22:45.042]                         restarts <- computeRestarts(cond)
[10:22:45.042]                         for (restart in restarts) {
[10:22:45.042]                           name <- restart$name
[10:22:45.042]                           if (is.null(name)) 
[10:22:45.042]                             next
[10:22:45.042]                           if (!grepl(pattern, name)) 
[10:22:45.042]                             next
[10:22:45.042]                           invokeRestart(restart)
[10:22:45.042]                           muffled <- TRUE
[10:22:45.042]                           break
[10:22:45.042]                         }
[10:22:45.042]                       }
[10:22:45.042]                     }
[10:22:45.042]                     invisible(muffled)
[10:22:45.042]                   }
[10:22:45.042]                   muffleCondition(cond)
[10:22:45.042]                 })
[10:22:45.042]             }))
[10:22:45.042]             future::FutureResult(value = ...future.value$value, 
[10:22:45.042]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:45.042]                   ...future.rng), globalenv = if (FALSE) 
[10:22:45.042]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:45.042]                     ...future.globalenv.names))
[10:22:45.042]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:45.042]         }, condition = base::local({
[10:22:45.042]             c <- base::c
[10:22:45.042]             inherits <- base::inherits
[10:22:45.042]             invokeRestart <- base::invokeRestart
[10:22:45.042]             length <- base::length
[10:22:45.042]             list <- base::list
[10:22:45.042]             seq.int <- base::seq.int
[10:22:45.042]             signalCondition <- base::signalCondition
[10:22:45.042]             sys.calls <- base::sys.calls
[10:22:45.042]             `[[` <- base::`[[`
[10:22:45.042]             `+` <- base::`+`
[10:22:45.042]             `<<-` <- base::`<<-`
[10:22:45.042]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:45.042]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:45.042]                   3L)]
[10:22:45.042]             }
[10:22:45.042]             function(cond) {
[10:22:45.042]                 is_error <- inherits(cond, "error")
[10:22:45.042]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:45.042]                   NULL)
[10:22:45.042]                 if (is_error) {
[10:22:45.042]                   sessionInformation <- function() {
[10:22:45.042]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:45.042]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:45.042]                       search = base::search(), system = base::Sys.info())
[10:22:45.042]                   }
[10:22:45.042]                   ...future.conditions[[length(...future.conditions) + 
[10:22:45.042]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:45.042]                     cond$call), session = sessionInformation(), 
[10:22:45.042]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:45.042]                   signalCondition(cond)
[10:22:45.042]                 }
[10:22:45.042]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:45.042]                 "immediateCondition"))) {
[10:22:45.042]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:45.042]                   ...future.conditions[[length(...future.conditions) + 
[10:22:45.042]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:45.042]                   if (TRUE && !signal) {
[10:22:45.042]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.042]                     {
[10:22:45.042]                       inherits <- base::inherits
[10:22:45.042]                       invokeRestart <- base::invokeRestart
[10:22:45.042]                       is.null <- base::is.null
[10:22:45.042]                       muffled <- FALSE
[10:22:45.042]                       if (inherits(cond, "message")) {
[10:22:45.042]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:45.042]                         if (muffled) 
[10:22:45.042]                           invokeRestart("muffleMessage")
[10:22:45.042]                       }
[10:22:45.042]                       else if (inherits(cond, "warning")) {
[10:22:45.042]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:45.042]                         if (muffled) 
[10:22:45.042]                           invokeRestart("muffleWarning")
[10:22:45.042]                       }
[10:22:45.042]                       else if (inherits(cond, "condition")) {
[10:22:45.042]                         if (!is.null(pattern)) {
[10:22:45.042]                           computeRestarts <- base::computeRestarts
[10:22:45.042]                           grepl <- base::grepl
[10:22:45.042]                           restarts <- computeRestarts(cond)
[10:22:45.042]                           for (restart in restarts) {
[10:22:45.042]                             name <- restart$name
[10:22:45.042]                             if (is.null(name)) 
[10:22:45.042]                               next
[10:22:45.042]                             if (!grepl(pattern, name)) 
[10:22:45.042]                               next
[10:22:45.042]                             invokeRestart(restart)
[10:22:45.042]                             muffled <- TRUE
[10:22:45.042]                             break
[10:22:45.042]                           }
[10:22:45.042]                         }
[10:22:45.042]                       }
[10:22:45.042]                       invisible(muffled)
[10:22:45.042]                     }
[10:22:45.042]                     muffleCondition(cond, pattern = "^muffle")
[10:22:45.042]                   }
[10:22:45.042]                 }
[10:22:45.042]                 else {
[10:22:45.042]                   if (TRUE) {
[10:22:45.042]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.042]                     {
[10:22:45.042]                       inherits <- base::inherits
[10:22:45.042]                       invokeRestart <- base::invokeRestart
[10:22:45.042]                       is.null <- base::is.null
[10:22:45.042]                       muffled <- FALSE
[10:22:45.042]                       if (inherits(cond, "message")) {
[10:22:45.042]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:45.042]                         if (muffled) 
[10:22:45.042]                           invokeRestart("muffleMessage")
[10:22:45.042]                       }
[10:22:45.042]                       else if (inherits(cond, "warning")) {
[10:22:45.042]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:45.042]                         if (muffled) 
[10:22:45.042]                           invokeRestart("muffleWarning")
[10:22:45.042]                       }
[10:22:45.042]                       else if (inherits(cond, "condition")) {
[10:22:45.042]                         if (!is.null(pattern)) {
[10:22:45.042]                           computeRestarts <- base::computeRestarts
[10:22:45.042]                           grepl <- base::grepl
[10:22:45.042]                           restarts <- computeRestarts(cond)
[10:22:45.042]                           for (restart in restarts) {
[10:22:45.042]                             name <- restart$name
[10:22:45.042]                             if (is.null(name)) 
[10:22:45.042]                               next
[10:22:45.042]                             if (!grepl(pattern, name)) 
[10:22:45.042]                               next
[10:22:45.042]                             invokeRestart(restart)
[10:22:45.042]                             muffled <- TRUE
[10:22:45.042]                             break
[10:22:45.042]                           }
[10:22:45.042]                         }
[10:22:45.042]                       }
[10:22:45.042]                       invisible(muffled)
[10:22:45.042]                     }
[10:22:45.042]                     muffleCondition(cond, pattern = "^muffle")
[10:22:45.042]                   }
[10:22:45.042]                 }
[10:22:45.042]             }
[10:22:45.042]         }))
[10:22:45.042]     }, error = function(ex) {
[10:22:45.042]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:45.042]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:45.042]                 ...future.rng), started = ...future.startTime, 
[10:22:45.042]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:45.042]             version = "1.8"), class = "FutureResult")
[10:22:45.042]     }, finally = {
[10:22:45.042]         if (!identical(...future.workdir, getwd())) 
[10:22:45.042]             setwd(...future.workdir)
[10:22:45.042]         {
[10:22:45.042]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:45.042]                 ...future.oldOptions$nwarnings <- NULL
[10:22:45.042]             }
[10:22:45.042]             base::options(...future.oldOptions)
[10:22:45.042]             if (.Platform$OS.type == "windows") {
[10:22:45.042]                 old_names <- names(...future.oldEnvVars)
[10:22:45.042]                 envs <- base::Sys.getenv()
[10:22:45.042]                 names <- names(envs)
[10:22:45.042]                 common <- intersect(names, old_names)
[10:22:45.042]                 added <- setdiff(names, old_names)
[10:22:45.042]                 removed <- setdiff(old_names, names)
[10:22:45.042]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:45.042]                   envs[common]]
[10:22:45.042]                 NAMES <- toupper(changed)
[10:22:45.042]                 args <- list()
[10:22:45.042]                 for (kk in seq_along(NAMES)) {
[10:22:45.042]                   name <- changed[[kk]]
[10:22:45.042]                   NAME <- NAMES[[kk]]
[10:22:45.042]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.042]                     next
[10:22:45.042]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:45.042]                 }
[10:22:45.042]                 NAMES <- toupper(added)
[10:22:45.042]                 for (kk in seq_along(NAMES)) {
[10:22:45.042]                   name <- added[[kk]]
[10:22:45.042]                   NAME <- NAMES[[kk]]
[10:22:45.042]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.042]                     next
[10:22:45.042]                   args[[name]] <- ""
[10:22:45.042]                 }
[10:22:45.042]                 NAMES <- toupper(removed)
[10:22:45.042]                 for (kk in seq_along(NAMES)) {
[10:22:45.042]                   name <- removed[[kk]]
[10:22:45.042]                   NAME <- NAMES[[kk]]
[10:22:45.042]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.042]                     next
[10:22:45.042]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:45.042]                 }
[10:22:45.042]                 if (length(args) > 0) 
[10:22:45.042]                   base::do.call(base::Sys.setenv, args = args)
[10:22:45.042]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:45.042]             }
[10:22:45.042]             else {
[10:22:45.042]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:45.042]             }
[10:22:45.042]             {
[10:22:45.042]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:45.042]                   0L) {
[10:22:45.042]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:45.042]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:45.042]                   base::options(opts)
[10:22:45.042]                 }
[10:22:45.042]                 {
[10:22:45.042]                   {
[10:22:45.042]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:45.042]                     NULL
[10:22:45.042]                   }
[10:22:45.042]                   options(future.plan = NULL)
[10:22:45.042]                   if (is.na(NA_character_)) 
[10:22:45.042]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:45.042]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:45.042]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:45.042]                     envir = parent.frame()) 
[10:22:45.042]                   {
[10:22:45.042]                     default_workers <- missing(workers)
[10:22:45.042]                     if (is.function(workers)) 
[10:22:45.042]                       workers <- workers()
[10:22:45.042]                     workers <- structure(as.integer(workers), 
[10:22:45.042]                       class = class(workers))
[10:22:45.042]                     stop_if_not(is.finite(workers), workers >= 
[10:22:45.042]                       1L)
[10:22:45.042]                     if ((workers == 1L && !inherits(workers, 
[10:22:45.042]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:45.042]                       if (default_workers) 
[10:22:45.042]                         supportsMulticore(warn = TRUE)
[10:22:45.042]                       return(sequential(..., envir = envir))
[10:22:45.042]                     }
[10:22:45.042]                     oopts <- options(mc.cores = workers)
[10:22:45.042]                     on.exit(options(oopts))
[10:22:45.042]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:45.042]                       envir = envir)
[10:22:45.042]                     if (!future$lazy) 
[10:22:45.042]                       future <- run(future)
[10:22:45.042]                     invisible(future)
[10:22:45.042]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:45.042]                 }
[10:22:45.042]             }
[10:22:45.042]         }
[10:22:45.042]     })
[10:22:45.042]     if (TRUE) {
[10:22:45.042]         base::sink(type = "output", split = FALSE)
[10:22:45.042]         if (TRUE) {
[10:22:45.042]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:45.042]         }
[10:22:45.042]         else {
[10:22:45.042]             ...future.result["stdout"] <- base::list(NULL)
[10:22:45.042]         }
[10:22:45.042]         base::close(...future.stdout)
[10:22:45.042]         ...future.stdout <- NULL
[10:22:45.042]     }
[10:22:45.042]     ...future.result$conditions <- ...future.conditions
[10:22:45.042]     ...future.result$finished <- base::Sys.time()
[10:22:45.042]     ...future.result
[10:22:45.042] }
[10:22:45.045] assign_globals() ...
[10:22:45.045] List of 5
[10:22:45.045]  $ future.call.arguments    : list()
[10:22:45.045]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:45.045]  $ ...future.FUN            :function (x)  
[10:22:45.045]  $ ...future.elements_ii    :List of 3
[10:22:45.045]   ..$ : int [1:4] 4 10 16 22
[10:22:45.045]   ..$ : int [1:4] 5 11 17 23
[10:22:45.045]   ..$ : int [1:4] 6 12 18 24
[10:22:45.045]  $ ...future.seeds_ii       : NULL
[10:22:45.045]  $ ...future.globals.maxSize: num Inf
[10:22:45.045]  - attr(*, "resolved")= logi FALSE
[10:22:45.045]  - attr(*, "total_size")= num NA
[10:22:45.045]  - attr(*, "where")=List of 5
[10:22:45.045]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:45.045]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:45.045]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:45.045]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:45.045]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:45.045]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:45.045]  - attr(*, "already-done")= logi TRUE
[10:22:45.055] - copied ‘future.call.arguments’ to environment
[10:22:45.055] - reassign environment for ‘...future.FUN’
[10:22:45.055] - copied ‘...future.FUN’ to environment
[10:22:45.056] - copied ‘...future.elements_ii’ to environment
[10:22:45.056] - copied ‘...future.seeds_ii’ to environment
[10:22:45.056] - copied ‘...future.globals.maxSize’ to environment
[10:22:45.056] assign_globals() ... done
[10:22:45.056] requestCore(): workers = 2
[10:22:45.058] MulticoreFuture started
[10:22:45.059] - Launch lazy future ... done
[10:22:45.059] run() for ‘MulticoreFuture’ ... done
[10:22:45.059] Created future:
[10:22:45.059] plan(): Setting new future strategy stack:
[10:22:45.060] List of future strategies:
[10:22:45.060] 1. sequential:
[10:22:45.060]    - args: function (..., envir = parent.frame())
[10:22:45.060]    - tweaked: FALSE
[10:22:45.060]    - call: NULL
[10:22:45.060] plan(): nbrOfWorkers() = 1
[10:22:45.062] plan(): Setting new future strategy stack:
[10:22:45.063] List of future strategies:
[10:22:45.063] 1. multicore:
[10:22:45.063]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:45.063]    - tweaked: FALSE
[10:22:45.063]    - call: plan(strategy)
[10:22:45.068] plan(): nbrOfWorkers() = 2
[10:22:45.059] MulticoreFuture:
[10:22:45.059] Label: ‘future_apply-2’
[10:22:45.059] Expression:
[10:22:45.059] {
[10:22:45.059]     do.call(function(...) {
[10:22:45.059]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:45.059]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:45.059]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:45.059]             on.exit(options(oopts), add = TRUE)
[10:22:45.059]         }
[10:22:45.059]         {
[10:22:45.059]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:45.059]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:45.059]                 ...future.FUN(...future.X_jj, ...)
[10:22:45.059]             })
[10:22:45.059]         }
[10:22:45.059]     }, args = future.call.arguments)
[10:22:45.059] }
[10:22:45.059] Lazy evaluation: FALSE
[10:22:45.059] Asynchronous evaluation: TRUE
[10:22:45.059] Local evaluation: TRUE
[10:22:45.059] Environment: R_GlobalEnv
[10:22:45.059] Capture standard output: TRUE
[10:22:45.059] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:45.059] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:45.059] Packages: <none>
[10:22:45.059] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:45.059] Resolved: TRUE
[10:22:45.059] Value: <not collected>
[10:22:45.059] Conditions captured: <none>
[10:22:45.059] Early signaling: FALSE
[10:22:45.059] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:45.059] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:45.069] Chunk #2 of 2 ... DONE
[10:22:45.069] Launching 2 futures (chunks) ... DONE
[10:22:45.069] Resolving 2 futures (chunks) ...
[10:22:45.069] resolve() on list ...
[10:22:45.069]  recursive: 0
[10:22:45.070]  length: 2
[10:22:45.070] 
[10:22:45.070] Future #1
[10:22:45.070] result() for MulticoreFuture ...
[10:22:45.071] result() for MulticoreFuture ...
[10:22:45.071] result() for MulticoreFuture ... done
[10:22:45.072] result() for MulticoreFuture ... done
[10:22:45.072] result() for MulticoreFuture ...
[10:22:45.072] result() for MulticoreFuture ... done
[10:22:45.072] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:22:45.072] - nx: 2
[10:22:45.072] - relay: TRUE
[10:22:45.073] - stdout: TRUE
[10:22:45.073] - signal: TRUE
[10:22:45.073] - resignal: FALSE
[10:22:45.073] - force: TRUE
[10:22:45.073] - relayed: [n=2] FALSE, FALSE
[10:22:45.073] - queued futures: [n=2] FALSE, FALSE
[10:22:45.073]  - until=1
[10:22:45.074]  - relaying element #1
[10:22:45.074] result() for MulticoreFuture ...
[10:22:45.074] result() for MulticoreFuture ... done
[10:22:45.074] result() for MulticoreFuture ...
[10:22:45.074] result() for MulticoreFuture ... done
[10:22:45.074] result() for MulticoreFuture ...
[10:22:45.075] result() for MulticoreFuture ... done
[10:22:45.075] result() for MulticoreFuture ...
[10:22:45.075] result() for MulticoreFuture ... done
[10:22:45.075] - relayed: [n=2] TRUE, FALSE
[10:22:45.075] - queued futures: [n=2] TRUE, FALSE
[10:22:45.075] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:22:45.076]  length: 1 (resolved future 1)
[10:22:45.076] Future #2
[10:22:45.076] result() for MulticoreFuture ...
[10:22:45.077] result() for MulticoreFuture ...
[10:22:45.077] result() for MulticoreFuture ... done
[10:22:45.077] result() for MulticoreFuture ... done
[10:22:45.077] result() for MulticoreFuture ...
[10:22:45.077] result() for MulticoreFuture ... done
[10:22:45.078] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:22:45.078] - nx: 2
[10:22:45.078] - relay: TRUE
[10:22:45.078] - stdout: TRUE
[10:22:45.078] - signal: TRUE
[10:22:45.078] - resignal: FALSE
[10:22:45.078] - force: TRUE
[10:22:45.078] - relayed: [n=2] TRUE, FALSE
[10:22:45.079] - queued futures: [n=2] TRUE, FALSE
[10:22:45.079]  - until=2
[10:22:45.079]  - relaying element #2
[10:22:45.079] result() for MulticoreFuture ...
[10:22:45.079] result() for MulticoreFuture ... done
[10:22:45.079] result() for MulticoreFuture ...
[10:22:45.079] result() for MulticoreFuture ... done
[10:22:45.080] result() for MulticoreFuture ...
[10:22:45.080] result() for MulticoreFuture ... done
[10:22:45.080] result() for MulticoreFuture ...
[10:22:45.080] result() for MulticoreFuture ... done
[10:22:45.080] - relayed: [n=2] TRUE, TRUE
[10:22:45.080] - queued futures: [n=2] TRUE, TRUE
[10:22:45.080] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:22:45.080]  length: 0 (resolved future 2)
[10:22:45.080] Relaying remaining futures
[10:22:45.081] signalConditionsASAP(NULL, pos=0) ...
[10:22:45.081] - nx: 2
[10:22:45.081] - relay: TRUE
[10:22:45.081] - stdout: TRUE
[10:22:45.081] - signal: TRUE
[10:22:45.081] - resignal: FALSE
[10:22:45.081] - force: TRUE
[10:22:45.081] - relayed: [n=2] TRUE, TRUE
[10:22:45.081] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:22:45.082] - relayed: [n=2] TRUE, TRUE
[10:22:45.082] - queued futures: [n=2] TRUE, TRUE
[10:22:45.082] signalConditionsASAP(NULL, pos=0) ... done
[10:22:45.082] resolve() on list ... DONE
[10:22:45.082] result() for MulticoreFuture ...
[10:22:45.082] result() for MulticoreFuture ... done
[10:22:45.082] result() for MulticoreFuture ...
[10:22:45.082] result() for MulticoreFuture ... done
[10:22:45.082] result() for MulticoreFuture ...
[10:22:45.083] result() for MulticoreFuture ... done
[10:22:45.083] result() for MulticoreFuture ...
[10:22:45.083] result() for MulticoreFuture ... done
[10:22:45.083]  - Number of value chunks collected: 2
[10:22:45.083] Resolving 2 futures (chunks) ... DONE
[10:22:45.083] Reducing values from 2 chunks ...
[10:22:45.086]  - Number of values collected after concatenation: 6
[10:22:45.086]  - Number of values expected: 6
[10:22:45.086] Reducing values from 2 chunks ... DONE
[10:22:45.086] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[10:22:45.087] getGlobalsAndPackagesXApply() ...
[10:22:45.087]  - future.globals: TRUE
[10:22:45.087] getGlobalsAndPackages() ...
[10:22:45.087] Searching for globals...
[10:22:45.089] - globals found: [1] ‘FUN’
[10:22:45.089] Searching for globals ... DONE
[10:22:45.089] Resolving globals: FALSE
[10:22:45.090] The total size of the 1 globals is 848 bytes (848 bytes)
[10:22:45.090] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:22:45.091] - globals: [1] ‘FUN’
[10:22:45.091] 
[10:22:45.091] getGlobalsAndPackages() ... DONE
[10:22:45.091]  - globals found/used: [n=1] ‘FUN’
[10:22:45.091]  - needed namespaces: [n=0] 
[10:22:45.091] Finding globals ... DONE
[10:22:45.091]  - use_args: TRUE
[10:22:45.092]  - Getting '...' globals ...
[10:22:45.092] resolve() on list ...
[10:22:45.092]  recursive: 0
[10:22:45.092]  length: 1
[10:22:45.092]  elements: ‘...’
[10:22:45.092]  length: 0 (resolved future 1)
[10:22:45.092] resolve() on list ... DONE
[10:22:45.093]    - '...' content: [n=0] 
[10:22:45.093] List of 1
[10:22:45.093]  $ ...: list()
[10:22:45.093]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:45.093]  - attr(*, "where")=List of 1
[10:22:45.093]   ..$ ...:<environment: 0x55ca4d51e630> 
[10:22:45.093]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:45.093]  - attr(*, "resolved")= logi TRUE
[10:22:45.093]  - attr(*, "total_size")= num NA
[10:22:45.096]  - Getting '...' globals ... DONE
[10:22:45.096] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:45.096] List of 2
[10:22:45.096]  $ ...future.FUN:function (x)  
[10:22:45.096]  $ ...          : list()
[10:22:45.096]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:45.096]  - attr(*, "where")=List of 2
[10:22:45.096]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:45.096]   ..$ ...          :<environment: 0x55ca4d51e630> 
[10:22:45.096]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:45.096]  - attr(*, "resolved")= logi FALSE
[10:22:45.096]  - attr(*, "total_size")= num 848
[10:22:45.099] Packages to be attached in all futures: [n=0] 
[10:22:45.099] getGlobalsAndPackagesXApply() ... DONE
[10:22:45.103] future_lapply() ...
[10:22:45.107] Number of chunks: 2
[10:22:45.107] getGlobalsAndPackagesXApply() ...
[10:22:45.107]  - future.globals: <name-value list> with names ‘list()’
[10:22:45.107]  - use_args: TRUE
[10:22:45.107] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:22:45.107] List of 2
[10:22:45.107]  $ ...          : list()
[10:22:45.107]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:45.107]  $ ...future.FUN:function (x)  
[10:22:45.107]  - attr(*, "where")=List of 2
[10:22:45.107]   ..$ ...          :<environment: 0x55ca4d51e630> 
[10:22:45.107]   ..$ ...future.FUN:<environment: namespace:base> 
[10:22:45.107]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:45.107]  - attr(*, "resolved")= logi FALSE
[10:22:45.107]  - attr(*, "total_size")= num NA
[10:22:45.111] Packages to be attached in all futures: [n=0] 
[10:22:45.111] getGlobalsAndPackagesXApply() ... DONE
[10:22:45.111] Number of futures (= number of chunks): 2
[10:22:45.111] Launching 2 futures (chunks) ...
[10:22:45.111] Chunk #1 of 2 ...
[10:22:45.112]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:45.112]  - seeds: <none>
[10:22:45.112]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:45.112] getGlobalsAndPackages() ...
[10:22:45.112] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:45.112] Resolving globals: FALSE
[10:22:45.112] Tweak future expression to call with '...' arguments ...
[10:22:45.112] {
[10:22:45.112]     do.call(function(...) {
[10:22:45.112]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:45.112]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:45.112]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:45.112]             on.exit(options(oopts), add = TRUE)
[10:22:45.112]         }
[10:22:45.112]         {
[10:22:45.112]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:45.112]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:45.112]                 ...future.FUN(...future.X_jj, ...)
[10:22:45.112]             })
[10:22:45.112]         }
[10:22:45.112]     }, args = future.call.arguments)
[10:22:45.112] }
[10:22:45.113] Tweak future expression to call with '...' arguments ... DONE
[10:22:45.113] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:45.113] 
[10:22:45.113] getGlobalsAndPackages() ... DONE
[10:22:45.114] run() for ‘Future’ ...
[10:22:45.114] - state: ‘created’
[10:22:45.114] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:45.119] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:45.119] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:45.120]   - Field: ‘label’
[10:22:45.120]   - Field: ‘local’
[10:22:45.120]   - Field: ‘owner’
[10:22:45.120]   - Field: ‘envir’
[10:22:45.120]   - Field: ‘workers’
[10:22:45.120]   - Field: ‘packages’
[10:22:45.120]   - Field: ‘gc’
[10:22:45.120]   - Field: ‘job’
[10:22:45.120]   - Field: ‘conditions’
[10:22:45.121]   - Field: ‘expr’
[10:22:45.121]   - Field: ‘uuid’
[10:22:45.121]   - Field: ‘seed’
[10:22:45.121]   - Field: ‘version’
[10:22:45.121]   - Field: ‘result’
[10:22:45.121]   - Field: ‘asynchronous’
[10:22:45.121]   - Field: ‘calls’
[10:22:45.121]   - Field: ‘globals’
[10:22:45.122]   - Field: ‘stdout’
[10:22:45.122]   - Field: ‘earlySignal’
[10:22:45.122]   - Field: ‘lazy’
[10:22:45.122]   - Field: ‘state’
[10:22:45.122] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:45.122] - Launch lazy future ...
[10:22:45.122] Packages needed by the future expression (n = 0): <none>
[10:22:45.122] Packages needed by future strategies (n = 0): <none>
[10:22:45.123] {
[10:22:45.123]     {
[10:22:45.123]         {
[10:22:45.123]             ...future.startTime <- base::Sys.time()
[10:22:45.123]             {
[10:22:45.123]                 {
[10:22:45.123]                   {
[10:22:45.123]                     {
[10:22:45.123]                       base::local({
[10:22:45.123]                         has_future <- base::requireNamespace("future", 
[10:22:45.123]                           quietly = TRUE)
[10:22:45.123]                         if (has_future) {
[10:22:45.123]                           ns <- base::getNamespace("future")
[10:22:45.123]                           version <- ns[[".package"]][["version"]]
[10:22:45.123]                           if (is.null(version)) 
[10:22:45.123]                             version <- utils::packageVersion("future")
[10:22:45.123]                         }
[10:22:45.123]                         else {
[10:22:45.123]                           version <- NULL
[10:22:45.123]                         }
[10:22:45.123]                         if (!has_future || version < "1.8.0") {
[10:22:45.123]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:45.123]                             "", base::R.version$version.string), 
[10:22:45.123]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:45.123]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:45.123]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:45.123]                               "release", "version")], collapse = " "), 
[10:22:45.123]                             hostname = base::Sys.info()[["nodename"]])
[10:22:45.123]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:45.123]                             info)
[10:22:45.123]                           info <- base::paste(info, collapse = "; ")
[10:22:45.123]                           if (!has_future) {
[10:22:45.123]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:45.123]                               info)
[10:22:45.123]                           }
[10:22:45.123]                           else {
[10:22:45.123]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:45.123]                               info, version)
[10:22:45.123]                           }
[10:22:45.123]                           base::stop(msg)
[10:22:45.123]                         }
[10:22:45.123]                       })
[10:22:45.123]                     }
[10:22:45.123]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:45.123]                     base::options(mc.cores = 1L)
[10:22:45.123]                   }
[10:22:45.123]                   options(future.plan = NULL)
[10:22:45.123]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:45.123]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:45.123]                 }
[10:22:45.123]                 ...future.workdir <- getwd()
[10:22:45.123]             }
[10:22:45.123]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:45.123]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:45.123]         }
[10:22:45.123]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:45.123]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:45.123]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:45.123]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:45.123]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:45.123]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:45.123]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:45.123]             base::names(...future.oldOptions))
[10:22:45.123]     }
[10:22:45.123]     if (FALSE) {
[10:22:45.123]     }
[10:22:45.123]     else {
[10:22:45.123]         if (TRUE) {
[10:22:45.123]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:45.123]                 open = "w")
[10:22:45.123]         }
[10:22:45.123]         else {
[10:22:45.123]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:45.123]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:45.123]         }
[10:22:45.123]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:45.123]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:45.123]             base::sink(type = "output", split = FALSE)
[10:22:45.123]             base::close(...future.stdout)
[10:22:45.123]         }, add = TRUE)
[10:22:45.123]     }
[10:22:45.123]     ...future.frame <- base::sys.nframe()
[10:22:45.123]     ...future.conditions <- base::list()
[10:22:45.123]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:45.123]     if (FALSE) {
[10:22:45.123]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:45.123]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:45.123]     }
[10:22:45.123]     ...future.result <- base::tryCatch({
[10:22:45.123]         base::withCallingHandlers({
[10:22:45.123]             ...future.value <- base::withVisible(base::local({
[10:22:45.123]                 withCallingHandlers({
[10:22:45.123]                   {
[10:22:45.123]                     do.call(function(...) {
[10:22:45.123]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:45.123]                       if (!identical(...future.globals.maxSize.org, 
[10:22:45.123]                         ...future.globals.maxSize)) {
[10:22:45.123]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:45.123]                         on.exit(options(oopts), add = TRUE)
[10:22:45.123]                       }
[10:22:45.123]                       {
[10:22:45.123]                         lapply(seq_along(...future.elements_ii), 
[10:22:45.123]                           FUN = function(jj) {
[10:22:45.123]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:45.123]                             ...future.FUN(...future.X_jj, ...)
[10:22:45.123]                           })
[10:22:45.123]                       }
[10:22:45.123]                     }, args = future.call.arguments)
[10:22:45.123]                   }
[10:22:45.123]                 }, immediateCondition = function(cond) {
[10:22:45.123]                   save_rds <- function (object, pathname, ...) 
[10:22:45.123]                   {
[10:22:45.123]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:45.123]                     if (file_test("-f", pathname_tmp)) {
[10:22:45.123]                       fi_tmp <- file.info(pathname_tmp)
[10:22:45.123]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:45.123]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:45.123]                         fi_tmp[["mtime"]])
[10:22:45.123]                     }
[10:22:45.123]                     tryCatch({
[10:22:45.123]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:45.123]                     }, error = function(ex) {
[10:22:45.123]                       msg <- conditionMessage(ex)
[10:22:45.123]                       fi_tmp <- file.info(pathname_tmp)
[10:22:45.123]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:45.123]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:45.123]                         fi_tmp[["mtime"]], msg)
[10:22:45.123]                       ex$message <- msg
[10:22:45.123]                       stop(ex)
[10:22:45.123]                     })
[10:22:45.123]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:45.123]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:45.123]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:45.123]                       fi_tmp <- file.info(pathname_tmp)
[10:22:45.123]                       fi <- file.info(pathname)
[10:22:45.123]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:45.123]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:45.123]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:45.123]                         fi[["size"]], fi[["mtime"]])
[10:22:45.123]                       stop(msg)
[10:22:45.123]                     }
[10:22:45.123]                     invisible(pathname)
[10:22:45.123]                   }
[10:22:45.123]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:45.123]                     rootPath = tempdir()) 
[10:22:45.123]                   {
[10:22:45.123]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:45.123]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:45.123]                       tmpdir = path, fileext = ".rds")
[10:22:45.123]                     save_rds(obj, file)
[10:22:45.123]                   }
[10:22:45.123]                   saveImmediateCondition(cond, path = "/tmp/RtmpTHXGJm/.future/immediateConditions")
[10:22:45.123]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.123]                   {
[10:22:45.123]                     inherits <- base::inherits
[10:22:45.123]                     invokeRestart <- base::invokeRestart
[10:22:45.123]                     is.null <- base::is.null
[10:22:45.123]                     muffled <- FALSE
[10:22:45.123]                     if (inherits(cond, "message")) {
[10:22:45.123]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:45.123]                       if (muffled) 
[10:22:45.123]                         invokeRestart("muffleMessage")
[10:22:45.123]                     }
[10:22:45.123]                     else if (inherits(cond, "warning")) {
[10:22:45.123]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:45.123]                       if (muffled) 
[10:22:45.123]                         invokeRestart("muffleWarning")
[10:22:45.123]                     }
[10:22:45.123]                     else if (inherits(cond, "condition")) {
[10:22:45.123]                       if (!is.null(pattern)) {
[10:22:45.123]                         computeRestarts <- base::computeRestarts
[10:22:45.123]                         grepl <- base::grepl
[10:22:45.123]                         restarts <- computeRestarts(cond)
[10:22:45.123]                         for (restart in restarts) {
[10:22:45.123]                           name <- restart$name
[10:22:45.123]                           if (is.null(name)) 
[10:22:45.123]                             next
[10:22:45.123]                           if (!grepl(pattern, name)) 
[10:22:45.123]                             next
[10:22:45.123]                           invokeRestart(restart)
[10:22:45.123]                           muffled <- TRUE
[10:22:45.123]                           break
[10:22:45.123]                         }
[10:22:45.123]                       }
[10:22:45.123]                     }
[10:22:45.123]                     invisible(muffled)
[10:22:45.123]                   }
[10:22:45.123]                   muffleCondition(cond)
[10:22:45.123]                 })
[10:22:45.123]             }))
[10:22:45.123]             future::FutureResult(value = ...future.value$value, 
[10:22:45.123]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:45.123]                   ...future.rng), globalenv = if (FALSE) 
[10:22:45.123]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:45.123]                     ...future.globalenv.names))
[10:22:45.123]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:45.123]         }, condition = base::local({
[10:22:45.123]             c <- base::c
[10:22:45.123]             inherits <- base::inherits
[10:22:45.123]             invokeRestart <- base::invokeRestart
[10:22:45.123]             length <- base::length
[10:22:45.123]             list <- base::list
[10:22:45.123]             seq.int <- base::seq.int
[10:22:45.123]             signalCondition <- base::signalCondition
[10:22:45.123]             sys.calls <- base::sys.calls
[10:22:45.123]             `[[` <- base::`[[`
[10:22:45.123]             `+` <- base::`+`
[10:22:45.123]             `<<-` <- base::`<<-`
[10:22:45.123]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:45.123]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:45.123]                   3L)]
[10:22:45.123]             }
[10:22:45.123]             function(cond) {
[10:22:45.123]                 is_error <- inherits(cond, "error")
[10:22:45.123]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:45.123]                   NULL)
[10:22:45.123]                 if (is_error) {
[10:22:45.123]                   sessionInformation <- function() {
[10:22:45.123]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:45.123]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:45.123]                       search = base::search(), system = base::Sys.info())
[10:22:45.123]                   }
[10:22:45.123]                   ...future.conditions[[length(...future.conditions) + 
[10:22:45.123]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:45.123]                     cond$call), session = sessionInformation(), 
[10:22:45.123]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:45.123]                   signalCondition(cond)
[10:22:45.123]                 }
[10:22:45.123]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:45.123]                 "immediateCondition"))) {
[10:22:45.123]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:45.123]                   ...future.conditions[[length(...future.conditions) + 
[10:22:45.123]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:45.123]                   if (TRUE && !signal) {
[10:22:45.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.123]                     {
[10:22:45.123]                       inherits <- base::inherits
[10:22:45.123]                       invokeRestart <- base::invokeRestart
[10:22:45.123]                       is.null <- base::is.null
[10:22:45.123]                       muffled <- FALSE
[10:22:45.123]                       if (inherits(cond, "message")) {
[10:22:45.123]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:45.123]                         if (muffled) 
[10:22:45.123]                           invokeRestart("muffleMessage")
[10:22:45.123]                       }
[10:22:45.123]                       else if (inherits(cond, "warning")) {
[10:22:45.123]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:45.123]                         if (muffled) 
[10:22:45.123]                           invokeRestart("muffleWarning")
[10:22:45.123]                       }
[10:22:45.123]                       else if (inherits(cond, "condition")) {
[10:22:45.123]                         if (!is.null(pattern)) {
[10:22:45.123]                           computeRestarts <- base::computeRestarts
[10:22:45.123]                           grepl <- base::grepl
[10:22:45.123]                           restarts <- computeRestarts(cond)
[10:22:45.123]                           for (restart in restarts) {
[10:22:45.123]                             name <- restart$name
[10:22:45.123]                             if (is.null(name)) 
[10:22:45.123]                               next
[10:22:45.123]                             if (!grepl(pattern, name)) 
[10:22:45.123]                               next
[10:22:45.123]                             invokeRestart(restart)
[10:22:45.123]                             muffled <- TRUE
[10:22:45.123]                             break
[10:22:45.123]                           }
[10:22:45.123]                         }
[10:22:45.123]                       }
[10:22:45.123]                       invisible(muffled)
[10:22:45.123]                     }
[10:22:45.123]                     muffleCondition(cond, pattern = "^muffle")
[10:22:45.123]                   }
[10:22:45.123]                 }
[10:22:45.123]                 else {
[10:22:45.123]                   if (TRUE) {
[10:22:45.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.123]                     {
[10:22:45.123]                       inherits <- base::inherits
[10:22:45.123]                       invokeRestart <- base::invokeRestart
[10:22:45.123]                       is.null <- base::is.null
[10:22:45.123]                       muffled <- FALSE
[10:22:45.123]                       if (inherits(cond, "message")) {
[10:22:45.123]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:45.123]                         if (muffled) 
[10:22:45.123]                           invokeRestart("muffleMessage")
[10:22:45.123]                       }
[10:22:45.123]                       else if (inherits(cond, "warning")) {
[10:22:45.123]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:45.123]                         if (muffled) 
[10:22:45.123]                           invokeRestart("muffleWarning")
[10:22:45.123]                       }
[10:22:45.123]                       else if (inherits(cond, "condition")) {
[10:22:45.123]                         if (!is.null(pattern)) {
[10:22:45.123]                           computeRestarts <- base::computeRestarts
[10:22:45.123]                           grepl <- base::grepl
[10:22:45.123]                           restarts <- computeRestarts(cond)
[10:22:45.123]                           for (restart in restarts) {
[10:22:45.123]                             name <- restart$name
[10:22:45.123]                             if (is.null(name)) 
[10:22:45.123]                               next
[10:22:45.123]                             if (!grepl(pattern, name)) 
[10:22:45.123]                               next
[10:22:45.123]                             invokeRestart(restart)
[10:22:45.123]                             muffled <- TRUE
[10:22:45.123]                             break
[10:22:45.123]                           }
[10:22:45.123]                         }
[10:22:45.123]                       }
[10:22:45.123]                       invisible(muffled)
[10:22:45.123]                     }
[10:22:45.123]                     muffleCondition(cond, pattern = "^muffle")
[10:22:45.123]                   }
[10:22:45.123]                 }
[10:22:45.123]             }
[10:22:45.123]         }))
[10:22:45.123]     }, error = function(ex) {
[10:22:45.123]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:45.123]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:45.123]                 ...future.rng), started = ...future.startTime, 
[10:22:45.123]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:45.123]             version = "1.8"), class = "FutureResult")
[10:22:45.123]     }, finally = {
[10:22:45.123]         if (!identical(...future.workdir, getwd())) 
[10:22:45.123]             setwd(...future.workdir)
[10:22:45.123]         {
[10:22:45.123]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:45.123]                 ...future.oldOptions$nwarnings <- NULL
[10:22:45.123]             }
[10:22:45.123]             base::options(...future.oldOptions)
[10:22:45.123]             if (.Platform$OS.type == "windows") {
[10:22:45.123]                 old_names <- names(...future.oldEnvVars)
[10:22:45.123]                 envs <- base::Sys.getenv()
[10:22:45.123]                 names <- names(envs)
[10:22:45.123]                 common <- intersect(names, old_names)
[10:22:45.123]                 added <- setdiff(names, old_names)
[10:22:45.123]                 removed <- setdiff(old_names, names)
[10:22:45.123]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:45.123]                   envs[common]]
[10:22:45.123]                 NAMES <- toupper(changed)
[10:22:45.123]                 args <- list()
[10:22:45.123]                 for (kk in seq_along(NAMES)) {
[10:22:45.123]                   name <- changed[[kk]]
[10:22:45.123]                   NAME <- NAMES[[kk]]
[10:22:45.123]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.123]                     next
[10:22:45.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:45.123]                 }
[10:22:45.123]                 NAMES <- toupper(added)
[10:22:45.123]                 for (kk in seq_along(NAMES)) {
[10:22:45.123]                   name <- added[[kk]]
[10:22:45.123]                   NAME <- NAMES[[kk]]
[10:22:45.123]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.123]                     next
[10:22:45.123]                   args[[name]] <- ""
[10:22:45.123]                 }
[10:22:45.123]                 NAMES <- toupper(removed)
[10:22:45.123]                 for (kk in seq_along(NAMES)) {
[10:22:45.123]                   name <- removed[[kk]]
[10:22:45.123]                   NAME <- NAMES[[kk]]
[10:22:45.123]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.123]                     next
[10:22:45.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:45.123]                 }
[10:22:45.123]                 if (length(args) > 0) 
[10:22:45.123]                   base::do.call(base::Sys.setenv, args = args)
[10:22:45.123]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:45.123]             }
[10:22:45.123]             else {
[10:22:45.123]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:45.123]             }
[10:22:45.123]             {
[10:22:45.123]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:45.123]                   0L) {
[10:22:45.123]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:45.123]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:45.123]                   base::options(opts)
[10:22:45.123]                 }
[10:22:45.123]                 {
[10:22:45.123]                   {
[10:22:45.123]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:45.123]                     NULL
[10:22:45.123]                   }
[10:22:45.123]                   options(future.plan = NULL)
[10:22:45.123]                   if (is.na(NA_character_)) 
[10:22:45.123]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:45.123]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:45.123]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:45.123]                     envir = parent.frame()) 
[10:22:45.123]                   {
[10:22:45.123]                     default_workers <- missing(workers)
[10:22:45.123]                     if (is.function(workers)) 
[10:22:45.123]                       workers <- workers()
[10:22:45.123]                     workers <- structure(as.integer(workers), 
[10:22:45.123]                       class = class(workers))
[10:22:45.123]                     stop_if_not(is.finite(workers), workers >= 
[10:22:45.123]                       1L)
[10:22:45.123]                     if ((workers == 1L && !inherits(workers, 
[10:22:45.123]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:45.123]                       if (default_workers) 
[10:22:45.123]                         supportsMulticore(warn = TRUE)
[10:22:45.123]                       return(sequential(..., envir = envir))
[10:22:45.123]                     }
[10:22:45.123]                     oopts <- options(mc.cores = workers)
[10:22:45.123]                     on.exit(options(oopts))
[10:22:45.123]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:45.123]                       envir = envir)
[10:22:45.123]                     if (!future$lazy) 
[10:22:45.123]                       future <- run(future)
[10:22:45.123]                     invisible(future)
[10:22:45.123]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:45.123]                 }
[10:22:45.123]             }
[10:22:45.123]         }
[10:22:45.123]     })
[10:22:45.123]     if (TRUE) {
[10:22:45.123]         base::sink(type = "output", split = FALSE)
[10:22:45.123]         if (TRUE) {
[10:22:45.123]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:45.123]         }
[10:22:45.123]         else {
[10:22:45.123]             ...future.result["stdout"] <- base::list(NULL)
[10:22:45.123]         }
[10:22:45.123]         base::close(...future.stdout)
[10:22:45.123]         ...future.stdout <- NULL
[10:22:45.123]     }
[10:22:45.123]     ...future.result$conditions <- ...future.conditions
[10:22:45.123]     ...future.result$finished <- base::Sys.time()
[10:22:45.123]     ...future.result
[10:22:45.123] }
[10:22:45.125] assign_globals() ...
[10:22:45.125] List of 5
[10:22:45.125]  $ future.call.arguments    : list()
[10:22:45.125]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:45.125]  $ ...future.FUN            :function (x)  
[10:22:45.125]  $ ...future.elements_ii    :List of 1
[10:22:45.125]   ..$ : int 1
[10:22:45.125]  $ ...future.seeds_ii       : NULL
[10:22:45.125]  $ ...future.globals.maxSize: num Inf
[10:22:45.125]  - attr(*, "resolved")= logi FALSE
[10:22:45.125]  - attr(*, "total_size")= num NA
[10:22:45.125]  - attr(*, "where")=List of 5
[10:22:45.125]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:45.125]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:45.125]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:45.125]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:45.125]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:45.125]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:45.125]  - attr(*, "already-done")= logi TRUE
[10:22:45.130] - copied ‘future.call.arguments’ to environment
[10:22:45.130] - copied ‘...future.FUN’ to environment
[10:22:45.130] - copied ‘...future.elements_ii’ to environment
[10:22:45.130] - copied ‘...future.seeds_ii’ to environment
[10:22:45.130] - copied ‘...future.globals.maxSize’ to environment
[10:22:45.131] assign_globals() ... done
[10:22:45.131] requestCore(): workers = 2
[10:22:45.133] MulticoreFuture started
[10:22:45.133] - Launch lazy future ... done
[10:22:45.133] run() for ‘MulticoreFuture’ ... done
[10:22:45.134] Created future:
[10:22:45.134] plan(): Setting new future strategy stack:
[10:22:45.134] List of future strategies:
[10:22:45.134] 1. sequential:
[10:22:45.134]    - args: function (..., envir = parent.frame())
[10:22:45.134]    - tweaked: FALSE
[10:22:45.134]    - call: NULL
[10:22:45.135] plan(): nbrOfWorkers() = 1
[10:22:45.137] plan(): Setting new future strategy stack:
[10:22:45.137] List of future strategies:
[10:22:45.137] 1. multicore:
[10:22:45.137]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:45.137]    - tweaked: FALSE
[10:22:45.137]    - call: plan(strategy)
[10:22:45.142] plan(): nbrOfWorkers() = 2
[10:22:45.134] MulticoreFuture:
[10:22:45.134] Label: ‘future_apply-1’
[10:22:45.134] Expression:
[10:22:45.134] {
[10:22:45.134]     do.call(function(...) {
[10:22:45.134]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:45.134]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:45.134]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:45.134]             on.exit(options(oopts), add = TRUE)
[10:22:45.134]         }
[10:22:45.134]         {
[10:22:45.134]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:45.134]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:45.134]                 ...future.FUN(...future.X_jj, ...)
[10:22:45.134]             })
[10:22:45.134]         }
[10:22:45.134]     }, args = future.call.arguments)
[10:22:45.134] }
[10:22:45.134] Lazy evaluation: FALSE
[10:22:45.134] Asynchronous evaluation: TRUE
[10:22:45.134] Local evaluation: TRUE
[10:22:45.134] Environment: R_GlobalEnv
[10:22:45.134] Capture standard output: TRUE
[10:22:45.134] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:45.134] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:45.134] Packages: <none>
[10:22:45.134] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:45.134] Resolved: TRUE
[10:22:45.134] Value: <not collected>
[10:22:45.134] Conditions captured: <none>
[10:22:45.134] Early signaling: FALSE
[10:22:45.134] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:45.134] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:45.143] Chunk #1 of 2 ... DONE
[10:22:45.144] Chunk #2 of 2 ...
[10:22:45.144]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:45.144]  - seeds: <none>
[10:22:45.144]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:45.144] getGlobalsAndPackages() ...
[10:22:45.144] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:45.145] Resolving globals: FALSE
[10:22:45.145] Tweak future expression to call with '...' arguments ...
[10:22:45.145] {
[10:22:45.145]     do.call(function(...) {
[10:22:45.145]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:45.145]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:45.145]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:45.145]             on.exit(options(oopts), add = TRUE)
[10:22:45.145]         }
[10:22:45.145]         {
[10:22:45.145]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:45.145]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:45.145]                 ...future.FUN(...future.X_jj, ...)
[10:22:45.145]             })
[10:22:45.145]         }
[10:22:45.145]     }, args = future.call.arguments)
[10:22:45.145] }
[10:22:45.145] Tweak future expression to call with '...' arguments ... DONE
[10:22:45.146] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:45.146] 
[10:22:45.147] getGlobalsAndPackages() ... DONE
[10:22:45.147] run() for ‘Future’ ...
[10:22:45.147] - state: ‘created’
[10:22:45.147] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:45.152] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:45.152] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:45.152]   - Field: ‘label’
[10:22:45.152]   - Field: ‘local’
[10:22:45.153]   - Field: ‘owner’
[10:22:45.153]   - Field: ‘envir’
[10:22:45.153]   - Field: ‘workers’
[10:22:45.153]   - Field: ‘packages’
[10:22:45.153]   - Field: ‘gc’
[10:22:45.153]   - Field: ‘job’
[10:22:45.153]   - Field: ‘conditions’
[10:22:45.154]   - Field: ‘expr’
[10:22:45.154]   - Field: ‘uuid’
[10:22:45.154]   - Field: ‘seed’
[10:22:45.154]   - Field: ‘version’
[10:22:45.154]   - Field: ‘result’
[10:22:45.154]   - Field: ‘asynchronous’
[10:22:45.155]   - Field: ‘calls’
[10:22:45.155]   - Field: ‘globals’
[10:22:45.155]   - Field: ‘stdout’
[10:22:45.155]   - Field: ‘earlySignal’
[10:22:45.155]   - Field: ‘lazy’
[10:22:45.155]   - Field: ‘state’
[10:22:45.155] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:45.155] - Launch lazy future ...
[10:22:45.156] Packages needed by the future expression (n = 0): <none>
[10:22:45.156] Packages needed by future strategies (n = 0): <none>
[10:22:45.157] {
[10:22:45.157]     {
[10:22:45.157]         {
[10:22:45.157]             ...future.startTime <- base::Sys.time()
[10:22:45.157]             {
[10:22:45.157]                 {
[10:22:45.157]                   {
[10:22:45.157]                     {
[10:22:45.157]                       base::local({
[10:22:45.157]                         has_future <- base::requireNamespace("future", 
[10:22:45.157]                           quietly = TRUE)
[10:22:45.157]                         if (has_future) {
[10:22:45.157]                           ns <- base::getNamespace("future")
[10:22:45.157]                           version <- ns[[".package"]][["version"]]
[10:22:45.157]                           if (is.null(version)) 
[10:22:45.157]                             version <- utils::packageVersion("future")
[10:22:45.157]                         }
[10:22:45.157]                         else {
[10:22:45.157]                           version <- NULL
[10:22:45.157]                         }
[10:22:45.157]                         if (!has_future || version < "1.8.0") {
[10:22:45.157]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:45.157]                             "", base::R.version$version.string), 
[10:22:45.157]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:45.157]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:45.157]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:45.157]                               "release", "version")], collapse = " "), 
[10:22:45.157]                             hostname = base::Sys.info()[["nodename"]])
[10:22:45.157]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:45.157]                             info)
[10:22:45.157]                           info <- base::paste(info, collapse = "; ")
[10:22:45.157]                           if (!has_future) {
[10:22:45.157]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:45.157]                               info)
[10:22:45.157]                           }
[10:22:45.157]                           else {
[10:22:45.157]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:45.157]                               info, version)
[10:22:45.157]                           }
[10:22:45.157]                           base::stop(msg)
[10:22:45.157]                         }
[10:22:45.157]                       })
[10:22:45.157]                     }
[10:22:45.157]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:45.157]                     base::options(mc.cores = 1L)
[10:22:45.157]                   }
[10:22:45.157]                   options(future.plan = NULL)
[10:22:45.157]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:45.157]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:45.157]                 }
[10:22:45.157]                 ...future.workdir <- getwd()
[10:22:45.157]             }
[10:22:45.157]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:45.157]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:45.157]         }
[10:22:45.157]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:45.157]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:45.157]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:45.157]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:45.157]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:45.157]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:45.157]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:45.157]             base::names(...future.oldOptions))
[10:22:45.157]     }
[10:22:45.157]     if (FALSE) {
[10:22:45.157]     }
[10:22:45.157]     else {
[10:22:45.157]         if (TRUE) {
[10:22:45.157]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:45.157]                 open = "w")
[10:22:45.157]         }
[10:22:45.157]         else {
[10:22:45.157]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:45.157]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:45.157]         }
[10:22:45.157]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:45.157]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:45.157]             base::sink(type = "output", split = FALSE)
[10:22:45.157]             base::close(...future.stdout)
[10:22:45.157]         }, add = TRUE)
[10:22:45.157]     }
[10:22:45.157]     ...future.frame <- base::sys.nframe()
[10:22:45.157]     ...future.conditions <- base::list()
[10:22:45.157]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:45.157]     if (FALSE) {
[10:22:45.157]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:45.157]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:45.157]     }
[10:22:45.157]     ...future.result <- base::tryCatch({
[10:22:45.157]         base::withCallingHandlers({
[10:22:45.157]             ...future.value <- base::withVisible(base::local({
[10:22:45.157]                 withCallingHandlers({
[10:22:45.157]                   {
[10:22:45.157]                     do.call(function(...) {
[10:22:45.157]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:45.157]                       if (!identical(...future.globals.maxSize.org, 
[10:22:45.157]                         ...future.globals.maxSize)) {
[10:22:45.157]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:45.157]                         on.exit(options(oopts), add = TRUE)
[10:22:45.157]                       }
[10:22:45.157]                       {
[10:22:45.157]                         lapply(seq_along(...future.elements_ii), 
[10:22:45.157]                           FUN = function(jj) {
[10:22:45.157]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:45.157]                             ...future.FUN(...future.X_jj, ...)
[10:22:45.157]                           })
[10:22:45.157]                       }
[10:22:45.157]                     }, args = future.call.arguments)
[10:22:45.157]                   }
[10:22:45.157]                 }, immediateCondition = function(cond) {
[10:22:45.157]                   save_rds <- function (object, pathname, ...) 
[10:22:45.157]                   {
[10:22:45.157]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:45.157]                     if (file_test("-f", pathname_tmp)) {
[10:22:45.157]                       fi_tmp <- file.info(pathname_tmp)
[10:22:45.157]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:45.157]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:45.157]                         fi_tmp[["mtime"]])
[10:22:45.157]                     }
[10:22:45.157]                     tryCatch({
[10:22:45.157]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:45.157]                     }, error = function(ex) {
[10:22:45.157]                       msg <- conditionMessage(ex)
[10:22:45.157]                       fi_tmp <- file.info(pathname_tmp)
[10:22:45.157]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:45.157]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:45.157]                         fi_tmp[["mtime"]], msg)
[10:22:45.157]                       ex$message <- msg
[10:22:45.157]                       stop(ex)
[10:22:45.157]                     })
[10:22:45.157]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:45.157]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:45.157]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:45.157]                       fi_tmp <- file.info(pathname_tmp)
[10:22:45.157]                       fi <- file.info(pathname)
[10:22:45.157]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:45.157]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:45.157]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:45.157]                         fi[["size"]], fi[["mtime"]])
[10:22:45.157]                       stop(msg)
[10:22:45.157]                     }
[10:22:45.157]                     invisible(pathname)
[10:22:45.157]                   }
[10:22:45.157]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:45.157]                     rootPath = tempdir()) 
[10:22:45.157]                   {
[10:22:45.157]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:45.157]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:45.157]                       tmpdir = path, fileext = ".rds")
[10:22:45.157]                     save_rds(obj, file)
[10:22:45.157]                   }
[10:22:45.157]                   saveImmediateCondition(cond, path = "/tmp/RtmpTHXGJm/.future/immediateConditions")
[10:22:45.157]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.157]                   {
[10:22:45.157]                     inherits <- base::inherits
[10:22:45.157]                     invokeRestart <- base::invokeRestart
[10:22:45.157]                     is.null <- base::is.null
[10:22:45.157]                     muffled <- FALSE
[10:22:45.157]                     if (inherits(cond, "message")) {
[10:22:45.157]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:45.157]                       if (muffled) 
[10:22:45.157]                         invokeRestart("muffleMessage")
[10:22:45.157]                     }
[10:22:45.157]                     else if (inherits(cond, "warning")) {
[10:22:45.157]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:45.157]                       if (muffled) 
[10:22:45.157]                         invokeRestart("muffleWarning")
[10:22:45.157]                     }
[10:22:45.157]                     else if (inherits(cond, "condition")) {
[10:22:45.157]                       if (!is.null(pattern)) {
[10:22:45.157]                         computeRestarts <- base::computeRestarts
[10:22:45.157]                         grepl <- base::grepl
[10:22:45.157]                         restarts <- computeRestarts(cond)
[10:22:45.157]                         for (restart in restarts) {
[10:22:45.157]                           name <- restart$name
[10:22:45.157]                           if (is.null(name)) 
[10:22:45.157]                             next
[10:22:45.157]                           if (!grepl(pattern, name)) 
[10:22:45.157]                             next
[10:22:45.157]                           invokeRestart(restart)
[10:22:45.157]                           muffled <- TRUE
[10:22:45.157]                           break
[10:22:45.157]                         }
[10:22:45.157]                       }
[10:22:45.157]                     }
[10:22:45.157]                     invisible(muffled)
[10:22:45.157]                   }
[10:22:45.157]                   muffleCondition(cond)
[10:22:45.157]                 })
[10:22:45.157]             }))
[10:22:45.157]             future::FutureResult(value = ...future.value$value, 
[10:22:45.157]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:45.157]                   ...future.rng), globalenv = if (FALSE) 
[10:22:45.157]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:45.157]                     ...future.globalenv.names))
[10:22:45.157]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:45.157]         }, condition = base::local({
[10:22:45.157]             c <- base::c
[10:22:45.157]             inherits <- base::inherits
[10:22:45.157]             invokeRestart <- base::invokeRestart
[10:22:45.157]             length <- base::length
[10:22:45.157]             list <- base::list
[10:22:45.157]             seq.int <- base::seq.int
[10:22:45.157]             signalCondition <- base::signalCondition
[10:22:45.157]             sys.calls <- base::sys.calls
[10:22:45.157]             `[[` <- base::`[[`
[10:22:45.157]             `+` <- base::`+`
[10:22:45.157]             `<<-` <- base::`<<-`
[10:22:45.157]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:45.157]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:45.157]                   3L)]
[10:22:45.157]             }
[10:22:45.157]             function(cond) {
[10:22:45.157]                 is_error <- inherits(cond, "error")
[10:22:45.157]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:45.157]                   NULL)
[10:22:45.157]                 if (is_error) {
[10:22:45.157]                   sessionInformation <- function() {
[10:22:45.157]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:45.157]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:45.157]                       search = base::search(), system = base::Sys.info())
[10:22:45.157]                   }
[10:22:45.157]                   ...future.conditions[[length(...future.conditions) + 
[10:22:45.157]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:45.157]                     cond$call), session = sessionInformation(), 
[10:22:45.157]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:45.157]                   signalCondition(cond)
[10:22:45.157]                 }
[10:22:45.157]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:45.157]                 "immediateCondition"))) {
[10:22:45.157]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:45.157]                   ...future.conditions[[length(...future.conditions) + 
[10:22:45.157]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:45.157]                   if (TRUE && !signal) {
[10:22:45.157]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.157]                     {
[10:22:45.157]                       inherits <- base::inherits
[10:22:45.157]                       invokeRestart <- base::invokeRestart
[10:22:45.157]                       is.null <- base::is.null
[10:22:45.157]                       muffled <- FALSE
[10:22:45.157]                       if (inherits(cond, "message")) {
[10:22:45.157]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:45.157]                         if (muffled) 
[10:22:45.157]                           invokeRestart("muffleMessage")
[10:22:45.157]                       }
[10:22:45.157]                       else if (inherits(cond, "warning")) {
[10:22:45.157]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:45.157]                         if (muffled) 
[10:22:45.157]                           invokeRestart("muffleWarning")
[10:22:45.157]                       }
[10:22:45.157]                       else if (inherits(cond, "condition")) {
[10:22:45.157]                         if (!is.null(pattern)) {
[10:22:45.157]                           computeRestarts <- base::computeRestarts
[10:22:45.157]                           grepl <- base::grepl
[10:22:45.157]                           restarts <- computeRestarts(cond)
[10:22:45.157]                           for (restart in restarts) {
[10:22:45.157]                             name <- restart$name
[10:22:45.157]                             if (is.null(name)) 
[10:22:45.157]                               next
[10:22:45.157]                             if (!grepl(pattern, name)) 
[10:22:45.157]                               next
[10:22:45.157]                             invokeRestart(restart)
[10:22:45.157]                             muffled <- TRUE
[10:22:45.157]                             break
[10:22:45.157]                           }
[10:22:45.157]                         }
[10:22:45.157]                       }
[10:22:45.157]                       invisible(muffled)
[10:22:45.157]                     }
[10:22:45.157]                     muffleCondition(cond, pattern = "^muffle")
[10:22:45.157]                   }
[10:22:45.157]                 }
[10:22:45.157]                 else {
[10:22:45.157]                   if (TRUE) {
[10:22:45.157]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.157]                     {
[10:22:45.157]                       inherits <- base::inherits
[10:22:45.157]                       invokeRestart <- base::invokeRestart
[10:22:45.157]                       is.null <- base::is.null
[10:22:45.157]                       muffled <- FALSE
[10:22:45.157]                       if (inherits(cond, "message")) {
[10:22:45.157]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:45.157]                         if (muffled) 
[10:22:45.157]                           invokeRestart("muffleMessage")
[10:22:45.157]                       }
[10:22:45.157]                       else if (inherits(cond, "warning")) {
[10:22:45.157]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:45.157]                         if (muffled) 
[10:22:45.157]                           invokeRestart("muffleWarning")
[10:22:45.157]                       }
[10:22:45.157]                       else if (inherits(cond, "condition")) {
[10:22:45.157]                         if (!is.null(pattern)) {
[10:22:45.157]                           computeRestarts <- base::computeRestarts
[10:22:45.157]                           grepl <- base::grepl
[10:22:45.157]                           restarts <- computeRestarts(cond)
[10:22:45.157]                           for (restart in restarts) {
[10:22:45.157]                             name <- restart$name
[10:22:45.157]                             if (is.null(name)) 
[10:22:45.157]                               next
[10:22:45.157]                             if (!grepl(pattern, name)) 
[10:22:45.157]                               next
[10:22:45.157]                             invokeRestart(restart)
[10:22:45.157]                             muffled <- TRUE
[10:22:45.157]                             break
[10:22:45.157]                           }
[10:22:45.157]                         }
[10:22:45.157]                       }
[10:22:45.157]                       invisible(muffled)
[10:22:45.157]                     }
[10:22:45.157]                     muffleCondition(cond, pattern = "^muffle")
[10:22:45.157]                   }
[10:22:45.157]                 }
[10:22:45.157]             }
[10:22:45.157]         }))
[10:22:45.157]     }, error = function(ex) {
[10:22:45.157]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:45.157]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:45.157]                 ...future.rng), started = ...future.startTime, 
[10:22:45.157]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:45.157]             version = "1.8"), class = "FutureResult")
[10:22:45.157]     }, finally = {
[10:22:45.157]         if (!identical(...future.workdir, getwd())) 
[10:22:45.157]             setwd(...future.workdir)
[10:22:45.157]         {
[10:22:45.157]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:45.157]                 ...future.oldOptions$nwarnings <- NULL
[10:22:45.157]             }
[10:22:45.157]             base::options(...future.oldOptions)
[10:22:45.157]             if (.Platform$OS.type == "windows") {
[10:22:45.157]                 old_names <- names(...future.oldEnvVars)
[10:22:45.157]                 envs <- base::Sys.getenv()
[10:22:45.157]                 names <- names(envs)
[10:22:45.157]                 common <- intersect(names, old_names)
[10:22:45.157]                 added <- setdiff(names, old_names)
[10:22:45.157]                 removed <- setdiff(old_names, names)
[10:22:45.157]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:45.157]                   envs[common]]
[10:22:45.157]                 NAMES <- toupper(changed)
[10:22:45.157]                 args <- list()
[10:22:45.157]                 for (kk in seq_along(NAMES)) {
[10:22:45.157]                   name <- changed[[kk]]
[10:22:45.157]                   NAME <- NAMES[[kk]]
[10:22:45.157]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.157]                     next
[10:22:45.157]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:45.157]                 }
[10:22:45.157]                 NAMES <- toupper(added)
[10:22:45.157]                 for (kk in seq_along(NAMES)) {
[10:22:45.157]                   name <- added[[kk]]
[10:22:45.157]                   NAME <- NAMES[[kk]]
[10:22:45.157]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.157]                     next
[10:22:45.157]                   args[[name]] <- ""
[10:22:45.157]                 }
[10:22:45.157]                 NAMES <- toupper(removed)
[10:22:45.157]                 for (kk in seq_along(NAMES)) {
[10:22:45.157]                   name <- removed[[kk]]
[10:22:45.157]                   NAME <- NAMES[[kk]]
[10:22:45.157]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.157]                     next
[10:22:45.157]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:45.157]                 }
[10:22:45.157]                 if (length(args) > 0) 
[10:22:45.157]                   base::do.call(base::Sys.setenv, args = args)
[10:22:45.157]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:45.157]             }
[10:22:45.157]             else {
[10:22:45.157]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:45.157]             }
[10:22:45.157]             {
[10:22:45.157]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:45.157]                   0L) {
[10:22:45.157]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:45.157]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:45.157]                   base::options(opts)
[10:22:45.157]                 }
[10:22:45.157]                 {
[10:22:45.157]                   {
[10:22:45.157]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:45.157]                     NULL
[10:22:45.157]                   }
[10:22:45.157]                   options(future.plan = NULL)
[10:22:45.157]                   if (is.na(NA_character_)) 
[10:22:45.157]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:45.157]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:45.157]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:45.157]                     envir = parent.frame()) 
[10:22:45.157]                   {
[10:22:45.157]                     default_workers <- missing(workers)
[10:22:45.157]                     if (is.function(workers)) 
[10:22:45.157]                       workers <- workers()
[10:22:45.157]                     workers <- structure(as.integer(workers), 
[10:22:45.157]                       class = class(workers))
[10:22:45.157]                     stop_if_not(is.finite(workers), workers >= 
[10:22:45.157]                       1L)
[10:22:45.157]                     if ((workers == 1L && !inherits(workers, 
[10:22:45.157]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:45.157]                       if (default_workers) 
[10:22:45.157]                         supportsMulticore(warn = TRUE)
[10:22:45.157]                       return(sequential(..., envir = envir))
[10:22:45.157]                     }
[10:22:45.157]                     oopts <- options(mc.cores = workers)
[10:22:45.157]                     on.exit(options(oopts))
[10:22:45.157]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:45.157]                       envir = envir)
[10:22:45.157]                     if (!future$lazy) 
[10:22:45.157]                       future <- run(future)
[10:22:45.157]                     invisible(future)
[10:22:45.157]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:45.157]                 }
[10:22:45.157]             }
[10:22:45.157]         }
[10:22:45.157]     })
[10:22:45.157]     if (TRUE) {
[10:22:45.157]         base::sink(type = "output", split = FALSE)
[10:22:45.157]         if (TRUE) {
[10:22:45.157]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:45.157]         }
[10:22:45.157]         else {
[10:22:45.157]             ...future.result["stdout"] <- base::list(NULL)
[10:22:45.157]         }
[10:22:45.157]         base::close(...future.stdout)
[10:22:45.157]         ...future.stdout <- NULL
[10:22:45.157]     }
[10:22:45.157]     ...future.result$conditions <- ...future.conditions
[10:22:45.157]     ...future.result$finished <- base::Sys.time()
[10:22:45.157]     ...future.result
[10:22:45.157] }
[10:22:45.160] assign_globals() ...
[10:22:45.163] List of 5
[10:22:45.163]  $ future.call.arguments    : list()
[10:22:45.163]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:45.163]  $ ...future.FUN            :function (x)  
[10:22:45.163]  $ ...future.elements_ii    :List of 1
[10:22:45.163]   ..$ : int 2
[10:22:45.163]  $ ...future.seeds_ii       : NULL
[10:22:45.163]  $ ...future.globals.maxSize: num Inf
[10:22:45.163]  - attr(*, "resolved")= logi FALSE
[10:22:45.163]  - attr(*, "total_size")= num NA
[10:22:45.163]  - attr(*, "where")=List of 5
[10:22:45.163]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:45.163]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:45.163]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:45.163]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:45.163]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:45.163]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:45.163]  - attr(*, "already-done")= logi TRUE
[10:22:45.173] - copied ‘future.call.arguments’ to environment
[10:22:45.174] - copied ‘...future.FUN’ to environment
[10:22:45.174] - copied ‘...future.elements_ii’ to environment
[10:22:45.174] - copied ‘...future.seeds_ii’ to environment
[10:22:45.174] - copied ‘...future.globals.maxSize’ to environment
[10:22:45.174] assign_globals() ... done
[10:22:45.174] requestCore(): workers = 2
[10:22:45.177] MulticoreFuture started
[10:22:45.177] - Launch lazy future ... done
[10:22:45.177] run() for ‘MulticoreFuture’ ... done
[10:22:45.178] Created future:
[10:22:45.178] plan(): Setting new future strategy stack:
[10:22:45.178] List of future strategies:
[10:22:45.178] 1. sequential:
[10:22:45.178]    - args: function (..., envir = parent.frame())
[10:22:45.178]    - tweaked: FALSE
[10:22:45.178]    - call: NULL
[10:22:45.179] plan(): nbrOfWorkers() = 1
[10:22:45.181] plan(): Setting new future strategy stack:
[10:22:45.181] List of future strategies:
[10:22:45.181] 1. multicore:
[10:22:45.181]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:45.181]    - tweaked: FALSE
[10:22:45.181]    - call: plan(strategy)
[10:22:45.186] plan(): nbrOfWorkers() = 2
[10:22:45.178] MulticoreFuture:
[10:22:45.178] Label: ‘future_apply-2’
[10:22:45.178] Expression:
[10:22:45.178] {
[10:22:45.178]     do.call(function(...) {
[10:22:45.178]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:45.178]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:45.178]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:45.178]             on.exit(options(oopts), add = TRUE)
[10:22:45.178]         }
[10:22:45.178]         {
[10:22:45.178]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:45.178]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:45.178]                 ...future.FUN(...future.X_jj, ...)
[10:22:45.178]             })
[10:22:45.178]         }
[10:22:45.178]     }, args = future.call.arguments)
[10:22:45.178] }
[10:22:45.178] Lazy evaluation: FALSE
[10:22:45.178] Asynchronous evaluation: TRUE
[10:22:45.178] Local evaluation: TRUE
[10:22:45.178] Environment: R_GlobalEnv
[10:22:45.178] Capture standard output: TRUE
[10:22:45.178] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:45.178] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:45.178] Packages: <none>
[10:22:45.178] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:45.178] Resolved: TRUE
[10:22:45.178] Value: <not collected>
[10:22:45.178] Conditions captured: <none>
[10:22:45.178] Early signaling: FALSE
[10:22:45.178] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:45.178] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:45.188] Chunk #2 of 2 ... DONE
[10:22:45.188] Launching 2 futures (chunks) ... DONE
[10:22:45.188] Resolving 2 futures (chunks) ...
[10:22:45.188] resolve() on list ...
[10:22:45.188]  recursive: 0
[10:22:45.188]  length: 2
[10:22:45.189] 
[10:22:45.189] Future #1
[10:22:45.189] result() for MulticoreFuture ...
[10:22:45.190] result() for MulticoreFuture ...
[10:22:45.190] result() for MulticoreFuture ... done
[10:22:45.190] result() for MulticoreFuture ... done
[10:22:45.191] result() for MulticoreFuture ...
[10:22:45.191] result() for MulticoreFuture ... done
[10:22:45.191] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:22:45.191] - nx: 2
[10:22:45.191] - relay: TRUE
[10:22:45.191] - stdout: TRUE
[10:22:45.191] - signal: TRUE
[10:22:45.192] - resignal: FALSE
[10:22:45.192] - force: TRUE
[10:22:45.192] - relayed: [n=2] FALSE, FALSE
[10:22:45.192] - queued futures: [n=2] FALSE, FALSE
[10:22:45.192]  - until=1
[10:22:45.192]  - relaying element #1
[10:22:45.192] result() for MulticoreFuture ...
[10:22:45.193] result() for MulticoreFuture ... done
[10:22:45.193] result() for MulticoreFuture ...
[10:22:45.193] result() for MulticoreFuture ... done
[10:22:45.193] result() for MulticoreFuture ...
[10:22:45.193] result() for MulticoreFuture ... done
[10:22:45.194] result() for MulticoreFuture ...
[10:22:45.194] result() for MulticoreFuture ... done
[10:22:45.194] - relayed: [n=2] TRUE, FALSE
[10:22:45.194] - queued futures: [n=2] TRUE, FALSE
[10:22:45.194] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:22:45.194]  length: 1 (resolved future 1)
[10:22:45.195] Future #2
[10:22:45.195] result() for MulticoreFuture ...
[10:22:45.196] result() for MulticoreFuture ...
[10:22:45.196] result() for MulticoreFuture ... done
[10:22:45.196] result() for MulticoreFuture ... done
[10:22:45.196] result() for MulticoreFuture ...
[10:22:45.196] result() for MulticoreFuture ... done
[10:22:45.196] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:22:45.196] - nx: 2
[10:22:45.197] - relay: TRUE
[10:22:45.197] - stdout: TRUE
[10:22:45.197] - signal: TRUE
[10:22:45.197] - resignal: FALSE
[10:22:45.197] - force: TRUE
[10:22:45.197] - relayed: [n=2] TRUE, FALSE
[10:22:45.197] - queued futures: [n=2] TRUE, FALSE
[10:22:45.197]  - until=2
[10:22:45.198]  - relaying element #2
[10:22:45.198] result() for MulticoreFuture ...
[10:22:45.198] result() for MulticoreFuture ... done
[10:22:45.198] result() for MulticoreFuture ...
[10:22:45.198] result() for MulticoreFuture ... done
[10:22:45.198] result() for MulticoreFuture ...
[10:22:45.198] result() for MulticoreFuture ... done
[10:22:45.199] result() for MulticoreFuture ...
[10:22:45.199] result() for MulticoreFuture ... done
[10:22:45.199] - relayed: [n=2] TRUE, TRUE
[10:22:45.199] - queued futures: [n=2] TRUE, TRUE
[10:22:45.199] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:22:45.199]  length: 0 (resolved future 2)
[10:22:45.199] Relaying remaining futures
[10:22:45.199] signalConditionsASAP(NULL, pos=0) ...
[10:22:45.199] - nx: 2
[10:22:45.200] - relay: TRUE
[10:22:45.200] - stdout: TRUE
[10:22:45.200] - signal: TRUE
[10:22:45.200] - resignal: FALSE
[10:22:45.200] - force: TRUE
[10:22:45.200] - relayed: [n=2] TRUE, TRUE
[10:22:45.200] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:22:45.200] - relayed: [n=2] TRUE, TRUE
[10:22:45.200] - queued futures: [n=2] TRUE, TRUE
[10:22:45.201] signalConditionsASAP(NULL, pos=0) ... done
[10:22:45.201] resolve() on list ... DONE
[10:22:45.201] result() for MulticoreFuture ...
[10:22:45.201] result() for MulticoreFuture ... done
[10:22:45.201] result() for MulticoreFuture ...
[10:22:45.201] result() for MulticoreFuture ... done
[10:22:45.201] result() for MulticoreFuture ...
[10:22:45.201] result() for MulticoreFuture ... done
[10:22:45.201] result() for MulticoreFuture ...
[10:22:45.202] result() for MulticoreFuture ... done
[10:22:45.202]  - Number of value chunks collected: 2
[10:22:45.202] Resolving 2 futures (chunks) ... DONE
[10:22:45.202] Reducing values from 2 chunks ...
[10:22:45.202]  - Number of values collected after concatenation: 2
[10:22:45.202]  - Number of values expected: 2
[10:22:45.202] Reducing values from 2 chunks ... DONE
[10:22:45.202] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[10:22:45.203] getGlobalsAndPackagesXApply() ...
[10:22:45.203]  - future.globals: TRUE
[10:22:45.203] getGlobalsAndPackages() ...
[10:22:45.203] Searching for globals...
[10:22:45.204] - globals found: [1] ‘FUN’
[10:22:45.207] Searching for globals ... DONE
[10:22:45.207] Resolving globals: FALSE
[10:22:45.207] The total size of the 1 globals is 848 bytes (848 bytes)
[10:22:45.208] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:22:45.208] - globals: [1] ‘FUN’
[10:22:45.208] 
[10:22:45.208] getGlobalsAndPackages() ... DONE
[10:22:45.209]  - globals found/used: [n=1] ‘FUN’
[10:22:45.209]  - needed namespaces: [n=0] 
[10:22:45.209] Finding globals ... DONE
[10:22:45.209]  - use_args: TRUE
[10:22:45.209]  - Getting '...' globals ...
[10:22:45.210] resolve() on list ...
[10:22:45.210]  recursive: 0
[10:22:45.210]  length: 1
[10:22:45.210]  elements: ‘...’
[10:22:45.210]  length: 0 (resolved future 1)
[10:22:45.210] resolve() on list ... DONE
[10:22:45.211]    - '...' content: [n=0] 
[10:22:45.211] List of 1
[10:22:45.211]  $ ...: list()
[10:22:45.211]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:45.211]  - attr(*, "where")=List of 1
[10:22:45.211]   ..$ ...:<environment: 0x55ca4d1c0e60> 
[10:22:45.211]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:45.211]  - attr(*, "resolved")= logi TRUE
[10:22:45.211]  - attr(*, "total_size")= num NA
[10:22:45.214]  - Getting '...' globals ... DONE
[10:22:45.214] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:45.214] List of 2
[10:22:45.214]  $ ...future.FUN:function (x)  
[10:22:45.214]  $ ...          : list()
[10:22:45.214]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:45.214]  - attr(*, "where")=List of 2
[10:22:45.214]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:45.214]   ..$ ...          :<environment: 0x55ca4d1c0e60> 
[10:22:45.214]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:45.214]  - attr(*, "resolved")= logi FALSE
[10:22:45.214]  - attr(*, "total_size")= num 848
[10:22:45.217] Packages to be attached in all futures: [n=0] 
[10:22:45.217] getGlobalsAndPackagesXApply() ... DONE
[10:22:45.221] future_lapply() ...
[10:22:45.225] Number of chunks: 2
[10:22:45.225] getGlobalsAndPackagesXApply() ...
[10:22:45.225]  - future.globals: <name-value list> with names ‘list()’
[10:22:45.225]  - use_args: TRUE
[10:22:45.225] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:22:45.225] List of 2
[10:22:45.225]  $ ...          : list()
[10:22:45.225]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:45.225]  $ ...future.FUN:function (x)  
[10:22:45.225]  - attr(*, "where")=List of 2
[10:22:45.225]   ..$ ...          :<environment: 0x55ca4d1c0e60> 
[10:22:45.225]   ..$ ...future.FUN:<environment: namespace:base> 
[10:22:45.225]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:45.225]  - attr(*, "resolved")= logi FALSE
[10:22:45.225]  - attr(*, "total_size")= num NA
[10:22:45.229] Packages to be attached in all futures: [n=0] 
[10:22:45.229] getGlobalsAndPackagesXApply() ... DONE
[10:22:45.229] Number of futures (= number of chunks): 2
[10:22:45.229] Launching 2 futures (chunks) ...
[10:22:45.229] Chunk #1 of 2 ...
[10:22:45.229]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:45.230]  - seeds: <none>
[10:22:45.230]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:45.230] getGlobalsAndPackages() ...
[10:22:45.230] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:45.230] Resolving globals: FALSE
[10:22:45.230] Tweak future expression to call with '...' arguments ...
[10:22:45.230] {
[10:22:45.230]     do.call(function(...) {
[10:22:45.230]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:45.230]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:45.230]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:45.230]             on.exit(options(oopts), add = TRUE)
[10:22:45.230]         }
[10:22:45.230]         {
[10:22:45.230]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:45.230]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:45.230]                 ...future.FUN(...future.X_jj, ...)
[10:22:45.230]             })
[10:22:45.230]         }
[10:22:45.230]     }, args = future.call.arguments)
[10:22:45.230] }
[10:22:45.230] Tweak future expression to call with '...' arguments ... DONE
[10:22:45.231] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:45.231] 
[10:22:45.231] getGlobalsAndPackages() ... DONE
[10:22:45.231] run() for ‘Future’ ...
[10:22:45.231] - state: ‘created’
[10:22:45.232] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:45.235] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:45.235] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:45.235]   - Field: ‘label’
[10:22:45.236]   - Field: ‘local’
[10:22:45.238]   - Field: ‘owner’
[10:22:45.238]   - Field: ‘envir’
[10:22:45.238]   - Field: ‘workers’
[10:22:45.238]   - Field: ‘packages’
[10:22:45.238]   - Field: ‘gc’
[10:22:45.238]   - Field: ‘job’
[10:22:45.238]   - Field: ‘conditions’
[10:22:45.238]   - Field: ‘expr’
[10:22:45.239]   - Field: ‘uuid’
[10:22:45.239]   - Field: ‘seed’
[10:22:45.239]   - Field: ‘version’
[10:22:45.239]   - Field: ‘result’
[10:22:45.239]   - Field: ‘asynchronous’
[10:22:45.239]   - Field: ‘calls’
[10:22:45.239]   - Field: ‘globals’
[10:22:45.239]   - Field: ‘stdout’
[10:22:45.239]   - Field: ‘earlySignal’
[10:22:45.240]   - Field: ‘lazy’
[10:22:45.240]   - Field: ‘state’
[10:22:45.240] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:45.240] - Launch lazy future ...
[10:22:45.240] Packages needed by the future expression (n = 0): <none>
[10:22:45.241] Packages needed by future strategies (n = 0): <none>
[10:22:45.241] {
[10:22:45.241]     {
[10:22:45.241]         {
[10:22:45.241]             ...future.startTime <- base::Sys.time()
[10:22:45.241]             {
[10:22:45.241]                 {
[10:22:45.241]                   {
[10:22:45.241]                     {
[10:22:45.241]                       base::local({
[10:22:45.241]                         has_future <- base::requireNamespace("future", 
[10:22:45.241]                           quietly = TRUE)
[10:22:45.241]                         if (has_future) {
[10:22:45.241]                           ns <- base::getNamespace("future")
[10:22:45.241]                           version <- ns[[".package"]][["version"]]
[10:22:45.241]                           if (is.null(version)) 
[10:22:45.241]                             version <- utils::packageVersion("future")
[10:22:45.241]                         }
[10:22:45.241]                         else {
[10:22:45.241]                           version <- NULL
[10:22:45.241]                         }
[10:22:45.241]                         if (!has_future || version < "1.8.0") {
[10:22:45.241]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:45.241]                             "", base::R.version$version.string), 
[10:22:45.241]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:45.241]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:45.241]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:45.241]                               "release", "version")], collapse = " "), 
[10:22:45.241]                             hostname = base::Sys.info()[["nodename"]])
[10:22:45.241]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:45.241]                             info)
[10:22:45.241]                           info <- base::paste(info, collapse = "; ")
[10:22:45.241]                           if (!has_future) {
[10:22:45.241]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:45.241]                               info)
[10:22:45.241]                           }
[10:22:45.241]                           else {
[10:22:45.241]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:45.241]                               info, version)
[10:22:45.241]                           }
[10:22:45.241]                           base::stop(msg)
[10:22:45.241]                         }
[10:22:45.241]                       })
[10:22:45.241]                     }
[10:22:45.241]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:45.241]                     base::options(mc.cores = 1L)
[10:22:45.241]                   }
[10:22:45.241]                   options(future.plan = NULL)
[10:22:45.241]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:45.241]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:45.241]                 }
[10:22:45.241]                 ...future.workdir <- getwd()
[10:22:45.241]             }
[10:22:45.241]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:45.241]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:45.241]         }
[10:22:45.241]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:45.241]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:45.241]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:45.241]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:45.241]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:45.241]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:45.241]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:45.241]             base::names(...future.oldOptions))
[10:22:45.241]     }
[10:22:45.241]     if (FALSE) {
[10:22:45.241]     }
[10:22:45.241]     else {
[10:22:45.241]         if (TRUE) {
[10:22:45.241]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:45.241]                 open = "w")
[10:22:45.241]         }
[10:22:45.241]         else {
[10:22:45.241]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:45.241]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:45.241]         }
[10:22:45.241]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:45.241]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:45.241]             base::sink(type = "output", split = FALSE)
[10:22:45.241]             base::close(...future.stdout)
[10:22:45.241]         }, add = TRUE)
[10:22:45.241]     }
[10:22:45.241]     ...future.frame <- base::sys.nframe()
[10:22:45.241]     ...future.conditions <- base::list()
[10:22:45.241]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:45.241]     if (FALSE) {
[10:22:45.241]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:45.241]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:45.241]     }
[10:22:45.241]     ...future.result <- base::tryCatch({
[10:22:45.241]         base::withCallingHandlers({
[10:22:45.241]             ...future.value <- base::withVisible(base::local({
[10:22:45.241]                 withCallingHandlers({
[10:22:45.241]                   {
[10:22:45.241]                     do.call(function(...) {
[10:22:45.241]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:45.241]                       if (!identical(...future.globals.maxSize.org, 
[10:22:45.241]                         ...future.globals.maxSize)) {
[10:22:45.241]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:45.241]                         on.exit(options(oopts), add = TRUE)
[10:22:45.241]                       }
[10:22:45.241]                       {
[10:22:45.241]                         lapply(seq_along(...future.elements_ii), 
[10:22:45.241]                           FUN = function(jj) {
[10:22:45.241]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:45.241]                             ...future.FUN(...future.X_jj, ...)
[10:22:45.241]                           })
[10:22:45.241]                       }
[10:22:45.241]                     }, args = future.call.arguments)
[10:22:45.241]                   }
[10:22:45.241]                 }, immediateCondition = function(cond) {
[10:22:45.241]                   save_rds <- function (object, pathname, ...) 
[10:22:45.241]                   {
[10:22:45.241]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:45.241]                     if (file_test("-f", pathname_tmp)) {
[10:22:45.241]                       fi_tmp <- file.info(pathname_tmp)
[10:22:45.241]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:45.241]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:45.241]                         fi_tmp[["mtime"]])
[10:22:45.241]                     }
[10:22:45.241]                     tryCatch({
[10:22:45.241]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:45.241]                     }, error = function(ex) {
[10:22:45.241]                       msg <- conditionMessage(ex)
[10:22:45.241]                       fi_tmp <- file.info(pathname_tmp)
[10:22:45.241]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:45.241]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:45.241]                         fi_tmp[["mtime"]], msg)
[10:22:45.241]                       ex$message <- msg
[10:22:45.241]                       stop(ex)
[10:22:45.241]                     })
[10:22:45.241]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:45.241]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:45.241]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:45.241]                       fi_tmp <- file.info(pathname_tmp)
[10:22:45.241]                       fi <- file.info(pathname)
[10:22:45.241]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:45.241]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:45.241]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:45.241]                         fi[["size"]], fi[["mtime"]])
[10:22:45.241]                       stop(msg)
[10:22:45.241]                     }
[10:22:45.241]                     invisible(pathname)
[10:22:45.241]                   }
[10:22:45.241]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:45.241]                     rootPath = tempdir()) 
[10:22:45.241]                   {
[10:22:45.241]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:45.241]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:45.241]                       tmpdir = path, fileext = ".rds")
[10:22:45.241]                     save_rds(obj, file)
[10:22:45.241]                   }
[10:22:45.241]                   saveImmediateCondition(cond, path = "/tmp/RtmpTHXGJm/.future/immediateConditions")
[10:22:45.241]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.241]                   {
[10:22:45.241]                     inherits <- base::inherits
[10:22:45.241]                     invokeRestart <- base::invokeRestart
[10:22:45.241]                     is.null <- base::is.null
[10:22:45.241]                     muffled <- FALSE
[10:22:45.241]                     if (inherits(cond, "message")) {
[10:22:45.241]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:45.241]                       if (muffled) 
[10:22:45.241]                         invokeRestart("muffleMessage")
[10:22:45.241]                     }
[10:22:45.241]                     else if (inherits(cond, "warning")) {
[10:22:45.241]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:45.241]                       if (muffled) 
[10:22:45.241]                         invokeRestart("muffleWarning")
[10:22:45.241]                     }
[10:22:45.241]                     else if (inherits(cond, "condition")) {
[10:22:45.241]                       if (!is.null(pattern)) {
[10:22:45.241]                         computeRestarts <- base::computeRestarts
[10:22:45.241]                         grepl <- base::grepl
[10:22:45.241]                         restarts <- computeRestarts(cond)
[10:22:45.241]                         for (restart in restarts) {
[10:22:45.241]                           name <- restart$name
[10:22:45.241]                           if (is.null(name)) 
[10:22:45.241]                             next
[10:22:45.241]                           if (!grepl(pattern, name)) 
[10:22:45.241]                             next
[10:22:45.241]                           invokeRestart(restart)
[10:22:45.241]                           muffled <- TRUE
[10:22:45.241]                           break
[10:22:45.241]                         }
[10:22:45.241]                       }
[10:22:45.241]                     }
[10:22:45.241]                     invisible(muffled)
[10:22:45.241]                   }
[10:22:45.241]                   muffleCondition(cond)
[10:22:45.241]                 })
[10:22:45.241]             }))
[10:22:45.241]             future::FutureResult(value = ...future.value$value, 
[10:22:45.241]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:45.241]                   ...future.rng), globalenv = if (FALSE) 
[10:22:45.241]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:45.241]                     ...future.globalenv.names))
[10:22:45.241]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:45.241]         }, condition = base::local({
[10:22:45.241]             c <- base::c
[10:22:45.241]             inherits <- base::inherits
[10:22:45.241]             invokeRestart <- base::invokeRestart
[10:22:45.241]             length <- base::length
[10:22:45.241]             list <- base::list
[10:22:45.241]             seq.int <- base::seq.int
[10:22:45.241]             signalCondition <- base::signalCondition
[10:22:45.241]             sys.calls <- base::sys.calls
[10:22:45.241]             `[[` <- base::`[[`
[10:22:45.241]             `+` <- base::`+`
[10:22:45.241]             `<<-` <- base::`<<-`
[10:22:45.241]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:45.241]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:45.241]                   3L)]
[10:22:45.241]             }
[10:22:45.241]             function(cond) {
[10:22:45.241]                 is_error <- inherits(cond, "error")
[10:22:45.241]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:45.241]                   NULL)
[10:22:45.241]                 if (is_error) {
[10:22:45.241]                   sessionInformation <- function() {
[10:22:45.241]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:45.241]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:45.241]                       search = base::search(), system = base::Sys.info())
[10:22:45.241]                   }
[10:22:45.241]                   ...future.conditions[[length(...future.conditions) + 
[10:22:45.241]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:45.241]                     cond$call), session = sessionInformation(), 
[10:22:45.241]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:45.241]                   signalCondition(cond)
[10:22:45.241]                 }
[10:22:45.241]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:45.241]                 "immediateCondition"))) {
[10:22:45.241]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:45.241]                   ...future.conditions[[length(...future.conditions) + 
[10:22:45.241]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:45.241]                   if (TRUE && !signal) {
[10:22:45.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.241]                     {
[10:22:45.241]                       inherits <- base::inherits
[10:22:45.241]                       invokeRestart <- base::invokeRestart
[10:22:45.241]                       is.null <- base::is.null
[10:22:45.241]                       muffled <- FALSE
[10:22:45.241]                       if (inherits(cond, "message")) {
[10:22:45.241]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:45.241]                         if (muffled) 
[10:22:45.241]                           invokeRestart("muffleMessage")
[10:22:45.241]                       }
[10:22:45.241]                       else if (inherits(cond, "warning")) {
[10:22:45.241]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:45.241]                         if (muffled) 
[10:22:45.241]                           invokeRestart("muffleWarning")
[10:22:45.241]                       }
[10:22:45.241]                       else if (inherits(cond, "condition")) {
[10:22:45.241]                         if (!is.null(pattern)) {
[10:22:45.241]                           computeRestarts <- base::computeRestarts
[10:22:45.241]                           grepl <- base::grepl
[10:22:45.241]                           restarts <- computeRestarts(cond)
[10:22:45.241]                           for (restart in restarts) {
[10:22:45.241]                             name <- restart$name
[10:22:45.241]                             if (is.null(name)) 
[10:22:45.241]                               next
[10:22:45.241]                             if (!grepl(pattern, name)) 
[10:22:45.241]                               next
[10:22:45.241]                             invokeRestart(restart)
[10:22:45.241]                             muffled <- TRUE
[10:22:45.241]                             break
[10:22:45.241]                           }
[10:22:45.241]                         }
[10:22:45.241]                       }
[10:22:45.241]                       invisible(muffled)
[10:22:45.241]                     }
[10:22:45.241]                     muffleCondition(cond, pattern = "^muffle")
[10:22:45.241]                   }
[10:22:45.241]                 }
[10:22:45.241]                 else {
[10:22:45.241]                   if (TRUE) {
[10:22:45.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.241]                     {
[10:22:45.241]                       inherits <- base::inherits
[10:22:45.241]                       invokeRestart <- base::invokeRestart
[10:22:45.241]                       is.null <- base::is.null
[10:22:45.241]                       muffled <- FALSE
[10:22:45.241]                       if (inherits(cond, "message")) {
[10:22:45.241]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:45.241]                         if (muffled) 
[10:22:45.241]                           invokeRestart("muffleMessage")
[10:22:45.241]                       }
[10:22:45.241]                       else if (inherits(cond, "warning")) {
[10:22:45.241]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:45.241]                         if (muffled) 
[10:22:45.241]                           invokeRestart("muffleWarning")
[10:22:45.241]                       }
[10:22:45.241]                       else if (inherits(cond, "condition")) {
[10:22:45.241]                         if (!is.null(pattern)) {
[10:22:45.241]                           computeRestarts <- base::computeRestarts
[10:22:45.241]                           grepl <- base::grepl
[10:22:45.241]                           restarts <- computeRestarts(cond)
[10:22:45.241]                           for (restart in restarts) {
[10:22:45.241]                             name <- restart$name
[10:22:45.241]                             if (is.null(name)) 
[10:22:45.241]                               next
[10:22:45.241]                             if (!grepl(pattern, name)) 
[10:22:45.241]                               next
[10:22:45.241]                             invokeRestart(restart)
[10:22:45.241]                             muffled <- TRUE
[10:22:45.241]                             break
[10:22:45.241]                           }
[10:22:45.241]                         }
[10:22:45.241]                       }
[10:22:45.241]                       invisible(muffled)
[10:22:45.241]                     }
[10:22:45.241]                     muffleCondition(cond, pattern = "^muffle")
[10:22:45.241]                   }
[10:22:45.241]                 }
[10:22:45.241]             }
[10:22:45.241]         }))
[10:22:45.241]     }, error = function(ex) {
[10:22:45.241]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:45.241]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:45.241]                 ...future.rng), started = ...future.startTime, 
[10:22:45.241]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:45.241]             version = "1.8"), class = "FutureResult")
[10:22:45.241]     }, finally = {
[10:22:45.241]         if (!identical(...future.workdir, getwd())) 
[10:22:45.241]             setwd(...future.workdir)
[10:22:45.241]         {
[10:22:45.241]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:45.241]                 ...future.oldOptions$nwarnings <- NULL
[10:22:45.241]             }
[10:22:45.241]             base::options(...future.oldOptions)
[10:22:45.241]             if (.Platform$OS.type == "windows") {
[10:22:45.241]                 old_names <- names(...future.oldEnvVars)
[10:22:45.241]                 envs <- base::Sys.getenv()
[10:22:45.241]                 names <- names(envs)
[10:22:45.241]                 common <- intersect(names, old_names)
[10:22:45.241]                 added <- setdiff(names, old_names)
[10:22:45.241]                 removed <- setdiff(old_names, names)
[10:22:45.241]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:45.241]                   envs[common]]
[10:22:45.241]                 NAMES <- toupper(changed)
[10:22:45.241]                 args <- list()
[10:22:45.241]                 for (kk in seq_along(NAMES)) {
[10:22:45.241]                   name <- changed[[kk]]
[10:22:45.241]                   NAME <- NAMES[[kk]]
[10:22:45.241]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.241]                     next
[10:22:45.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:45.241]                 }
[10:22:45.241]                 NAMES <- toupper(added)
[10:22:45.241]                 for (kk in seq_along(NAMES)) {
[10:22:45.241]                   name <- added[[kk]]
[10:22:45.241]                   NAME <- NAMES[[kk]]
[10:22:45.241]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.241]                     next
[10:22:45.241]                   args[[name]] <- ""
[10:22:45.241]                 }
[10:22:45.241]                 NAMES <- toupper(removed)
[10:22:45.241]                 for (kk in seq_along(NAMES)) {
[10:22:45.241]                   name <- removed[[kk]]
[10:22:45.241]                   NAME <- NAMES[[kk]]
[10:22:45.241]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.241]                     next
[10:22:45.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:45.241]                 }
[10:22:45.241]                 if (length(args) > 0) 
[10:22:45.241]                   base::do.call(base::Sys.setenv, args = args)
[10:22:45.241]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:45.241]             }
[10:22:45.241]             else {
[10:22:45.241]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:45.241]             }
[10:22:45.241]             {
[10:22:45.241]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:45.241]                   0L) {
[10:22:45.241]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:45.241]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:45.241]                   base::options(opts)
[10:22:45.241]                 }
[10:22:45.241]                 {
[10:22:45.241]                   {
[10:22:45.241]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:45.241]                     NULL
[10:22:45.241]                   }
[10:22:45.241]                   options(future.plan = NULL)
[10:22:45.241]                   if (is.na(NA_character_)) 
[10:22:45.241]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:45.241]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:45.241]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:45.241]                     envir = parent.frame()) 
[10:22:45.241]                   {
[10:22:45.241]                     default_workers <- missing(workers)
[10:22:45.241]                     if (is.function(workers)) 
[10:22:45.241]                       workers <- workers()
[10:22:45.241]                     workers <- structure(as.integer(workers), 
[10:22:45.241]                       class = class(workers))
[10:22:45.241]                     stop_if_not(is.finite(workers), workers >= 
[10:22:45.241]                       1L)
[10:22:45.241]                     if ((workers == 1L && !inherits(workers, 
[10:22:45.241]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:45.241]                       if (default_workers) 
[10:22:45.241]                         supportsMulticore(warn = TRUE)
[10:22:45.241]                       return(sequential(..., envir = envir))
[10:22:45.241]                     }
[10:22:45.241]                     oopts <- options(mc.cores = workers)
[10:22:45.241]                     on.exit(options(oopts))
[10:22:45.241]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:45.241]                       envir = envir)
[10:22:45.241]                     if (!future$lazy) 
[10:22:45.241]                       future <- run(future)
[10:22:45.241]                     invisible(future)
[10:22:45.241]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:45.241]                 }
[10:22:45.241]             }
[10:22:45.241]         }
[10:22:45.241]     })
[10:22:45.241]     if (TRUE) {
[10:22:45.241]         base::sink(type = "output", split = FALSE)
[10:22:45.241]         if (TRUE) {
[10:22:45.241]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:45.241]         }
[10:22:45.241]         else {
[10:22:45.241]             ...future.result["stdout"] <- base::list(NULL)
[10:22:45.241]         }
[10:22:45.241]         base::close(...future.stdout)
[10:22:45.241]         ...future.stdout <- NULL
[10:22:45.241]     }
[10:22:45.241]     ...future.result$conditions <- ...future.conditions
[10:22:45.241]     ...future.result$finished <- base::Sys.time()
[10:22:45.241]     ...future.result
[10:22:45.241] }
[10:22:45.244] assign_globals() ...
[10:22:45.244] List of 5
[10:22:45.244]  $ future.call.arguments    : list()
[10:22:45.244]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:45.244]  $ ...future.FUN            :function (x)  
[10:22:45.244]  $ ...future.elements_ii    :List of 1
[10:22:45.244]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[10:22:45.244]  $ ...future.seeds_ii       : NULL
[10:22:45.244]  $ ...future.globals.maxSize: num Inf
[10:22:45.244]  - attr(*, "resolved")= logi FALSE
[10:22:45.244]  - attr(*, "total_size")= num NA
[10:22:45.244]  - attr(*, "where")=List of 5
[10:22:45.244]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:45.244]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:45.244]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:45.244]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:45.244]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:45.244]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:45.244]  - attr(*, "already-done")= logi TRUE
[10:22:45.249] - copied ‘future.call.arguments’ to environment
[10:22:45.250] - copied ‘...future.FUN’ to environment
[10:22:45.250] - copied ‘...future.elements_ii’ to environment
[10:22:45.250] - copied ‘...future.seeds_ii’ to environment
[10:22:45.250] - copied ‘...future.globals.maxSize’ to environment
[10:22:45.250] assign_globals() ... done
[10:22:45.250] requestCore(): workers = 2
[10:22:45.252] MulticoreFuture started
[10:22:45.253] - Launch lazy future ... done
[10:22:45.253] run() for ‘MulticoreFuture’ ... done
[10:22:45.253] Created future:
[10:22:45.254] plan(): Setting new future strategy stack:
[10:22:45.254] List of future strategies:
[10:22:45.254] 1. sequential:
[10:22:45.254]    - args: function (..., envir = parent.frame())
[10:22:45.254]    - tweaked: FALSE
[10:22:45.254]    - call: NULL
[10:22:45.255] plan(): nbrOfWorkers() = 1
[10:22:45.257] plan(): Setting new future strategy stack:
[10:22:45.257] List of future strategies:
[10:22:45.257] 1. multicore:
[10:22:45.257]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:45.257]    - tweaked: FALSE
[10:22:45.257]    - call: plan(strategy)
[10:22:45.262] plan(): nbrOfWorkers() = 2
[10:22:45.254] MulticoreFuture:
[10:22:45.254] Label: ‘future_apply-1’
[10:22:45.254] Expression:
[10:22:45.254] {
[10:22:45.254]     do.call(function(...) {
[10:22:45.254]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:45.254]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:45.254]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:45.254]             on.exit(options(oopts), add = TRUE)
[10:22:45.254]         }
[10:22:45.254]         {
[10:22:45.254]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:45.254]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:45.254]                 ...future.FUN(...future.X_jj, ...)
[10:22:45.254]             })
[10:22:45.254]         }
[10:22:45.254]     }, args = future.call.arguments)
[10:22:45.254] }
[10:22:45.254] Lazy evaluation: FALSE
[10:22:45.254] Asynchronous evaluation: TRUE
[10:22:45.254] Local evaluation: TRUE
[10:22:45.254] Environment: R_GlobalEnv
[10:22:45.254] Capture standard output: TRUE
[10:22:45.254] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:45.254] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:45.254] Packages: <none>
[10:22:45.254] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:45.254] Resolved: TRUE
[10:22:45.254] Value: <not collected>
[10:22:45.254] Conditions captured: <none>
[10:22:45.254] Early signaling: FALSE
[10:22:45.254] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:45.254] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:45.263] Chunk #1 of 2 ... DONE
[10:22:45.263] Chunk #2 of 2 ...
[10:22:45.264]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:45.264]  - seeds: <none>
[10:22:45.264]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:45.264] getGlobalsAndPackages() ...
[10:22:45.264] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:45.264] Resolving globals: FALSE
[10:22:45.264] Tweak future expression to call with '...' arguments ...
[10:22:45.265] {
[10:22:45.265]     do.call(function(...) {
[10:22:45.265]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:45.265]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:45.265]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:45.265]             on.exit(options(oopts), add = TRUE)
[10:22:45.265]         }
[10:22:45.265]         {
[10:22:45.265]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:45.265]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:45.265]                 ...future.FUN(...future.X_jj, ...)
[10:22:45.265]             })
[10:22:45.265]         }
[10:22:45.265]     }, args = future.call.arguments)
[10:22:45.265] }
[10:22:45.265] Tweak future expression to call with '...' arguments ... DONE
[10:22:45.266] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:45.266] 
[10:22:45.266] getGlobalsAndPackages() ... DONE
[10:22:45.267] run() for ‘Future’ ...
[10:22:45.267] - state: ‘created’
[10:22:45.267] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:45.272] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:45.272] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:45.272]   - Field: ‘label’
[10:22:45.273]   - Field: ‘local’
[10:22:45.273]   - Field: ‘owner’
[10:22:45.273]   - Field: ‘envir’
[10:22:45.273]   - Field: ‘workers’
[10:22:45.273]   - Field: ‘packages’
[10:22:45.273]   - Field: ‘gc’
[10:22:45.273]   - Field: ‘job’
[10:22:45.274]   - Field: ‘conditions’
[10:22:45.274]   - Field: ‘expr’
[10:22:45.274]   - Field: ‘uuid’
[10:22:45.274]   - Field: ‘seed’
[10:22:45.274]   - Field: ‘version’
[10:22:45.274]   - Field: ‘result’
[10:22:45.274]   - Field: ‘asynchronous’
[10:22:45.275]   - Field: ‘calls’
[10:22:45.275]   - Field: ‘globals’
[10:22:45.275]   - Field: ‘stdout’
[10:22:45.275]   - Field: ‘earlySignal’
[10:22:45.275]   - Field: ‘lazy’
[10:22:45.275]   - Field: ‘state’
[10:22:45.275] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:45.276] - Launch lazy future ...
[10:22:45.276] Packages needed by the future expression (n = 0): <none>
[10:22:45.276] Packages needed by future strategies (n = 0): <none>
[10:22:45.277] {
[10:22:45.277]     {
[10:22:45.277]         {
[10:22:45.277]             ...future.startTime <- base::Sys.time()
[10:22:45.277]             {
[10:22:45.277]                 {
[10:22:45.277]                   {
[10:22:45.277]                     {
[10:22:45.277]                       base::local({
[10:22:45.277]                         has_future <- base::requireNamespace("future", 
[10:22:45.277]                           quietly = TRUE)
[10:22:45.277]                         if (has_future) {
[10:22:45.277]                           ns <- base::getNamespace("future")
[10:22:45.277]                           version <- ns[[".package"]][["version"]]
[10:22:45.277]                           if (is.null(version)) 
[10:22:45.277]                             version <- utils::packageVersion("future")
[10:22:45.277]                         }
[10:22:45.277]                         else {
[10:22:45.277]                           version <- NULL
[10:22:45.277]                         }
[10:22:45.277]                         if (!has_future || version < "1.8.0") {
[10:22:45.277]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:45.277]                             "", base::R.version$version.string), 
[10:22:45.277]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:45.277]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:45.277]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:45.277]                               "release", "version")], collapse = " "), 
[10:22:45.277]                             hostname = base::Sys.info()[["nodename"]])
[10:22:45.277]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:45.277]                             info)
[10:22:45.277]                           info <- base::paste(info, collapse = "; ")
[10:22:45.277]                           if (!has_future) {
[10:22:45.277]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:45.277]                               info)
[10:22:45.277]                           }
[10:22:45.277]                           else {
[10:22:45.277]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:45.277]                               info, version)
[10:22:45.277]                           }
[10:22:45.277]                           base::stop(msg)
[10:22:45.277]                         }
[10:22:45.277]                       })
[10:22:45.277]                     }
[10:22:45.277]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:45.277]                     base::options(mc.cores = 1L)
[10:22:45.277]                   }
[10:22:45.277]                   options(future.plan = NULL)
[10:22:45.277]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:45.277]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:45.277]                 }
[10:22:45.277]                 ...future.workdir <- getwd()
[10:22:45.277]             }
[10:22:45.277]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:45.277]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:45.277]         }
[10:22:45.277]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:45.277]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:45.277]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:45.277]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:45.277]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:45.277]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:45.277]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:45.277]             base::names(...future.oldOptions))
[10:22:45.277]     }
[10:22:45.277]     if (FALSE) {
[10:22:45.277]     }
[10:22:45.277]     else {
[10:22:45.277]         if (TRUE) {
[10:22:45.277]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:45.277]                 open = "w")
[10:22:45.277]         }
[10:22:45.277]         else {
[10:22:45.277]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:45.277]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:45.277]         }
[10:22:45.277]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:45.277]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:45.277]             base::sink(type = "output", split = FALSE)
[10:22:45.277]             base::close(...future.stdout)
[10:22:45.277]         }, add = TRUE)
[10:22:45.277]     }
[10:22:45.277]     ...future.frame <- base::sys.nframe()
[10:22:45.277]     ...future.conditions <- base::list()
[10:22:45.277]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:45.277]     if (FALSE) {
[10:22:45.277]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:45.277]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:45.277]     }
[10:22:45.277]     ...future.result <- base::tryCatch({
[10:22:45.277]         base::withCallingHandlers({
[10:22:45.277]             ...future.value <- base::withVisible(base::local({
[10:22:45.277]                 withCallingHandlers({
[10:22:45.277]                   {
[10:22:45.277]                     do.call(function(...) {
[10:22:45.277]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:45.277]                       if (!identical(...future.globals.maxSize.org, 
[10:22:45.277]                         ...future.globals.maxSize)) {
[10:22:45.277]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:45.277]                         on.exit(options(oopts), add = TRUE)
[10:22:45.277]                       }
[10:22:45.277]                       {
[10:22:45.277]                         lapply(seq_along(...future.elements_ii), 
[10:22:45.277]                           FUN = function(jj) {
[10:22:45.277]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:45.277]                             ...future.FUN(...future.X_jj, ...)
[10:22:45.277]                           })
[10:22:45.277]                       }
[10:22:45.277]                     }, args = future.call.arguments)
[10:22:45.277]                   }
[10:22:45.277]                 }, immediateCondition = function(cond) {
[10:22:45.277]                   save_rds <- function (object, pathname, ...) 
[10:22:45.277]                   {
[10:22:45.277]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:45.277]                     if (file_test("-f", pathname_tmp)) {
[10:22:45.277]                       fi_tmp <- file.info(pathname_tmp)
[10:22:45.277]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:45.277]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:45.277]                         fi_tmp[["mtime"]])
[10:22:45.277]                     }
[10:22:45.277]                     tryCatch({
[10:22:45.277]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:45.277]                     }, error = function(ex) {
[10:22:45.277]                       msg <- conditionMessage(ex)
[10:22:45.277]                       fi_tmp <- file.info(pathname_tmp)
[10:22:45.277]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:45.277]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:45.277]                         fi_tmp[["mtime"]], msg)
[10:22:45.277]                       ex$message <- msg
[10:22:45.277]                       stop(ex)
[10:22:45.277]                     })
[10:22:45.277]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:45.277]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:45.277]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:45.277]                       fi_tmp <- file.info(pathname_tmp)
[10:22:45.277]                       fi <- file.info(pathname)
[10:22:45.277]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:45.277]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:45.277]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:45.277]                         fi[["size"]], fi[["mtime"]])
[10:22:45.277]                       stop(msg)
[10:22:45.277]                     }
[10:22:45.277]                     invisible(pathname)
[10:22:45.277]                   }
[10:22:45.277]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:45.277]                     rootPath = tempdir()) 
[10:22:45.277]                   {
[10:22:45.277]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:45.277]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:45.277]                       tmpdir = path, fileext = ".rds")
[10:22:45.277]                     save_rds(obj, file)
[10:22:45.277]                   }
[10:22:45.277]                   saveImmediateCondition(cond, path = "/tmp/RtmpTHXGJm/.future/immediateConditions")
[10:22:45.277]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.277]                   {
[10:22:45.277]                     inherits <- base::inherits
[10:22:45.277]                     invokeRestart <- base::invokeRestart
[10:22:45.277]                     is.null <- base::is.null
[10:22:45.277]                     muffled <- FALSE
[10:22:45.277]                     if (inherits(cond, "message")) {
[10:22:45.277]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:45.277]                       if (muffled) 
[10:22:45.277]                         invokeRestart("muffleMessage")
[10:22:45.277]                     }
[10:22:45.277]                     else if (inherits(cond, "warning")) {
[10:22:45.277]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:45.277]                       if (muffled) 
[10:22:45.277]                         invokeRestart("muffleWarning")
[10:22:45.277]                     }
[10:22:45.277]                     else if (inherits(cond, "condition")) {
[10:22:45.277]                       if (!is.null(pattern)) {
[10:22:45.277]                         computeRestarts <- base::computeRestarts
[10:22:45.277]                         grepl <- base::grepl
[10:22:45.277]                         restarts <- computeRestarts(cond)
[10:22:45.277]                         for (restart in restarts) {
[10:22:45.277]                           name <- restart$name
[10:22:45.277]                           if (is.null(name)) 
[10:22:45.277]                             next
[10:22:45.277]                           if (!grepl(pattern, name)) 
[10:22:45.277]                             next
[10:22:45.277]                           invokeRestart(restart)
[10:22:45.277]                           muffled <- TRUE
[10:22:45.277]                           break
[10:22:45.277]                         }
[10:22:45.277]                       }
[10:22:45.277]                     }
[10:22:45.277]                     invisible(muffled)
[10:22:45.277]                   }
[10:22:45.277]                   muffleCondition(cond)
[10:22:45.277]                 })
[10:22:45.277]             }))
[10:22:45.277]             future::FutureResult(value = ...future.value$value, 
[10:22:45.277]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:45.277]                   ...future.rng), globalenv = if (FALSE) 
[10:22:45.277]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:45.277]                     ...future.globalenv.names))
[10:22:45.277]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:45.277]         }, condition = base::local({
[10:22:45.277]             c <- base::c
[10:22:45.277]             inherits <- base::inherits
[10:22:45.277]             invokeRestart <- base::invokeRestart
[10:22:45.277]             length <- base::length
[10:22:45.277]             list <- base::list
[10:22:45.277]             seq.int <- base::seq.int
[10:22:45.277]             signalCondition <- base::signalCondition
[10:22:45.277]             sys.calls <- base::sys.calls
[10:22:45.277]             `[[` <- base::`[[`
[10:22:45.277]             `+` <- base::`+`
[10:22:45.277]             `<<-` <- base::`<<-`
[10:22:45.277]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:45.277]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:45.277]                   3L)]
[10:22:45.277]             }
[10:22:45.277]             function(cond) {
[10:22:45.277]                 is_error <- inherits(cond, "error")
[10:22:45.277]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:45.277]                   NULL)
[10:22:45.277]                 if (is_error) {
[10:22:45.277]                   sessionInformation <- function() {
[10:22:45.277]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:45.277]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:45.277]                       search = base::search(), system = base::Sys.info())
[10:22:45.277]                   }
[10:22:45.277]                   ...future.conditions[[length(...future.conditions) + 
[10:22:45.277]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:45.277]                     cond$call), session = sessionInformation(), 
[10:22:45.277]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:45.277]                   signalCondition(cond)
[10:22:45.277]                 }
[10:22:45.277]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:45.277]                 "immediateCondition"))) {
[10:22:45.277]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:45.277]                   ...future.conditions[[length(...future.conditions) + 
[10:22:45.277]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:45.277]                   if (TRUE && !signal) {
[10:22:45.277]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.277]                     {
[10:22:45.277]                       inherits <- base::inherits
[10:22:45.277]                       invokeRestart <- base::invokeRestart
[10:22:45.277]                       is.null <- base::is.null
[10:22:45.277]                       muffled <- FALSE
[10:22:45.277]                       if (inherits(cond, "message")) {
[10:22:45.277]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:45.277]                         if (muffled) 
[10:22:45.277]                           invokeRestart("muffleMessage")
[10:22:45.277]                       }
[10:22:45.277]                       else if (inherits(cond, "warning")) {
[10:22:45.277]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:45.277]                         if (muffled) 
[10:22:45.277]                           invokeRestart("muffleWarning")
[10:22:45.277]                       }
[10:22:45.277]                       else if (inherits(cond, "condition")) {
[10:22:45.277]                         if (!is.null(pattern)) {
[10:22:45.277]                           computeRestarts <- base::computeRestarts
[10:22:45.277]                           grepl <- base::grepl
[10:22:45.277]                           restarts <- computeRestarts(cond)
[10:22:45.277]                           for (restart in restarts) {
[10:22:45.277]                             name <- restart$name
[10:22:45.277]                             if (is.null(name)) 
[10:22:45.277]                               next
[10:22:45.277]                             if (!grepl(pattern, name)) 
[10:22:45.277]                               next
[10:22:45.277]                             invokeRestart(restart)
[10:22:45.277]                             muffled <- TRUE
[10:22:45.277]                             break
[10:22:45.277]                           }
[10:22:45.277]                         }
[10:22:45.277]                       }
[10:22:45.277]                       invisible(muffled)
[10:22:45.277]                     }
[10:22:45.277]                     muffleCondition(cond, pattern = "^muffle")
[10:22:45.277]                   }
[10:22:45.277]                 }
[10:22:45.277]                 else {
[10:22:45.277]                   if (TRUE) {
[10:22:45.277]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.277]                     {
[10:22:45.277]                       inherits <- base::inherits
[10:22:45.277]                       invokeRestart <- base::invokeRestart
[10:22:45.277]                       is.null <- base::is.null
[10:22:45.277]                       muffled <- FALSE
[10:22:45.277]                       if (inherits(cond, "message")) {
[10:22:45.277]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:45.277]                         if (muffled) 
[10:22:45.277]                           invokeRestart("muffleMessage")
[10:22:45.277]                       }
[10:22:45.277]                       else if (inherits(cond, "warning")) {
[10:22:45.277]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:45.277]                         if (muffled) 
[10:22:45.277]                           invokeRestart("muffleWarning")
[10:22:45.277]                       }
[10:22:45.277]                       else if (inherits(cond, "condition")) {
[10:22:45.277]                         if (!is.null(pattern)) {
[10:22:45.277]                           computeRestarts <- base::computeRestarts
[10:22:45.277]                           grepl <- base::grepl
[10:22:45.277]                           restarts <- computeRestarts(cond)
[10:22:45.277]                           for (restart in restarts) {
[10:22:45.277]                             name <- restart$name
[10:22:45.277]                             if (is.null(name)) 
[10:22:45.277]                               next
[10:22:45.277]                             if (!grepl(pattern, name)) 
[10:22:45.277]                               next
[10:22:45.277]                             invokeRestart(restart)
[10:22:45.277]                             muffled <- TRUE
[10:22:45.277]                             break
[10:22:45.277]                           }
[10:22:45.277]                         }
[10:22:45.277]                       }
[10:22:45.277]                       invisible(muffled)
[10:22:45.277]                     }
[10:22:45.277]                     muffleCondition(cond, pattern = "^muffle")
[10:22:45.277]                   }
[10:22:45.277]                 }
[10:22:45.277]             }
[10:22:45.277]         }))
[10:22:45.277]     }, error = function(ex) {
[10:22:45.277]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:45.277]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:45.277]                 ...future.rng), started = ...future.startTime, 
[10:22:45.277]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:45.277]             version = "1.8"), class = "FutureResult")
[10:22:45.277]     }, finally = {
[10:22:45.277]         if (!identical(...future.workdir, getwd())) 
[10:22:45.277]             setwd(...future.workdir)
[10:22:45.277]         {
[10:22:45.277]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:45.277]                 ...future.oldOptions$nwarnings <- NULL
[10:22:45.277]             }
[10:22:45.277]             base::options(...future.oldOptions)
[10:22:45.277]             if (.Platform$OS.type == "windows") {
[10:22:45.277]                 old_names <- names(...future.oldEnvVars)
[10:22:45.277]                 envs <- base::Sys.getenv()
[10:22:45.277]                 names <- names(envs)
[10:22:45.277]                 common <- intersect(names, old_names)
[10:22:45.277]                 added <- setdiff(names, old_names)
[10:22:45.277]                 removed <- setdiff(old_names, names)
[10:22:45.277]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:45.277]                   envs[common]]
[10:22:45.277]                 NAMES <- toupper(changed)
[10:22:45.277]                 args <- list()
[10:22:45.277]                 for (kk in seq_along(NAMES)) {
[10:22:45.277]                   name <- changed[[kk]]
[10:22:45.277]                   NAME <- NAMES[[kk]]
[10:22:45.277]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.277]                     next
[10:22:45.277]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:45.277]                 }
[10:22:45.277]                 NAMES <- toupper(added)
[10:22:45.277]                 for (kk in seq_along(NAMES)) {
[10:22:45.277]                   name <- added[[kk]]
[10:22:45.277]                   NAME <- NAMES[[kk]]
[10:22:45.277]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.277]                     next
[10:22:45.277]                   args[[name]] <- ""
[10:22:45.277]                 }
[10:22:45.277]                 NAMES <- toupper(removed)
[10:22:45.277]                 for (kk in seq_along(NAMES)) {
[10:22:45.277]                   name <- removed[[kk]]
[10:22:45.277]                   NAME <- NAMES[[kk]]
[10:22:45.277]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.277]                     next
[10:22:45.277]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:45.277]                 }
[10:22:45.277]                 if (length(args) > 0) 
[10:22:45.277]                   base::do.call(base::Sys.setenv, args = args)
[10:22:45.277]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:45.277]             }
[10:22:45.277]             else {
[10:22:45.277]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:45.277]             }
[10:22:45.277]             {
[10:22:45.277]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:45.277]                   0L) {
[10:22:45.277]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:45.277]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:45.277]                   base::options(opts)
[10:22:45.277]                 }
[10:22:45.277]                 {
[10:22:45.277]                   {
[10:22:45.277]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:45.277]                     NULL
[10:22:45.277]                   }
[10:22:45.277]                   options(future.plan = NULL)
[10:22:45.277]                   if (is.na(NA_character_)) 
[10:22:45.277]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:45.277]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:45.277]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:45.277]                     envir = parent.frame()) 
[10:22:45.277]                   {
[10:22:45.277]                     default_workers <- missing(workers)
[10:22:45.277]                     if (is.function(workers)) 
[10:22:45.277]                       workers <- workers()
[10:22:45.277]                     workers <- structure(as.integer(workers), 
[10:22:45.277]                       class = class(workers))
[10:22:45.277]                     stop_if_not(is.finite(workers), workers >= 
[10:22:45.277]                       1L)
[10:22:45.277]                     if ((workers == 1L && !inherits(workers, 
[10:22:45.277]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:45.277]                       if (default_workers) 
[10:22:45.277]                         supportsMulticore(warn = TRUE)
[10:22:45.277]                       return(sequential(..., envir = envir))
[10:22:45.277]                     }
[10:22:45.277]                     oopts <- options(mc.cores = workers)
[10:22:45.277]                     on.exit(options(oopts))
[10:22:45.277]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:45.277]                       envir = envir)
[10:22:45.277]                     if (!future$lazy) 
[10:22:45.277]                       future <- run(future)
[10:22:45.277]                     invisible(future)
[10:22:45.277]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:45.277]                 }
[10:22:45.277]             }
[10:22:45.277]         }
[10:22:45.277]     })
[10:22:45.277]     if (TRUE) {
[10:22:45.277]         base::sink(type = "output", split = FALSE)
[10:22:45.277]         if (TRUE) {
[10:22:45.277]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:45.277]         }
[10:22:45.277]         else {
[10:22:45.277]             ...future.result["stdout"] <- base::list(NULL)
[10:22:45.277]         }
[10:22:45.277]         base::close(...future.stdout)
[10:22:45.277]         ...future.stdout <- NULL
[10:22:45.277]     }
[10:22:45.277]     ...future.result$conditions <- ...future.conditions
[10:22:45.277]     ...future.result$finished <- base::Sys.time()
[10:22:45.277]     ...future.result
[10:22:45.277] }
[10:22:45.280] assign_globals() ...
[10:22:45.280] List of 5
[10:22:45.280]  $ future.call.arguments    : list()
[10:22:45.280]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:45.280]  $ ...future.FUN            :function (x)  
[10:22:45.280]  $ ...future.elements_ii    :List of 1
[10:22:45.280]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[10:22:45.280]  $ ...future.seeds_ii       : NULL
[10:22:45.280]  $ ...future.globals.maxSize: num Inf
[10:22:45.280]  - attr(*, "resolved")= logi FALSE
[10:22:45.280]  - attr(*, "total_size")= num NA
[10:22:45.280]  - attr(*, "where")=List of 5
[10:22:45.280]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:45.280]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:45.280]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:45.280]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:45.280]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:45.280]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:45.280]  - attr(*, "already-done")= logi TRUE
[10:22:45.293] - copied ‘future.call.arguments’ to environment
[10:22:45.294] - copied ‘...future.FUN’ to environment
[10:22:45.294] - copied ‘...future.elements_ii’ to environment
[10:22:45.294] - copied ‘...future.seeds_ii’ to environment
[10:22:45.294] - copied ‘...future.globals.maxSize’ to environment
[10:22:45.294] assign_globals() ... done
[10:22:45.294] requestCore(): workers = 2
[10:22:45.297] MulticoreFuture started
[10:22:45.297] - Launch lazy future ... done
[10:22:45.297] run() for ‘MulticoreFuture’ ... done
[10:22:45.298] Created future:
[10:22:45.298] plan(): Setting new future strategy stack:
[10:22:45.298] List of future strategies:
[10:22:45.298] 1. sequential:
[10:22:45.298]    - args: function (..., envir = parent.frame())
[10:22:45.298]    - tweaked: FALSE
[10:22:45.298]    - call: NULL
[10:22:45.299] plan(): nbrOfWorkers() = 1
[10:22:45.302] plan(): Setting new future strategy stack:
[10:22:45.302] List of future strategies:
[10:22:45.302] 1. multicore:
[10:22:45.302]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:45.302]    - tweaked: FALSE
[10:22:45.302]    - call: plan(strategy)
[10:22:45.307] plan(): nbrOfWorkers() = 2
[10:22:45.298] MulticoreFuture:
[10:22:45.298] Label: ‘future_apply-2’
[10:22:45.298] Expression:
[10:22:45.298] {
[10:22:45.298]     do.call(function(...) {
[10:22:45.298]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:45.298]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:45.298]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:45.298]             on.exit(options(oopts), add = TRUE)
[10:22:45.298]         }
[10:22:45.298]         {
[10:22:45.298]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:45.298]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:45.298]                 ...future.FUN(...future.X_jj, ...)
[10:22:45.298]             })
[10:22:45.298]         }
[10:22:45.298]     }, args = future.call.arguments)
[10:22:45.298] }
[10:22:45.298] Lazy evaluation: FALSE
[10:22:45.298] Asynchronous evaluation: TRUE
[10:22:45.298] Local evaluation: TRUE
[10:22:45.298] Environment: R_GlobalEnv
[10:22:45.298] Capture standard output: TRUE
[10:22:45.298] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:45.298] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:45.298] Packages: <none>
[10:22:45.298] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:45.298] Resolved: TRUE
[10:22:45.298] Value: <not collected>
[10:22:45.298] Conditions captured: <none>
[10:22:45.298] Early signaling: FALSE
[10:22:45.298] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:45.298] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:45.308] Chunk #2 of 2 ... DONE
[10:22:45.308] Launching 2 futures (chunks) ... DONE
[10:22:45.309] Resolving 2 futures (chunks) ...
[10:22:45.309] resolve() on list ...
[10:22:45.309]  recursive: 0
[10:22:45.309]  length: 2
[10:22:45.309] 
[10:22:45.310] Future #1
[10:22:45.310] result() for MulticoreFuture ...
[10:22:45.311] result() for MulticoreFuture ...
[10:22:45.311] result() for MulticoreFuture ... done
[10:22:45.311] result() for MulticoreFuture ... done
[10:22:45.311] result() for MulticoreFuture ...
[10:22:45.311] result() for MulticoreFuture ... done
[10:22:45.312] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:22:45.312] - nx: 2
[10:22:45.312] - relay: TRUE
[10:22:45.312] - stdout: TRUE
[10:22:45.312] - signal: TRUE
[10:22:45.312] - resignal: FALSE
[10:22:45.313] - force: TRUE
[10:22:45.313] - relayed: [n=2] FALSE, FALSE
[10:22:45.313] - queued futures: [n=2] FALSE, FALSE
[10:22:45.313]  - until=1
[10:22:45.313]  - relaying element #1
[10:22:45.313] result() for MulticoreFuture ...
[10:22:45.313] result() for MulticoreFuture ... done
[10:22:45.314] result() for MulticoreFuture ...
[10:22:45.314] result() for MulticoreFuture ... done
[10:22:45.314] result() for MulticoreFuture ...
[10:22:45.314] result() for MulticoreFuture ... done
[10:22:45.314] result() for MulticoreFuture ...
[10:22:45.315] result() for MulticoreFuture ... done
[10:22:45.315] - relayed: [n=2] TRUE, FALSE
[10:22:45.315] - queued futures: [n=2] TRUE, FALSE
[10:22:45.315] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:22:45.315]  length: 1 (resolved future 1)
[10:22:45.316] Future #2
[10:22:45.316] result() for MulticoreFuture ...
[10:22:45.316] result() for MulticoreFuture ...
[10:22:45.317] result() for MulticoreFuture ... done
[10:22:45.317] result() for MulticoreFuture ... done
[10:22:45.317] result() for MulticoreFuture ...
[10:22:45.317] result() for MulticoreFuture ... done
[10:22:45.317] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:22:45.317] - nx: 2
[10:22:45.317] - relay: TRUE
[10:22:45.318] - stdout: TRUE
[10:22:45.318] - signal: TRUE
[10:22:45.318] - resignal: FALSE
[10:22:45.318] - force: TRUE
[10:22:45.318] - relayed: [n=2] TRUE, FALSE
[10:22:45.318] - queued futures: [n=2] TRUE, FALSE
[10:22:45.318]  - until=2
[10:22:45.318]  - relaying element #2
[10:22:45.319] result() for MulticoreFuture ...
[10:22:45.319] result() for MulticoreFuture ... done
[10:22:45.319] result() for MulticoreFuture ...
[10:22:45.319] result() for MulticoreFuture ... done
[10:22:45.319] result() for MulticoreFuture ...
[10:22:45.319] result() for MulticoreFuture ... done
[10:22:45.319] result() for MulticoreFuture ...
[10:22:45.319] result() for MulticoreFuture ... done
[10:22:45.320] - relayed: [n=2] TRUE, TRUE
[10:22:45.320] - queued futures: [n=2] TRUE, TRUE
[10:22:45.320] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:22:45.320]  length: 0 (resolved future 2)
[10:22:45.320] Relaying remaining futures
[10:22:45.320] signalConditionsASAP(NULL, pos=0) ...
[10:22:45.320] - nx: 2
[10:22:45.320] - relay: TRUE
[10:22:45.320] - stdout: TRUE
[10:22:45.321] - signal: TRUE
[10:22:45.321] - resignal: FALSE
[10:22:45.321] - force: TRUE
[10:22:45.321] - relayed: [n=2] TRUE, TRUE
[10:22:45.321] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:22:45.321] - relayed: [n=2] TRUE, TRUE
[10:22:45.321] - queued futures: [n=2] TRUE, TRUE
[10:22:45.321] signalConditionsASAP(NULL, pos=0) ... done
[10:22:45.322] resolve() on list ... DONE
[10:22:45.322] result() for MulticoreFuture ...
[10:22:45.322] result() for MulticoreFuture ... done
[10:22:45.322] result() for MulticoreFuture ...
[10:22:45.322] result() for MulticoreFuture ... done
[10:22:45.322] result() for MulticoreFuture ...
[10:22:45.322] result() for MulticoreFuture ... done
[10:22:45.322] result() for MulticoreFuture ...
[10:22:45.322] result() for MulticoreFuture ... done
[10:22:45.323]  - Number of value chunks collected: 2
[10:22:45.323] Resolving 2 futures (chunks) ... DONE
[10:22:45.323] Reducing values from 2 chunks ...
[10:22:45.323]  - Number of values collected after concatenation: 2
[10:22:45.323]  - Number of values expected: 2
[10:22:45.323] Reducing values from 2 chunks ... DONE
[10:22:45.323] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[10:22:45.324] getGlobalsAndPackagesXApply() ...
[10:22:45.324]  - future.globals: TRUE
[10:22:45.324] getGlobalsAndPackages() ...
[10:22:45.324] Searching for globals...
[10:22:45.330] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[10:22:45.330] Searching for globals ... DONE
[10:22:45.330] Resolving globals: FALSE
[10:22:45.331] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[10:22:45.331] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[10:22:45.332] - globals: [1] ‘FUN’
[10:22:45.332] 
[10:22:45.332] getGlobalsAndPackages() ... DONE
[10:22:45.332]  - globals found/used: [n=1] ‘FUN’
[10:22:45.332]  - needed namespaces: [n=0] 
[10:22:45.332] Finding globals ... DONE
[10:22:45.332]  - use_args: TRUE
[10:22:45.332]  - Getting '...' globals ...
[10:22:45.333] resolve() on list ...
[10:22:45.333]  recursive: 0
[10:22:45.333]  length: 1
[10:22:45.333]  elements: ‘...’
[10:22:45.333]  length: 0 (resolved future 1)
[10:22:45.333] resolve() on list ... DONE
[10:22:45.334]    - '...' content: [n=0] 
[10:22:45.334] List of 1
[10:22:45.334]  $ ...: list()
[10:22:45.334]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:45.334]  - attr(*, "where")=List of 1
[10:22:45.334]   ..$ ...:<environment: 0x55ca4d137188> 
[10:22:45.334]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:45.334]  - attr(*, "resolved")= logi TRUE
[10:22:45.334]  - attr(*, "total_size")= num NA
[10:22:45.337]  - Getting '...' globals ... DONE
[10:22:45.337] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:45.337] List of 2
[10:22:45.337]  $ ...future.FUN:function (x)  
[10:22:45.337]  $ ...          : list()
[10:22:45.337]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:45.337]  - attr(*, "where")=List of 2
[10:22:45.337]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:45.337]   ..$ ...          :<environment: 0x55ca4d137188> 
[10:22:45.337]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:45.337]  - attr(*, "resolved")= logi FALSE
[10:22:45.337]  - attr(*, "total_size")= num 9888
[10:22:45.339] Packages to be attached in all futures: [n=0] 
[10:22:45.340] getGlobalsAndPackagesXApply() ... DONE
[10:22:45.343] future_lapply() ...
[10:22:45.348] Number of chunks: 2
[10:22:45.348] getGlobalsAndPackagesXApply() ...
[10:22:45.349]  - future.globals: <name-value list> with names ‘list()’
[10:22:45.349]  - use_args: TRUE
[10:22:45.349] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:22:45.349] List of 2
[10:22:45.349]  $ ...          : list()
[10:22:45.349]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:45.349]  $ ...future.FUN:function (x)  
[10:22:45.349]  - attr(*, "where")=List of 2
[10:22:45.349]   ..$ ...          :<environment: 0x55ca4d137188> 
[10:22:45.349]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[10:22:45.349]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:45.349]  - attr(*, "resolved")= logi FALSE
[10:22:45.349]  - attr(*, "total_size")= num NA
[10:22:45.352] Packages to be attached in all futures: [n=0] 
[10:22:45.352] getGlobalsAndPackagesXApply() ... DONE
[10:22:45.352] Number of futures (= number of chunks): 2
[10:22:45.353] Launching 2 futures (chunks) ...
[10:22:45.353] Chunk #1 of 2 ...
[10:22:45.353]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:45.353]  - seeds: <none>
[10:22:45.355]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:45.355] getGlobalsAndPackages() ...
[10:22:45.355] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:45.356] Resolving globals: FALSE
[10:22:45.356] Tweak future expression to call with '...' arguments ...
[10:22:45.356] {
[10:22:45.356]     do.call(function(...) {
[10:22:45.356]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:45.356]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:45.356]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:45.356]             on.exit(options(oopts), add = TRUE)
[10:22:45.356]         }
[10:22:45.356]         {
[10:22:45.356]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:45.356]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:45.356]                 ...future.FUN(...future.X_jj, ...)
[10:22:45.356]             })
[10:22:45.356]         }
[10:22:45.356]     }, args = future.call.arguments)
[10:22:45.356] }
[10:22:45.356] Tweak future expression to call with '...' arguments ... DONE
[10:22:45.357] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:45.357] 
[10:22:45.357] getGlobalsAndPackages() ... DONE
[10:22:45.357] run() for ‘Future’ ...
[10:22:45.357] - state: ‘created’
[10:22:45.358] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:45.361] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:45.362] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:45.362]   - Field: ‘label’
[10:22:45.362]   - Field: ‘local’
[10:22:45.362]   - Field: ‘owner’
[10:22:45.362]   - Field: ‘envir’
[10:22:45.362]   - Field: ‘workers’
[10:22:45.362]   - Field: ‘packages’
[10:22:45.362]   - Field: ‘gc’
[10:22:45.362]   - Field: ‘job’
[10:22:45.362]   - Field: ‘conditions’
[10:22:45.363]   - Field: ‘expr’
[10:22:45.363]   - Field: ‘uuid’
[10:22:45.363]   - Field: ‘seed’
[10:22:45.363]   - Field: ‘version’
[10:22:45.363]   - Field: ‘result’
[10:22:45.363]   - Field: ‘asynchronous’
[10:22:45.363]   - Field: ‘calls’
[10:22:45.363]   - Field: ‘globals’
[10:22:45.363]   - Field: ‘stdout’
[10:22:45.363]   - Field: ‘earlySignal’
[10:22:45.364]   - Field: ‘lazy’
[10:22:45.364]   - Field: ‘state’
[10:22:45.364] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:45.364] - Launch lazy future ...
[10:22:45.364] Packages needed by the future expression (n = 0): <none>
[10:22:45.364] Packages needed by future strategies (n = 0): <none>
[10:22:45.365] {
[10:22:45.365]     {
[10:22:45.365]         {
[10:22:45.365]             ...future.startTime <- base::Sys.time()
[10:22:45.365]             {
[10:22:45.365]                 {
[10:22:45.365]                   {
[10:22:45.365]                     {
[10:22:45.365]                       base::local({
[10:22:45.365]                         has_future <- base::requireNamespace("future", 
[10:22:45.365]                           quietly = TRUE)
[10:22:45.365]                         if (has_future) {
[10:22:45.365]                           ns <- base::getNamespace("future")
[10:22:45.365]                           version <- ns[[".package"]][["version"]]
[10:22:45.365]                           if (is.null(version)) 
[10:22:45.365]                             version <- utils::packageVersion("future")
[10:22:45.365]                         }
[10:22:45.365]                         else {
[10:22:45.365]                           version <- NULL
[10:22:45.365]                         }
[10:22:45.365]                         if (!has_future || version < "1.8.0") {
[10:22:45.365]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:45.365]                             "", base::R.version$version.string), 
[10:22:45.365]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:45.365]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:45.365]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:45.365]                               "release", "version")], collapse = " "), 
[10:22:45.365]                             hostname = base::Sys.info()[["nodename"]])
[10:22:45.365]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:45.365]                             info)
[10:22:45.365]                           info <- base::paste(info, collapse = "; ")
[10:22:45.365]                           if (!has_future) {
[10:22:45.365]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:45.365]                               info)
[10:22:45.365]                           }
[10:22:45.365]                           else {
[10:22:45.365]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:45.365]                               info, version)
[10:22:45.365]                           }
[10:22:45.365]                           base::stop(msg)
[10:22:45.365]                         }
[10:22:45.365]                       })
[10:22:45.365]                     }
[10:22:45.365]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:45.365]                     base::options(mc.cores = 1L)
[10:22:45.365]                   }
[10:22:45.365]                   options(future.plan = NULL)
[10:22:45.365]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:45.365]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:45.365]                 }
[10:22:45.365]                 ...future.workdir <- getwd()
[10:22:45.365]             }
[10:22:45.365]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:45.365]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:45.365]         }
[10:22:45.365]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:45.365]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:45.365]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:45.365]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:45.365]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:45.365]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:45.365]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:45.365]             base::names(...future.oldOptions))
[10:22:45.365]     }
[10:22:45.365]     if (FALSE) {
[10:22:45.365]     }
[10:22:45.365]     else {
[10:22:45.365]         if (TRUE) {
[10:22:45.365]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:45.365]                 open = "w")
[10:22:45.365]         }
[10:22:45.365]         else {
[10:22:45.365]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:45.365]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:45.365]         }
[10:22:45.365]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:45.365]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:45.365]             base::sink(type = "output", split = FALSE)
[10:22:45.365]             base::close(...future.stdout)
[10:22:45.365]         }, add = TRUE)
[10:22:45.365]     }
[10:22:45.365]     ...future.frame <- base::sys.nframe()
[10:22:45.365]     ...future.conditions <- base::list()
[10:22:45.365]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:45.365]     if (FALSE) {
[10:22:45.365]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:45.365]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:45.365]     }
[10:22:45.365]     ...future.result <- base::tryCatch({
[10:22:45.365]         base::withCallingHandlers({
[10:22:45.365]             ...future.value <- base::withVisible(base::local({
[10:22:45.365]                 withCallingHandlers({
[10:22:45.365]                   {
[10:22:45.365]                     do.call(function(...) {
[10:22:45.365]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:45.365]                       if (!identical(...future.globals.maxSize.org, 
[10:22:45.365]                         ...future.globals.maxSize)) {
[10:22:45.365]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:45.365]                         on.exit(options(oopts), add = TRUE)
[10:22:45.365]                       }
[10:22:45.365]                       {
[10:22:45.365]                         lapply(seq_along(...future.elements_ii), 
[10:22:45.365]                           FUN = function(jj) {
[10:22:45.365]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:45.365]                             ...future.FUN(...future.X_jj, ...)
[10:22:45.365]                           })
[10:22:45.365]                       }
[10:22:45.365]                     }, args = future.call.arguments)
[10:22:45.365]                   }
[10:22:45.365]                 }, immediateCondition = function(cond) {
[10:22:45.365]                   save_rds <- function (object, pathname, ...) 
[10:22:45.365]                   {
[10:22:45.365]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:45.365]                     if (file_test("-f", pathname_tmp)) {
[10:22:45.365]                       fi_tmp <- file.info(pathname_tmp)
[10:22:45.365]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:45.365]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:45.365]                         fi_tmp[["mtime"]])
[10:22:45.365]                     }
[10:22:45.365]                     tryCatch({
[10:22:45.365]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:45.365]                     }, error = function(ex) {
[10:22:45.365]                       msg <- conditionMessage(ex)
[10:22:45.365]                       fi_tmp <- file.info(pathname_tmp)
[10:22:45.365]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:45.365]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:45.365]                         fi_tmp[["mtime"]], msg)
[10:22:45.365]                       ex$message <- msg
[10:22:45.365]                       stop(ex)
[10:22:45.365]                     })
[10:22:45.365]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:45.365]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:45.365]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:45.365]                       fi_tmp <- file.info(pathname_tmp)
[10:22:45.365]                       fi <- file.info(pathname)
[10:22:45.365]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:45.365]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:45.365]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:45.365]                         fi[["size"]], fi[["mtime"]])
[10:22:45.365]                       stop(msg)
[10:22:45.365]                     }
[10:22:45.365]                     invisible(pathname)
[10:22:45.365]                   }
[10:22:45.365]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:45.365]                     rootPath = tempdir()) 
[10:22:45.365]                   {
[10:22:45.365]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:45.365]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:45.365]                       tmpdir = path, fileext = ".rds")
[10:22:45.365]                     save_rds(obj, file)
[10:22:45.365]                   }
[10:22:45.365]                   saveImmediateCondition(cond, path = "/tmp/RtmpTHXGJm/.future/immediateConditions")
[10:22:45.365]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.365]                   {
[10:22:45.365]                     inherits <- base::inherits
[10:22:45.365]                     invokeRestart <- base::invokeRestart
[10:22:45.365]                     is.null <- base::is.null
[10:22:45.365]                     muffled <- FALSE
[10:22:45.365]                     if (inherits(cond, "message")) {
[10:22:45.365]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:45.365]                       if (muffled) 
[10:22:45.365]                         invokeRestart("muffleMessage")
[10:22:45.365]                     }
[10:22:45.365]                     else if (inherits(cond, "warning")) {
[10:22:45.365]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:45.365]                       if (muffled) 
[10:22:45.365]                         invokeRestart("muffleWarning")
[10:22:45.365]                     }
[10:22:45.365]                     else if (inherits(cond, "condition")) {
[10:22:45.365]                       if (!is.null(pattern)) {
[10:22:45.365]                         computeRestarts <- base::computeRestarts
[10:22:45.365]                         grepl <- base::grepl
[10:22:45.365]                         restarts <- computeRestarts(cond)
[10:22:45.365]                         for (restart in restarts) {
[10:22:45.365]                           name <- restart$name
[10:22:45.365]                           if (is.null(name)) 
[10:22:45.365]                             next
[10:22:45.365]                           if (!grepl(pattern, name)) 
[10:22:45.365]                             next
[10:22:45.365]                           invokeRestart(restart)
[10:22:45.365]                           muffled <- TRUE
[10:22:45.365]                           break
[10:22:45.365]                         }
[10:22:45.365]                       }
[10:22:45.365]                     }
[10:22:45.365]                     invisible(muffled)
[10:22:45.365]                   }
[10:22:45.365]                   muffleCondition(cond)
[10:22:45.365]                 })
[10:22:45.365]             }))
[10:22:45.365]             future::FutureResult(value = ...future.value$value, 
[10:22:45.365]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:45.365]                   ...future.rng), globalenv = if (FALSE) 
[10:22:45.365]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:45.365]                     ...future.globalenv.names))
[10:22:45.365]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:45.365]         }, condition = base::local({
[10:22:45.365]             c <- base::c
[10:22:45.365]             inherits <- base::inherits
[10:22:45.365]             invokeRestart <- base::invokeRestart
[10:22:45.365]             length <- base::length
[10:22:45.365]             list <- base::list
[10:22:45.365]             seq.int <- base::seq.int
[10:22:45.365]             signalCondition <- base::signalCondition
[10:22:45.365]             sys.calls <- base::sys.calls
[10:22:45.365]             `[[` <- base::`[[`
[10:22:45.365]             `+` <- base::`+`
[10:22:45.365]             `<<-` <- base::`<<-`
[10:22:45.365]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:45.365]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:45.365]                   3L)]
[10:22:45.365]             }
[10:22:45.365]             function(cond) {
[10:22:45.365]                 is_error <- inherits(cond, "error")
[10:22:45.365]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:45.365]                   NULL)
[10:22:45.365]                 if (is_error) {
[10:22:45.365]                   sessionInformation <- function() {
[10:22:45.365]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:45.365]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:45.365]                       search = base::search(), system = base::Sys.info())
[10:22:45.365]                   }
[10:22:45.365]                   ...future.conditions[[length(...future.conditions) + 
[10:22:45.365]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:45.365]                     cond$call), session = sessionInformation(), 
[10:22:45.365]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:45.365]                   signalCondition(cond)
[10:22:45.365]                 }
[10:22:45.365]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:45.365]                 "immediateCondition"))) {
[10:22:45.365]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:45.365]                   ...future.conditions[[length(...future.conditions) + 
[10:22:45.365]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:45.365]                   if (TRUE && !signal) {
[10:22:45.365]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.365]                     {
[10:22:45.365]                       inherits <- base::inherits
[10:22:45.365]                       invokeRestart <- base::invokeRestart
[10:22:45.365]                       is.null <- base::is.null
[10:22:45.365]                       muffled <- FALSE
[10:22:45.365]                       if (inherits(cond, "message")) {
[10:22:45.365]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:45.365]                         if (muffled) 
[10:22:45.365]                           invokeRestart("muffleMessage")
[10:22:45.365]                       }
[10:22:45.365]                       else if (inherits(cond, "warning")) {
[10:22:45.365]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:45.365]                         if (muffled) 
[10:22:45.365]                           invokeRestart("muffleWarning")
[10:22:45.365]                       }
[10:22:45.365]                       else if (inherits(cond, "condition")) {
[10:22:45.365]                         if (!is.null(pattern)) {
[10:22:45.365]                           computeRestarts <- base::computeRestarts
[10:22:45.365]                           grepl <- base::grepl
[10:22:45.365]                           restarts <- computeRestarts(cond)
[10:22:45.365]                           for (restart in restarts) {
[10:22:45.365]                             name <- restart$name
[10:22:45.365]                             if (is.null(name)) 
[10:22:45.365]                               next
[10:22:45.365]                             if (!grepl(pattern, name)) 
[10:22:45.365]                               next
[10:22:45.365]                             invokeRestart(restart)
[10:22:45.365]                             muffled <- TRUE
[10:22:45.365]                             break
[10:22:45.365]                           }
[10:22:45.365]                         }
[10:22:45.365]                       }
[10:22:45.365]                       invisible(muffled)
[10:22:45.365]                     }
[10:22:45.365]                     muffleCondition(cond, pattern = "^muffle")
[10:22:45.365]                   }
[10:22:45.365]                 }
[10:22:45.365]                 else {
[10:22:45.365]                   if (TRUE) {
[10:22:45.365]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.365]                     {
[10:22:45.365]                       inherits <- base::inherits
[10:22:45.365]                       invokeRestart <- base::invokeRestart
[10:22:45.365]                       is.null <- base::is.null
[10:22:45.365]                       muffled <- FALSE
[10:22:45.365]                       if (inherits(cond, "message")) {
[10:22:45.365]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:45.365]                         if (muffled) 
[10:22:45.365]                           invokeRestart("muffleMessage")
[10:22:45.365]                       }
[10:22:45.365]                       else if (inherits(cond, "warning")) {
[10:22:45.365]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:45.365]                         if (muffled) 
[10:22:45.365]                           invokeRestart("muffleWarning")
[10:22:45.365]                       }
[10:22:45.365]                       else if (inherits(cond, "condition")) {
[10:22:45.365]                         if (!is.null(pattern)) {
[10:22:45.365]                           computeRestarts <- base::computeRestarts
[10:22:45.365]                           grepl <- base::grepl
[10:22:45.365]                           restarts <- computeRestarts(cond)
[10:22:45.365]                           for (restart in restarts) {
[10:22:45.365]                             name <- restart$name
[10:22:45.365]                             if (is.null(name)) 
[10:22:45.365]                               next
[10:22:45.365]                             if (!grepl(pattern, name)) 
[10:22:45.365]                               next
[10:22:45.365]                             invokeRestart(restart)
[10:22:45.365]                             muffled <- TRUE
[10:22:45.365]                             break
[10:22:45.365]                           }
[10:22:45.365]                         }
[10:22:45.365]                       }
[10:22:45.365]                       invisible(muffled)
[10:22:45.365]                     }
[10:22:45.365]                     muffleCondition(cond, pattern = "^muffle")
[10:22:45.365]                   }
[10:22:45.365]                 }
[10:22:45.365]             }
[10:22:45.365]         }))
[10:22:45.365]     }, error = function(ex) {
[10:22:45.365]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:45.365]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:45.365]                 ...future.rng), started = ...future.startTime, 
[10:22:45.365]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:45.365]             version = "1.8"), class = "FutureResult")
[10:22:45.365]     }, finally = {
[10:22:45.365]         if (!identical(...future.workdir, getwd())) 
[10:22:45.365]             setwd(...future.workdir)
[10:22:45.365]         {
[10:22:45.365]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:45.365]                 ...future.oldOptions$nwarnings <- NULL
[10:22:45.365]             }
[10:22:45.365]             base::options(...future.oldOptions)
[10:22:45.365]             if (.Platform$OS.type == "windows") {
[10:22:45.365]                 old_names <- names(...future.oldEnvVars)
[10:22:45.365]                 envs <- base::Sys.getenv()
[10:22:45.365]                 names <- names(envs)
[10:22:45.365]                 common <- intersect(names, old_names)
[10:22:45.365]                 added <- setdiff(names, old_names)
[10:22:45.365]                 removed <- setdiff(old_names, names)
[10:22:45.365]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:45.365]                   envs[common]]
[10:22:45.365]                 NAMES <- toupper(changed)
[10:22:45.365]                 args <- list()
[10:22:45.365]                 for (kk in seq_along(NAMES)) {
[10:22:45.365]                   name <- changed[[kk]]
[10:22:45.365]                   NAME <- NAMES[[kk]]
[10:22:45.365]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.365]                     next
[10:22:45.365]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:45.365]                 }
[10:22:45.365]                 NAMES <- toupper(added)
[10:22:45.365]                 for (kk in seq_along(NAMES)) {
[10:22:45.365]                   name <- added[[kk]]
[10:22:45.365]                   NAME <- NAMES[[kk]]
[10:22:45.365]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.365]                     next
[10:22:45.365]                   args[[name]] <- ""
[10:22:45.365]                 }
[10:22:45.365]                 NAMES <- toupper(removed)
[10:22:45.365]                 for (kk in seq_along(NAMES)) {
[10:22:45.365]                   name <- removed[[kk]]
[10:22:45.365]                   NAME <- NAMES[[kk]]
[10:22:45.365]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.365]                     next
[10:22:45.365]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:45.365]                 }
[10:22:45.365]                 if (length(args) > 0) 
[10:22:45.365]                   base::do.call(base::Sys.setenv, args = args)
[10:22:45.365]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:45.365]             }
[10:22:45.365]             else {
[10:22:45.365]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:45.365]             }
[10:22:45.365]             {
[10:22:45.365]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:45.365]                   0L) {
[10:22:45.365]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:45.365]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:45.365]                   base::options(opts)
[10:22:45.365]                 }
[10:22:45.365]                 {
[10:22:45.365]                   {
[10:22:45.365]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:45.365]                     NULL
[10:22:45.365]                   }
[10:22:45.365]                   options(future.plan = NULL)
[10:22:45.365]                   if (is.na(NA_character_)) 
[10:22:45.365]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:45.365]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:45.365]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:45.365]                     envir = parent.frame()) 
[10:22:45.365]                   {
[10:22:45.365]                     default_workers <- missing(workers)
[10:22:45.365]                     if (is.function(workers)) 
[10:22:45.365]                       workers <- workers()
[10:22:45.365]                     workers <- structure(as.integer(workers), 
[10:22:45.365]                       class = class(workers))
[10:22:45.365]                     stop_if_not(is.finite(workers), workers >= 
[10:22:45.365]                       1L)
[10:22:45.365]                     if ((workers == 1L && !inherits(workers, 
[10:22:45.365]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:45.365]                       if (default_workers) 
[10:22:45.365]                         supportsMulticore(warn = TRUE)
[10:22:45.365]                       return(sequential(..., envir = envir))
[10:22:45.365]                     }
[10:22:45.365]                     oopts <- options(mc.cores = workers)
[10:22:45.365]                     on.exit(options(oopts))
[10:22:45.365]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:45.365]                       envir = envir)
[10:22:45.365]                     if (!future$lazy) 
[10:22:45.365]                       future <- run(future)
[10:22:45.365]                     invisible(future)
[10:22:45.365]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:45.365]                 }
[10:22:45.365]             }
[10:22:45.365]         }
[10:22:45.365]     })
[10:22:45.365]     if (TRUE) {
[10:22:45.365]         base::sink(type = "output", split = FALSE)
[10:22:45.365]         if (TRUE) {
[10:22:45.365]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:45.365]         }
[10:22:45.365]         else {
[10:22:45.365]             ...future.result["stdout"] <- base::list(NULL)
[10:22:45.365]         }
[10:22:45.365]         base::close(...future.stdout)
[10:22:45.365]         ...future.stdout <- NULL
[10:22:45.365]     }
[10:22:45.365]     ...future.result$conditions <- ...future.conditions
[10:22:45.365]     ...future.result$finished <- base::Sys.time()
[10:22:45.365]     ...future.result
[10:22:45.365] }
[10:22:45.367] assign_globals() ...
[10:22:45.367] List of 5
[10:22:45.367]  $ future.call.arguments    : list()
[10:22:45.367]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:45.367]  $ ...future.FUN            :function (x)  
[10:22:45.367]  $ ...future.elements_ii    :List of 1
[10:22:45.367]   ..$ : int [1:2] 1 3
[10:22:45.367]  $ ...future.seeds_ii       : NULL
[10:22:45.367]  $ ...future.globals.maxSize: num Inf
[10:22:45.367]  - attr(*, "resolved")= logi FALSE
[10:22:45.367]  - attr(*, "total_size")= num NA
[10:22:45.367]  - attr(*, "where")=List of 5
[10:22:45.367]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:45.367]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:45.367]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:45.367]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:45.367]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:45.367]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:45.367]  - attr(*, "already-done")= logi TRUE
[10:22:45.372] - copied ‘future.call.arguments’ to environment
[10:22:45.372] - reassign environment for ‘...future.FUN’
[10:22:45.373] - copied ‘...future.FUN’ to environment
[10:22:45.373] - copied ‘...future.elements_ii’ to environment
[10:22:45.373] - copied ‘...future.seeds_ii’ to environment
[10:22:45.373] - copied ‘...future.globals.maxSize’ to environment
[10:22:45.373] assign_globals() ... done
[10:22:45.373] requestCore(): workers = 2
[10:22:45.375] MulticoreFuture started
[10:22:45.376] - Launch lazy future ... done
[10:22:45.376] run() for ‘MulticoreFuture’ ... done
[10:22:45.376] Created future:
[10:22:45.376] plan(): Setting new future strategy stack:
[10:22:45.377] List of future strategies:
[10:22:45.377] 1. sequential:
[10:22:45.377]    - args: function (..., envir = parent.frame())
[10:22:45.377]    - tweaked: FALSE
[10:22:45.377]    - call: NULL
[10:22:45.377] plan(): nbrOfWorkers() = 1
[10:22:45.380] plan(): Setting new future strategy stack:
[10:22:45.380] List of future strategies:
[10:22:45.380] 1. multicore:
[10:22:45.380]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:45.380]    - tweaked: FALSE
[10:22:45.380]    - call: plan(strategy)
[10:22:45.385] plan(): nbrOfWorkers() = 2
[10:22:45.376] MulticoreFuture:
[10:22:45.376] Label: ‘future_apply-1’
[10:22:45.376] Expression:
[10:22:45.376] {
[10:22:45.376]     do.call(function(...) {
[10:22:45.376]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:45.376]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:45.376]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:45.376]             on.exit(options(oopts), add = TRUE)
[10:22:45.376]         }
[10:22:45.376]         {
[10:22:45.376]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:45.376]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:45.376]                 ...future.FUN(...future.X_jj, ...)
[10:22:45.376]             })
[10:22:45.376]         }
[10:22:45.376]     }, args = future.call.arguments)
[10:22:45.376] }
[10:22:45.376] Lazy evaluation: FALSE
[10:22:45.376] Asynchronous evaluation: TRUE
[10:22:45.376] Local evaluation: TRUE
[10:22:45.376] Environment: R_GlobalEnv
[10:22:45.376] Capture standard output: TRUE
[10:22:45.376] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:45.376] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:45.376] Packages: <none>
[10:22:45.376] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:45.376] Resolved: TRUE
[10:22:45.376] Value: <not collected>
[10:22:45.376] Conditions captured: <none>
[10:22:45.376] Early signaling: FALSE
[10:22:45.376] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:45.376] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:45.386] Chunk #1 of 2 ... DONE
[10:22:45.386] Chunk #2 of 2 ...
[10:22:45.386]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:45.386]  - seeds: <none>
[10:22:45.386]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:45.387] getGlobalsAndPackages() ...
[10:22:45.387] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:45.387] Resolving globals: FALSE
[10:22:45.387] Tweak future expression to call with '...' arguments ...
[10:22:45.387] {
[10:22:45.387]     do.call(function(...) {
[10:22:45.387]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:45.387]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:45.387]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:45.387]             on.exit(options(oopts), add = TRUE)
[10:22:45.387]         }
[10:22:45.387]         {
[10:22:45.387]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:45.387]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:45.387]                 ...future.FUN(...future.X_jj, ...)
[10:22:45.387]             })
[10:22:45.387]         }
[10:22:45.387]     }, args = future.call.arguments)
[10:22:45.387] }
[10:22:45.388] Tweak future expression to call with '...' arguments ... DONE
[10:22:45.388] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:45.388] 
[10:22:45.389] getGlobalsAndPackages() ... DONE
[10:22:45.389] run() for ‘Future’ ...
[10:22:45.389] - state: ‘created’
[10:22:45.390] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:45.394] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:45.394] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:45.395]   - Field: ‘label’
[10:22:45.395]   - Field: ‘local’
[10:22:45.395]   - Field: ‘owner’
[10:22:45.395]   - Field: ‘envir’
[10:22:45.395]   - Field: ‘workers’
[10:22:45.395]   - Field: ‘packages’
[10:22:45.399]   - Field: ‘gc’
[10:22:45.399]   - Field: ‘job’
[10:22:45.399]   - Field: ‘conditions’
[10:22:45.400]   - Field: ‘expr’
[10:22:45.400]   - Field: ‘uuid’
[10:22:45.401]   - Field: ‘seed’
[10:22:45.401]   - Field: ‘version’
[10:22:45.401]   - Field: ‘result’
[10:22:45.401]   - Field: ‘asynchronous’
[10:22:45.402]   - Field: ‘calls’
[10:22:45.402]   - Field: ‘globals’
[10:22:45.402]   - Field: ‘stdout’
[10:22:45.402]   - Field: ‘earlySignal’
[10:22:45.403]   - Field: ‘lazy’
[10:22:45.403]   - Field: ‘state’
[10:22:45.403] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:45.403] - Launch lazy future ...
[10:22:45.404] Packages needed by the future expression (n = 0): <none>
[10:22:45.404] Packages needed by future strategies (n = 0): <none>
[10:22:45.406] {
[10:22:45.406]     {
[10:22:45.406]         {
[10:22:45.406]             ...future.startTime <- base::Sys.time()
[10:22:45.406]             {
[10:22:45.406]                 {
[10:22:45.406]                   {
[10:22:45.406]                     {
[10:22:45.406]                       base::local({
[10:22:45.406]                         has_future <- base::requireNamespace("future", 
[10:22:45.406]                           quietly = TRUE)
[10:22:45.406]                         if (has_future) {
[10:22:45.406]                           ns <- base::getNamespace("future")
[10:22:45.406]                           version <- ns[[".package"]][["version"]]
[10:22:45.406]                           if (is.null(version)) 
[10:22:45.406]                             version <- utils::packageVersion("future")
[10:22:45.406]                         }
[10:22:45.406]                         else {
[10:22:45.406]                           version <- NULL
[10:22:45.406]                         }
[10:22:45.406]                         if (!has_future || version < "1.8.0") {
[10:22:45.406]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:45.406]                             "", base::R.version$version.string), 
[10:22:45.406]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:45.406]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:45.406]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:45.406]                               "release", "version")], collapse = " "), 
[10:22:45.406]                             hostname = base::Sys.info()[["nodename"]])
[10:22:45.406]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:45.406]                             info)
[10:22:45.406]                           info <- base::paste(info, collapse = "; ")
[10:22:45.406]                           if (!has_future) {
[10:22:45.406]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:45.406]                               info)
[10:22:45.406]                           }
[10:22:45.406]                           else {
[10:22:45.406]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:45.406]                               info, version)
[10:22:45.406]                           }
[10:22:45.406]                           base::stop(msg)
[10:22:45.406]                         }
[10:22:45.406]                       })
[10:22:45.406]                     }
[10:22:45.406]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:45.406]                     base::options(mc.cores = 1L)
[10:22:45.406]                   }
[10:22:45.406]                   options(future.plan = NULL)
[10:22:45.406]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:45.406]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:45.406]                 }
[10:22:45.406]                 ...future.workdir <- getwd()
[10:22:45.406]             }
[10:22:45.406]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:45.406]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:45.406]         }
[10:22:45.406]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:45.406]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:45.406]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:45.406]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:45.406]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:45.406]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:45.406]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:45.406]             base::names(...future.oldOptions))
[10:22:45.406]     }
[10:22:45.406]     if (FALSE) {
[10:22:45.406]     }
[10:22:45.406]     else {
[10:22:45.406]         if (TRUE) {
[10:22:45.406]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:45.406]                 open = "w")
[10:22:45.406]         }
[10:22:45.406]         else {
[10:22:45.406]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:45.406]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:45.406]         }
[10:22:45.406]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:45.406]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:45.406]             base::sink(type = "output", split = FALSE)
[10:22:45.406]             base::close(...future.stdout)
[10:22:45.406]         }, add = TRUE)
[10:22:45.406]     }
[10:22:45.406]     ...future.frame <- base::sys.nframe()
[10:22:45.406]     ...future.conditions <- base::list()
[10:22:45.406]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:45.406]     if (FALSE) {
[10:22:45.406]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:45.406]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:45.406]     }
[10:22:45.406]     ...future.result <- base::tryCatch({
[10:22:45.406]         base::withCallingHandlers({
[10:22:45.406]             ...future.value <- base::withVisible(base::local({
[10:22:45.406]                 withCallingHandlers({
[10:22:45.406]                   {
[10:22:45.406]                     do.call(function(...) {
[10:22:45.406]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:45.406]                       if (!identical(...future.globals.maxSize.org, 
[10:22:45.406]                         ...future.globals.maxSize)) {
[10:22:45.406]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:45.406]                         on.exit(options(oopts), add = TRUE)
[10:22:45.406]                       }
[10:22:45.406]                       {
[10:22:45.406]                         lapply(seq_along(...future.elements_ii), 
[10:22:45.406]                           FUN = function(jj) {
[10:22:45.406]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:45.406]                             ...future.FUN(...future.X_jj, ...)
[10:22:45.406]                           })
[10:22:45.406]                       }
[10:22:45.406]                     }, args = future.call.arguments)
[10:22:45.406]                   }
[10:22:45.406]                 }, immediateCondition = function(cond) {
[10:22:45.406]                   save_rds <- function (object, pathname, ...) 
[10:22:45.406]                   {
[10:22:45.406]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:45.406]                     if (file_test("-f", pathname_tmp)) {
[10:22:45.406]                       fi_tmp <- file.info(pathname_tmp)
[10:22:45.406]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:45.406]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:45.406]                         fi_tmp[["mtime"]])
[10:22:45.406]                     }
[10:22:45.406]                     tryCatch({
[10:22:45.406]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:45.406]                     }, error = function(ex) {
[10:22:45.406]                       msg <- conditionMessage(ex)
[10:22:45.406]                       fi_tmp <- file.info(pathname_tmp)
[10:22:45.406]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:45.406]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:45.406]                         fi_tmp[["mtime"]], msg)
[10:22:45.406]                       ex$message <- msg
[10:22:45.406]                       stop(ex)
[10:22:45.406]                     })
[10:22:45.406]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:45.406]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:45.406]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:45.406]                       fi_tmp <- file.info(pathname_tmp)
[10:22:45.406]                       fi <- file.info(pathname)
[10:22:45.406]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:45.406]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:45.406]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:45.406]                         fi[["size"]], fi[["mtime"]])
[10:22:45.406]                       stop(msg)
[10:22:45.406]                     }
[10:22:45.406]                     invisible(pathname)
[10:22:45.406]                   }
[10:22:45.406]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:45.406]                     rootPath = tempdir()) 
[10:22:45.406]                   {
[10:22:45.406]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:45.406]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:45.406]                       tmpdir = path, fileext = ".rds")
[10:22:45.406]                     save_rds(obj, file)
[10:22:45.406]                   }
[10:22:45.406]                   saveImmediateCondition(cond, path = "/tmp/RtmpTHXGJm/.future/immediateConditions")
[10:22:45.406]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.406]                   {
[10:22:45.406]                     inherits <- base::inherits
[10:22:45.406]                     invokeRestart <- base::invokeRestart
[10:22:45.406]                     is.null <- base::is.null
[10:22:45.406]                     muffled <- FALSE
[10:22:45.406]                     if (inherits(cond, "message")) {
[10:22:45.406]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:45.406]                       if (muffled) 
[10:22:45.406]                         invokeRestart("muffleMessage")
[10:22:45.406]                     }
[10:22:45.406]                     else if (inherits(cond, "warning")) {
[10:22:45.406]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:45.406]                       if (muffled) 
[10:22:45.406]                         invokeRestart("muffleWarning")
[10:22:45.406]                     }
[10:22:45.406]                     else if (inherits(cond, "condition")) {
[10:22:45.406]                       if (!is.null(pattern)) {
[10:22:45.406]                         computeRestarts <- base::computeRestarts
[10:22:45.406]                         grepl <- base::grepl
[10:22:45.406]                         restarts <- computeRestarts(cond)
[10:22:45.406]                         for (restart in restarts) {
[10:22:45.406]                           name <- restart$name
[10:22:45.406]                           if (is.null(name)) 
[10:22:45.406]                             next
[10:22:45.406]                           if (!grepl(pattern, name)) 
[10:22:45.406]                             next
[10:22:45.406]                           invokeRestart(restart)
[10:22:45.406]                           muffled <- TRUE
[10:22:45.406]                           break
[10:22:45.406]                         }
[10:22:45.406]                       }
[10:22:45.406]                     }
[10:22:45.406]                     invisible(muffled)
[10:22:45.406]                   }
[10:22:45.406]                   muffleCondition(cond)
[10:22:45.406]                 })
[10:22:45.406]             }))
[10:22:45.406]             future::FutureResult(value = ...future.value$value, 
[10:22:45.406]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:45.406]                   ...future.rng), globalenv = if (FALSE) 
[10:22:45.406]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:45.406]                     ...future.globalenv.names))
[10:22:45.406]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:45.406]         }, condition = base::local({
[10:22:45.406]             c <- base::c
[10:22:45.406]             inherits <- base::inherits
[10:22:45.406]             invokeRestart <- base::invokeRestart
[10:22:45.406]             length <- base::length
[10:22:45.406]             list <- base::list
[10:22:45.406]             seq.int <- base::seq.int
[10:22:45.406]             signalCondition <- base::signalCondition
[10:22:45.406]             sys.calls <- base::sys.calls
[10:22:45.406]             `[[` <- base::`[[`
[10:22:45.406]             `+` <- base::`+`
[10:22:45.406]             `<<-` <- base::`<<-`
[10:22:45.406]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:45.406]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:45.406]                   3L)]
[10:22:45.406]             }
[10:22:45.406]             function(cond) {
[10:22:45.406]                 is_error <- inherits(cond, "error")
[10:22:45.406]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:45.406]                   NULL)
[10:22:45.406]                 if (is_error) {
[10:22:45.406]                   sessionInformation <- function() {
[10:22:45.406]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:45.406]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:45.406]                       search = base::search(), system = base::Sys.info())
[10:22:45.406]                   }
[10:22:45.406]                   ...future.conditions[[length(...future.conditions) + 
[10:22:45.406]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:45.406]                     cond$call), session = sessionInformation(), 
[10:22:45.406]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:45.406]                   signalCondition(cond)
[10:22:45.406]                 }
[10:22:45.406]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:45.406]                 "immediateCondition"))) {
[10:22:45.406]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:45.406]                   ...future.conditions[[length(...future.conditions) + 
[10:22:45.406]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:45.406]                   if (TRUE && !signal) {
[10:22:45.406]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.406]                     {
[10:22:45.406]                       inherits <- base::inherits
[10:22:45.406]                       invokeRestart <- base::invokeRestart
[10:22:45.406]                       is.null <- base::is.null
[10:22:45.406]                       muffled <- FALSE
[10:22:45.406]                       if (inherits(cond, "message")) {
[10:22:45.406]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:45.406]                         if (muffled) 
[10:22:45.406]                           invokeRestart("muffleMessage")
[10:22:45.406]                       }
[10:22:45.406]                       else if (inherits(cond, "warning")) {
[10:22:45.406]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:45.406]                         if (muffled) 
[10:22:45.406]                           invokeRestart("muffleWarning")
[10:22:45.406]                       }
[10:22:45.406]                       else if (inherits(cond, "condition")) {
[10:22:45.406]                         if (!is.null(pattern)) {
[10:22:45.406]                           computeRestarts <- base::computeRestarts
[10:22:45.406]                           grepl <- base::grepl
[10:22:45.406]                           restarts <- computeRestarts(cond)
[10:22:45.406]                           for (restart in restarts) {
[10:22:45.406]                             name <- restart$name
[10:22:45.406]                             if (is.null(name)) 
[10:22:45.406]                               next
[10:22:45.406]                             if (!grepl(pattern, name)) 
[10:22:45.406]                               next
[10:22:45.406]                             invokeRestart(restart)
[10:22:45.406]                             muffled <- TRUE
[10:22:45.406]                             break
[10:22:45.406]                           }
[10:22:45.406]                         }
[10:22:45.406]                       }
[10:22:45.406]                       invisible(muffled)
[10:22:45.406]                     }
[10:22:45.406]                     muffleCondition(cond, pattern = "^muffle")
[10:22:45.406]                   }
[10:22:45.406]                 }
[10:22:45.406]                 else {
[10:22:45.406]                   if (TRUE) {
[10:22:45.406]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.406]                     {
[10:22:45.406]                       inherits <- base::inherits
[10:22:45.406]                       invokeRestart <- base::invokeRestart
[10:22:45.406]                       is.null <- base::is.null
[10:22:45.406]                       muffled <- FALSE
[10:22:45.406]                       if (inherits(cond, "message")) {
[10:22:45.406]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:45.406]                         if (muffled) 
[10:22:45.406]                           invokeRestart("muffleMessage")
[10:22:45.406]                       }
[10:22:45.406]                       else if (inherits(cond, "warning")) {
[10:22:45.406]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:45.406]                         if (muffled) 
[10:22:45.406]                           invokeRestart("muffleWarning")
[10:22:45.406]                       }
[10:22:45.406]                       else if (inherits(cond, "condition")) {
[10:22:45.406]                         if (!is.null(pattern)) {
[10:22:45.406]                           computeRestarts <- base::computeRestarts
[10:22:45.406]                           grepl <- base::grepl
[10:22:45.406]                           restarts <- computeRestarts(cond)
[10:22:45.406]                           for (restart in restarts) {
[10:22:45.406]                             name <- restart$name
[10:22:45.406]                             if (is.null(name)) 
[10:22:45.406]                               next
[10:22:45.406]                             if (!grepl(pattern, name)) 
[10:22:45.406]                               next
[10:22:45.406]                             invokeRestart(restart)
[10:22:45.406]                             muffled <- TRUE
[10:22:45.406]                             break
[10:22:45.406]                           }
[10:22:45.406]                         }
[10:22:45.406]                       }
[10:22:45.406]                       invisible(muffled)
[10:22:45.406]                     }
[10:22:45.406]                     muffleCondition(cond, pattern = "^muffle")
[10:22:45.406]                   }
[10:22:45.406]                 }
[10:22:45.406]             }
[10:22:45.406]         }))
[10:22:45.406]     }, error = function(ex) {
[10:22:45.406]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:45.406]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:45.406]                 ...future.rng), started = ...future.startTime, 
[10:22:45.406]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:45.406]             version = "1.8"), class = "FutureResult")
[10:22:45.406]     }, finally = {
[10:22:45.406]         if (!identical(...future.workdir, getwd())) 
[10:22:45.406]             setwd(...future.workdir)
[10:22:45.406]         {
[10:22:45.406]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:45.406]                 ...future.oldOptions$nwarnings <- NULL
[10:22:45.406]             }
[10:22:45.406]             base::options(...future.oldOptions)
[10:22:45.406]             if (.Platform$OS.type == "windows") {
[10:22:45.406]                 old_names <- names(...future.oldEnvVars)
[10:22:45.406]                 envs <- base::Sys.getenv()
[10:22:45.406]                 names <- names(envs)
[10:22:45.406]                 common <- intersect(names, old_names)
[10:22:45.406]                 added <- setdiff(names, old_names)
[10:22:45.406]                 removed <- setdiff(old_names, names)
[10:22:45.406]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:45.406]                   envs[common]]
[10:22:45.406]                 NAMES <- toupper(changed)
[10:22:45.406]                 args <- list()
[10:22:45.406]                 for (kk in seq_along(NAMES)) {
[10:22:45.406]                   name <- changed[[kk]]
[10:22:45.406]                   NAME <- NAMES[[kk]]
[10:22:45.406]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.406]                     next
[10:22:45.406]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:45.406]                 }
[10:22:45.406]                 NAMES <- toupper(added)
[10:22:45.406]                 for (kk in seq_along(NAMES)) {
[10:22:45.406]                   name <- added[[kk]]
[10:22:45.406]                   NAME <- NAMES[[kk]]
[10:22:45.406]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.406]                     next
[10:22:45.406]                   args[[name]] <- ""
[10:22:45.406]                 }
[10:22:45.406]                 NAMES <- toupper(removed)
[10:22:45.406]                 for (kk in seq_along(NAMES)) {
[10:22:45.406]                   name <- removed[[kk]]
[10:22:45.406]                   NAME <- NAMES[[kk]]
[10:22:45.406]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.406]                     next
[10:22:45.406]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:45.406]                 }
[10:22:45.406]                 if (length(args) > 0) 
[10:22:45.406]                   base::do.call(base::Sys.setenv, args = args)
[10:22:45.406]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:45.406]             }
[10:22:45.406]             else {
[10:22:45.406]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:45.406]             }
[10:22:45.406]             {
[10:22:45.406]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:45.406]                   0L) {
[10:22:45.406]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:45.406]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:45.406]                   base::options(opts)
[10:22:45.406]                 }
[10:22:45.406]                 {
[10:22:45.406]                   {
[10:22:45.406]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:45.406]                     NULL
[10:22:45.406]                   }
[10:22:45.406]                   options(future.plan = NULL)
[10:22:45.406]                   if (is.na(NA_character_)) 
[10:22:45.406]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:45.406]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:45.406]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:45.406]                     envir = parent.frame()) 
[10:22:45.406]                   {
[10:22:45.406]                     default_workers <- missing(workers)
[10:22:45.406]                     if (is.function(workers)) 
[10:22:45.406]                       workers <- workers()
[10:22:45.406]                     workers <- structure(as.integer(workers), 
[10:22:45.406]                       class = class(workers))
[10:22:45.406]                     stop_if_not(is.finite(workers), workers >= 
[10:22:45.406]                       1L)
[10:22:45.406]                     if ((workers == 1L && !inherits(workers, 
[10:22:45.406]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:45.406]                       if (default_workers) 
[10:22:45.406]                         supportsMulticore(warn = TRUE)
[10:22:45.406]                       return(sequential(..., envir = envir))
[10:22:45.406]                     }
[10:22:45.406]                     oopts <- options(mc.cores = workers)
[10:22:45.406]                     on.exit(options(oopts))
[10:22:45.406]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:45.406]                       envir = envir)
[10:22:45.406]                     if (!future$lazy) 
[10:22:45.406]                       future <- run(future)
[10:22:45.406]                     invisible(future)
[10:22:45.406]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:45.406]                 }
[10:22:45.406]             }
[10:22:45.406]         }
[10:22:45.406]     })
[10:22:45.406]     if (TRUE) {
[10:22:45.406]         base::sink(type = "output", split = FALSE)
[10:22:45.406]         if (TRUE) {
[10:22:45.406]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:45.406]         }
[10:22:45.406]         else {
[10:22:45.406]             ...future.result["stdout"] <- base::list(NULL)
[10:22:45.406]         }
[10:22:45.406]         base::close(...future.stdout)
[10:22:45.406]         ...future.stdout <- NULL
[10:22:45.406]     }
[10:22:45.406]     ...future.result$conditions <- ...future.conditions
[10:22:45.406]     ...future.result$finished <- base::Sys.time()
[10:22:45.406]     ...future.result
[10:22:45.406] }
[10:22:45.408] assign_globals() ...
[10:22:45.409] List of 5
[10:22:45.409]  $ future.call.arguments    : list()
[10:22:45.409]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:45.409]  $ ...future.FUN            :function (x)  
[10:22:45.409]  $ ...future.elements_ii    :List of 1
[10:22:45.409]   ..$ : int [1:2] 2 4
[10:22:45.409]  $ ...future.seeds_ii       : NULL
[10:22:45.409]  $ ...future.globals.maxSize: num Inf
[10:22:45.409]  - attr(*, "resolved")= logi FALSE
[10:22:45.409]  - attr(*, "total_size")= num NA
[10:22:45.409]  - attr(*, "where")=List of 5
[10:22:45.409]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:45.409]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:45.409]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:45.409]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:45.409]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:45.409]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:45.409]  - attr(*, "already-done")= logi TRUE
[10:22:45.416] - copied ‘future.call.arguments’ to environment
[10:22:45.416] - reassign environment for ‘...future.FUN’
[10:22:45.416] - copied ‘...future.FUN’ to environment
[10:22:45.416] - copied ‘...future.elements_ii’ to environment
[10:22:45.417] - copied ‘...future.seeds_ii’ to environment
[10:22:45.417] - copied ‘...future.globals.maxSize’ to environment
[10:22:45.417] assign_globals() ... done
[10:22:45.417] requestCore(): workers = 2
[10:22:45.419] MulticoreFuture started
[10:22:45.420] - Launch lazy future ... done
[10:22:45.420] run() for ‘MulticoreFuture’ ... done
[10:22:45.420] Created future:
[10:22:45.423] plan(): Setting new future strategy stack:
[10:22:45.423] List of future strategies:
[10:22:45.423] 1. sequential:
[10:22:45.423]    - args: function (..., envir = parent.frame())
[10:22:45.423]    - tweaked: FALSE
[10:22:45.423]    - call: NULL
[10:22:45.424] plan(): nbrOfWorkers() = 1
[10:22:45.426] plan(): Setting new future strategy stack:
[10:22:45.426] List of future strategies:
[10:22:45.426] 1. multicore:
[10:22:45.426]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:45.426]    - tweaked: FALSE
[10:22:45.426]    - call: plan(strategy)
[10:22:45.431] plan(): nbrOfWorkers() = 2
[10:22:45.420] MulticoreFuture:
[10:22:45.420] Label: ‘future_apply-2’
[10:22:45.420] Expression:
[10:22:45.420] {
[10:22:45.420]     do.call(function(...) {
[10:22:45.420]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:45.420]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:45.420]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:45.420]             on.exit(options(oopts), add = TRUE)
[10:22:45.420]         }
[10:22:45.420]         {
[10:22:45.420]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:45.420]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:45.420]                 ...future.FUN(...future.X_jj, ...)
[10:22:45.420]             })
[10:22:45.420]         }
[10:22:45.420]     }, args = future.call.arguments)
[10:22:45.420] }
[10:22:45.420] Lazy evaluation: FALSE
[10:22:45.420] Asynchronous evaluation: TRUE
[10:22:45.420] Local evaluation: TRUE
[10:22:45.420] Environment: R_GlobalEnv
[10:22:45.420] Capture standard output: TRUE
[10:22:45.420] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:45.420] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:45.420] Packages: <none>
[10:22:45.420] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:45.420] Resolved: TRUE
[10:22:45.420] Value: <not collected>
[10:22:45.420] Conditions captured: <none>
[10:22:45.420] Early signaling: FALSE
[10:22:45.420] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:45.420] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:45.432] Chunk #2 of 2 ... DONE
[10:22:45.432] Launching 2 futures (chunks) ... DONE
[10:22:45.433] Resolving 2 futures (chunks) ...
[10:22:45.433] resolve() on list ...
[10:22:45.433]  recursive: 0
[10:22:45.433]  length: 2
[10:22:45.433] 
[10:22:45.434] Future #1
[10:22:45.434] result() for MulticoreFuture ...
[10:22:45.435] result() for MulticoreFuture ...
[10:22:45.435] result() for MulticoreFuture ... done
[10:22:45.435] result() for MulticoreFuture ... done
[10:22:45.435] result() for MulticoreFuture ...
[10:22:45.436] result() for MulticoreFuture ... done
[10:22:45.436] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:22:45.436] - nx: 2
[10:22:45.436] - relay: TRUE
[10:22:45.436] - stdout: TRUE
[10:22:45.436] - signal: TRUE
[10:22:45.437] - resignal: FALSE
[10:22:45.437] - force: TRUE
[10:22:45.437] - relayed: [n=2] FALSE, FALSE
[10:22:45.437] - queued futures: [n=2] FALSE, FALSE
[10:22:45.437]  - until=1
[10:22:45.437]  - relaying element #1
[10:22:45.437] result() for MulticoreFuture ...
[10:22:45.438] result() for MulticoreFuture ... done
[10:22:45.438] result() for MulticoreFuture ...
[10:22:45.438] result() for MulticoreFuture ... done
[10:22:45.438] result() for MulticoreFuture ...
[10:22:45.438] result() for MulticoreFuture ... done
[10:22:45.439] result() for MulticoreFuture ...
[10:22:45.439] result() for MulticoreFuture ... done
[10:22:45.439] - relayed: [n=2] TRUE, FALSE
[10:22:45.439] - queued futures: [n=2] TRUE, FALSE
[10:22:45.439] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:22:45.439]  length: 1 (resolved future 1)
[10:22:45.440] Future #2
[10:22:45.440] result() for MulticoreFuture ...
[10:22:45.441] result() for MulticoreFuture ...
[10:22:45.441] result() for MulticoreFuture ... done
[10:22:45.441] result() for MulticoreFuture ... done
[10:22:45.441] result() for MulticoreFuture ...
[10:22:45.441] result() for MulticoreFuture ... done
[10:22:45.442] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:22:45.442] - nx: 2
[10:22:45.442] - relay: TRUE
[10:22:45.442] - stdout: TRUE
[10:22:45.442] - signal: TRUE
[10:22:45.443] - resignal: FALSE
[10:22:45.443] - force: TRUE
[10:22:45.443] - relayed: [n=2] TRUE, FALSE
[10:22:45.443] - queued futures: [n=2] TRUE, FALSE
[10:22:45.443]  - until=2
[10:22:45.443]  - relaying element #2
[10:22:45.444] result() for MulticoreFuture ...
[10:22:45.444] result() for MulticoreFuture ... done
[10:22:45.444] result() for MulticoreFuture ...
[10:22:45.444] result() for MulticoreFuture ... done
[10:22:45.444] result() for MulticoreFuture ...
[10:22:45.444] result() for MulticoreFuture ... done
[10:22:45.444] result() for MulticoreFuture ...
[10:22:45.444] result() for MulticoreFuture ... done
[10:22:45.444] - relayed: [n=2] TRUE, TRUE
[10:22:45.445] - queued futures: [n=2] TRUE, TRUE
[10:22:45.445] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:22:45.445]  length: 0 (resolved future 2)
[10:22:45.445] Relaying remaining futures
[10:22:45.445] signalConditionsASAP(NULL, pos=0) ...
[10:22:45.445] - nx: 2
[10:22:45.445] - relay: TRUE
[10:22:45.445] - stdout: TRUE
[10:22:45.445] - signal: TRUE
[10:22:45.446] - resignal: FALSE
[10:22:45.448] - force: TRUE
[10:22:45.449] - relayed: [n=2] TRUE, TRUE
[10:22:45.449] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:22:45.449] - relayed: [n=2] TRUE, TRUE
[10:22:45.449] - queued futures: [n=2] TRUE, TRUE
[10:22:45.449] signalConditionsASAP(NULL, pos=0) ... done
[10:22:45.450] resolve() on list ... DONE
[10:22:45.450] result() for MulticoreFuture ...
[10:22:45.450] result() for MulticoreFuture ... done
[10:22:45.450] result() for MulticoreFuture ...
[10:22:45.450] result() for MulticoreFuture ... done
[10:22:45.450] result() for MulticoreFuture ...
[10:22:45.451] result() for MulticoreFuture ... done
[10:22:45.451] result() for MulticoreFuture ...
[10:22:45.451] result() for MulticoreFuture ... done
[10:22:45.451]  - Number of value chunks collected: 2
[10:22:45.451] Resolving 2 futures (chunks) ... DONE
[10:22:45.452] Reducing values from 2 chunks ...
[10:22:45.452]  - Number of values collected after concatenation: 2
[10:22:45.452]  - Number of values expected: 2
[10:22:45.452] Reducing values from 2 chunks ... DONE
[10:22:45.452] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[10:22:45.453] getGlobalsAndPackagesXApply() ...
[10:22:45.453]  - future.globals: TRUE
[10:22:45.453] getGlobalsAndPackages() ...
[10:22:45.453] Searching for globals...
[10:22:45.457] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[10:22:45.457] Searching for globals ... DONE
[10:22:45.457] Resolving globals: FALSE
[10:22:45.458] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[10:22:45.458] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[10:22:45.459] - globals: [1] ‘FUN’
[10:22:45.459] 
[10:22:45.459] getGlobalsAndPackages() ... DONE
[10:22:45.459]  - globals found/used: [n=1] ‘FUN’
[10:22:45.459]  - needed namespaces: [n=0] 
[10:22:45.459] Finding globals ... DONE
[10:22:45.459]  - use_args: TRUE
[10:22:45.459]  - Getting '...' globals ...
[10:22:45.460] resolve() on list ...
[10:22:45.460]  recursive: 0
[10:22:45.460]  length: 1
[10:22:45.460]  elements: ‘...’
[10:22:45.460]  length: 0 (resolved future 1)
[10:22:45.460] resolve() on list ... DONE
[10:22:45.460]    - '...' content: [n=0] 
[10:22:45.460] List of 1
[10:22:45.460]  $ ...: list()
[10:22:45.460]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:45.460]  - attr(*, "where")=List of 1
[10:22:45.460]   ..$ ...:<environment: 0x55ca4d1ea718> 
[10:22:45.460]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:45.460]  - attr(*, "resolved")= logi TRUE
[10:22:45.460]  - attr(*, "total_size")= num NA
[10:22:45.463]  - Getting '...' globals ... DONE
[10:22:45.464] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:45.464] List of 2
[10:22:45.464]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[10:22:45.464]  $ ...          : list()
[10:22:45.464]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:45.464]  - attr(*, "where")=List of 2
[10:22:45.464]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:45.464]   ..$ ...          :<environment: 0x55ca4d1ea718> 
[10:22:45.464]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:45.464]  - attr(*, "resolved")= logi FALSE
[10:22:45.464]  - attr(*, "total_size")= num 36296
[10:22:45.466] Packages to be attached in all futures: [n=0] 
[10:22:45.466] getGlobalsAndPackagesXApply() ... DONE
[10:22:45.470] future_lapply() ...
[10:22:45.476] Generating random seeds ...
[10:22:45.476] Generating random seed streams for 2 elements ...
[10:22:45.476] Generating random seed streams for 2 elements ... DONE
[10:22:45.476] Generating random seeds ... DONE
[10:22:45.476] Will set RNG state on exit: 10407, -1638519490, -1307184908, -1740443544, 2079890645, 548810653, -421214229
[10:22:45.480] Number of chunks: 2
[10:22:45.480] getGlobalsAndPackagesXApply() ...
[10:22:45.480]  - future.globals: <name-value list> with names ‘list()’
[10:22:45.481]  - use_args: TRUE
[10:22:45.481] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:22:45.481] List of 2
[10:22:45.481]  $ ...          : list()
[10:22:45.481]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:45.481]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[10:22:45.481]  - attr(*, "where")=List of 2
[10:22:45.481]   ..$ ...          :<environment: 0x55ca4d1ea718> 
[10:22:45.481]   ..$ ...future.FUN:<environment: namespace:base> 
[10:22:45.481]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:45.481]  - attr(*, "resolved")= logi FALSE
[10:22:45.481]  - attr(*, "total_size")= num NA
[10:22:45.484] Packages to be attached in all futures: [n=0] 
[10:22:45.485] getGlobalsAndPackagesXApply() ... DONE
[10:22:45.485] Number of futures (= number of chunks): 2
[10:22:45.485] Launching 2 futures (chunks) ...
[10:22:45.485] Chunk #1 of 2 ...
[10:22:45.485]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:45.485]  - seeds: [1] <seeds>
[10:22:45.485]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:45.486] getGlobalsAndPackages() ...
[10:22:45.486] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:45.486] Resolving globals: FALSE
[10:22:45.486] Tweak future expression to call with '...' arguments ...
[10:22:45.486] {
[10:22:45.486]     do.call(function(...) {
[10:22:45.486]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:45.486]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:45.486]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:45.486]             on.exit(options(oopts), add = TRUE)
[10:22:45.486]         }
[10:22:45.486]         {
[10:22:45.486]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:45.486]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:45.486]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:22:45.486]                   envir = globalenv(), inherits = FALSE)
[10:22:45.486]                 ...future.FUN(...future.X_jj, ...)
[10:22:45.486]             })
[10:22:45.486]         }
[10:22:45.486]     }, args = future.call.arguments)
[10:22:45.486] }
[10:22:45.486] Tweak future expression to call with '...' arguments ... DONE
[10:22:45.487] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:45.487] 
[10:22:45.487] getGlobalsAndPackages() ... DONE
[10:22:45.487] run() for ‘Future’ ...
[10:22:45.487] - state: ‘created’
[10:22:45.487] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:45.491] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:45.491] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:45.491]   - Field: ‘label’
[10:22:45.491]   - Field: ‘local’
[10:22:45.491]   - Field: ‘owner’
[10:22:45.492]   - Field: ‘envir’
[10:22:45.492]   - Field: ‘workers’
[10:22:45.492]   - Field: ‘packages’
[10:22:45.492]   - Field: ‘gc’
[10:22:45.492]   - Field: ‘job’
[10:22:45.492]   - Field: ‘conditions’
[10:22:45.492]   - Field: ‘expr’
[10:22:45.492]   - Field: ‘uuid’
[10:22:45.492]   - Field: ‘seed’
[10:22:45.492]   - Field: ‘version’
[10:22:45.492]   - Field: ‘result’
[10:22:45.493]   - Field: ‘asynchronous’
[10:22:45.493]   - Field: ‘calls’
[10:22:45.493]   - Field: ‘globals’
[10:22:45.493]   - Field: ‘stdout’
[10:22:45.493]   - Field: ‘earlySignal’
[10:22:45.493]   - Field: ‘lazy’
[10:22:45.493]   - Field: ‘state’
[10:22:45.493] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:45.493] - Launch lazy future ...
[10:22:45.494] Packages needed by the future expression (n = 0): <none>
[10:22:45.494] Packages needed by future strategies (n = 0): <none>
[10:22:45.494] {
[10:22:45.494]     {
[10:22:45.494]         {
[10:22:45.494]             ...future.startTime <- base::Sys.time()
[10:22:45.494]             {
[10:22:45.494]                 {
[10:22:45.494]                   {
[10:22:45.494]                     {
[10:22:45.494]                       base::local({
[10:22:45.494]                         has_future <- base::requireNamespace("future", 
[10:22:45.494]                           quietly = TRUE)
[10:22:45.494]                         if (has_future) {
[10:22:45.494]                           ns <- base::getNamespace("future")
[10:22:45.494]                           version <- ns[[".package"]][["version"]]
[10:22:45.494]                           if (is.null(version)) 
[10:22:45.494]                             version <- utils::packageVersion("future")
[10:22:45.494]                         }
[10:22:45.494]                         else {
[10:22:45.494]                           version <- NULL
[10:22:45.494]                         }
[10:22:45.494]                         if (!has_future || version < "1.8.0") {
[10:22:45.494]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:45.494]                             "", base::R.version$version.string), 
[10:22:45.494]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:45.494]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:45.494]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:45.494]                               "release", "version")], collapse = " "), 
[10:22:45.494]                             hostname = base::Sys.info()[["nodename"]])
[10:22:45.494]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:45.494]                             info)
[10:22:45.494]                           info <- base::paste(info, collapse = "; ")
[10:22:45.494]                           if (!has_future) {
[10:22:45.494]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:45.494]                               info)
[10:22:45.494]                           }
[10:22:45.494]                           else {
[10:22:45.494]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:45.494]                               info, version)
[10:22:45.494]                           }
[10:22:45.494]                           base::stop(msg)
[10:22:45.494]                         }
[10:22:45.494]                       })
[10:22:45.494]                     }
[10:22:45.494]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:45.494]                     base::options(mc.cores = 1L)
[10:22:45.494]                   }
[10:22:45.494]                   options(future.plan = NULL)
[10:22:45.494]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:45.494]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:45.494]                 }
[10:22:45.494]                 ...future.workdir <- getwd()
[10:22:45.494]             }
[10:22:45.494]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:45.494]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:45.494]         }
[10:22:45.494]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:45.494]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:45.494]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:45.494]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:45.494]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:45.494]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:45.494]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:45.494]             base::names(...future.oldOptions))
[10:22:45.494]     }
[10:22:45.494]     if (FALSE) {
[10:22:45.494]     }
[10:22:45.494]     else {
[10:22:45.494]         if (TRUE) {
[10:22:45.494]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:45.494]                 open = "w")
[10:22:45.494]         }
[10:22:45.494]         else {
[10:22:45.494]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:45.494]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:45.494]         }
[10:22:45.494]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:45.494]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:45.494]             base::sink(type = "output", split = FALSE)
[10:22:45.494]             base::close(...future.stdout)
[10:22:45.494]         }, add = TRUE)
[10:22:45.494]     }
[10:22:45.494]     ...future.frame <- base::sys.nframe()
[10:22:45.494]     ...future.conditions <- base::list()
[10:22:45.494]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:45.494]     if (FALSE) {
[10:22:45.494]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:45.494]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:45.494]     }
[10:22:45.494]     ...future.result <- base::tryCatch({
[10:22:45.494]         base::withCallingHandlers({
[10:22:45.494]             ...future.value <- base::withVisible(base::local({
[10:22:45.494]                 withCallingHandlers({
[10:22:45.494]                   {
[10:22:45.494]                     do.call(function(...) {
[10:22:45.494]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:45.494]                       if (!identical(...future.globals.maxSize.org, 
[10:22:45.494]                         ...future.globals.maxSize)) {
[10:22:45.494]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:45.494]                         on.exit(options(oopts), add = TRUE)
[10:22:45.494]                       }
[10:22:45.494]                       {
[10:22:45.494]                         lapply(seq_along(...future.elements_ii), 
[10:22:45.494]                           FUN = function(jj) {
[10:22:45.494]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:45.494]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:22:45.494]                               envir = globalenv(), inherits = FALSE)
[10:22:45.494]                             ...future.FUN(...future.X_jj, ...)
[10:22:45.494]                           })
[10:22:45.494]                       }
[10:22:45.494]                     }, args = future.call.arguments)
[10:22:45.494]                   }
[10:22:45.494]                 }, immediateCondition = function(cond) {
[10:22:45.494]                   save_rds <- function (object, pathname, ...) 
[10:22:45.494]                   {
[10:22:45.494]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:45.494]                     if (file_test("-f", pathname_tmp)) {
[10:22:45.494]                       fi_tmp <- file.info(pathname_tmp)
[10:22:45.494]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:45.494]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:45.494]                         fi_tmp[["mtime"]])
[10:22:45.494]                     }
[10:22:45.494]                     tryCatch({
[10:22:45.494]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:45.494]                     }, error = function(ex) {
[10:22:45.494]                       msg <- conditionMessage(ex)
[10:22:45.494]                       fi_tmp <- file.info(pathname_tmp)
[10:22:45.494]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:45.494]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:45.494]                         fi_tmp[["mtime"]], msg)
[10:22:45.494]                       ex$message <- msg
[10:22:45.494]                       stop(ex)
[10:22:45.494]                     })
[10:22:45.494]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:45.494]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:45.494]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:45.494]                       fi_tmp <- file.info(pathname_tmp)
[10:22:45.494]                       fi <- file.info(pathname)
[10:22:45.494]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:45.494]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:45.494]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:45.494]                         fi[["size"]], fi[["mtime"]])
[10:22:45.494]                       stop(msg)
[10:22:45.494]                     }
[10:22:45.494]                     invisible(pathname)
[10:22:45.494]                   }
[10:22:45.494]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:45.494]                     rootPath = tempdir()) 
[10:22:45.494]                   {
[10:22:45.494]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:45.494]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:45.494]                       tmpdir = path, fileext = ".rds")
[10:22:45.494]                     save_rds(obj, file)
[10:22:45.494]                   }
[10:22:45.494]                   saveImmediateCondition(cond, path = "/tmp/RtmpTHXGJm/.future/immediateConditions")
[10:22:45.494]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.494]                   {
[10:22:45.494]                     inherits <- base::inherits
[10:22:45.494]                     invokeRestart <- base::invokeRestart
[10:22:45.494]                     is.null <- base::is.null
[10:22:45.494]                     muffled <- FALSE
[10:22:45.494]                     if (inherits(cond, "message")) {
[10:22:45.494]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:45.494]                       if (muffled) 
[10:22:45.494]                         invokeRestart("muffleMessage")
[10:22:45.494]                     }
[10:22:45.494]                     else if (inherits(cond, "warning")) {
[10:22:45.494]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:45.494]                       if (muffled) 
[10:22:45.494]                         invokeRestart("muffleWarning")
[10:22:45.494]                     }
[10:22:45.494]                     else if (inherits(cond, "condition")) {
[10:22:45.494]                       if (!is.null(pattern)) {
[10:22:45.494]                         computeRestarts <- base::computeRestarts
[10:22:45.494]                         grepl <- base::grepl
[10:22:45.494]                         restarts <- computeRestarts(cond)
[10:22:45.494]                         for (restart in restarts) {
[10:22:45.494]                           name <- restart$name
[10:22:45.494]                           if (is.null(name)) 
[10:22:45.494]                             next
[10:22:45.494]                           if (!grepl(pattern, name)) 
[10:22:45.494]                             next
[10:22:45.494]                           invokeRestart(restart)
[10:22:45.494]                           muffled <- TRUE
[10:22:45.494]                           break
[10:22:45.494]                         }
[10:22:45.494]                       }
[10:22:45.494]                     }
[10:22:45.494]                     invisible(muffled)
[10:22:45.494]                   }
[10:22:45.494]                   muffleCondition(cond)
[10:22:45.494]                 })
[10:22:45.494]             }))
[10:22:45.494]             future::FutureResult(value = ...future.value$value, 
[10:22:45.494]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:45.494]                   ...future.rng), globalenv = if (FALSE) 
[10:22:45.494]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:45.494]                     ...future.globalenv.names))
[10:22:45.494]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:45.494]         }, condition = base::local({
[10:22:45.494]             c <- base::c
[10:22:45.494]             inherits <- base::inherits
[10:22:45.494]             invokeRestart <- base::invokeRestart
[10:22:45.494]             length <- base::length
[10:22:45.494]             list <- base::list
[10:22:45.494]             seq.int <- base::seq.int
[10:22:45.494]             signalCondition <- base::signalCondition
[10:22:45.494]             sys.calls <- base::sys.calls
[10:22:45.494]             `[[` <- base::`[[`
[10:22:45.494]             `+` <- base::`+`
[10:22:45.494]             `<<-` <- base::`<<-`
[10:22:45.494]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:45.494]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:45.494]                   3L)]
[10:22:45.494]             }
[10:22:45.494]             function(cond) {
[10:22:45.494]                 is_error <- inherits(cond, "error")
[10:22:45.494]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:45.494]                   NULL)
[10:22:45.494]                 if (is_error) {
[10:22:45.494]                   sessionInformation <- function() {
[10:22:45.494]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:45.494]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:45.494]                       search = base::search(), system = base::Sys.info())
[10:22:45.494]                   }
[10:22:45.494]                   ...future.conditions[[length(...future.conditions) + 
[10:22:45.494]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:45.494]                     cond$call), session = sessionInformation(), 
[10:22:45.494]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:45.494]                   signalCondition(cond)
[10:22:45.494]                 }
[10:22:45.494]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[10:22:45.494]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:45.494]                   ...future.conditions[[length(...future.conditions) + 
[10:22:45.494]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:45.494]                   if (TRUE && !signal) {
[10:22:45.494]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.494]                     {
[10:22:45.494]                       inherits <- base::inherits
[10:22:45.494]                       invokeRestart <- base::invokeRestart
[10:22:45.494]                       is.null <- base::is.null
[10:22:45.494]                       muffled <- FALSE
[10:22:45.494]                       if (inherits(cond, "message")) {
[10:22:45.494]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:45.494]                         if (muffled) 
[10:22:45.494]                           invokeRestart("muffleMessage")
[10:22:45.494]                       }
[10:22:45.494]                       else if (inherits(cond, "warning")) {
[10:22:45.494]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:45.494]                         if (muffled) 
[10:22:45.494]                           invokeRestart("muffleWarning")
[10:22:45.494]                       }
[10:22:45.494]                       else if (inherits(cond, "condition")) {
[10:22:45.494]                         if (!is.null(pattern)) {
[10:22:45.494]                           computeRestarts <- base::computeRestarts
[10:22:45.494]                           grepl <- base::grepl
[10:22:45.494]                           restarts <- computeRestarts(cond)
[10:22:45.494]                           for (restart in restarts) {
[10:22:45.494]                             name <- restart$name
[10:22:45.494]                             if (is.null(name)) 
[10:22:45.494]                               next
[10:22:45.494]                             if (!grepl(pattern, name)) 
[10:22:45.494]                               next
[10:22:45.494]                             invokeRestart(restart)
[10:22:45.494]                             muffled <- TRUE
[10:22:45.494]                             break
[10:22:45.494]                           }
[10:22:45.494]                         }
[10:22:45.494]                       }
[10:22:45.494]                       invisible(muffled)
[10:22:45.494]                     }
[10:22:45.494]                     muffleCondition(cond, pattern = "^muffle")
[10:22:45.494]                   }
[10:22:45.494]                 }
[10:22:45.494]                 else {
[10:22:45.494]                   if (TRUE) {
[10:22:45.494]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.494]                     {
[10:22:45.494]                       inherits <- base::inherits
[10:22:45.494]                       invokeRestart <- base::invokeRestart
[10:22:45.494]                       is.null <- base::is.null
[10:22:45.494]                       muffled <- FALSE
[10:22:45.494]                       if (inherits(cond, "message")) {
[10:22:45.494]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:45.494]                         if (muffled) 
[10:22:45.494]                           invokeRestart("muffleMessage")
[10:22:45.494]                       }
[10:22:45.494]                       else if (inherits(cond, "warning")) {
[10:22:45.494]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:45.494]                         if (muffled) 
[10:22:45.494]                           invokeRestart("muffleWarning")
[10:22:45.494]                       }
[10:22:45.494]                       else if (inherits(cond, "condition")) {
[10:22:45.494]                         if (!is.null(pattern)) {
[10:22:45.494]                           computeRestarts <- base::computeRestarts
[10:22:45.494]                           grepl <- base::grepl
[10:22:45.494]                           restarts <- computeRestarts(cond)
[10:22:45.494]                           for (restart in restarts) {
[10:22:45.494]                             name <- restart$name
[10:22:45.494]                             if (is.null(name)) 
[10:22:45.494]                               next
[10:22:45.494]                             if (!grepl(pattern, name)) 
[10:22:45.494]                               next
[10:22:45.494]                             invokeRestart(restart)
[10:22:45.494]                             muffled <- TRUE
[10:22:45.494]                             break
[10:22:45.494]                           }
[10:22:45.494]                         }
[10:22:45.494]                       }
[10:22:45.494]                       invisible(muffled)
[10:22:45.494]                     }
[10:22:45.494]                     muffleCondition(cond, pattern = "^muffle")
[10:22:45.494]                   }
[10:22:45.494]                 }
[10:22:45.494]             }
[10:22:45.494]         }))
[10:22:45.494]     }, error = function(ex) {
[10:22:45.494]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:45.494]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:45.494]                 ...future.rng), started = ...future.startTime, 
[10:22:45.494]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:45.494]             version = "1.8"), class = "FutureResult")
[10:22:45.494]     }, finally = {
[10:22:45.494]         if (!identical(...future.workdir, getwd())) 
[10:22:45.494]             setwd(...future.workdir)
[10:22:45.494]         {
[10:22:45.494]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:45.494]                 ...future.oldOptions$nwarnings <- NULL
[10:22:45.494]             }
[10:22:45.494]             base::options(...future.oldOptions)
[10:22:45.494]             if (.Platform$OS.type == "windows") {
[10:22:45.494]                 old_names <- names(...future.oldEnvVars)
[10:22:45.494]                 envs <- base::Sys.getenv()
[10:22:45.494]                 names <- names(envs)
[10:22:45.494]                 common <- intersect(names, old_names)
[10:22:45.494]                 added <- setdiff(names, old_names)
[10:22:45.494]                 removed <- setdiff(old_names, names)
[10:22:45.494]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:45.494]                   envs[common]]
[10:22:45.494]                 NAMES <- toupper(changed)
[10:22:45.494]                 args <- list()
[10:22:45.494]                 for (kk in seq_along(NAMES)) {
[10:22:45.494]                   name <- changed[[kk]]
[10:22:45.494]                   NAME <- NAMES[[kk]]
[10:22:45.494]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.494]                     next
[10:22:45.494]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:45.494]                 }
[10:22:45.494]                 NAMES <- toupper(added)
[10:22:45.494]                 for (kk in seq_along(NAMES)) {
[10:22:45.494]                   name <- added[[kk]]
[10:22:45.494]                   NAME <- NAMES[[kk]]
[10:22:45.494]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.494]                     next
[10:22:45.494]                   args[[name]] <- ""
[10:22:45.494]                 }
[10:22:45.494]                 NAMES <- toupper(removed)
[10:22:45.494]                 for (kk in seq_along(NAMES)) {
[10:22:45.494]                   name <- removed[[kk]]
[10:22:45.494]                   NAME <- NAMES[[kk]]
[10:22:45.494]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.494]                     next
[10:22:45.494]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:45.494]                 }
[10:22:45.494]                 if (length(args) > 0) 
[10:22:45.494]                   base::do.call(base::Sys.setenv, args = args)
[10:22:45.494]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:45.494]             }
[10:22:45.494]             else {
[10:22:45.494]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:45.494]             }
[10:22:45.494]             {
[10:22:45.494]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:45.494]                   0L) {
[10:22:45.494]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:45.494]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:45.494]                   base::options(opts)
[10:22:45.494]                 }
[10:22:45.494]                 {
[10:22:45.494]                   {
[10:22:45.494]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:45.494]                     NULL
[10:22:45.494]                   }
[10:22:45.494]                   options(future.plan = NULL)
[10:22:45.494]                   if (is.na(NA_character_)) 
[10:22:45.494]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:45.494]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:45.494]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:45.494]                     envir = parent.frame()) 
[10:22:45.494]                   {
[10:22:45.494]                     default_workers <- missing(workers)
[10:22:45.494]                     if (is.function(workers)) 
[10:22:45.494]                       workers <- workers()
[10:22:45.494]                     workers <- structure(as.integer(workers), 
[10:22:45.494]                       class = class(workers))
[10:22:45.494]                     stop_if_not(is.finite(workers), workers >= 
[10:22:45.494]                       1L)
[10:22:45.494]                     if ((workers == 1L && !inherits(workers, 
[10:22:45.494]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:45.494]                       if (default_workers) 
[10:22:45.494]                         supportsMulticore(warn = TRUE)
[10:22:45.494]                       return(sequential(..., envir = envir))
[10:22:45.494]                     }
[10:22:45.494]                     oopts <- options(mc.cores = workers)
[10:22:45.494]                     on.exit(options(oopts))
[10:22:45.494]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:45.494]                       envir = envir)
[10:22:45.494]                     if (!future$lazy) 
[10:22:45.494]                       future <- run(future)
[10:22:45.494]                     invisible(future)
[10:22:45.494]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:45.494]                 }
[10:22:45.494]             }
[10:22:45.494]         }
[10:22:45.494]     })
[10:22:45.494]     if (TRUE) {
[10:22:45.494]         base::sink(type = "output", split = FALSE)
[10:22:45.494]         if (TRUE) {
[10:22:45.494]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:45.494]         }
[10:22:45.494]         else {
[10:22:45.494]             ...future.result["stdout"] <- base::list(NULL)
[10:22:45.494]         }
[10:22:45.494]         base::close(...future.stdout)
[10:22:45.494]         ...future.stdout <- NULL
[10:22:45.494]     }
[10:22:45.494]     ...future.result$conditions <- ...future.conditions
[10:22:45.494]     ...future.result$finished <- base::Sys.time()
[10:22:45.494]     ...future.result
[10:22:45.494] }
[10:22:45.497] assign_globals() ...
[10:22:45.497] List of 5
[10:22:45.497]  $ future.call.arguments    : list()
[10:22:45.497]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:45.497]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[10:22:45.497]  $ ...future.elements_ii    :List of 1
[10:22:45.497]   ..$ : int [1:2] 1 3
[10:22:45.497]  $ ...future.seeds_ii       :List of 1
[10:22:45.497]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[10:22:45.497]  $ ...future.globals.maxSize: num Inf
[10:22:45.497]  - attr(*, "resolved")= logi FALSE
[10:22:45.497]  - attr(*, "total_size")= num NA
[10:22:45.497]  - attr(*, "where")=List of 5
[10:22:45.497]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:45.497]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:45.497]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:45.497]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:45.497]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:45.497]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:45.497]  - attr(*, "already-done")= logi TRUE
[10:22:45.502] - copied ‘future.call.arguments’ to environment
[10:22:45.502] - copied ‘...future.FUN’ to environment
[10:22:45.502] - copied ‘...future.elements_ii’ to environment
[10:22:45.502] - copied ‘...future.seeds_ii’ to environment
[10:22:45.502] - copied ‘...future.globals.maxSize’ to environment
[10:22:45.503] assign_globals() ... done
[10:22:45.503] requestCore(): workers = 2
[10:22:45.505] MulticoreFuture started
[10:22:45.509] - Launch lazy future ... done
[10:22:45.510] plan(): Setting new future strategy stack:
[10:22:45.510] run() for ‘MulticoreFuture’ ... done
[10:22:45.511] Created future:
[10:22:45.510] List of future strategies:
[10:22:45.510] 1. sequential:
[10:22:45.510]    - args: function (..., envir = parent.frame())
[10:22:45.510]    - tweaked: FALSE
[10:22:45.510]    - call: NULL
[10:22:45.512] plan(): nbrOfWorkers() = 1
[10:22:45.514] plan(): Setting new future strategy stack:
[10:22:45.514] List of future strategies:
[10:22:45.514] 1. multicore:
[10:22:45.514]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:45.514]    - tweaked: FALSE
[10:22:45.514]    - call: plan(strategy)
[10:22:45.521] plan(): nbrOfWorkers() = 2
[10:22:45.511] MulticoreFuture:
[10:22:45.511] Label: ‘future_apply-1’
[10:22:45.511] Expression:
[10:22:45.511] {
[10:22:45.511]     do.call(function(...) {
[10:22:45.511]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:45.511]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:45.511]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:45.511]             on.exit(options(oopts), add = TRUE)
[10:22:45.511]         }
[10:22:45.511]         {
[10:22:45.511]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:45.511]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:45.511]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:22:45.511]                   envir = globalenv(), inherits = FALSE)
[10:22:45.511]                 ...future.FUN(...future.X_jj, ...)
[10:22:45.511]             })
[10:22:45.511]         }
[10:22:45.511]     }, args = future.call.arguments)
[10:22:45.511] }
[10:22:45.511] Lazy evaluation: FALSE
[10:22:45.511] Asynchronous evaluation: TRUE
[10:22:45.511] Local evaluation: TRUE
[10:22:45.511] Environment: R_GlobalEnv
[10:22:45.511] Capture standard output: TRUE
[10:22:45.511] Capture condition classes: <none>
[10:22:45.511] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:45.511] Packages: <none>
[10:22:45.511] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:22:45.511] Resolved: TRUE
[10:22:45.511] Value: <not collected>
[10:22:45.511] Conditions captured: <none>
[10:22:45.511] Early signaling: FALSE
[10:22:45.511] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:45.511] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:45.522] Chunk #1 of 2 ... DONE
[10:22:45.523] Chunk #2 of 2 ...
[10:22:45.523]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:45.523]  - seeds: [1] <seeds>
[10:22:45.523]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:45.524] getGlobalsAndPackages() ...
[10:22:45.524] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:45.524] Resolving globals: FALSE
[10:22:45.524] Tweak future expression to call with '...' arguments ...
[10:22:45.525] {
[10:22:45.525]     do.call(function(...) {
[10:22:45.525]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:45.525]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:45.525]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:45.525]             on.exit(options(oopts), add = TRUE)
[10:22:45.525]         }
[10:22:45.525]         {
[10:22:45.525]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:45.525]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:45.525]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:22:45.525]                   envir = globalenv(), inherits = FALSE)
[10:22:45.525]                 ...future.FUN(...future.X_jj, ...)
[10:22:45.525]             })
[10:22:45.525]         }
[10:22:45.525]     }, args = future.call.arguments)
[10:22:45.525] }
[10:22:45.525] Tweak future expression to call with '...' arguments ... DONE
[10:22:45.526] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:45.526] 
[10:22:45.526] getGlobalsAndPackages() ... DONE
[10:22:45.527] run() for ‘Future’ ...
[10:22:45.528] - state: ‘created’
[10:22:45.528] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:45.533] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:45.533] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:45.534]   - Field: ‘label’
[10:22:45.534]   - Field: ‘local’
[10:22:45.534]   - Field: ‘owner’
[10:22:45.534]   - Field: ‘envir’
[10:22:45.534]   - Field: ‘workers’
[10:22:45.534]   - Field: ‘packages’
[10:22:45.534]   - Field: ‘gc’
[10:22:45.534]   - Field: ‘job’
[10:22:45.535]   - Field: ‘conditions’
[10:22:45.535]   - Field: ‘expr’
[10:22:45.535]   - Field: ‘uuid’
[10:22:45.535]   - Field: ‘seed’
[10:22:45.535]   - Field: ‘version’
[10:22:45.536]   - Field: ‘result’
[10:22:45.536]   - Field: ‘asynchronous’
[10:22:45.536]   - Field: ‘calls’
[10:22:45.536]   - Field: ‘globals’
[10:22:45.536]   - Field: ‘stdout’
[10:22:45.536]   - Field: ‘earlySignal’
[10:22:45.536]   - Field: ‘lazy’
[10:22:45.537]   - Field: ‘state’
[10:22:45.537] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:45.537] - Launch lazy future ...
[10:22:45.537] Packages needed by the future expression (n = 0): <none>
[10:22:45.538] Packages needed by future strategies (n = 0): <none>
[10:22:45.538] {
[10:22:45.538]     {
[10:22:45.538]         {
[10:22:45.538]             ...future.startTime <- base::Sys.time()
[10:22:45.538]             {
[10:22:45.538]                 {
[10:22:45.538]                   {
[10:22:45.538]                     {
[10:22:45.538]                       base::local({
[10:22:45.538]                         has_future <- base::requireNamespace("future", 
[10:22:45.538]                           quietly = TRUE)
[10:22:45.538]                         if (has_future) {
[10:22:45.538]                           ns <- base::getNamespace("future")
[10:22:45.538]                           version <- ns[[".package"]][["version"]]
[10:22:45.538]                           if (is.null(version)) 
[10:22:45.538]                             version <- utils::packageVersion("future")
[10:22:45.538]                         }
[10:22:45.538]                         else {
[10:22:45.538]                           version <- NULL
[10:22:45.538]                         }
[10:22:45.538]                         if (!has_future || version < "1.8.0") {
[10:22:45.538]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:45.538]                             "", base::R.version$version.string), 
[10:22:45.538]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:45.538]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:45.538]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:45.538]                               "release", "version")], collapse = " "), 
[10:22:45.538]                             hostname = base::Sys.info()[["nodename"]])
[10:22:45.538]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:45.538]                             info)
[10:22:45.538]                           info <- base::paste(info, collapse = "; ")
[10:22:45.538]                           if (!has_future) {
[10:22:45.538]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:45.538]                               info)
[10:22:45.538]                           }
[10:22:45.538]                           else {
[10:22:45.538]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:45.538]                               info, version)
[10:22:45.538]                           }
[10:22:45.538]                           base::stop(msg)
[10:22:45.538]                         }
[10:22:45.538]                       })
[10:22:45.538]                     }
[10:22:45.538]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:45.538]                     base::options(mc.cores = 1L)
[10:22:45.538]                   }
[10:22:45.538]                   options(future.plan = NULL)
[10:22:45.538]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:45.538]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:45.538]                 }
[10:22:45.538]                 ...future.workdir <- getwd()
[10:22:45.538]             }
[10:22:45.538]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:45.538]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:45.538]         }
[10:22:45.538]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:45.538]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:45.538]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:45.538]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:45.538]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:45.538]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:45.538]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:45.538]             base::names(...future.oldOptions))
[10:22:45.538]     }
[10:22:45.538]     if (FALSE) {
[10:22:45.538]     }
[10:22:45.538]     else {
[10:22:45.538]         if (TRUE) {
[10:22:45.538]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:45.538]                 open = "w")
[10:22:45.538]         }
[10:22:45.538]         else {
[10:22:45.538]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:45.538]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:45.538]         }
[10:22:45.538]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:45.538]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:45.538]             base::sink(type = "output", split = FALSE)
[10:22:45.538]             base::close(...future.stdout)
[10:22:45.538]         }, add = TRUE)
[10:22:45.538]     }
[10:22:45.538]     ...future.frame <- base::sys.nframe()
[10:22:45.538]     ...future.conditions <- base::list()
[10:22:45.538]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:45.538]     if (FALSE) {
[10:22:45.538]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:45.538]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:45.538]     }
[10:22:45.538]     ...future.result <- base::tryCatch({
[10:22:45.538]         base::withCallingHandlers({
[10:22:45.538]             ...future.value <- base::withVisible(base::local({
[10:22:45.538]                 withCallingHandlers({
[10:22:45.538]                   {
[10:22:45.538]                     do.call(function(...) {
[10:22:45.538]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:45.538]                       if (!identical(...future.globals.maxSize.org, 
[10:22:45.538]                         ...future.globals.maxSize)) {
[10:22:45.538]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:45.538]                         on.exit(options(oopts), add = TRUE)
[10:22:45.538]                       }
[10:22:45.538]                       {
[10:22:45.538]                         lapply(seq_along(...future.elements_ii), 
[10:22:45.538]                           FUN = function(jj) {
[10:22:45.538]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:45.538]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:22:45.538]                               envir = globalenv(), inherits = FALSE)
[10:22:45.538]                             ...future.FUN(...future.X_jj, ...)
[10:22:45.538]                           })
[10:22:45.538]                       }
[10:22:45.538]                     }, args = future.call.arguments)
[10:22:45.538]                   }
[10:22:45.538]                 }, immediateCondition = function(cond) {
[10:22:45.538]                   save_rds <- function (object, pathname, ...) 
[10:22:45.538]                   {
[10:22:45.538]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:45.538]                     if (file_test("-f", pathname_tmp)) {
[10:22:45.538]                       fi_tmp <- file.info(pathname_tmp)
[10:22:45.538]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:45.538]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:45.538]                         fi_tmp[["mtime"]])
[10:22:45.538]                     }
[10:22:45.538]                     tryCatch({
[10:22:45.538]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:45.538]                     }, error = function(ex) {
[10:22:45.538]                       msg <- conditionMessage(ex)
[10:22:45.538]                       fi_tmp <- file.info(pathname_tmp)
[10:22:45.538]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:45.538]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:45.538]                         fi_tmp[["mtime"]], msg)
[10:22:45.538]                       ex$message <- msg
[10:22:45.538]                       stop(ex)
[10:22:45.538]                     })
[10:22:45.538]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:45.538]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:45.538]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:45.538]                       fi_tmp <- file.info(pathname_tmp)
[10:22:45.538]                       fi <- file.info(pathname)
[10:22:45.538]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:45.538]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:45.538]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:45.538]                         fi[["size"]], fi[["mtime"]])
[10:22:45.538]                       stop(msg)
[10:22:45.538]                     }
[10:22:45.538]                     invisible(pathname)
[10:22:45.538]                   }
[10:22:45.538]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:45.538]                     rootPath = tempdir()) 
[10:22:45.538]                   {
[10:22:45.538]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:45.538]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:45.538]                       tmpdir = path, fileext = ".rds")
[10:22:45.538]                     save_rds(obj, file)
[10:22:45.538]                   }
[10:22:45.538]                   saveImmediateCondition(cond, path = "/tmp/RtmpTHXGJm/.future/immediateConditions")
[10:22:45.538]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.538]                   {
[10:22:45.538]                     inherits <- base::inherits
[10:22:45.538]                     invokeRestart <- base::invokeRestart
[10:22:45.538]                     is.null <- base::is.null
[10:22:45.538]                     muffled <- FALSE
[10:22:45.538]                     if (inherits(cond, "message")) {
[10:22:45.538]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:45.538]                       if (muffled) 
[10:22:45.538]                         invokeRestart("muffleMessage")
[10:22:45.538]                     }
[10:22:45.538]                     else if (inherits(cond, "warning")) {
[10:22:45.538]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:45.538]                       if (muffled) 
[10:22:45.538]                         invokeRestart("muffleWarning")
[10:22:45.538]                     }
[10:22:45.538]                     else if (inherits(cond, "condition")) {
[10:22:45.538]                       if (!is.null(pattern)) {
[10:22:45.538]                         computeRestarts <- base::computeRestarts
[10:22:45.538]                         grepl <- base::grepl
[10:22:45.538]                         restarts <- computeRestarts(cond)
[10:22:45.538]                         for (restart in restarts) {
[10:22:45.538]                           name <- restart$name
[10:22:45.538]                           if (is.null(name)) 
[10:22:45.538]                             next
[10:22:45.538]                           if (!grepl(pattern, name)) 
[10:22:45.538]                             next
[10:22:45.538]                           invokeRestart(restart)
[10:22:45.538]                           muffled <- TRUE
[10:22:45.538]                           break
[10:22:45.538]                         }
[10:22:45.538]                       }
[10:22:45.538]                     }
[10:22:45.538]                     invisible(muffled)
[10:22:45.538]                   }
[10:22:45.538]                   muffleCondition(cond)
[10:22:45.538]                 })
[10:22:45.538]             }))
[10:22:45.538]             future::FutureResult(value = ...future.value$value, 
[10:22:45.538]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:45.538]                   ...future.rng), globalenv = if (FALSE) 
[10:22:45.538]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:45.538]                     ...future.globalenv.names))
[10:22:45.538]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:45.538]         }, condition = base::local({
[10:22:45.538]             c <- base::c
[10:22:45.538]             inherits <- base::inherits
[10:22:45.538]             invokeRestart <- base::invokeRestart
[10:22:45.538]             length <- base::length
[10:22:45.538]             list <- base::list
[10:22:45.538]             seq.int <- base::seq.int
[10:22:45.538]             signalCondition <- base::signalCondition
[10:22:45.538]             sys.calls <- base::sys.calls
[10:22:45.538]             `[[` <- base::`[[`
[10:22:45.538]             `+` <- base::`+`
[10:22:45.538]             `<<-` <- base::`<<-`
[10:22:45.538]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:45.538]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:45.538]                   3L)]
[10:22:45.538]             }
[10:22:45.538]             function(cond) {
[10:22:45.538]                 is_error <- inherits(cond, "error")
[10:22:45.538]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:45.538]                   NULL)
[10:22:45.538]                 if (is_error) {
[10:22:45.538]                   sessionInformation <- function() {
[10:22:45.538]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:45.538]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:45.538]                       search = base::search(), system = base::Sys.info())
[10:22:45.538]                   }
[10:22:45.538]                   ...future.conditions[[length(...future.conditions) + 
[10:22:45.538]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:45.538]                     cond$call), session = sessionInformation(), 
[10:22:45.538]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:45.538]                   signalCondition(cond)
[10:22:45.538]                 }
[10:22:45.538]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[10:22:45.538]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:45.538]                   ...future.conditions[[length(...future.conditions) + 
[10:22:45.538]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:45.538]                   if (TRUE && !signal) {
[10:22:45.538]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.538]                     {
[10:22:45.538]                       inherits <- base::inherits
[10:22:45.538]                       invokeRestart <- base::invokeRestart
[10:22:45.538]                       is.null <- base::is.null
[10:22:45.538]                       muffled <- FALSE
[10:22:45.538]                       if (inherits(cond, "message")) {
[10:22:45.538]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:45.538]                         if (muffled) 
[10:22:45.538]                           invokeRestart("muffleMessage")
[10:22:45.538]                       }
[10:22:45.538]                       else if (inherits(cond, "warning")) {
[10:22:45.538]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:45.538]                         if (muffled) 
[10:22:45.538]                           invokeRestart("muffleWarning")
[10:22:45.538]                       }
[10:22:45.538]                       else if (inherits(cond, "condition")) {
[10:22:45.538]                         if (!is.null(pattern)) {
[10:22:45.538]                           computeRestarts <- base::computeRestarts
[10:22:45.538]                           grepl <- base::grepl
[10:22:45.538]                           restarts <- computeRestarts(cond)
[10:22:45.538]                           for (restart in restarts) {
[10:22:45.538]                             name <- restart$name
[10:22:45.538]                             if (is.null(name)) 
[10:22:45.538]                               next
[10:22:45.538]                             if (!grepl(pattern, name)) 
[10:22:45.538]                               next
[10:22:45.538]                             invokeRestart(restart)
[10:22:45.538]                             muffled <- TRUE
[10:22:45.538]                             break
[10:22:45.538]                           }
[10:22:45.538]                         }
[10:22:45.538]                       }
[10:22:45.538]                       invisible(muffled)
[10:22:45.538]                     }
[10:22:45.538]                     muffleCondition(cond, pattern = "^muffle")
[10:22:45.538]                   }
[10:22:45.538]                 }
[10:22:45.538]                 else {
[10:22:45.538]                   if (TRUE) {
[10:22:45.538]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.538]                     {
[10:22:45.538]                       inherits <- base::inherits
[10:22:45.538]                       invokeRestart <- base::invokeRestart
[10:22:45.538]                       is.null <- base::is.null
[10:22:45.538]                       muffled <- FALSE
[10:22:45.538]                       if (inherits(cond, "message")) {
[10:22:45.538]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:45.538]                         if (muffled) 
[10:22:45.538]                           invokeRestart("muffleMessage")
[10:22:45.538]                       }
[10:22:45.538]                       else if (inherits(cond, "warning")) {
[10:22:45.538]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:45.538]                         if (muffled) 
[10:22:45.538]                           invokeRestart("muffleWarning")
[10:22:45.538]                       }
[10:22:45.538]                       else if (inherits(cond, "condition")) {
[10:22:45.538]                         if (!is.null(pattern)) {
[10:22:45.538]                           computeRestarts <- base::computeRestarts
[10:22:45.538]                           grepl <- base::grepl
[10:22:45.538]                           restarts <- computeRestarts(cond)
[10:22:45.538]                           for (restart in restarts) {
[10:22:45.538]                             name <- restart$name
[10:22:45.538]                             if (is.null(name)) 
[10:22:45.538]                               next
[10:22:45.538]                             if (!grepl(pattern, name)) 
[10:22:45.538]                               next
[10:22:45.538]                             invokeRestart(restart)
[10:22:45.538]                             muffled <- TRUE
[10:22:45.538]                             break
[10:22:45.538]                           }
[10:22:45.538]                         }
[10:22:45.538]                       }
[10:22:45.538]                       invisible(muffled)
[10:22:45.538]                     }
[10:22:45.538]                     muffleCondition(cond, pattern = "^muffle")
[10:22:45.538]                   }
[10:22:45.538]                 }
[10:22:45.538]             }
[10:22:45.538]         }))
[10:22:45.538]     }, error = function(ex) {
[10:22:45.538]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:45.538]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:45.538]                 ...future.rng), started = ...future.startTime, 
[10:22:45.538]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:45.538]             version = "1.8"), class = "FutureResult")
[10:22:45.538]     }, finally = {
[10:22:45.538]         if (!identical(...future.workdir, getwd())) 
[10:22:45.538]             setwd(...future.workdir)
[10:22:45.538]         {
[10:22:45.538]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:45.538]                 ...future.oldOptions$nwarnings <- NULL
[10:22:45.538]             }
[10:22:45.538]             base::options(...future.oldOptions)
[10:22:45.538]             if (.Platform$OS.type == "windows") {
[10:22:45.538]                 old_names <- names(...future.oldEnvVars)
[10:22:45.538]                 envs <- base::Sys.getenv()
[10:22:45.538]                 names <- names(envs)
[10:22:45.538]                 common <- intersect(names, old_names)
[10:22:45.538]                 added <- setdiff(names, old_names)
[10:22:45.538]                 removed <- setdiff(old_names, names)
[10:22:45.538]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:45.538]                   envs[common]]
[10:22:45.538]                 NAMES <- toupper(changed)
[10:22:45.538]                 args <- list()
[10:22:45.538]                 for (kk in seq_along(NAMES)) {
[10:22:45.538]                   name <- changed[[kk]]
[10:22:45.538]                   NAME <- NAMES[[kk]]
[10:22:45.538]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.538]                     next
[10:22:45.538]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:45.538]                 }
[10:22:45.538]                 NAMES <- toupper(added)
[10:22:45.538]                 for (kk in seq_along(NAMES)) {
[10:22:45.538]                   name <- added[[kk]]
[10:22:45.538]                   NAME <- NAMES[[kk]]
[10:22:45.538]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.538]                     next
[10:22:45.538]                   args[[name]] <- ""
[10:22:45.538]                 }
[10:22:45.538]                 NAMES <- toupper(removed)
[10:22:45.538]                 for (kk in seq_along(NAMES)) {
[10:22:45.538]                   name <- removed[[kk]]
[10:22:45.538]                   NAME <- NAMES[[kk]]
[10:22:45.538]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.538]                     next
[10:22:45.538]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:45.538]                 }
[10:22:45.538]                 if (length(args) > 0) 
[10:22:45.538]                   base::do.call(base::Sys.setenv, args = args)
[10:22:45.538]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:45.538]             }
[10:22:45.538]             else {
[10:22:45.538]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:45.538]             }
[10:22:45.538]             {
[10:22:45.538]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:45.538]                   0L) {
[10:22:45.538]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:45.538]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:45.538]                   base::options(opts)
[10:22:45.538]                 }
[10:22:45.538]                 {
[10:22:45.538]                   {
[10:22:45.538]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:45.538]                     NULL
[10:22:45.538]                   }
[10:22:45.538]                   options(future.plan = NULL)
[10:22:45.538]                   if (is.na(NA_character_)) 
[10:22:45.538]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:45.538]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:45.538]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:22:45.538]                     envir = parent.frame()) 
[10:22:45.538]                   {
[10:22:45.538]                     default_workers <- missing(workers)
[10:22:45.538]                     if (is.function(workers)) 
[10:22:45.538]                       workers <- workers()
[10:22:45.538]                     workers <- structure(as.integer(workers), 
[10:22:45.538]                       class = class(workers))
[10:22:45.538]                     stop_if_not(is.finite(workers), workers >= 
[10:22:45.538]                       1L)
[10:22:45.538]                     if ((workers == 1L && !inherits(workers, 
[10:22:45.538]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:45.538]                       if (default_workers) 
[10:22:45.538]                         supportsMulticore(warn = TRUE)
[10:22:45.538]                       return(sequential(..., envir = envir))
[10:22:45.538]                     }
[10:22:45.538]                     oopts <- options(mc.cores = workers)
[10:22:45.538]                     on.exit(options(oopts))
[10:22:45.538]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:45.538]                       envir = envir)
[10:22:45.538]                     if (!future$lazy) 
[10:22:45.538]                       future <- run(future)
[10:22:45.538]                     invisible(future)
[10:22:45.538]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:45.538]                 }
[10:22:45.538]             }
[10:22:45.538]         }
[10:22:45.538]     })
[10:22:45.538]     if (TRUE) {
[10:22:45.538]         base::sink(type = "output", split = FALSE)
[10:22:45.538]         if (TRUE) {
[10:22:45.538]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:45.538]         }
[10:22:45.538]         else {
[10:22:45.538]             ...future.result["stdout"] <- base::list(NULL)
[10:22:45.538]         }
[10:22:45.538]         base::close(...future.stdout)
[10:22:45.538]         ...future.stdout <- NULL
[10:22:45.538]     }
[10:22:45.538]     ...future.result$conditions <- ...future.conditions
[10:22:45.538]     ...future.result$finished <- base::Sys.time()
[10:22:45.538]     ...future.result
[10:22:45.538] }
[10:22:45.541] assign_globals() ...
[10:22:45.541] List of 5
[10:22:45.541]  $ future.call.arguments    : list()
[10:22:45.541]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:45.541]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[10:22:45.541]  $ ...future.elements_ii    :List of 1
[10:22:45.541]   ..$ : int [1:2] 2 4
[10:22:45.541]  $ ...future.seeds_ii       :List of 1
[10:22:45.541]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[10:22:45.541]  $ ...future.globals.maxSize: num Inf
[10:22:45.541]  - attr(*, "resolved")= logi FALSE
[10:22:45.541]  - attr(*, "total_size")= num NA
[10:22:45.541]  - attr(*, "where")=List of 5
[10:22:45.541]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:22:45.541]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:22:45.541]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:22:45.541]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:22:45.541]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:22:45.541]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:45.541]  - attr(*, "already-done")= logi TRUE
[10:22:45.548] - copied ‘future.call.arguments’ to environment
[10:22:45.548] - copied ‘...future.FUN’ to environment
[10:22:45.548] - copied ‘...future.elements_ii’ to environment
[10:22:45.548] - copied ‘...future.seeds_ii’ to environment
[10:22:45.548] - copied ‘...future.globals.maxSize’ to environment
[10:22:45.548] assign_globals() ... done
[10:22:45.549] requestCore(): workers = 2
[10:22:45.551] MulticoreFuture started
[10:22:45.551] - Launch lazy future ... done
[10:22:45.552] run() for ‘MulticoreFuture’ ... done
[10:22:45.552] Created future:
[10:22:45.552] plan(): Setting new future strategy stack:
[10:22:45.552] List of future strategies:
[10:22:45.552] 1. sequential:
[10:22:45.552]    - args: function (..., envir = parent.frame())
[10:22:45.552]    - tweaked: FALSE
[10:22:45.552]    - call: NULL
[10:22:45.553] plan(): nbrOfWorkers() = 1
[10:22:45.555] plan(): Setting new future strategy stack:
[10:22:45.555] List of future strategies:
[10:22:45.555] 1. multicore:
[10:22:45.555]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:45.555]    - tweaked: FALSE
[10:22:45.555]    - call: plan(strategy)
[10:22:45.561] plan(): nbrOfWorkers() = 2
[10:22:45.552] MulticoreFuture:
[10:22:45.552] Label: ‘future_apply-2’
[10:22:45.552] Expression:
[10:22:45.552] {
[10:22:45.552]     do.call(function(...) {
[10:22:45.552]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:45.552]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:45.552]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:45.552]             on.exit(options(oopts), add = TRUE)
[10:22:45.552]         }
[10:22:45.552]         {
[10:22:45.552]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:45.552]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:45.552]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:22:45.552]                   envir = globalenv(), inherits = FALSE)
[10:22:45.552]                 ...future.FUN(...future.X_jj, ...)
[10:22:45.552]             })
[10:22:45.552]         }
[10:22:45.552]     }, args = future.call.arguments)
[10:22:45.552] }
[10:22:45.552] Lazy evaluation: FALSE
[10:22:45.552] Asynchronous evaluation: TRUE
[10:22:45.552] Local evaluation: TRUE
[10:22:45.552] Environment: R_GlobalEnv
[10:22:45.552] Capture standard output: TRUE
[10:22:45.552] Capture condition classes: <none>
[10:22:45.552] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:45.552] Packages: <none>
[10:22:45.552] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:22:45.552] Resolved: TRUE
[10:22:45.552] Value: <not collected>
[10:22:45.552] Conditions captured: <none>
[10:22:45.552] Early signaling: FALSE
[10:22:45.552] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:45.552] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:45.562] Chunk #2 of 2 ... DONE
[10:22:45.562] Launching 2 futures (chunks) ... DONE
[10:22:45.562] Resolving 2 futures (chunks) ...
[10:22:45.562] resolve() on list ...
[10:22:45.562]  recursive: 0
[10:22:45.562]  length: 2
[10:22:45.563] 
[10:22:45.563] Future #1
[10:22:45.563] result() for MulticoreFuture ...
[10:22:45.564] result() for MulticoreFuture ...
[10:22:45.564] result() for MulticoreFuture ... done
[10:22:45.564] result() for MulticoreFuture ... done
[10:22:45.564] result() for MulticoreFuture ...
[10:22:45.565] result() for MulticoreFuture ... done
[10:22:45.565] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:22:45.565] - nx: 2
[10:22:45.565] - relay: TRUE
[10:22:45.565] - stdout: TRUE
[10:22:45.566] - signal: TRUE
[10:22:45.566] - resignal: FALSE
[10:22:45.566] - force: TRUE
[10:22:45.566] - relayed: [n=2] FALSE, FALSE
[10:22:45.566] - queued futures: [n=2] FALSE, FALSE
[10:22:45.566]  - until=1
[10:22:45.566]  - relaying element #1
[10:22:45.567] result() for MulticoreFuture ...
[10:22:45.567] result() for MulticoreFuture ... done
[10:22:45.567] result() for MulticoreFuture ...
[10:22:45.567] result() for MulticoreFuture ... done
[10:22:45.567] result() for MulticoreFuture ...
[10:22:45.567] result() for MulticoreFuture ... done
[10:22:45.568] result() for MulticoreFuture ...
[10:22:45.571] result() for MulticoreFuture ... done
[10:22:45.572] - relayed: [n=2] TRUE, FALSE
[10:22:45.572] - queued futures: [n=2] TRUE, FALSE
[10:22:45.572] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:22:45.573]  length: 1 (resolved future 1)
[10:22:45.573] Future #2
[10:22:45.574] result() for MulticoreFuture ...
[10:22:45.575] result() for MulticoreFuture ...
[10:22:45.575] result() for MulticoreFuture ... done
[10:22:45.575] result() for MulticoreFuture ... done
[10:22:45.575] result() for MulticoreFuture ...
[10:22:45.576] result() for MulticoreFuture ... done
[10:22:45.576] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:22:45.576] - nx: 2
[10:22:45.576] - relay: TRUE
[10:22:45.576] - stdout: TRUE
[10:22:45.577] - signal: TRUE
[10:22:45.577] - resignal: FALSE
[10:22:45.577] - force: TRUE
[10:22:45.577] - relayed: [n=2] TRUE, FALSE
[10:22:45.577] - queued futures: [n=2] TRUE, FALSE
[10:22:45.577]  - until=2
[10:22:45.577]  - relaying element #2
[10:22:45.578] result() for MulticoreFuture ...
[10:22:45.578] result() for MulticoreFuture ... done
[10:22:45.578] result() for MulticoreFuture ...
[10:22:45.578] result() for MulticoreFuture ... done
[10:22:45.578] result() for MulticoreFuture ...
[10:22:45.578] result() for MulticoreFuture ... done
[10:22:45.579] result() for MulticoreFuture ...
[10:22:45.579] result() for MulticoreFuture ... done
[10:22:45.579] - relayed: [n=2] TRUE, TRUE
[10:22:45.579] - queued futures: [n=2] TRUE, TRUE
[10:22:45.579] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:22:45.579]  length: 0 (resolved future 2)
[10:22:45.580] Relaying remaining futures
[10:22:45.580] signalConditionsASAP(NULL, pos=0) ...
[10:22:45.580] - nx: 2
[10:22:45.580] - relay: TRUE
[10:22:45.580] - stdout: TRUE
[10:22:45.580] - signal: TRUE
[10:22:45.580] - resignal: FALSE
[10:22:45.580] - force: TRUE
[10:22:45.581] - relayed: [n=2] TRUE, TRUE
[10:22:45.581] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:22:45.581] - relayed: [n=2] TRUE, TRUE
[10:22:45.581] - queued futures: [n=2] TRUE, TRUE
[10:22:45.581] signalConditionsASAP(NULL, pos=0) ... done
[10:22:45.581] resolve() on list ... DONE
[10:22:45.581] result() for MulticoreFuture ...
[10:22:45.581] result() for MulticoreFuture ... done
[10:22:45.582] result() for MulticoreFuture ...
[10:22:45.582] result() for MulticoreFuture ... done
[10:22:45.582] result() for MulticoreFuture ...
[10:22:45.582] result() for MulticoreFuture ... done
[10:22:45.582] result() for MulticoreFuture ...
[10:22:45.582] result() for MulticoreFuture ... done
[10:22:45.582]  - Number of value chunks collected: 2
[10:22:45.582] Resolving 2 futures (chunks) ... DONE
[10:22:45.583] Reducing values from 2 chunks ...
[10:22:45.583]  - Number of values collected after concatenation: 2
[10:22:45.583]  - Number of values expected: 2
[10:22:45.583] Reducing values from 2 chunks ... DONE
[10:22:45.583] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[10:22:45.583] plan(): Setting new future strategy stack:
[10:22:45.583] List of future strategies:
[10:22:45.583] 1. sequential:
[10:22:45.583]    - args: function (..., envir = parent.frame())
[10:22:45.583]    - tweaked: FALSE
[10:22:45.583]    - call: plan(sequential)
[10:22:45.584] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[10:22:45.584] plan(): Setting new future strategy stack:
[10:22:45.585] List of future strategies:
[10:22:45.585] 1. multisession:
[10:22:45.585]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:45.585]    - tweaked: FALSE
[10:22:45.585]    - call: plan(strategy)
[10:22:45.585] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:22:45.585] multisession:
[10:22:45.585] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:45.585] - tweaked: FALSE
[10:22:45.585] - call: plan(strategy)
[10:22:45.592] getGlobalsAndPackages() ...
[10:22:45.592] Not searching for globals
[10:22:45.593] - globals: [0] <none>
[10:22:45.593] getGlobalsAndPackages() ... DONE
[10:22:45.593] [local output] makeClusterPSOCK() ...
[10:22:45.638] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:22:45.639] [local output] Base port: 11089
[10:22:45.639] [local output] Getting setup options for 2 cluster nodes ...
[10:22:45.640] [local output]  - Node 1 of 2 ...
[10:22:45.640] [local output] localMachine=TRUE => revtunnel=FALSE

[10:22:45.641] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpTHXGJm/worker.rank=1.parallelly.parent=68445.10b5d20b242c5.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpTHXGJm/worker.rank=1.parallelly.parent=68445.10b5d20b242c5.pid")'’
[10:22:45.838] - Possible to infer worker's PID: TRUE
[10:22:45.838] [local output] Rscript port: 11089

[10:22:45.838] [local output]  - Node 2 of 2 ...
[10:22:45.839] [local output] localMachine=TRUE => revtunnel=FALSE

[10:22:45.839] [local output] Rscript port: 11089

[10:22:45.840] [local output] Getting setup options for 2 cluster nodes ... done
[10:22:45.840] [local output]  - Parallel setup requested for some PSOCK nodes
[10:22:45.840] [local output] Setting up PSOCK nodes in parallel
[10:22:45.840] List of 36
[10:22:45.840]  $ worker          : chr "localhost"
[10:22:45.840]   ..- attr(*, "localhost")= logi TRUE
[10:22:45.840]  $ master          : chr "localhost"
[10:22:45.840]  $ port            : int 11089
[10:22:45.840]  $ connectTimeout  : num 120
[10:22:45.840]  $ timeout         : num 2592000
[10:22:45.840]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:22:45.840]  $ homogeneous     : logi TRUE
[10:22:45.840]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:22:45.840]  $ rscript_envs    : NULL
[10:22:45.840]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:22:45.840]  $ rscript_startup : NULL
[10:22:45.840]  $ rscript_sh      : chr "sh"
[10:22:45.840]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:22:45.840]  $ methods         : logi TRUE
[10:22:45.840]  $ socketOptions   : chr "no-delay"
[10:22:45.840]  $ useXDR          : logi FALSE
[10:22:45.840]  $ outfile         : chr "/dev/null"
[10:22:45.840]  $ renice          : int NA
[10:22:45.840]  $ rshcmd          : NULL
[10:22:45.840]  $ user            : chr(0) 
[10:22:45.840]  $ revtunnel       : logi FALSE
[10:22:45.840]  $ rshlogfile      : NULL
[10:22:45.840]  $ rshopts         : chr(0) 
[10:22:45.840]  $ rank            : int 1
[10:22:45.840]  $ manual          : logi FALSE
[10:22:45.840]  $ dryrun          : logi FALSE
[10:22:45.840]  $ quiet           : logi FALSE
[10:22:45.840]  $ setup_strategy  : chr "parallel"
[10:22:45.840]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:22:45.840]  $ pidfile         : chr "/tmp/RtmpTHXGJm/worker.rank=1.parallelly.parent=68445.10b5d20b242c5.pid"
[10:22:45.840]  $ rshcmd_label    : NULL
[10:22:45.840]  $ rsh_call        : NULL
[10:22:45.840]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:22:45.840]  $ localMachine    : logi TRUE
[10:22:45.840]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:22:45.840]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:22:45.840]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:22:45.840]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:22:45.840]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:22:45.840]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:22:45.840]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:22:45.840]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:22:45.840]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:22:45.840]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:22:45.840]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:22:45.840]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:22:45.840]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:22:45.840]  $ arguments       :List of 28
[10:22:45.840]   ..$ worker          : chr "localhost"
[10:22:45.840]   ..$ master          : NULL
[10:22:45.840]   ..$ port            : int 11089
[10:22:45.840]   ..$ connectTimeout  : num 120
[10:22:45.840]   ..$ timeout         : num 2592000
[10:22:45.840]   ..$ rscript         : NULL
[10:22:45.840]   ..$ homogeneous     : NULL
[10:22:45.840]   ..$ rscript_args    : NULL
[10:22:45.840]   ..$ rscript_envs    : NULL
[10:22:45.840]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:22:45.840]   ..$ rscript_startup : NULL
[10:22:45.840]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:22:45.840]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:22:45.840]   ..$ methods         : logi TRUE
[10:22:45.840]   ..$ socketOptions   : chr "no-delay"
[10:22:45.840]   ..$ useXDR          : logi FALSE
[10:22:45.840]   ..$ outfile         : chr "/dev/null"
[10:22:45.840]   ..$ renice          : int NA
[10:22:45.840]   ..$ rshcmd          : NULL
[10:22:45.840]   ..$ user            : NULL
[10:22:45.840]   ..$ revtunnel       : logi NA
[10:22:45.840]   ..$ rshlogfile      : NULL
[10:22:45.840]   ..$ rshopts         : NULL
[10:22:45.840]   ..$ rank            : int 1
[10:22:45.840]   ..$ manual          : logi FALSE
[10:22:45.840]   ..$ dryrun          : logi FALSE
[10:22:45.840]   ..$ quiet           : logi FALSE
[10:22:45.840]   ..$ setup_strategy  : chr "parallel"
[10:22:45.840]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:22:45.858] [local output] System call to launch all workers:
[10:22:45.858] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpTHXGJm/worker.rank=1.parallelly.parent=68445.10b5d20b242c5.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11089 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:22:45.858] [local output] Starting PSOCK main server
[10:22:45.863] [local output] Workers launched
[10:22:45.864] [local output] Waiting for workers to connect back
[10:22:45.864]  - [local output] 0 workers out of 2 ready
[10:22:46.109]  - [local output] 0 workers out of 2 ready
[10:22:46.109]  - [local output] 1 workers out of 2 ready
[10:22:46.110]  - [local output] 1 workers out of 2 ready
[10:22:46.111]  - [local output] 2 workers out of 2 ready
[10:22:46.111] [local output] Launching of workers completed
[10:22:46.111] [local output] Collecting session information from workers
[10:22:46.112] [local output]  - Worker #1 of 2
[10:22:46.113] [local output]  - Worker #2 of 2
[10:22:46.113] [local output] makeClusterPSOCK() ... done
[10:22:46.124] Packages needed by the future expression (n = 0): <none>
[10:22:46.124] Packages needed by future strategies (n = 0): <none>
[10:22:46.125] {
[10:22:46.125]     {
[10:22:46.125]         {
[10:22:46.125]             ...future.startTime <- base::Sys.time()
[10:22:46.125]             {
[10:22:46.125]                 {
[10:22:46.125]                   {
[10:22:46.125]                     {
[10:22:46.125]                       base::local({
[10:22:46.125]                         has_future <- base::requireNamespace("future", 
[10:22:46.125]                           quietly = TRUE)
[10:22:46.125]                         if (has_future) {
[10:22:46.125]                           ns <- base::getNamespace("future")
[10:22:46.125]                           version <- ns[[".package"]][["version"]]
[10:22:46.125]                           if (is.null(version)) 
[10:22:46.125]                             version <- utils::packageVersion("future")
[10:22:46.125]                         }
[10:22:46.125]                         else {
[10:22:46.125]                           version <- NULL
[10:22:46.125]                         }
[10:22:46.125]                         if (!has_future || version < "1.8.0") {
[10:22:46.125]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:46.125]                             "", base::R.version$version.string), 
[10:22:46.125]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:46.125]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:46.125]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:46.125]                               "release", "version")], collapse = " "), 
[10:22:46.125]                             hostname = base::Sys.info()[["nodename"]])
[10:22:46.125]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:46.125]                             info)
[10:22:46.125]                           info <- base::paste(info, collapse = "; ")
[10:22:46.125]                           if (!has_future) {
[10:22:46.125]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:46.125]                               info)
[10:22:46.125]                           }
[10:22:46.125]                           else {
[10:22:46.125]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:46.125]                               info, version)
[10:22:46.125]                           }
[10:22:46.125]                           base::stop(msg)
[10:22:46.125]                         }
[10:22:46.125]                       })
[10:22:46.125]                     }
[10:22:46.125]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:46.125]                     base::options(mc.cores = 1L)
[10:22:46.125]                   }
[10:22:46.125]                   options(future.plan = NULL)
[10:22:46.125]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:46.125]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:46.125]                 }
[10:22:46.125]                 ...future.workdir <- getwd()
[10:22:46.125]             }
[10:22:46.125]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:46.125]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:46.125]         }
[10:22:46.125]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:46.125]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:46.125]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:46.125]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:46.125]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:46.125]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:46.125]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:46.125]             base::names(...future.oldOptions))
[10:22:46.125]     }
[10:22:46.125]     if (FALSE) {
[10:22:46.125]     }
[10:22:46.125]     else {
[10:22:46.125]         if (TRUE) {
[10:22:46.125]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:46.125]                 open = "w")
[10:22:46.125]         }
[10:22:46.125]         else {
[10:22:46.125]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:46.125]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:46.125]         }
[10:22:46.125]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:46.125]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:46.125]             base::sink(type = "output", split = FALSE)
[10:22:46.125]             base::close(...future.stdout)
[10:22:46.125]         }, add = TRUE)
[10:22:46.125]     }
[10:22:46.125]     ...future.frame <- base::sys.nframe()
[10:22:46.125]     ...future.conditions <- base::list()
[10:22:46.125]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:46.125]     if (FALSE) {
[10:22:46.125]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:46.125]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:46.125]     }
[10:22:46.125]     ...future.result <- base::tryCatch({
[10:22:46.125]         base::withCallingHandlers({
[10:22:46.125]             ...future.value <- base::withVisible(base::local({
[10:22:46.125]                 ...future.makeSendCondition <- base::local({
[10:22:46.125]                   sendCondition <- NULL
[10:22:46.125]                   function(frame = 1L) {
[10:22:46.125]                     if (is.function(sendCondition)) 
[10:22:46.125]                       return(sendCondition)
[10:22:46.125]                     ns <- getNamespace("parallel")
[10:22:46.125]                     if (exists("sendData", mode = "function", 
[10:22:46.125]                       envir = ns)) {
[10:22:46.125]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:46.125]                         envir = ns)
[10:22:46.125]                       envir <- sys.frame(frame)
[10:22:46.125]                       master <- NULL
[10:22:46.125]                       while (!identical(envir, .GlobalEnv) && 
[10:22:46.125]                         !identical(envir, emptyenv())) {
[10:22:46.125]                         if (exists("master", mode = "list", envir = envir, 
[10:22:46.125]                           inherits = FALSE)) {
[10:22:46.125]                           master <- get("master", mode = "list", 
[10:22:46.125]                             envir = envir, inherits = FALSE)
[10:22:46.125]                           if (inherits(master, c("SOCKnode", 
[10:22:46.125]                             "SOCK0node"))) {
[10:22:46.125]                             sendCondition <<- function(cond) {
[10:22:46.125]                               data <- list(type = "VALUE", value = cond, 
[10:22:46.125]                                 success = TRUE)
[10:22:46.125]                               parallel_sendData(master, data)
[10:22:46.125]                             }
[10:22:46.125]                             return(sendCondition)
[10:22:46.125]                           }
[10:22:46.125]                         }
[10:22:46.125]                         frame <- frame + 1L
[10:22:46.125]                         envir <- sys.frame(frame)
[10:22:46.125]                       }
[10:22:46.125]                     }
[10:22:46.125]                     sendCondition <<- function(cond) NULL
[10:22:46.125]                   }
[10:22:46.125]                 })
[10:22:46.125]                 withCallingHandlers({
[10:22:46.125]                   NA
[10:22:46.125]                 }, immediateCondition = function(cond) {
[10:22:46.125]                   sendCondition <- ...future.makeSendCondition()
[10:22:46.125]                   sendCondition(cond)
[10:22:46.125]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:46.125]                   {
[10:22:46.125]                     inherits <- base::inherits
[10:22:46.125]                     invokeRestart <- base::invokeRestart
[10:22:46.125]                     is.null <- base::is.null
[10:22:46.125]                     muffled <- FALSE
[10:22:46.125]                     if (inherits(cond, "message")) {
[10:22:46.125]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:46.125]                       if (muffled) 
[10:22:46.125]                         invokeRestart("muffleMessage")
[10:22:46.125]                     }
[10:22:46.125]                     else if (inherits(cond, "warning")) {
[10:22:46.125]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:46.125]                       if (muffled) 
[10:22:46.125]                         invokeRestart("muffleWarning")
[10:22:46.125]                     }
[10:22:46.125]                     else if (inherits(cond, "condition")) {
[10:22:46.125]                       if (!is.null(pattern)) {
[10:22:46.125]                         computeRestarts <- base::computeRestarts
[10:22:46.125]                         grepl <- base::grepl
[10:22:46.125]                         restarts <- computeRestarts(cond)
[10:22:46.125]                         for (restart in restarts) {
[10:22:46.125]                           name <- restart$name
[10:22:46.125]                           if (is.null(name)) 
[10:22:46.125]                             next
[10:22:46.125]                           if (!grepl(pattern, name)) 
[10:22:46.125]                             next
[10:22:46.125]                           invokeRestart(restart)
[10:22:46.125]                           muffled <- TRUE
[10:22:46.125]                           break
[10:22:46.125]                         }
[10:22:46.125]                       }
[10:22:46.125]                     }
[10:22:46.125]                     invisible(muffled)
[10:22:46.125]                   }
[10:22:46.125]                   muffleCondition(cond)
[10:22:46.125]                 })
[10:22:46.125]             }))
[10:22:46.125]             future::FutureResult(value = ...future.value$value, 
[10:22:46.125]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:46.125]                   ...future.rng), globalenv = if (FALSE) 
[10:22:46.125]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:46.125]                     ...future.globalenv.names))
[10:22:46.125]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:46.125]         }, condition = base::local({
[10:22:46.125]             c <- base::c
[10:22:46.125]             inherits <- base::inherits
[10:22:46.125]             invokeRestart <- base::invokeRestart
[10:22:46.125]             length <- base::length
[10:22:46.125]             list <- base::list
[10:22:46.125]             seq.int <- base::seq.int
[10:22:46.125]             signalCondition <- base::signalCondition
[10:22:46.125]             sys.calls <- base::sys.calls
[10:22:46.125]             `[[` <- base::`[[`
[10:22:46.125]             `+` <- base::`+`
[10:22:46.125]             `<<-` <- base::`<<-`
[10:22:46.125]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:46.125]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:46.125]                   3L)]
[10:22:46.125]             }
[10:22:46.125]             function(cond) {
[10:22:46.125]                 is_error <- inherits(cond, "error")
[10:22:46.125]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:46.125]                   NULL)
[10:22:46.125]                 if (is_error) {
[10:22:46.125]                   sessionInformation <- function() {
[10:22:46.125]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:46.125]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:46.125]                       search = base::search(), system = base::Sys.info())
[10:22:46.125]                   }
[10:22:46.125]                   ...future.conditions[[length(...future.conditions) + 
[10:22:46.125]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:46.125]                     cond$call), session = sessionInformation(), 
[10:22:46.125]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:46.125]                   signalCondition(cond)
[10:22:46.125]                 }
[10:22:46.125]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:46.125]                 "immediateCondition"))) {
[10:22:46.125]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:46.125]                   ...future.conditions[[length(...future.conditions) + 
[10:22:46.125]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:46.125]                   if (TRUE && !signal) {
[10:22:46.125]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:46.125]                     {
[10:22:46.125]                       inherits <- base::inherits
[10:22:46.125]                       invokeRestart <- base::invokeRestart
[10:22:46.125]                       is.null <- base::is.null
[10:22:46.125]                       muffled <- FALSE
[10:22:46.125]                       if (inherits(cond, "message")) {
[10:22:46.125]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:46.125]                         if (muffled) 
[10:22:46.125]                           invokeRestart("muffleMessage")
[10:22:46.125]                       }
[10:22:46.125]                       else if (inherits(cond, "warning")) {
[10:22:46.125]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:46.125]                         if (muffled) 
[10:22:46.125]                           invokeRestart("muffleWarning")
[10:22:46.125]                       }
[10:22:46.125]                       else if (inherits(cond, "condition")) {
[10:22:46.125]                         if (!is.null(pattern)) {
[10:22:46.125]                           computeRestarts <- base::computeRestarts
[10:22:46.125]                           grepl <- base::grepl
[10:22:46.125]                           restarts <- computeRestarts(cond)
[10:22:46.125]                           for (restart in restarts) {
[10:22:46.125]                             name <- restart$name
[10:22:46.125]                             if (is.null(name)) 
[10:22:46.125]                               next
[10:22:46.125]                             if (!grepl(pattern, name)) 
[10:22:46.125]                               next
[10:22:46.125]                             invokeRestart(restart)
[10:22:46.125]                             muffled <- TRUE
[10:22:46.125]                             break
[10:22:46.125]                           }
[10:22:46.125]                         }
[10:22:46.125]                       }
[10:22:46.125]                       invisible(muffled)
[10:22:46.125]                     }
[10:22:46.125]                     muffleCondition(cond, pattern = "^muffle")
[10:22:46.125]                   }
[10:22:46.125]                 }
[10:22:46.125]                 else {
[10:22:46.125]                   if (TRUE) {
[10:22:46.125]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:46.125]                     {
[10:22:46.125]                       inherits <- base::inherits
[10:22:46.125]                       invokeRestart <- base::invokeRestart
[10:22:46.125]                       is.null <- base::is.null
[10:22:46.125]                       muffled <- FALSE
[10:22:46.125]                       if (inherits(cond, "message")) {
[10:22:46.125]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:46.125]                         if (muffled) 
[10:22:46.125]                           invokeRestart("muffleMessage")
[10:22:46.125]                       }
[10:22:46.125]                       else if (inherits(cond, "warning")) {
[10:22:46.125]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:46.125]                         if (muffled) 
[10:22:46.125]                           invokeRestart("muffleWarning")
[10:22:46.125]                       }
[10:22:46.125]                       else if (inherits(cond, "condition")) {
[10:22:46.125]                         if (!is.null(pattern)) {
[10:22:46.125]                           computeRestarts <- base::computeRestarts
[10:22:46.125]                           grepl <- base::grepl
[10:22:46.125]                           restarts <- computeRestarts(cond)
[10:22:46.125]                           for (restart in restarts) {
[10:22:46.125]                             name <- restart$name
[10:22:46.125]                             if (is.null(name)) 
[10:22:46.125]                               next
[10:22:46.125]                             if (!grepl(pattern, name)) 
[10:22:46.125]                               next
[10:22:46.125]                             invokeRestart(restart)
[10:22:46.125]                             muffled <- TRUE
[10:22:46.125]                             break
[10:22:46.125]                           }
[10:22:46.125]                         }
[10:22:46.125]                       }
[10:22:46.125]                       invisible(muffled)
[10:22:46.125]                     }
[10:22:46.125]                     muffleCondition(cond, pattern = "^muffle")
[10:22:46.125]                   }
[10:22:46.125]                 }
[10:22:46.125]             }
[10:22:46.125]         }))
[10:22:46.125]     }, error = function(ex) {
[10:22:46.125]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:46.125]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:46.125]                 ...future.rng), started = ...future.startTime, 
[10:22:46.125]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:46.125]             version = "1.8"), class = "FutureResult")
[10:22:46.125]     }, finally = {
[10:22:46.125]         if (!identical(...future.workdir, getwd())) 
[10:22:46.125]             setwd(...future.workdir)
[10:22:46.125]         {
[10:22:46.125]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:46.125]                 ...future.oldOptions$nwarnings <- NULL
[10:22:46.125]             }
[10:22:46.125]             base::options(...future.oldOptions)
[10:22:46.125]             if (.Platform$OS.type == "windows") {
[10:22:46.125]                 old_names <- names(...future.oldEnvVars)
[10:22:46.125]                 envs <- base::Sys.getenv()
[10:22:46.125]                 names <- names(envs)
[10:22:46.125]                 common <- intersect(names, old_names)
[10:22:46.125]                 added <- setdiff(names, old_names)
[10:22:46.125]                 removed <- setdiff(old_names, names)
[10:22:46.125]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:46.125]                   envs[common]]
[10:22:46.125]                 NAMES <- toupper(changed)
[10:22:46.125]                 args <- list()
[10:22:46.125]                 for (kk in seq_along(NAMES)) {
[10:22:46.125]                   name <- changed[[kk]]
[10:22:46.125]                   NAME <- NAMES[[kk]]
[10:22:46.125]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:46.125]                     next
[10:22:46.125]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:46.125]                 }
[10:22:46.125]                 NAMES <- toupper(added)
[10:22:46.125]                 for (kk in seq_along(NAMES)) {
[10:22:46.125]                   name <- added[[kk]]
[10:22:46.125]                   NAME <- NAMES[[kk]]
[10:22:46.125]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:46.125]                     next
[10:22:46.125]                   args[[name]] <- ""
[10:22:46.125]                 }
[10:22:46.125]                 NAMES <- toupper(removed)
[10:22:46.125]                 for (kk in seq_along(NAMES)) {
[10:22:46.125]                   name <- removed[[kk]]
[10:22:46.125]                   NAME <- NAMES[[kk]]
[10:22:46.125]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:46.125]                     next
[10:22:46.125]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:46.125]                 }
[10:22:46.125]                 if (length(args) > 0) 
[10:22:46.125]                   base::do.call(base::Sys.setenv, args = args)
[10:22:46.125]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:46.125]             }
[10:22:46.125]             else {
[10:22:46.125]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:46.125]             }
[10:22:46.125]             {
[10:22:46.125]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:46.125]                   0L) {
[10:22:46.125]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:46.125]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:46.125]                   base::options(opts)
[10:22:46.125]                 }
[10:22:46.125]                 {
[10:22:46.125]                   {
[10:22:46.125]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:46.125]                     NULL
[10:22:46.125]                   }
[10:22:46.125]                   options(future.plan = NULL)
[10:22:46.125]                   if (is.na(NA_character_)) 
[10:22:46.125]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:46.125]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:46.125]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:46.125]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:46.125]                     envir = parent.frame()) 
[10:22:46.125]                   {
[10:22:46.125]                     if (is.function(workers)) 
[10:22:46.125]                       workers <- workers()
[10:22:46.125]                     workers <- structure(as.integer(workers), 
[10:22:46.125]                       class = class(workers))
[10:22:46.125]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:46.125]                       workers >= 1)
[10:22:46.125]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:46.125]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:46.125]                     }
[10:22:46.125]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:46.125]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:46.125]                       envir = envir)
[10:22:46.125]                     if (!future$lazy) 
[10:22:46.125]                       future <- run(future)
[10:22:46.125]                     invisible(future)
[10:22:46.125]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:46.125]                 }
[10:22:46.125]             }
[10:22:46.125]         }
[10:22:46.125]     })
[10:22:46.125]     if (TRUE) {
[10:22:46.125]         base::sink(type = "output", split = FALSE)
[10:22:46.125]         if (TRUE) {
[10:22:46.125]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:46.125]         }
[10:22:46.125]         else {
[10:22:46.125]             ...future.result["stdout"] <- base::list(NULL)
[10:22:46.125]         }
[10:22:46.125]         base::close(...future.stdout)
[10:22:46.125]         ...future.stdout <- NULL
[10:22:46.125]     }
[10:22:46.125]     ...future.result$conditions <- ...future.conditions
[10:22:46.125]     ...future.result$finished <- base::Sys.time()
[10:22:46.125]     ...future.result
[10:22:46.125] }
[10:22:46.179] MultisessionFuture started
[10:22:46.179] result() for ClusterFuture ...
[10:22:46.180] receiveMessageFromWorker() for ClusterFuture ...
[10:22:46.180] - Validating connection of MultisessionFuture
[10:22:46.224] - received message: FutureResult
[10:22:46.225] - Received FutureResult
[10:22:46.225] - Erased future from FutureRegistry
[10:22:46.225] result() for ClusterFuture ...
[10:22:46.225] - result already collected: FutureResult
[10:22:46.225] result() for ClusterFuture ... done
[10:22:46.225] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:46.225] result() for ClusterFuture ... done
[10:22:46.226] result() for ClusterFuture ...
[10:22:46.226] - result already collected: FutureResult
[10:22:46.226] result() for ClusterFuture ... done
[10:22:46.226] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:22:46.230] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[10:22:46.231] getGlobalsAndPackagesXApply() ...
[10:22:46.231]  - future.globals: TRUE
[10:22:46.231] getGlobalsAndPackages() ...
[10:22:46.231] Searching for globals...
[10:22:46.278] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[10:22:46.279] Searching for globals ... DONE
[10:22:46.279] Resolving globals: FALSE
[10:22:46.281] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[10:22:46.281] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[10:22:46.281] - globals: [1] ‘FUN’
[10:22:46.281] 
[10:22:46.281] getGlobalsAndPackages() ... DONE
[10:22:46.281]  - globals found/used: [n=1] ‘FUN’
[10:22:46.282]  - needed namespaces: [n=0] 
[10:22:46.282] Finding globals ... DONE
[10:22:46.282]  - use_args: TRUE
[10:22:46.282]  - Getting '...' globals ...
[10:22:46.282] resolve() on list ...
[10:22:46.282]  recursive: 0
[10:22:46.282]  length: 1
[10:22:46.282]  elements: ‘...’
[10:22:46.283]  length: 0 (resolved future 1)
[10:22:46.283] resolve() on list ... DONE
[10:22:46.283]    - '...' content: [n=0] 
[10:22:46.283] List of 1
[10:22:46.283]  $ ...: list()
[10:22:46.283]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:46.283]  - attr(*, "where")=List of 1
[10:22:46.283]   ..$ ...:<environment: 0x55ca4e09a4d8> 
[10:22:46.283]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:46.283]  - attr(*, "resolved")= logi TRUE
[10:22:46.283]  - attr(*, "total_size")= num NA
[10:22:46.285]  - Getting '...' globals ... DONE
[10:22:46.286] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:46.286] List of 2
[10:22:46.286]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:22:46.286]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:22:46.286]  $ ...          : list()
[10:22:46.286]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:46.286]  - attr(*, "where")=List of 2
[10:22:46.286]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:46.286]   ..$ ...          :<environment: 0x55ca4e09a4d8> 
[10:22:46.286]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:46.286]  - attr(*, "resolved")= logi FALSE
[10:22:46.286]  - attr(*, "total_size")= num 354224
[10:22:46.288] Packages to be attached in all futures: [n=0] 
[10:22:46.288] getGlobalsAndPackagesXApply() ... DONE
[10:22:46.292] future_lapply() ...
[10:22:46.326] Number of chunks: 2
[10:22:46.326] getGlobalsAndPackagesXApply() ...
[10:22:46.326]  - future.globals: <name-value list> with names ‘list()’
[10:22:46.326]  - use_args: TRUE
[10:22:46.326] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:22:46.326] List of 2
[10:22:46.326]  $ ...          : list()
[10:22:46.326]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:46.326]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:22:46.326]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:22:46.326]  - attr(*, "where")=List of 2
[10:22:46.326]   ..$ ...          :<environment: 0x55ca4e09a4d8> 
[10:22:46.326]   ..$ ...future.FUN:<environment: namespace:base> 
[10:22:46.326]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:46.326]  - attr(*, "resolved")= logi FALSE
[10:22:46.326]  - attr(*, "total_size")= num NA
[10:22:46.330] Packages to be attached in all futures: [n=0] 
[10:22:46.330] getGlobalsAndPackagesXApply() ... DONE
[10:22:46.330] Number of futures (= number of chunks): 2
[10:22:46.330] Launching 2 futures (chunks) ...
[10:22:46.330] Chunk #1 of 2 ...
[10:22:46.331]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:46.331]  - seeds: <none>
[10:22:46.331]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:46.331] getGlobalsAndPackages() ...
[10:22:46.331] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:46.331] Resolving globals: FALSE
[10:22:46.331] Tweak future expression to call with '...' arguments ...
[10:22:46.331] {
[10:22:46.331]     do.call(function(...) {
[10:22:46.331]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:46.331]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:46.331]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:46.331]             on.exit(options(oopts), add = TRUE)
[10:22:46.331]         }
[10:22:46.331]         {
[10:22:46.331]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:46.331]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:46.331]                 ...future.FUN(...future.X_jj, ...)
[10:22:46.331]             })
[10:22:46.331]         }
[10:22:46.331]     }, args = future.call.arguments)
[10:22:46.331] }
[10:22:46.332] Tweak future expression to call with '...' arguments ... DONE
[10:22:46.332] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:46.332] 
[10:22:46.332] getGlobalsAndPackages() ... DONE
[10:22:46.332] run() for ‘Future’ ...
[10:22:46.333] - state: ‘created’
[10:22:46.333] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:46.346] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:46.347] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:46.347]   - Field: ‘node’
[10:22:46.347]   - Field: ‘label’
[10:22:46.347]   - Field: ‘local’
[10:22:46.347]   - Field: ‘owner’
[10:22:46.347]   - Field: ‘envir’
[10:22:46.347]   - Field: ‘workers’
[10:22:46.347]   - Field: ‘packages’
[10:22:46.347]   - Field: ‘gc’
[10:22:46.348]   - Field: ‘conditions’
[10:22:46.348]   - Field: ‘persistent’
[10:22:46.348]   - Field: ‘expr’
[10:22:46.348]   - Field: ‘uuid’
[10:22:46.348]   - Field: ‘seed’
[10:22:46.348]   - Field: ‘version’
[10:22:46.348]   - Field: ‘result’
[10:22:46.348]   - Field: ‘asynchronous’
[10:22:46.348]   - Field: ‘calls’
[10:22:46.348]   - Field: ‘globals’
[10:22:46.348]   - Field: ‘stdout’
[10:22:46.349]   - Field: ‘earlySignal’
[10:22:46.349]   - Field: ‘lazy’
[10:22:46.349]   - Field: ‘state’
[10:22:46.349] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:46.349] - Launch lazy future ...
[10:22:46.349] Packages needed by the future expression (n = 0): <none>
[10:22:46.349] Packages needed by future strategies (n = 0): <none>
[10:22:46.350] {
[10:22:46.350]     {
[10:22:46.350]         {
[10:22:46.350]             ...future.startTime <- base::Sys.time()
[10:22:46.350]             {
[10:22:46.350]                 {
[10:22:46.350]                   {
[10:22:46.350]                     {
[10:22:46.350]                       base::local({
[10:22:46.350]                         has_future <- base::requireNamespace("future", 
[10:22:46.350]                           quietly = TRUE)
[10:22:46.350]                         if (has_future) {
[10:22:46.350]                           ns <- base::getNamespace("future")
[10:22:46.350]                           version <- ns[[".package"]][["version"]]
[10:22:46.350]                           if (is.null(version)) 
[10:22:46.350]                             version <- utils::packageVersion("future")
[10:22:46.350]                         }
[10:22:46.350]                         else {
[10:22:46.350]                           version <- NULL
[10:22:46.350]                         }
[10:22:46.350]                         if (!has_future || version < "1.8.0") {
[10:22:46.350]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:46.350]                             "", base::R.version$version.string), 
[10:22:46.350]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:46.350]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:46.350]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:46.350]                               "release", "version")], collapse = " "), 
[10:22:46.350]                             hostname = base::Sys.info()[["nodename"]])
[10:22:46.350]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:46.350]                             info)
[10:22:46.350]                           info <- base::paste(info, collapse = "; ")
[10:22:46.350]                           if (!has_future) {
[10:22:46.350]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:46.350]                               info)
[10:22:46.350]                           }
[10:22:46.350]                           else {
[10:22:46.350]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:46.350]                               info, version)
[10:22:46.350]                           }
[10:22:46.350]                           base::stop(msg)
[10:22:46.350]                         }
[10:22:46.350]                       })
[10:22:46.350]                     }
[10:22:46.350]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:46.350]                     base::options(mc.cores = 1L)
[10:22:46.350]                   }
[10:22:46.350]                   options(future.plan = NULL)
[10:22:46.350]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:46.350]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:46.350]                 }
[10:22:46.350]                 ...future.workdir <- getwd()
[10:22:46.350]             }
[10:22:46.350]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:46.350]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:46.350]         }
[10:22:46.350]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:46.350]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:46.350]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:46.350]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:46.350]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:46.350]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:46.350]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:46.350]             base::names(...future.oldOptions))
[10:22:46.350]     }
[10:22:46.350]     if (FALSE) {
[10:22:46.350]     }
[10:22:46.350]     else {
[10:22:46.350]         if (TRUE) {
[10:22:46.350]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:46.350]                 open = "w")
[10:22:46.350]         }
[10:22:46.350]         else {
[10:22:46.350]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:46.350]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:46.350]         }
[10:22:46.350]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:46.350]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:46.350]             base::sink(type = "output", split = FALSE)
[10:22:46.350]             base::close(...future.stdout)
[10:22:46.350]         }, add = TRUE)
[10:22:46.350]     }
[10:22:46.350]     ...future.frame <- base::sys.nframe()
[10:22:46.350]     ...future.conditions <- base::list()
[10:22:46.350]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:46.350]     if (FALSE) {
[10:22:46.350]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:46.350]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:46.350]     }
[10:22:46.350]     ...future.result <- base::tryCatch({
[10:22:46.350]         base::withCallingHandlers({
[10:22:46.350]             ...future.value <- base::withVisible(base::local({
[10:22:46.350]                 ...future.makeSendCondition <- base::local({
[10:22:46.350]                   sendCondition <- NULL
[10:22:46.350]                   function(frame = 1L) {
[10:22:46.350]                     if (is.function(sendCondition)) 
[10:22:46.350]                       return(sendCondition)
[10:22:46.350]                     ns <- getNamespace("parallel")
[10:22:46.350]                     if (exists("sendData", mode = "function", 
[10:22:46.350]                       envir = ns)) {
[10:22:46.350]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:46.350]                         envir = ns)
[10:22:46.350]                       envir <- sys.frame(frame)
[10:22:46.350]                       master <- NULL
[10:22:46.350]                       while (!identical(envir, .GlobalEnv) && 
[10:22:46.350]                         !identical(envir, emptyenv())) {
[10:22:46.350]                         if (exists("master", mode = "list", envir = envir, 
[10:22:46.350]                           inherits = FALSE)) {
[10:22:46.350]                           master <- get("master", mode = "list", 
[10:22:46.350]                             envir = envir, inherits = FALSE)
[10:22:46.350]                           if (inherits(master, c("SOCKnode", 
[10:22:46.350]                             "SOCK0node"))) {
[10:22:46.350]                             sendCondition <<- function(cond) {
[10:22:46.350]                               data <- list(type = "VALUE", value = cond, 
[10:22:46.350]                                 success = TRUE)
[10:22:46.350]                               parallel_sendData(master, data)
[10:22:46.350]                             }
[10:22:46.350]                             return(sendCondition)
[10:22:46.350]                           }
[10:22:46.350]                         }
[10:22:46.350]                         frame <- frame + 1L
[10:22:46.350]                         envir <- sys.frame(frame)
[10:22:46.350]                       }
[10:22:46.350]                     }
[10:22:46.350]                     sendCondition <<- function(cond) NULL
[10:22:46.350]                   }
[10:22:46.350]                 })
[10:22:46.350]                 withCallingHandlers({
[10:22:46.350]                   {
[10:22:46.350]                     do.call(function(...) {
[10:22:46.350]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:46.350]                       if (!identical(...future.globals.maxSize.org, 
[10:22:46.350]                         ...future.globals.maxSize)) {
[10:22:46.350]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:46.350]                         on.exit(options(oopts), add = TRUE)
[10:22:46.350]                       }
[10:22:46.350]                       {
[10:22:46.350]                         lapply(seq_along(...future.elements_ii), 
[10:22:46.350]                           FUN = function(jj) {
[10:22:46.350]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:46.350]                             ...future.FUN(...future.X_jj, ...)
[10:22:46.350]                           })
[10:22:46.350]                       }
[10:22:46.350]                     }, args = future.call.arguments)
[10:22:46.350]                   }
[10:22:46.350]                 }, immediateCondition = function(cond) {
[10:22:46.350]                   sendCondition <- ...future.makeSendCondition()
[10:22:46.350]                   sendCondition(cond)
[10:22:46.350]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:46.350]                   {
[10:22:46.350]                     inherits <- base::inherits
[10:22:46.350]                     invokeRestart <- base::invokeRestart
[10:22:46.350]                     is.null <- base::is.null
[10:22:46.350]                     muffled <- FALSE
[10:22:46.350]                     if (inherits(cond, "message")) {
[10:22:46.350]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:46.350]                       if (muffled) 
[10:22:46.350]                         invokeRestart("muffleMessage")
[10:22:46.350]                     }
[10:22:46.350]                     else if (inherits(cond, "warning")) {
[10:22:46.350]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:46.350]                       if (muffled) 
[10:22:46.350]                         invokeRestart("muffleWarning")
[10:22:46.350]                     }
[10:22:46.350]                     else if (inherits(cond, "condition")) {
[10:22:46.350]                       if (!is.null(pattern)) {
[10:22:46.350]                         computeRestarts <- base::computeRestarts
[10:22:46.350]                         grepl <- base::grepl
[10:22:46.350]                         restarts <- computeRestarts(cond)
[10:22:46.350]                         for (restart in restarts) {
[10:22:46.350]                           name <- restart$name
[10:22:46.350]                           if (is.null(name)) 
[10:22:46.350]                             next
[10:22:46.350]                           if (!grepl(pattern, name)) 
[10:22:46.350]                             next
[10:22:46.350]                           invokeRestart(restart)
[10:22:46.350]                           muffled <- TRUE
[10:22:46.350]                           break
[10:22:46.350]                         }
[10:22:46.350]                       }
[10:22:46.350]                     }
[10:22:46.350]                     invisible(muffled)
[10:22:46.350]                   }
[10:22:46.350]                   muffleCondition(cond)
[10:22:46.350]                 })
[10:22:46.350]             }))
[10:22:46.350]             future::FutureResult(value = ...future.value$value, 
[10:22:46.350]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:46.350]                   ...future.rng), globalenv = if (FALSE) 
[10:22:46.350]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:46.350]                     ...future.globalenv.names))
[10:22:46.350]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:46.350]         }, condition = base::local({
[10:22:46.350]             c <- base::c
[10:22:46.350]             inherits <- base::inherits
[10:22:46.350]             invokeRestart <- base::invokeRestart
[10:22:46.350]             length <- base::length
[10:22:46.350]             list <- base::list
[10:22:46.350]             seq.int <- base::seq.int
[10:22:46.350]             signalCondition <- base::signalCondition
[10:22:46.350]             sys.calls <- base::sys.calls
[10:22:46.350]             `[[` <- base::`[[`
[10:22:46.350]             `+` <- base::`+`
[10:22:46.350]             `<<-` <- base::`<<-`
[10:22:46.350]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:46.350]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:46.350]                   3L)]
[10:22:46.350]             }
[10:22:46.350]             function(cond) {
[10:22:46.350]                 is_error <- inherits(cond, "error")
[10:22:46.350]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:46.350]                   NULL)
[10:22:46.350]                 if (is_error) {
[10:22:46.350]                   sessionInformation <- function() {
[10:22:46.350]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:46.350]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:46.350]                       search = base::search(), system = base::Sys.info())
[10:22:46.350]                   }
[10:22:46.350]                   ...future.conditions[[length(...future.conditions) + 
[10:22:46.350]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:46.350]                     cond$call), session = sessionInformation(), 
[10:22:46.350]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:46.350]                   signalCondition(cond)
[10:22:46.350]                 }
[10:22:46.350]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:46.350]                 "immediateCondition"))) {
[10:22:46.350]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:46.350]                   ...future.conditions[[length(...future.conditions) + 
[10:22:46.350]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:46.350]                   if (TRUE && !signal) {
[10:22:46.350]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:46.350]                     {
[10:22:46.350]                       inherits <- base::inherits
[10:22:46.350]                       invokeRestart <- base::invokeRestart
[10:22:46.350]                       is.null <- base::is.null
[10:22:46.350]                       muffled <- FALSE
[10:22:46.350]                       if (inherits(cond, "message")) {
[10:22:46.350]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:46.350]                         if (muffled) 
[10:22:46.350]                           invokeRestart("muffleMessage")
[10:22:46.350]                       }
[10:22:46.350]                       else if (inherits(cond, "warning")) {
[10:22:46.350]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:46.350]                         if (muffled) 
[10:22:46.350]                           invokeRestart("muffleWarning")
[10:22:46.350]                       }
[10:22:46.350]                       else if (inherits(cond, "condition")) {
[10:22:46.350]                         if (!is.null(pattern)) {
[10:22:46.350]                           computeRestarts <- base::computeRestarts
[10:22:46.350]                           grepl <- base::grepl
[10:22:46.350]                           restarts <- computeRestarts(cond)
[10:22:46.350]                           for (restart in restarts) {
[10:22:46.350]                             name <- restart$name
[10:22:46.350]                             if (is.null(name)) 
[10:22:46.350]                               next
[10:22:46.350]                             if (!grepl(pattern, name)) 
[10:22:46.350]                               next
[10:22:46.350]                             invokeRestart(restart)
[10:22:46.350]                             muffled <- TRUE
[10:22:46.350]                             break
[10:22:46.350]                           }
[10:22:46.350]                         }
[10:22:46.350]                       }
[10:22:46.350]                       invisible(muffled)
[10:22:46.350]                     }
[10:22:46.350]                     muffleCondition(cond, pattern = "^muffle")
[10:22:46.350]                   }
[10:22:46.350]                 }
[10:22:46.350]                 else {
[10:22:46.350]                   if (TRUE) {
[10:22:46.350]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:46.350]                     {
[10:22:46.350]                       inherits <- base::inherits
[10:22:46.350]                       invokeRestart <- base::invokeRestart
[10:22:46.350]                       is.null <- base::is.null
[10:22:46.350]                       muffled <- FALSE
[10:22:46.350]                       if (inherits(cond, "message")) {
[10:22:46.350]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:46.350]                         if (muffled) 
[10:22:46.350]                           invokeRestart("muffleMessage")
[10:22:46.350]                       }
[10:22:46.350]                       else if (inherits(cond, "warning")) {
[10:22:46.350]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:46.350]                         if (muffled) 
[10:22:46.350]                           invokeRestart("muffleWarning")
[10:22:46.350]                       }
[10:22:46.350]                       else if (inherits(cond, "condition")) {
[10:22:46.350]                         if (!is.null(pattern)) {
[10:22:46.350]                           computeRestarts <- base::computeRestarts
[10:22:46.350]                           grepl <- base::grepl
[10:22:46.350]                           restarts <- computeRestarts(cond)
[10:22:46.350]                           for (restart in restarts) {
[10:22:46.350]                             name <- restart$name
[10:22:46.350]                             if (is.null(name)) 
[10:22:46.350]                               next
[10:22:46.350]                             if (!grepl(pattern, name)) 
[10:22:46.350]                               next
[10:22:46.350]                             invokeRestart(restart)
[10:22:46.350]                             muffled <- TRUE
[10:22:46.350]                             break
[10:22:46.350]                           }
[10:22:46.350]                         }
[10:22:46.350]                       }
[10:22:46.350]                       invisible(muffled)
[10:22:46.350]                     }
[10:22:46.350]                     muffleCondition(cond, pattern = "^muffle")
[10:22:46.350]                   }
[10:22:46.350]                 }
[10:22:46.350]             }
[10:22:46.350]         }))
[10:22:46.350]     }, error = function(ex) {
[10:22:46.350]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:46.350]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:46.350]                 ...future.rng), started = ...future.startTime, 
[10:22:46.350]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:46.350]             version = "1.8"), class = "FutureResult")
[10:22:46.350]     }, finally = {
[10:22:46.350]         if (!identical(...future.workdir, getwd())) 
[10:22:46.350]             setwd(...future.workdir)
[10:22:46.350]         {
[10:22:46.350]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:46.350]                 ...future.oldOptions$nwarnings <- NULL
[10:22:46.350]             }
[10:22:46.350]             base::options(...future.oldOptions)
[10:22:46.350]             if (.Platform$OS.type == "windows") {
[10:22:46.350]                 old_names <- names(...future.oldEnvVars)
[10:22:46.350]                 envs <- base::Sys.getenv()
[10:22:46.350]                 names <- names(envs)
[10:22:46.350]                 common <- intersect(names, old_names)
[10:22:46.350]                 added <- setdiff(names, old_names)
[10:22:46.350]                 removed <- setdiff(old_names, names)
[10:22:46.350]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:46.350]                   envs[common]]
[10:22:46.350]                 NAMES <- toupper(changed)
[10:22:46.350]                 args <- list()
[10:22:46.350]                 for (kk in seq_along(NAMES)) {
[10:22:46.350]                   name <- changed[[kk]]
[10:22:46.350]                   NAME <- NAMES[[kk]]
[10:22:46.350]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:46.350]                     next
[10:22:46.350]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:46.350]                 }
[10:22:46.350]                 NAMES <- toupper(added)
[10:22:46.350]                 for (kk in seq_along(NAMES)) {
[10:22:46.350]                   name <- added[[kk]]
[10:22:46.350]                   NAME <- NAMES[[kk]]
[10:22:46.350]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:46.350]                     next
[10:22:46.350]                   args[[name]] <- ""
[10:22:46.350]                 }
[10:22:46.350]                 NAMES <- toupper(removed)
[10:22:46.350]                 for (kk in seq_along(NAMES)) {
[10:22:46.350]                   name <- removed[[kk]]
[10:22:46.350]                   NAME <- NAMES[[kk]]
[10:22:46.350]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:46.350]                     next
[10:22:46.350]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:46.350]                 }
[10:22:46.350]                 if (length(args) > 0) 
[10:22:46.350]                   base::do.call(base::Sys.setenv, args = args)
[10:22:46.350]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:46.350]             }
[10:22:46.350]             else {
[10:22:46.350]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:46.350]             }
[10:22:46.350]             {
[10:22:46.350]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:46.350]                   0L) {
[10:22:46.350]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:46.350]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:46.350]                   base::options(opts)
[10:22:46.350]                 }
[10:22:46.350]                 {
[10:22:46.350]                   {
[10:22:46.350]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:46.350]                     NULL
[10:22:46.350]                   }
[10:22:46.350]                   options(future.plan = NULL)
[10:22:46.350]                   if (is.na(NA_character_)) 
[10:22:46.350]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:46.350]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:46.350]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:46.350]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:46.350]                     envir = parent.frame()) 
[10:22:46.350]                   {
[10:22:46.350]                     if (is.function(workers)) 
[10:22:46.350]                       workers <- workers()
[10:22:46.350]                     workers <- structure(as.integer(workers), 
[10:22:46.350]                       class = class(workers))
[10:22:46.350]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:46.350]                       workers >= 1)
[10:22:46.350]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:46.350]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:46.350]                     }
[10:22:46.350]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:46.350]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:46.350]                       envir = envir)
[10:22:46.350]                     if (!future$lazy) 
[10:22:46.350]                       future <- run(future)
[10:22:46.350]                     invisible(future)
[10:22:46.350]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:46.350]                 }
[10:22:46.350]             }
[10:22:46.350]         }
[10:22:46.350]     })
[10:22:46.350]     if (TRUE) {
[10:22:46.350]         base::sink(type = "output", split = FALSE)
[10:22:46.350]         if (TRUE) {
[10:22:46.350]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:46.350]         }
[10:22:46.350]         else {
[10:22:46.350]             ...future.result["stdout"] <- base::list(NULL)
[10:22:46.350]         }
[10:22:46.350]         base::close(...future.stdout)
[10:22:46.350]         ...future.stdout <- NULL
[10:22:46.350]     }
[10:22:46.350]     ...future.result$conditions <- ...future.conditions
[10:22:46.350]     ...future.result$finished <- base::Sys.time()
[10:22:46.350]     ...future.result
[10:22:46.350] }
[10:22:46.353] Exporting 5 global objects (346.05 KiB) to cluster node #1 ...
[10:22:46.353] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:22:46.354] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:22:46.354] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ...
[10:22:46.398] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ... DONE
[10:22:46.398] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[10:22:46.399] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[10:22:46.399] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:22:46.399] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:22:46.399] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[10:22:46.399] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[10:22:46.400] Exporting 5 global objects (346.05 KiB) to cluster node #1 ... DONE
[10:22:46.400] MultisessionFuture started
[10:22:46.400] - Launch lazy future ... done
[10:22:46.400] run() for ‘MultisessionFuture’ ... done
[10:22:46.400] Created future:
[10:22:46.401] MultisessionFuture:
[10:22:46.401] Label: ‘future_apply-1’
[10:22:46.401] Expression:
[10:22:46.401] {
[10:22:46.401]     do.call(function(...) {
[10:22:46.401]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:46.401]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:46.401]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:46.401]             on.exit(options(oopts), add = TRUE)
[10:22:46.401]         }
[10:22:46.401]         {
[10:22:46.401]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:46.401]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:46.401]                 ...future.FUN(...future.X_jj, ...)
[10:22:46.401]             })
[10:22:46.401]         }
[10:22:46.401]     }, args = future.call.arguments)
[10:22:46.401] }
[10:22:46.401] Lazy evaluation: FALSE
[10:22:46.401] Asynchronous evaluation: TRUE
[10:22:46.401] Local evaluation: TRUE
[10:22:46.401] Environment: R_GlobalEnv
[10:22:46.401] Capture standard output: TRUE
[10:22:46.401] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:46.401] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:46.401] Packages: <none>
[10:22:46.401] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:46.401] Resolved: FALSE
[10:22:46.401] Value: <not collected>
[10:22:46.401] Conditions captured: <none>
[10:22:46.401] Early signaling: FALSE
[10:22:46.401] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:46.401] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:46.412] Chunk #1 of 2 ... DONE
[10:22:46.413] Chunk #2 of 2 ...
[10:22:46.413]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:46.413]  - seeds: <none>
[10:22:46.413]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:46.413] getGlobalsAndPackages() ...
[10:22:46.413] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:46.413] Resolving globals: FALSE
[10:22:46.414] Tweak future expression to call with '...' arguments ...
[10:22:46.414] {
[10:22:46.414]     do.call(function(...) {
[10:22:46.414]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:46.414]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:46.414]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:46.414]             on.exit(options(oopts), add = TRUE)
[10:22:46.414]         }
[10:22:46.414]         {
[10:22:46.414]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:46.414]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:46.414]                 ...future.FUN(...future.X_jj, ...)
[10:22:46.414]             })
[10:22:46.414]         }
[10:22:46.414]     }, args = future.call.arguments)
[10:22:46.414] }
[10:22:46.414] Tweak future expression to call with '...' arguments ... DONE
[10:22:46.414] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:46.415] 
[10:22:46.415] getGlobalsAndPackages() ... DONE
[10:22:46.415] run() for ‘Future’ ...
[10:22:46.415] - state: ‘created’
[10:22:46.415] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:46.429] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:46.430] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:46.430]   - Field: ‘node’
[10:22:46.430]   - Field: ‘label’
[10:22:46.430]   - Field: ‘local’
[10:22:46.430]   - Field: ‘owner’
[10:22:46.430]   - Field: ‘envir’
[10:22:46.430]   - Field: ‘workers’
[10:22:46.432]   - Field: ‘packages’
[10:22:46.432]   - Field: ‘gc’
[10:22:46.432]   - Field: ‘conditions’
[10:22:46.433]   - Field: ‘persistent’
[10:22:46.433]   - Field: ‘expr’
[10:22:46.433]   - Field: ‘uuid’
[10:22:46.433]   - Field: ‘seed’
[10:22:46.433]   - Field: ‘version’
[10:22:46.433]   - Field: ‘result’
[10:22:46.433]   - Field: ‘asynchronous’
[10:22:46.433]   - Field: ‘calls’
[10:22:46.433]   - Field: ‘globals’
[10:22:46.433]   - Field: ‘stdout’
[10:22:46.433]   - Field: ‘earlySignal’
[10:22:46.434]   - Field: ‘lazy’
[10:22:46.434]   - Field: ‘state’
[10:22:46.434] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:46.434] - Launch lazy future ...
[10:22:46.434] Packages needed by the future expression (n = 0): <none>
[10:22:46.434] Packages needed by future strategies (n = 0): <none>
[10:22:46.435] {
[10:22:46.435]     {
[10:22:46.435]         {
[10:22:46.435]             ...future.startTime <- base::Sys.time()
[10:22:46.435]             {
[10:22:46.435]                 {
[10:22:46.435]                   {
[10:22:46.435]                     {
[10:22:46.435]                       base::local({
[10:22:46.435]                         has_future <- base::requireNamespace("future", 
[10:22:46.435]                           quietly = TRUE)
[10:22:46.435]                         if (has_future) {
[10:22:46.435]                           ns <- base::getNamespace("future")
[10:22:46.435]                           version <- ns[[".package"]][["version"]]
[10:22:46.435]                           if (is.null(version)) 
[10:22:46.435]                             version <- utils::packageVersion("future")
[10:22:46.435]                         }
[10:22:46.435]                         else {
[10:22:46.435]                           version <- NULL
[10:22:46.435]                         }
[10:22:46.435]                         if (!has_future || version < "1.8.0") {
[10:22:46.435]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:46.435]                             "", base::R.version$version.string), 
[10:22:46.435]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:46.435]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:46.435]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:46.435]                               "release", "version")], collapse = " "), 
[10:22:46.435]                             hostname = base::Sys.info()[["nodename"]])
[10:22:46.435]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:46.435]                             info)
[10:22:46.435]                           info <- base::paste(info, collapse = "; ")
[10:22:46.435]                           if (!has_future) {
[10:22:46.435]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:46.435]                               info)
[10:22:46.435]                           }
[10:22:46.435]                           else {
[10:22:46.435]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:46.435]                               info, version)
[10:22:46.435]                           }
[10:22:46.435]                           base::stop(msg)
[10:22:46.435]                         }
[10:22:46.435]                       })
[10:22:46.435]                     }
[10:22:46.435]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:46.435]                     base::options(mc.cores = 1L)
[10:22:46.435]                   }
[10:22:46.435]                   options(future.plan = NULL)
[10:22:46.435]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:46.435]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:46.435]                 }
[10:22:46.435]                 ...future.workdir <- getwd()
[10:22:46.435]             }
[10:22:46.435]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:46.435]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:46.435]         }
[10:22:46.435]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:46.435]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:46.435]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:46.435]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:46.435]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:46.435]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:46.435]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:46.435]             base::names(...future.oldOptions))
[10:22:46.435]     }
[10:22:46.435]     if (FALSE) {
[10:22:46.435]     }
[10:22:46.435]     else {
[10:22:46.435]         if (TRUE) {
[10:22:46.435]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:46.435]                 open = "w")
[10:22:46.435]         }
[10:22:46.435]         else {
[10:22:46.435]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:46.435]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:46.435]         }
[10:22:46.435]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:46.435]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:46.435]             base::sink(type = "output", split = FALSE)
[10:22:46.435]             base::close(...future.stdout)
[10:22:46.435]         }, add = TRUE)
[10:22:46.435]     }
[10:22:46.435]     ...future.frame <- base::sys.nframe()
[10:22:46.435]     ...future.conditions <- base::list()
[10:22:46.435]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:46.435]     if (FALSE) {
[10:22:46.435]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:46.435]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:46.435]     }
[10:22:46.435]     ...future.result <- base::tryCatch({
[10:22:46.435]         base::withCallingHandlers({
[10:22:46.435]             ...future.value <- base::withVisible(base::local({
[10:22:46.435]                 ...future.makeSendCondition <- base::local({
[10:22:46.435]                   sendCondition <- NULL
[10:22:46.435]                   function(frame = 1L) {
[10:22:46.435]                     if (is.function(sendCondition)) 
[10:22:46.435]                       return(sendCondition)
[10:22:46.435]                     ns <- getNamespace("parallel")
[10:22:46.435]                     if (exists("sendData", mode = "function", 
[10:22:46.435]                       envir = ns)) {
[10:22:46.435]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:46.435]                         envir = ns)
[10:22:46.435]                       envir <- sys.frame(frame)
[10:22:46.435]                       master <- NULL
[10:22:46.435]                       while (!identical(envir, .GlobalEnv) && 
[10:22:46.435]                         !identical(envir, emptyenv())) {
[10:22:46.435]                         if (exists("master", mode = "list", envir = envir, 
[10:22:46.435]                           inherits = FALSE)) {
[10:22:46.435]                           master <- get("master", mode = "list", 
[10:22:46.435]                             envir = envir, inherits = FALSE)
[10:22:46.435]                           if (inherits(master, c("SOCKnode", 
[10:22:46.435]                             "SOCK0node"))) {
[10:22:46.435]                             sendCondition <<- function(cond) {
[10:22:46.435]                               data <- list(type = "VALUE", value = cond, 
[10:22:46.435]                                 success = TRUE)
[10:22:46.435]                               parallel_sendData(master, data)
[10:22:46.435]                             }
[10:22:46.435]                             return(sendCondition)
[10:22:46.435]                           }
[10:22:46.435]                         }
[10:22:46.435]                         frame <- frame + 1L
[10:22:46.435]                         envir <- sys.frame(frame)
[10:22:46.435]                       }
[10:22:46.435]                     }
[10:22:46.435]                     sendCondition <<- function(cond) NULL
[10:22:46.435]                   }
[10:22:46.435]                 })
[10:22:46.435]                 withCallingHandlers({
[10:22:46.435]                   {
[10:22:46.435]                     do.call(function(...) {
[10:22:46.435]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:46.435]                       if (!identical(...future.globals.maxSize.org, 
[10:22:46.435]                         ...future.globals.maxSize)) {
[10:22:46.435]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:46.435]                         on.exit(options(oopts), add = TRUE)
[10:22:46.435]                       }
[10:22:46.435]                       {
[10:22:46.435]                         lapply(seq_along(...future.elements_ii), 
[10:22:46.435]                           FUN = function(jj) {
[10:22:46.435]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:46.435]                             ...future.FUN(...future.X_jj, ...)
[10:22:46.435]                           })
[10:22:46.435]                       }
[10:22:46.435]                     }, args = future.call.arguments)
[10:22:46.435]                   }
[10:22:46.435]                 }, immediateCondition = function(cond) {
[10:22:46.435]                   sendCondition <- ...future.makeSendCondition()
[10:22:46.435]                   sendCondition(cond)
[10:22:46.435]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:46.435]                   {
[10:22:46.435]                     inherits <- base::inherits
[10:22:46.435]                     invokeRestart <- base::invokeRestart
[10:22:46.435]                     is.null <- base::is.null
[10:22:46.435]                     muffled <- FALSE
[10:22:46.435]                     if (inherits(cond, "message")) {
[10:22:46.435]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:46.435]                       if (muffled) 
[10:22:46.435]                         invokeRestart("muffleMessage")
[10:22:46.435]                     }
[10:22:46.435]                     else if (inherits(cond, "warning")) {
[10:22:46.435]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:46.435]                       if (muffled) 
[10:22:46.435]                         invokeRestart("muffleWarning")
[10:22:46.435]                     }
[10:22:46.435]                     else if (inherits(cond, "condition")) {
[10:22:46.435]                       if (!is.null(pattern)) {
[10:22:46.435]                         computeRestarts <- base::computeRestarts
[10:22:46.435]                         grepl <- base::grepl
[10:22:46.435]                         restarts <- computeRestarts(cond)
[10:22:46.435]                         for (restart in restarts) {
[10:22:46.435]                           name <- restart$name
[10:22:46.435]                           if (is.null(name)) 
[10:22:46.435]                             next
[10:22:46.435]                           if (!grepl(pattern, name)) 
[10:22:46.435]                             next
[10:22:46.435]                           invokeRestart(restart)
[10:22:46.435]                           muffled <- TRUE
[10:22:46.435]                           break
[10:22:46.435]                         }
[10:22:46.435]                       }
[10:22:46.435]                     }
[10:22:46.435]                     invisible(muffled)
[10:22:46.435]                   }
[10:22:46.435]                   muffleCondition(cond)
[10:22:46.435]                 })
[10:22:46.435]             }))
[10:22:46.435]             future::FutureResult(value = ...future.value$value, 
[10:22:46.435]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:46.435]                   ...future.rng), globalenv = if (FALSE) 
[10:22:46.435]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:46.435]                     ...future.globalenv.names))
[10:22:46.435]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:46.435]         }, condition = base::local({
[10:22:46.435]             c <- base::c
[10:22:46.435]             inherits <- base::inherits
[10:22:46.435]             invokeRestart <- base::invokeRestart
[10:22:46.435]             length <- base::length
[10:22:46.435]             list <- base::list
[10:22:46.435]             seq.int <- base::seq.int
[10:22:46.435]             signalCondition <- base::signalCondition
[10:22:46.435]             sys.calls <- base::sys.calls
[10:22:46.435]             `[[` <- base::`[[`
[10:22:46.435]             `+` <- base::`+`
[10:22:46.435]             `<<-` <- base::`<<-`
[10:22:46.435]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:46.435]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:46.435]                   3L)]
[10:22:46.435]             }
[10:22:46.435]             function(cond) {
[10:22:46.435]                 is_error <- inherits(cond, "error")
[10:22:46.435]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:46.435]                   NULL)
[10:22:46.435]                 if (is_error) {
[10:22:46.435]                   sessionInformation <- function() {
[10:22:46.435]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:46.435]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:46.435]                       search = base::search(), system = base::Sys.info())
[10:22:46.435]                   }
[10:22:46.435]                   ...future.conditions[[length(...future.conditions) + 
[10:22:46.435]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:46.435]                     cond$call), session = sessionInformation(), 
[10:22:46.435]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:46.435]                   signalCondition(cond)
[10:22:46.435]                 }
[10:22:46.435]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:46.435]                 "immediateCondition"))) {
[10:22:46.435]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:46.435]                   ...future.conditions[[length(...future.conditions) + 
[10:22:46.435]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:46.435]                   if (TRUE && !signal) {
[10:22:46.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:46.435]                     {
[10:22:46.435]                       inherits <- base::inherits
[10:22:46.435]                       invokeRestart <- base::invokeRestart
[10:22:46.435]                       is.null <- base::is.null
[10:22:46.435]                       muffled <- FALSE
[10:22:46.435]                       if (inherits(cond, "message")) {
[10:22:46.435]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:46.435]                         if (muffled) 
[10:22:46.435]                           invokeRestart("muffleMessage")
[10:22:46.435]                       }
[10:22:46.435]                       else if (inherits(cond, "warning")) {
[10:22:46.435]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:46.435]                         if (muffled) 
[10:22:46.435]                           invokeRestart("muffleWarning")
[10:22:46.435]                       }
[10:22:46.435]                       else if (inherits(cond, "condition")) {
[10:22:46.435]                         if (!is.null(pattern)) {
[10:22:46.435]                           computeRestarts <- base::computeRestarts
[10:22:46.435]                           grepl <- base::grepl
[10:22:46.435]                           restarts <- computeRestarts(cond)
[10:22:46.435]                           for (restart in restarts) {
[10:22:46.435]                             name <- restart$name
[10:22:46.435]                             if (is.null(name)) 
[10:22:46.435]                               next
[10:22:46.435]                             if (!grepl(pattern, name)) 
[10:22:46.435]                               next
[10:22:46.435]                             invokeRestart(restart)
[10:22:46.435]                             muffled <- TRUE
[10:22:46.435]                             break
[10:22:46.435]                           }
[10:22:46.435]                         }
[10:22:46.435]                       }
[10:22:46.435]                       invisible(muffled)
[10:22:46.435]                     }
[10:22:46.435]                     muffleCondition(cond, pattern = "^muffle")
[10:22:46.435]                   }
[10:22:46.435]                 }
[10:22:46.435]                 else {
[10:22:46.435]                   if (TRUE) {
[10:22:46.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:46.435]                     {
[10:22:46.435]                       inherits <- base::inherits
[10:22:46.435]                       invokeRestart <- base::invokeRestart
[10:22:46.435]                       is.null <- base::is.null
[10:22:46.435]                       muffled <- FALSE
[10:22:46.435]                       if (inherits(cond, "message")) {
[10:22:46.435]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:46.435]                         if (muffled) 
[10:22:46.435]                           invokeRestart("muffleMessage")
[10:22:46.435]                       }
[10:22:46.435]                       else if (inherits(cond, "warning")) {
[10:22:46.435]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:46.435]                         if (muffled) 
[10:22:46.435]                           invokeRestart("muffleWarning")
[10:22:46.435]                       }
[10:22:46.435]                       else if (inherits(cond, "condition")) {
[10:22:46.435]                         if (!is.null(pattern)) {
[10:22:46.435]                           computeRestarts <- base::computeRestarts
[10:22:46.435]                           grepl <- base::grepl
[10:22:46.435]                           restarts <- computeRestarts(cond)
[10:22:46.435]                           for (restart in restarts) {
[10:22:46.435]                             name <- restart$name
[10:22:46.435]                             if (is.null(name)) 
[10:22:46.435]                               next
[10:22:46.435]                             if (!grepl(pattern, name)) 
[10:22:46.435]                               next
[10:22:46.435]                             invokeRestart(restart)
[10:22:46.435]                             muffled <- TRUE
[10:22:46.435]                             break
[10:22:46.435]                           }
[10:22:46.435]                         }
[10:22:46.435]                       }
[10:22:46.435]                       invisible(muffled)
[10:22:46.435]                     }
[10:22:46.435]                     muffleCondition(cond, pattern = "^muffle")
[10:22:46.435]                   }
[10:22:46.435]                 }
[10:22:46.435]             }
[10:22:46.435]         }))
[10:22:46.435]     }, error = function(ex) {
[10:22:46.435]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:46.435]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:46.435]                 ...future.rng), started = ...future.startTime, 
[10:22:46.435]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:46.435]             version = "1.8"), class = "FutureResult")
[10:22:46.435]     }, finally = {
[10:22:46.435]         if (!identical(...future.workdir, getwd())) 
[10:22:46.435]             setwd(...future.workdir)
[10:22:46.435]         {
[10:22:46.435]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:46.435]                 ...future.oldOptions$nwarnings <- NULL
[10:22:46.435]             }
[10:22:46.435]             base::options(...future.oldOptions)
[10:22:46.435]             if (.Platform$OS.type == "windows") {
[10:22:46.435]                 old_names <- names(...future.oldEnvVars)
[10:22:46.435]                 envs <- base::Sys.getenv()
[10:22:46.435]                 names <- names(envs)
[10:22:46.435]                 common <- intersect(names, old_names)
[10:22:46.435]                 added <- setdiff(names, old_names)
[10:22:46.435]                 removed <- setdiff(old_names, names)
[10:22:46.435]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:46.435]                   envs[common]]
[10:22:46.435]                 NAMES <- toupper(changed)
[10:22:46.435]                 args <- list()
[10:22:46.435]                 for (kk in seq_along(NAMES)) {
[10:22:46.435]                   name <- changed[[kk]]
[10:22:46.435]                   NAME <- NAMES[[kk]]
[10:22:46.435]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:46.435]                     next
[10:22:46.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:46.435]                 }
[10:22:46.435]                 NAMES <- toupper(added)
[10:22:46.435]                 for (kk in seq_along(NAMES)) {
[10:22:46.435]                   name <- added[[kk]]
[10:22:46.435]                   NAME <- NAMES[[kk]]
[10:22:46.435]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:46.435]                     next
[10:22:46.435]                   args[[name]] <- ""
[10:22:46.435]                 }
[10:22:46.435]                 NAMES <- toupper(removed)
[10:22:46.435]                 for (kk in seq_along(NAMES)) {
[10:22:46.435]                   name <- removed[[kk]]
[10:22:46.435]                   NAME <- NAMES[[kk]]
[10:22:46.435]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:46.435]                     next
[10:22:46.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:46.435]                 }
[10:22:46.435]                 if (length(args) > 0) 
[10:22:46.435]                   base::do.call(base::Sys.setenv, args = args)
[10:22:46.435]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:46.435]             }
[10:22:46.435]             else {
[10:22:46.435]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:46.435]             }
[10:22:46.435]             {
[10:22:46.435]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:46.435]                   0L) {
[10:22:46.435]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:46.435]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:46.435]                   base::options(opts)
[10:22:46.435]                 }
[10:22:46.435]                 {
[10:22:46.435]                   {
[10:22:46.435]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:46.435]                     NULL
[10:22:46.435]                   }
[10:22:46.435]                   options(future.plan = NULL)
[10:22:46.435]                   if (is.na(NA_character_)) 
[10:22:46.435]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:46.435]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:46.435]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:46.435]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:46.435]                     envir = parent.frame()) 
[10:22:46.435]                   {
[10:22:46.435]                     if (is.function(workers)) 
[10:22:46.435]                       workers <- workers()
[10:22:46.435]                     workers <- structure(as.integer(workers), 
[10:22:46.435]                       class = class(workers))
[10:22:46.435]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:46.435]                       workers >= 1)
[10:22:46.435]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:46.435]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:46.435]                     }
[10:22:46.435]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:46.435]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:46.435]                       envir = envir)
[10:22:46.435]                     if (!future$lazy) 
[10:22:46.435]                       future <- run(future)
[10:22:46.435]                     invisible(future)
[10:22:46.435]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:46.435]                 }
[10:22:46.435]             }
[10:22:46.435]         }
[10:22:46.435]     })
[10:22:46.435]     if (TRUE) {
[10:22:46.435]         base::sink(type = "output", split = FALSE)
[10:22:46.435]         if (TRUE) {
[10:22:46.435]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:46.435]         }
[10:22:46.435]         else {
[10:22:46.435]             ...future.result["stdout"] <- base::list(NULL)
[10:22:46.435]         }
[10:22:46.435]         base::close(...future.stdout)
[10:22:46.435]         ...future.stdout <- NULL
[10:22:46.435]     }
[10:22:46.435]     ...future.result$conditions <- ...future.conditions
[10:22:46.435]     ...future.result$finished <- base::Sys.time()
[10:22:46.435]     ...future.result
[10:22:46.435] }
[10:22:46.489] Exporting 5 global objects (346.05 KiB) to cluster node #2 ...
[10:22:46.489] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:22:46.489] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:22:46.490] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ...
[10:22:46.534] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ... DONE
[10:22:46.534] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[10:22:46.535] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[10:22:46.535] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:22:46.535] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:22:46.535] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[10:22:46.536] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[10:22:46.536] Exporting 5 global objects (346.05 KiB) to cluster node #2 ... DONE
[10:22:46.536] MultisessionFuture started
[10:22:46.537] - Launch lazy future ... done
[10:22:46.537] run() for ‘MultisessionFuture’ ... done
[10:22:46.537] Created future:
[10:22:46.537] MultisessionFuture:
[10:22:46.537] Label: ‘future_apply-2’
[10:22:46.537] Expression:
[10:22:46.537] {
[10:22:46.537]     do.call(function(...) {
[10:22:46.537]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:46.537]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:46.537]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:46.537]             on.exit(options(oopts), add = TRUE)
[10:22:46.537]         }
[10:22:46.537]         {
[10:22:46.537]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:46.537]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:46.537]                 ...future.FUN(...future.X_jj, ...)
[10:22:46.537]             })
[10:22:46.537]         }
[10:22:46.537]     }, args = future.call.arguments)
[10:22:46.537] }
[10:22:46.537] Lazy evaluation: FALSE
[10:22:46.537] Asynchronous evaluation: TRUE
[10:22:46.537] Local evaluation: TRUE
[10:22:46.537] Environment: R_GlobalEnv
[10:22:46.537] Capture standard output: TRUE
[10:22:46.537] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:46.537] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:46.537] Packages: <none>
[10:22:46.537] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:46.537] Resolved: FALSE
[10:22:46.537] Value: <not collected>
[10:22:46.537] Conditions captured: <none>
[10:22:46.537] Early signaling: FALSE
[10:22:46.537] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:46.537] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:46.549] Chunk #2 of 2 ... DONE
[10:22:46.549] Launching 2 futures (chunks) ... DONE
[10:22:46.549] Resolving 2 futures (chunks) ...
[10:22:46.549] resolve() on list ...
[10:22:46.549]  recursive: 0
[10:22:46.549]  length: 2
[10:22:46.550] 
[10:22:46.550] receiveMessageFromWorker() for ClusterFuture ...
[10:22:46.550] - Validating connection of MultisessionFuture
[10:22:46.550] - received message: FutureResult
[10:22:46.550] - Received FutureResult
[10:22:46.551] - Erased future from FutureRegistry
[10:22:46.551] result() for ClusterFuture ...
[10:22:46.551] - result already collected: FutureResult
[10:22:46.551] result() for ClusterFuture ... done
[10:22:46.551] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:46.551] Future #1
[10:22:46.551] result() for ClusterFuture ...
[10:22:46.551] - result already collected: FutureResult
[10:22:46.551] result() for ClusterFuture ... done
[10:22:46.551] result() for ClusterFuture ...
[10:22:46.551] - result already collected: FutureResult
[10:22:46.551] result() for ClusterFuture ... done
[10:22:46.552] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:22:46.552] - nx: 2
[10:22:46.552] - relay: TRUE
[10:22:46.552] - stdout: TRUE
[10:22:46.552] - signal: TRUE
[10:22:46.552] - resignal: FALSE
[10:22:46.552] - force: TRUE
[10:22:46.552] - relayed: [n=2] FALSE, FALSE
[10:22:46.552] - queued futures: [n=2] FALSE, FALSE
[10:22:46.552]  - until=1
[10:22:46.552]  - relaying element #1
[10:22:46.553] result() for ClusterFuture ...
[10:22:46.553] - result already collected: FutureResult
[10:22:46.553] result() for ClusterFuture ... done
[10:22:46.553] result() for ClusterFuture ...
[10:22:46.553] - result already collected: FutureResult
[10:22:46.553] result() for ClusterFuture ... done
[10:22:46.553] result() for ClusterFuture ...
[10:22:46.553] - result already collected: FutureResult
[10:22:46.553] result() for ClusterFuture ... done
[10:22:46.553] result() for ClusterFuture ...
[10:22:46.553] - result already collected: FutureResult
[10:22:46.554] result() for ClusterFuture ... done
[10:22:46.554] - relayed: [n=2] TRUE, FALSE
[10:22:46.554] - queued futures: [n=2] TRUE, FALSE
[10:22:46.554] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:22:46.554]  length: 1 (resolved future 1)
[10:22:46.625] receiveMessageFromWorker() for ClusterFuture ...
[10:22:46.625] - Validating connection of MultisessionFuture
[10:22:46.625] - received message: FutureResult
[10:22:46.625] - Received FutureResult
[10:22:46.625] - Erased future from FutureRegistry
[10:22:46.625] result() for ClusterFuture ...
[10:22:46.626] - result already collected: FutureResult
[10:22:46.626] result() for ClusterFuture ... done
[10:22:46.626] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:46.626] Future #2
[10:22:46.626] result() for ClusterFuture ...
[10:22:46.626] - result already collected: FutureResult
[10:22:46.626] result() for ClusterFuture ... done
[10:22:46.626] result() for ClusterFuture ...
[10:22:46.626] - result already collected: FutureResult
[10:22:46.626] result() for ClusterFuture ... done
[10:22:46.627] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:22:46.627] - nx: 2
[10:22:46.627] - relay: TRUE
[10:22:46.627] - stdout: TRUE
[10:22:46.627] - signal: TRUE
[10:22:46.627] - resignal: FALSE
[10:22:46.627] - force: TRUE
[10:22:46.627] - relayed: [n=2] TRUE, FALSE
[10:22:46.627] - queued futures: [n=2] TRUE, FALSE
[10:22:46.627]  - until=2
[10:22:46.628]  - relaying element #2
[10:22:46.628] result() for ClusterFuture ...
[10:22:46.628] - result already collected: FutureResult
[10:22:46.628] result() for ClusterFuture ... done
[10:22:46.628] result() for ClusterFuture ...
[10:22:46.628] - result already collected: FutureResult
[10:22:46.628] result() for ClusterFuture ... done
[10:22:46.628] result() for ClusterFuture ...
[10:22:46.628] - result already collected: FutureResult
[10:22:46.628] result() for ClusterFuture ... done
[10:22:46.628] result() for ClusterFuture ...
[10:22:46.629] - result already collected: FutureResult
[10:22:46.629] result() for ClusterFuture ... done
[10:22:46.629] - relayed: [n=2] TRUE, TRUE
[10:22:46.629] - queued futures: [n=2] TRUE, TRUE
[10:22:46.629] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:22:46.629]  length: 0 (resolved future 2)
[10:22:46.629] Relaying remaining futures
[10:22:46.629] signalConditionsASAP(NULL, pos=0) ...
[10:22:46.629] - nx: 2
[10:22:46.629] - relay: TRUE
[10:22:46.630] - stdout: TRUE
[10:22:46.630] - signal: TRUE
[10:22:46.630] - resignal: FALSE
[10:22:46.630] - force: TRUE
[10:22:46.630] - relayed: [n=2] TRUE, TRUE
[10:22:46.630] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:22:46.630] - relayed: [n=2] TRUE, TRUE
[10:22:46.630] - queued futures: [n=2] TRUE, TRUE
[10:22:46.630] signalConditionsASAP(NULL, pos=0) ... done
[10:22:46.630] resolve() on list ... DONE
[10:22:46.630] result() for ClusterFuture ...
[10:22:46.631] - result already collected: FutureResult
[10:22:46.631] result() for ClusterFuture ... done
[10:22:46.631] result() for ClusterFuture ...
[10:22:46.631] - result already collected: FutureResult
[10:22:46.631] result() for ClusterFuture ... done
[10:22:46.631] result() for ClusterFuture ...
[10:22:46.631] - result already collected: FutureResult
[10:22:46.631] result() for ClusterFuture ... done
[10:22:46.631] result() for ClusterFuture ...
[10:22:46.631] - result already collected: FutureResult
[10:22:46.631] result() for ClusterFuture ... done
[10:22:46.632]  - Number of value chunks collected: 2
[10:22:46.632] Resolving 2 futures (chunks) ... DONE
[10:22:46.632] Reducing values from 2 chunks ...
[10:22:46.632]  - Number of values collected after concatenation: 2
[10:22:46.632]  - Number of values expected: 2
[10:22:46.632] Reducing values from 2 chunks ... DONE
[10:22:46.632] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[10:22:46.633] getGlobalsAndPackagesXApply() ...
[10:22:46.633]  - future.globals: TRUE
[10:22:46.633] getGlobalsAndPackages() ...
[10:22:46.633] Searching for globals...
[10:22:46.666] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[10:22:46.666] Searching for globals ... DONE
[10:22:46.666] Resolving globals: FALSE
[10:22:46.668] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[10:22:46.668] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[10:22:46.668] - globals: [1] ‘FUN’
[10:22:46.668] 
[10:22:46.668] getGlobalsAndPackages() ... DONE
[10:22:46.669]  - globals found/used: [n=1] ‘FUN’
[10:22:46.669]  - needed namespaces: [n=0] 
[10:22:46.669] Finding globals ... DONE
[10:22:46.669]  - use_args: TRUE
[10:22:46.669]  - Getting '...' globals ...
[10:22:46.669] resolve() on list ...
[10:22:46.669]  recursive: 0
[10:22:46.669]  length: 1
[10:22:46.670]  elements: ‘...’
[10:22:46.670]  length: 0 (resolved future 1)
[10:22:46.670] resolve() on list ... DONE
[10:22:46.670]    - '...' content: [n=0] 
[10:22:46.670] List of 1
[10:22:46.670]  $ ...: list()
[10:22:46.670]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:46.670]  - attr(*, "where")=List of 1
[10:22:46.670]   ..$ ...:<environment: 0x55ca4c1e98d0> 
[10:22:46.670]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:46.670]  - attr(*, "resolved")= logi TRUE
[10:22:46.670]  - attr(*, "total_size")= num NA
[10:22:46.673]  - Getting '...' globals ... DONE
[10:22:46.673] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:46.673] List of 2
[10:22:46.673]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:22:46.673]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:22:46.673]  $ ...          : list()
[10:22:46.673]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:46.673]  - attr(*, "where")=List of 2
[10:22:46.673]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:46.673]   ..$ ...          :<environment: 0x55ca4c1e98d0> 
[10:22:46.673]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:46.673]  - attr(*, "resolved")= logi FALSE
[10:22:46.673]  - attr(*, "total_size")= num 354224
[10:22:46.676] Packages to be attached in all futures: [n=0] 
[10:22:46.676] getGlobalsAndPackagesXApply() ... DONE
[10:22:46.682] future_lapply() ...
[10:22:46.715] Number of chunks: 2
[10:22:46.715] getGlobalsAndPackagesXApply() ...
[10:22:46.716]  - future.globals: <name-value list> with names ‘list()’
[10:22:46.716]  - use_args: TRUE
[10:22:46.716] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:22:46.716] List of 2
[10:22:46.716]  $ ...          : list()
[10:22:46.716]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:46.716]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:22:46.716]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:22:46.716]  - attr(*, "where")=List of 2
[10:22:46.716]   ..$ ...          :<environment: 0x55ca4c1e98d0> 
[10:22:46.716]   ..$ ...future.FUN:<environment: namespace:base> 
[10:22:46.716]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:46.716]  - attr(*, "resolved")= logi FALSE
[10:22:46.716]  - attr(*, "total_size")= num NA
[10:22:46.720] Packages to be attached in all futures: [n=0] 
[10:22:46.720] getGlobalsAndPackagesXApply() ... DONE
[10:22:46.720] Number of futures (= number of chunks): 2
[10:22:46.720] Launching 2 futures (chunks) ...
[10:22:46.720] Chunk #1 of 2 ...
[10:22:46.720]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:46.721]  - seeds: <none>
[10:22:46.721]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:46.721] getGlobalsAndPackages() ...
[10:22:46.721] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:46.721] Resolving globals: FALSE
[10:22:46.721] Tweak future expression to call with '...' arguments ...
[10:22:46.721] {
[10:22:46.721]     do.call(function(...) {
[10:22:46.721]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:46.721]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:46.721]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:46.721]             on.exit(options(oopts), add = TRUE)
[10:22:46.721]         }
[10:22:46.721]         {
[10:22:46.721]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:46.721]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:46.721]                 ...future.FUN(...future.X_jj, ...)
[10:22:46.721]             })
[10:22:46.721]         }
[10:22:46.721]     }, args = future.call.arguments)
[10:22:46.721] }
[10:22:46.721] Tweak future expression to call with '...' arguments ... DONE
[10:22:46.722] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:46.722] 
[10:22:46.722] getGlobalsAndPackages() ... DONE
[10:22:46.722] run() for ‘Future’ ...
[10:22:46.723] - state: ‘created’
[10:22:46.723] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:46.736] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:46.737] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:46.737]   - Field: ‘node’
[10:22:46.737]   - Field: ‘label’
[10:22:46.737]   - Field: ‘local’
[10:22:46.737]   - Field: ‘owner’
[10:22:46.737]   - Field: ‘envir’
[10:22:46.737]   - Field: ‘workers’
[10:22:46.737]   - Field: ‘packages’
[10:22:46.737]   - Field: ‘gc’
[10:22:46.737]   - Field: ‘conditions’
[10:22:46.738]   - Field: ‘persistent’
[10:22:46.738]   - Field: ‘expr’
[10:22:46.738]   - Field: ‘uuid’
[10:22:46.738]   - Field: ‘seed’
[10:22:46.738]   - Field: ‘version’
[10:22:46.738]   - Field: ‘result’
[10:22:46.738]   - Field: ‘asynchronous’
[10:22:46.738]   - Field: ‘calls’
[10:22:46.738]   - Field: ‘globals’
[10:22:46.738]   - Field: ‘stdout’
[10:22:46.739]   - Field: ‘earlySignal’
[10:22:46.739]   - Field: ‘lazy’
[10:22:46.739]   - Field: ‘state’
[10:22:46.739] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:46.739] - Launch lazy future ...
[10:22:46.739] Packages needed by the future expression (n = 0): <none>
[10:22:46.739] Packages needed by future strategies (n = 0): <none>
[10:22:46.740] {
[10:22:46.740]     {
[10:22:46.740]         {
[10:22:46.740]             ...future.startTime <- base::Sys.time()
[10:22:46.740]             {
[10:22:46.740]                 {
[10:22:46.740]                   {
[10:22:46.740]                     {
[10:22:46.740]                       base::local({
[10:22:46.740]                         has_future <- base::requireNamespace("future", 
[10:22:46.740]                           quietly = TRUE)
[10:22:46.740]                         if (has_future) {
[10:22:46.740]                           ns <- base::getNamespace("future")
[10:22:46.740]                           version <- ns[[".package"]][["version"]]
[10:22:46.740]                           if (is.null(version)) 
[10:22:46.740]                             version <- utils::packageVersion("future")
[10:22:46.740]                         }
[10:22:46.740]                         else {
[10:22:46.740]                           version <- NULL
[10:22:46.740]                         }
[10:22:46.740]                         if (!has_future || version < "1.8.0") {
[10:22:46.740]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:46.740]                             "", base::R.version$version.string), 
[10:22:46.740]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:46.740]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:46.740]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:46.740]                               "release", "version")], collapse = " "), 
[10:22:46.740]                             hostname = base::Sys.info()[["nodename"]])
[10:22:46.740]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:46.740]                             info)
[10:22:46.740]                           info <- base::paste(info, collapse = "; ")
[10:22:46.740]                           if (!has_future) {
[10:22:46.740]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:46.740]                               info)
[10:22:46.740]                           }
[10:22:46.740]                           else {
[10:22:46.740]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:46.740]                               info, version)
[10:22:46.740]                           }
[10:22:46.740]                           base::stop(msg)
[10:22:46.740]                         }
[10:22:46.740]                       })
[10:22:46.740]                     }
[10:22:46.740]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:46.740]                     base::options(mc.cores = 1L)
[10:22:46.740]                   }
[10:22:46.740]                   options(future.plan = NULL)
[10:22:46.740]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:46.740]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:46.740]                 }
[10:22:46.740]                 ...future.workdir <- getwd()
[10:22:46.740]             }
[10:22:46.740]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:46.740]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:46.740]         }
[10:22:46.740]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:46.740]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:46.740]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:46.740]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:46.740]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:46.740]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:46.740]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:46.740]             base::names(...future.oldOptions))
[10:22:46.740]     }
[10:22:46.740]     if (FALSE) {
[10:22:46.740]     }
[10:22:46.740]     else {
[10:22:46.740]         if (TRUE) {
[10:22:46.740]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:46.740]                 open = "w")
[10:22:46.740]         }
[10:22:46.740]         else {
[10:22:46.740]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:46.740]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:46.740]         }
[10:22:46.740]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:46.740]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:46.740]             base::sink(type = "output", split = FALSE)
[10:22:46.740]             base::close(...future.stdout)
[10:22:46.740]         }, add = TRUE)
[10:22:46.740]     }
[10:22:46.740]     ...future.frame <- base::sys.nframe()
[10:22:46.740]     ...future.conditions <- base::list()
[10:22:46.740]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:46.740]     if (FALSE) {
[10:22:46.740]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:46.740]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:46.740]     }
[10:22:46.740]     ...future.result <- base::tryCatch({
[10:22:46.740]         base::withCallingHandlers({
[10:22:46.740]             ...future.value <- base::withVisible(base::local({
[10:22:46.740]                 ...future.makeSendCondition <- base::local({
[10:22:46.740]                   sendCondition <- NULL
[10:22:46.740]                   function(frame = 1L) {
[10:22:46.740]                     if (is.function(sendCondition)) 
[10:22:46.740]                       return(sendCondition)
[10:22:46.740]                     ns <- getNamespace("parallel")
[10:22:46.740]                     if (exists("sendData", mode = "function", 
[10:22:46.740]                       envir = ns)) {
[10:22:46.740]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:46.740]                         envir = ns)
[10:22:46.740]                       envir <- sys.frame(frame)
[10:22:46.740]                       master <- NULL
[10:22:46.740]                       while (!identical(envir, .GlobalEnv) && 
[10:22:46.740]                         !identical(envir, emptyenv())) {
[10:22:46.740]                         if (exists("master", mode = "list", envir = envir, 
[10:22:46.740]                           inherits = FALSE)) {
[10:22:46.740]                           master <- get("master", mode = "list", 
[10:22:46.740]                             envir = envir, inherits = FALSE)
[10:22:46.740]                           if (inherits(master, c("SOCKnode", 
[10:22:46.740]                             "SOCK0node"))) {
[10:22:46.740]                             sendCondition <<- function(cond) {
[10:22:46.740]                               data <- list(type = "VALUE", value = cond, 
[10:22:46.740]                                 success = TRUE)
[10:22:46.740]                               parallel_sendData(master, data)
[10:22:46.740]                             }
[10:22:46.740]                             return(sendCondition)
[10:22:46.740]                           }
[10:22:46.740]                         }
[10:22:46.740]                         frame <- frame + 1L
[10:22:46.740]                         envir <- sys.frame(frame)
[10:22:46.740]                       }
[10:22:46.740]                     }
[10:22:46.740]                     sendCondition <<- function(cond) NULL
[10:22:46.740]                   }
[10:22:46.740]                 })
[10:22:46.740]                 withCallingHandlers({
[10:22:46.740]                   {
[10:22:46.740]                     do.call(function(...) {
[10:22:46.740]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:46.740]                       if (!identical(...future.globals.maxSize.org, 
[10:22:46.740]                         ...future.globals.maxSize)) {
[10:22:46.740]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:46.740]                         on.exit(options(oopts), add = TRUE)
[10:22:46.740]                       }
[10:22:46.740]                       {
[10:22:46.740]                         lapply(seq_along(...future.elements_ii), 
[10:22:46.740]                           FUN = function(jj) {
[10:22:46.740]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:46.740]                             ...future.FUN(...future.X_jj, ...)
[10:22:46.740]                           })
[10:22:46.740]                       }
[10:22:46.740]                     }, args = future.call.arguments)
[10:22:46.740]                   }
[10:22:46.740]                 }, immediateCondition = function(cond) {
[10:22:46.740]                   sendCondition <- ...future.makeSendCondition()
[10:22:46.740]                   sendCondition(cond)
[10:22:46.740]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:46.740]                   {
[10:22:46.740]                     inherits <- base::inherits
[10:22:46.740]                     invokeRestart <- base::invokeRestart
[10:22:46.740]                     is.null <- base::is.null
[10:22:46.740]                     muffled <- FALSE
[10:22:46.740]                     if (inherits(cond, "message")) {
[10:22:46.740]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:46.740]                       if (muffled) 
[10:22:46.740]                         invokeRestart("muffleMessage")
[10:22:46.740]                     }
[10:22:46.740]                     else if (inherits(cond, "warning")) {
[10:22:46.740]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:46.740]                       if (muffled) 
[10:22:46.740]                         invokeRestart("muffleWarning")
[10:22:46.740]                     }
[10:22:46.740]                     else if (inherits(cond, "condition")) {
[10:22:46.740]                       if (!is.null(pattern)) {
[10:22:46.740]                         computeRestarts <- base::computeRestarts
[10:22:46.740]                         grepl <- base::grepl
[10:22:46.740]                         restarts <- computeRestarts(cond)
[10:22:46.740]                         for (restart in restarts) {
[10:22:46.740]                           name <- restart$name
[10:22:46.740]                           if (is.null(name)) 
[10:22:46.740]                             next
[10:22:46.740]                           if (!grepl(pattern, name)) 
[10:22:46.740]                             next
[10:22:46.740]                           invokeRestart(restart)
[10:22:46.740]                           muffled <- TRUE
[10:22:46.740]                           break
[10:22:46.740]                         }
[10:22:46.740]                       }
[10:22:46.740]                     }
[10:22:46.740]                     invisible(muffled)
[10:22:46.740]                   }
[10:22:46.740]                   muffleCondition(cond)
[10:22:46.740]                 })
[10:22:46.740]             }))
[10:22:46.740]             future::FutureResult(value = ...future.value$value, 
[10:22:46.740]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:46.740]                   ...future.rng), globalenv = if (FALSE) 
[10:22:46.740]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:46.740]                     ...future.globalenv.names))
[10:22:46.740]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:46.740]         }, condition = base::local({
[10:22:46.740]             c <- base::c
[10:22:46.740]             inherits <- base::inherits
[10:22:46.740]             invokeRestart <- base::invokeRestart
[10:22:46.740]             length <- base::length
[10:22:46.740]             list <- base::list
[10:22:46.740]             seq.int <- base::seq.int
[10:22:46.740]             signalCondition <- base::signalCondition
[10:22:46.740]             sys.calls <- base::sys.calls
[10:22:46.740]             `[[` <- base::`[[`
[10:22:46.740]             `+` <- base::`+`
[10:22:46.740]             `<<-` <- base::`<<-`
[10:22:46.740]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:46.740]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:46.740]                   3L)]
[10:22:46.740]             }
[10:22:46.740]             function(cond) {
[10:22:46.740]                 is_error <- inherits(cond, "error")
[10:22:46.740]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:46.740]                   NULL)
[10:22:46.740]                 if (is_error) {
[10:22:46.740]                   sessionInformation <- function() {
[10:22:46.740]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:46.740]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:46.740]                       search = base::search(), system = base::Sys.info())
[10:22:46.740]                   }
[10:22:46.740]                   ...future.conditions[[length(...future.conditions) + 
[10:22:46.740]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:46.740]                     cond$call), session = sessionInformation(), 
[10:22:46.740]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:46.740]                   signalCondition(cond)
[10:22:46.740]                 }
[10:22:46.740]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:46.740]                 "immediateCondition"))) {
[10:22:46.740]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:46.740]                   ...future.conditions[[length(...future.conditions) + 
[10:22:46.740]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:46.740]                   if (TRUE && !signal) {
[10:22:46.740]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:46.740]                     {
[10:22:46.740]                       inherits <- base::inherits
[10:22:46.740]                       invokeRestart <- base::invokeRestart
[10:22:46.740]                       is.null <- base::is.null
[10:22:46.740]                       muffled <- FALSE
[10:22:46.740]                       if (inherits(cond, "message")) {
[10:22:46.740]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:46.740]                         if (muffled) 
[10:22:46.740]                           invokeRestart("muffleMessage")
[10:22:46.740]                       }
[10:22:46.740]                       else if (inherits(cond, "warning")) {
[10:22:46.740]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:46.740]                         if (muffled) 
[10:22:46.740]                           invokeRestart("muffleWarning")
[10:22:46.740]                       }
[10:22:46.740]                       else if (inherits(cond, "condition")) {
[10:22:46.740]                         if (!is.null(pattern)) {
[10:22:46.740]                           computeRestarts <- base::computeRestarts
[10:22:46.740]                           grepl <- base::grepl
[10:22:46.740]                           restarts <- computeRestarts(cond)
[10:22:46.740]                           for (restart in restarts) {
[10:22:46.740]                             name <- restart$name
[10:22:46.740]                             if (is.null(name)) 
[10:22:46.740]                               next
[10:22:46.740]                             if (!grepl(pattern, name)) 
[10:22:46.740]                               next
[10:22:46.740]                             invokeRestart(restart)
[10:22:46.740]                             muffled <- TRUE
[10:22:46.740]                             break
[10:22:46.740]                           }
[10:22:46.740]                         }
[10:22:46.740]                       }
[10:22:46.740]                       invisible(muffled)
[10:22:46.740]                     }
[10:22:46.740]                     muffleCondition(cond, pattern = "^muffle")
[10:22:46.740]                   }
[10:22:46.740]                 }
[10:22:46.740]                 else {
[10:22:46.740]                   if (TRUE) {
[10:22:46.740]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:46.740]                     {
[10:22:46.740]                       inherits <- base::inherits
[10:22:46.740]                       invokeRestart <- base::invokeRestart
[10:22:46.740]                       is.null <- base::is.null
[10:22:46.740]                       muffled <- FALSE
[10:22:46.740]                       if (inherits(cond, "message")) {
[10:22:46.740]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:46.740]                         if (muffled) 
[10:22:46.740]                           invokeRestart("muffleMessage")
[10:22:46.740]                       }
[10:22:46.740]                       else if (inherits(cond, "warning")) {
[10:22:46.740]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:46.740]                         if (muffled) 
[10:22:46.740]                           invokeRestart("muffleWarning")
[10:22:46.740]                       }
[10:22:46.740]                       else if (inherits(cond, "condition")) {
[10:22:46.740]                         if (!is.null(pattern)) {
[10:22:46.740]                           computeRestarts <- base::computeRestarts
[10:22:46.740]                           grepl <- base::grepl
[10:22:46.740]                           restarts <- computeRestarts(cond)
[10:22:46.740]                           for (restart in restarts) {
[10:22:46.740]                             name <- restart$name
[10:22:46.740]                             if (is.null(name)) 
[10:22:46.740]                               next
[10:22:46.740]                             if (!grepl(pattern, name)) 
[10:22:46.740]                               next
[10:22:46.740]                             invokeRestart(restart)
[10:22:46.740]                             muffled <- TRUE
[10:22:46.740]                             break
[10:22:46.740]                           }
[10:22:46.740]                         }
[10:22:46.740]                       }
[10:22:46.740]                       invisible(muffled)
[10:22:46.740]                     }
[10:22:46.740]                     muffleCondition(cond, pattern = "^muffle")
[10:22:46.740]                   }
[10:22:46.740]                 }
[10:22:46.740]             }
[10:22:46.740]         }))
[10:22:46.740]     }, error = function(ex) {
[10:22:46.740]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:46.740]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:46.740]                 ...future.rng), started = ...future.startTime, 
[10:22:46.740]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:46.740]             version = "1.8"), class = "FutureResult")
[10:22:46.740]     }, finally = {
[10:22:46.740]         if (!identical(...future.workdir, getwd())) 
[10:22:46.740]             setwd(...future.workdir)
[10:22:46.740]         {
[10:22:46.740]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:46.740]                 ...future.oldOptions$nwarnings <- NULL
[10:22:46.740]             }
[10:22:46.740]             base::options(...future.oldOptions)
[10:22:46.740]             if (.Platform$OS.type == "windows") {
[10:22:46.740]                 old_names <- names(...future.oldEnvVars)
[10:22:46.740]                 envs <- base::Sys.getenv()
[10:22:46.740]                 names <- names(envs)
[10:22:46.740]                 common <- intersect(names, old_names)
[10:22:46.740]                 added <- setdiff(names, old_names)
[10:22:46.740]                 removed <- setdiff(old_names, names)
[10:22:46.740]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:46.740]                   envs[common]]
[10:22:46.740]                 NAMES <- toupper(changed)
[10:22:46.740]                 args <- list()
[10:22:46.740]                 for (kk in seq_along(NAMES)) {
[10:22:46.740]                   name <- changed[[kk]]
[10:22:46.740]                   NAME <- NAMES[[kk]]
[10:22:46.740]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:46.740]                     next
[10:22:46.740]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:46.740]                 }
[10:22:46.740]                 NAMES <- toupper(added)
[10:22:46.740]                 for (kk in seq_along(NAMES)) {
[10:22:46.740]                   name <- added[[kk]]
[10:22:46.740]                   NAME <- NAMES[[kk]]
[10:22:46.740]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:46.740]                     next
[10:22:46.740]                   args[[name]] <- ""
[10:22:46.740]                 }
[10:22:46.740]                 NAMES <- toupper(removed)
[10:22:46.740]                 for (kk in seq_along(NAMES)) {
[10:22:46.740]                   name <- removed[[kk]]
[10:22:46.740]                   NAME <- NAMES[[kk]]
[10:22:46.740]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:46.740]                     next
[10:22:46.740]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:46.740]                 }
[10:22:46.740]                 if (length(args) > 0) 
[10:22:46.740]                   base::do.call(base::Sys.setenv, args = args)
[10:22:46.740]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:46.740]             }
[10:22:46.740]             else {
[10:22:46.740]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:46.740]             }
[10:22:46.740]             {
[10:22:46.740]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:46.740]                   0L) {
[10:22:46.740]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:46.740]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:46.740]                   base::options(opts)
[10:22:46.740]                 }
[10:22:46.740]                 {
[10:22:46.740]                   {
[10:22:46.740]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:46.740]                     NULL
[10:22:46.740]                   }
[10:22:46.740]                   options(future.plan = NULL)
[10:22:46.740]                   if (is.na(NA_character_)) 
[10:22:46.740]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:46.740]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:46.740]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:46.740]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:46.740]                     envir = parent.frame()) 
[10:22:46.740]                   {
[10:22:46.740]                     if (is.function(workers)) 
[10:22:46.740]                       workers <- workers()
[10:22:46.740]                     workers <- structure(as.integer(workers), 
[10:22:46.740]                       class = class(workers))
[10:22:46.740]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:46.740]                       workers >= 1)
[10:22:46.740]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:46.740]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:46.740]                     }
[10:22:46.740]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:46.740]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:46.740]                       envir = envir)
[10:22:46.740]                     if (!future$lazy) 
[10:22:46.740]                       future <- run(future)
[10:22:46.740]                     invisible(future)
[10:22:46.740]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:46.740]                 }
[10:22:46.740]             }
[10:22:46.740]         }
[10:22:46.740]     })
[10:22:46.740]     if (TRUE) {
[10:22:46.740]         base::sink(type = "output", split = FALSE)
[10:22:46.740]         if (TRUE) {
[10:22:46.740]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:46.740]         }
[10:22:46.740]         else {
[10:22:46.740]             ...future.result["stdout"] <- base::list(NULL)
[10:22:46.740]         }
[10:22:46.740]         base::close(...future.stdout)
[10:22:46.740]         ...future.stdout <- NULL
[10:22:46.740]     }
[10:22:46.740]     ...future.result$conditions <- ...future.conditions
[10:22:46.740]     ...future.result$finished <- base::Sys.time()
[10:22:46.740]     ...future.result
[10:22:46.740] }
[10:22:46.743] Exporting 5 global objects (346.05 KiB) to cluster node #1 ...
[10:22:46.743] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:22:46.744] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:22:46.744] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ...
[10:22:46.786] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ... DONE
[10:22:46.786] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[10:22:46.786] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[10:22:46.787] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:22:46.787] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:22:46.787] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[10:22:46.787] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[10:22:46.787] Exporting 5 global objects (346.05 KiB) to cluster node #1 ... DONE
[10:22:46.788] MultisessionFuture started
[10:22:46.788] - Launch lazy future ... done
[10:22:46.788] run() for ‘MultisessionFuture’ ... done
[10:22:46.788] Created future:
[10:22:46.788] MultisessionFuture:
[10:22:46.788] Label: ‘future_apply-1’
[10:22:46.788] Expression:
[10:22:46.788] {
[10:22:46.788]     do.call(function(...) {
[10:22:46.788]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:46.788]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:46.788]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:46.788]             on.exit(options(oopts), add = TRUE)
[10:22:46.788]         }
[10:22:46.788]         {
[10:22:46.788]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:46.788]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:46.788]                 ...future.FUN(...future.X_jj, ...)
[10:22:46.788]             })
[10:22:46.788]         }
[10:22:46.788]     }, args = future.call.arguments)
[10:22:46.788] }
[10:22:46.788] Lazy evaluation: FALSE
[10:22:46.788] Asynchronous evaluation: TRUE
[10:22:46.788] Local evaluation: TRUE
[10:22:46.788] Environment: R_GlobalEnv
[10:22:46.788] Capture standard output: TRUE
[10:22:46.788] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:46.788] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:46.788] Packages: <none>
[10:22:46.788] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:46.788] Resolved: FALSE
[10:22:46.788] Value: <not collected>
[10:22:46.788] Conditions captured: <none>
[10:22:46.788] Early signaling: FALSE
[10:22:46.788] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:46.788] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:46.800] Chunk #1 of 2 ... DONE
[10:22:46.800] Chunk #2 of 2 ...
[10:22:46.800]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:46.800]  - seeds: <none>
[10:22:46.801]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:46.801] getGlobalsAndPackages() ...
[10:22:46.801] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:46.801] Resolving globals: FALSE
[10:22:46.801] Tweak future expression to call with '...' arguments ...
[10:22:46.801] {
[10:22:46.801]     do.call(function(...) {
[10:22:46.801]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:46.801]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:46.801]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:46.801]             on.exit(options(oopts), add = TRUE)
[10:22:46.801]         }
[10:22:46.801]         {
[10:22:46.801]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:46.801]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:46.801]                 ...future.FUN(...future.X_jj, ...)
[10:22:46.801]             })
[10:22:46.801]         }
[10:22:46.801]     }, args = future.call.arguments)
[10:22:46.801] }
[10:22:46.801] Tweak future expression to call with '...' arguments ... DONE
[10:22:46.802] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:46.802] 
[10:22:46.802] getGlobalsAndPackages() ... DONE
[10:22:46.802] run() for ‘Future’ ...
[10:22:46.802] - state: ‘created’
[10:22:46.802] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:46.816] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:46.816] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:46.817]   - Field: ‘node’
[10:22:46.817]   - Field: ‘label’
[10:22:46.817]   - Field: ‘local’
[10:22:46.817]   - Field: ‘owner’
[10:22:46.817]   - Field: ‘envir’
[10:22:46.817]   - Field: ‘workers’
[10:22:46.817]   - Field: ‘packages’
[10:22:46.817]   - Field: ‘gc’
[10:22:46.817]   - Field: ‘conditions’
[10:22:46.817]   - Field: ‘persistent’
[10:22:46.817]   - Field: ‘expr’
[10:22:46.818]   - Field: ‘uuid’
[10:22:46.818]   - Field: ‘seed’
[10:22:46.818]   - Field: ‘version’
[10:22:46.818]   - Field: ‘result’
[10:22:46.818]   - Field: ‘asynchronous’
[10:22:46.818]   - Field: ‘calls’
[10:22:46.818]   - Field: ‘globals’
[10:22:46.818]   - Field: ‘stdout’
[10:22:46.818]   - Field: ‘earlySignal’
[10:22:46.818]   - Field: ‘lazy’
[10:22:46.818]   - Field: ‘state’
[10:22:46.819] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:46.819] - Launch lazy future ...
[10:22:46.819] Packages needed by the future expression (n = 0): <none>
[10:22:46.819] Packages needed by future strategies (n = 0): <none>
[10:22:46.819] {
[10:22:46.819]     {
[10:22:46.819]         {
[10:22:46.819]             ...future.startTime <- base::Sys.time()
[10:22:46.819]             {
[10:22:46.819]                 {
[10:22:46.819]                   {
[10:22:46.819]                     {
[10:22:46.819]                       base::local({
[10:22:46.819]                         has_future <- base::requireNamespace("future", 
[10:22:46.819]                           quietly = TRUE)
[10:22:46.819]                         if (has_future) {
[10:22:46.819]                           ns <- base::getNamespace("future")
[10:22:46.819]                           version <- ns[[".package"]][["version"]]
[10:22:46.819]                           if (is.null(version)) 
[10:22:46.819]                             version <- utils::packageVersion("future")
[10:22:46.819]                         }
[10:22:46.819]                         else {
[10:22:46.819]                           version <- NULL
[10:22:46.819]                         }
[10:22:46.819]                         if (!has_future || version < "1.8.0") {
[10:22:46.819]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:46.819]                             "", base::R.version$version.string), 
[10:22:46.819]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:46.819]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:46.819]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:46.819]                               "release", "version")], collapse = " "), 
[10:22:46.819]                             hostname = base::Sys.info()[["nodename"]])
[10:22:46.819]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:46.819]                             info)
[10:22:46.819]                           info <- base::paste(info, collapse = "; ")
[10:22:46.819]                           if (!has_future) {
[10:22:46.819]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:46.819]                               info)
[10:22:46.819]                           }
[10:22:46.819]                           else {
[10:22:46.819]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:46.819]                               info, version)
[10:22:46.819]                           }
[10:22:46.819]                           base::stop(msg)
[10:22:46.819]                         }
[10:22:46.819]                       })
[10:22:46.819]                     }
[10:22:46.819]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:46.819]                     base::options(mc.cores = 1L)
[10:22:46.819]                   }
[10:22:46.819]                   options(future.plan = NULL)
[10:22:46.819]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:46.819]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:46.819]                 }
[10:22:46.819]                 ...future.workdir <- getwd()
[10:22:46.819]             }
[10:22:46.819]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:46.819]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:46.819]         }
[10:22:46.819]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:46.819]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:46.819]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:46.819]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:46.819]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:46.819]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:46.819]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:46.819]             base::names(...future.oldOptions))
[10:22:46.819]     }
[10:22:46.819]     if (FALSE) {
[10:22:46.819]     }
[10:22:46.819]     else {
[10:22:46.819]         if (TRUE) {
[10:22:46.819]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:46.819]                 open = "w")
[10:22:46.819]         }
[10:22:46.819]         else {
[10:22:46.819]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:46.819]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:46.819]         }
[10:22:46.819]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:46.819]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:46.819]             base::sink(type = "output", split = FALSE)
[10:22:46.819]             base::close(...future.stdout)
[10:22:46.819]         }, add = TRUE)
[10:22:46.819]     }
[10:22:46.819]     ...future.frame <- base::sys.nframe()
[10:22:46.819]     ...future.conditions <- base::list()
[10:22:46.819]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:46.819]     if (FALSE) {
[10:22:46.819]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:46.819]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:46.819]     }
[10:22:46.819]     ...future.result <- base::tryCatch({
[10:22:46.819]         base::withCallingHandlers({
[10:22:46.819]             ...future.value <- base::withVisible(base::local({
[10:22:46.819]                 ...future.makeSendCondition <- base::local({
[10:22:46.819]                   sendCondition <- NULL
[10:22:46.819]                   function(frame = 1L) {
[10:22:46.819]                     if (is.function(sendCondition)) 
[10:22:46.819]                       return(sendCondition)
[10:22:46.819]                     ns <- getNamespace("parallel")
[10:22:46.819]                     if (exists("sendData", mode = "function", 
[10:22:46.819]                       envir = ns)) {
[10:22:46.819]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:46.819]                         envir = ns)
[10:22:46.819]                       envir <- sys.frame(frame)
[10:22:46.819]                       master <- NULL
[10:22:46.819]                       while (!identical(envir, .GlobalEnv) && 
[10:22:46.819]                         !identical(envir, emptyenv())) {
[10:22:46.819]                         if (exists("master", mode = "list", envir = envir, 
[10:22:46.819]                           inherits = FALSE)) {
[10:22:46.819]                           master <- get("master", mode = "list", 
[10:22:46.819]                             envir = envir, inherits = FALSE)
[10:22:46.819]                           if (inherits(master, c("SOCKnode", 
[10:22:46.819]                             "SOCK0node"))) {
[10:22:46.819]                             sendCondition <<- function(cond) {
[10:22:46.819]                               data <- list(type = "VALUE", value = cond, 
[10:22:46.819]                                 success = TRUE)
[10:22:46.819]                               parallel_sendData(master, data)
[10:22:46.819]                             }
[10:22:46.819]                             return(sendCondition)
[10:22:46.819]                           }
[10:22:46.819]                         }
[10:22:46.819]                         frame <- frame + 1L
[10:22:46.819]                         envir <- sys.frame(frame)
[10:22:46.819]                       }
[10:22:46.819]                     }
[10:22:46.819]                     sendCondition <<- function(cond) NULL
[10:22:46.819]                   }
[10:22:46.819]                 })
[10:22:46.819]                 withCallingHandlers({
[10:22:46.819]                   {
[10:22:46.819]                     do.call(function(...) {
[10:22:46.819]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:46.819]                       if (!identical(...future.globals.maxSize.org, 
[10:22:46.819]                         ...future.globals.maxSize)) {
[10:22:46.819]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:46.819]                         on.exit(options(oopts), add = TRUE)
[10:22:46.819]                       }
[10:22:46.819]                       {
[10:22:46.819]                         lapply(seq_along(...future.elements_ii), 
[10:22:46.819]                           FUN = function(jj) {
[10:22:46.819]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:46.819]                             ...future.FUN(...future.X_jj, ...)
[10:22:46.819]                           })
[10:22:46.819]                       }
[10:22:46.819]                     }, args = future.call.arguments)
[10:22:46.819]                   }
[10:22:46.819]                 }, immediateCondition = function(cond) {
[10:22:46.819]                   sendCondition <- ...future.makeSendCondition()
[10:22:46.819]                   sendCondition(cond)
[10:22:46.819]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:46.819]                   {
[10:22:46.819]                     inherits <- base::inherits
[10:22:46.819]                     invokeRestart <- base::invokeRestart
[10:22:46.819]                     is.null <- base::is.null
[10:22:46.819]                     muffled <- FALSE
[10:22:46.819]                     if (inherits(cond, "message")) {
[10:22:46.819]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:46.819]                       if (muffled) 
[10:22:46.819]                         invokeRestart("muffleMessage")
[10:22:46.819]                     }
[10:22:46.819]                     else if (inherits(cond, "warning")) {
[10:22:46.819]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:46.819]                       if (muffled) 
[10:22:46.819]                         invokeRestart("muffleWarning")
[10:22:46.819]                     }
[10:22:46.819]                     else if (inherits(cond, "condition")) {
[10:22:46.819]                       if (!is.null(pattern)) {
[10:22:46.819]                         computeRestarts <- base::computeRestarts
[10:22:46.819]                         grepl <- base::grepl
[10:22:46.819]                         restarts <- computeRestarts(cond)
[10:22:46.819]                         for (restart in restarts) {
[10:22:46.819]                           name <- restart$name
[10:22:46.819]                           if (is.null(name)) 
[10:22:46.819]                             next
[10:22:46.819]                           if (!grepl(pattern, name)) 
[10:22:46.819]                             next
[10:22:46.819]                           invokeRestart(restart)
[10:22:46.819]                           muffled <- TRUE
[10:22:46.819]                           break
[10:22:46.819]                         }
[10:22:46.819]                       }
[10:22:46.819]                     }
[10:22:46.819]                     invisible(muffled)
[10:22:46.819]                   }
[10:22:46.819]                   muffleCondition(cond)
[10:22:46.819]                 })
[10:22:46.819]             }))
[10:22:46.819]             future::FutureResult(value = ...future.value$value, 
[10:22:46.819]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:46.819]                   ...future.rng), globalenv = if (FALSE) 
[10:22:46.819]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:46.819]                     ...future.globalenv.names))
[10:22:46.819]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:46.819]         }, condition = base::local({
[10:22:46.819]             c <- base::c
[10:22:46.819]             inherits <- base::inherits
[10:22:46.819]             invokeRestart <- base::invokeRestart
[10:22:46.819]             length <- base::length
[10:22:46.819]             list <- base::list
[10:22:46.819]             seq.int <- base::seq.int
[10:22:46.819]             signalCondition <- base::signalCondition
[10:22:46.819]             sys.calls <- base::sys.calls
[10:22:46.819]             `[[` <- base::`[[`
[10:22:46.819]             `+` <- base::`+`
[10:22:46.819]             `<<-` <- base::`<<-`
[10:22:46.819]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:46.819]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:46.819]                   3L)]
[10:22:46.819]             }
[10:22:46.819]             function(cond) {
[10:22:46.819]                 is_error <- inherits(cond, "error")
[10:22:46.819]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:46.819]                   NULL)
[10:22:46.819]                 if (is_error) {
[10:22:46.819]                   sessionInformation <- function() {
[10:22:46.819]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:46.819]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:46.819]                       search = base::search(), system = base::Sys.info())
[10:22:46.819]                   }
[10:22:46.819]                   ...future.conditions[[length(...future.conditions) + 
[10:22:46.819]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:46.819]                     cond$call), session = sessionInformation(), 
[10:22:46.819]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:46.819]                   signalCondition(cond)
[10:22:46.819]                 }
[10:22:46.819]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:46.819]                 "immediateCondition"))) {
[10:22:46.819]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:46.819]                   ...future.conditions[[length(...future.conditions) + 
[10:22:46.819]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:46.819]                   if (TRUE && !signal) {
[10:22:46.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:46.819]                     {
[10:22:46.819]                       inherits <- base::inherits
[10:22:46.819]                       invokeRestart <- base::invokeRestart
[10:22:46.819]                       is.null <- base::is.null
[10:22:46.819]                       muffled <- FALSE
[10:22:46.819]                       if (inherits(cond, "message")) {
[10:22:46.819]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:46.819]                         if (muffled) 
[10:22:46.819]                           invokeRestart("muffleMessage")
[10:22:46.819]                       }
[10:22:46.819]                       else if (inherits(cond, "warning")) {
[10:22:46.819]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:46.819]                         if (muffled) 
[10:22:46.819]                           invokeRestart("muffleWarning")
[10:22:46.819]                       }
[10:22:46.819]                       else if (inherits(cond, "condition")) {
[10:22:46.819]                         if (!is.null(pattern)) {
[10:22:46.819]                           computeRestarts <- base::computeRestarts
[10:22:46.819]                           grepl <- base::grepl
[10:22:46.819]                           restarts <- computeRestarts(cond)
[10:22:46.819]                           for (restart in restarts) {
[10:22:46.819]                             name <- restart$name
[10:22:46.819]                             if (is.null(name)) 
[10:22:46.819]                               next
[10:22:46.819]                             if (!grepl(pattern, name)) 
[10:22:46.819]                               next
[10:22:46.819]                             invokeRestart(restart)
[10:22:46.819]                             muffled <- TRUE
[10:22:46.819]                             break
[10:22:46.819]                           }
[10:22:46.819]                         }
[10:22:46.819]                       }
[10:22:46.819]                       invisible(muffled)
[10:22:46.819]                     }
[10:22:46.819]                     muffleCondition(cond, pattern = "^muffle")
[10:22:46.819]                   }
[10:22:46.819]                 }
[10:22:46.819]                 else {
[10:22:46.819]                   if (TRUE) {
[10:22:46.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:46.819]                     {
[10:22:46.819]                       inherits <- base::inherits
[10:22:46.819]                       invokeRestart <- base::invokeRestart
[10:22:46.819]                       is.null <- base::is.null
[10:22:46.819]                       muffled <- FALSE
[10:22:46.819]                       if (inherits(cond, "message")) {
[10:22:46.819]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:46.819]                         if (muffled) 
[10:22:46.819]                           invokeRestart("muffleMessage")
[10:22:46.819]                       }
[10:22:46.819]                       else if (inherits(cond, "warning")) {
[10:22:46.819]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:46.819]                         if (muffled) 
[10:22:46.819]                           invokeRestart("muffleWarning")
[10:22:46.819]                       }
[10:22:46.819]                       else if (inherits(cond, "condition")) {
[10:22:46.819]                         if (!is.null(pattern)) {
[10:22:46.819]                           computeRestarts <- base::computeRestarts
[10:22:46.819]                           grepl <- base::grepl
[10:22:46.819]                           restarts <- computeRestarts(cond)
[10:22:46.819]                           for (restart in restarts) {
[10:22:46.819]                             name <- restart$name
[10:22:46.819]                             if (is.null(name)) 
[10:22:46.819]                               next
[10:22:46.819]                             if (!grepl(pattern, name)) 
[10:22:46.819]                               next
[10:22:46.819]                             invokeRestart(restart)
[10:22:46.819]                             muffled <- TRUE
[10:22:46.819]                             break
[10:22:46.819]                           }
[10:22:46.819]                         }
[10:22:46.819]                       }
[10:22:46.819]                       invisible(muffled)
[10:22:46.819]                     }
[10:22:46.819]                     muffleCondition(cond, pattern = "^muffle")
[10:22:46.819]                   }
[10:22:46.819]                 }
[10:22:46.819]             }
[10:22:46.819]         }))
[10:22:46.819]     }, error = function(ex) {
[10:22:46.819]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:46.819]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:46.819]                 ...future.rng), started = ...future.startTime, 
[10:22:46.819]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:46.819]             version = "1.8"), class = "FutureResult")
[10:22:46.819]     }, finally = {
[10:22:46.819]         if (!identical(...future.workdir, getwd())) 
[10:22:46.819]             setwd(...future.workdir)
[10:22:46.819]         {
[10:22:46.819]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:46.819]                 ...future.oldOptions$nwarnings <- NULL
[10:22:46.819]             }
[10:22:46.819]             base::options(...future.oldOptions)
[10:22:46.819]             if (.Platform$OS.type == "windows") {
[10:22:46.819]                 old_names <- names(...future.oldEnvVars)
[10:22:46.819]                 envs <- base::Sys.getenv()
[10:22:46.819]                 names <- names(envs)
[10:22:46.819]                 common <- intersect(names, old_names)
[10:22:46.819]                 added <- setdiff(names, old_names)
[10:22:46.819]                 removed <- setdiff(old_names, names)
[10:22:46.819]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:46.819]                   envs[common]]
[10:22:46.819]                 NAMES <- toupper(changed)
[10:22:46.819]                 args <- list()
[10:22:46.819]                 for (kk in seq_along(NAMES)) {
[10:22:46.819]                   name <- changed[[kk]]
[10:22:46.819]                   NAME <- NAMES[[kk]]
[10:22:46.819]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:46.819]                     next
[10:22:46.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:46.819]                 }
[10:22:46.819]                 NAMES <- toupper(added)
[10:22:46.819]                 for (kk in seq_along(NAMES)) {
[10:22:46.819]                   name <- added[[kk]]
[10:22:46.819]                   NAME <- NAMES[[kk]]
[10:22:46.819]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:46.819]                     next
[10:22:46.819]                   args[[name]] <- ""
[10:22:46.819]                 }
[10:22:46.819]                 NAMES <- toupper(removed)
[10:22:46.819]                 for (kk in seq_along(NAMES)) {
[10:22:46.819]                   name <- removed[[kk]]
[10:22:46.819]                   NAME <- NAMES[[kk]]
[10:22:46.819]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:46.819]                     next
[10:22:46.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:46.819]                 }
[10:22:46.819]                 if (length(args) > 0) 
[10:22:46.819]                   base::do.call(base::Sys.setenv, args = args)
[10:22:46.819]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:46.819]             }
[10:22:46.819]             else {
[10:22:46.819]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:46.819]             }
[10:22:46.819]             {
[10:22:46.819]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:46.819]                   0L) {
[10:22:46.819]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:46.819]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:46.819]                   base::options(opts)
[10:22:46.819]                 }
[10:22:46.819]                 {
[10:22:46.819]                   {
[10:22:46.819]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:46.819]                     NULL
[10:22:46.819]                   }
[10:22:46.819]                   options(future.plan = NULL)
[10:22:46.819]                   if (is.na(NA_character_)) 
[10:22:46.819]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:46.819]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:46.819]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:46.819]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:46.819]                     envir = parent.frame()) 
[10:22:46.819]                   {
[10:22:46.819]                     if (is.function(workers)) 
[10:22:46.819]                       workers <- workers()
[10:22:46.819]                     workers <- structure(as.integer(workers), 
[10:22:46.819]                       class = class(workers))
[10:22:46.819]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:46.819]                       workers >= 1)
[10:22:46.819]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:46.819]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:46.819]                     }
[10:22:46.819]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:46.819]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:46.819]                       envir = envir)
[10:22:46.819]                     if (!future$lazy) 
[10:22:46.819]                       future <- run(future)
[10:22:46.819]                     invisible(future)
[10:22:46.819]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:46.819]                 }
[10:22:46.819]             }
[10:22:46.819]         }
[10:22:46.819]     })
[10:22:46.819]     if (TRUE) {
[10:22:46.819]         base::sink(type = "output", split = FALSE)
[10:22:46.819]         if (TRUE) {
[10:22:46.819]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:46.819]         }
[10:22:46.819]         else {
[10:22:46.819]             ...future.result["stdout"] <- base::list(NULL)
[10:22:46.819]         }
[10:22:46.819]         base::close(...future.stdout)
[10:22:46.819]         ...future.stdout <- NULL
[10:22:46.819]     }
[10:22:46.819]     ...future.result$conditions <- ...future.conditions
[10:22:46.819]     ...future.result$finished <- base::Sys.time()
[10:22:46.819]     ...future.result
[10:22:46.819] }
[10:22:46.823] Exporting 5 global objects (346.05 KiB) to cluster node #2 ...
[10:22:46.823] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:22:46.823] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:22:46.823] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ...
[10:22:46.870] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ... DONE
[10:22:46.870] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[10:22:46.871] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[10:22:46.871] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:22:46.871] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:22:46.871] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[10:22:46.872] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[10:22:46.872] Exporting 5 global objects (346.05 KiB) to cluster node #2 ... DONE
[10:22:46.872] MultisessionFuture started
[10:22:46.873] - Launch lazy future ... done
[10:22:46.873] run() for ‘MultisessionFuture’ ... done
[10:22:46.873] Created future:
[10:22:46.873] MultisessionFuture:
[10:22:46.873] Label: ‘future_apply-2’
[10:22:46.873] Expression:
[10:22:46.873] {
[10:22:46.873]     do.call(function(...) {
[10:22:46.873]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:46.873]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:46.873]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:46.873]             on.exit(options(oopts), add = TRUE)
[10:22:46.873]         }
[10:22:46.873]         {
[10:22:46.873]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:46.873]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:46.873]                 ...future.FUN(...future.X_jj, ...)
[10:22:46.873]             })
[10:22:46.873]         }
[10:22:46.873]     }, args = future.call.arguments)
[10:22:46.873] }
[10:22:46.873] Lazy evaluation: FALSE
[10:22:46.873] Asynchronous evaluation: TRUE
[10:22:46.873] Local evaluation: TRUE
[10:22:46.873] Environment: R_GlobalEnv
[10:22:46.873] Capture standard output: TRUE
[10:22:46.873] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:46.873] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:46.873] Packages: <none>
[10:22:46.873] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:46.873] Resolved: FALSE
[10:22:46.873] Value: <not collected>
[10:22:46.873] Conditions captured: <none>
[10:22:46.873] Early signaling: FALSE
[10:22:46.873] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:46.873] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:46.885] Chunk #2 of 2 ... DONE
[10:22:46.885] Launching 2 futures (chunks) ... DONE
[10:22:46.885] Resolving 2 futures (chunks) ...
[10:22:46.885] resolve() on list ...
[10:22:46.885]  recursive: 0
[10:22:46.885]  length: 2
[10:22:46.885] 
[10:22:46.886] receiveMessageFromWorker() for ClusterFuture ...
[10:22:46.886] - Validating connection of MultisessionFuture
[10:22:46.886] - received message: FutureResult
[10:22:46.886] - Received FutureResult
[10:22:46.886] - Erased future from FutureRegistry
[10:22:46.887] result() for ClusterFuture ...
[10:22:46.887] - result already collected: FutureResult
[10:22:46.887] result() for ClusterFuture ... done
[10:22:46.887] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:46.887] Future #1
[10:22:46.887] result() for ClusterFuture ...
[10:22:46.887] - result already collected: FutureResult
[10:22:46.887] result() for ClusterFuture ... done
[10:22:46.887] result() for ClusterFuture ...
[10:22:46.887] - result already collected: FutureResult
[10:22:46.887] result() for ClusterFuture ... done
[10:22:46.888] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:22:46.888] - nx: 2
[10:22:46.888] - relay: TRUE
[10:22:46.888] - stdout: TRUE
[10:22:46.888] - signal: TRUE
[10:22:46.888] - resignal: FALSE
[10:22:46.888] - force: TRUE
[10:22:46.888] - relayed: [n=2] FALSE, FALSE
[10:22:46.888] - queued futures: [n=2] FALSE, FALSE
[10:22:46.888]  - until=1
[10:22:46.888]  - relaying element #1
[10:22:46.889] result() for ClusterFuture ...
[10:22:46.889] - result already collected: FutureResult
[10:22:46.889] result() for ClusterFuture ... done
[10:22:46.889] result() for ClusterFuture ...
[10:22:46.889] - result already collected: FutureResult
[10:22:46.889] result() for ClusterFuture ... done
[10:22:46.889] result() for ClusterFuture ...
[10:22:46.889] - result already collected: FutureResult
[10:22:46.891] result() for ClusterFuture ... done
[10:22:46.892] result() for ClusterFuture ...
[10:22:46.892] - result already collected: FutureResult
[10:22:46.892] result() for ClusterFuture ... done
[10:22:46.892] - relayed: [n=2] TRUE, FALSE
[10:22:46.892] - queued futures: [n=2] TRUE, FALSE
[10:22:46.892] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:22:46.892]  length: 1 (resolved future 1)
[10:22:46.918] receiveMessageFromWorker() for ClusterFuture ...
[10:22:46.918] - Validating connection of MultisessionFuture
[10:22:46.919] - received message: FutureResult
[10:22:46.919] - Received FutureResult
[10:22:46.919] - Erased future from FutureRegistry
[10:22:46.919] result() for ClusterFuture ...
[10:22:46.919] - result already collected: FutureResult
[10:22:46.919] result() for ClusterFuture ... done
[10:22:46.919] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:46.919] Future #2
[10:22:46.919] result() for ClusterFuture ...
[10:22:46.920] - result already collected: FutureResult
[10:22:46.920] result() for ClusterFuture ... done
[10:22:46.920] result() for ClusterFuture ...
[10:22:46.920] - result already collected: FutureResult
[10:22:46.920] result() for ClusterFuture ... done
[10:22:46.920] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:22:46.920] - nx: 2
[10:22:46.920] - relay: TRUE
[10:22:46.920] - stdout: TRUE
[10:22:46.920] - signal: TRUE
[10:22:46.920] - resignal: FALSE
[10:22:46.920] - force: TRUE
[10:22:46.921] - relayed: [n=2] TRUE, FALSE
[10:22:46.921] - queued futures: [n=2] TRUE, FALSE
[10:22:46.921]  - until=2
[10:22:46.921]  - relaying element #2
[10:22:46.921] result() for ClusterFuture ...
[10:22:46.921] - result already collected: FutureResult
[10:22:46.921] result() for ClusterFuture ... done
[10:22:46.921] result() for ClusterFuture ...
[10:22:46.921] - result already collected: FutureResult
[10:22:46.921] result() for ClusterFuture ... done
[10:22:46.921] result() for ClusterFuture ...
[10:22:46.922] - result already collected: FutureResult
[10:22:46.922] result() for ClusterFuture ... done
[10:22:46.922] result() for ClusterFuture ...
[10:22:46.922] - result already collected: FutureResult
[10:22:46.922] result() for ClusterFuture ... done
[10:22:46.922] - relayed: [n=2] TRUE, TRUE
[10:22:46.922] - queued futures: [n=2] TRUE, TRUE
[10:22:46.922] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:22:46.922]  length: 0 (resolved future 2)
[10:22:46.922] Relaying remaining futures
[10:22:46.922] signalConditionsASAP(NULL, pos=0) ...
[10:22:46.923] - nx: 2
[10:22:46.923] - relay: TRUE
[10:22:46.923] - stdout: TRUE
[10:22:46.923] - signal: TRUE
[10:22:46.923] - resignal: FALSE
[10:22:46.923] - force: TRUE
[10:22:46.923] - relayed: [n=2] TRUE, TRUE
[10:22:46.923] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:22:46.923] - relayed: [n=2] TRUE, TRUE
[10:22:46.923] - queued futures: [n=2] TRUE, TRUE
[10:22:46.923] signalConditionsASAP(NULL, pos=0) ... done
[10:22:46.924] resolve() on list ... DONE
[10:22:46.924] result() for ClusterFuture ...
[10:22:46.924] - result already collected: FutureResult
[10:22:46.924] result() for ClusterFuture ... done
[10:22:46.924] result() for ClusterFuture ...
[10:22:46.924] - result already collected: FutureResult
[10:22:46.924] result() for ClusterFuture ... done
[10:22:46.924] result() for ClusterFuture ...
[10:22:46.924] - result already collected: FutureResult
[10:22:46.924] result() for ClusterFuture ... done
[10:22:46.924] result() for ClusterFuture ...
[10:22:46.924] - result already collected: FutureResult
[10:22:46.925] result() for ClusterFuture ... done
[10:22:46.925]  - Number of value chunks collected: 2
[10:22:46.925] Resolving 2 futures (chunks) ... DONE
[10:22:46.925] Reducing values from 2 chunks ...
[10:22:46.925]  - Number of values collected after concatenation: 2
[10:22:46.925]  - Number of values expected: 2
[10:22:46.925] Reducing values from 2 chunks ... DONE
[10:22:46.925] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[10:22:46.926] getGlobalsAndPackagesXApply() ...
[10:22:46.926]  - future.globals: TRUE
[10:22:46.926] getGlobalsAndPackages() ...
[10:22:46.926] Searching for globals...
[10:22:46.927] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:22:46.927] Searching for globals ... DONE
[10:22:46.928] Resolving globals: FALSE
[10:22:46.928] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[10:22:46.928] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[10:22:46.928] - globals: [1] ‘FUN’
[10:22:46.929] - packages: [1] ‘stats’
[10:22:46.929] getGlobalsAndPackages() ... DONE
[10:22:46.929]  - globals found/used: [n=1] ‘FUN’
[10:22:46.929]  - needed namespaces: [n=1] ‘stats’
[10:22:46.929] Finding globals ... DONE
[10:22:46.929]  - use_args: TRUE
[10:22:46.929]  - Getting '...' globals ...
[10:22:46.929] resolve() on list ...
[10:22:46.930]  recursive: 0
[10:22:46.930]  length: 1
[10:22:46.930]  elements: ‘...’
[10:22:46.930]  length: 0 (resolved future 1)
[10:22:46.930] resolve() on list ... DONE
[10:22:46.930]    - '...' content: [n=0] 
[10:22:46.930] List of 1
[10:22:46.930]  $ ...: list()
[10:22:46.930]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:46.930]  - attr(*, "where")=List of 1
[10:22:46.930]   ..$ ...:<environment: 0x55ca4d194378> 
[10:22:46.930]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:46.930]  - attr(*, "resolved")= logi TRUE
[10:22:46.930]  - attr(*, "total_size")= num NA
[10:22:46.933]  - Getting '...' globals ... DONE
[10:22:46.933] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:46.933] List of 2
[10:22:46.933]  $ ...future.FUN:function (x, ...)  
[10:22:46.933]  $ ...          : list()
[10:22:46.933]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:46.933]  - attr(*, "where")=List of 2
[10:22:46.933]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:46.933]   ..$ ...          :<environment: 0x55ca4d194378> 
[10:22:46.933]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:46.933]  - attr(*, "resolved")= logi FALSE
[10:22:46.933]  - attr(*, "total_size")= num 1248
[10:22:46.936] Packages to be attached in all futures: [n=1] ‘stats’
[10:22:46.936] getGlobalsAndPackagesXApply() ... DONE
[10:22:46.939] future_lapply() ...
[10:22:46.943] Number of chunks: 2
[10:22:46.943] getGlobalsAndPackagesXApply() ...
[10:22:46.943]  - future.globals: <name-value list> with names ‘list()’
[10:22:46.944]  - use_args: TRUE
[10:22:46.944] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:22:46.944] List of 2
[10:22:46.944]  $ ...          : list()
[10:22:46.944]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:46.944]  $ ...future.FUN:function (x, ...)  
[10:22:46.944]  - attr(*, "where")=List of 2
[10:22:46.944]   ..$ ...          :<environment: 0x55ca4d194378> 
[10:22:46.944]   ..$ ...future.FUN:<environment: namespace:stats> 
[10:22:46.944]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:46.944]  - attr(*, "resolved")= logi FALSE
[10:22:46.944]  - attr(*, "total_size")= num NA
[10:22:46.947] Packages to be attached in all futures: [n=1] ‘stats’
[10:22:46.947] getGlobalsAndPackagesXApply() ... DONE
[10:22:46.947] Number of futures (= number of chunks): 2
[10:22:46.947] Launching 2 futures (chunks) ...
[10:22:46.947] Chunk #1 of 2 ...
[10:22:46.947]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:46.947]  - seeds: <none>
[10:22:46.948]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:46.948] getGlobalsAndPackages() ...
[10:22:46.948] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:46.948] Resolving globals: FALSE
[10:22:46.948] Tweak future expression to call with '...' arguments ...
[10:22:46.948] {
[10:22:46.948]     do.call(function(...) {
[10:22:46.948]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:46.948]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:46.948]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:46.948]             on.exit(options(oopts), add = TRUE)
[10:22:46.948]         }
[10:22:46.948]         {
[10:22:46.948]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:46.948]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:46.948]                 ...future.FUN(...future.X_jj, ...)
[10:22:46.948]             })
[10:22:46.948]         }
[10:22:46.948]     }, args = future.call.arguments)
[10:22:46.948] }
[10:22:46.948] Tweak future expression to call with '...' arguments ... DONE
[10:22:46.949] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:46.949] - packages: [1] ‘stats’
[10:22:46.949] getGlobalsAndPackages() ... DONE
[10:22:46.949] run() for ‘Future’ ...
[10:22:46.949] - state: ‘created’
[10:22:46.950] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:46.963] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:46.963] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:46.963]   - Field: ‘node’
[10:22:46.963]   - Field: ‘label’
[10:22:46.963]   - Field: ‘local’
[10:22:46.964]   - Field: ‘owner’
[10:22:46.964]   - Field: ‘envir’
[10:22:46.964]   - Field: ‘workers’
[10:22:46.964]   - Field: ‘packages’
[10:22:46.964]   - Field: ‘gc’
[10:22:46.964]   - Field: ‘conditions’
[10:22:46.964]   - Field: ‘persistent’
[10:22:46.964]   - Field: ‘expr’
[10:22:46.964]   - Field: ‘uuid’
[10:22:46.964]   - Field: ‘seed’
[10:22:46.965]   - Field: ‘version’
[10:22:46.965]   - Field: ‘result’
[10:22:46.965]   - Field: ‘asynchronous’
[10:22:46.965]   - Field: ‘calls’
[10:22:46.965]   - Field: ‘globals’
[10:22:46.965]   - Field: ‘stdout’
[10:22:46.965]   - Field: ‘earlySignal’
[10:22:46.965]   - Field: ‘lazy’
[10:22:46.965]   - Field: ‘state’
[10:22:46.965] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:46.966] - Launch lazy future ...
[10:22:46.966] Packages needed by the future expression (n = 1): ‘stats’
[10:22:46.966] Packages needed by future strategies (n = 0): <none>
[10:22:46.966] {
[10:22:46.966]     {
[10:22:46.966]         {
[10:22:46.966]             ...future.startTime <- base::Sys.time()
[10:22:46.966]             {
[10:22:46.966]                 {
[10:22:46.966]                   {
[10:22:46.966]                     {
[10:22:46.966]                       {
[10:22:46.966]                         base::local({
[10:22:46.966]                           has_future <- base::requireNamespace("future", 
[10:22:46.966]                             quietly = TRUE)
[10:22:46.966]                           if (has_future) {
[10:22:46.966]                             ns <- base::getNamespace("future")
[10:22:46.966]                             version <- ns[[".package"]][["version"]]
[10:22:46.966]                             if (is.null(version)) 
[10:22:46.966]                               version <- utils::packageVersion("future")
[10:22:46.966]                           }
[10:22:46.966]                           else {
[10:22:46.966]                             version <- NULL
[10:22:46.966]                           }
[10:22:46.966]                           if (!has_future || version < "1.8.0") {
[10:22:46.966]                             info <- base::c(r_version = base::gsub("R version ", 
[10:22:46.966]                               "", base::R.version$version.string), 
[10:22:46.966]                               platform = base::sprintf("%s (%s-bit)", 
[10:22:46.966]                                 base::R.version$platform, 8 * 
[10:22:46.966]                                   base::.Machine$sizeof.pointer), 
[10:22:46.966]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:46.966]                                 "release", "version")], collapse = " "), 
[10:22:46.966]                               hostname = base::Sys.info()[["nodename"]])
[10:22:46.966]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:22:46.966]                               info)
[10:22:46.966]                             info <- base::paste(info, collapse = "; ")
[10:22:46.966]                             if (!has_future) {
[10:22:46.966]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:46.966]                                 info)
[10:22:46.966]                             }
[10:22:46.966]                             else {
[10:22:46.966]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:46.966]                                 info, version)
[10:22:46.966]                             }
[10:22:46.966]                             base::stop(msg)
[10:22:46.966]                           }
[10:22:46.966]                         })
[10:22:46.966]                       }
[10:22:46.966]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:46.966]                       base::options(mc.cores = 1L)
[10:22:46.966]                     }
[10:22:46.966]                     base::local({
[10:22:46.966]                       for (pkg in "stats") {
[10:22:46.966]                         base::loadNamespace(pkg)
[10:22:46.966]                         base::library(pkg, character.only = TRUE)
[10:22:46.966]                       }
[10:22:46.966]                     })
[10:22:46.966]                   }
[10:22:46.966]                   options(future.plan = NULL)
[10:22:46.966]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:46.966]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:46.966]                 }
[10:22:46.966]                 ...future.workdir <- getwd()
[10:22:46.966]             }
[10:22:46.966]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:46.966]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:46.966]         }
[10:22:46.966]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:46.966]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:46.966]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:46.966]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:46.966]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:46.966]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:46.966]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:46.966]             base::names(...future.oldOptions))
[10:22:46.966]     }
[10:22:46.966]     if (FALSE) {
[10:22:46.966]     }
[10:22:46.966]     else {
[10:22:46.966]         if (TRUE) {
[10:22:46.966]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:46.966]                 open = "w")
[10:22:46.966]         }
[10:22:46.966]         else {
[10:22:46.966]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:46.966]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:46.966]         }
[10:22:46.966]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:46.966]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:46.966]             base::sink(type = "output", split = FALSE)
[10:22:46.966]             base::close(...future.stdout)
[10:22:46.966]         }, add = TRUE)
[10:22:46.966]     }
[10:22:46.966]     ...future.frame <- base::sys.nframe()
[10:22:46.966]     ...future.conditions <- base::list()
[10:22:46.966]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:46.966]     if (FALSE) {
[10:22:46.966]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:46.966]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:46.966]     }
[10:22:46.966]     ...future.result <- base::tryCatch({
[10:22:46.966]         base::withCallingHandlers({
[10:22:46.966]             ...future.value <- base::withVisible(base::local({
[10:22:46.966]                 ...future.makeSendCondition <- base::local({
[10:22:46.966]                   sendCondition <- NULL
[10:22:46.966]                   function(frame = 1L) {
[10:22:46.966]                     if (is.function(sendCondition)) 
[10:22:46.966]                       return(sendCondition)
[10:22:46.966]                     ns <- getNamespace("parallel")
[10:22:46.966]                     if (exists("sendData", mode = "function", 
[10:22:46.966]                       envir = ns)) {
[10:22:46.966]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:46.966]                         envir = ns)
[10:22:46.966]                       envir <- sys.frame(frame)
[10:22:46.966]                       master <- NULL
[10:22:46.966]                       while (!identical(envir, .GlobalEnv) && 
[10:22:46.966]                         !identical(envir, emptyenv())) {
[10:22:46.966]                         if (exists("master", mode = "list", envir = envir, 
[10:22:46.966]                           inherits = FALSE)) {
[10:22:46.966]                           master <- get("master", mode = "list", 
[10:22:46.966]                             envir = envir, inherits = FALSE)
[10:22:46.966]                           if (inherits(master, c("SOCKnode", 
[10:22:46.966]                             "SOCK0node"))) {
[10:22:46.966]                             sendCondition <<- function(cond) {
[10:22:46.966]                               data <- list(type = "VALUE", value = cond, 
[10:22:46.966]                                 success = TRUE)
[10:22:46.966]                               parallel_sendData(master, data)
[10:22:46.966]                             }
[10:22:46.966]                             return(sendCondition)
[10:22:46.966]                           }
[10:22:46.966]                         }
[10:22:46.966]                         frame <- frame + 1L
[10:22:46.966]                         envir <- sys.frame(frame)
[10:22:46.966]                       }
[10:22:46.966]                     }
[10:22:46.966]                     sendCondition <<- function(cond) NULL
[10:22:46.966]                   }
[10:22:46.966]                 })
[10:22:46.966]                 withCallingHandlers({
[10:22:46.966]                   {
[10:22:46.966]                     do.call(function(...) {
[10:22:46.966]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:46.966]                       if (!identical(...future.globals.maxSize.org, 
[10:22:46.966]                         ...future.globals.maxSize)) {
[10:22:46.966]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:46.966]                         on.exit(options(oopts), add = TRUE)
[10:22:46.966]                       }
[10:22:46.966]                       {
[10:22:46.966]                         lapply(seq_along(...future.elements_ii), 
[10:22:46.966]                           FUN = function(jj) {
[10:22:46.966]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:46.966]                             ...future.FUN(...future.X_jj, ...)
[10:22:46.966]                           })
[10:22:46.966]                       }
[10:22:46.966]                     }, args = future.call.arguments)
[10:22:46.966]                   }
[10:22:46.966]                 }, immediateCondition = function(cond) {
[10:22:46.966]                   sendCondition <- ...future.makeSendCondition()
[10:22:46.966]                   sendCondition(cond)
[10:22:46.966]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:46.966]                   {
[10:22:46.966]                     inherits <- base::inherits
[10:22:46.966]                     invokeRestart <- base::invokeRestart
[10:22:46.966]                     is.null <- base::is.null
[10:22:46.966]                     muffled <- FALSE
[10:22:46.966]                     if (inherits(cond, "message")) {
[10:22:46.966]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:46.966]                       if (muffled) 
[10:22:46.966]                         invokeRestart("muffleMessage")
[10:22:46.966]                     }
[10:22:46.966]                     else if (inherits(cond, "warning")) {
[10:22:46.966]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:46.966]                       if (muffled) 
[10:22:46.966]                         invokeRestart("muffleWarning")
[10:22:46.966]                     }
[10:22:46.966]                     else if (inherits(cond, "condition")) {
[10:22:46.966]                       if (!is.null(pattern)) {
[10:22:46.966]                         computeRestarts <- base::computeRestarts
[10:22:46.966]                         grepl <- base::grepl
[10:22:46.966]                         restarts <- computeRestarts(cond)
[10:22:46.966]                         for (restart in restarts) {
[10:22:46.966]                           name <- restart$name
[10:22:46.966]                           if (is.null(name)) 
[10:22:46.966]                             next
[10:22:46.966]                           if (!grepl(pattern, name)) 
[10:22:46.966]                             next
[10:22:46.966]                           invokeRestart(restart)
[10:22:46.966]                           muffled <- TRUE
[10:22:46.966]                           break
[10:22:46.966]                         }
[10:22:46.966]                       }
[10:22:46.966]                     }
[10:22:46.966]                     invisible(muffled)
[10:22:46.966]                   }
[10:22:46.966]                   muffleCondition(cond)
[10:22:46.966]                 })
[10:22:46.966]             }))
[10:22:46.966]             future::FutureResult(value = ...future.value$value, 
[10:22:46.966]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:46.966]                   ...future.rng), globalenv = if (FALSE) 
[10:22:46.966]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:46.966]                     ...future.globalenv.names))
[10:22:46.966]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:46.966]         }, condition = base::local({
[10:22:46.966]             c <- base::c
[10:22:46.966]             inherits <- base::inherits
[10:22:46.966]             invokeRestart <- base::invokeRestart
[10:22:46.966]             length <- base::length
[10:22:46.966]             list <- base::list
[10:22:46.966]             seq.int <- base::seq.int
[10:22:46.966]             signalCondition <- base::signalCondition
[10:22:46.966]             sys.calls <- base::sys.calls
[10:22:46.966]             `[[` <- base::`[[`
[10:22:46.966]             `+` <- base::`+`
[10:22:46.966]             `<<-` <- base::`<<-`
[10:22:46.966]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:46.966]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:46.966]                   3L)]
[10:22:46.966]             }
[10:22:46.966]             function(cond) {
[10:22:46.966]                 is_error <- inherits(cond, "error")
[10:22:46.966]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:46.966]                   NULL)
[10:22:46.966]                 if (is_error) {
[10:22:46.966]                   sessionInformation <- function() {
[10:22:46.966]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:46.966]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:46.966]                       search = base::search(), system = base::Sys.info())
[10:22:46.966]                   }
[10:22:46.966]                   ...future.conditions[[length(...future.conditions) + 
[10:22:46.966]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:46.966]                     cond$call), session = sessionInformation(), 
[10:22:46.966]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:46.966]                   signalCondition(cond)
[10:22:46.966]                 }
[10:22:46.966]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:46.966]                 "immediateCondition"))) {
[10:22:46.966]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:46.966]                   ...future.conditions[[length(...future.conditions) + 
[10:22:46.966]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:46.966]                   if (TRUE && !signal) {
[10:22:46.966]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:46.966]                     {
[10:22:46.966]                       inherits <- base::inherits
[10:22:46.966]                       invokeRestart <- base::invokeRestart
[10:22:46.966]                       is.null <- base::is.null
[10:22:46.966]                       muffled <- FALSE
[10:22:46.966]                       if (inherits(cond, "message")) {
[10:22:46.966]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:46.966]                         if (muffled) 
[10:22:46.966]                           invokeRestart("muffleMessage")
[10:22:46.966]                       }
[10:22:46.966]                       else if (inherits(cond, "warning")) {
[10:22:46.966]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:46.966]                         if (muffled) 
[10:22:46.966]                           invokeRestart("muffleWarning")
[10:22:46.966]                       }
[10:22:46.966]                       else if (inherits(cond, "condition")) {
[10:22:46.966]                         if (!is.null(pattern)) {
[10:22:46.966]                           computeRestarts <- base::computeRestarts
[10:22:46.966]                           grepl <- base::grepl
[10:22:46.966]                           restarts <- computeRestarts(cond)
[10:22:46.966]                           for (restart in restarts) {
[10:22:46.966]                             name <- restart$name
[10:22:46.966]                             if (is.null(name)) 
[10:22:46.966]                               next
[10:22:46.966]                             if (!grepl(pattern, name)) 
[10:22:46.966]                               next
[10:22:46.966]                             invokeRestart(restart)
[10:22:46.966]                             muffled <- TRUE
[10:22:46.966]                             break
[10:22:46.966]                           }
[10:22:46.966]                         }
[10:22:46.966]                       }
[10:22:46.966]                       invisible(muffled)
[10:22:46.966]                     }
[10:22:46.966]                     muffleCondition(cond, pattern = "^muffle")
[10:22:46.966]                   }
[10:22:46.966]                 }
[10:22:46.966]                 else {
[10:22:46.966]                   if (TRUE) {
[10:22:46.966]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:46.966]                     {
[10:22:46.966]                       inherits <- base::inherits
[10:22:46.966]                       invokeRestart <- base::invokeRestart
[10:22:46.966]                       is.null <- base::is.null
[10:22:46.966]                       muffled <- FALSE
[10:22:46.966]                       if (inherits(cond, "message")) {
[10:22:46.966]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:46.966]                         if (muffled) 
[10:22:46.966]                           invokeRestart("muffleMessage")
[10:22:46.966]                       }
[10:22:46.966]                       else if (inherits(cond, "warning")) {
[10:22:46.966]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:46.966]                         if (muffled) 
[10:22:46.966]                           invokeRestart("muffleWarning")
[10:22:46.966]                       }
[10:22:46.966]                       else if (inherits(cond, "condition")) {
[10:22:46.966]                         if (!is.null(pattern)) {
[10:22:46.966]                           computeRestarts <- base::computeRestarts
[10:22:46.966]                           grepl <- base::grepl
[10:22:46.966]                           restarts <- computeRestarts(cond)
[10:22:46.966]                           for (restart in restarts) {
[10:22:46.966]                             name <- restart$name
[10:22:46.966]                             if (is.null(name)) 
[10:22:46.966]                               next
[10:22:46.966]                             if (!grepl(pattern, name)) 
[10:22:46.966]                               next
[10:22:46.966]                             invokeRestart(restart)
[10:22:46.966]                             muffled <- TRUE
[10:22:46.966]                             break
[10:22:46.966]                           }
[10:22:46.966]                         }
[10:22:46.966]                       }
[10:22:46.966]                       invisible(muffled)
[10:22:46.966]                     }
[10:22:46.966]                     muffleCondition(cond, pattern = "^muffle")
[10:22:46.966]                   }
[10:22:46.966]                 }
[10:22:46.966]             }
[10:22:46.966]         }))
[10:22:46.966]     }, error = function(ex) {
[10:22:46.966]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:46.966]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:46.966]                 ...future.rng), started = ...future.startTime, 
[10:22:46.966]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:46.966]             version = "1.8"), class = "FutureResult")
[10:22:46.966]     }, finally = {
[10:22:46.966]         if (!identical(...future.workdir, getwd())) 
[10:22:46.966]             setwd(...future.workdir)
[10:22:46.966]         {
[10:22:46.966]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:46.966]                 ...future.oldOptions$nwarnings <- NULL
[10:22:46.966]             }
[10:22:46.966]             base::options(...future.oldOptions)
[10:22:46.966]             if (.Platform$OS.type == "windows") {
[10:22:46.966]                 old_names <- names(...future.oldEnvVars)
[10:22:46.966]                 envs <- base::Sys.getenv()
[10:22:46.966]                 names <- names(envs)
[10:22:46.966]                 common <- intersect(names, old_names)
[10:22:46.966]                 added <- setdiff(names, old_names)
[10:22:46.966]                 removed <- setdiff(old_names, names)
[10:22:46.966]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:46.966]                   envs[common]]
[10:22:46.966]                 NAMES <- toupper(changed)
[10:22:46.966]                 args <- list()
[10:22:46.966]                 for (kk in seq_along(NAMES)) {
[10:22:46.966]                   name <- changed[[kk]]
[10:22:46.966]                   NAME <- NAMES[[kk]]
[10:22:46.966]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:46.966]                     next
[10:22:46.966]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:46.966]                 }
[10:22:46.966]                 NAMES <- toupper(added)
[10:22:46.966]                 for (kk in seq_along(NAMES)) {
[10:22:46.966]                   name <- added[[kk]]
[10:22:46.966]                   NAME <- NAMES[[kk]]
[10:22:46.966]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:46.966]                     next
[10:22:46.966]                   args[[name]] <- ""
[10:22:46.966]                 }
[10:22:46.966]                 NAMES <- toupper(removed)
[10:22:46.966]                 for (kk in seq_along(NAMES)) {
[10:22:46.966]                   name <- removed[[kk]]
[10:22:46.966]                   NAME <- NAMES[[kk]]
[10:22:46.966]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:46.966]                     next
[10:22:46.966]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:46.966]                 }
[10:22:46.966]                 if (length(args) > 0) 
[10:22:46.966]                   base::do.call(base::Sys.setenv, args = args)
[10:22:46.966]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:46.966]             }
[10:22:46.966]             else {
[10:22:46.966]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:46.966]             }
[10:22:46.966]             {
[10:22:46.966]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:46.966]                   0L) {
[10:22:46.966]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:46.966]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:46.966]                   base::options(opts)
[10:22:46.966]                 }
[10:22:46.966]                 {
[10:22:46.966]                   {
[10:22:46.966]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:46.966]                     NULL
[10:22:46.966]                   }
[10:22:46.966]                   options(future.plan = NULL)
[10:22:46.966]                   if (is.na(NA_character_)) 
[10:22:46.966]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:46.966]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:46.966]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:46.966]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:46.966]                     envir = parent.frame()) 
[10:22:46.966]                   {
[10:22:46.966]                     if (is.function(workers)) 
[10:22:46.966]                       workers <- workers()
[10:22:46.966]                     workers <- structure(as.integer(workers), 
[10:22:46.966]                       class = class(workers))
[10:22:46.966]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:46.966]                       workers >= 1)
[10:22:46.966]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:46.966]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:46.966]                     }
[10:22:46.966]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:46.966]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:46.966]                       envir = envir)
[10:22:46.966]                     if (!future$lazy) 
[10:22:46.966]                       future <- run(future)
[10:22:46.966]                     invisible(future)
[10:22:46.966]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:46.966]                 }
[10:22:46.966]             }
[10:22:46.966]         }
[10:22:46.966]     })
[10:22:46.966]     if (TRUE) {
[10:22:46.966]         base::sink(type = "output", split = FALSE)
[10:22:46.966]         if (TRUE) {
[10:22:46.966]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:46.966]         }
[10:22:46.966]         else {
[10:22:46.966]             ...future.result["stdout"] <- base::list(NULL)
[10:22:46.966]         }
[10:22:46.966]         base::close(...future.stdout)
[10:22:46.966]         ...future.stdout <- NULL
[10:22:46.966]     }
[10:22:46.966]     ...future.result$conditions <- ...future.conditions
[10:22:46.966]     ...future.result$finished <- base::Sys.time()
[10:22:46.966]     ...future.result
[10:22:46.966] }
[10:22:46.970] Exporting 5 global objects (1.35 KiB) to cluster node #1 ...
[10:22:46.970] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:22:46.970] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:22:46.970] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[10:22:46.971] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[10:22:46.971] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[10:22:46.971] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[10:22:46.971] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:22:46.971] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:22:46.972] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[10:22:46.972] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[10:22:46.972] Exporting 5 global objects (1.35 KiB) to cluster node #1 ... DONE
[10:22:46.972] MultisessionFuture started
[10:22:46.973] - Launch lazy future ... done
[10:22:46.973] run() for ‘MultisessionFuture’ ... done
[10:22:46.973] Created future:
[10:22:46.973] MultisessionFuture:
[10:22:46.973] Label: ‘future_apply-1’
[10:22:46.973] Expression:
[10:22:46.973] {
[10:22:46.973]     do.call(function(...) {
[10:22:46.973]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:46.973]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:46.973]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:46.973]             on.exit(options(oopts), add = TRUE)
[10:22:46.973]         }
[10:22:46.973]         {
[10:22:46.973]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:46.973]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:46.973]                 ...future.FUN(...future.X_jj, ...)
[10:22:46.973]             })
[10:22:46.973]         }
[10:22:46.973]     }, args = future.call.arguments)
[10:22:46.973] }
[10:22:46.973] Lazy evaluation: FALSE
[10:22:46.973] Asynchronous evaluation: TRUE
[10:22:46.973] Local evaluation: TRUE
[10:22:46.973] Environment: R_GlobalEnv
[10:22:46.973] Capture standard output: TRUE
[10:22:46.973] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:46.973] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:46.973] Packages: 1 packages (‘stats’)
[10:22:46.973] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:46.973] Resolved: FALSE
[10:22:46.973] Value: <not collected>
[10:22:46.973] Conditions captured: <none>
[10:22:46.973] Early signaling: FALSE
[10:22:46.973] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:46.973] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:46.984] Chunk #1 of 2 ... DONE
[10:22:46.985] Chunk #2 of 2 ...
[10:22:46.985]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:46.985]  - seeds: <none>
[10:22:46.985]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:46.985] getGlobalsAndPackages() ...
[10:22:46.985] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:46.985] Resolving globals: FALSE
[10:22:46.986] Tweak future expression to call with '...' arguments ...
[10:22:46.986] {
[10:22:46.986]     do.call(function(...) {
[10:22:46.986]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:46.986]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:46.986]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:46.986]             on.exit(options(oopts), add = TRUE)
[10:22:46.986]         }
[10:22:46.986]         {
[10:22:46.986]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:46.986]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:46.986]                 ...future.FUN(...future.X_jj, ...)
[10:22:46.986]             })
[10:22:46.986]         }
[10:22:46.986]     }, args = future.call.arguments)
[10:22:46.986] }
[10:22:46.986] Tweak future expression to call with '...' arguments ... DONE
[10:22:46.986] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:46.986] - packages: [1] ‘stats’
[10:22:46.987] getGlobalsAndPackages() ... DONE
[10:22:46.987] run() for ‘Future’ ...
[10:22:46.987] - state: ‘created’
[10:22:46.987] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:47.000] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:47.001] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:47.001]   - Field: ‘node’
[10:22:47.001]   - Field: ‘label’
[10:22:47.001]   - Field: ‘local’
[10:22:47.001]   - Field: ‘owner’
[10:22:47.001]   - Field: ‘envir’
[10:22:47.001]   - Field: ‘workers’
[10:22:47.001]   - Field: ‘packages’
[10:22:47.001]   - Field: ‘gc’
[10:22:47.002]   - Field: ‘conditions’
[10:22:47.002]   - Field: ‘persistent’
[10:22:47.002]   - Field: ‘expr’
[10:22:47.002]   - Field: ‘uuid’
[10:22:47.002]   - Field: ‘seed’
[10:22:47.002]   - Field: ‘version’
[10:22:47.002]   - Field: ‘result’
[10:22:47.002]   - Field: ‘asynchronous’
[10:22:47.002]   - Field: ‘calls’
[10:22:47.002]   - Field: ‘globals’
[10:22:47.002]   - Field: ‘stdout’
[10:22:47.003]   - Field: ‘earlySignal’
[10:22:47.003]   - Field: ‘lazy’
[10:22:47.003]   - Field: ‘state’
[10:22:47.003] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:47.003] - Launch lazy future ...
[10:22:47.003] Packages needed by the future expression (n = 1): ‘stats’
[10:22:47.003] Packages needed by future strategies (n = 0): <none>
[10:22:47.004] {
[10:22:47.004]     {
[10:22:47.004]         {
[10:22:47.004]             ...future.startTime <- base::Sys.time()
[10:22:47.004]             {
[10:22:47.004]                 {
[10:22:47.004]                   {
[10:22:47.004]                     {
[10:22:47.004]                       {
[10:22:47.004]                         base::local({
[10:22:47.004]                           has_future <- base::requireNamespace("future", 
[10:22:47.004]                             quietly = TRUE)
[10:22:47.004]                           if (has_future) {
[10:22:47.004]                             ns <- base::getNamespace("future")
[10:22:47.004]                             version <- ns[[".package"]][["version"]]
[10:22:47.004]                             if (is.null(version)) 
[10:22:47.004]                               version <- utils::packageVersion("future")
[10:22:47.004]                           }
[10:22:47.004]                           else {
[10:22:47.004]                             version <- NULL
[10:22:47.004]                           }
[10:22:47.004]                           if (!has_future || version < "1.8.0") {
[10:22:47.004]                             info <- base::c(r_version = base::gsub("R version ", 
[10:22:47.004]                               "", base::R.version$version.string), 
[10:22:47.004]                               platform = base::sprintf("%s (%s-bit)", 
[10:22:47.004]                                 base::R.version$platform, 8 * 
[10:22:47.004]                                   base::.Machine$sizeof.pointer), 
[10:22:47.004]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:47.004]                                 "release", "version")], collapse = " "), 
[10:22:47.004]                               hostname = base::Sys.info()[["nodename"]])
[10:22:47.004]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:22:47.004]                               info)
[10:22:47.004]                             info <- base::paste(info, collapse = "; ")
[10:22:47.004]                             if (!has_future) {
[10:22:47.004]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:47.004]                                 info)
[10:22:47.004]                             }
[10:22:47.004]                             else {
[10:22:47.004]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:47.004]                                 info, version)
[10:22:47.004]                             }
[10:22:47.004]                             base::stop(msg)
[10:22:47.004]                           }
[10:22:47.004]                         })
[10:22:47.004]                       }
[10:22:47.004]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:47.004]                       base::options(mc.cores = 1L)
[10:22:47.004]                     }
[10:22:47.004]                     base::local({
[10:22:47.004]                       for (pkg in "stats") {
[10:22:47.004]                         base::loadNamespace(pkg)
[10:22:47.004]                         base::library(pkg, character.only = TRUE)
[10:22:47.004]                       }
[10:22:47.004]                     })
[10:22:47.004]                   }
[10:22:47.004]                   options(future.plan = NULL)
[10:22:47.004]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:47.004]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:47.004]                 }
[10:22:47.004]                 ...future.workdir <- getwd()
[10:22:47.004]             }
[10:22:47.004]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:47.004]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:47.004]         }
[10:22:47.004]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:47.004]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:47.004]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:47.004]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:47.004]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:47.004]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:47.004]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:47.004]             base::names(...future.oldOptions))
[10:22:47.004]     }
[10:22:47.004]     if (FALSE) {
[10:22:47.004]     }
[10:22:47.004]     else {
[10:22:47.004]         if (TRUE) {
[10:22:47.004]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:47.004]                 open = "w")
[10:22:47.004]         }
[10:22:47.004]         else {
[10:22:47.004]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:47.004]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:47.004]         }
[10:22:47.004]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:47.004]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:47.004]             base::sink(type = "output", split = FALSE)
[10:22:47.004]             base::close(...future.stdout)
[10:22:47.004]         }, add = TRUE)
[10:22:47.004]     }
[10:22:47.004]     ...future.frame <- base::sys.nframe()
[10:22:47.004]     ...future.conditions <- base::list()
[10:22:47.004]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:47.004]     if (FALSE) {
[10:22:47.004]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:47.004]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:47.004]     }
[10:22:47.004]     ...future.result <- base::tryCatch({
[10:22:47.004]         base::withCallingHandlers({
[10:22:47.004]             ...future.value <- base::withVisible(base::local({
[10:22:47.004]                 ...future.makeSendCondition <- base::local({
[10:22:47.004]                   sendCondition <- NULL
[10:22:47.004]                   function(frame = 1L) {
[10:22:47.004]                     if (is.function(sendCondition)) 
[10:22:47.004]                       return(sendCondition)
[10:22:47.004]                     ns <- getNamespace("parallel")
[10:22:47.004]                     if (exists("sendData", mode = "function", 
[10:22:47.004]                       envir = ns)) {
[10:22:47.004]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:47.004]                         envir = ns)
[10:22:47.004]                       envir <- sys.frame(frame)
[10:22:47.004]                       master <- NULL
[10:22:47.004]                       while (!identical(envir, .GlobalEnv) && 
[10:22:47.004]                         !identical(envir, emptyenv())) {
[10:22:47.004]                         if (exists("master", mode = "list", envir = envir, 
[10:22:47.004]                           inherits = FALSE)) {
[10:22:47.004]                           master <- get("master", mode = "list", 
[10:22:47.004]                             envir = envir, inherits = FALSE)
[10:22:47.004]                           if (inherits(master, c("SOCKnode", 
[10:22:47.004]                             "SOCK0node"))) {
[10:22:47.004]                             sendCondition <<- function(cond) {
[10:22:47.004]                               data <- list(type = "VALUE", value = cond, 
[10:22:47.004]                                 success = TRUE)
[10:22:47.004]                               parallel_sendData(master, data)
[10:22:47.004]                             }
[10:22:47.004]                             return(sendCondition)
[10:22:47.004]                           }
[10:22:47.004]                         }
[10:22:47.004]                         frame <- frame + 1L
[10:22:47.004]                         envir <- sys.frame(frame)
[10:22:47.004]                       }
[10:22:47.004]                     }
[10:22:47.004]                     sendCondition <<- function(cond) NULL
[10:22:47.004]                   }
[10:22:47.004]                 })
[10:22:47.004]                 withCallingHandlers({
[10:22:47.004]                   {
[10:22:47.004]                     do.call(function(...) {
[10:22:47.004]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.004]                       if (!identical(...future.globals.maxSize.org, 
[10:22:47.004]                         ...future.globals.maxSize)) {
[10:22:47.004]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.004]                         on.exit(options(oopts), add = TRUE)
[10:22:47.004]                       }
[10:22:47.004]                       {
[10:22:47.004]                         lapply(seq_along(...future.elements_ii), 
[10:22:47.004]                           FUN = function(jj) {
[10:22:47.004]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.004]                             ...future.FUN(...future.X_jj, ...)
[10:22:47.004]                           })
[10:22:47.004]                       }
[10:22:47.004]                     }, args = future.call.arguments)
[10:22:47.004]                   }
[10:22:47.004]                 }, immediateCondition = function(cond) {
[10:22:47.004]                   sendCondition <- ...future.makeSendCondition()
[10:22:47.004]                   sendCondition(cond)
[10:22:47.004]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.004]                   {
[10:22:47.004]                     inherits <- base::inherits
[10:22:47.004]                     invokeRestart <- base::invokeRestart
[10:22:47.004]                     is.null <- base::is.null
[10:22:47.004]                     muffled <- FALSE
[10:22:47.004]                     if (inherits(cond, "message")) {
[10:22:47.004]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:47.004]                       if (muffled) 
[10:22:47.004]                         invokeRestart("muffleMessage")
[10:22:47.004]                     }
[10:22:47.004]                     else if (inherits(cond, "warning")) {
[10:22:47.004]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:47.004]                       if (muffled) 
[10:22:47.004]                         invokeRestart("muffleWarning")
[10:22:47.004]                     }
[10:22:47.004]                     else if (inherits(cond, "condition")) {
[10:22:47.004]                       if (!is.null(pattern)) {
[10:22:47.004]                         computeRestarts <- base::computeRestarts
[10:22:47.004]                         grepl <- base::grepl
[10:22:47.004]                         restarts <- computeRestarts(cond)
[10:22:47.004]                         for (restart in restarts) {
[10:22:47.004]                           name <- restart$name
[10:22:47.004]                           if (is.null(name)) 
[10:22:47.004]                             next
[10:22:47.004]                           if (!grepl(pattern, name)) 
[10:22:47.004]                             next
[10:22:47.004]                           invokeRestart(restart)
[10:22:47.004]                           muffled <- TRUE
[10:22:47.004]                           break
[10:22:47.004]                         }
[10:22:47.004]                       }
[10:22:47.004]                     }
[10:22:47.004]                     invisible(muffled)
[10:22:47.004]                   }
[10:22:47.004]                   muffleCondition(cond)
[10:22:47.004]                 })
[10:22:47.004]             }))
[10:22:47.004]             future::FutureResult(value = ...future.value$value, 
[10:22:47.004]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:47.004]                   ...future.rng), globalenv = if (FALSE) 
[10:22:47.004]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:47.004]                     ...future.globalenv.names))
[10:22:47.004]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:47.004]         }, condition = base::local({
[10:22:47.004]             c <- base::c
[10:22:47.004]             inherits <- base::inherits
[10:22:47.004]             invokeRestart <- base::invokeRestart
[10:22:47.004]             length <- base::length
[10:22:47.004]             list <- base::list
[10:22:47.004]             seq.int <- base::seq.int
[10:22:47.004]             signalCondition <- base::signalCondition
[10:22:47.004]             sys.calls <- base::sys.calls
[10:22:47.004]             `[[` <- base::`[[`
[10:22:47.004]             `+` <- base::`+`
[10:22:47.004]             `<<-` <- base::`<<-`
[10:22:47.004]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:47.004]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:47.004]                   3L)]
[10:22:47.004]             }
[10:22:47.004]             function(cond) {
[10:22:47.004]                 is_error <- inherits(cond, "error")
[10:22:47.004]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:47.004]                   NULL)
[10:22:47.004]                 if (is_error) {
[10:22:47.004]                   sessionInformation <- function() {
[10:22:47.004]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:47.004]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:47.004]                       search = base::search(), system = base::Sys.info())
[10:22:47.004]                   }
[10:22:47.004]                   ...future.conditions[[length(...future.conditions) + 
[10:22:47.004]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:47.004]                     cond$call), session = sessionInformation(), 
[10:22:47.004]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:47.004]                   signalCondition(cond)
[10:22:47.004]                 }
[10:22:47.004]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:47.004]                 "immediateCondition"))) {
[10:22:47.004]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:47.004]                   ...future.conditions[[length(...future.conditions) + 
[10:22:47.004]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:47.004]                   if (TRUE && !signal) {
[10:22:47.004]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.004]                     {
[10:22:47.004]                       inherits <- base::inherits
[10:22:47.004]                       invokeRestart <- base::invokeRestart
[10:22:47.004]                       is.null <- base::is.null
[10:22:47.004]                       muffled <- FALSE
[10:22:47.004]                       if (inherits(cond, "message")) {
[10:22:47.004]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:47.004]                         if (muffled) 
[10:22:47.004]                           invokeRestart("muffleMessage")
[10:22:47.004]                       }
[10:22:47.004]                       else if (inherits(cond, "warning")) {
[10:22:47.004]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:47.004]                         if (muffled) 
[10:22:47.004]                           invokeRestart("muffleWarning")
[10:22:47.004]                       }
[10:22:47.004]                       else if (inherits(cond, "condition")) {
[10:22:47.004]                         if (!is.null(pattern)) {
[10:22:47.004]                           computeRestarts <- base::computeRestarts
[10:22:47.004]                           grepl <- base::grepl
[10:22:47.004]                           restarts <- computeRestarts(cond)
[10:22:47.004]                           for (restart in restarts) {
[10:22:47.004]                             name <- restart$name
[10:22:47.004]                             if (is.null(name)) 
[10:22:47.004]                               next
[10:22:47.004]                             if (!grepl(pattern, name)) 
[10:22:47.004]                               next
[10:22:47.004]                             invokeRestart(restart)
[10:22:47.004]                             muffled <- TRUE
[10:22:47.004]                             break
[10:22:47.004]                           }
[10:22:47.004]                         }
[10:22:47.004]                       }
[10:22:47.004]                       invisible(muffled)
[10:22:47.004]                     }
[10:22:47.004]                     muffleCondition(cond, pattern = "^muffle")
[10:22:47.004]                   }
[10:22:47.004]                 }
[10:22:47.004]                 else {
[10:22:47.004]                   if (TRUE) {
[10:22:47.004]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.004]                     {
[10:22:47.004]                       inherits <- base::inherits
[10:22:47.004]                       invokeRestart <- base::invokeRestart
[10:22:47.004]                       is.null <- base::is.null
[10:22:47.004]                       muffled <- FALSE
[10:22:47.004]                       if (inherits(cond, "message")) {
[10:22:47.004]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:47.004]                         if (muffled) 
[10:22:47.004]                           invokeRestart("muffleMessage")
[10:22:47.004]                       }
[10:22:47.004]                       else if (inherits(cond, "warning")) {
[10:22:47.004]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:47.004]                         if (muffled) 
[10:22:47.004]                           invokeRestart("muffleWarning")
[10:22:47.004]                       }
[10:22:47.004]                       else if (inherits(cond, "condition")) {
[10:22:47.004]                         if (!is.null(pattern)) {
[10:22:47.004]                           computeRestarts <- base::computeRestarts
[10:22:47.004]                           grepl <- base::grepl
[10:22:47.004]                           restarts <- computeRestarts(cond)
[10:22:47.004]                           for (restart in restarts) {
[10:22:47.004]                             name <- restart$name
[10:22:47.004]                             if (is.null(name)) 
[10:22:47.004]                               next
[10:22:47.004]                             if (!grepl(pattern, name)) 
[10:22:47.004]                               next
[10:22:47.004]                             invokeRestart(restart)
[10:22:47.004]                             muffled <- TRUE
[10:22:47.004]                             break
[10:22:47.004]                           }
[10:22:47.004]                         }
[10:22:47.004]                       }
[10:22:47.004]                       invisible(muffled)
[10:22:47.004]                     }
[10:22:47.004]                     muffleCondition(cond, pattern = "^muffle")
[10:22:47.004]                   }
[10:22:47.004]                 }
[10:22:47.004]             }
[10:22:47.004]         }))
[10:22:47.004]     }, error = function(ex) {
[10:22:47.004]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:47.004]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:47.004]                 ...future.rng), started = ...future.startTime, 
[10:22:47.004]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:47.004]             version = "1.8"), class = "FutureResult")
[10:22:47.004]     }, finally = {
[10:22:47.004]         if (!identical(...future.workdir, getwd())) 
[10:22:47.004]             setwd(...future.workdir)
[10:22:47.004]         {
[10:22:47.004]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:47.004]                 ...future.oldOptions$nwarnings <- NULL
[10:22:47.004]             }
[10:22:47.004]             base::options(...future.oldOptions)
[10:22:47.004]             if (.Platform$OS.type == "windows") {
[10:22:47.004]                 old_names <- names(...future.oldEnvVars)
[10:22:47.004]                 envs <- base::Sys.getenv()
[10:22:47.004]                 names <- names(envs)
[10:22:47.004]                 common <- intersect(names, old_names)
[10:22:47.004]                 added <- setdiff(names, old_names)
[10:22:47.004]                 removed <- setdiff(old_names, names)
[10:22:47.004]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:47.004]                   envs[common]]
[10:22:47.004]                 NAMES <- toupper(changed)
[10:22:47.004]                 args <- list()
[10:22:47.004]                 for (kk in seq_along(NAMES)) {
[10:22:47.004]                   name <- changed[[kk]]
[10:22:47.004]                   NAME <- NAMES[[kk]]
[10:22:47.004]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.004]                     next
[10:22:47.004]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:47.004]                 }
[10:22:47.004]                 NAMES <- toupper(added)
[10:22:47.004]                 for (kk in seq_along(NAMES)) {
[10:22:47.004]                   name <- added[[kk]]
[10:22:47.004]                   NAME <- NAMES[[kk]]
[10:22:47.004]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.004]                     next
[10:22:47.004]                   args[[name]] <- ""
[10:22:47.004]                 }
[10:22:47.004]                 NAMES <- toupper(removed)
[10:22:47.004]                 for (kk in seq_along(NAMES)) {
[10:22:47.004]                   name <- removed[[kk]]
[10:22:47.004]                   NAME <- NAMES[[kk]]
[10:22:47.004]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.004]                     next
[10:22:47.004]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:47.004]                 }
[10:22:47.004]                 if (length(args) > 0) 
[10:22:47.004]                   base::do.call(base::Sys.setenv, args = args)
[10:22:47.004]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:47.004]             }
[10:22:47.004]             else {
[10:22:47.004]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:47.004]             }
[10:22:47.004]             {
[10:22:47.004]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:47.004]                   0L) {
[10:22:47.004]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:47.004]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:47.004]                   base::options(opts)
[10:22:47.004]                 }
[10:22:47.004]                 {
[10:22:47.004]                   {
[10:22:47.004]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:47.004]                     NULL
[10:22:47.004]                   }
[10:22:47.004]                   options(future.plan = NULL)
[10:22:47.004]                   if (is.na(NA_character_)) 
[10:22:47.004]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:47.004]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:47.004]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:47.004]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:47.004]                     envir = parent.frame()) 
[10:22:47.004]                   {
[10:22:47.004]                     if (is.function(workers)) 
[10:22:47.004]                       workers <- workers()
[10:22:47.004]                     workers <- structure(as.integer(workers), 
[10:22:47.004]                       class = class(workers))
[10:22:47.004]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:47.004]                       workers >= 1)
[10:22:47.004]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:47.004]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:47.004]                     }
[10:22:47.004]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:47.004]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:47.004]                       envir = envir)
[10:22:47.004]                     if (!future$lazy) 
[10:22:47.004]                       future <- run(future)
[10:22:47.004]                     invisible(future)
[10:22:47.004]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:47.004]                 }
[10:22:47.004]             }
[10:22:47.004]         }
[10:22:47.004]     })
[10:22:47.004]     if (TRUE) {
[10:22:47.004]         base::sink(type = "output", split = FALSE)
[10:22:47.004]         if (TRUE) {
[10:22:47.004]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:47.004]         }
[10:22:47.004]         else {
[10:22:47.004]             ...future.result["stdout"] <- base::list(NULL)
[10:22:47.004]         }
[10:22:47.004]         base::close(...future.stdout)
[10:22:47.004]         ...future.stdout <- NULL
[10:22:47.004]     }
[10:22:47.004]     ...future.result$conditions <- ...future.conditions
[10:22:47.004]     ...future.result$finished <- base::Sys.time()
[10:22:47.004]     ...future.result
[10:22:47.004] }
[10:22:47.007] Exporting 5 global objects (1.35 KiB) to cluster node #2 ...
[10:22:47.007] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:22:47.008] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:22:47.008] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[10:22:47.008] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[10:22:47.008] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[10:22:47.009] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[10:22:47.009] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:22:47.009] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:22:47.009] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[10:22:47.010] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[10:22:47.010] Exporting 5 global objects (1.35 KiB) to cluster node #2 ... DONE
[10:22:47.010] MultisessionFuture started
[10:22:47.011] - Launch lazy future ... done
[10:22:47.011] run() for ‘MultisessionFuture’ ... done
[10:22:47.011] Created future:
[10:22:47.011] MultisessionFuture:
[10:22:47.011] Label: ‘future_apply-2’
[10:22:47.011] Expression:
[10:22:47.011] {
[10:22:47.011]     do.call(function(...) {
[10:22:47.011]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.011]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:47.011]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.011]             on.exit(options(oopts), add = TRUE)
[10:22:47.011]         }
[10:22:47.011]         {
[10:22:47.011]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:47.011]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.011]                 ...future.FUN(...future.X_jj, ...)
[10:22:47.011]             })
[10:22:47.011]         }
[10:22:47.011]     }, args = future.call.arguments)
[10:22:47.011] }
[10:22:47.011] Lazy evaluation: FALSE
[10:22:47.011] Asynchronous evaluation: TRUE
[10:22:47.011] Local evaluation: TRUE
[10:22:47.011] Environment: R_GlobalEnv
[10:22:47.011] Capture standard output: TRUE
[10:22:47.011] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:47.011] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:47.011] Packages: 1 packages (‘stats’)
[10:22:47.011] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:47.011] Resolved: FALSE
[10:22:47.011] Value: <not collected>
[10:22:47.011] Conditions captured: <none>
[10:22:47.011] Early signaling: FALSE
[10:22:47.011] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:47.011] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:47.023] Chunk #2 of 2 ... DONE
[10:22:47.023] Launching 2 futures (chunks) ... DONE
[10:22:47.023] Resolving 2 futures (chunks) ...
[10:22:47.023] resolve() on list ...
[10:22:47.023]  recursive: 0
[10:22:47.023]  length: 2
[10:22:47.023] 
[10:22:47.024] receiveMessageFromWorker() for ClusterFuture ...
[10:22:47.024] - Validating connection of MultisessionFuture
[10:22:47.024] - received message: FutureResult
[10:22:47.024] - Received FutureResult
[10:22:47.024] - Erased future from FutureRegistry
[10:22:47.024] result() for ClusterFuture ...
[10:22:47.024] - result already collected: FutureResult
[10:22:47.024] result() for ClusterFuture ... done
[10:22:47.025] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:47.025] Future #1
[10:22:47.025] result() for ClusterFuture ...
[10:22:47.025] - result already collected: FutureResult
[10:22:47.025] result() for ClusterFuture ... done
[10:22:47.025] result() for ClusterFuture ...
[10:22:47.025] - result already collected: FutureResult
[10:22:47.025] result() for ClusterFuture ... done
[10:22:47.025] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:22:47.025] - nx: 2
[10:22:47.025] - relay: TRUE
[10:22:47.026] - stdout: TRUE
[10:22:47.026] - signal: TRUE
[10:22:47.026] - resignal: FALSE
[10:22:47.026] - force: TRUE
[10:22:47.026] - relayed: [n=2] FALSE, FALSE
[10:22:47.026] - queued futures: [n=2] FALSE, FALSE
[10:22:47.026]  - until=1
[10:22:47.026]  - relaying element #1
[10:22:47.026] result() for ClusterFuture ...
[10:22:47.026] - result already collected: FutureResult
[10:22:47.026] result() for ClusterFuture ... done
[10:22:47.026] result() for ClusterFuture ...
[10:22:47.027] - result already collected: FutureResult
[10:22:47.027] result() for ClusterFuture ... done
[10:22:47.027] result() for ClusterFuture ...
[10:22:47.027] - result already collected: FutureResult
[10:22:47.027] result() for ClusterFuture ... done
[10:22:47.027] result() for ClusterFuture ...
[10:22:47.027] - result already collected: FutureResult
[10:22:47.027] result() for ClusterFuture ... done
[10:22:47.027] - relayed: [n=2] TRUE, FALSE
[10:22:47.027] - queued futures: [n=2] TRUE, FALSE
[10:22:47.027] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:22:47.028]  length: 1 (resolved future 1)
[10:22:47.069] receiveMessageFromWorker() for ClusterFuture ...
[10:22:47.070] - Validating connection of MultisessionFuture
[10:22:47.070] - received message: FutureResult
[10:22:47.070] - Received FutureResult
[10:22:47.070] - Erased future from FutureRegistry
[10:22:47.070] result() for ClusterFuture ...
[10:22:47.070] - result already collected: FutureResult
[10:22:47.070] result() for ClusterFuture ... done
[10:22:47.070] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:47.070] Future #2
[10:22:47.071] result() for ClusterFuture ...
[10:22:47.071] - result already collected: FutureResult
[10:22:47.071] result() for ClusterFuture ... done
[10:22:47.071] result() for ClusterFuture ...
[10:22:47.071] - result already collected: FutureResult
[10:22:47.071] result() for ClusterFuture ... done
[10:22:47.071] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:22:47.071] - nx: 2
[10:22:47.071] - relay: TRUE
[10:22:47.071] - stdout: TRUE
[10:22:47.071] - signal: TRUE
[10:22:47.072] - resignal: FALSE
[10:22:47.072] - force: TRUE
[10:22:47.072] - relayed: [n=2] TRUE, FALSE
[10:22:47.072] - queued futures: [n=2] TRUE, FALSE
[10:22:47.072]  - until=2
[10:22:47.072]  - relaying element #2
[10:22:47.072] result() for ClusterFuture ...
[10:22:47.072] - result already collected: FutureResult
[10:22:47.072] result() for ClusterFuture ... done
[10:22:47.072] result() for ClusterFuture ...
[10:22:47.072] - result already collected: FutureResult
[10:22:47.072] result() for ClusterFuture ... done
[10:22:47.073] result() for ClusterFuture ...
[10:22:47.073] - result already collected: FutureResult
[10:22:47.073] result() for ClusterFuture ... done
[10:22:47.073] result() for ClusterFuture ...
[10:22:47.073] - result already collected: FutureResult
[10:22:47.073] result() for ClusterFuture ... done
[10:22:47.073] - relayed: [n=2] TRUE, TRUE
[10:22:47.073] - queued futures: [n=2] TRUE, TRUE
[10:22:47.073] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:22:47.073]  length: 0 (resolved future 2)
[10:22:47.074] Relaying remaining futures
[10:22:47.074] signalConditionsASAP(NULL, pos=0) ...
[10:22:47.074] - nx: 2
[10:22:47.074] - relay: TRUE
[10:22:47.074] - stdout: TRUE
[10:22:47.074] - signal: TRUE
[10:22:47.074] - resignal: FALSE
[10:22:47.074] - force: TRUE
[10:22:47.074] - relayed: [n=2] TRUE, TRUE
[10:22:47.074] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:22:47.074] - relayed: [n=2] TRUE, TRUE
[10:22:47.075] - queued futures: [n=2] TRUE, TRUE
[10:22:47.075] signalConditionsASAP(NULL, pos=0) ... done
[10:22:47.075] resolve() on list ... DONE
[10:22:47.075] result() for ClusterFuture ...
[10:22:47.075] - result already collected: FutureResult
[10:22:47.075] result() for ClusterFuture ... done
[10:22:47.075] result() for ClusterFuture ...
[10:22:47.075] - result already collected: FutureResult
[10:22:47.075] result() for ClusterFuture ... done
[10:22:47.075] result() for ClusterFuture ...
[10:22:47.075] - result already collected: FutureResult
[10:22:47.075] result() for ClusterFuture ... done
[10:22:47.076] result() for ClusterFuture ...
[10:22:47.076] - result already collected: FutureResult
[10:22:47.076] result() for ClusterFuture ... done
[10:22:47.076]  - Number of value chunks collected: 2
[10:22:47.076] Resolving 2 futures (chunks) ... DONE
[10:22:47.076] Reducing values from 2 chunks ...
[10:22:47.076]  - Number of values collected after concatenation: 2
[10:22:47.076]  - Number of values expected: 2
[10:22:47.076] Reducing values from 2 chunks ... DONE
[10:22:47.076] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[10:22:47.077] getGlobalsAndPackagesXApply() ...
[10:22:47.077]  - future.globals: TRUE
[10:22:47.077] getGlobalsAndPackages() ...
[10:22:47.077] Searching for globals...
[10:22:47.078] - globals found: [1] ‘FUN’
[10:22:47.078] Searching for globals ... DONE
[10:22:47.079] Resolving globals: FALSE
[10:22:47.079] The total size of the 1 globals is 848 bytes (848 bytes)
[10:22:47.079] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:22:47.079] - globals: [1] ‘FUN’
[10:22:47.079] 
[10:22:47.080] getGlobalsAndPackages() ... DONE
[10:22:47.080]  - globals found/used: [n=1] ‘FUN’
[10:22:47.080]  - needed namespaces: [n=0] 
[10:22:47.080] Finding globals ... DONE
[10:22:47.080]  - use_args: TRUE
[10:22:47.080]  - Getting '...' globals ...
[10:22:47.080] resolve() on list ...
[10:22:47.080]  recursive: 0
[10:22:47.080]  length: 1
[10:22:47.081]  elements: ‘...’
[10:22:47.081]  length: 0 (resolved future 1)
[10:22:47.081] resolve() on list ... DONE
[10:22:47.081]    - '...' content: [n=0] 
[10:22:47.081] List of 1
[10:22:47.081]  $ ...: list()
[10:22:47.081]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:47.081]  - attr(*, "where")=List of 1
[10:22:47.081]   ..$ ...:<environment: 0x55ca4ed86f08> 
[10:22:47.081]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:47.081]  - attr(*, "resolved")= logi TRUE
[10:22:47.081]  - attr(*, "total_size")= num NA
[10:22:47.084]  - Getting '...' globals ... DONE
[10:22:47.084] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:47.084] List of 2
[10:22:47.084]  $ ...future.FUN:function (x)  
[10:22:47.084]  $ ...          : list()
[10:22:47.084]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:47.084]  - attr(*, "where")=List of 2
[10:22:47.084]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:47.084]   ..$ ...          :<environment: 0x55ca4ed86f08> 
[10:22:47.084]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:47.084]  - attr(*, "resolved")= logi FALSE
[10:22:47.084]  - attr(*, "total_size")= num 848
[10:22:47.089] Packages to be attached in all futures: [n=0] 
[10:22:47.089] getGlobalsAndPackagesXApply() ... DONE
[10:22:47.092] future_lapply() ...
[10:22:47.096] Number of chunks: 2
[10:22:47.096] getGlobalsAndPackagesXApply() ...
[10:22:47.096]  - future.globals: <name-value list> with names ‘list()’
[10:22:47.097]  - use_args: TRUE
[10:22:47.097] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:22:47.097] List of 2
[10:22:47.097]  $ ...          : list()
[10:22:47.097]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:47.097]  $ ...future.FUN:function (x)  
[10:22:47.097]  - attr(*, "where")=List of 2
[10:22:47.097]   ..$ ...          :<environment: 0x55ca4ed86f08> 
[10:22:47.097]   ..$ ...future.FUN:<environment: namespace:base> 
[10:22:47.097]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:47.097]  - attr(*, "resolved")= logi FALSE
[10:22:47.097]  - attr(*, "total_size")= num NA
[10:22:47.100] Packages to be attached in all futures: [n=0] 
[10:22:47.100] getGlobalsAndPackagesXApply() ... DONE
[10:22:47.100] Number of futures (= number of chunks): 2
[10:22:47.101] Launching 2 futures (chunks) ...
[10:22:47.101] Chunk #1 of 2 ...
[10:22:47.101]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:47.101]  - seeds: <none>
[10:22:47.101]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.101] getGlobalsAndPackages() ...
[10:22:47.101] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.101] Resolving globals: FALSE
[10:22:47.102] Tweak future expression to call with '...' arguments ...
[10:22:47.102] {
[10:22:47.102]     do.call(function(...) {
[10:22:47.102]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.102]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:47.102]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.102]             on.exit(options(oopts), add = TRUE)
[10:22:47.102]         }
[10:22:47.102]         {
[10:22:47.102]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:47.102]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.102]                 ...future.FUN(...future.X_jj, ...)
[10:22:47.102]             })
[10:22:47.102]         }
[10:22:47.102]     }, args = future.call.arguments)
[10:22:47.102] }
[10:22:47.102] Tweak future expression to call with '...' arguments ... DONE
[10:22:47.102] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.102] 
[10:22:47.102] getGlobalsAndPackages() ... DONE
[10:22:47.103] run() for ‘Future’ ...
[10:22:47.103] - state: ‘created’
[10:22:47.103] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:47.117] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:47.117] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:47.117]   - Field: ‘node’
[10:22:47.118]   - Field: ‘label’
[10:22:47.118]   - Field: ‘local’
[10:22:47.118]   - Field: ‘owner’
[10:22:47.118]   - Field: ‘envir’
[10:22:47.118]   - Field: ‘workers’
[10:22:47.118]   - Field: ‘packages’
[10:22:47.118]   - Field: ‘gc’
[10:22:47.118]   - Field: ‘conditions’
[10:22:47.118]   - Field: ‘persistent’
[10:22:47.118]   - Field: ‘expr’
[10:22:47.118]   - Field: ‘uuid’
[10:22:47.119]   - Field: ‘seed’
[10:22:47.119]   - Field: ‘version’
[10:22:47.119]   - Field: ‘result’
[10:22:47.119]   - Field: ‘asynchronous’
[10:22:47.119]   - Field: ‘calls’
[10:22:47.119]   - Field: ‘globals’
[10:22:47.119]   - Field: ‘stdout’
[10:22:47.119]   - Field: ‘earlySignal’
[10:22:47.119]   - Field: ‘lazy’
[10:22:47.119]   - Field: ‘state’
[10:22:47.119] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:47.120] - Launch lazy future ...
[10:22:47.120] Packages needed by the future expression (n = 0): <none>
[10:22:47.120] Packages needed by future strategies (n = 0): <none>
[10:22:47.120] {
[10:22:47.120]     {
[10:22:47.120]         {
[10:22:47.120]             ...future.startTime <- base::Sys.time()
[10:22:47.120]             {
[10:22:47.120]                 {
[10:22:47.120]                   {
[10:22:47.120]                     {
[10:22:47.120]                       base::local({
[10:22:47.120]                         has_future <- base::requireNamespace("future", 
[10:22:47.120]                           quietly = TRUE)
[10:22:47.120]                         if (has_future) {
[10:22:47.120]                           ns <- base::getNamespace("future")
[10:22:47.120]                           version <- ns[[".package"]][["version"]]
[10:22:47.120]                           if (is.null(version)) 
[10:22:47.120]                             version <- utils::packageVersion("future")
[10:22:47.120]                         }
[10:22:47.120]                         else {
[10:22:47.120]                           version <- NULL
[10:22:47.120]                         }
[10:22:47.120]                         if (!has_future || version < "1.8.0") {
[10:22:47.120]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:47.120]                             "", base::R.version$version.string), 
[10:22:47.120]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:47.120]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:47.120]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:47.120]                               "release", "version")], collapse = " "), 
[10:22:47.120]                             hostname = base::Sys.info()[["nodename"]])
[10:22:47.120]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:47.120]                             info)
[10:22:47.120]                           info <- base::paste(info, collapse = "; ")
[10:22:47.120]                           if (!has_future) {
[10:22:47.120]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:47.120]                               info)
[10:22:47.120]                           }
[10:22:47.120]                           else {
[10:22:47.120]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:47.120]                               info, version)
[10:22:47.120]                           }
[10:22:47.120]                           base::stop(msg)
[10:22:47.120]                         }
[10:22:47.120]                       })
[10:22:47.120]                     }
[10:22:47.120]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:47.120]                     base::options(mc.cores = 1L)
[10:22:47.120]                   }
[10:22:47.120]                   options(future.plan = NULL)
[10:22:47.120]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:47.120]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:47.120]                 }
[10:22:47.120]                 ...future.workdir <- getwd()
[10:22:47.120]             }
[10:22:47.120]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:47.120]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:47.120]         }
[10:22:47.120]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:47.120]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:47.120]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:47.120]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:47.120]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:47.120]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:47.120]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:47.120]             base::names(...future.oldOptions))
[10:22:47.120]     }
[10:22:47.120]     if (FALSE) {
[10:22:47.120]     }
[10:22:47.120]     else {
[10:22:47.120]         if (TRUE) {
[10:22:47.120]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:47.120]                 open = "w")
[10:22:47.120]         }
[10:22:47.120]         else {
[10:22:47.120]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:47.120]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:47.120]         }
[10:22:47.120]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:47.120]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:47.120]             base::sink(type = "output", split = FALSE)
[10:22:47.120]             base::close(...future.stdout)
[10:22:47.120]         }, add = TRUE)
[10:22:47.120]     }
[10:22:47.120]     ...future.frame <- base::sys.nframe()
[10:22:47.120]     ...future.conditions <- base::list()
[10:22:47.120]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:47.120]     if (FALSE) {
[10:22:47.120]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:47.120]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:47.120]     }
[10:22:47.120]     ...future.result <- base::tryCatch({
[10:22:47.120]         base::withCallingHandlers({
[10:22:47.120]             ...future.value <- base::withVisible(base::local({
[10:22:47.120]                 ...future.makeSendCondition <- base::local({
[10:22:47.120]                   sendCondition <- NULL
[10:22:47.120]                   function(frame = 1L) {
[10:22:47.120]                     if (is.function(sendCondition)) 
[10:22:47.120]                       return(sendCondition)
[10:22:47.120]                     ns <- getNamespace("parallel")
[10:22:47.120]                     if (exists("sendData", mode = "function", 
[10:22:47.120]                       envir = ns)) {
[10:22:47.120]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:47.120]                         envir = ns)
[10:22:47.120]                       envir <- sys.frame(frame)
[10:22:47.120]                       master <- NULL
[10:22:47.120]                       while (!identical(envir, .GlobalEnv) && 
[10:22:47.120]                         !identical(envir, emptyenv())) {
[10:22:47.120]                         if (exists("master", mode = "list", envir = envir, 
[10:22:47.120]                           inherits = FALSE)) {
[10:22:47.120]                           master <- get("master", mode = "list", 
[10:22:47.120]                             envir = envir, inherits = FALSE)
[10:22:47.120]                           if (inherits(master, c("SOCKnode", 
[10:22:47.120]                             "SOCK0node"))) {
[10:22:47.120]                             sendCondition <<- function(cond) {
[10:22:47.120]                               data <- list(type = "VALUE", value = cond, 
[10:22:47.120]                                 success = TRUE)
[10:22:47.120]                               parallel_sendData(master, data)
[10:22:47.120]                             }
[10:22:47.120]                             return(sendCondition)
[10:22:47.120]                           }
[10:22:47.120]                         }
[10:22:47.120]                         frame <- frame + 1L
[10:22:47.120]                         envir <- sys.frame(frame)
[10:22:47.120]                       }
[10:22:47.120]                     }
[10:22:47.120]                     sendCondition <<- function(cond) NULL
[10:22:47.120]                   }
[10:22:47.120]                 })
[10:22:47.120]                 withCallingHandlers({
[10:22:47.120]                   {
[10:22:47.120]                     do.call(function(...) {
[10:22:47.120]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.120]                       if (!identical(...future.globals.maxSize.org, 
[10:22:47.120]                         ...future.globals.maxSize)) {
[10:22:47.120]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.120]                         on.exit(options(oopts), add = TRUE)
[10:22:47.120]                       }
[10:22:47.120]                       {
[10:22:47.120]                         lapply(seq_along(...future.elements_ii), 
[10:22:47.120]                           FUN = function(jj) {
[10:22:47.120]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.120]                             ...future.FUN(...future.X_jj, ...)
[10:22:47.120]                           })
[10:22:47.120]                       }
[10:22:47.120]                     }, args = future.call.arguments)
[10:22:47.120]                   }
[10:22:47.120]                 }, immediateCondition = function(cond) {
[10:22:47.120]                   sendCondition <- ...future.makeSendCondition()
[10:22:47.120]                   sendCondition(cond)
[10:22:47.120]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.120]                   {
[10:22:47.120]                     inherits <- base::inherits
[10:22:47.120]                     invokeRestart <- base::invokeRestart
[10:22:47.120]                     is.null <- base::is.null
[10:22:47.120]                     muffled <- FALSE
[10:22:47.120]                     if (inherits(cond, "message")) {
[10:22:47.120]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:47.120]                       if (muffled) 
[10:22:47.120]                         invokeRestart("muffleMessage")
[10:22:47.120]                     }
[10:22:47.120]                     else if (inherits(cond, "warning")) {
[10:22:47.120]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:47.120]                       if (muffled) 
[10:22:47.120]                         invokeRestart("muffleWarning")
[10:22:47.120]                     }
[10:22:47.120]                     else if (inherits(cond, "condition")) {
[10:22:47.120]                       if (!is.null(pattern)) {
[10:22:47.120]                         computeRestarts <- base::computeRestarts
[10:22:47.120]                         grepl <- base::grepl
[10:22:47.120]                         restarts <- computeRestarts(cond)
[10:22:47.120]                         for (restart in restarts) {
[10:22:47.120]                           name <- restart$name
[10:22:47.120]                           if (is.null(name)) 
[10:22:47.120]                             next
[10:22:47.120]                           if (!grepl(pattern, name)) 
[10:22:47.120]                             next
[10:22:47.120]                           invokeRestart(restart)
[10:22:47.120]                           muffled <- TRUE
[10:22:47.120]                           break
[10:22:47.120]                         }
[10:22:47.120]                       }
[10:22:47.120]                     }
[10:22:47.120]                     invisible(muffled)
[10:22:47.120]                   }
[10:22:47.120]                   muffleCondition(cond)
[10:22:47.120]                 })
[10:22:47.120]             }))
[10:22:47.120]             future::FutureResult(value = ...future.value$value, 
[10:22:47.120]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:47.120]                   ...future.rng), globalenv = if (FALSE) 
[10:22:47.120]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:47.120]                     ...future.globalenv.names))
[10:22:47.120]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:47.120]         }, condition = base::local({
[10:22:47.120]             c <- base::c
[10:22:47.120]             inherits <- base::inherits
[10:22:47.120]             invokeRestart <- base::invokeRestart
[10:22:47.120]             length <- base::length
[10:22:47.120]             list <- base::list
[10:22:47.120]             seq.int <- base::seq.int
[10:22:47.120]             signalCondition <- base::signalCondition
[10:22:47.120]             sys.calls <- base::sys.calls
[10:22:47.120]             `[[` <- base::`[[`
[10:22:47.120]             `+` <- base::`+`
[10:22:47.120]             `<<-` <- base::`<<-`
[10:22:47.120]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:47.120]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:47.120]                   3L)]
[10:22:47.120]             }
[10:22:47.120]             function(cond) {
[10:22:47.120]                 is_error <- inherits(cond, "error")
[10:22:47.120]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:47.120]                   NULL)
[10:22:47.120]                 if (is_error) {
[10:22:47.120]                   sessionInformation <- function() {
[10:22:47.120]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:47.120]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:47.120]                       search = base::search(), system = base::Sys.info())
[10:22:47.120]                   }
[10:22:47.120]                   ...future.conditions[[length(...future.conditions) + 
[10:22:47.120]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:47.120]                     cond$call), session = sessionInformation(), 
[10:22:47.120]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:47.120]                   signalCondition(cond)
[10:22:47.120]                 }
[10:22:47.120]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:47.120]                 "immediateCondition"))) {
[10:22:47.120]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:47.120]                   ...future.conditions[[length(...future.conditions) + 
[10:22:47.120]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:47.120]                   if (TRUE && !signal) {
[10:22:47.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.120]                     {
[10:22:47.120]                       inherits <- base::inherits
[10:22:47.120]                       invokeRestart <- base::invokeRestart
[10:22:47.120]                       is.null <- base::is.null
[10:22:47.120]                       muffled <- FALSE
[10:22:47.120]                       if (inherits(cond, "message")) {
[10:22:47.120]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:47.120]                         if (muffled) 
[10:22:47.120]                           invokeRestart("muffleMessage")
[10:22:47.120]                       }
[10:22:47.120]                       else if (inherits(cond, "warning")) {
[10:22:47.120]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:47.120]                         if (muffled) 
[10:22:47.120]                           invokeRestart("muffleWarning")
[10:22:47.120]                       }
[10:22:47.120]                       else if (inherits(cond, "condition")) {
[10:22:47.120]                         if (!is.null(pattern)) {
[10:22:47.120]                           computeRestarts <- base::computeRestarts
[10:22:47.120]                           grepl <- base::grepl
[10:22:47.120]                           restarts <- computeRestarts(cond)
[10:22:47.120]                           for (restart in restarts) {
[10:22:47.120]                             name <- restart$name
[10:22:47.120]                             if (is.null(name)) 
[10:22:47.120]                               next
[10:22:47.120]                             if (!grepl(pattern, name)) 
[10:22:47.120]                               next
[10:22:47.120]                             invokeRestart(restart)
[10:22:47.120]                             muffled <- TRUE
[10:22:47.120]                             break
[10:22:47.120]                           }
[10:22:47.120]                         }
[10:22:47.120]                       }
[10:22:47.120]                       invisible(muffled)
[10:22:47.120]                     }
[10:22:47.120]                     muffleCondition(cond, pattern = "^muffle")
[10:22:47.120]                   }
[10:22:47.120]                 }
[10:22:47.120]                 else {
[10:22:47.120]                   if (TRUE) {
[10:22:47.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.120]                     {
[10:22:47.120]                       inherits <- base::inherits
[10:22:47.120]                       invokeRestart <- base::invokeRestart
[10:22:47.120]                       is.null <- base::is.null
[10:22:47.120]                       muffled <- FALSE
[10:22:47.120]                       if (inherits(cond, "message")) {
[10:22:47.120]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:47.120]                         if (muffled) 
[10:22:47.120]                           invokeRestart("muffleMessage")
[10:22:47.120]                       }
[10:22:47.120]                       else if (inherits(cond, "warning")) {
[10:22:47.120]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:47.120]                         if (muffled) 
[10:22:47.120]                           invokeRestart("muffleWarning")
[10:22:47.120]                       }
[10:22:47.120]                       else if (inherits(cond, "condition")) {
[10:22:47.120]                         if (!is.null(pattern)) {
[10:22:47.120]                           computeRestarts <- base::computeRestarts
[10:22:47.120]                           grepl <- base::grepl
[10:22:47.120]                           restarts <- computeRestarts(cond)
[10:22:47.120]                           for (restart in restarts) {
[10:22:47.120]                             name <- restart$name
[10:22:47.120]                             if (is.null(name)) 
[10:22:47.120]                               next
[10:22:47.120]                             if (!grepl(pattern, name)) 
[10:22:47.120]                               next
[10:22:47.120]                             invokeRestart(restart)
[10:22:47.120]                             muffled <- TRUE
[10:22:47.120]                             break
[10:22:47.120]                           }
[10:22:47.120]                         }
[10:22:47.120]                       }
[10:22:47.120]                       invisible(muffled)
[10:22:47.120]                     }
[10:22:47.120]                     muffleCondition(cond, pattern = "^muffle")
[10:22:47.120]                   }
[10:22:47.120]                 }
[10:22:47.120]             }
[10:22:47.120]         }))
[10:22:47.120]     }, error = function(ex) {
[10:22:47.120]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:47.120]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:47.120]                 ...future.rng), started = ...future.startTime, 
[10:22:47.120]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:47.120]             version = "1.8"), class = "FutureResult")
[10:22:47.120]     }, finally = {
[10:22:47.120]         if (!identical(...future.workdir, getwd())) 
[10:22:47.120]             setwd(...future.workdir)
[10:22:47.120]         {
[10:22:47.120]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:47.120]                 ...future.oldOptions$nwarnings <- NULL
[10:22:47.120]             }
[10:22:47.120]             base::options(...future.oldOptions)
[10:22:47.120]             if (.Platform$OS.type == "windows") {
[10:22:47.120]                 old_names <- names(...future.oldEnvVars)
[10:22:47.120]                 envs <- base::Sys.getenv()
[10:22:47.120]                 names <- names(envs)
[10:22:47.120]                 common <- intersect(names, old_names)
[10:22:47.120]                 added <- setdiff(names, old_names)
[10:22:47.120]                 removed <- setdiff(old_names, names)
[10:22:47.120]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:47.120]                   envs[common]]
[10:22:47.120]                 NAMES <- toupper(changed)
[10:22:47.120]                 args <- list()
[10:22:47.120]                 for (kk in seq_along(NAMES)) {
[10:22:47.120]                   name <- changed[[kk]]
[10:22:47.120]                   NAME <- NAMES[[kk]]
[10:22:47.120]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.120]                     next
[10:22:47.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:47.120]                 }
[10:22:47.120]                 NAMES <- toupper(added)
[10:22:47.120]                 for (kk in seq_along(NAMES)) {
[10:22:47.120]                   name <- added[[kk]]
[10:22:47.120]                   NAME <- NAMES[[kk]]
[10:22:47.120]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.120]                     next
[10:22:47.120]                   args[[name]] <- ""
[10:22:47.120]                 }
[10:22:47.120]                 NAMES <- toupper(removed)
[10:22:47.120]                 for (kk in seq_along(NAMES)) {
[10:22:47.120]                   name <- removed[[kk]]
[10:22:47.120]                   NAME <- NAMES[[kk]]
[10:22:47.120]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.120]                     next
[10:22:47.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:47.120]                 }
[10:22:47.120]                 if (length(args) > 0) 
[10:22:47.120]                   base::do.call(base::Sys.setenv, args = args)
[10:22:47.120]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:47.120]             }
[10:22:47.120]             else {
[10:22:47.120]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:47.120]             }
[10:22:47.120]             {
[10:22:47.120]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:47.120]                   0L) {
[10:22:47.120]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:47.120]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:47.120]                   base::options(opts)
[10:22:47.120]                 }
[10:22:47.120]                 {
[10:22:47.120]                   {
[10:22:47.120]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:47.120]                     NULL
[10:22:47.120]                   }
[10:22:47.120]                   options(future.plan = NULL)
[10:22:47.120]                   if (is.na(NA_character_)) 
[10:22:47.120]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:47.120]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:47.120]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:47.120]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:47.120]                     envir = parent.frame()) 
[10:22:47.120]                   {
[10:22:47.120]                     if (is.function(workers)) 
[10:22:47.120]                       workers <- workers()
[10:22:47.120]                     workers <- structure(as.integer(workers), 
[10:22:47.120]                       class = class(workers))
[10:22:47.120]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:47.120]                       workers >= 1)
[10:22:47.120]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:47.120]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:47.120]                     }
[10:22:47.120]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:47.120]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:47.120]                       envir = envir)
[10:22:47.120]                     if (!future$lazy) 
[10:22:47.120]                       future <- run(future)
[10:22:47.120]                     invisible(future)
[10:22:47.120]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:47.120]                 }
[10:22:47.120]             }
[10:22:47.120]         }
[10:22:47.120]     })
[10:22:47.120]     if (TRUE) {
[10:22:47.120]         base::sink(type = "output", split = FALSE)
[10:22:47.120]         if (TRUE) {
[10:22:47.120]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:47.120]         }
[10:22:47.120]         else {
[10:22:47.120]             ...future.result["stdout"] <- base::list(NULL)
[10:22:47.120]         }
[10:22:47.120]         base::close(...future.stdout)
[10:22:47.120]         ...future.stdout <- NULL
[10:22:47.120]     }
[10:22:47.120]     ...future.result$conditions <- ...future.conditions
[10:22:47.120]     ...future.result$finished <- base::Sys.time()
[10:22:47.120]     ...future.result
[10:22:47.120] }
[10:22:47.123] Exporting 5 global objects (0.99 KiB) to cluster node #1 ...
[10:22:47.124] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:22:47.124] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:22:47.124] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[10:22:47.124] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[10:22:47.125] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[10:22:47.125] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[10:22:47.125] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:22:47.125] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:22:47.125] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[10:22:47.126] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[10:22:47.126] Exporting 5 global objects (0.99 KiB) to cluster node #1 ... DONE
[10:22:47.126] MultisessionFuture started
[10:22:47.126] - Launch lazy future ... done
[10:22:47.127] run() for ‘MultisessionFuture’ ... done
[10:22:47.127] Created future:
[10:22:47.127] MultisessionFuture:
[10:22:47.127] Label: ‘future_apply-1’
[10:22:47.127] Expression:
[10:22:47.127] {
[10:22:47.127]     do.call(function(...) {
[10:22:47.127]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.127]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:47.127]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.127]             on.exit(options(oopts), add = TRUE)
[10:22:47.127]         }
[10:22:47.127]         {
[10:22:47.127]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:47.127]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.127]                 ...future.FUN(...future.X_jj, ...)
[10:22:47.127]             })
[10:22:47.127]         }
[10:22:47.127]     }, args = future.call.arguments)
[10:22:47.127] }
[10:22:47.127] Lazy evaluation: FALSE
[10:22:47.127] Asynchronous evaluation: TRUE
[10:22:47.127] Local evaluation: TRUE
[10:22:47.127] Environment: R_GlobalEnv
[10:22:47.127] Capture standard output: TRUE
[10:22:47.127] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:47.127] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:47.127] Packages: <none>
[10:22:47.127] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:47.127] Resolved: FALSE
[10:22:47.127] Value: <not collected>
[10:22:47.127] Conditions captured: <none>
[10:22:47.127] Early signaling: FALSE
[10:22:47.127] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:47.127] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:47.138] Chunk #1 of 2 ... DONE
[10:22:47.138] Chunk #2 of 2 ...
[10:22:47.139]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:47.139]  - seeds: <none>
[10:22:47.139]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.139] getGlobalsAndPackages() ...
[10:22:47.139] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.139] Resolving globals: FALSE
[10:22:47.139] Tweak future expression to call with '...' arguments ...
[10:22:47.139] {
[10:22:47.139]     do.call(function(...) {
[10:22:47.139]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.139]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:47.139]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.139]             on.exit(options(oopts), add = TRUE)
[10:22:47.139]         }
[10:22:47.139]         {
[10:22:47.139]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:47.139]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.139]                 ...future.FUN(...future.X_jj, ...)
[10:22:47.139]             })
[10:22:47.139]         }
[10:22:47.139]     }, args = future.call.arguments)
[10:22:47.139] }
[10:22:47.140] Tweak future expression to call with '...' arguments ... DONE
[10:22:47.140] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.140] 
[10:22:47.140] getGlobalsAndPackages() ... DONE
[10:22:47.141] run() for ‘Future’ ...
[10:22:47.141] - state: ‘created’
[10:22:47.141] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:47.155] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:47.155] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:47.156]   - Field: ‘node’
[10:22:47.156]   - Field: ‘label’
[10:22:47.156]   - Field: ‘local’
[10:22:47.156]   - Field: ‘owner’
[10:22:47.156]   - Field: ‘envir’
[10:22:47.156]   - Field: ‘workers’
[10:22:47.156]   - Field: ‘packages’
[10:22:47.156]   - Field: ‘gc’
[10:22:47.156]   - Field: ‘conditions’
[10:22:47.156]   - Field: ‘persistent’
[10:22:47.157]   - Field: ‘expr’
[10:22:47.157]   - Field: ‘uuid’
[10:22:47.157]   - Field: ‘seed’
[10:22:47.157]   - Field: ‘version’
[10:22:47.157]   - Field: ‘result’
[10:22:47.157]   - Field: ‘asynchronous’
[10:22:47.157]   - Field: ‘calls’
[10:22:47.157]   - Field: ‘globals’
[10:22:47.157]   - Field: ‘stdout’
[10:22:47.157]   - Field: ‘earlySignal’
[10:22:47.158]   - Field: ‘lazy’
[10:22:47.158]   - Field: ‘state’
[10:22:47.158] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:47.158] - Launch lazy future ...
[10:22:47.158] Packages needed by the future expression (n = 0): <none>
[10:22:47.158] Packages needed by future strategies (n = 0): <none>
[10:22:47.159] {
[10:22:47.159]     {
[10:22:47.159]         {
[10:22:47.159]             ...future.startTime <- base::Sys.time()
[10:22:47.159]             {
[10:22:47.159]                 {
[10:22:47.159]                   {
[10:22:47.159]                     {
[10:22:47.159]                       base::local({
[10:22:47.159]                         has_future <- base::requireNamespace("future", 
[10:22:47.159]                           quietly = TRUE)
[10:22:47.159]                         if (has_future) {
[10:22:47.159]                           ns <- base::getNamespace("future")
[10:22:47.159]                           version <- ns[[".package"]][["version"]]
[10:22:47.159]                           if (is.null(version)) 
[10:22:47.159]                             version <- utils::packageVersion("future")
[10:22:47.159]                         }
[10:22:47.159]                         else {
[10:22:47.159]                           version <- NULL
[10:22:47.159]                         }
[10:22:47.159]                         if (!has_future || version < "1.8.0") {
[10:22:47.159]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:47.159]                             "", base::R.version$version.string), 
[10:22:47.159]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:47.159]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:47.159]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:47.159]                               "release", "version")], collapse = " "), 
[10:22:47.159]                             hostname = base::Sys.info()[["nodename"]])
[10:22:47.159]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:47.159]                             info)
[10:22:47.159]                           info <- base::paste(info, collapse = "; ")
[10:22:47.159]                           if (!has_future) {
[10:22:47.159]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:47.159]                               info)
[10:22:47.159]                           }
[10:22:47.159]                           else {
[10:22:47.159]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:47.159]                               info, version)
[10:22:47.159]                           }
[10:22:47.159]                           base::stop(msg)
[10:22:47.159]                         }
[10:22:47.159]                       })
[10:22:47.159]                     }
[10:22:47.159]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:47.159]                     base::options(mc.cores = 1L)
[10:22:47.159]                   }
[10:22:47.159]                   options(future.plan = NULL)
[10:22:47.159]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:47.159]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:47.159]                 }
[10:22:47.159]                 ...future.workdir <- getwd()
[10:22:47.159]             }
[10:22:47.159]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:47.159]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:47.159]         }
[10:22:47.159]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:47.159]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:47.159]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:47.159]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:47.159]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:47.159]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:47.159]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:47.159]             base::names(...future.oldOptions))
[10:22:47.159]     }
[10:22:47.159]     if (FALSE) {
[10:22:47.159]     }
[10:22:47.159]     else {
[10:22:47.159]         if (TRUE) {
[10:22:47.159]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:47.159]                 open = "w")
[10:22:47.159]         }
[10:22:47.159]         else {
[10:22:47.159]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:47.159]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:47.159]         }
[10:22:47.159]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:47.159]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:47.159]             base::sink(type = "output", split = FALSE)
[10:22:47.159]             base::close(...future.stdout)
[10:22:47.159]         }, add = TRUE)
[10:22:47.159]     }
[10:22:47.159]     ...future.frame <- base::sys.nframe()
[10:22:47.159]     ...future.conditions <- base::list()
[10:22:47.159]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:47.159]     if (FALSE) {
[10:22:47.159]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:47.159]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:47.159]     }
[10:22:47.159]     ...future.result <- base::tryCatch({
[10:22:47.159]         base::withCallingHandlers({
[10:22:47.159]             ...future.value <- base::withVisible(base::local({
[10:22:47.159]                 ...future.makeSendCondition <- base::local({
[10:22:47.159]                   sendCondition <- NULL
[10:22:47.159]                   function(frame = 1L) {
[10:22:47.159]                     if (is.function(sendCondition)) 
[10:22:47.159]                       return(sendCondition)
[10:22:47.159]                     ns <- getNamespace("parallel")
[10:22:47.159]                     if (exists("sendData", mode = "function", 
[10:22:47.159]                       envir = ns)) {
[10:22:47.159]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:47.159]                         envir = ns)
[10:22:47.159]                       envir <- sys.frame(frame)
[10:22:47.159]                       master <- NULL
[10:22:47.159]                       while (!identical(envir, .GlobalEnv) && 
[10:22:47.159]                         !identical(envir, emptyenv())) {
[10:22:47.159]                         if (exists("master", mode = "list", envir = envir, 
[10:22:47.159]                           inherits = FALSE)) {
[10:22:47.159]                           master <- get("master", mode = "list", 
[10:22:47.159]                             envir = envir, inherits = FALSE)
[10:22:47.159]                           if (inherits(master, c("SOCKnode", 
[10:22:47.159]                             "SOCK0node"))) {
[10:22:47.159]                             sendCondition <<- function(cond) {
[10:22:47.159]                               data <- list(type = "VALUE", value = cond, 
[10:22:47.159]                                 success = TRUE)
[10:22:47.159]                               parallel_sendData(master, data)
[10:22:47.159]                             }
[10:22:47.159]                             return(sendCondition)
[10:22:47.159]                           }
[10:22:47.159]                         }
[10:22:47.159]                         frame <- frame + 1L
[10:22:47.159]                         envir <- sys.frame(frame)
[10:22:47.159]                       }
[10:22:47.159]                     }
[10:22:47.159]                     sendCondition <<- function(cond) NULL
[10:22:47.159]                   }
[10:22:47.159]                 })
[10:22:47.159]                 withCallingHandlers({
[10:22:47.159]                   {
[10:22:47.159]                     do.call(function(...) {
[10:22:47.159]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.159]                       if (!identical(...future.globals.maxSize.org, 
[10:22:47.159]                         ...future.globals.maxSize)) {
[10:22:47.159]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.159]                         on.exit(options(oopts), add = TRUE)
[10:22:47.159]                       }
[10:22:47.159]                       {
[10:22:47.159]                         lapply(seq_along(...future.elements_ii), 
[10:22:47.159]                           FUN = function(jj) {
[10:22:47.159]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.159]                             ...future.FUN(...future.X_jj, ...)
[10:22:47.159]                           })
[10:22:47.159]                       }
[10:22:47.159]                     }, args = future.call.arguments)
[10:22:47.159]                   }
[10:22:47.159]                 }, immediateCondition = function(cond) {
[10:22:47.159]                   sendCondition <- ...future.makeSendCondition()
[10:22:47.159]                   sendCondition(cond)
[10:22:47.159]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.159]                   {
[10:22:47.159]                     inherits <- base::inherits
[10:22:47.159]                     invokeRestart <- base::invokeRestart
[10:22:47.159]                     is.null <- base::is.null
[10:22:47.159]                     muffled <- FALSE
[10:22:47.159]                     if (inherits(cond, "message")) {
[10:22:47.159]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:47.159]                       if (muffled) 
[10:22:47.159]                         invokeRestart("muffleMessage")
[10:22:47.159]                     }
[10:22:47.159]                     else if (inherits(cond, "warning")) {
[10:22:47.159]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:47.159]                       if (muffled) 
[10:22:47.159]                         invokeRestart("muffleWarning")
[10:22:47.159]                     }
[10:22:47.159]                     else if (inherits(cond, "condition")) {
[10:22:47.159]                       if (!is.null(pattern)) {
[10:22:47.159]                         computeRestarts <- base::computeRestarts
[10:22:47.159]                         grepl <- base::grepl
[10:22:47.159]                         restarts <- computeRestarts(cond)
[10:22:47.159]                         for (restart in restarts) {
[10:22:47.159]                           name <- restart$name
[10:22:47.159]                           if (is.null(name)) 
[10:22:47.159]                             next
[10:22:47.159]                           if (!grepl(pattern, name)) 
[10:22:47.159]                             next
[10:22:47.159]                           invokeRestart(restart)
[10:22:47.159]                           muffled <- TRUE
[10:22:47.159]                           break
[10:22:47.159]                         }
[10:22:47.159]                       }
[10:22:47.159]                     }
[10:22:47.159]                     invisible(muffled)
[10:22:47.159]                   }
[10:22:47.159]                   muffleCondition(cond)
[10:22:47.159]                 })
[10:22:47.159]             }))
[10:22:47.159]             future::FutureResult(value = ...future.value$value, 
[10:22:47.159]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:47.159]                   ...future.rng), globalenv = if (FALSE) 
[10:22:47.159]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:47.159]                     ...future.globalenv.names))
[10:22:47.159]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:47.159]         }, condition = base::local({
[10:22:47.159]             c <- base::c
[10:22:47.159]             inherits <- base::inherits
[10:22:47.159]             invokeRestart <- base::invokeRestart
[10:22:47.159]             length <- base::length
[10:22:47.159]             list <- base::list
[10:22:47.159]             seq.int <- base::seq.int
[10:22:47.159]             signalCondition <- base::signalCondition
[10:22:47.159]             sys.calls <- base::sys.calls
[10:22:47.159]             `[[` <- base::`[[`
[10:22:47.159]             `+` <- base::`+`
[10:22:47.159]             `<<-` <- base::`<<-`
[10:22:47.159]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:47.159]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:47.159]                   3L)]
[10:22:47.159]             }
[10:22:47.159]             function(cond) {
[10:22:47.159]                 is_error <- inherits(cond, "error")
[10:22:47.159]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:47.159]                   NULL)
[10:22:47.159]                 if (is_error) {
[10:22:47.159]                   sessionInformation <- function() {
[10:22:47.159]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:47.159]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:47.159]                       search = base::search(), system = base::Sys.info())
[10:22:47.159]                   }
[10:22:47.159]                   ...future.conditions[[length(...future.conditions) + 
[10:22:47.159]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:47.159]                     cond$call), session = sessionInformation(), 
[10:22:47.159]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:47.159]                   signalCondition(cond)
[10:22:47.159]                 }
[10:22:47.159]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:47.159]                 "immediateCondition"))) {
[10:22:47.159]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:47.159]                   ...future.conditions[[length(...future.conditions) + 
[10:22:47.159]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:47.159]                   if (TRUE && !signal) {
[10:22:47.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.159]                     {
[10:22:47.159]                       inherits <- base::inherits
[10:22:47.159]                       invokeRestart <- base::invokeRestart
[10:22:47.159]                       is.null <- base::is.null
[10:22:47.159]                       muffled <- FALSE
[10:22:47.159]                       if (inherits(cond, "message")) {
[10:22:47.159]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:47.159]                         if (muffled) 
[10:22:47.159]                           invokeRestart("muffleMessage")
[10:22:47.159]                       }
[10:22:47.159]                       else if (inherits(cond, "warning")) {
[10:22:47.159]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:47.159]                         if (muffled) 
[10:22:47.159]                           invokeRestart("muffleWarning")
[10:22:47.159]                       }
[10:22:47.159]                       else if (inherits(cond, "condition")) {
[10:22:47.159]                         if (!is.null(pattern)) {
[10:22:47.159]                           computeRestarts <- base::computeRestarts
[10:22:47.159]                           grepl <- base::grepl
[10:22:47.159]                           restarts <- computeRestarts(cond)
[10:22:47.159]                           for (restart in restarts) {
[10:22:47.159]                             name <- restart$name
[10:22:47.159]                             if (is.null(name)) 
[10:22:47.159]                               next
[10:22:47.159]                             if (!grepl(pattern, name)) 
[10:22:47.159]                               next
[10:22:47.159]                             invokeRestart(restart)
[10:22:47.159]                             muffled <- TRUE
[10:22:47.159]                             break
[10:22:47.159]                           }
[10:22:47.159]                         }
[10:22:47.159]                       }
[10:22:47.159]                       invisible(muffled)
[10:22:47.159]                     }
[10:22:47.159]                     muffleCondition(cond, pattern = "^muffle")
[10:22:47.159]                   }
[10:22:47.159]                 }
[10:22:47.159]                 else {
[10:22:47.159]                   if (TRUE) {
[10:22:47.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.159]                     {
[10:22:47.159]                       inherits <- base::inherits
[10:22:47.159]                       invokeRestart <- base::invokeRestart
[10:22:47.159]                       is.null <- base::is.null
[10:22:47.159]                       muffled <- FALSE
[10:22:47.159]                       if (inherits(cond, "message")) {
[10:22:47.159]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:47.159]                         if (muffled) 
[10:22:47.159]                           invokeRestart("muffleMessage")
[10:22:47.159]                       }
[10:22:47.159]                       else if (inherits(cond, "warning")) {
[10:22:47.159]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:47.159]                         if (muffled) 
[10:22:47.159]                           invokeRestart("muffleWarning")
[10:22:47.159]                       }
[10:22:47.159]                       else if (inherits(cond, "condition")) {
[10:22:47.159]                         if (!is.null(pattern)) {
[10:22:47.159]                           computeRestarts <- base::computeRestarts
[10:22:47.159]                           grepl <- base::grepl
[10:22:47.159]                           restarts <- computeRestarts(cond)
[10:22:47.159]                           for (restart in restarts) {
[10:22:47.159]                             name <- restart$name
[10:22:47.159]                             if (is.null(name)) 
[10:22:47.159]                               next
[10:22:47.159]                             if (!grepl(pattern, name)) 
[10:22:47.159]                               next
[10:22:47.159]                             invokeRestart(restart)
[10:22:47.159]                             muffled <- TRUE
[10:22:47.159]                             break
[10:22:47.159]                           }
[10:22:47.159]                         }
[10:22:47.159]                       }
[10:22:47.159]                       invisible(muffled)
[10:22:47.159]                     }
[10:22:47.159]                     muffleCondition(cond, pattern = "^muffle")
[10:22:47.159]                   }
[10:22:47.159]                 }
[10:22:47.159]             }
[10:22:47.159]         }))
[10:22:47.159]     }, error = function(ex) {
[10:22:47.159]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:47.159]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:47.159]                 ...future.rng), started = ...future.startTime, 
[10:22:47.159]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:47.159]             version = "1.8"), class = "FutureResult")
[10:22:47.159]     }, finally = {
[10:22:47.159]         if (!identical(...future.workdir, getwd())) 
[10:22:47.159]             setwd(...future.workdir)
[10:22:47.159]         {
[10:22:47.159]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:47.159]                 ...future.oldOptions$nwarnings <- NULL
[10:22:47.159]             }
[10:22:47.159]             base::options(...future.oldOptions)
[10:22:47.159]             if (.Platform$OS.type == "windows") {
[10:22:47.159]                 old_names <- names(...future.oldEnvVars)
[10:22:47.159]                 envs <- base::Sys.getenv()
[10:22:47.159]                 names <- names(envs)
[10:22:47.159]                 common <- intersect(names, old_names)
[10:22:47.159]                 added <- setdiff(names, old_names)
[10:22:47.159]                 removed <- setdiff(old_names, names)
[10:22:47.159]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:47.159]                   envs[common]]
[10:22:47.159]                 NAMES <- toupper(changed)
[10:22:47.159]                 args <- list()
[10:22:47.159]                 for (kk in seq_along(NAMES)) {
[10:22:47.159]                   name <- changed[[kk]]
[10:22:47.159]                   NAME <- NAMES[[kk]]
[10:22:47.159]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.159]                     next
[10:22:47.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:47.159]                 }
[10:22:47.159]                 NAMES <- toupper(added)
[10:22:47.159]                 for (kk in seq_along(NAMES)) {
[10:22:47.159]                   name <- added[[kk]]
[10:22:47.159]                   NAME <- NAMES[[kk]]
[10:22:47.159]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.159]                     next
[10:22:47.159]                   args[[name]] <- ""
[10:22:47.159]                 }
[10:22:47.159]                 NAMES <- toupper(removed)
[10:22:47.159]                 for (kk in seq_along(NAMES)) {
[10:22:47.159]                   name <- removed[[kk]]
[10:22:47.159]                   NAME <- NAMES[[kk]]
[10:22:47.159]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.159]                     next
[10:22:47.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:47.159]                 }
[10:22:47.159]                 if (length(args) > 0) 
[10:22:47.159]                   base::do.call(base::Sys.setenv, args = args)
[10:22:47.159]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:47.159]             }
[10:22:47.159]             else {
[10:22:47.159]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:47.159]             }
[10:22:47.159]             {
[10:22:47.159]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:47.159]                   0L) {
[10:22:47.159]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:47.159]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:47.159]                   base::options(opts)
[10:22:47.159]                 }
[10:22:47.159]                 {
[10:22:47.159]                   {
[10:22:47.159]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:47.159]                     NULL
[10:22:47.159]                   }
[10:22:47.159]                   options(future.plan = NULL)
[10:22:47.159]                   if (is.na(NA_character_)) 
[10:22:47.159]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:47.159]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:47.159]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:47.159]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:47.159]                     envir = parent.frame()) 
[10:22:47.159]                   {
[10:22:47.159]                     if (is.function(workers)) 
[10:22:47.159]                       workers <- workers()
[10:22:47.159]                     workers <- structure(as.integer(workers), 
[10:22:47.159]                       class = class(workers))
[10:22:47.159]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:47.159]                       workers >= 1)
[10:22:47.159]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:47.159]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:47.159]                     }
[10:22:47.159]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:47.159]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:47.159]                       envir = envir)
[10:22:47.159]                     if (!future$lazy) 
[10:22:47.159]                       future <- run(future)
[10:22:47.159]                     invisible(future)
[10:22:47.159]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:47.159]                 }
[10:22:47.159]             }
[10:22:47.159]         }
[10:22:47.159]     })
[10:22:47.159]     if (TRUE) {
[10:22:47.159]         base::sink(type = "output", split = FALSE)
[10:22:47.159]         if (TRUE) {
[10:22:47.159]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:47.159]         }
[10:22:47.159]         else {
[10:22:47.159]             ...future.result["stdout"] <- base::list(NULL)
[10:22:47.159]         }
[10:22:47.159]         base::close(...future.stdout)
[10:22:47.159]         ...future.stdout <- NULL
[10:22:47.159]     }
[10:22:47.159]     ...future.result$conditions <- ...future.conditions
[10:22:47.159]     ...future.result$finished <- base::Sys.time()
[10:22:47.159]     ...future.result
[10:22:47.159] }
[10:22:47.162] Exporting 5 global objects (0.99 KiB) to cluster node #2 ...
[10:22:47.162] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:22:47.162] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:22:47.163] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[10:22:47.163] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[10:22:47.163] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[10:22:47.163] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[10:22:47.164] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:22:47.164] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:22:47.164] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[10:22:47.164] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[10:22:47.165] Exporting 5 global objects (0.99 KiB) to cluster node #2 ... DONE
[10:22:47.165] MultisessionFuture started
[10:22:47.165] - Launch lazy future ... done
[10:22:47.166] run() for ‘MultisessionFuture’ ... done
[10:22:47.166] Created future:
[10:22:47.166] MultisessionFuture:
[10:22:47.166] Label: ‘future_apply-2’
[10:22:47.166] Expression:
[10:22:47.166] {
[10:22:47.166]     do.call(function(...) {
[10:22:47.166]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.166]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:47.166]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.166]             on.exit(options(oopts), add = TRUE)
[10:22:47.166]         }
[10:22:47.166]         {
[10:22:47.166]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:47.166]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.166]                 ...future.FUN(...future.X_jj, ...)
[10:22:47.166]             })
[10:22:47.166]         }
[10:22:47.166]     }, args = future.call.arguments)
[10:22:47.166] }
[10:22:47.166] Lazy evaluation: FALSE
[10:22:47.166] Asynchronous evaluation: TRUE
[10:22:47.166] Local evaluation: TRUE
[10:22:47.166] Environment: R_GlobalEnv
[10:22:47.166] Capture standard output: TRUE
[10:22:47.166] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:47.166] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:47.166] Packages: <none>
[10:22:47.166] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:47.166] Resolved: FALSE
[10:22:47.166] Value: <not collected>
[10:22:47.166] Conditions captured: <none>
[10:22:47.166] Early signaling: FALSE
[10:22:47.166] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:47.166] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:47.177] Chunk #2 of 2 ... DONE
[10:22:47.178] Launching 2 futures (chunks) ... DONE
[10:22:47.178] Resolving 2 futures (chunks) ...
[10:22:47.178] resolve() on list ...
[10:22:47.178]  recursive: 0
[10:22:47.178]  length: 2
[10:22:47.178] 
[10:22:47.179] receiveMessageFromWorker() for ClusterFuture ...
[10:22:47.179] - Validating connection of MultisessionFuture
[10:22:47.179] - received message: FutureResult
[10:22:47.179] - Received FutureResult
[10:22:47.179] - Erased future from FutureRegistry
[10:22:47.179] result() for ClusterFuture ...
[10:22:47.179] - result already collected: FutureResult
[10:22:47.179] result() for ClusterFuture ... done
[10:22:47.179] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:47.180] Future #1
[10:22:47.180] result() for ClusterFuture ...
[10:22:47.180] - result already collected: FutureResult
[10:22:47.180] result() for ClusterFuture ... done
[10:22:47.180] result() for ClusterFuture ...
[10:22:47.180] - result already collected: FutureResult
[10:22:47.180] result() for ClusterFuture ... done
[10:22:47.180] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:22:47.180] - nx: 2
[10:22:47.180] - relay: TRUE
[10:22:47.180] - stdout: TRUE
[10:22:47.181] - signal: TRUE
[10:22:47.181] - resignal: FALSE
[10:22:47.181] - force: TRUE
[10:22:47.181] - relayed: [n=2] FALSE, FALSE
[10:22:47.181] - queued futures: [n=2] FALSE, FALSE
[10:22:47.181]  - until=1
[10:22:47.181]  - relaying element #1
[10:22:47.181] result() for ClusterFuture ...
[10:22:47.181] - result already collected: FutureResult
[10:22:47.181] result() for ClusterFuture ... done
[10:22:47.181] result() for ClusterFuture ...
[10:22:47.182] - result already collected: FutureResult
[10:22:47.182] result() for ClusterFuture ... done
[10:22:47.182] result() for ClusterFuture ...
[10:22:47.182] - result already collected: FutureResult
[10:22:47.182] result() for ClusterFuture ... done
[10:22:47.182] result() for ClusterFuture ...
[10:22:47.182] - result already collected: FutureResult
[10:22:47.182] result() for ClusterFuture ... done
[10:22:47.182] - relayed: [n=2] TRUE, FALSE
[10:22:47.182] - queued futures: [n=2] TRUE, FALSE
[10:22:47.182] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:22:47.183]  length: 1 (resolved future 1)
[10:22:47.210] receiveMessageFromWorker() for ClusterFuture ...
[10:22:47.210] - Validating connection of MultisessionFuture
[10:22:47.211] - received message: FutureResult
[10:22:47.211] - Received FutureResult
[10:22:47.211] - Erased future from FutureRegistry
[10:22:47.211] result() for ClusterFuture ...
[10:22:47.211] - result already collected: FutureResult
[10:22:47.211] result() for ClusterFuture ... done
[10:22:47.211] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:47.211] Future #2
[10:22:47.211] result() for ClusterFuture ...
[10:22:47.211] - result already collected: FutureResult
[10:22:47.212] result() for ClusterFuture ... done
[10:22:47.212] result() for ClusterFuture ...
[10:22:47.212] - result already collected: FutureResult
[10:22:47.212] result() for ClusterFuture ... done
[10:22:47.212] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:22:47.212] - nx: 2
[10:22:47.212] - relay: TRUE
[10:22:47.212] - stdout: TRUE
[10:22:47.212] - signal: TRUE
[10:22:47.212] - resignal: FALSE
[10:22:47.212] - force: TRUE
[10:22:47.212] - relayed: [n=2] TRUE, FALSE
[10:22:47.213] - queued futures: [n=2] TRUE, FALSE
[10:22:47.213]  - until=2
[10:22:47.213]  - relaying element #2
[10:22:47.213] result() for ClusterFuture ...
[10:22:47.213] - result already collected: FutureResult
[10:22:47.213] result() for ClusterFuture ... done
[10:22:47.213] result() for ClusterFuture ...
[10:22:47.213] - result already collected: FutureResult
[10:22:47.213] result() for ClusterFuture ... done
[10:22:47.213] result() for ClusterFuture ...
[10:22:47.214] - result already collected: FutureResult
[10:22:47.214] result() for ClusterFuture ... done
[10:22:47.214] result() for ClusterFuture ...
[10:22:47.214] - result already collected: FutureResult
[10:22:47.214] result() for ClusterFuture ... done
[10:22:47.214] - relayed: [n=2] TRUE, TRUE
[10:22:47.214] - queued futures: [n=2] TRUE, TRUE
[10:22:47.214] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:22:47.214]  length: 0 (resolved future 2)
[10:22:47.214] Relaying remaining futures
[10:22:47.214] signalConditionsASAP(NULL, pos=0) ...
[10:22:47.215] - nx: 2
[10:22:47.215] - relay: TRUE
[10:22:47.215] - stdout: TRUE
[10:22:47.215] - signal: TRUE
[10:22:47.215] - resignal: FALSE
[10:22:47.215] - force: TRUE
[10:22:47.215] - relayed: [n=2] TRUE, TRUE
[10:22:47.215] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:22:47.215] - relayed: [n=2] TRUE, TRUE
[10:22:47.215] - queued futures: [n=2] TRUE, TRUE
[10:22:47.215] signalConditionsASAP(NULL, pos=0) ... done
[10:22:47.216] resolve() on list ... DONE
[10:22:47.216] result() for ClusterFuture ...
[10:22:47.216] - result already collected: FutureResult
[10:22:47.216] result() for ClusterFuture ... done
[10:22:47.216] result() for ClusterFuture ...
[10:22:47.216] - result already collected: FutureResult
[10:22:47.216] result() for ClusterFuture ... done
[10:22:47.216] result() for ClusterFuture ...
[10:22:47.216] - result already collected: FutureResult
[10:22:47.216] result() for ClusterFuture ... done
[10:22:47.216] result() for ClusterFuture ...
[10:22:47.217] - result already collected: FutureResult
[10:22:47.217] result() for ClusterFuture ... done
[10:22:47.217]  - Number of value chunks collected: 2
[10:22:47.217] Resolving 2 futures (chunks) ... DONE
[10:22:47.217] Reducing values from 2 chunks ...
[10:22:47.217]  - Number of values collected after concatenation: 2
[10:22:47.217]  - Number of values expected: 2
[10:22:47.217] Reducing values from 2 chunks ... DONE
[10:22:47.217] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[10:22:47.218] getGlobalsAndPackagesXApply() ...
[10:22:47.218]  - future.globals: TRUE
[10:22:47.218] getGlobalsAndPackages() ...
[10:22:47.218] Searching for globals...
[10:22:47.219] - globals found: [1] ‘FUN’
[10:22:47.219] Searching for globals ... DONE
[10:22:47.219] Resolving globals: FALSE
[10:22:47.220] The total size of the 1 globals is 848 bytes (848 bytes)
[10:22:47.220] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:22:47.220] - globals: [1] ‘FUN’
[10:22:47.220] 
[10:22:47.220] getGlobalsAndPackages() ... DONE
[10:22:47.220]  - globals found/used: [n=1] ‘FUN’
[10:22:47.220]  - needed namespaces: [n=0] 
[10:22:47.221] Finding globals ... DONE
[10:22:47.221]  - use_args: TRUE
[10:22:47.221]  - Getting '...' globals ...
[10:22:47.221] resolve() on list ...
[10:22:47.221]  recursive: 0
[10:22:47.221]  length: 1
[10:22:47.221]  elements: ‘...’
[10:22:47.221]  length: 0 (resolved future 1)
[10:22:47.222] resolve() on list ... DONE
[10:22:47.222]    - '...' content: [n=0] 
[10:22:47.222] List of 1
[10:22:47.222]  $ ...: list()
[10:22:47.222]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:47.222]  - attr(*, "where")=List of 1
[10:22:47.222]   ..$ ...:<environment: 0x55ca4e4e4d48> 
[10:22:47.222]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:47.222]  - attr(*, "resolved")= logi TRUE
[10:22:47.222]  - attr(*, "total_size")= num NA
[10:22:47.224]  - Getting '...' globals ... DONE
[10:22:47.225] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:47.225] List of 2
[10:22:47.225]  $ ...future.FUN:function (x)  
[10:22:47.225]  $ ...          : list()
[10:22:47.225]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:47.225]  - attr(*, "where")=List of 2
[10:22:47.225]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:47.225]   ..$ ...          :<environment: 0x55ca4e4e4d48> 
[10:22:47.225]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:47.225]  - attr(*, "resolved")= logi FALSE
[10:22:47.225]  - attr(*, "total_size")= num 848
[10:22:47.227] Packages to be attached in all futures: [n=0] 
[10:22:47.227] getGlobalsAndPackagesXApply() ... DONE
[10:22:47.231] future_lapply() ...
[10:22:47.235] Number of chunks: 2
[10:22:47.235] getGlobalsAndPackagesXApply() ...
[10:22:47.235]  - future.globals: <name-value list> with names ‘list()’
[10:22:47.235]  - use_args: TRUE
[10:22:47.235] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:22:47.235] List of 2
[10:22:47.235]  $ ...          : list()
[10:22:47.235]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:47.235]  $ ...future.FUN:function (x)  
[10:22:47.235]  - attr(*, "where")=List of 2
[10:22:47.235]   ..$ ...          :<environment: 0x55ca4e4e4d48> 
[10:22:47.235]   ..$ ...future.FUN:<environment: namespace:base> 
[10:22:47.235]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:47.235]  - attr(*, "resolved")= logi FALSE
[10:22:47.235]  - attr(*, "total_size")= num NA
[10:22:47.239] Packages to be attached in all futures: [n=0] 
[10:22:47.239] getGlobalsAndPackagesXApply() ... DONE
[10:22:47.239] Number of futures (= number of chunks): 2
[10:22:47.239] Launching 2 futures (chunks) ...
[10:22:47.240] Chunk #1 of 2 ...
[10:22:47.240]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:47.240]  - seeds: <none>
[10:22:47.240]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.240] getGlobalsAndPackages() ...
[10:22:47.240] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.240] Resolving globals: FALSE
[10:22:47.240] Tweak future expression to call with '...' arguments ...
[10:22:47.240] {
[10:22:47.240]     do.call(function(...) {
[10:22:47.240]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.240]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:47.240]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.240]             on.exit(options(oopts), add = TRUE)
[10:22:47.240]         }
[10:22:47.240]         {
[10:22:47.240]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:47.240]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.240]                 ...future.FUN(...future.X_jj, ...)
[10:22:47.240]             })
[10:22:47.240]         }
[10:22:47.240]     }, args = future.call.arguments)
[10:22:47.240] }
[10:22:47.241] Tweak future expression to call with '...' arguments ... DONE
[10:22:47.241] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.241] 
[10:22:47.241] getGlobalsAndPackages() ... DONE
[10:22:47.242] run() for ‘Future’ ...
[10:22:47.242] - state: ‘created’
[10:22:47.242] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:47.256] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:47.256] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:47.256]   - Field: ‘node’
[10:22:47.256]   - Field: ‘label’
[10:22:47.256]   - Field: ‘local’
[10:22:47.256]   - Field: ‘owner’
[10:22:47.256]   - Field: ‘envir’
[10:22:47.257]   - Field: ‘workers’
[10:22:47.257]   - Field: ‘packages’
[10:22:47.257]   - Field: ‘gc’
[10:22:47.257]   - Field: ‘conditions’
[10:22:47.257]   - Field: ‘persistent’
[10:22:47.257]   - Field: ‘expr’
[10:22:47.257]   - Field: ‘uuid’
[10:22:47.257]   - Field: ‘seed’
[10:22:47.257]   - Field: ‘version’
[10:22:47.258]   - Field: ‘result’
[10:22:47.258]   - Field: ‘asynchronous’
[10:22:47.258]   - Field: ‘calls’
[10:22:47.258]   - Field: ‘globals’
[10:22:47.258]   - Field: ‘stdout’
[10:22:47.258]   - Field: ‘earlySignal’
[10:22:47.258]   - Field: ‘lazy’
[10:22:47.258]   - Field: ‘state’
[10:22:47.258] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:47.258] - Launch lazy future ...
[10:22:47.259] Packages needed by the future expression (n = 0): <none>
[10:22:47.259] Packages needed by future strategies (n = 0): <none>
[10:22:47.259] {
[10:22:47.259]     {
[10:22:47.259]         {
[10:22:47.259]             ...future.startTime <- base::Sys.time()
[10:22:47.259]             {
[10:22:47.259]                 {
[10:22:47.259]                   {
[10:22:47.259]                     {
[10:22:47.259]                       base::local({
[10:22:47.259]                         has_future <- base::requireNamespace("future", 
[10:22:47.259]                           quietly = TRUE)
[10:22:47.259]                         if (has_future) {
[10:22:47.259]                           ns <- base::getNamespace("future")
[10:22:47.259]                           version <- ns[[".package"]][["version"]]
[10:22:47.259]                           if (is.null(version)) 
[10:22:47.259]                             version <- utils::packageVersion("future")
[10:22:47.259]                         }
[10:22:47.259]                         else {
[10:22:47.259]                           version <- NULL
[10:22:47.259]                         }
[10:22:47.259]                         if (!has_future || version < "1.8.0") {
[10:22:47.259]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:47.259]                             "", base::R.version$version.string), 
[10:22:47.259]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:47.259]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:47.259]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:47.259]                               "release", "version")], collapse = " "), 
[10:22:47.259]                             hostname = base::Sys.info()[["nodename"]])
[10:22:47.259]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:47.259]                             info)
[10:22:47.259]                           info <- base::paste(info, collapse = "; ")
[10:22:47.259]                           if (!has_future) {
[10:22:47.259]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:47.259]                               info)
[10:22:47.259]                           }
[10:22:47.259]                           else {
[10:22:47.259]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:47.259]                               info, version)
[10:22:47.259]                           }
[10:22:47.259]                           base::stop(msg)
[10:22:47.259]                         }
[10:22:47.259]                       })
[10:22:47.259]                     }
[10:22:47.259]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:47.259]                     base::options(mc.cores = 1L)
[10:22:47.259]                   }
[10:22:47.259]                   options(future.plan = NULL)
[10:22:47.259]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:47.259]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:47.259]                 }
[10:22:47.259]                 ...future.workdir <- getwd()
[10:22:47.259]             }
[10:22:47.259]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:47.259]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:47.259]         }
[10:22:47.259]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:47.259]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:47.259]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:47.259]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:47.259]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:47.259]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:47.259]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:47.259]             base::names(...future.oldOptions))
[10:22:47.259]     }
[10:22:47.259]     if (FALSE) {
[10:22:47.259]     }
[10:22:47.259]     else {
[10:22:47.259]         if (TRUE) {
[10:22:47.259]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:47.259]                 open = "w")
[10:22:47.259]         }
[10:22:47.259]         else {
[10:22:47.259]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:47.259]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:47.259]         }
[10:22:47.259]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:47.259]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:47.259]             base::sink(type = "output", split = FALSE)
[10:22:47.259]             base::close(...future.stdout)
[10:22:47.259]         }, add = TRUE)
[10:22:47.259]     }
[10:22:47.259]     ...future.frame <- base::sys.nframe()
[10:22:47.259]     ...future.conditions <- base::list()
[10:22:47.259]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:47.259]     if (FALSE) {
[10:22:47.259]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:47.259]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:47.259]     }
[10:22:47.259]     ...future.result <- base::tryCatch({
[10:22:47.259]         base::withCallingHandlers({
[10:22:47.259]             ...future.value <- base::withVisible(base::local({
[10:22:47.259]                 ...future.makeSendCondition <- base::local({
[10:22:47.259]                   sendCondition <- NULL
[10:22:47.259]                   function(frame = 1L) {
[10:22:47.259]                     if (is.function(sendCondition)) 
[10:22:47.259]                       return(sendCondition)
[10:22:47.259]                     ns <- getNamespace("parallel")
[10:22:47.259]                     if (exists("sendData", mode = "function", 
[10:22:47.259]                       envir = ns)) {
[10:22:47.259]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:47.259]                         envir = ns)
[10:22:47.259]                       envir <- sys.frame(frame)
[10:22:47.259]                       master <- NULL
[10:22:47.259]                       while (!identical(envir, .GlobalEnv) && 
[10:22:47.259]                         !identical(envir, emptyenv())) {
[10:22:47.259]                         if (exists("master", mode = "list", envir = envir, 
[10:22:47.259]                           inherits = FALSE)) {
[10:22:47.259]                           master <- get("master", mode = "list", 
[10:22:47.259]                             envir = envir, inherits = FALSE)
[10:22:47.259]                           if (inherits(master, c("SOCKnode", 
[10:22:47.259]                             "SOCK0node"))) {
[10:22:47.259]                             sendCondition <<- function(cond) {
[10:22:47.259]                               data <- list(type = "VALUE", value = cond, 
[10:22:47.259]                                 success = TRUE)
[10:22:47.259]                               parallel_sendData(master, data)
[10:22:47.259]                             }
[10:22:47.259]                             return(sendCondition)
[10:22:47.259]                           }
[10:22:47.259]                         }
[10:22:47.259]                         frame <- frame + 1L
[10:22:47.259]                         envir <- sys.frame(frame)
[10:22:47.259]                       }
[10:22:47.259]                     }
[10:22:47.259]                     sendCondition <<- function(cond) NULL
[10:22:47.259]                   }
[10:22:47.259]                 })
[10:22:47.259]                 withCallingHandlers({
[10:22:47.259]                   {
[10:22:47.259]                     do.call(function(...) {
[10:22:47.259]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.259]                       if (!identical(...future.globals.maxSize.org, 
[10:22:47.259]                         ...future.globals.maxSize)) {
[10:22:47.259]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.259]                         on.exit(options(oopts), add = TRUE)
[10:22:47.259]                       }
[10:22:47.259]                       {
[10:22:47.259]                         lapply(seq_along(...future.elements_ii), 
[10:22:47.259]                           FUN = function(jj) {
[10:22:47.259]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.259]                             ...future.FUN(...future.X_jj, ...)
[10:22:47.259]                           })
[10:22:47.259]                       }
[10:22:47.259]                     }, args = future.call.arguments)
[10:22:47.259]                   }
[10:22:47.259]                 }, immediateCondition = function(cond) {
[10:22:47.259]                   sendCondition <- ...future.makeSendCondition()
[10:22:47.259]                   sendCondition(cond)
[10:22:47.259]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.259]                   {
[10:22:47.259]                     inherits <- base::inherits
[10:22:47.259]                     invokeRestart <- base::invokeRestart
[10:22:47.259]                     is.null <- base::is.null
[10:22:47.259]                     muffled <- FALSE
[10:22:47.259]                     if (inherits(cond, "message")) {
[10:22:47.259]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:47.259]                       if (muffled) 
[10:22:47.259]                         invokeRestart("muffleMessage")
[10:22:47.259]                     }
[10:22:47.259]                     else if (inherits(cond, "warning")) {
[10:22:47.259]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:47.259]                       if (muffled) 
[10:22:47.259]                         invokeRestart("muffleWarning")
[10:22:47.259]                     }
[10:22:47.259]                     else if (inherits(cond, "condition")) {
[10:22:47.259]                       if (!is.null(pattern)) {
[10:22:47.259]                         computeRestarts <- base::computeRestarts
[10:22:47.259]                         grepl <- base::grepl
[10:22:47.259]                         restarts <- computeRestarts(cond)
[10:22:47.259]                         for (restart in restarts) {
[10:22:47.259]                           name <- restart$name
[10:22:47.259]                           if (is.null(name)) 
[10:22:47.259]                             next
[10:22:47.259]                           if (!grepl(pattern, name)) 
[10:22:47.259]                             next
[10:22:47.259]                           invokeRestart(restart)
[10:22:47.259]                           muffled <- TRUE
[10:22:47.259]                           break
[10:22:47.259]                         }
[10:22:47.259]                       }
[10:22:47.259]                     }
[10:22:47.259]                     invisible(muffled)
[10:22:47.259]                   }
[10:22:47.259]                   muffleCondition(cond)
[10:22:47.259]                 })
[10:22:47.259]             }))
[10:22:47.259]             future::FutureResult(value = ...future.value$value, 
[10:22:47.259]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:47.259]                   ...future.rng), globalenv = if (FALSE) 
[10:22:47.259]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:47.259]                     ...future.globalenv.names))
[10:22:47.259]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:47.259]         }, condition = base::local({
[10:22:47.259]             c <- base::c
[10:22:47.259]             inherits <- base::inherits
[10:22:47.259]             invokeRestart <- base::invokeRestart
[10:22:47.259]             length <- base::length
[10:22:47.259]             list <- base::list
[10:22:47.259]             seq.int <- base::seq.int
[10:22:47.259]             signalCondition <- base::signalCondition
[10:22:47.259]             sys.calls <- base::sys.calls
[10:22:47.259]             `[[` <- base::`[[`
[10:22:47.259]             `+` <- base::`+`
[10:22:47.259]             `<<-` <- base::`<<-`
[10:22:47.259]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:47.259]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:47.259]                   3L)]
[10:22:47.259]             }
[10:22:47.259]             function(cond) {
[10:22:47.259]                 is_error <- inherits(cond, "error")
[10:22:47.259]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:47.259]                   NULL)
[10:22:47.259]                 if (is_error) {
[10:22:47.259]                   sessionInformation <- function() {
[10:22:47.259]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:47.259]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:47.259]                       search = base::search(), system = base::Sys.info())
[10:22:47.259]                   }
[10:22:47.259]                   ...future.conditions[[length(...future.conditions) + 
[10:22:47.259]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:47.259]                     cond$call), session = sessionInformation(), 
[10:22:47.259]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:47.259]                   signalCondition(cond)
[10:22:47.259]                 }
[10:22:47.259]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:47.259]                 "immediateCondition"))) {
[10:22:47.259]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:47.259]                   ...future.conditions[[length(...future.conditions) + 
[10:22:47.259]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:47.259]                   if (TRUE && !signal) {
[10:22:47.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.259]                     {
[10:22:47.259]                       inherits <- base::inherits
[10:22:47.259]                       invokeRestart <- base::invokeRestart
[10:22:47.259]                       is.null <- base::is.null
[10:22:47.259]                       muffled <- FALSE
[10:22:47.259]                       if (inherits(cond, "message")) {
[10:22:47.259]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:47.259]                         if (muffled) 
[10:22:47.259]                           invokeRestart("muffleMessage")
[10:22:47.259]                       }
[10:22:47.259]                       else if (inherits(cond, "warning")) {
[10:22:47.259]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:47.259]                         if (muffled) 
[10:22:47.259]                           invokeRestart("muffleWarning")
[10:22:47.259]                       }
[10:22:47.259]                       else if (inherits(cond, "condition")) {
[10:22:47.259]                         if (!is.null(pattern)) {
[10:22:47.259]                           computeRestarts <- base::computeRestarts
[10:22:47.259]                           grepl <- base::grepl
[10:22:47.259]                           restarts <- computeRestarts(cond)
[10:22:47.259]                           for (restart in restarts) {
[10:22:47.259]                             name <- restart$name
[10:22:47.259]                             if (is.null(name)) 
[10:22:47.259]                               next
[10:22:47.259]                             if (!grepl(pattern, name)) 
[10:22:47.259]                               next
[10:22:47.259]                             invokeRestart(restart)
[10:22:47.259]                             muffled <- TRUE
[10:22:47.259]                             break
[10:22:47.259]                           }
[10:22:47.259]                         }
[10:22:47.259]                       }
[10:22:47.259]                       invisible(muffled)
[10:22:47.259]                     }
[10:22:47.259]                     muffleCondition(cond, pattern = "^muffle")
[10:22:47.259]                   }
[10:22:47.259]                 }
[10:22:47.259]                 else {
[10:22:47.259]                   if (TRUE) {
[10:22:47.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.259]                     {
[10:22:47.259]                       inherits <- base::inherits
[10:22:47.259]                       invokeRestart <- base::invokeRestart
[10:22:47.259]                       is.null <- base::is.null
[10:22:47.259]                       muffled <- FALSE
[10:22:47.259]                       if (inherits(cond, "message")) {
[10:22:47.259]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:47.259]                         if (muffled) 
[10:22:47.259]                           invokeRestart("muffleMessage")
[10:22:47.259]                       }
[10:22:47.259]                       else if (inherits(cond, "warning")) {
[10:22:47.259]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:47.259]                         if (muffled) 
[10:22:47.259]                           invokeRestart("muffleWarning")
[10:22:47.259]                       }
[10:22:47.259]                       else if (inherits(cond, "condition")) {
[10:22:47.259]                         if (!is.null(pattern)) {
[10:22:47.259]                           computeRestarts <- base::computeRestarts
[10:22:47.259]                           grepl <- base::grepl
[10:22:47.259]                           restarts <- computeRestarts(cond)
[10:22:47.259]                           for (restart in restarts) {
[10:22:47.259]                             name <- restart$name
[10:22:47.259]                             if (is.null(name)) 
[10:22:47.259]                               next
[10:22:47.259]                             if (!grepl(pattern, name)) 
[10:22:47.259]                               next
[10:22:47.259]                             invokeRestart(restart)
[10:22:47.259]                             muffled <- TRUE
[10:22:47.259]                             break
[10:22:47.259]                           }
[10:22:47.259]                         }
[10:22:47.259]                       }
[10:22:47.259]                       invisible(muffled)
[10:22:47.259]                     }
[10:22:47.259]                     muffleCondition(cond, pattern = "^muffle")
[10:22:47.259]                   }
[10:22:47.259]                 }
[10:22:47.259]             }
[10:22:47.259]         }))
[10:22:47.259]     }, error = function(ex) {
[10:22:47.259]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:47.259]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:47.259]                 ...future.rng), started = ...future.startTime, 
[10:22:47.259]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:47.259]             version = "1.8"), class = "FutureResult")
[10:22:47.259]     }, finally = {
[10:22:47.259]         if (!identical(...future.workdir, getwd())) 
[10:22:47.259]             setwd(...future.workdir)
[10:22:47.259]         {
[10:22:47.259]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:47.259]                 ...future.oldOptions$nwarnings <- NULL
[10:22:47.259]             }
[10:22:47.259]             base::options(...future.oldOptions)
[10:22:47.259]             if (.Platform$OS.type == "windows") {
[10:22:47.259]                 old_names <- names(...future.oldEnvVars)
[10:22:47.259]                 envs <- base::Sys.getenv()
[10:22:47.259]                 names <- names(envs)
[10:22:47.259]                 common <- intersect(names, old_names)
[10:22:47.259]                 added <- setdiff(names, old_names)
[10:22:47.259]                 removed <- setdiff(old_names, names)
[10:22:47.259]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:47.259]                   envs[common]]
[10:22:47.259]                 NAMES <- toupper(changed)
[10:22:47.259]                 args <- list()
[10:22:47.259]                 for (kk in seq_along(NAMES)) {
[10:22:47.259]                   name <- changed[[kk]]
[10:22:47.259]                   NAME <- NAMES[[kk]]
[10:22:47.259]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.259]                     next
[10:22:47.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:47.259]                 }
[10:22:47.259]                 NAMES <- toupper(added)
[10:22:47.259]                 for (kk in seq_along(NAMES)) {
[10:22:47.259]                   name <- added[[kk]]
[10:22:47.259]                   NAME <- NAMES[[kk]]
[10:22:47.259]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.259]                     next
[10:22:47.259]                   args[[name]] <- ""
[10:22:47.259]                 }
[10:22:47.259]                 NAMES <- toupper(removed)
[10:22:47.259]                 for (kk in seq_along(NAMES)) {
[10:22:47.259]                   name <- removed[[kk]]
[10:22:47.259]                   NAME <- NAMES[[kk]]
[10:22:47.259]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.259]                     next
[10:22:47.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:47.259]                 }
[10:22:47.259]                 if (length(args) > 0) 
[10:22:47.259]                   base::do.call(base::Sys.setenv, args = args)
[10:22:47.259]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:47.259]             }
[10:22:47.259]             else {
[10:22:47.259]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:47.259]             }
[10:22:47.259]             {
[10:22:47.259]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:47.259]                   0L) {
[10:22:47.259]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:47.259]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:47.259]                   base::options(opts)
[10:22:47.259]                 }
[10:22:47.259]                 {
[10:22:47.259]                   {
[10:22:47.259]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:47.259]                     NULL
[10:22:47.259]                   }
[10:22:47.259]                   options(future.plan = NULL)
[10:22:47.259]                   if (is.na(NA_character_)) 
[10:22:47.259]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:47.259]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:47.259]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:47.259]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:47.259]                     envir = parent.frame()) 
[10:22:47.259]                   {
[10:22:47.259]                     if (is.function(workers)) 
[10:22:47.259]                       workers <- workers()
[10:22:47.259]                     workers <- structure(as.integer(workers), 
[10:22:47.259]                       class = class(workers))
[10:22:47.259]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:47.259]                       workers >= 1)
[10:22:47.259]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:47.259]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:47.259]                     }
[10:22:47.259]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:47.259]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:47.259]                       envir = envir)
[10:22:47.259]                     if (!future$lazy) 
[10:22:47.259]                       future <- run(future)
[10:22:47.259]                     invisible(future)
[10:22:47.259]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:47.259]                 }
[10:22:47.259]             }
[10:22:47.259]         }
[10:22:47.259]     })
[10:22:47.259]     if (TRUE) {
[10:22:47.259]         base::sink(type = "output", split = FALSE)
[10:22:47.259]         if (TRUE) {
[10:22:47.259]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:47.259]         }
[10:22:47.259]         else {
[10:22:47.259]             ...future.result["stdout"] <- base::list(NULL)
[10:22:47.259]         }
[10:22:47.259]         base::close(...future.stdout)
[10:22:47.259]         ...future.stdout <- NULL
[10:22:47.259]     }
[10:22:47.259]     ...future.result$conditions <- ...future.conditions
[10:22:47.259]     ...future.result$finished <- base::Sys.time()
[10:22:47.259]     ...future.result
[10:22:47.259] }
[10:22:47.263] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[10:22:47.263] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:22:47.263] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:22:47.263] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[10:22:47.264] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[10:22:47.264] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[10:22:47.264] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[10:22:47.264] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:22:47.264] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:22:47.265] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[10:22:47.265] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[10:22:47.265] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[10:22:47.266] MultisessionFuture started
[10:22:47.266] - Launch lazy future ... done
[10:22:47.266] run() for ‘MultisessionFuture’ ... done
[10:22:47.266] Created future:
[10:22:47.266] MultisessionFuture:
[10:22:47.266] Label: ‘future_apply-1’
[10:22:47.266] Expression:
[10:22:47.266] {
[10:22:47.266]     do.call(function(...) {
[10:22:47.266]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.266]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:47.266]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.266]             on.exit(options(oopts), add = TRUE)
[10:22:47.266]         }
[10:22:47.266]         {
[10:22:47.266]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:47.266]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.266]                 ...future.FUN(...future.X_jj, ...)
[10:22:47.266]             })
[10:22:47.266]         }
[10:22:47.266]     }, args = future.call.arguments)
[10:22:47.266] }
[10:22:47.266] Lazy evaluation: FALSE
[10:22:47.266] Asynchronous evaluation: TRUE
[10:22:47.266] Local evaluation: TRUE
[10:22:47.266] Environment: R_GlobalEnv
[10:22:47.266] Capture standard output: TRUE
[10:22:47.266] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:47.266] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:47.266] Packages: <none>
[10:22:47.266] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:47.266] Resolved: FALSE
[10:22:47.266] Value: <not collected>
[10:22:47.266] Conditions captured: <none>
[10:22:47.266] Early signaling: FALSE
[10:22:47.266] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:47.266] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:47.278] Chunk #1 of 2 ... DONE
[10:22:47.278] Chunk #2 of 2 ...
[10:22:47.278]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:47.278]  - seeds: <none>
[10:22:47.280]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.281] getGlobalsAndPackages() ...
[10:22:47.281] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.281] Resolving globals: FALSE
[10:22:47.281] Tweak future expression to call with '...' arguments ...
[10:22:47.281] {
[10:22:47.281]     do.call(function(...) {
[10:22:47.281]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.281]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:47.281]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.281]             on.exit(options(oopts), add = TRUE)
[10:22:47.281]         }
[10:22:47.281]         {
[10:22:47.281]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:47.281]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.281]                 ...future.FUN(...future.X_jj, ...)
[10:22:47.281]             })
[10:22:47.281]         }
[10:22:47.281]     }, args = future.call.arguments)
[10:22:47.281] }
[10:22:47.281] Tweak future expression to call with '...' arguments ... DONE
[10:22:47.282] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.282] 
[10:22:47.282] getGlobalsAndPackages() ... DONE
[10:22:47.282] run() for ‘Future’ ...
[10:22:47.282] - state: ‘created’
[10:22:47.283] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:47.298] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:47.298] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:47.298]   - Field: ‘node’
[10:22:47.298]   - Field: ‘label’
[10:22:47.299]   - Field: ‘local’
[10:22:47.299]   - Field: ‘owner’
[10:22:47.299]   - Field: ‘envir’
[10:22:47.299]   - Field: ‘workers’
[10:22:47.299]   - Field: ‘packages’
[10:22:47.300]   - Field: ‘gc’
[10:22:47.300]   - Field: ‘conditions’
[10:22:47.300]   - Field: ‘persistent’
[10:22:47.300]   - Field: ‘expr’
[10:22:47.300]   - Field: ‘uuid’
[10:22:47.300]   - Field: ‘seed’
[10:22:47.301]   - Field: ‘version’
[10:22:47.301]   - Field: ‘result’
[10:22:47.301]   - Field: ‘asynchronous’
[10:22:47.301]   - Field: ‘calls’
[10:22:47.301]   - Field: ‘globals’
[10:22:47.302]   - Field: ‘stdout’
[10:22:47.302]   - Field: ‘earlySignal’
[10:22:47.302]   - Field: ‘lazy’
[10:22:47.302]   - Field: ‘state’
[10:22:47.302] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:47.302] - Launch lazy future ...
[10:22:47.303] Packages needed by the future expression (n = 0): <none>
[10:22:47.303] Packages needed by future strategies (n = 0): <none>
[10:22:47.304] {
[10:22:47.304]     {
[10:22:47.304]         {
[10:22:47.304]             ...future.startTime <- base::Sys.time()
[10:22:47.304]             {
[10:22:47.304]                 {
[10:22:47.304]                   {
[10:22:47.304]                     {
[10:22:47.304]                       base::local({
[10:22:47.304]                         has_future <- base::requireNamespace("future", 
[10:22:47.304]                           quietly = TRUE)
[10:22:47.304]                         if (has_future) {
[10:22:47.304]                           ns <- base::getNamespace("future")
[10:22:47.304]                           version <- ns[[".package"]][["version"]]
[10:22:47.304]                           if (is.null(version)) 
[10:22:47.304]                             version <- utils::packageVersion("future")
[10:22:47.304]                         }
[10:22:47.304]                         else {
[10:22:47.304]                           version <- NULL
[10:22:47.304]                         }
[10:22:47.304]                         if (!has_future || version < "1.8.0") {
[10:22:47.304]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:47.304]                             "", base::R.version$version.string), 
[10:22:47.304]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:47.304]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:47.304]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:47.304]                               "release", "version")], collapse = " "), 
[10:22:47.304]                             hostname = base::Sys.info()[["nodename"]])
[10:22:47.304]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:47.304]                             info)
[10:22:47.304]                           info <- base::paste(info, collapse = "; ")
[10:22:47.304]                           if (!has_future) {
[10:22:47.304]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:47.304]                               info)
[10:22:47.304]                           }
[10:22:47.304]                           else {
[10:22:47.304]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:47.304]                               info, version)
[10:22:47.304]                           }
[10:22:47.304]                           base::stop(msg)
[10:22:47.304]                         }
[10:22:47.304]                       })
[10:22:47.304]                     }
[10:22:47.304]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:47.304]                     base::options(mc.cores = 1L)
[10:22:47.304]                   }
[10:22:47.304]                   options(future.plan = NULL)
[10:22:47.304]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:47.304]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:47.304]                 }
[10:22:47.304]                 ...future.workdir <- getwd()
[10:22:47.304]             }
[10:22:47.304]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:47.304]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:47.304]         }
[10:22:47.304]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:47.304]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:47.304]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:47.304]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:47.304]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:47.304]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:47.304]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:47.304]             base::names(...future.oldOptions))
[10:22:47.304]     }
[10:22:47.304]     if (FALSE) {
[10:22:47.304]     }
[10:22:47.304]     else {
[10:22:47.304]         if (TRUE) {
[10:22:47.304]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:47.304]                 open = "w")
[10:22:47.304]         }
[10:22:47.304]         else {
[10:22:47.304]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:47.304]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:47.304]         }
[10:22:47.304]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:47.304]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:47.304]             base::sink(type = "output", split = FALSE)
[10:22:47.304]             base::close(...future.stdout)
[10:22:47.304]         }, add = TRUE)
[10:22:47.304]     }
[10:22:47.304]     ...future.frame <- base::sys.nframe()
[10:22:47.304]     ...future.conditions <- base::list()
[10:22:47.304]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:47.304]     if (FALSE) {
[10:22:47.304]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:47.304]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:47.304]     }
[10:22:47.304]     ...future.result <- base::tryCatch({
[10:22:47.304]         base::withCallingHandlers({
[10:22:47.304]             ...future.value <- base::withVisible(base::local({
[10:22:47.304]                 ...future.makeSendCondition <- base::local({
[10:22:47.304]                   sendCondition <- NULL
[10:22:47.304]                   function(frame = 1L) {
[10:22:47.304]                     if (is.function(sendCondition)) 
[10:22:47.304]                       return(sendCondition)
[10:22:47.304]                     ns <- getNamespace("parallel")
[10:22:47.304]                     if (exists("sendData", mode = "function", 
[10:22:47.304]                       envir = ns)) {
[10:22:47.304]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:47.304]                         envir = ns)
[10:22:47.304]                       envir <- sys.frame(frame)
[10:22:47.304]                       master <- NULL
[10:22:47.304]                       while (!identical(envir, .GlobalEnv) && 
[10:22:47.304]                         !identical(envir, emptyenv())) {
[10:22:47.304]                         if (exists("master", mode = "list", envir = envir, 
[10:22:47.304]                           inherits = FALSE)) {
[10:22:47.304]                           master <- get("master", mode = "list", 
[10:22:47.304]                             envir = envir, inherits = FALSE)
[10:22:47.304]                           if (inherits(master, c("SOCKnode", 
[10:22:47.304]                             "SOCK0node"))) {
[10:22:47.304]                             sendCondition <<- function(cond) {
[10:22:47.304]                               data <- list(type = "VALUE", value = cond, 
[10:22:47.304]                                 success = TRUE)
[10:22:47.304]                               parallel_sendData(master, data)
[10:22:47.304]                             }
[10:22:47.304]                             return(sendCondition)
[10:22:47.304]                           }
[10:22:47.304]                         }
[10:22:47.304]                         frame <- frame + 1L
[10:22:47.304]                         envir <- sys.frame(frame)
[10:22:47.304]                       }
[10:22:47.304]                     }
[10:22:47.304]                     sendCondition <<- function(cond) NULL
[10:22:47.304]                   }
[10:22:47.304]                 })
[10:22:47.304]                 withCallingHandlers({
[10:22:47.304]                   {
[10:22:47.304]                     do.call(function(...) {
[10:22:47.304]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.304]                       if (!identical(...future.globals.maxSize.org, 
[10:22:47.304]                         ...future.globals.maxSize)) {
[10:22:47.304]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.304]                         on.exit(options(oopts), add = TRUE)
[10:22:47.304]                       }
[10:22:47.304]                       {
[10:22:47.304]                         lapply(seq_along(...future.elements_ii), 
[10:22:47.304]                           FUN = function(jj) {
[10:22:47.304]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.304]                             ...future.FUN(...future.X_jj, ...)
[10:22:47.304]                           })
[10:22:47.304]                       }
[10:22:47.304]                     }, args = future.call.arguments)
[10:22:47.304]                   }
[10:22:47.304]                 }, immediateCondition = function(cond) {
[10:22:47.304]                   sendCondition <- ...future.makeSendCondition()
[10:22:47.304]                   sendCondition(cond)
[10:22:47.304]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.304]                   {
[10:22:47.304]                     inherits <- base::inherits
[10:22:47.304]                     invokeRestart <- base::invokeRestart
[10:22:47.304]                     is.null <- base::is.null
[10:22:47.304]                     muffled <- FALSE
[10:22:47.304]                     if (inherits(cond, "message")) {
[10:22:47.304]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:47.304]                       if (muffled) 
[10:22:47.304]                         invokeRestart("muffleMessage")
[10:22:47.304]                     }
[10:22:47.304]                     else if (inherits(cond, "warning")) {
[10:22:47.304]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:47.304]                       if (muffled) 
[10:22:47.304]                         invokeRestart("muffleWarning")
[10:22:47.304]                     }
[10:22:47.304]                     else if (inherits(cond, "condition")) {
[10:22:47.304]                       if (!is.null(pattern)) {
[10:22:47.304]                         computeRestarts <- base::computeRestarts
[10:22:47.304]                         grepl <- base::grepl
[10:22:47.304]                         restarts <- computeRestarts(cond)
[10:22:47.304]                         for (restart in restarts) {
[10:22:47.304]                           name <- restart$name
[10:22:47.304]                           if (is.null(name)) 
[10:22:47.304]                             next
[10:22:47.304]                           if (!grepl(pattern, name)) 
[10:22:47.304]                             next
[10:22:47.304]                           invokeRestart(restart)
[10:22:47.304]                           muffled <- TRUE
[10:22:47.304]                           break
[10:22:47.304]                         }
[10:22:47.304]                       }
[10:22:47.304]                     }
[10:22:47.304]                     invisible(muffled)
[10:22:47.304]                   }
[10:22:47.304]                   muffleCondition(cond)
[10:22:47.304]                 })
[10:22:47.304]             }))
[10:22:47.304]             future::FutureResult(value = ...future.value$value, 
[10:22:47.304]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:47.304]                   ...future.rng), globalenv = if (FALSE) 
[10:22:47.304]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:47.304]                     ...future.globalenv.names))
[10:22:47.304]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:47.304]         }, condition = base::local({
[10:22:47.304]             c <- base::c
[10:22:47.304]             inherits <- base::inherits
[10:22:47.304]             invokeRestart <- base::invokeRestart
[10:22:47.304]             length <- base::length
[10:22:47.304]             list <- base::list
[10:22:47.304]             seq.int <- base::seq.int
[10:22:47.304]             signalCondition <- base::signalCondition
[10:22:47.304]             sys.calls <- base::sys.calls
[10:22:47.304]             `[[` <- base::`[[`
[10:22:47.304]             `+` <- base::`+`
[10:22:47.304]             `<<-` <- base::`<<-`
[10:22:47.304]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:47.304]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:47.304]                   3L)]
[10:22:47.304]             }
[10:22:47.304]             function(cond) {
[10:22:47.304]                 is_error <- inherits(cond, "error")
[10:22:47.304]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:47.304]                   NULL)
[10:22:47.304]                 if (is_error) {
[10:22:47.304]                   sessionInformation <- function() {
[10:22:47.304]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:47.304]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:47.304]                       search = base::search(), system = base::Sys.info())
[10:22:47.304]                   }
[10:22:47.304]                   ...future.conditions[[length(...future.conditions) + 
[10:22:47.304]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:47.304]                     cond$call), session = sessionInformation(), 
[10:22:47.304]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:47.304]                   signalCondition(cond)
[10:22:47.304]                 }
[10:22:47.304]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:47.304]                 "immediateCondition"))) {
[10:22:47.304]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:47.304]                   ...future.conditions[[length(...future.conditions) + 
[10:22:47.304]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:47.304]                   if (TRUE && !signal) {
[10:22:47.304]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.304]                     {
[10:22:47.304]                       inherits <- base::inherits
[10:22:47.304]                       invokeRestart <- base::invokeRestart
[10:22:47.304]                       is.null <- base::is.null
[10:22:47.304]                       muffled <- FALSE
[10:22:47.304]                       if (inherits(cond, "message")) {
[10:22:47.304]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:47.304]                         if (muffled) 
[10:22:47.304]                           invokeRestart("muffleMessage")
[10:22:47.304]                       }
[10:22:47.304]                       else if (inherits(cond, "warning")) {
[10:22:47.304]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:47.304]                         if (muffled) 
[10:22:47.304]                           invokeRestart("muffleWarning")
[10:22:47.304]                       }
[10:22:47.304]                       else if (inherits(cond, "condition")) {
[10:22:47.304]                         if (!is.null(pattern)) {
[10:22:47.304]                           computeRestarts <- base::computeRestarts
[10:22:47.304]                           grepl <- base::grepl
[10:22:47.304]                           restarts <- computeRestarts(cond)
[10:22:47.304]                           for (restart in restarts) {
[10:22:47.304]                             name <- restart$name
[10:22:47.304]                             if (is.null(name)) 
[10:22:47.304]                               next
[10:22:47.304]                             if (!grepl(pattern, name)) 
[10:22:47.304]                               next
[10:22:47.304]                             invokeRestart(restart)
[10:22:47.304]                             muffled <- TRUE
[10:22:47.304]                             break
[10:22:47.304]                           }
[10:22:47.304]                         }
[10:22:47.304]                       }
[10:22:47.304]                       invisible(muffled)
[10:22:47.304]                     }
[10:22:47.304]                     muffleCondition(cond, pattern = "^muffle")
[10:22:47.304]                   }
[10:22:47.304]                 }
[10:22:47.304]                 else {
[10:22:47.304]                   if (TRUE) {
[10:22:47.304]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.304]                     {
[10:22:47.304]                       inherits <- base::inherits
[10:22:47.304]                       invokeRestart <- base::invokeRestart
[10:22:47.304]                       is.null <- base::is.null
[10:22:47.304]                       muffled <- FALSE
[10:22:47.304]                       if (inherits(cond, "message")) {
[10:22:47.304]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:47.304]                         if (muffled) 
[10:22:47.304]                           invokeRestart("muffleMessage")
[10:22:47.304]                       }
[10:22:47.304]                       else if (inherits(cond, "warning")) {
[10:22:47.304]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:47.304]                         if (muffled) 
[10:22:47.304]                           invokeRestart("muffleWarning")
[10:22:47.304]                       }
[10:22:47.304]                       else if (inherits(cond, "condition")) {
[10:22:47.304]                         if (!is.null(pattern)) {
[10:22:47.304]                           computeRestarts <- base::computeRestarts
[10:22:47.304]                           grepl <- base::grepl
[10:22:47.304]                           restarts <- computeRestarts(cond)
[10:22:47.304]                           for (restart in restarts) {
[10:22:47.304]                             name <- restart$name
[10:22:47.304]                             if (is.null(name)) 
[10:22:47.304]                               next
[10:22:47.304]                             if (!grepl(pattern, name)) 
[10:22:47.304]                               next
[10:22:47.304]                             invokeRestart(restart)
[10:22:47.304]                             muffled <- TRUE
[10:22:47.304]                             break
[10:22:47.304]                           }
[10:22:47.304]                         }
[10:22:47.304]                       }
[10:22:47.304]                       invisible(muffled)
[10:22:47.304]                     }
[10:22:47.304]                     muffleCondition(cond, pattern = "^muffle")
[10:22:47.304]                   }
[10:22:47.304]                 }
[10:22:47.304]             }
[10:22:47.304]         }))
[10:22:47.304]     }, error = function(ex) {
[10:22:47.304]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:47.304]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:47.304]                 ...future.rng), started = ...future.startTime, 
[10:22:47.304]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:47.304]             version = "1.8"), class = "FutureResult")
[10:22:47.304]     }, finally = {
[10:22:47.304]         if (!identical(...future.workdir, getwd())) 
[10:22:47.304]             setwd(...future.workdir)
[10:22:47.304]         {
[10:22:47.304]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:47.304]                 ...future.oldOptions$nwarnings <- NULL
[10:22:47.304]             }
[10:22:47.304]             base::options(...future.oldOptions)
[10:22:47.304]             if (.Platform$OS.type == "windows") {
[10:22:47.304]                 old_names <- names(...future.oldEnvVars)
[10:22:47.304]                 envs <- base::Sys.getenv()
[10:22:47.304]                 names <- names(envs)
[10:22:47.304]                 common <- intersect(names, old_names)
[10:22:47.304]                 added <- setdiff(names, old_names)
[10:22:47.304]                 removed <- setdiff(old_names, names)
[10:22:47.304]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:47.304]                   envs[common]]
[10:22:47.304]                 NAMES <- toupper(changed)
[10:22:47.304]                 args <- list()
[10:22:47.304]                 for (kk in seq_along(NAMES)) {
[10:22:47.304]                   name <- changed[[kk]]
[10:22:47.304]                   NAME <- NAMES[[kk]]
[10:22:47.304]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.304]                     next
[10:22:47.304]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:47.304]                 }
[10:22:47.304]                 NAMES <- toupper(added)
[10:22:47.304]                 for (kk in seq_along(NAMES)) {
[10:22:47.304]                   name <- added[[kk]]
[10:22:47.304]                   NAME <- NAMES[[kk]]
[10:22:47.304]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.304]                     next
[10:22:47.304]                   args[[name]] <- ""
[10:22:47.304]                 }
[10:22:47.304]                 NAMES <- toupper(removed)
[10:22:47.304]                 for (kk in seq_along(NAMES)) {
[10:22:47.304]                   name <- removed[[kk]]
[10:22:47.304]                   NAME <- NAMES[[kk]]
[10:22:47.304]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.304]                     next
[10:22:47.304]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:47.304]                 }
[10:22:47.304]                 if (length(args) > 0) 
[10:22:47.304]                   base::do.call(base::Sys.setenv, args = args)
[10:22:47.304]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:47.304]             }
[10:22:47.304]             else {
[10:22:47.304]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:47.304]             }
[10:22:47.304]             {
[10:22:47.304]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:47.304]                   0L) {
[10:22:47.304]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:47.304]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:47.304]                   base::options(opts)
[10:22:47.304]                 }
[10:22:47.304]                 {
[10:22:47.304]                   {
[10:22:47.304]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:47.304]                     NULL
[10:22:47.304]                   }
[10:22:47.304]                   options(future.plan = NULL)
[10:22:47.304]                   if (is.na(NA_character_)) 
[10:22:47.304]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:47.304]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:47.304]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:47.304]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:47.304]                     envir = parent.frame()) 
[10:22:47.304]                   {
[10:22:47.304]                     if (is.function(workers)) 
[10:22:47.304]                       workers <- workers()
[10:22:47.304]                     workers <- structure(as.integer(workers), 
[10:22:47.304]                       class = class(workers))
[10:22:47.304]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:47.304]                       workers >= 1)
[10:22:47.304]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:47.304]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:47.304]                     }
[10:22:47.304]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:47.304]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:47.304]                       envir = envir)
[10:22:47.304]                     if (!future$lazy) 
[10:22:47.304]                       future <- run(future)
[10:22:47.304]                     invisible(future)
[10:22:47.304]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:47.304]                 }
[10:22:47.304]             }
[10:22:47.304]         }
[10:22:47.304]     })
[10:22:47.304]     if (TRUE) {
[10:22:47.304]         base::sink(type = "output", split = FALSE)
[10:22:47.304]         if (TRUE) {
[10:22:47.304]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:47.304]         }
[10:22:47.304]         else {
[10:22:47.304]             ...future.result["stdout"] <- base::list(NULL)
[10:22:47.304]         }
[10:22:47.304]         base::close(...future.stdout)
[10:22:47.304]         ...future.stdout <- NULL
[10:22:47.304]     }
[10:22:47.304]     ...future.result$conditions <- ...future.conditions
[10:22:47.304]     ...future.result$finished <- base::Sys.time()
[10:22:47.304]     ...future.result
[10:22:47.304] }
[10:22:47.309] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[10:22:47.310] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:22:47.310] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:22:47.310] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[10:22:47.311] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[10:22:47.311] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #2 ...
[10:22:47.311] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #2 ... DONE
[10:22:47.311] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:22:47.312] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:22:47.312] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[10:22:47.312] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[10:22:47.313] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[10:22:47.314] MultisessionFuture started
[10:22:47.314] - Launch lazy future ... done
[10:22:47.314] run() for ‘MultisessionFuture’ ... done
[10:22:47.314] Created future:
[10:22:47.314] MultisessionFuture:
[10:22:47.314] Label: ‘future_apply-2’
[10:22:47.314] Expression:
[10:22:47.314] {
[10:22:47.314]     do.call(function(...) {
[10:22:47.314]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.314]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:47.314]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.314]             on.exit(options(oopts), add = TRUE)
[10:22:47.314]         }
[10:22:47.314]         {
[10:22:47.314]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:47.314]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.314]                 ...future.FUN(...future.X_jj, ...)
[10:22:47.314]             })
[10:22:47.314]         }
[10:22:47.314]     }, args = future.call.arguments)
[10:22:47.314] }
[10:22:47.314] Lazy evaluation: FALSE
[10:22:47.314] Asynchronous evaluation: TRUE
[10:22:47.314] Local evaluation: TRUE
[10:22:47.314] Environment: R_GlobalEnv
[10:22:47.314] Capture standard output: TRUE
[10:22:47.314] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:47.314] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:47.314] Packages: <none>
[10:22:47.314] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:47.314] Resolved: FALSE
[10:22:47.314] Value: <not collected>
[10:22:47.314] Conditions captured: <none>
[10:22:47.314] Early signaling: FALSE
[10:22:47.314] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:47.314] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:47.326] Chunk #2 of 2 ... DONE
[10:22:47.326] Launching 2 futures (chunks) ... DONE
[10:22:47.327] Resolving 2 futures (chunks) ...
[10:22:47.327] resolve() on list ...
[10:22:47.327]  recursive: 0
[10:22:47.327]  length: 2
[10:22:47.327] 
[10:22:47.328] receiveMessageFromWorker() for ClusterFuture ...
[10:22:47.328] - Validating connection of MultisessionFuture
[10:22:47.328] - received message: FutureResult
[10:22:47.328] - Received FutureResult
[10:22:47.329] - Erased future from FutureRegistry
[10:22:47.329] result() for ClusterFuture ...
[10:22:47.329] - result already collected: FutureResult
[10:22:47.329] result() for ClusterFuture ... done
[10:22:47.329] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:47.329] Future #1
[10:22:47.329] result() for ClusterFuture ...
[10:22:47.329] - result already collected: FutureResult
[10:22:47.330] result() for ClusterFuture ... done
[10:22:47.330] result() for ClusterFuture ...
[10:22:47.330] - result already collected: FutureResult
[10:22:47.330] result() for ClusterFuture ... done
[10:22:47.330] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:22:47.330] - nx: 2
[10:22:47.330] - relay: TRUE
[10:22:47.330] - stdout: TRUE
[10:22:47.331] - signal: TRUE
[10:22:47.331] - resignal: FALSE
[10:22:47.331] - force: TRUE
[10:22:47.331] - relayed: [n=2] FALSE, FALSE
[10:22:47.331] - queued futures: [n=2] FALSE, FALSE
[10:22:47.331]  - until=1
[10:22:47.331]  - relaying element #1
[10:22:47.331] result() for ClusterFuture ...
[10:22:47.332] - result already collected: FutureResult
[10:22:47.332] result() for ClusterFuture ... done
[10:22:47.332] result() for ClusterFuture ...
[10:22:47.332] - result already collected: FutureResult
[10:22:47.332] result() for ClusterFuture ... done
[10:22:47.332] result() for ClusterFuture ...
[10:22:47.332] - result already collected: FutureResult
[10:22:47.333] result() for ClusterFuture ... done
[10:22:47.333] result() for ClusterFuture ...
[10:22:47.333] - result already collected: FutureResult
[10:22:47.333] result() for ClusterFuture ... done
[10:22:47.333] - relayed: [n=2] TRUE, FALSE
[10:22:47.333] - queued futures: [n=2] TRUE, FALSE
[10:22:47.333] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:22:47.333]  length: 1 (resolved future 1)
[10:22:47.362] receiveMessageFromWorker() for ClusterFuture ...
[10:22:47.363] - Validating connection of MultisessionFuture
[10:22:47.363] - received message: FutureResult
[10:22:47.363] - Received FutureResult
[10:22:47.363] - Erased future from FutureRegistry
[10:22:47.363] result() for ClusterFuture ...
[10:22:47.363] - result already collected: FutureResult
[10:22:47.363] result() for ClusterFuture ... done
[10:22:47.363] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:47.363] Future #2
[10:22:47.364] result() for ClusterFuture ...
[10:22:47.364] - result already collected: FutureResult
[10:22:47.364] result() for ClusterFuture ... done
[10:22:47.364] result() for ClusterFuture ...
[10:22:47.364] - result already collected: FutureResult
[10:22:47.364] result() for ClusterFuture ... done
[10:22:47.364] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:22:47.364] - nx: 2
[10:22:47.364] - relay: TRUE
[10:22:47.364] - stdout: TRUE
[10:22:47.364] - signal: TRUE
[10:22:47.365] - resignal: FALSE
[10:22:47.365] - force: TRUE
[10:22:47.365] - relayed: [n=2] TRUE, FALSE
[10:22:47.365] - queued futures: [n=2] TRUE, FALSE
[10:22:47.365]  - until=2
[10:22:47.365]  - relaying element #2
[10:22:47.365] result() for ClusterFuture ...
[10:22:47.365] - result already collected: FutureResult
[10:22:47.365] result() for ClusterFuture ... done
[10:22:47.365] result() for ClusterFuture ...
[10:22:47.365] - result already collected: FutureResult
[10:22:47.366] result() for ClusterFuture ... done
[10:22:47.366] result() for ClusterFuture ...
[10:22:47.366] - result already collected: FutureResult
[10:22:47.366] result() for ClusterFuture ... done
[10:22:47.366] result() for ClusterFuture ...
[10:22:47.366] - result already collected: FutureResult
[10:22:47.366] result() for ClusterFuture ... done
[10:22:47.366] - relayed: [n=2] TRUE, TRUE
[10:22:47.366] - queued futures: [n=2] TRUE, TRUE
[10:22:47.366] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:22:47.367]  length: 0 (resolved future 2)
[10:22:47.367] Relaying remaining futures
[10:22:47.367] signalConditionsASAP(NULL, pos=0) ...
[10:22:47.367] - nx: 2
[10:22:47.367] - relay: TRUE
[10:22:47.367] - stdout: TRUE
[10:22:47.367] - signal: TRUE
[10:22:47.367] - resignal: FALSE
[10:22:47.367] - force: TRUE
[10:22:47.367] - relayed: [n=2] TRUE, TRUE
[10:22:47.367] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:22:47.368] - relayed: [n=2] TRUE, TRUE
[10:22:47.368] - queued futures: [n=2] TRUE, TRUE
[10:22:47.368] signalConditionsASAP(NULL, pos=0) ... done
[10:22:47.368] resolve() on list ... DONE
[10:22:47.368] result() for ClusterFuture ...
[10:22:47.368] - result already collected: FutureResult
[10:22:47.368] result() for ClusterFuture ... done
[10:22:47.368] result() for ClusterFuture ...
[10:22:47.368] - result already collected: FutureResult
[10:22:47.368] result() for ClusterFuture ... done
[10:22:47.368] result() for ClusterFuture ...
[10:22:47.369] - result already collected: FutureResult
[10:22:47.369] result() for ClusterFuture ... done
[10:22:47.369] result() for ClusterFuture ...
[10:22:47.369] - result already collected: FutureResult
[10:22:47.369] result() for ClusterFuture ... done
[10:22:47.369]  - Number of value chunks collected: 2
[10:22:47.369] Resolving 2 futures (chunks) ... DONE
[10:22:47.369] Reducing values from 2 chunks ...
[10:22:47.369]  - Number of values collected after concatenation: 6
[10:22:47.369]  - Number of values expected: 6
[10:22:47.370] Reducing values from 2 chunks ... DONE
[10:22:47.370] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[10:22:47.370] getGlobalsAndPackagesXApply() ...
[10:22:47.370]  - future.globals: TRUE
[10:22:47.370] getGlobalsAndPackages() ...
[10:22:47.370] Searching for globals...
[10:22:47.372] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[10:22:47.372] Searching for globals ... DONE
[10:22:47.372] Resolving globals: FALSE
[10:22:47.372] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[10:22:47.373] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[10:22:47.373] - globals: [1] ‘FUN’
[10:22:47.373] 
[10:22:47.373] getGlobalsAndPackages() ... DONE
[10:22:47.373]  - globals found/used: [n=1] ‘FUN’
[10:22:47.373]  - needed namespaces: [n=0] 
[10:22:47.373] Finding globals ... DONE
[10:22:47.373]  - use_args: TRUE
[10:22:47.374]  - Getting '...' globals ...
[10:22:47.374] resolve() on list ...
[10:22:47.374]  recursive: 0
[10:22:47.374]  length: 1
[10:22:47.374]  elements: ‘...’
[10:22:47.374]  length: 0 (resolved future 1)
[10:22:47.374] resolve() on list ... DONE
[10:22:47.374]    - '...' content: [n=0] 
[10:22:47.375] List of 1
[10:22:47.375]  $ ...: list()
[10:22:47.375]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:47.375]  - attr(*, "where")=List of 1
[10:22:47.375]   ..$ ...:<environment: 0x55ca4d84cea0> 
[10:22:47.375]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:47.375]  - attr(*, "resolved")= logi TRUE
[10:22:47.375]  - attr(*, "total_size")= num NA
[10:22:47.377]  - Getting '...' globals ... DONE
[10:22:47.377] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:47.377] List of 2
[10:22:47.377]  $ ...future.FUN:function (x)  
[10:22:47.377]  $ ...          : list()
[10:22:47.377]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:47.377]  - attr(*, "where")=List of 2
[10:22:47.377]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:47.377]   ..$ ...          :<environment: 0x55ca4d84cea0> 
[10:22:47.377]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:47.377]  - attr(*, "resolved")= logi FALSE
[10:22:47.377]  - attr(*, "total_size")= num 1768
[10:22:47.380] Packages to be attached in all futures: [n=0] 
[10:22:47.380] getGlobalsAndPackagesXApply() ... DONE
[10:22:47.384] future_lapply() ...
[10:22:47.388] Number of chunks: 2
[10:22:47.388] getGlobalsAndPackagesXApply() ...
[10:22:47.388]  - future.globals: <name-value list> with names ‘list()’
[10:22:47.388]  - use_args: TRUE
[10:22:47.388] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:22:47.388] List of 2
[10:22:47.388]  $ ...          : list()
[10:22:47.388]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:47.388]  $ ...future.FUN:function (x)  
[10:22:47.388]  - attr(*, "where")=List of 2
[10:22:47.388]   ..$ ...          :<environment: 0x55ca4d84cea0> 
[10:22:47.388]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[10:22:47.388]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:47.388]  - attr(*, "resolved")= logi FALSE
[10:22:47.388]  - attr(*, "total_size")= num NA
[10:22:47.391] Packages to be attached in all futures: [n=0] 
[10:22:47.391] getGlobalsAndPackagesXApply() ... DONE
[10:22:47.391] Number of futures (= number of chunks): 2
[10:22:47.391] Launching 2 futures (chunks) ...
[10:22:47.392] Chunk #1 of 2 ...
[10:22:47.392]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:47.392]  - seeds: <none>
[10:22:47.392]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.392] getGlobalsAndPackages() ...
[10:22:47.392] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.392] Resolving globals: FALSE
[10:22:47.392] Tweak future expression to call with '...' arguments ...
[10:22:47.392] {
[10:22:47.392]     do.call(function(...) {
[10:22:47.392]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.392]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:47.392]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.392]             on.exit(options(oopts), add = TRUE)
[10:22:47.392]         }
[10:22:47.392]         {
[10:22:47.392]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:47.392]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.392]                 ...future.FUN(...future.X_jj, ...)
[10:22:47.392]             })
[10:22:47.392]         }
[10:22:47.392]     }, args = future.call.arguments)
[10:22:47.392] }
[10:22:47.393] Tweak future expression to call with '...' arguments ... DONE
[10:22:47.393] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.393] 
[10:22:47.393] getGlobalsAndPackages() ... DONE
[10:22:47.394] run() for ‘Future’ ...
[10:22:47.394] - state: ‘created’
[10:22:47.394] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:47.407] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:47.407] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:47.408]   - Field: ‘node’
[10:22:47.408]   - Field: ‘label’
[10:22:47.408]   - Field: ‘local’
[10:22:47.408]   - Field: ‘owner’
[10:22:47.408]   - Field: ‘envir’
[10:22:47.408]   - Field: ‘workers’
[10:22:47.408]   - Field: ‘packages’
[10:22:47.408]   - Field: ‘gc’
[10:22:47.408]   - Field: ‘conditions’
[10:22:47.408]   - Field: ‘persistent’
[10:22:47.408]   - Field: ‘expr’
[10:22:47.409]   - Field: ‘uuid’
[10:22:47.409]   - Field: ‘seed’
[10:22:47.409]   - Field: ‘version’
[10:22:47.409]   - Field: ‘result’
[10:22:47.409]   - Field: ‘asynchronous’
[10:22:47.409]   - Field: ‘calls’
[10:22:47.409]   - Field: ‘globals’
[10:22:47.409]   - Field: ‘stdout’
[10:22:47.409]   - Field: ‘earlySignal’
[10:22:47.410]   - Field: ‘lazy’
[10:22:47.410]   - Field: ‘state’
[10:22:47.410] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:47.410] - Launch lazy future ...
[10:22:47.410] Packages needed by the future expression (n = 0): <none>
[10:22:47.410] Packages needed by future strategies (n = 0): <none>
[10:22:47.411] {
[10:22:47.411]     {
[10:22:47.411]         {
[10:22:47.411]             ...future.startTime <- base::Sys.time()
[10:22:47.411]             {
[10:22:47.411]                 {
[10:22:47.411]                   {
[10:22:47.411]                     {
[10:22:47.411]                       base::local({
[10:22:47.411]                         has_future <- base::requireNamespace("future", 
[10:22:47.411]                           quietly = TRUE)
[10:22:47.411]                         if (has_future) {
[10:22:47.411]                           ns <- base::getNamespace("future")
[10:22:47.411]                           version <- ns[[".package"]][["version"]]
[10:22:47.411]                           if (is.null(version)) 
[10:22:47.411]                             version <- utils::packageVersion("future")
[10:22:47.411]                         }
[10:22:47.411]                         else {
[10:22:47.411]                           version <- NULL
[10:22:47.411]                         }
[10:22:47.411]                         if (!has_future || version < "1.8.0") {
[10:22:47.411]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:47.411]                             "", base::R.version$version.string), 
[10:22:47.411]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:47.411]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:47.411]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:47.411]                               "release", "version")], collapse = " "), 
[10:22:47.411]                             hostname = base::Sys.info()[["nodename"]])
[10:22:47.411]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:47.411]                             info)
[10:22:47.411]                           info <- base::paste(info, collapse = "; ")
[10:22:47.411]                           if (!has_future) {
[10:22:47.411]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:47.411]                               info)
[10:22:47.411]                           }
[10:22:47.411]                           else {
[10:22:47.411]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:47.411]                               info, version)
[10:22:47.411]                           }
[10:22:47.411]                           base::stop(msg)
[10:22:47.411]                         }
[10:22:47.411]                       })
[10:22:47.411]                     }
[10:22:47.411]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:47.411]                     base::options(mc.cores = 1L)
[10:22:47.411]                   }
[10:22:47.411]                   options(future.plan = NULL)
[10:22:47.411]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:47.411]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:47.411]                 }
[10:22:47.411]                 ...future.workdir <- getwd()
[10:22:47.411]             }
[10:22:47.411]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:47.411]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:47.411]         }
[10:22:47.411]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:47.411]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:47.411]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:47.411]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:47.411]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:47.411]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:47.411]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:47.411]             base::names(...future.oldOptions))
[10:22:47.411]     }
[10:22:47.411]     if (FALSE) {
[10:22:47.411]     }
[10:22:47.411]     else {
[10:22:47.411]         if (TRUE) {
[10:22:47.411]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:47.411]                 open = "w")
[10:22:47.411]         }
[10:22:47.411]         else {
[10:22:47.411]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:47.411]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:47.411]         }
[10:22:47.411]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:47.411]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:47.411]             base::sink(type = "output", split = FALSE)
[10:22:47.411]             base::close(...future.stdout)
[10:22:47.411]         }, add = TRUE)
[10:22:47.411]     }
[10:22:47.411]     ...future.frame <- base::sys.nframe()
[10:22:47.411]     ...future.conditions <- base::list()
[10:22:47.411]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:47.411]     if (FALSE) {
[10:22:47.411]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:47.411]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:47.411]     }
[10:22:47.411]     ...future.result <- base::tryCatch({
[10:22:47.411]         base::withCallingHandlers({
[10:22:47.411]             ...future.value <- base::withVisible(base::local({
[10:22:47.411]                 ...future.makeSendCondition <- base::local({
[10:22:47.411]                   sendCondition <- NULL
[10:22:47.411]                   function(frame = 1L) {
[10:22:47.411]                     if (is.function(sendCondition)) 
[10:22:47.411]                       return(sendCondition)
[10:22:47.411]                     ns <- getNamespace("parallel")
[10:22:47.411]                     if (exists("sendData", mode = "function", 
[10:22:47.411]                       envir = ns)) {
[10:22:47.411]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:47.411]                         envir = ns)
[10:22:47.411]                       envir <- sys.frame(frame)
[10:22:47.411]                       master <- NULL
[10:22:47.411]                       while (!identical(envir, .GlobalEnv) && 
[10:22:47.411]                         !identical(envir, emptyenv())) {
[10:22:47.411]                         if (exists("master", mode = "list", envir = envir, 
[10:22:47.411]                           inherits = FALSE)) {
[10:22:47.411]                           master <- get("master", mode = "list", 
[10:22:47.411]                             envir = envir, inherits = FALSE)
[10:22:47.411]                           if (inherits(master, c("SOCKnode", 
[10:22:47.411]                             "SOCK0node"))) {
[10:22:47.411]                             sendCondition <<- function(cond) {
[10:22:47.411]                               data <- list(type = "VALUE", value = cond, 
[10:22:47.411]                                 success = TRUE)
[10:22:47.411]                               parallel_sendData(master, data)
[10:22:47.411]                             }
[10:22:47.411]                             return(sendCondition)
[10:22:47.411]                           }
[10:22:47.411]                         }
[10:22:47.411]                         frame <- frame + 1L
[10:22:47.411]                         envir <- sys.frame(frame)
[10:22:47.411]                       }
[10:22:47.411]                     }
[10:22:47.411]                     sendCondition <<- function(cond) NULL
[10:22:47.411]                   }
[10:22:47.411]                 })
[10:22:47.411]                 withCallingHandlers({
[10:22:47.411]                   {
[10:22:47.411]                     do.call(function(...) {
[10:22:47.411]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.411]                       if (!identical(...future.globals.maxSize.org, 
[10:22:47.411]                         ...future.globals.maxSize)) {
[10:22:47.411]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.411]                         on.exit(options(oopts), add = TRUE)
[10:22:47.411]                       }
[10:22:47.411]                       {
[10:22:47.411]                         lapply(seq_along(...future.elements_ii), 
[10:22:47.411]                           FUN = function(jj) {
[10:22:47.411]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.411]                             ...future.FUN(...future.X_jj, ...)
[10:22:47.411]                           })
[10:22:47.411]                       }
[10:22:47.411]                     }, args = future.call.arguments)
[10:22:47.411]                   }
[10:22:47.411]                 }, immediateCondition = function(cond) {
[10:22:47.411]                   sendCondition <- ...future.makeSendCondition()
[10:22:47.411]                   sendCondition(cond)
[10:22:47.411]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.411]                   {
[10:22:47.411]                     inherits <- base::inherits
[10:22:47.411]                     invokeRestart <- base::invokeRestart
[10:22:47.411]                     is.null <- base::is.null
[10:22:47.411]                     muffled <- FALSE
[10:22:47.411]                     if (inherits(cond, "message")) {
[10:22:47.411]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:47.411]                       if (muffled) 
[10:22:47.411]                         invokeRestart("muffleMessage")
[10:22:47.411]                     }
[10:22:47.411]                     else if (inherits(cond, "warning")) {
[10:22:47.411]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:47.411]                       if (muffled) 
[10:22:47.411]                         invokeRestart("muffleWarning")
[10:22:47.411]                     }
[10:22:47.411]                     else if (inherits(cond, "condition")) {
[10:22:47.411]                       if (!is.null(pattern)) {
[10:22:47.411]                         computeRestarts <- base::computeRestarts
[10:22:47.411]                         grepl <- base::grepl
[10:22:47.411]                         restarts <- computeRestarts(cond)
[10:22:47.411]                         for (restart in restarts) {
[10:22:47.411]                           name <- restart$name
[10:22:47.411]                           if (is.null(name)) 
[10:22:47.411]                             next
[10:22:47.411]                           if (!grepl(pattern, name)) 
[10:22:47.411]                             next
[10:22:47.411]                           invokeRestart(restart)
[10:22:47.411]                           muffled <- TRUE
[10:22:47.411]                           break
[10:22:47.411]                         }
[10:22:47.411]                       }
[10:22:47.411]                     }
[10:22:47.411]                     invisible(muffled)
[10:22:47.411]                   }
[10:22:47.411]                   muffleCondition(cond)
[10:22:47.411]                 })
[10:22:47.411]             }))
[10:22:47.411]             future::FutureResult(value = ...future.value$value, 
[10:22:47.411]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:47.411]                   ...future.rng), globalenv = if (FALSE) 
[10:22:47.411]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:47.411]                     ...future.globalenv.names))
[10:22:47.411]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:47.411]         }, condition = base::local({
[10:22:47.411]             c <- base::c
[10:22:47.411]             inherits <- base::inherits
[10:22:47.411]             invokeRestart <- base::invokeRestart
[10:22:47.411]             length <- base::length
[10:22:47.411]             list <- base::list
[10:22:47.411]             seq.int <- base::seq.int
[10:22:47.411]             signalCondition <- base::signalCondition
[10:22:47.411]             sys.calls <- base::sys.calls
[10:22:47.411]             `[[` <- base::`[[`
[10:22:47.411]             `+` <- base::`+`
[10:22:47.411]             `<<-` <- base::`<<-`
[10:22:47.411]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:47.411]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:47.411]                   3L)]
[10:22:47.411]             }
[10:22:47.411]             function(cond) {
[10:22:47.411]                 is_error <- inherits(cond, "error")
[10:22:47.411]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:47.411]                   NULL)
[10:22:47.411]                 if (is_error) {
[10:22:47.411]                   sessionInformation <- function() {
[10:22:47.411]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:47.411]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:47.411]                       search = base::search(), system = base::Sys.info())
[10:22:47.411]                   }
[10:22:47.411]                   ...future.conditions[[length(...future.conditions) + 
[10:22:47.411]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:47.411]                     cond$call), session = sessionInformation(), 
[10:22:47.411]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:47.411]                   signalCondition(cond)
[10:22:47.411]                 }
[10:22:47.411]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:47.411]                 "immediateCondition"))) {
[10:22:47.411]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:47.411]                   ...future.conditions[[length(...future.conditions) + 
[10:22:47.411]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:47.411]                   if (TRUE && !signal) {
[10:22:47.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.411]                     {
[10:22:47.411]                       inherits <- base::inherits
[10:22:47.411]                       invokeRestart <- base::invokeRestart
[10:22:47.411]                       is.null <- base::is.null
[10:22:47.411]                       muffled <- FALSE
[10:22:47.411]                       if (inherits(cond, "message")) {
[10:22:47.411]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:47.411]                         if (muffled) 
[10:22:47.411]                           invokeRestart("muffleMessage")
[10:22:47.411]                       }
[10:22:47.411]                       else if (inherits(cond, "warning")) {
[10:22:47.411]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:47.411]                         if (muffled) 
[10:22:47.411]                           invokeRestart("muffleWarning")
[10:22:47.411]                       }
[10:22:47.411]                       else if (inherits(cond, "condition")) {
[10:22:47.411]                         if (!is.null(pattern)) {
[10:22:47.411]                           computeRestarts <- base::computeRestarts
[10:22:47.411]                           grepl <- base::grepl
[10:22:47.411]                           restarts <- computeRestarts(cond)
[10:22:47.411]                           for (restart in restarts) {
[10:22:47.411]                             name <- restart$name
[10:22:47.411]                             if (is.null(name)) 
[10:22:47.411]                               next
[10:22:47.411]                             if (!grepl(pattern, name)) 
[10:22:47.411]                               next
[10:22:47.411]                             invokeRestart(restart)
[10:22:47.411]                             muffled <- TRUE
[10:22:47.411]                             break
[10:22:47.411]                           }
[10:22:47.411]                         }
[10:22:47.411]                       }
[10:22:47.411]                       invisible(muffled)
[10:22:47.411]                     }
[10:22:47.411]                     muffleCondition(cond, pattern = "^muffle")
[10:22:47.411]                   }
[10:22:47.411]                 }
[10:22:47.411]                 else {
[10:22:47.411]                   if (TRUE) {
[10:22:47.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.411]                     {
[10:22:47.411]                       inherits <- base::inherits
[10:22:47.411]                       invokeRestart <- base::invokeRestart
[10:22:47.411]                       is.null <- base::is.null
[10:22:47.411]                       muffled <- FALSE
[10:22:47.411]                       if (inherits(cond, "message")) {
[10:22:47.411]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:47.411]                         if (muffled) 
[10:22:47.411]                           invokeRestart("muffleMessage")
[10:22:47.411]                       }
[10:22:47.411]                       else if (inherits(cond, "warning")) {
[10:22:47.411]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:47.411]                         if (muffled) 
[10:22:47.411]                           invokeRestart("muffleWarning")
[10:22:47.411]                       }
[10:22:47.411]                       else if (inherits(cond, "condition")) {
[10:22:47.411]                         if (!is.null(pattern)) {
[10:22:47.411]                           computeRestarts <- base::computeRestarts
[10:22:47.411]                           grepl <- base::grepl
[10:22:47.411]                           restarts <- computeRestarts(cond)
[10:22:47.411]                           for (restart in restarts) {
[10:22:47.411]                             name <- restart$name
[10:22:47.411]                             if (is.null(name)) 
[10:22:47.411]                               next
[10:22:47.411]                             if (!grepl(pattern, name)) 
[10:22:47.411]                               next
[10:22:47.411]                             invokeRestart(restart)
[10:22:47.411]                             muffled <- TRUE
[10:22:47.411]                             break
[10:22:47.411]                           }
[10:22:47.411]                         }
[10:22:47.411]                       }
[10:22:47.411]                       invisible(muffled)
[10:22:47.411]                     }
[10:22:47.411]                     muffleCondition(cond, pattern = "^muffle")
[10:22:47.411]                   }
[10:22:47.411]                 }
[10:22:47.411]             }
[10:22:47.411]         }))
[10:22:47.411]     }, error = function(ex) {
[10:22:47.411]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:47.411]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:47.411]                 ...future.rng), started = ...future.startTime, 
[10:22:47.411]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:47.411]             version = "1.8"), class = "FutureResult")
[10:22:47.411]     }, finally = {
[10:22:47.411]         if (!identical(...future.workdir, getwd())) 
[10:22:47.411]             setwd(...future.workdir)
[10:22:47.411]         {
[10:22:47.411]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:47.411]                 ...future.oldOptions$nwarnings <- NULL
[10:22:47.411]             }
[10:22:47.411]             base::options(...future.oldOptions)
[10:22:47.411]             if (.Platform$OS.type == "windows") {
[10:22:47.411]                 old_names <- names(...future.oldEnvVars)
[10:22:47.411]                 envs <- base::Sys.getenv()
[10:22:47.411]                 names <- names(envs)
[10:22:47.411]                 common <- intersect(names, old_names)
[10:22:47.411]                 added <- setdiff(names, old_names)
[10:22:47.411]                 removed <- setdiff(old_names, names)
[10:22:47.411]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:47.411]                   envs[common]]
[10:22:47.411]                 NAMES <- toupper(changed)
[10:22:47.411]                 args <- list()
[10:22:47.411]                 for (kk in seq_along(NAMES)) {
[10:22:47.411]                   name <- changed[[kk]]
[10:22:47.411]                   NAME <- NAMES[[kk]]
[10:22:47.411]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.411]                     next
[10:22:47.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:47.411]                 }
[10:22:47.411]                 NAMES <- toupper(added)
[10:22:47.411]                 for (kk in seq_along(NAMES)) {
[10:22:47.411]                   name <- added[[kk]]
[10:22:47.411]                   NAME <- NAMES[[kk]]
[10:22:47.411]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.411]                     next
[10:22:47.411]                   args[[name]] <- ""
[10:22:47.411]                 }
[10:22:47.411]                 NAMES <- toupper(removed)
[10:22:47.411]                 for (kk in seq_along(NAMES)) {
[10:22:47.411]                   name <- removed[[kk]]
[10:22:47.411]                   NAME <- NAMES[[kk]]
[10:22:47.411]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.411]                     next
[10:22:47.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:47.411]                 }
[10:22:47.411]                 if (length(args) > 0) 
[10:22:47.411]                   base::do.call(base::Sys.setenv, args = args)
[10:22:47.411]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:47.411]             }
[10:22:47.411]             else {
[10:22:47.411]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:47.411]             }
[10:22:47.411]             {
[10:22:47.411]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:47.411]                   0L) {
[10:22:47.411]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:47.411]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:47.411]                   base::options(opts)
[10:22:47.411]                 }
[10:22:47.411]                 {
[10:22:47.411]                   {
[10:22:47.411]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:47.411]                     NULL
[10:22:47.411]                   }
[10:22:47.411]                   options(future.plan = NULL)
[10:22:47.411]                   if (is.na(NA_character_)) 
[10:22:47.411]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:47.411]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:47.411]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:47.411]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:47.411]                     envir = parent.frame()) 
[10:22:47.411]                   {
[10:22:47.411]                     if (is.function(workers)) 
[10:22:47.411]                       workers <- workers()
[10:22:47.411]                     workers <- structure(as.integer(workers), 
[10:22:47.411]                       class = class(workers))
[10:22:47.411]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:47.411]                       workers >= 1)
[10:22:47.411]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:47.411]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:47.411]                     }
[10:22:47.411]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:47.411]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:47.411]                       envir = envir)
[10:22:47.411]                     if (!future$lazy) 
[10:22:47.411]                       future <- run(future)
[10:22:47.411]                     invisible(future)
[10:22:47.411]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:47.411]                 }
[10:22:47.411]             }
[10:22:47.411]         }
[10:22:47.411]     })
[10:22:47.411]     if (TRUE) {
[10:22:47.411]         base::sink(type = "output", split = FALSE)
[10:22:47.411]         if (TRUE) {
[10:22:47.411]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:47.411]         }
[10:22:47.411]         else {
[10:22:47.411]             ...future.result["stdout"] <- base::list(NULL)
[10:22:47.411]         }
[10:22:47.411]         base::close(...future.stdout)
[10:22:47.411]         ...future.stdout <- NULL
[10:22:47.411]     }
[10:22:47.411]     ...future.result$conditions <- ...future.conditions
[10:22:47.411]     ...future.result$finished <- base::Sys.time()
[10:22:47.411]     ...future.result
[10:22:47.411] }
[10:22:47.414] Exporting 5 global objects (1.97 KiB) to cluster node #1 ...
[10:22:47.414] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:22:47.414] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:22:47.414] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #1 ...
[10:22:47.415] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #1 ... DONE
[10:22:47.415] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #1 ...
[10:22:47.415] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #1 ... DONE
[10:22:47.415] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:22:47.416] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:22:47.416] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[10:22:47.416] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[10:22:47.416] Exporting 5 global objects (1.97 KiB) to cluster node #1 ... DONE
[10:22:47.417] MultisessionFuture started
[10:22:47.417] - Launch lazy future ... done
[10:22:47.417] run() for ‘MultisessionFuture’ ... done
[10:22:47.417] Created future:
[10:22:47.417] MultisessionFuture:
[10:22:47.417] Label: ‘future_apply-1’
[10:22:47.417] Expression:
[10:22:47.417] {
[10:22:47.417]     do.call(function(...) {
[10:22:47.417]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.417]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:47.417]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.417]             on.exit(options(oopts), add = TRUE)
[10:22:47.417]         }
[10:22:47.417]         {
[10:22:47.417]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:47.417]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.417]                 ...future.FUN(...future.X_jj, ...)
[10:22:47.417]             })
[10:22:47.417]         }
[10:22:47.417]     }, args = future.call.arguments)
[10:22:47.417] }
[10:22:47.417] Lazy evaluation: FALSE
[10:22:47.417] Asynchronous evaluation: TRUE
[10:22:47.417] Local evaluation: TRUE
[10:22:47.417] Environment: R_GlobalEnv
[10:22:47.417] Capture standard output: TRUE
[10:22:47.417] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:47.417] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:47.417] Packages: <none>
[10:22:47.417] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:47.417] Resolved: FALSE
[10:22:47.417] Value: <not collected>
[10:22:47.417] Conditions captured: <none>
[10:22:47.417] Early signaling: FALSE
[10:22:47.417] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:47.417] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:47.429] Chunk #1 of 2 ... DONE
[10:22:47.429] Chunk #2 of 2 ...
[10:22:47.429]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:47.429]  - seeds: <none>
[10:22:47.429]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.429] getGlobalsAndPackages() ...
[10:22:47.429] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.429] Resolving globals: FALSE
[10:22:47.430] Tweak future expression to call with '...' arguments ...
[10:22:47.430] {
[10:22:47.430]     do.call(function(...) {
[10:22:47.430]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.430]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:47.430]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.430]             on.exit(options(oopts), add = TRUE)
[10:22:47.430]         }
[10:22:47.430]         {
[10:22:47.430]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:47.430]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.430]                 ...future.FUN(...future.X_jj, ...)
[10:22:47.430]             })
[10:22:47.430]         }
[10:22:47.430]     }, args = future.call.arguments)
[10:22:47.430] }
[10:22:47.430] Tweak future expression to call with '...' arguments ... DONE
[10:22:47.430] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.430] 
[10:22:47.430] getGlobalsAndPackages() ... DONE
[10:22:47.431] run() for ‘Future’ ...
[10:22:47.431] - state: ‘created’
[10:22:47.431] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:47.444] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:47.445] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:47.445]   - Field: ‘node’
[10:22:47.445]   - Field: ‘label’
[10:22:47.445]   - Field: ‘local’
[10:22:47.445]   - Field: ‘owner’
[10:22:47.445]   - Field: ‘envir’
[10:22:47.445]   - Field: ‘workers’
[10:22:47.445]   - Field: ‘packages’
[10:22:47.445]   - Field: ‘gc’
[10:22:47.445]   - Field: ‘conditions’
[10:22:47.446]   - Field: ‘persistent’
[10:22:47.446]   - Field: ‘expr’
[10:22:47.446]   - Field: ‘uuid’
[10:22:47.446]   - Field: ‘seed’
[10:22:47.446]   - Field: ‘version’
[10:22:47.446]   - Field: ‘result’
[10:22:47.446]   - Field: ‘asynchronous’
[10:22:47.446]   - Field: ‘calls’
[10:22:47.446]   - Field: ‘globals’
[10:22:47.446]   - Field: ‘stdout’
[10:22:47.446]   - Field: ‘earlySignal’
[10:22:47.447]   - Field: ‘lazy’
[10:22:47.447]   - Field: ‘state’
[10:22:47.447] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:47.447] - Launch lazy future ...
[10:22:47.447] Packages needed by the future expression (n = 0): <none>
[10:22:47.447] Packages needed by future strategies (n = 0): <none>
[10:22:47.448] {
[10:22:47.448]     {
[10:22:47.448]         {
[10:22:47.448]             ...future.startTime <- base::Sys.time()
[10:22:47.448]             {
[10:22:47.448]                 {
[10:22:47.448]                   {
[10:22:47.448]                     {
[10:22:47.448]                       base::local({
[10:22:47.448]                         has_future <- base::requireNamespace("future", 
[10:22:47.448]                           quietly = TRUE)
[10:22:47.448]                         if (has_future) {
[10:22:47.448]                           ns <- base::getNamespace("future")
[10:22:47.448]                           version <- ns[[".package"]][["version"]]
[10:22:47.448]                           if (is.null(version)) 
[10:22:47.448]                             version <- utils::packageVersion("future")
[10:22:47.448]                         }
[10:22:47.448]                         else {
[10:22:47.448]                           version <- NULL
[10:22:47.448]                         }
[10:22:47.448]                         if (!has_future || version < "1.8.0") {
[10:22:47.448]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:47.448]                             "", base::R.version$version.string), 
[10:22:47.448]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:47.448]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:47.448]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:47.448]                               "release", "version")], collapse = " "), 
[10:22:47.448]                             hostname = base::Sys.info()[["nodename"]])
[10:22:47.448]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:47.448]                             info)
[10:22:47.448]                           info <- base::paste(info, collapse = "; ")
[10:22:47.448]                           if (!has_future) {
[10:22:47.448]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:47.448]                               info)
[10:22:47.448]                           }
[10:22:47.448]                           else {
[10:22:47.448]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:47.448]                               info, version)
[10:22:47.448]                           }
[10:22:47.448]                           base::stop(msg)
[10:22:47.448]                         }
[10:22:47.448]                       })
[10:22:47.448]                     }
[10:22:47.448]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:47.448]                     base::options(mc.cores = 1L)
[10:22:47.448]                   }
[10:22:47.448]                   options(future.plan = NULL)
[10:22:47.448]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:47.448]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:47.448]                 }
[10:22:47.448]                 ...future.workdir <- getwd()
[10:22:47.448]             }
[10:22:47.448]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:47.448]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:47.448]         }
[10:22:47.448]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:47.448]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:47.448]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:47.448]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:47.448]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:47.448]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:47.448]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:47.448]             base::names(...future.oldOptions))
[10:22:47.448]     }
[10:22:47.448]     if (FALSE) {
[10:22:47.448]     }
[10:22:47.448]     else {
[10:22:47.448]         if (TRUE) {
[10:22:47.448]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:47.448]                 open = "w")
[10:22:47.448]         }
[10:22:47.448]         else {
[10:22:47.448]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:47.448]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:47.448]         }
[10:22:47.448]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:47.448]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:47.448]             base::sink(type = "output", split = FALSE)
[10:22:47.448]             base::close(...future.stdout)
[10:22:47.448]         }, add = TRUE)
[10:22:47.448]     }
[10:22:47.448]     ...future.frame <- base::sys.nframe()
[10:22:47.448]     ...future.conditions <- base::list()
[10:22:47.448]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:47.448]     if (FALSE) {
[10:22:47.448]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:47.448]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:47.448]     }
[10:22:47.448]     ...future.result <- base::tryCatch({
[10:22:47.448]         base::withCallingHandlers({
[10:22:47.448]             ...future.value <- base::withVisible(base::local({
[10:22:47.448]                 ...future.makeSendCondition <- base::local({
[10:22:47.448]                   sendCondition <- NULL
[10:22:47.448]                   function(frame = 1L) {
[10:22:47.448]                     if (is.function(sendCondition)) 
[10:22:47.448]                       return(sendCondition)
[10:22:47.448]                     ns <- getNamespace("parallel")
[10:22:47.448]                     if (exists("sendData", mode = "function", 
[10:22:47.448]                       envir = ns)) {
[10:22:47.448]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:47.448]                         envir = ns)
[10:22:47.448]                       envir <- sys.frame(frame)
[10:22:47.448]                       master <- NULL
[10:22:47.448]                       while (!identical(envir, .GlobalEnv) && 
[10:22:47.448]                         !identical(envir, emptyenv())) {
[10:22:47.448]                         if (exists("master", mode = "list", envir = envir, 
[10:22:47.448]                           inherits = FALSE)) {
[10:22:47.448]                           master <- get("master", mode = "list", 
[10:22:47.448]                             envir = envir, inherits = FALSE)
[10:22:47.448]                           if (inherits(master, c("SOCKnode", 
[10:22:47.448]                             "SOCK0node"))) {
[10:22:47.448]                             sendCondition <<- function(cond) {
[10:22:47.448]                               data <- list(type = "VALUE", value = cond, 
[10:22:47.448]                                 success = TRUE)
[10:22:47.448]                               parallel_sendData(master, data)
[10:22:47.448]                             }
[10:22:47.448]                             return(sendCondition)
[10:22:47.448]                           }
[10:22:47.448]                         }
[10:22:47.448]                         frame <- frame + 1L
[10:22:47.448]                         envir <- sys.frame(frame)
[10:22:47.448]                       }
[10:22:47.448]                     }
[10:22:47.448]                     sendCondition <<- function(cond) NULL
[10:22:47.448]                   }
[10:22:47.448]                 })
[10:22:47.448]                 withCallingHandlers({
[10:22:47.448]                   {
[10:22:47.448]                     do.call(function(...) {
[10:22:47.448]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.448]                       if (!identical(...future.globals.maxSize.org, 
[10:22:47.448]                         ...future.globals.maxSize)) {
[10:22:47.448]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.448]                         on.exit(options(oopts), add = TRUE)
[10:22:47.448]                       }
[10:22:47.448]                       {
[10:22:47.448]                         lapply(seq_along(...future.elements_ii), 
[10:22:47.448]                           FUN = function(jj) {
[10:22:47.448]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.448]                             ...future.FUN(...future.X_jj, ...)
[10:22:47.448]                           })
[10:22:47.448]                       }
[10:22:47.448]                     }, args = future.call.arguments)
[10:22:47.448]                   }
[10:22:47.448]                 }, immediateCondition = function(cond) {
[10:22:47.448]                   sendCondition <- ...future.makeSendCondition()
[10:22:47.448]                   sendCondition(cond)
[10:22:47.448]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.448]                   {
[10:22:47.448]                     inherits <- base::inherits
[10:22:47.448]                     invokeRestart <- base::invokeRestart
[10:22:47.448]                     is.null <- base::is.null
[10:22:47.448]                     muffled <- FALSE
[10:22:47.448]                     if (inherits(cond, "message")) {
[10:22:47.448]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:47.448]                       if (muffled) 
[10:22:47.448]                         invokeRestart("muffleMessage")
[10:22:47.448]                     }
[10:22:47.448]                     else if (inherits(cond, "warning")) {
[10:22:47.448]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:47.448]                       if (muffled) 
[10:22:47.448]                         invokeRestart("muffleWarning")
[10:22:47.448]                     }
[10:22:47.448]                     else if (inherits(cond, "condition")) {
[10:22:47.448]                       if (!is.null(pattern)) {
[10:22:47.448]                         computeRestarts <- base::computeRestarts
[10:22:47.448]                         grepl <- base::grepl
[10:22:47.448]                         restarts <- computeRestarts(cond)
[10:22:47.448]                         for (restart in restarts) {
[10:22:47.448]                           name <- restart$name
[10:22:47.448]                           if (is.null(name)) 
[10:22:47.448]                             next
[10:22:47.448]                           if (!grepl(pattern, name)) 
[10:22:47.448]                             next
[10:22:47.448]                           invokeRestart(restart)
[10:22:47.448]                           muffled <- TRUE
[10:22:47.448]                           break
[10:22:47.448]                         }
[10:22:47.448]                       }
[10:22:47.448]                     }
[10:22:47.448]                     invisible(muffled)
[10:22:47.448]                   }
[10:22:47.448]                   muffleCondition(cond)
[10:22:47.448]                 })
[10:22:47.448]             }))
[10:22:47.448]             future::FutureResult(value = ...future.value$value, 
[10:22:47.448]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:47.448]                   ...future.rng), globalenv = if (FALSE) 
[10:22:47.448]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:47.448]                     ...future.globalenv.names))
[10:22:47.448]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:47.448]         }, condition = base::local({
[10:22:47.448]             c <- base::c
[10:22:47.448]             inherits <- base::inherits
[10:22:47.448]             invokeRestart <- base::invokeRestart
[10:22:47.448]             length <- base::length
[10:22:47.448]             list <- base::list
[10:22:47.448]             seq.int <- base::seq.int
[10:22:47.448]             signalCondition <- base::signalCondition
[10:22:47.448]             sys.calls <- base::sys.calls
[10:22:47.448]             `[[` <- base::`[[`
[10:22:47.448]             `+` <- base::`+`
[10:22:47.448]             `<<-` <- base::`<<-`
[10:22:47.448]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:47.448]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:47.448]                   3L)]
[10:22:47.448]             }
[10:22:47.448]             function(cond) {
[10:22:47.448]                 is_error <- inherits(cond, "error")
[10:22:47.448]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:47.448]                   NULL)
[10:22:47.448]                 if (is_error) {
[10:22:47.448]                   sessionInformation <- function() {
[10:22:47.448]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:47.448]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:47.448]                       search = base::search(), system = base::Sys.info())
[10:22:47.448]                   }
[10:22:47.448]                   ...future.conditions[[length(...future.conditions) + 
[10:22:47.448]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:47.448]                     cond$call), session = sessionInformation(), 
[10:22:47.448]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:47.448]                   signalCondition(cond)
[10:22:47.448]                 }
[10:22:47.448]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:47.448]                 "immediateCondition"))) {
[10:22:47.448]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:47.448]                   ...future.conditions[[length(...future.conditions) + 
[10:22:47.448]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:47.448]                   if (TRUE && !signal) {
[10:22:47.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.448]                     {
[10:22:47.448]                       inherits <- base::inherits
[10:22:47.448]                       invokeRestart <- base::invokeRestart
[10:22:47.448]                       is.null <- base::is.null
[10:22:47.448]                       muffled <- FALSE
[10:22:47.448]                       if (inherits(cond, "message")) {
[10:22:47.448]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:47.448]                         if (muffled) 
[10:22:47.448]                           invokeRestart("muffleMessage")
[10:22:47.448]                       }
[10:22:47.448]                       else if (inherits(cond, "warning")) {
[10:22:47.448]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:47.448]                         if (muffled) 
[10:22:47.448]                           invokeRestart("muffleWarning")
[10:22:47.448]                       }
[10:22:47.448]                       else if (inherits(cond, "condition")) {
[10:22:47.448]                         if (!is.null(pattern)) {
[10:22:47.448]                           computeRestarts <- base::computeRestarts
[10:22:47.448]                           grepl <- base::grepl
[10:22:47.448]                           restarts <- computeRestarts(cond)
[10:22:47.448]                           for (restart in restarts) {
[10:22:47.448]                             name <- restart$name
[10:22:47.448]                             if (is.null(name)) 
[10:22:47.448]                               next
[10:22:47.448]                             if (!grepl(pattern, name)) 
[10:22:47.448]                               next
[10:22:47.448]                             invokeRestart(restart)
[10:22:47.448]                             muffled <- TRUE
[10:22:47.448]                             break
[10:22:47.448]                           }
[10:22:47.448]                         }
[10:22:47.448]                       }
[10:22:47.448]                       invisible(muffled)
[10:22:47.448]                     }
[10:22:47.448]                     muffleCondition(cond, pattern = "^muffle")
[10:22:47.448]                   }
[10:22:47.448]                 }
[10:22:47.448]                 else {
[10:22:47.448]                   if (TRUE) {
[10:22:47.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.448]                     {
[10:22:47.448]                       inherits <- base::inherits
[10:22:47.448]                       invokeRestart <- base::invokeRestart
[10:22:47.448]                       is.null <- base::is.null
[10:22:47.448]                       muffled <- FALSE
[10:22:47.448]                       if (inherits(cond, "message")) {
[10:22:47.448]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:47.448]                         if (muffled) 
[10:22:47.448]                           invokeRestart("muffleMessage")
[10:22:47.448]                       }
[10:22:47.448]                       else if (inherits(cond, "warning")) {
[10:22:47.448]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:47.448]                         if (muffled) 
[10:22:47.448]                           invokeRestart("muffleWarning")
[10:22:47.448]                       }
[10:22:47.448]                       else if (inherits(cond, "condition")) {
[10:22:47.448]                         if (!is.null(pattern)) {
[10:22:47.448]                           computeRestarts <- base::computeRestarts
[10:22:47.448]                           grepl <- base::grepl
[10:22:47.448]                           restarts <- computeRestarts(cond)
[10:22:47.448]                           for (restart in restarts) {
[10:22:47.448]                             name <- restart$name
[10:22:47.448]                             if (is.null(name)) 
[10:22:47.448]                               next
[10:22:47.448]                             if (!grepl(pattern, name)) 
[10:22:47.448]                               next
[10:22:47.448]                             invokeRestart(restart)
[10:22:47.448]                             muffled <- TRUE
[10:22:47.448]                             break
[10:22:47.448]                           }
[10:22:47.448]                         }
[10:22:47.448]                       }
[10:22:47.448]                       invisible(muffled)
[10:22:47.448]                     }
[10:22:47.448]                     muffleCondition(cond, pattern = "^muffle")
[10:22:47.448]                   }
[10:22:47.448]                 }
[10:22:47.448]             }
[10:22:47.448]         }))
[10:22:47.448]     }, error = function(ex) {
[10:22:47.448]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:47.448]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:47.448]                 ...future.rng), started = ...future.startTime, 
[10:22:47.448]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:47.448]             version = "1.8"), class = "FutureResult")
[10:22:47.448]     }, finally = {
[10:22:47.448]         if (!identical(...future.workdir, getwd())) 
[10:22:47.448]             setwd(...future.workdir)
[10:22:47.448]         {
[10:22:47.448]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:47.448]                 ...future.oldOptions$nwarnings <- NULL
[10:22:47.448]             }
[10:22:47.448]             base::options(...future.oldOptions)
[10:22:47.448]             if (.Platform$OS.type == "windows") {
[10:22:47.448]                 old_names <- names(...future.oldEnvVars)
[10:22:47.448]                 envs <- base::Sys.getenv()
[10:22:47.448]                 names <- names(envs)
[10:22:47.448]                 common <- intersect(names, old_names)
[10:22:47.448]                 added <- setdiff(names, old_names)
[10:22:47.448]                 removed <- setdiff(old_names, names)
[10:22:47.448]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:47.448]                   envs[common]]
[10:22:47.448]                 NAMES <- toupper(changed)
[10:22:47.448]                 args <- list()
[10:22:47.448]                 for (kk in seq_along(NAMES)) {
[10:22:47.448]                   name <- changed[[kk]]
[10:22:47.448]                   NAME <- NAMES[[kk]]
[10:22:47.448]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.448]                     next
[10:22:47.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:47.448]                 }
[10:22:47.448]                 NAMES <- toupper(added)
[10:22:47.448]                 for (kk in seq_along(NAMES)) {
[10:22:47.448]                   name <- added[[kk]]
[10:22:47.448]                   NAME <- NAMES[[kk]]
[10:22:47.448]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.448]                     next
[10:22:47.448]                   args[[name]] <- ""
[10:22:47.448]                 }
[10:22:47.448]                 NAMES <- toupper(removed)
[10:22:47.448]                 for (kk in seq_along(NAMES)) {
[10:22:47.448]                   name <- removed[[kk]]
[10:22:47.448]                   NAME <- NAMES[[kk]]
[10:22:47.448]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.448]                     next
[10:22:47.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:47.448]                 }
[10:22:47.448]                 if (length(args) > 0) 
[10:22:47.448]                   base::do.call(base::Sys.setenv, args = args)
[10:22:47.448]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:47.448]             }
[10:22:47.448]             else {
[10:22:47.448]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:47.448]             }
[10:22:47.448]             {
[10:22:47.448]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:47.448]                   0L) {
[10:22:47.448]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:47.448]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:47.448]                   base::options(opts)
[10:22:47.448]                 }
[10:22:47.448]                 {
[10:22:47.448]                   {
[10:22:47.448]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:47.448]                     NULL
[10:22:47.448]                   }
[10:22:47.448]                   options(future.plan = NULL)
[10:22:47.448]                   if (is.na(NA_character_)) 
[10:22:47.448]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:47.448]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:47.448]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:47.448]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:47.448]                     envir = parent.frame()) 
[10:22:47.448]                   {
[10:22:47.448]                     if (is.function(workers)) 
[10:22:47.448]                       workers <- workers()
[10:22:47.448]                     workers <- structure(as.integer(workers), 
[10:22:47.448]                       class = class(workers))
[10:22:47.448]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:47.448]                       workers >= 1)
[10:22:47.448]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:47.448]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:47.448]                     }
[10:22:47.448]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:47.448]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:47.448]                       envir = envir)
[10:22:47.448]                     if (!future$lazy) 
[10:22:47.448]                       future <- run(future)
[10:22:47.448]                     invisible(future)
[10:22:47.448]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:47.448]                 }
[10:22:47.448]             }
[10:22:47.448]         }
[10:22:47.448]     })
[10:22:47.448]     if (TRUE) {
[10:22:47.448]         base::sink(type = "output", split = FALSE)
[10:22:47.448]         if (TRUE) {
[10:22:47.448]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:47.448]         }
[10:22:47.448]         else {
[10:22:47.448]             ...future.result["stdout"] <- base::list(NULL)
[10:22:47.448]         }
[10:22:47.448]         base::close(...future.stdout)
[10:22:47.448]         ...future.stdout <- NULL
[10:22:47.448]     }
[10:22:47.448]     ...future.result$conditions <- ...future.conditions
[10:22:47.448]     ...future.result$finished <- base::Sys.time()
[10:22:47.448]     ...future.result
[10:22:47.448] }
[10:22:47.451] Exporting 5 global objects (1.97 KiB) to cluster node #2 ...
[10:22:47.451] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:22:47.451] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:22:47.451] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #2 ...
[10:22:47.452] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #2 ... DONE
[10:22:47.452] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #2 ...
[10:22:47.452] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #2 ... DONE
[10:22:47.452] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:22:47.453] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:22:47.453] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[10:22:47.453] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[10:22:47.453] Exporting 5 global objects (1.97 KiB) to cluster node #2 ... DONE
[10:22:47.454] MultisessionFuture started
[10:22:47.454] - Launch lazy future ... done
[10:22:47.454] run() for ‘MultisessionFuture’ ... done
[10:22:47.454] Created future:
[10:22:47.454] MultisessionFuture:
[10:22:47.454] Label: ‘future_apply-2’
[10:22:47.454] Expression:
[10:22:47.454] {
[10:22:47.454]     do.call(function(...) {
[10:22:47.454]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.454]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:47.454]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.454]             on.exit(options(oopts), add = TRUE)
[10:22:47.454]         }
[10:22:47.454]         {
[10:22:47.454]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:47.454]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.454]                 ...future.FUN(...future.X_jj, ...)
[10:22:47.454]             })
[10:22:47.454]         }
[10:22:47.454]     }, args = future.call.arguments)
[10:22:47.454] }
[10:22:47.454] Lazy evaluation: FALSE
[10:22:47.454] Asynchronous evaluation: TRUE
[10:22:47.454] Local evaluation: TRUE
[10:22:47.454] Environment: R_GlobalEnv
[10:22:47.454] Capture standard output: TRUE
[10:22:47.454] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:47.454] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:47.454] Packages: <none>
[10:22:47.454] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:47.454] Resolved: FALSE
[10:22:47.454] Value: <not collected>
[10:22:47.454] Conditions captured: <none>
[10:22:47.454] Early signaling: FALSE
[10:22:47.454] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:47.454] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:47.466] Chunk #2 of 2 ... DONE
[10:22:47.466] Launching 2 futures (chunks) ... DONE
[10:22:47.466] Resolving 2 futures (chunks) ...
[10:22:47.466] resolve() on list ...
[10:22:47.466]  recursive: 0
[10:22:47.466]  length: 2
[10:22:47.466] 
[10:22:47.467] receiveMessageFromWorker() for ClusterFuture ...
[10:22:47.467] - Validating connection of MultisessionFuture
[10:22:47.467] - received message: FutureResult
[10:22:47.467] - Received FutureResult
[10:22:47.467] - Erased future from FutureRegistry
[10:22:47.468] result() for ClusterFuture ...
[10:22:47.468] - result already collected: FutureResult
[10:22:47.468] result() for ClusterFuture ... done
[10:22:47.468] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:47.468] Future #1
[10:22:47.468] result() for ClusterFuture ...
[10:22:47.468] - result already collected: FutureResult
[10:22:47.468] result() for ClusterFuture ... done
[10:22:47.468] result() for ClusterFuture ...
[10:22:47.468] - result already collected: FutureResult
[10:22:47.468] result() for ClusterFuture ... done
[10:22:47.469] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:22:47.469] - nx: 2
[10:22:47.469] - relay: TRUE
[10:22:47.469] - stdout: TRUE
[10:22:47.469] - signal: TRUE
[10:22:47.469] - resignal: FALSE
[10:22:47.469] - force: TRUE
[10:22:47.469] - relayed: [n=2] FALSE, FALSE
[10:22:47.469] - queued futures: [n=2] FALSE, FALSE
[10:22:47.469]  - until=1
[10:22:47.469]  - relaying element #1
[10:22:47.470] result() for ClusterFuture ...
[10:22:47.470] - result already collected: FutureResult
[10:22:47.470] result() for ClusterFuture ... done
[10:22:47.470] result() for ClusterFuture ...
[10:22:47.470] - result already collected: FutureResult
[10:22:47.470] result() for ClusterFuture ... done
[10:22:47.470] result() for ClusterFuture ...
[10:22:47.470] - result already collected: FutureResult
[10:22:47.470] result() for ClusterFuture ... done
[10:22:47.470] result() for ClusterFuture ...
[10:22:47.470] - result already collected: FutureResult
[10:22:47.471] result() for ClusterFuture ... done
[10:22:47.471] - relayed: [n=2] TRUE, FALSE
[10:22:47.471] - queued futures: [n=2] TRUE, FALSE
[10:22:47.471] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:22:47.471]  length: 1 (resolved future 1)
[10:22:47.513] receiveMessageFromWorker() for ClusterFuture ...
[10:22:47.513] - Validating connection of MultisessionFuture
[10:22:47.513] - received message: FutureResult
[10:22:47.513] - Received FutureResult
[10:22:47.513] - Erased future from FutureRegistry
[10:22:47.513] result() for ClusterFuture ...
[10:22:47.514] - result already collected: FutureResult
[10:22:47.514] result() for ClusterFuture ... done
[10:22:47.516] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:47.516] Future #2
[10:22:47.516] result() for ClusterFuture ...
[10:22:47.517] - result already collected: FutureResult
[10:22:47.517] result() for ClusterFuture ... done
[10:22:47.517] result() for ClusterFuture ...
[10:22:47.517] - result already collected: FutureResult
[10:22:47.517] result() for ClusterFuture ... done
[10:22:47.517] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:22:47.517] - nx: 2
[10:22:47.517] - relay: TRUE
[10:22:47.517] - stdout: TRUE
[10:22:47.517] - signal: TRUE
[10:22:47.518] - resignal: FALSE
[10:22:47.518] - force: TRUE
[10:22:47.518] - relayed: [n=2] TRUE, FALSE
[10:22:47.518] - queued futures: [n=2] TRUE, FALSE
[10:22:47.518]  - until=2
[10:22:47.518]  - relaying element #2
[10:22:47.518] result() for ClusterFuture ...
[10:22:47.518] - result already collected: FutureResult
[10:22:47.518] result() for ClusterFuture ... done
[10:22:47.518] result() for ClusterFuture ...
[10:22:47.518] - result already collected: FutureResult
[10:22:47.519] result() for ClusterFuture ... done
[10:22:47.519] result() for ClusterFuture ...
[10:22:47.519] - result already collected: FutureResult
[10:22:47.519] result() for ClusterFuture ... done
[10:22:47.519] result() for ClusterFuture ...
[10:22:47.519] - result already collected: FutureResult
[10:22:47.519] result() for ClusterFuture ... done
[10:22:47.519] - relayed: [n=2] TRUE, TRUE
[10:22:47.519] - queued futures: [n=2] TRUE, TRUE
[10:22:47.519] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:22:47.520]  length: 0 (resolved future 2)
[10:22:47.520] Relaying remaining futures
[10:22:47.520] signalConditionsASAP(NULL, pos=0) ...
[10:22:47.520] - nx: 2
[10:22:47.520] - relay: TRUE
[10:22:47.520] - stdout: TRUE
[10:22:47.520] - signal: TRUE
[10:22:47.520] - resignal: FALSE
[10:22:47.520] - force: TRUE
[10:22:47.520] - relayed: [n=2] TRUE, TRUE
[10:22:47.520] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:22:47.520] - relayed: [n=2] TRUE, TRUE
[10:22:47.521] - queued futures: [n=2] TRUE, TRUE
[10:22:47.521] signalConditionsASAP(NULL, pos=0) ... done
[10:22:47.521] resolve() on list ... DONE
[10:22:47.521] result() for ClusterFuture ...
[10:22:47.521] - result already collected: FutureResult
[10:22:47.521] result() for ClusterFuture ... done
[10:22:47.521] result() for ClusterFuture ...
[10:22:47.521] - result already collected: FutureResult
[10:22:47.521] result() for ClusterFuture ... done
[10:22:47.521] result() for ClusterFuture ...
[10:22:47.521] - result already collected: FutureResult
[10:22:47.522] result() for ClusterFuture ... done
[10:22:47.522] result() for ClusterFuture ...
[10:22:47.522] - result already collected: FutureResult
[10:22:47.522] result() for ClusterFuture ... done
[10:22:47.522]  - Number of value chunks collected: 2
[10:22:47.522] Resolving 2 futures (chunks) ... DONE
[10:22:47.522] Reducing values from 2 chunks ...
[10:22:47.522]  - Number of values collected after concatenation: 6
[10:22:47.522]  - Number of values expected: 6
[10:22:47.522] Reducing values from 2 chunks ... DONE
[10:22:47.522] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[10:22:47.523] getGlobalsAndPackagesXApply() ...
[10:22:47.523]  - future.globals: TRUE
[10:22:47.523] getGlobalsAndPackages() ...
[10:22:47.523] Searching for globals...
[10:22:47.524] - globals found: [1] ‘FUN’
[10:22:47.524] Searching for globals ... DONE
[10:22:47.524] Resolving globals: FALSE
[10:22:47.525] The total size of the 1 globals is 848 bytes (848 bytes)
[10:22:47.525] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:22:47.525] - globals: [1] ‘FUN’
[10:22:47.525] 
[10:22:47.525] getGlobalsAndPackages() ... DONE
[10:22:47.525]  - globals found/used: [n=1] ‘FUN’
[10:22:47.526]  - needed namespaces: [n=0] 
[10:22:47.526] Finding globals ... DONE
[10:22:47.526]  - use_args: TRUE
[10:22:47.526]  - Getting '...' globals ...
[10:22:47.526] resolve() on list ...
[10:22:47.526]  recursive: 0
[10:22:47.526]  length: 1
[10:22:47.526]  elements: ‘...’
[10:22:47.527]  length: 0 (resolved future 1)
[10:22:47.527] resolve() on list ... DONE
[10:22:47.527]    - '...' content: [n=0] 
[10:22:47.527] List of 1
[10:22:47.527]  $ ...: list()
[10:22:47.527]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:47.527]  - attr(*, "where")=List of 1
[10:22:47.527]   ..$ ...:<environment: 0x55ca4d3360f0> 
[10:22:47.527]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:47.527]  - attr(*, "resolved")= logi TRUE
[10:22:47.527]  - attr(*, "total_size")= num NA
[10:22:47.529]  - Getting '...' globals ... DONE
[10:22:47.530] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:47.530] List of 2
[10:22:47.530]  $ ...future.FUN:function (x)  
[10:22:47.530]  $ ...          : list()
[10:22:47.530]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:47.530]  - attr(*, "where")=List of 2
[10:22:47.530]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:47.530]   ..$ ...          :<environment: 0x55ca4d3360f0> 
[10:22:47.530]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:47.530]  - attr(*, "resolved")= logi FALSE
[10:22:47.530]  - attr(*, "total_size")= num 848
[10:22:47.532] Packages to be attached in all futures: [n=0] 
[10:22:47.532] getGlobalsAndPackagesXApply() ... DONE
[10:22:47.536] future_lapply() ...
[10:22:47.540] Number of chunks: 2
[10:22:47.540] getGlobalsAndPackagesXApply() ...
[10:22:47.540]  - future.globals: <name-value list> with names ‘list()’
[10:22:47.540]  - use_args: TRUE
[10:22:47.540] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:22:47.540] List of 2
[10:22:47.540]  $ ...          : list()
[10:22:47.540]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:47.540]  $ ...future.FUN:function (x)  
[10:22:47.540]  - attr(*, "where")=List of 2
[10:22:47.540]   ..$ ...          :<environment: 0x55ca4d3360f0> 
[10:22:47.540]   ..$ ...future.FUN:<environment: namespace:base> 
[10:22:47.540]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:47.540]  - attr(*, "resolved")= logi FALSE
[10:22:47.540]  - attr(*, "total_size")= num NA
[10:22:47.544] Packages to be attached in all futures: [n=0] 
[10:22:47.544] getGlobalsAndPackagesXApply() ... DONE
[10:22:47.544] Number of futures (= number of chunks): 2
[10:22:47.544] Launching 2 futures (chunks) ...
[10:22:47.544] Chunk #1 of 2 ...
[10:22:47.545]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:47.545]  - seeds: <none>
[10:22:47.545]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.545] getGlobalsAndPackages() ...
[10:22:47.545] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.545] Resolving globals: FALSE
[10:22:47.545] Tweak future expression to call with '...' arguments ...
[10:22:47.545] {
[10:22:47.545]     do.call(function(...) {
[10:22:47.545]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.545]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:47.545]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.545]             on.exit(options(oopts), add = TRUE)
[10:22:47.545]         }
[10:22:47.545]         {
[10:22:47.545]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:47.545]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.545]                 ...future.FUN(...future.X_jj, ...)
[10:22:47.545]             })
[10:22:47.545]         }
[10:22:47.545]     }, args = future.call.arguments)
[10:22:47.545] }
[10:22:47.546] Tweak future expression to call with '...' arguments ... DONE
[10:22:47.546] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.546] 
[10:22:47.546] getGlobalsAndPackages() ... DONE
[10:22:47.547] run() for ‘Future’ ...
[10:22:47.547] - state: ‘created’
[10:22:47.547] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:47.561] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:47.561] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:47.561]   - Field: ‘node’
[10:22:47.561]   - Field: ‘label’
[10:22:47.561]   - Field: ‘local’
[10:22:47.561]   - Field: ‘owner’
[10:22:47.561]   - Field: ‘envir’
[10:22:47.561]   - Field: ‘workers’
[10:22:47.561]   - Field: ‘packages’
[10:22:47.562]   - Field: ‘gc’
[10:22:47.562]   - Field: ‘conditions’
[10:22:47.562]   - Field: ‘persistent’
[10:22:47.562]   - Field: ‘expr’
[10:22:47.562]   - Field: ‘uuid’
[10:22:47.562]   - Field: ‘seed’
[10:22:47.562]   - Field: ‘version’
[10:22:47.562]   - Field: ‘result’
[10:22:47.562]   - Field: ‘asynchronous’
[10:22:47.562]   - Field: ‘calls’
[10:22:47.563]   - Field: ‘globals’
[10:22:47.563]   - Field: ‘stdout’
[10:22:47.563]   - Field: ‘earlySignal’
[10:22:47.563]   - Field: ‘lazy’
[10:22:47.563]   - Field: ‘state’
[10:22:47.563] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:47.563] - Launch lazy future ...
[10:22:47.563] Packages needed by the future expression (n = 0): <none>
[10:22:47.563] Packages needed by future strategies (n = 0): <none>
[10:22:47.564] {
[10:22:47.564]     {
[10:22:47.564]         {
[10:22:47.564]             ...future.startTime <- base::Sys.time()
[10:22:47.564]             {
[10:22:47.564]                 {
[10:22:47.564]                   {
[10:22:47.564]                     {
[10:22:47.564]                       base::local({
[10:22:47.564]                         has_future <- base::requireNamespace("future", 
[10:22:47.564]                           quietly = TRUE)
[10:22:47.564]                         if (has_future) {
[10:22:47.564]                           ns <- base::getNamespace("future")
[10:22:47.564]                           version <- ns[[".package"]][["version"]]
[10:22:47.564]                           if (is.null(version)) 
[10:22:47.564]                             version <- utils::packageVersion("future")
[10:22:47.564]                         }
[10:22:47.564]                         else {
[10:22:47.564]                           version <- NULL
[10:22:47.564]                         }
[10:22:47.564]                         if (!has_future || version < "1.8.0") {
[10:22:47.564]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:47.564]                             "", base::R.version$version.string), 
[10:22:47.564]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:47.564]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:47.564]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:47.564]                               "release", "version")], collapse = " "), 
[10:22:47.564]                             hostname = base::Sys.info()[["nodename"]])
[10:22:47.564]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:47.564]                             info)
[10:22:47.564]                           info <- base::paste(info, collapse = "; ")
[10:22:47.564]                           if (!has_future) {
[10:22:47.564]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:47.564]                               info)
[10:22:47.564]                           }
[10:22:47.564]                           else {
[10:22:47.564]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:47.564]                               info, version)
[10:22:47.564]                           }
[10:22:47.564]                           base::stop(msg)
[10:22:47.564]                         }
[10:22:47.564]                       })
[10:22:47.564]                     }
[10:22:47.564]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:47.564]                     base::options(mc.cores = 1L)
[10:22:47.564]                   }
[10:22:47.564]                   options(future.plan = NULL)
[10:22:47.564]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:47.564]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:47.564]                 }
[10:22:47.564]                 ...future.workdir <- getwd()
[10:22:47.564]             }
[10:22:47.564]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:47.564]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:47.564]         }
[10:22:47.564]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:47.564]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:47.564]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:47.564]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:47.564]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:47.564]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:47.564]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:47.564]             base::names(...future.oldOptions))
[10:22:47.564]     }
[10:22:47.564]     if (FALSE) {
[10:22:47.564]     }
[10:22:47.564]     else {
[10:22:47.564]         if (TRUE) {
[10:22:47.564]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:47.564]                 open = "w")
[10:22:47.564]         }
[10:22:47.564]         else {
[10:22:47.564]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:47.564]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:47.564]         }
[10:22:47.564]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:47.564]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:47.564]             base::sink(type = "output", split = FALSE)
[10:22:47.564]             base::close(...future.stdout)
[10:22:47.564]         }, add = TRUE)
[10:22:47.564]     }
[10:22:47.564]     ...future.frame <- base::sys.nframe()
[10:22:47.564]     ...future.conditions <- base::list()
[10:22:47.564]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:47.564]     if (FALSE) {
[10:22:47.564]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:47.564]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:47.564]     }
[10:22:47.564]     ...future.result <- base::tryCatch({
[10:22:47.564]         base::withCallingHandlers({
[10:22:47.564]             ...future.value <- base::withVisible(base::local({
[10:22:47.564]                 ...future.makeSendCondition <- base::local({
[10:22:47.564]                   sendCondition <- NULL
[10:22:47.564]                   function(frame = 1L) {
[10:22:47.564]                     if (is.function(sendCondition)) 
[10:22:47.564]                       return(sendCondition)
[10:22:47.564]                     ns <- getNamespace("parallel")
[10:22:47.564]                     if (exists("sendData", mode = "function", 
[10:22:47.564]                       envir = ns)) {
[10:22:47.564]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:47.564]                         envir = ns)
[10:22:47.564]                       envir <- sys.frame(frame)
[10:22:47.564]                       master <- NULL
[10:22:47.564]                       while (!identical(envir, .GlobalEnv) && 
[10:22:47.564]                         !identical(envir, emptyenv())) {
[10:22:47.564]                         if (exists("master", mode = "list", envir = envir, 
[10:22:47.564]                           inherits = FALSE)) {
[10:22:47.564]                           master <- get("master", mode = "list", 
[10:22:47.564]                             envir = envir, inherits = FALSE)
[10:22:47.564]                           if (inherits(master, c("SOCKnode", 
[10:22:47.564]                             "SOCK0node"))) {
[10:22:47.564]                             sendCondition <<- function(cond) {
[10:22:47.564]                               data <- list(type = "VALUE", value = cond, 
[10:22:47.564]                                 success = TRUE)
[10:22:47.564]                               parallel_sendData(master, data)
[10:22:47.564]                             }
[10:22:47.564]                             return(sendCondition)
[10:22:47.564]                           }
[10:22:47.564]                         }
[10:22:47.564]                         frame <- frame + 1L
[10:22:47.564]                         envir <- sys.frame(frame)
[10:22:47.564]                       }
[10:22:47.564]                     }
[10:22:47.564]                     sendCondition <<- function(cond) NULL
[10:22:47.564]                   }
[10:22:47.564]                 })
[10:22:47.564]                 withCallingHandlers({
[10:22:47.564]                   {
[10:22:47.564]                     do.call(function(...) {
[10:22:47.564]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.564]                       if (!identical(...future.globals.maxSize.org, 
[10:22:47.564]                         ...future.globals.maxSize)) {
[10:22:47.564]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.564]                         on.exit(options(oopts), add = TRUE)
[10:22:47.564]                       }
[10:22:47.564]                       {
[10:22:47.564]                         lapply(seq_along(...future.elements_ii), 
[10:22:47.564]                           FUN = function(jj) {
[10:22:47.564]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.564]                             ...future.FUN(...future.X_jj, ...)
[10:22:47.564]                           })
[10:22:47.564]                       }
[10:22:47.564]                     }, args = future.call.arguments)
[10:22:47.564]                   }
[10:22:47.564]                 }, immediateCondition = function(cond) {
[10:22:47.564]                   sendCondition <- ...future.makeSendCondition()
[10:22:47.564]                   sendCondition(cond)
[10:22:47.564]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.564]                   {
[10:22:47.564]                     inherits <- base::inherits
[10:22:47.564]                     invokeRestart <- base::invokeRestart
[10:22:47.564]                     is.null <- base::is.null
[10:22:47.564]                     muffled <- FALSE
[10:22:47.564]                     if (inherits(cond, "message")) {
[10:22:47.564]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:47.564]                       if (muffled) 
[10:22:47.564]                         invokeRestart("muffleMessage")
[10:22:47.564]                     }
[10:22:47.564]                     else if (inherits(cond, "warning")) {
[10:22:47.564]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:47.564]                       if (muffled) 
[10:22:47.564]                         invokeRestart("muffleWarning")
[10:22:47.564]                     }
[10:22:47.564]                     else if (inherits(cond, "condition")) {
[10:22:47.564]                       if (!is.null(pattern)) {
[10:22:47.564]                         computeRestarts <- base::computeRestarts
[10:22:47.564]                         grepl <- base::grepl
[10:22:47.564]                         restarts <- computeRestarts(cond)
[10:22:47.564]                         for (restart in restarts) {
[10:22:47.564]                           name <- restart$name
[10:22:47.564]                           if (is.null(name)) 
[10:22:47.564]                             next
[10:22:47.564]                           if (!grepl(pattern, name)) 
[10:22:47.564]                             next
[10:22:47.564]                           invokeRestart(restart)
[10:22:47.564]                           muffled <- TRUE
[10:22:47.564]                           break
[10:22:47.564]                         }
[10:22:47.564]                       }
[10:22:47.564]                     }
[10:22:47.564]                     invisible(muffled)
[10:22:47.564]                   }
[10:22:47.564]                   muffleCondition(cond)
[10:22:47.564]                 })
[10:22:47.564]             }))
[10:22:47.564]             future::FutureResult(value = ...future.value$value, 
[10:22:47.564]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:47.564]                   ...future.rng), globalenv = if (FALSE) 
[10:22:47.564]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:47.564]                     ...future.globalenv.names))
[10:22:47.564]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:47.564]         }, condition = base::local({
[10:22:47.564]             c <- base::c
[10:22:47.564]             inherits <- base::inherits
[10:22:47.564]             invokeRestart <- base::invokeRestart
[10:22:47.564]             length <- base::length
[10:22:47.564]             list <- base::list
[10:22:47.564]             seq.int <- base::seq.int
[10:22:47.564]             signalCondition <- base::signalCondition
[10:22:47.564]             sys.calls <- base::sys.calls
[10:22:47.564]             `[[` <- base::`[[`
[10:22:47.564]             `+` <- base::`+`
[10:22:47.564]             `<<-` <- base::`<<-`
[10:22:47.564]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:47.564]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:47.564]                   3L)]
[10:22:47.564]             }
[10:22:47.564]             function(cond) {
[10:22:47.564]                 is_error <- inherits(cond, "error")
[10:22:47.564]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:47.564]                   NULL)
[10:22:47.564]                 if (is_error) {
[10:22:47.564]                   sessionInformation <- function() {
[10:22:47.564]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:47.564]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:47.564]                       search = base::search(), system = base::Sys.info())
[10:22:47.564]                   }
[10:22:47.564]                   ...future.conditions[[length(...future.conditions) + 
[10:22:47.564]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:47.564]                     cond$call), session = sessionInformation(), 
[10:22:47.564]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:47.564]                   signalCondition(cond)
[10:22:47.564]                 }
[10:22:47.564]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:47.564]                 "immediateCondition"))) {
[10:22:47.564]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:47.564]                   ...future.conditions[[length(...future.conditions) + 
[10:22:47.564]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:47.564]                   if (TRUE && !signal) {
[10:22:47.564]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.564]                     {
[10:22:47.564]                       inherits <- base::inherits
[10:22:47.564]                       invokeRestart <- base::invokeRestart
[10:22:47.564]                       is.null <- base::is.null
[10:22:47.564]                       muffled <- FALSE
[10:22:47.564]                       if (inherits(cond, "message")) {
[10:22:47.564]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:47.564]                         if (muffled) 
[10:22:47.564]                           invokeRestart("muffleMessage")
[10:22:47.564]                       }
[10:22:47.564]                       else if (inherits(cond, "warning")) {
[10:22:47.564]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:47.564]                         if (muffled) 
[10:22:47.564]                           invokeRestart("muffleWarning")
[10:22:47.564]                       }
[10:22:47.564]                       else if (inherits(cond, "condition")) {
[10:22:47.564]                         if (!is.null(pattern)) {
[10:22:47.564]                           computeRestarts <- base::computeRestarts
[10:22:47.564]                           grepl <- base::grepl
[10:22:47.564]                           restarts <- computeRestarts(cond)
[10:22:47.564]                           for (restart in restarts) {
[10:22:47.564]                             name <- restart$name
[10:22:47.564]                             if (is.null(name)) 
[10:22:47.564]                               next
[10:22:47.564]                             if (!grepl(pattern, name)) 
[10:22:47.564]                               next
[10:22:47.564]                             invokeRestart(restart)
[10:22:47.564]                             muffled <- TRUE
[10:22:47.564]                             break
[10:22:47.564]                           }
[10:22:47.564]                         }
[10:22:47.564]                       }
[10:22:47.564]                       invisible(muffled)
[10:22:47.564]                     }
[10:22:47.564]                     muffleCondition(cond, pattern = "^muffle")
[10:22:47.564]                   }
[10:22:47.564]                 }
[10:22:47.564]                 else {
[10:22:47.564]                   if (TRUE) {
[10:22:47.564]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.564]                     {
[10:22:47.564]                       inherits <- base::inherits
[10:22:47.564]                       invokeRestart <- base::invokeRestart
[10:22:47.564]                       is.null <- base::is.null
[10:22:47.564]                       muffled <- FALSE
[10:22:47.564]                       if (inherits(cond, "message")) {
[10:22:47.564]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:47.564]                         if (muffled) 
[10:22:47.564]                           invokeRestart("muffleMessage")
[10:22:47.564]                       }
[10:22:47.564]                       else if (inherits(cond, "warning")) {
[10:22:47.564]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:47.564]                         if (muffled) 
[10:22:47.564]                           invokeRestart("muffleWarning")
[10:22:47.564]                       }
[10:22:47.564]                       else if (inherits(cond, "condition")) {
[10:22:47.564]                         if (!is.null(pattern)) {
[10:22:47.564]                           computeRestarts <- base::computeRestarts
[10:22:47.564]                           grepl <- base::grepl
[10:22:47.564]                           restarts <- computeRestarts(cond)
[10:22:47.564]                           for (restart in restarts) {
[10:22:47.564]                             name <- restart$name
[10:22:47.564]                             if (is.null(name)) 
[10:22:47.564]                               next
[10:22:47.564]                             if (!grepl(pattern, name)) 
[10:22:47.564]                               next
[10:22:47.564]                             invokeRestart(restart)
[10:22:47.564]                             muffled <- TRUE
[10:22:47.564]                             break
[10:22:47.564]                           }
[10:22:47.564]                         }
[10:22:47.564]                       }
[10:22:47.564]                       invisible(muffled)
[10:22:47.564]                     }
[10:22:47.564]                     muffleCondition(cond, pattern = "^muffle")
[10:22:47.564]                   }
[10:22:47.564]                 }
[10:22:47.564]             }
[10:22:47.564]         }))
[10:22:47.564]     }, error = function(ex) {
[10:22:47.564]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:47.564]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:47.564]                 ...future.rng), started = ...future.startTime, 
[10:22:47.564]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:47.564]             version = "1.8"), class = "FutureResult")
[10:22:47.564]     }, finally = {
[10:22:47.564]         if (!identical(...future.workdir, getwd())) 
[10:22:47.564]             setwd(...future.workdir)
[10:22:47.564]         {
[10:22:47.564]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:47.564]                 ...future.oldOptions$nwarnings <- NULL
[10:22:47.564]             }
[10:22:47.564]             base::options(...future.oldOptions)
[10:22:47.564]             if (.Platform$OS.type == "windows") {
[10:22:47.564]                 old_names <- names(...future.oldEnvVars)
[10:22:47.564]                 envs <- base::Sys.getenv()
[10:22:47.564]                 names <- names(envs)
[10:22:47.564]                 common <- intersect(names, old_names)
[10:22:47.564]                 added <- setdiff(names, old_names)
[10:22:47.564]                 removed <- setdiff(old_names, names)
[10:22:47.564]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:47.564]                   envs[common]]
[10:22:47.564]                 NAMES <- toupper(changed)
[10:22:47.564]                 args <- list()
[10:22:47.564]                 for (kk in seq_along(NAMES)) {
[10:22:47.564]                   name <- changed[[kk]]
[10:22:47.564]                   NAME <- NAMES[[kk]]
[10:22:47.564]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.564]                     next
[10:22:47.564]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:47.564]                 }
[10:22:47.564]                 NAMES <- toupper(added)
[10:22:47.564]                 for (kk in seq_along(NAMES)) {
[10:22:47.564]                   name <- added[[kk]]
[10:22:47.564]                   NAME <- NAMES[[kk]]
[10:22:47.564]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.564]                     next
[10:22:47.564]                   args[[name]] <- ""
[10:22:47.564]                 }
[10:22:47.564]                 NAMES <- toupper(removed)
[10:22:47.564]                 for (kk in seq_along(NAMES)) {
[10:22:47.564]                   name <- removed[[kk]]
[10:22:47.564]                   NAME <- NAMES[[kk]]
[10:22:47.564]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.564]                     next
[10:22:47.564]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:47.564]                 }
[10:22:47.564]                 if (length(args) > 0) 
[10:22:47.564]                   base::do.call(base::Sys.setenv, args = args)
[10:22:47.564]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:47.564]             }
[10:22:47.564]             else {
[10:22:47.564]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:47.564]             }
[10:22:47.564]             {
[10:22:47.564]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:47.564]                   0L) {
[10:22:47.564]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:47.564]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:47.564]                   base::options(opts)
[10:22:47.564]                 }
[10:22:47.564]                 {
[10:22:47.564]                   {
[10:22:47.564]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:47.564]                     NULL
[10:22:47.564]                   }
[10:22:47.564]                   options(future.plan = NULL)
[10:22:47.564]                   if (is.na(NA_character_)) 
[10:22:47.564]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:47.564]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:47.564]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:47.564]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:47.564]                     envir = parent.frame()) 
[10:22:47.564]                   {
[10:22:47.564]                     if (is.function(workers)) 
[10:22:47.564]                       workers <- workers()
[10:22:47.564]                     workers <- structure(as.integer(workers), 
[10:22:47.564]                       class = class(workers))
[10:22:47.564]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:47.564]                       workers >= 1)
[10:22:47.564]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:47.564]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:47.564]                     }
[10:22:47.564]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:47.564]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:47.564]                       envir = envir)
[10:22:47.564]                     if (!future$lazy) 
[10:22:47.564]                       future <- run(future)
[10:22:47.564]                     invisible(future)
[10:22:47.564]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:47.564]                 }
[10:22:47.564]             }
[10:22:47.564]         }
[10:22:47.564]     })
[10:22:47.564]     if (TRUE) {
[10:22:47.564]         base::sink(type = "output", split = FALSE)
[10:22:47.564]         if (TRUE) {
[10:22:47.564]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:47.564]         }
[10:22:47.564]         else {
[10:22:47.564]             ...future.result["stdout"] <- base::list(NULL)
[10:22:47.564]         }
[10:22:47.564]         base::close(...future.stdout)
[10:22:47.564]         ...future.stdout <- NULL
[10:22:47.564]     }
[10:22:47.564]     ...future.result$conditions <- ...future.conditions
[10:22:47.564]     ...future.result$finished <- base::Sys.time()
[10:22:47.564]     ...future.result
[10:22:47.564] }
[10:22:47.567] Exporting 5 global objects (960 bytes) to cluster node #1 ...
[10:22:47.567] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:22:47.568] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:22:47.568] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[10:22:47.568] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[10:22:47.568] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[10:22:47.569] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[10:22:47.569] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:22:47.569] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:22:47.569] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[10:22:47.570] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[10:22:47.570] Exporting 5 global objects (960 bytes) to cluster node #1 ... DONE
[10:22:47.570] MultisessionFuture started
[10:22:47.571] - Launch lazy future ... done
[10:22:47.571] run() for ‘MultisessionFuture’ ... done
[10:22:47.571] Created future:
[10:22:47.571] MultisessionFuture:
[10:22:47.571] Label: ‘future_apply-1’
[10:22:47.571] Expression:
[10:22:47.571] {
[10:22:47.571]     do.call(function(...) {
[10:22:47.571]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.571]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:47.571]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.571]             on.exit(options(oopts), add = TRUE)
[10:22:47.571]         }
[10:22:47.571]         {
[10:22:47.571]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:47.571]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.571]                 ...future.FUN(...future.X_jj, ...)
[10:22:47.571]             })
[10:22:47.571]         }
[10:22:47.571]     }, args = future.call.arguments)
[10:22:47.571] }
[10:22:47.571] Lazy evaluation: FALSE
[10:22:47.571] Asynchronous evaluation: TRUE
[10:22:47.571] Local evaluation: TRUE
[10:22:47.571] Environment: R_GlobalEnv
[10:22:47.571] Capture standard output: TRUE
[10:22:47.571] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:47.571] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:47.571] Packages: <none>
[10:22:47.571] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:47.571] Resolved: FALSE
[10:22:47.571] Value: <not collected>
[10:22:47.571] Conditions captured: <none>
[10:22:47.571] Early signaling: FALSE
[10:22:47.571] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:47.571] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:47.583] Chunk #1 of 2 ... DONE
[10:22:47.583] Chunk #2 of 2 ...
[10:22:47.583]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:47.583]  - seeds: <none>
[10:22:47.583]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.583] getGlobalsAndPackages() ...
[10:22:47.583] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.583] Resolving globals: FALSE
[10:22:47.583] Tweak future expression to call with '...' arguments ...
[10:22:47.584] {
[10:22:47.584]     do.call(function(...) {
[10:22:47.584]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.584]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:47.584]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.584]             on.exit(options(oopts), add = TRUE)
[10:22:47.584]         }
[10:22:47.584]         {
[10:22:47.584]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:47.584]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.584]                 ...future.FUN(...future.X_jj, ...)
[10:22:47.584]             })
[10:22:47.584]         }
[10:22:47.584]     }, args = future.call.arguments)
[10:22:47.584] }
[10:22:47.584] Tweak future expression to call with '...' arguments ... DONE
[10:22:47.584] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.584] 
[10:22:47.584] getGlobalsAndPackages() ... DONE
[10:22:47.585] run() for ‘Future’ ...
[10:22:47.585] - state: ‘created’
[10:22:47.585] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:47.599] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:47.599] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:47.599]   - Field: ‘node’
[10:22:47.599]   - Field: ‘label’
[10:22:47.599]   - Field: ‘local’
[10:22:47.599]   - Field: ‘owner’
[10:22:47.599]   - Field: ‘envir’
[10:22:47.599]   - Field: ‘workers’
[10:22:47.599]   - Field: ‘packages’
[10:22:47.600]   - Field: ‘gc’
[10:22:47.600]   - Field: ‘conditions’
[10:22:47.600]   - Field: ‘persistent’
[10:22:47.600]   - Field: ‘expr’
[10:22:47.600]   - Field: ‘uuid’
[10:22:47.600]   - Field: ‘seed’
[10:22:47.600]   - Field: ‘version’
[10:22:47.600]   - Field: ‘result’
[10:22:47.600]   - Field: ‘asynchronous’
[10:22:47.600]   - Field: ‘calls’
[10:22:47.600]   - Field: ‘globals’
[10:22:47.601]   - Field: ‘stdout’
[10:22:47.601]   - Field: ‘earlySignal’
[10:22:47.601]   - Field: ‘lazy’
[10:22:47.601]   - Field: ‘state’
[10:22:47.601] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:47.601] - Launch lazy future ...
[10:22:47.601] Packages needed by the future expression (n = 0): <none>
[10:22:47.601] Packages needed by future strategies (n = 0): <none>
[10:22:47.602] {
[10:22:47.602]     {
[10:22:47.602]         {
[10:22:47.602]             ...future.startTime <- base::Sys.time()
[10:22:47.602]             {
[10:22:47.602]                 {
[10:22:47.602]                   {
[10:22:47.602]                     {
[10:22:47.602]                       base::local({
[10:22:47.602]                         has_future <- base::requireNamespace("future", 
[10:22:47.602]                           quietly = TRUE)
[10:22:47.602]                         if (has_future) {
[10:22:47.602]                           ns <- base::getNamespace("future")
[10:22:47.602]                           version <- ns[[".package"]][["version"]]
[10:22:47.602]                           if (is.null(version)) 
[10:22:47.602]                             version <- utils::packageVersion("future")
[10:22:47.602]                         }
[10:22:47.602]                         else {
[10:22:47.602]                           version <- NULL
[10:22:47.602]                         }
[10:22:47.602]                         if (!has_future || version < "1.8.0") {
[10:22:47.602]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:47.602]                             "", base::R.version$version.string), 
[10:22:47.602]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:47.602]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:47.602]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:47.602]                               "release", "version")], collapse = " "), 
[10:22:47.602]                             hostname = base::Sys.info()[["nodename"]])
[10:22:47.602]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:47.602]                             info)
[10:22:47.602]                           info <- base::paste(info, collapse = "; ")
[10:22:47.602]                           if (!has_future) {
[10:22:47.602]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:47.602]                               info)
[10:22:47.602]                           }
[10:22:47.602]                           else {
[10:22:47.602]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:47.602]                               info, version)
[10:22:47.602]                           }
[10:22:47.602]                           base::stop(msg)
[10:22:47.602]                         }
[10:22:47.602]                       })
[10:22:47.602]                     }
[10:22:47.602]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:47.602]                     base::options(mc.cores = 1L)
[10:22:47.602]                   }
[10:22:47.602]                   options(future.plan = NULL)
[10:22:47.602]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:47.602]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:47.602]                 }
[10:22:47.602]                 ...future.workdir <- getwd()
[10:22:47.602]             }
[10:22:47.602]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:47.602]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:47.602]         }
[10:22:47.602]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:47.602]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:47.602]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:47.602]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:47.602]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:47.602]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:47.602]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:47.602]             base::names(...future.oldOptions))
[10:22:47.602]     }
[10:22:47.602]     if (FALSE) {
[10:22:47.602]     }
[10:22:47.602]     else {
[10:22:47.602]         if (TRUE) {
[10:22:47.602]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:47.602]                 open = "w")
[10:22:47.602]         }
[10:22:47.602]         else {
[10:22:47.602]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:47.602]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:47.602]         }
[10:22:47.602]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:47.602]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:47.602]             base::sink(type = "output", split = FALSE)
[10:22:47.602]             base::close(...future.stdout)
[10:22:47.602]         }, add = TRUE)
[10:22:47.602]     }
[10:22:47.602]     ...future.frame <- base::sys.nframe()
[10:22:47.602]     ...future.conditions <- base::list()
[10:22:47.602]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:47.602]     if (FALSE) {
[10:22:47.602]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:47.602]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:47.602]     }
[10:22:47.602]     ...future.result <- base::tryCatch({
[10:22:47.602]         base::withCallingHandlers({
[10:22:47.602]             ...future.value <- base::withVisible(base::local({
[10:22:47.602]                 ...future.makeSendCondition <- base::local({
[10:22:47.602]                   sendCondition <- NULL
[10:22:47.602]                   function(frame = 1L) {
[10:22:47.602]                     if (is.function(sendCondition)) 
[10:22:47.602]                       return(sendCondition)
[10:22:47.602]                     ns <- getNamespace("parallel")
[10:22:47.602]                     if (exists("sendData", mode = "function", 
[10:22:47.602]                       envir = ns)) {
[10:22:47.602]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:47.602]                         envir = ns)
[10:22:47.602]                       envir <- sys.frame(frame)
[10:22:47.602]                       master <- NULL
[10:22:47.602]                       while (!identical(envir, .GlobalEnv) && 
[10:22:47.602]                         !identical(envir, emptyenv())) {
[10:22:47.602]                         if (exists("master", mode = "list", envir = envir, 
[10:22:47.602]                           inherits = FALSE)) {
[10:22:47.602]                           master <- get("master", mode = "list", 
[10:22:47.602]                             envir = envir, inherits = FALSE)
[10:22:47.602]                           if (inherits(master, c("SOCKnode", 
[10:22:47.602]                             "SOCK0node"))) {
[10:22:47.602]                             sendCondition <<- function(cond) {
[10:22:47.602]                               data <- list(type = "VALUE", value = cond, 
[10:22:47.602]                                 success = TRUE)
[10:22:47.602]                               parallel_sendData(master, data)
[10:22:47.602]                             }
[10:22:47.602]                             return(sendCondition)
[10:22:47.602]                           }
[10:22:47.602]                         }
[10:22:47.602]                         frame <- frame + 1L
[10:22:47.602]                         envir <- sys.frame(frame)
[10:22:47.602]                       }
[10:22:47.602]                     }
[10:22:47.602]                     sendCondition <<- function(cond) NULL
[10:22:47.602]                   }
[10:22:47.602]                 })
[10:22:47.602]                 withCallingHandlers({
[10:22:47.602]                   {
[10:22:47.602]                     do.call(function(...) {
[10:22:47.602]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.602]                       if (!identical(...future.globals.maxSize.org, 
[10:22:47.602]                         ...future.globals.maxSize)) {
[10:22:47.602]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.602]                         on.exit(options(oopts), add = TRUE)
[10:22:47.602]                       }
[10:22:47.602]                       {
[10:22:47.602]                         lapply(seq_along(...future.elements_ii), 
[10:22:47.602]                           FUN = function(jj) {
[10:22:47.602]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.602]                             ...future.FUN(...future.X_jj, ...)
[10:22:47.602]                           })
[10:22:47.602]                       }
[10:22:47.602]                     }, args = future.call.arguments)
[10:22:47.602]                   }
[10:22:47.602]                 }, immediateCondition = function(cond) {
[10:22:47.602]                   sendCondition <- ...future.makeSendCondition()
[10:22:47.602]                   sendCondition(cond)
[10:22:47.602]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.602]                   {
[10:22:47.602]                     inherits <- base::inherits
[10:22:47.602]                     invokeRestart <- base::invokeRestart
[10:22:47.602]                     is.null <- base::is.null
[10:22:47.602]                     muffled <- FALSE
[10:22:47.602]                     if (inherits(cond, "message")) {
[10:22:47.602]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:47.602]                       if (muffled) 
[10:22:47.602]                         invokeRestart("muffleMessage")
[10:22:47.602]                     }
[10:22:47.602]                     else if (inherits(cond, "warning")) {
[10:22:47.602]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:47.602]                       if (muffled) 
[10:22:47.602]                         invokeRestart("muffleWarning")
[10:22:47.602]                     }
[10:22:47.602]                     else if (inherits(cond, "condition")) {
[10:22:47.602]                       if (!is.null(pattern)) {
[10:22:47.602]                         computeRestarts <- base::computeRestarts
[10:22:47.602]                         grepl <- base::grepl
[10:22:47.602]                         restarts <- computeRestarts(cond)
[10:22:47.602]                         for (restart in restarts) {
[10:22:47.602]                           name <- restart$name
[10:22:47.602]                           if (is.null(name)) 
[10:22:47.602]                             next
[10:22:47.602]                           if (!grepl(pattern, name)) 
[10:22:47.602]                             next
[10:22:47.602]                           invokeRestart(restart)
[10:22:47.602]                           muffled <- TRUE
[10:22:47.602]                           break
[10:22:47.602]                         }
[10:22:47.602]                       }
[10:22:47.602]                     }
[10:22:47.602]                     invisible(muffled)
[10:22:47.602]                   }
[10:22:47.602]                   muffleCondition(cond)
[10:22:47.602]                 })
[10:22:47.602]             }))
[10:22:47.602]             future::FutureResult(value = ...future.value$value, 
[10:22:47.602]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:47.602]                   ...future.rng), globalenv = if (FALSE) 
[10:22:47.602]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:47.602]                     ...future.globalenv.names))
[10:22:47.602]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:47.602]         }, condition = base::local({
[10:22:47.602]             c <- base::c
[10:22:47.602]             inherits <- base::inherits
[10:22:47.602]             invokeRestart <- base::invokeRestart
[10:22:47.602]             length <- base::length
[10:22:47.602]             list <- base::list
[10:22:47.602]             seq.int <- base::seq.int
[10:22:47.602]             signalCondition <- base::signalCondition
[10:22:47.602]             sys.calls <- base::sys.calls
[10:22:47.602]             `[[` <- base::`[[`
[10:22:47.602]             `+` <- base::`+`
[10:22:47.602]             `<<-` <- base::`<<-`
[10:22:47.602]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:47.602]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:47.602]                   3L)]
[10:22:47.602]             }
[10:22:47.602]             function(cond) {
[10:22:47.602]                 is_error <- inherits(cond, "error")
[10:22:47.602]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:47.602]                   NULL)
[10:22:47.602]                 if (is_error) {
[10:22:47.602]                   sessionInformation <- function() {
[10:22:47.602]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:47.602]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:47.602]                       search = base::search(), system = base::Sys.info())
[10:22:47.602]                   }
[10:22:47.602]                   ...future.conditions[[length(...future.conditions) + 
[10:22:47.602]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:47.602]                     cond$call), session = sessionInformation(), 
[10:22:47.602]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:47.602]                   signalCondition(cond)
[10:22:47.602]                 }
[10:22:47.602]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:47.602]                 "immediateCondition"))) {
[10:22:47.602]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:47.602]                   ...future.conditions[[length(...future.conditions) + 
[10:22:47.602]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:47.602]                   if (TRUE && !signal) {
[10:22:47.602]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.602]                     {
[10:22:47.602]                       inherits <- base::inherits
[10:22:47.602]                       invokeRestart <- base::invokeRestart
[10:22:47.602]                       is.null <- base::is.null
[10:22:47.602]                       muffled <- FALSE
[10:22:47.602]                       if (inherits(cond, "message")) {
[10:22:47.602]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:47.602]                         if (muffled) 
[10:22:47.602]                           invokeRestart("muffleMessage")
[10:22:47.602]                       }
[10:22:47.602]                       else if (inherits(cond, "warning")) {
[10:22:47.602]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:47.602]                         if (muffled) 
[10:22:47.602]                           invokeRestart("muffleWarning")
[10:22:47.602]                       }
[10:22:47.602]                       else if (inherits(cond, "condition")) {
[10:22:47.602]                         if (!is.null(pattern)) {
[10:22:47.602]                           computeRestarts <- base::computeRestarts
[10:22:47.602]                           grepl <- base::grepl
[10:22:47.602]                           restarts <- computeRestarts(cond)
[10:22:47.602]                           for (restart in restarts) {
[10:22:47.602]                             name <- restart$name
[10:22:47.602]                             if (is.null(name)) 
[10:22:47.602]                               next
[10:22:47.602]                             if (!grepl(pattern, name)) 
[10:22:47.602]                               next
[10:22:47.602]                             invokeRestart(restart)
[10:22:47.602]                             muffled <- TRUE
[10:22:47.602]                             break
[10:22:47.602]                           }
[10:22:47.602]                         }
[10:22:47.602]                       }
[10:22:47.602]                       invisible(muffled)
[10:22:47.602]                     }
[10:22:47.602]                     muffleCondition(cond, pattern = "^muffle")
[10:22:47.602]                   }
[10:22:47.602]                 }
[10:22:47.602]                 else {
[10:22:47.602]                   if (TRUE) {
[10:22:47.602]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.602]                     {
[10:22:47.602]                       inherits <- base::inherits
[10:22:47.602]                       invokeRestart <- base::invokeRestart
[10:22:47.602]                       is.null <- base::is.null
[10:22:47.602]                       muffled <- FALSE
[10:22:47.602]                       if (inherits(cond, "message")) {
[10:22:47.602]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:47.602]                         if (muffled) 
[10:22:47.602]                           invokeRestart("muffleMessage")
[10:22:47.602]                       }
[10:22:47.602]                       else if (inherits(cond, "warning")) {
[10:22:47.602]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:47.602]                         if (muffled) 
[10:22:47.602]                           invokeRestart("muffleWarning")
[10:22:47.602]                       }
[10:22:47.602]                       else if (inherits(cond, "condition")) {
[10:22:47.602]                         if (!is.null(pattern)) {
[10:22:47.602]                           computeRestarts <- base::computeRestarts
[10:22:47.602]                           grepl <- base::grepl
[10:22:47.602]                           restarts <- computeRestarts(cond)
[10:22:47.602]                           for (restart in restarts) {
[10:22:47.602]                             name <- restart$name
[10:22:47.602]                             if (is.null(name)) 
[10:22:47.602]                               next
[10:22:47.602]                             if (!grepl(pattern, name)) 
[10:22:47.602]                               next
[10:22:47.602]                             invokeRestart(restart)
[10:22:47.602]                             muffled <- TRUE
[10:22:47.602]                             break
[10:22:47.602]                           }
[10:22:47.602]                         }
[10:22:47.602]                       }
[10:22:47.602]                       invisible(muffled)
[10:22:47.602]                     }
[10:22:47.602]                     muffleCondition(cond, pattern = "^muffle")
[10:22:47.602]                   }
[10:22:47.602]                 }
[10:22:47.602]             }
[10:22:47.602]         }))
[10:22:47.602]     }, error = function(ex) {
[10:22:47.602]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:47.602]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:47.602]                 ...future.rng), started = ...future.startTime, 
[10:22:47.602]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:47.602]             version = "1.8"), class = "FutureResult")
[10:22:47.602]     }, finally = {
[10:22:47.602]         if (!identical(...future.workdir, getwd())) 
[10:22:47.602]             setwd(...future.workdir)
[10:22:47.602]         {
[10:22:47.602]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:47.602]                 ...future.oldOptions$nwarnings <- NULL
[10:22:47.602]             }
[10:22:47.602]             base::options(...future.oldOptions)
[10:22:47.602]             if (.Platform$OS.type == "windows") {
[10:22:47.602]                 old_names <- names(...future.oldEnvVars)
[10:22:47.602]                 envs <- base::Sys.getenv()
[10:22:47.602]                 names <- names(envs)
[10:22:47.602]                 common <- intersect(names, old_names)
[10:22:47.602]                 added <- setdiff(names, old_names)
[10:22:47.602]                 removed <- setdiff(old_names, names)
[10:22:47.602]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:47.602]                   envs[common]]
[10:22:47.602]                 NAMES <- toupper(changed)
[10:22:47.602]                 args <- list()
[10:22:47.602]                 for (kk in seq_along(NAMES)) {
[10:22:47.602]                   name <- changed[[kk]]
[10:22:47.602]                   NAME <- NAMES[[kk]]
[10:22:47.602]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.602]                     next
[10:22:47.602]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:47.602]                 }
[10:22:47.602]                 NAMES <- toupper(added)
[10:22:47.602]                 for (kk in seq_along(NAMES)) {
[10:22:47.602]                   name <- added[[kk]]
[10:22:47.602]                   NAME <- NAMES[[kk]]
[10:22:47.602]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.602]                     next
[10:22:47.602]                   args[[name]] <- ""
[10:22:47.602]                 }
[10:22:47.602]                 NAMES <- toupper(removed)
[10:22:47.602]                 for (kk in seq_along(NAMES)) {
[10:22:47.602]                   name <- removed[[kk]]
[10:22:47.602]                   NAME <- NAMES[[kk]]
[10:22:47.602]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.602]                     next
[10:22:47.602]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:47.602]                 }
[10:22:47.602]                 if (length(args) > 0) 
[10:22:47.602]                   base::do.call(base::Sys.setenv, args = args)
[10:22:47.602]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:47.602]             }
[10:22:47.602]             else {
[10:22:47.602]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:47.602]             }
[10:22:47.602]             {
[10:22:47.602]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:47.602]                   0L) {
[10:22:47.602]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:47.602]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:47.602]                   base::options(opts)
[10:22:47.602]                 }
[10:22:47.602]                 {
[10:22:47.602]                   {
[10:22:47.602]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:47.602]                     NULL
[10:22:47.602]                   }
[10:22:47.602]                   options(future.plan = NULL)
[10:22:47.602]                   if (is.na(NA_character_)) 
[10:22:47.602]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:47.602]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:47.602]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:47.602]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:47.602]                     envir = parent.frame()) 
[10:22:47.602]                   {
[10:22:47.602]                     if (is.function(workers)) 
[10:22:47.602]                       workers <- workers()
[10:22:47.602]                     workers <- structure(as.integer(workers), 
[10:22:47.602]                       class = class(workers))
[10:22:47.602]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:47.602]                       workers >= 1)
[10:22:47.602]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:47.602]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:47.602]                     }
[10:22:47.602]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:47.602]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:47.602]                       envir = envir)
[10:22:47.602]                     if (!future$lazy) 
[10:22:47.602]                       future <- run(future)
[10:22:47.602]                     invisible(future)
[10:22:47.602]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:47.602]                 }
[10:22:47.602]             }
[10:22:47.602]         }
[10:22:47.602]     })
[10:22:47.602]     if (TRUE) {
[10:22:47.602]         base::sink(type = "output", split = FALSE)
[10:22:47.602]         if (TRUE) {
[10:22:47.602]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:47.602]         }
[10:22:47.602]         else {
[10:22:47.602]             ...future.result["stdout"] <- base::list(NULL)
[10:22:47.602]         }
[10:22:47.602]         base::close(...future.stdout)
[10:22:47.602]         ...future.stdout <- NULL
[10:22:47.602]     }
[10:22:47.602]     ...future.result$conditions <- ...future.conditions
[10:22:47.602]     ...future.result$finished <- base::Sys.time()
[10:22:47.602]     ...future.result
[10:22:47.602] }
[10:22:47.605] Exporting 5 global objects (960 bytes) to cluster node #2 ...
[10:22:47.605] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:22:47.606] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:22:47.606] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[10:22:47.606] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[10:22:47.606] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[10:22:47.607] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[10:22:47.607] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:22:47.607] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:22:47.607] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[10:22:47.608] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[10:22:47.608] Exporting 5 global objects (960 bytes) to cluster node #2 ... DONE
[10:22:47.608] MultisessionFuture started
[10:22:47.609] - Launch lazy future ... done
[10:22:47.609] run() for ‘MultisessionFuture’ ... done
[10:22:47.609] Created future:
[10:22:47.609] MultisessionFuture:
[10:22:47.609] Label: ‘future_apply-2’
[10:22:47.609] Expression:
[10:22:47.609] {
[10:22:47.609]     do.call(function(...) {
[10:22:47.609]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.609]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:47.609]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.609]             on.exit(options(oopts), add = TRUE)
[10:22:47.609]         }
[10:22:47.609]         {
[10:22:47.609]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:47.609]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.609]                 ...future.FUN(...future.X_jj, ...)
[10:22:47.609]             })
[10:22:47.609]         }
[10:22:47.609]     }, args = future.call.arguments)
[10:22:47.609] }
[10:22:47.609] Lazy evaluation: FALSE
[10:22:47.609] Asynchronous evaluation: TRUE
[10:22:47.609] Local evaluation: TRUE
[10:22:47.609] Environment: R_GlobalEnv
[10:22:47.609] Capture standard output: TRUE
[10:22:47.609] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:47.609] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:47.609] Packages: <none>
[10:22:47.609] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:47.609] Resolved: FALSE
[10:22:47.609] Value: <not collected>
[10:22:47.609] Conditions captured: <none>
[10:22:47.609] Early signaling: FALSE
[10:22:47.609] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:47.609] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:47.620] Chunk #2 of 2 ... DONE
[10:22:47.621] Launching 2 futures (chunks) ... DONE
[10:22:47.621] Resolving 2 futures (chunks) ...
[10:22:47.621] resolve() on list ...
[10:22:47.621]  recursive: 0
[10:22:47.621]  length: 2
[10:22:47.621] 
[10:22:47.622] receiveMessageFromWorker() for ClusterFuture ...
[10:22:47.622] - Validating connection of MultisessionFuture
[10:22:47.622] - received message: FutureResult
[10:22:47.622] - Received FutureResult
[10:22:47.622] - Erased future from FutureRegistry
[10:22:47.622] result() for ClusterFuture ...
[10:22:47.622] - result already collected: FutureResult
[10:22:47.622] result() for ClusterFuture ... done
[10:22:47.623] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:47.623] Future #1
[10:22:47.623] result() for ClusterFuture ...
[10:22:47.623] - result already collected: FutureResult
[10:22:47.623] result() for ClusterFuture ... done
[10:22:47.623] result() for ClusterFuture ...
[10:22:47.623] - result already collected: FutureResult
[10:22:47.623] result() for ClusterFuture ... done
[10:22:47.623] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:22:47.623] - nx: 2
[10:22:47.623] - relay: TRUE
[10:22:47.624] - stdout: TRUE
[10:22:47.624] - signal: TRUE
[10:22:47.624] - resignal: FALSE
[10:22:47.624] - force: TRUE
[10:22:47.624] - relayed: [n=2] FALSE, FALSE
[10:22:47.624] - queued futures: [n=2] FALSE, FALSE
[10:22:47.624]  - until=1
[10:22:47.624]  - relaying element #1
[10:22:47.624] result() for ClusterFuture ...
[10:22:47.624] - result already collected: FutureResult
[10:22:47.624] result() for ClusterFuture ... done
[10:22:47.624] result() for ClusterFuture ...
[10:22:47.625] - result already collected: FutureResult
[10:22:47.625] result() for ClusterFuture ... done
[10:22:47.625] result() for ClusterFuture ...
[10:22:47.625] - result already collected: FutureResult
[10:22:47.625] result() for ClusterFuture ... done
[10:22:47.625] result() for ClusterFuture ...
[10:22:47.625] - result already collected: FutureResult
[10:22:47.625] result() for ClusterFuture ... done
[10:22:47.625] - relayed: [n=2] TRUE, FALSE
[10:22:47.625] - queued futures: [n=2] TRUE, FALSE
[10:22:47.626] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:22:47.626]  length: 1 (resolved future 1)
[10:22:47.654] receiveMessageFromWorker() for ClusterFuture ...
[10:22:47.654] - Validating connection of MultisessionFuture
[10:22:47.655] - received message: FutureResult
[10:22:47.655] - Received FutureResult
[10:22:47.655] - Erased future from FutureRegistry
[10:22:47.655] result() for ClusterFuture ...
[10:22:47.655] - result already collected: FutureResult
[10:22:47.655] result() for ClusterFuture ... done
[10:22:47.655] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:47.655] Future #2
[10:22:47.655] result() for ClusterFuture ...
[10:22:47.656] - result already collected: FutureResult
[10:22:47.656] result() for ClusterFuture ... done
[10:22:47.656] result() for ClusterFuture ...
[10:22:47.656] - result already collected: FutureResult
[10:22:47.656] result() for ClusterFuture ... done
[10:22:47.656] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:22:47.656] - nx: 2
[10:22:47.656] - relay: TRUE
[10:22:47.656] - stdout: TRUE
[10:22:47.656] - signal: TRUE
[10:22:47.656] - resignal: FALSE
[10:22:47.656] - force: TRUE
[10:22:47.657] - relayed: [n=2] TRUE, FALSE
[10:22:47.657] - queued futures: [n=2] TRUE, FALSE
[10:22:47.657]  - until=2
[10:22:47.657]  - relaying element #2
[10:22:47.657] result() for ClusterFuture ...
[10:22:47.657] - result already collected: FutureResult
[10:22:47.657] result() for ClusterFuture ... done
[10:22:47.657] result() for ClusterFuture ...
[10:22:47.657] - result already collected: FutureResult
[10:22:47.657] result() for ClusterFuture ... done
[10:22:47.658] result() for ClusterFuture ...
[10:22:47.658] - result already collected: FutureResult
[10:22:47.658] result() for ClusterFuture ... done
[10:22:47.658] result() for ClusterFuture ...
[10:22:47.658] - result already collected: FutureResult
[10:22:47.658] result() for ClusterFuture ... done
[10:22:47.658] - relayed: [n=2] TRUE, TRUE
[10:22:47.658] - queued futures: [n=2] TRUE, TRUE
[10:22:47.658] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:22:47.658]  length: 0 (resolved future 2)
[10:22:47.658] Relaying remaining futures
[10:22:47.659] signalConditionsASAP(NULL, pos=0) ...
[10:22:47.659] - nx: 2
[10:22:47.659] - relay: TRUE
[10:22:47.659] - stdout: TRUE
[10:22:47.659] - signal: TRUE
[10:22:47.659] - resignal: FALSE
[10:22:47.659] - force: TRUE
[10:22:47.659] - relayed: [n=2] TRUE, TRUE
[10:22:47.659] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:22:47.659] - relayed: [n=2] TRUE, TRUE
[10:22:47.659] - queued futures: [n=2] TRUE, TRUE
[10:22:47.660] signalConditionsASAP(NULL, pos=0) ... done
[10:22:47.660] resolve() on list ... DONE
[10:22:47.660] result() for ClusterFuture ...
[10:22:47.660] - result already collected: FutureResult
[10:22:47.660] result() for ClusterFuture ... done
[10:22:47.660] result() for ClusterFuture ...
[10:22:47.660] - result already collected: FutureResult
[10:22:47.660] result() for ClusterFuture ... done
[10:22:47.660] result() for ClusterFuture ...
[10:22:47.660] - result already collected: FutureResult
[10:22:47.660] result() for ClusterFuture ... done
[10:22:47.661] result() for ClusterFuture ...
[10:22:47.661] - result already collected: FutureResult
[10:22:47.661] result() for ClusterFuture ... done
[10:22:47.661]  - Number of value chunks collected: 2
[10:22:47.661] Resolving 2 futures (chunks) ... DONE
[10:22:47.661] Reducing values from 2 chunks ...
[10:22:47.661]  - Number of values collected after concatenation: 2
[10:22:47.661]  - Number of values expected: 2
[10:22:47.661] Reducing values from 2 chunks ... DONE
[10:22:47.661] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[10:22:47.662] getGlobalsAndPackagesXApply() ...
[10:22:47.662]  - future.globals: TRUE
[10:22:47.662] getGlobalsAndPackages() ...
[10:22:47.662] Searching for globals...
[10:22:47.663] - globals found: [1] ‘FUN’
[10:22:47.663] Searching for globals ... DONE
[10:22:47.663] Resolving globals: FALSE
[10:22:47.663] The total size of the 1 globals is 848 bytes (848 bytes)
[10:22:47.664] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[10:22:47.664] - globals: [1] ‘FUN’
[10:22:47.664] 
[10:22:47.664] getGlobalsAndPackages() ... DONE
[10:22:47.664]  - globals found/used: [n=1] ‘FUN’
[10:22:47.664]  - needed namespaces: [n=0] 
[10:22:47.664] Finding globals ... DONE
[10:22:47.665]  - use_args: TRUE
[10:22:47.665]  - Getting '...' globals ...
[10:22:47.665] resolve() on list ...
[10:22:47.665]  recursive: 0
[10:22:47.665]  length: 1
[10:22:47.665]  elements: ‘...’
[10:22:47.665]  length: 0 (resolved future 1)
[10:22:47.665] resolve() on list ... DONE
[10:22:47.666]    - '...' content: [n=0] 
[10:22:47.666] List of 1
[10:22:47.666]  $ ...: list()
[10:22:47.666]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:47.666]  - attr(*, "where")=List of 1
[10:22:47.666]   ..$ ...:<environment: 0x55ca4ec04048> 
[10:22:47.666]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:47.666]  - attr(*, "resolved")= logi TRUE
[10:22:47.666]  - attr(*, "total_size")= num NA
[10:22:47.668]  - Getting '...' globals ... DONE
[10:22:47.668] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:47.668] List of 2
[10:22:47.668]  $ ...future.FUN:function (x)  
[10:22:47.668]  $ ...          : list()
[10:22:47.668]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:47.668]  - attr(*, "where")=List of 2
[10:22:47.668]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:47.668]   ..$ ...          :<environment: 0x55ca4ec04048> 
[10:22:47.668]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:47.668]  - attr(*, "resolved")= logi FALSE
[10:22:47.668]  - attr(*, "total_size")= num 848
[10:22:47.671] Packages to be attached in all futures: [n=0] 
[10:22:47.671] getGlobalsAndPackagesXApply() ... DONE
[10:22:47.674] future_lapply() ...
[10:22:47.680] Number of chunks: 2
[10:22:47.680] getGlobalsAndPackagesXApply() ...
[10:22:47.680]  - future.globals: <name-value list> with names ‘list()’
[10:22:47.681]  - use_args: TRUE
[10:22:47.681] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:22:47.681] List of 2
[10:22:47.681]  $ ...          : list()
[10:22:47.681]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:47.681]  $ ...future.FUN:function (x)  
[10:22:47.681]  - attr(*, "where")=List of 2
[10:22:47.681]   ..$ ...          :<environment: 0x55ca4ec04048> 
[10:22:47.681]   ..$ ...future.FUN:<environment: namespace:base> 
[10:22:47.681]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:47.681]  - attr(*, "resolved")= logi FALSE
[10:22:47.681]  - attr(*, "total_size")= num NA
[10:22:47.684] Packages to be attached in all futures: [n=0] 
[10:22:47.684] getGlobalsAndPackagesXApply() ... DONE
[10:22:47.684] Number of futures (= number of chunks): 2
[10:22:47.684] Launching 2 futures (chunks) ...
[10:22:47.684] Chunk #1 of 2 ...
[10:22:47.685]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:47.685]  - seeds: <none>
[10:22:47.685]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.685] getGlobalsAndPackages() ...
[10:22:47.685] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.685] Resolving globals: FALSE
[10:22:47.685] Tweak future expression to call with '...' arguments ...
[10:22:47.685] {
[10:22:47.685]     do.call(function(...) {
[10:22:47.685]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.685]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:47.685]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.685]             on.exit(options(oopts), add = TRUE)
[10:22:47.685]         }
[10:22:47.685]         {
[10:22:47.685]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:47.685]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.685]                 ...future.FUN(...future.X_jj, ...)
[10:22:47.685]             })
[10:22:47.685]         }
[10:22:47.685]     }, args = future.call.arguments)
[10:22:47.685] }
[10:22:47.686] Tweak future expression to call with '...' arguments ... DONE
[10:22:47.686] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.686] 
[10:22:47.686] getGlobalsAndPackages() ... DONE
[10:22:47.686] run() for ‘Future’ ...
[10:22:47.687] - state: ‘created’
[10:22:47.687] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:47.700] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:47.700] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:47.700]   - Field: ‘node’
[10:22:47.701]   - Field: ‘label’
[10:22:47.701]   - Field: ‘local’
[10:22:47.701]   - Field: ‘owner’
[10:22:47.701]   - Field: ‘envir’
[10:22:47.701]   - Field: ‘workers’
[10:22:47.701]   - Field: ‘packages’
[10:22:47.701]   - Field: ‘gc’
[10:22:47.701]   - Field: ‘conditions’
[10:22:47.701]   - Field: ‘persistent’
[10:22:47.701]   - Field: ‘expr’
[10:22:47.702]   - Field: ‘uuid’
[10:22:47.702]   - Field: ‘seed’
[10:22:47.702]   - Field: ‘version’
[10:22:47.702]   - Field: ‘result’
[10:22:47.702]   - Field: ‘asynchronous’
[10:22:47.702]   - Field: ‘calls’
[10:22:47.702]   - Field: ‘globals’
[10:22:47.702]   - Field: ‘stdout’
[10:22:47.702]   - Field: ‘earlySignal’
[10:22:47.702]   - Field: ‘lazy’
[10:22:47.702]   - Field: ‘state’
[10:22:47.703] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:47.703] - Launch lazy future ...
[10:22:47.703] Packages needed by the future expression (n = 0): <none>
[10:22:47.703] Packages needed by future strategies (n = 0): <none>
[10:22:47.703] {
[10:22:47.703]     {
[10:22:47.703]         {
[10:22:47.703]             ...future.startTime <- base::Sys.time()
[10:22:47.703]             {
[10:22:47.703]                 {
[10:22:47.703]                   {
[10:22:47.703]                     {
[10:22:47.703]                       base::local({
[10:22:47.703]                         has_future <- base::requireNamespace("future", 
[10:22:47.703]                           quietly = TRUE)
[10:22:47.703]                         if (has_future) {
[10:22:47.703]                           ns <- base::getNamespace("future")
[10:22:47.703]                           version <- ns[[".package"]][["version"]]
[10:22:47.703]                           if (is.null(version)) 
[10:22:47.703]                             version <- utils::packageVersion("future")
[10:22:47.703]                         }
[10:22:47.703]                         else {
[10:22:47.703]                           version <- NULL
[10:22:47.703]                         }
[10:22:47.703]                         if (!has_future || version < "1.8.0") {
[10:22:47.703]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:47.703]                             "", base::R.version$version.string), 
[10:22:47.703]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:47.703]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:47.703]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:47.703]                               "release", "version")], collapse = " "), 
[10:22:47.703]                             hostname = base::Sys.info()[["nodename"]])
[10:22:47.703]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:47.703]                             info)
[10:22:47.703]                           info <- base::paste(info, collapse = "; ")
[10:22:47.703]                           if (!has_future) {
[10:22:47.703]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:47.703]                               info)
[10:22:47.703]                           }
[10:22:47.703]                           else {
[10:22:47.703]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:47.703]                               info, version)
[10:22:47.703]                           }
[10:22:47.703]                           base::stop(msg)
[10:22:47.703]                         }
[10:22:47.703]                       })
[10:22:47.703]                     }
[10:22:47.703]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:47.703]                     base::options(mc.cores = 1L)
[10:22:47.703]                   }
[10:22:47.703]                   options(future.plan = NULL)
[10:22:47.703]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:47.703]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:47.703]                 }
[10:22:47.703]                 ...future.workdir <- getwd()
[10:22:47.703]             }
[10:22:47.703]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:47.703]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:47.703]         }
[10:22:47.703]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:47.703]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:47.703]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:47.703]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:47.703]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:47.703]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:47.703]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:47.703]             base::names(...future.oldOptions))
[10:22:47.703]     }
[10:22:47.703]     if (FALSE) {
[10:22:47.703]     }
[10:22:47.703]     else {
[10:22:47.703]         if (TRUE) {
[10:22:47.703]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:47.703]                 open = "w")
[10:22:47.703]         }
[10:22:47.703]         else {
[10:22:47.703]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:47.703]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:47.703]         }
[10:22:47.703]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:47.703]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:47.703]             base::sink(type = "output", split = FALSE)
[10:22:47.703]             base::close(...future.stdout)
[10:22:47.703]         }, add = TRUE)
[10:22:47.703]     }
[10:22:47.703]     ...future.frame <- base::sys.nframe()
[10:22:47.703]     ...future.conditions <- base::list()
[10:22:47.703]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:47.703]     if (FALSE) {
[10:22:47.703]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:47.703]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:47.703]     }
[10:22:47.703]     ...future.result <- base::tryCatch({
[10:22:47.703]         base::withCallingHandlers({
[10:22:47.703]             ...future.value <- base::withVisible(base::local({
[10:22:47.703]                 ...future.makeSendCondition <- base::local({
[10:22:47.703]                   sendCondition <- NULL
[10:22:47.703]                   function(frame = 1L) {
[10:22:47.703]                     if (is.function(sendCondition)) 
[10:22:47.703]                       return(sendCondition)
[10:22:47.703]                     ns <- getNamespace("parallel")
[10:22:47.703]                     if (exists("sendData", mode = "function", 
[10:22:47.703]                       envir = ns)) {
[10:22:47.703]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:47.703]                         envir = ns)
[10:22:47.703]                       envir <- sys.frame(frame)
[10:22:47.703]                       master <- NULL
[10:22:47.703]                       while (!identical(envir, .GlobalEnv) && 
[10:22:47.703]                         !identical(envir, emptyenv())) {
[10:22:47.703]                         if (exists("master", mode = "list", envir = envir, 
[10:22:47.703]                           inherits = FALSE)) {
[10:22:47.703]                           master <- get("master", mode = "list", 
[10:22:47.703]                             envir = envir, inherits = FALSE)
[10:22:47.703]                           if (inherits(master, c("SOCKnode", 
[10:22:47.703]                             "SOCK0node"))) {
[10:22:47.703]                             sendCondition <<- function(cond) {
[10:22:47.703]                               data <- list(type = "VALUE", value = cond, 
[10:22:47.703]                                 success = TRUE)
[10:22:47.703]                               parallel_sendData(master, data)
[10:22:47.703]                             }
[10:22:47.703]                             return(sendCondition)
[10:22:47.703]                           }
[10:22:47.703]                         }
[10:22:47.703]                         frame <- frame + 1L
[10:22:47.703]                         envir <- sys.frame(frame)
[10:22:47.703]                       }
[10:22:47.703]                     }
[10:22:47.703]                     sendCondition <<- function(cond) NULL
[10:22:47.703]                   }
[10:22:47.703]                 })
[10:22:47.703]                 withCallingHandlers({
[10:22:47.703]                   {
[10:22:47.703]                     do.call(function(...) {
[10:22:47.703]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.703]                       if (!identical(...future.globals.maxSize.org, 
[10:22:47.703]                         ...future.globals.maxSize)) {
[10:22:47.703]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.703]                         on.exit(options(oopts), add = TRUE)
[10:22:47.703]                       }
[10:22:47.703]                       {
[10:22:47.703]                         lapply(seq_along(...future.elements_ii), 
[10:22:47.703]                           FUN = function(jj) {
[10:22:47.703]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.703]                             ...future.FUN(...future.X_jj, ...)
[10:22:47.703]                           })
[10:22:47.703]                       }
[10:22:47.703]                     }, args = future.call.arguments)
[10:22:47.703]                   }
[10:22:47.703]                 }, immediateCondition = function(cond) {
[10:22:47.703]                   sendCondition <- ...future.makeSendCondition()
[10:22:47.703]                   sendCondition(cond)
[10:22:47.703]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.703]                   {
[10:22:47.703]                     inherits <- base::inherits
[10:22:47.703]                     invokeRestart <- base::invokeRestart
[10:22:47.703]                     is.null <- base::is.null
[10:22:47.703]                     muffled <- FALSE
[10:22:47.703]                     if (inherits(cond, "message")) {
[10:22:47.703]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:47.703]                       if (muffled) 
[10:22:47.703]                         invokeRestart("muffleMessage")
[10:22:47.703]                     }
[10:22:47.703]                     else if (inherits(cond, "warning")) {
[10:22:47.703]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:47.703]                       if (muffled) 
[10:22:47.703]                         invokeRestart("muffleWarning")
[10:22:47.703]                     }
[10:22:47.703]                     else if (inherits(cond, "condition")) {
[10:22:47.703]                       if (!is.null(pattern)) {
[10:22:47.703]                         computeRestarts <- base::computeRestarts
[10:22:47.703]                         grepl <- base::grepl
[10:22:47.703]                         restarts <- computeRestarts(cond)
[10:22:47.703]                         for (restart in restarts) {
[10:22:47.703]                           name <- restart$name
[10:22:47.703]                           if (is.null(name)) 
[10:22:47.703]                             next
[10:22:47.703]                           if (!grepl(pattern, name)) 
[10:22:47.703]                             next
[10:22:47.703]                           invokeRestart(restart)
[10:22:47.703]                           muffled <- TRUE
[10:22:47.703]                           break
[10:22:47.703]                         }
[10:22:47.703]                       }
[10:22:47.703]                     }
[10:22:47.703]                     invisible(muffled)
[10:22:47.703]                   }
[10:22:47.703]                   muffleCondition(cond)
[10:22:47.703]                 })
[10:22:47.703]             }))
[10:22:47.703]             future::FutureResult(value = ...future.value$value, 
[10:22:47.703]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:47.703]                   ...future.rng), globalenv = if (FALSE) 
[10:22:47.703]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:47.703]                     ...future.globalenv.names))
[10:22:47.703]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:47.703]         }, condition = base::local({
[10:22:47.703]             c <- base::c
[10:22:47.703]             inherits <- base::inherits
[10:22:47.703]             invokeRestart <- base::invokeRestart
[10:22:47.703]             length <- base::length
[10:22:47.703]             list <- base::list
[10:22:47.703]             seq.int <- base::seq.int
[10:22:47.703]             signalCondition <- base::signalCondition
[10:22:47.703]             sys.calls <- base::sys.calls
[10:22:47.703]             `[[` <- base::`[[`
[10:22:47.703]             `+` <- base::`+`
[10:22:47.703]             `<<-` <- base::`<<-`
[10:22:47.703]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:47.703]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:47.703]                   3L)]
[10:22:47.703]             }
[10:22:47.703]             function(cond) {
[10:22:47.703]                 is_error <- inherits(cond, "error")
[10:22:47.703]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:47.703]                   NULL)
[10:22:47.703]                 if (is_error) {
[10:22:47.703]                   sessionInformation <- function() {
[10:22:47.703]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:47.703]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:47.703]                       search = base::search(), system = base::Sys.info())
[10:22:47.703]                   }
[10:22:47.703]                   ...future.conditions[[length(...future.conditions) + 
[10:22:47.703]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:47.703]                     cond$call), session = sessionInformation(), 
[10:22:47.703]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:47.703]                   signalCondition(cond)
[10:22:47.703]                 }
[10:22:47.703]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:47.703]                 "immediateCondition"))) {
[10:22:47.703]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:47.703]                   ...future.conditions[[length(...future.conditions) + 
[10:22:47.703]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:47.703]                   if (TRUE && !signal) {
[10:22:47.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.703]                     {
[10:22:47.703]                       inherits <- base::inherits
[10:22:47.703]                       invokeRestart <- base::invokeRestart
[10:22:47.703]                       is.null <- base::is.null
[10:22:47.703]                       muffled <- FALSE
[10:22:47.703]                       if (inherits(cond, "message")) {
[10:22:47.703]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:47.703]                         if (muffled) 
[10:22:47.703]                           invokeRestart("muffleMessage")
[10:22:47.703]                       }
[10:22:47.703]                       else if (inherits(cond, "warning")) {
[10:22:47.703]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:47.703]                         if (muffled) 
[10:22:47.703]                           invokeRestart("muffleWarning")
[10:22:47.703]                       }
[10:22:47.703]                       else if (inherits(cond, "condition")) {
[10:22:47.703]                         if (!is.null(pattern)) {
[10:22:47.703]                           computeRestarts <- base::computeRestarts
[10:22:47.703]                           grepl <- base::grepl
[10:22:47.703]                           restarts <- computeRestarts(cond)
[10:22:47.703]                           for (restart in restarts) {
[10:22:47.703]                             name <- restart$name
[10:22:47.703]                             if (is.null(name)) 
[10:22:47.703]                               next
[10:22:47.703]                             if (!grepl(pattern, name)) 
[10:22:47.703]                               next
[10:22:47.703]                             invokeRestart(restart)
[10:22:47.703]                             muffled <- TRUE
[10:22:47.703]                             break
[10:22:47.703]                           }
[10:22:47.703]                         }
[10:22:47.703]                       }
[10:22:47.703]                       invisible(muffled)
[10:22:47.703]                     }
[10:22:47.703]                     muffleCondition(cond, pattern = "^muffle")
[10:22:47.703]                   }
[10:22:47.703]                 }
[10:22:47.703]                 else {
[10:22:47.703]                   if (TRUE) {
[10:22:47.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.703]                     {
[10:22:47.703]                       inherits <- base::inherits
[10:22:47.703]                       invokeRestart <- base::invokeRestart
[10:22:47.703]                       is.null <- base::is.null
[10:22:47.703]                       muffled <- FALSE
[10:22:47.703]                       if (inherits(cond, "message")) {
[10:22:47.703]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:47.703]                         if (muffled) 
[10:22:47.703]                           invokeRestart("muffleMessage")
[10:22:47.703]                       }
[10:22:47.703]                       else if (inherits(cond, "warning")) {
[10:22:47.703]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:47.703]                         if (muffled) 
[10:22:47.703]                           invokeRestart("muffleWarning")
[10:22:47.703]                       }
[10:22:47.703]                       else if (inherits(cond, "condition")) {
[10:22:47.703]                         if (!is.null(pattern)) {
[10:22:47.703]                           computeRestarts <- base::computeRestarts
[10:22:47.703]                           grepl <- base::grepl
[10:22:47.703]                           restarts <- computeRestarts(cond)
[10:22:47.703]                           for (restart in restarts) {
[10:22:47.703]                             name <- restart$name
[10:22:47.703]                             if (is.null(name)) 
[10:22:47.703]                               next
[10:22:47.703]                             if (!grepl(pattern, name)) 
[10:22:47.703]                               next
[10:22:47.703]                             invokeRestart(restart)
[10:22:47.703]                             muffled <- TRUE
[10:22:47.703]                             break
[10:22:47.703]                           }
[10:22:47.703]                         }
[10:22:47.703]                       }
[10:22:47.703]                       invisible(muffled)
[10:22:47.703]                     }
[10:22:47.703]                     muffleCondition(cond, pattern = "^muffle")
[10:22:47.703]                   }
[10:22:47.703]                 }
[10:22:47.703]             }
[10:22:47.703]         }))
[10:22:47.703]     }, error = function(ex) {
[10:22:47.703]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:47.703]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:47.703]                 ...future.rng), started = ...future.startTime, 
[10:22:47.703]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:47.703]             version = "1.8"), class = "FutureResult")
[10:22:47.703]     }, finally = {
[10:22:47.703]         if (!identical(...future.workdir, getwd())) 
[10:22:47.703]             setwd(...future.workdir)
[10:22:47.703]         {
[10:22:47.703]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:47.703]                 ...future.oldOptions$nwarnings <- NULL
[10:22:47.703]             }
[10:22:47.703]             base::options(...future.oldOptions)
[10:22:47.703]             if (.Platform$OS.type == "windows") {
[10:22:47.703]                 old_names <- names(...future.oldEnvVars)
[10:22:47.703]                 envs <- base::Sys.getenv()
[10:22:47.703]                 names <- names(envs)
[10:22:47.703]                 common <- intersect(names, old_names)
[10:22:47.703]                 added <- setdiff(names, old_names)
[10:22:47.703]                 removed <- setdiff(old_names, names)
[10:22:47.703]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:47.703]                   envs[common]]
[10:22:47.703]                 NAMES <- toupper(changed)
[10:22:47.703]                 args <- list()
[10:22:47.703]                 for (kk in seq_along(NAMES)) {
[10:22:47.703]                   name <- changed[[kk]]
[10:22:47.703]                   NAME <- NAMES[[kk]]
[10:22:47.703]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.703]                     next
[10:22:47.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:47.703]                 }
[10:22:47.703]                 NAMES <- toupper(added)
[10:22:47.703]                 for (kk in seq_along(NAMES)) {
[10:22:47.703]                   name <- added[[kk]]
[10:22:47.703]                   NAME <- NAMES[[kk]]
[10:22:47.703]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.703]                     next
[10:22:47.703]                   args[[name]] <- ""
[10:22:47.703]                 }
[10:22:47.703]                 NAMES <- toupper(removed)
[10:22:47.703]                 for (kk in seq_along(NAMES)) {
[10:22:47.703]                   name <- removed[[kk]]
[10:22:47.703]                   NAME <- NAMES[[kk]]
[10:22:47.703]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.703]                     next
[10:22:47.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:47.703]                 }
[10:22:47.703]                 if (length(args) > 0) 
[10:22:47.703]                   base::do.call(base::Sys.setenv, args = args)
[10:22:47.703]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:47.703]             }
[10:22:47.703]             else {
[10:22:47.703]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:47.703]             }
[10:22:47.703]             {
[10:22:47.703]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:47.703]                   0L) {
[10:22:47.703]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:47.703]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:47.703]                   base::options(opts)
[10:22:47.703]                 }
[10:22:47.703]                 {
[10:22:47.703]                   {
[10:22:47.703]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:47.703]                     NULL
[10:22:47.703]                   }
[10:22:47.703]                   options(future.plan = NULL)
[10:22:47.703]                   if (is.na(NA_character_)) 
[10:22:47.703]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:47.703]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:47.703]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:47.703]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:47.703]                     envir = parent.frame()) 
[10:22:47.703]                   {
[10:22:47.703]                     if (is.function(workers)) 
[10:22:47.703]                       workers <- workers()
[10:22:47.703]                     workers <- structure(as.integer(workers), 
[10:22:47.703]                       class = class(workers))
[10:22:47.703]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:47.703]                       workers >= 1)
[10:22:47.703]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:47.703]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:47.703]                     }
[10:22:47.703]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:47.703]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:47.703]                       envir = envir)
[10:22:47.703]                     if (!future$lazy) 
[10:22:47.703]                       future <- run(future)
[10:22:47.703]                     invisible(future)
[10:22:47.703]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:47.703]                 }
[10:22:47.703]             }
[10:22:47.703]         }
[10:22:47.703]     })
[10:22:47.703]     if (TRUE) {
[10:22:47.703]         base::sink(type = "output", split = FALSE)
[10:22:47.703]         if (TRUE) {
[10:22:47.703]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:47.703]         }
[10:22:47.703]         else {
[10:22:47.703]             ...future.result["stdout"] <- base::list(NULL)
[10:22:47.703]         }
[10:22:47.703]         base::close(...future.stdout)
[10:22:47.703]         ...future.stdout <- NULL
[10:22:47.703]     }
[10:22:47.703]     ...future.result$conditions <- ...future.conditions
[10:22:47.703]     ...future.result$finished <- base::Sys.time()
[10:22:47.703]     ...future.result
[10:22:47.703] }
[10:22:47.706] Exporting 5 global objects (1.12 KiB) to cluster node #1 ...
[10:22:47.707] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:22:47.707] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:22:47.707] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[10:22:47.707] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[10:22:47.708] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #1 ...
[10:22:47.708] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #1 ... DONE
[10:22:47.708] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:22:47.708] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:22:47.708] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[10:22:47.709] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[10:22:47.709] Exporting 5 global objects (1.12 KiB) to cluster node #1 ... DONE
[10:22:47.709] MultisessionFuture started
[10:22:47.709] - Launch lazy future ... done
[10:22:47.710] run() for ‘MultisessionFuture’ ... done
[10:22:47.710] Created future:
[10:22:47.710] MultisessionFuture:
[10:22:47.710] Label: ‘future_apply-1’
[10:22:47.710] Expression:
[10:22:47.710] {
[10:22:47.710]     do.call(function(...) {
[10:22:47.710]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.710]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:47.710]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.710]             on.exit(options(oopts), add = TRUE)
[10:22:47.710]         }
[10:22:47.710]         {
[10:22:47.710]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:47.710]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.710]                 ...future.FUN(...future.X_jj, ...)
[10:22:47.710]             })
[10:22:47.710]         }
[10:22:47.710]     }, args = future.call.arguments)
[10:22:47.710] }
[10:22:47.710] Lazy evaluation: FALSE
[10:22:47.710] Asynchronous evaluation: TRUE
[10:22:47.710] Local evaluation: TRUE
[10:22:47.710] Environment: R_GlobalEnv
[10:22:47.710] Capture standard output: TRUE
[10:22:47.710] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:47.710] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:47.710] Packages: <none>
[10:22:47.710] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:47.710] Resolved: FALSE
[10:22:47.710] Value: <not collected>
[10:22:47.710] Conditions captured: <none>
[10:22:47.710] Early signaling: FALSE
[10:22:47.710] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:47.710] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:47.721] Chunk #1 of 2 ... DONE
[10:22:47.721] Chunk #2 of 2 ...
[10:22:47.722]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:47.722]  - seeds: <none>
[10:22:47.722]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.722] getGlobalsAndPackages() ...
[10:22:47.722] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.722] Resolving globals: FALSE
[10:22:47.722] Tweak future expression to call with '...' arguments ...
[10:22:47.722] {
[10:22:47.722]     do.call(function(...) {
[10:22:47.722]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.722]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:47.722]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.722]             on.exit(options(oopts), add = TRUE)
[10:22:47.722]         }
[10:22:47.722]         {
[10:22:47.722]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:47.722]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.722]                 ...future.FUN(...future.X_jj, ...)
[10:22:47.722]             })
[10:22:47.722]         }
[10:22:47.722]     }, args = future.call.arguments)
[10:22:47.722] }
[10:22:47.723] Tweak future expression to call with '...' arguments ... DONE
[10:22:47.723] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.723] 
[10:22:47.723] getGlobalsAndPackages() ... DONE
[10:22:47.724] run() for ‘Future’ ...
[10:22:47.724] - state: ‘created’
[10:22:47.724] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:47.739] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:47.739] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:47.739]   - Field: ‘node’
[10:22:47.739]   - Field: ‘label’
[10:22:47.739]   - Field: ‘local’
[10:22:47.739]   - Field: ‘owner’
[10:22:47.740]   - Field: ‘envir’
[10:22:47.740]   - Field: ‘workers’
[10:22:47.740]   - Field: ‘packages’
[10:22:47.740]   - Field: ‘gc’
[10:22:47.740]   - Field: ‘conditions’
[10:22:47.740]   - Field: ‘persistent’
[10:22:47.740]   - Field: ‘expr’
[10:22:47.740]   - Field: ‘uuid’
[10:22:47.740]   - Field: ‘seed’
[10:22:47.740]   - Field: ‘version’
[10:22:47.740]   - Field: ‘result’
[10:22:47.741]   - Field: ‘asynchronous’
[10:22:47.741]   - Field: ‘calls’
[10:22:47.741]   - Field: ‘globals’
[10:22:47.741]   - Field: ‘stdout’
[10:22:47.741]   - Field: ‘earlySignal’
[10:22:47.741]   - Field: ‘lazy’
[10:22:47.741]   - Field: ‘state’
[10:22:47.741] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:47.741] - Launch lazy future ...
[10:22:47.742] Packages needed by the future expression (n = 0): <none>
[10:22:47.742] Packages needed by future strategies (n = 0): <none>
[10:22:47.742] {
[10:22:47.742]     {
[10:22:47.742]         {
[10:22:47.742]             ...future.startTime <- base::Sys.time()
[10:22:47.742]             {
[10:22:47.742]                 {
[10:22:47.742]                   {
[10:22:47.742]                     {
[10:22:47.742]                       base::local({
[10:22:47.742]                         has_future <- base::requireNamespace("future", 
[10:22:47.742]                           quietly = TRUE)
[10:22:47.742]                         if (has_future) {
[10:22:47.742]                           ns <- base::getNamespace("future")
[10:22:47.742]                           version <- ns[[".package"]][["version"]]
[10:22:47.742]                           if (is.null(version)) 
[10:22:47.742]                             version <- utils::packageVersion("future")
[10:22:47.742]                         }
[10:22:47.742]                         else {
[10:22:47.742]                           version <- NULL
[10:22:47.742]                         }
[10:22:47.742]                         if (!has_future || version < "1.8.0") {
[10:22:47.742]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:47.742]                             "", base::R.version$version.string), 
[10:22:47.742]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:47.742]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:47.742]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:47.742]                               "release", "version")], collapse = " "), 
[10:22:47.742]                             hostname = base::Sys.info()[["nodename"]])
[10:22:47.742]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:47.742]                             info)
[10:22:47.742]                           info <- base::paste(info, collapse = "; ")
[10:22:47.742]                           if (!has_future) {
[10:22:47.742]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:47.742]                               info)
[10:22:47.742]                           }
[10:22:47.742]                           else {
[10:22:47.742]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:47.742]                               info, version)
[10:22:47.742]                           }
[10:22:47.742]                           base::stop(msg)
[10:22:47.742]                         }
[10:22:47.742]                       })
[10:22:47.742]                     }
[10:22:47.742]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:47.742]                     base::options(mc.cores = 1L)
[10:22:47.742]                   }
[10:22:47.742]                   options(future.plan = NULL)
[10:22:47.742]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:47.742]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:47.742]                 }
[10:22:47.742]                 ...future.workdir <- getwd()
[10:22:47.742]             }
[10:22:47.742]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:47.742]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:47.742]         }
[10:22:47.742]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:47.742]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:47.742]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:47.742]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:47.742]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:47.742]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:47.742]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:47.742]             base::names(...future.oldOptions))
[10:22:47.742]     }
[10:22:47.742]     if (FALSE) {
[10:22:47.742]     }
[10:22:47.742]     else {
[10:22:47.742]         if (TRUE) {
[10:22:47.742]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:47.742]                 open = "w")
[10:22:47.742]         }
[10:22:47.742]         else {
[10:22:47.742]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:47.742]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:47.742]         }
[10:22:47.742]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:47.742]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:47.742]             base::sink(type = "output", split = FALSE)
[10:22:47.742]             base::close(...future.stdout)
[10:22:47.742]         }, add = TRUE)
[10:22:47.742]     }
[10:22:47.742]     ...future.frame <- base::sys.nframe()
[10:22:47.742]     ...future.conditions <- base::list()
[10:22:47.742]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:47.742]     if (FALSE) {
[10:22:47.742]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:47.742]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:47.742]     }
[10:22:47.742]     ...future.result <- base::tryCatch({
[10:22:47.742]         base::withCallingHandlers({
[10:22:47.742]             ...future.value <- base::withVisible(base::local({
[10:22:47.742]                 ...future.makeSendCondition <- base::local({
[10:22:47.742]                   sendCondition <- NULL
[10:22:47.742]                   function(frame = 1L) {
[10:22:47.742]                     if (is.function(sendCondition)) 
[10:22:47.742]                       return(sendCondition)
[10:22:47.742]                     ns <- getNamespace("parallel")
[10:22:47.742]                     if (exists("sendData", mode = "function", 
[10:22:47.742]                       envir = ns)) {
[10:22:47.742]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:47.742]                         envir = ns)
[10:22:47.742]                       envir <- sys.frame(frame)
[10:22:47.742]                       master <- NULL
[10:22:47.742]                       while (!identical(envir, .GlobalEnv) && 
[10:22:47.742]                         !identical(envir, emptyenv())) {
[10:22:47.742]                         if (exists("master", mode = "list", envir = envir, 
[10:22:47.742]                           inherits = FALSE)) {
[10:22:47.742]                           master <- get("master", mode = "list", 
[10:22:47.742]                             envir = envir, inherits = FALSE)
[10:22:47.742]                           if (inherits(master, c("SOCKnode", 
[10:22:47.742]                             "SOCK0node"))) {
[10:22:47.742]                             sendCondition <<- function(cond) {
[10:22:47.742]                               data <- list(type = "VALUE", value = cond, 
[10:22:47.742]                                 success = TRUE)
[10:22:47.742]                               parallel_sendData(master, data)
[10:22:47.742]                             }
[10:22:47.742]                             return(sendCondition)
[10:22:47.742]                           }
[10:22:47.742]                         }
[10:22:47.742]                         frame <- frame + 1L
[10:22:47.742]                         envir <- sys.frame(frame)
[10:22:47.742]                       }
[10:22:47.742]                     }
[10:22:47.742]                     sendCondition <<- function(cond) NULL
[10:22:47.742]                   }
[10:22:47.742]                 })
[10:22:47.742]                 withCallingHandlers({
[10:22:47.742]                   {
[10:22:47.742]                     do.call(function(...) {
[10:22:47.742]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.742]                       if (!identical(...future.globals.maxSize.org, 
[10:22:47.742]                         ...future.globals.maxSize)) {
[10:22:47.742]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.742]                         on.exit(options(oopts), add = TRUE)
[10:22:47.742]                       }
[10:22:47.742]                       {
[10:22:47.742]                         lapply(seq_along(...future.elements_ii), 
[10:22:47.742]                           FUN = function(jj) {
[10:22:47.742]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.742]                             ...future.FUN(...future.X_jj, ...)
[10:22:47.742]                           })
[10:22:47.742]                       }
[10:22:47.742]                     }, args = future.call.arguments)
[10:22:47.742]                   }
[10:22:47.742]                 }, immediateCondition = function(cond) {
[10:22:47.742]                   sendCondition <- ...future.makeSendCondition()
[10:22:47.742]                   sendCondition(cond)
[10:22:47.742]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.742]                   {
[10:22:47.742]                     inherits <- base::inherits
[10:22:47.742]                     invokeRestart <- base::invokeRestart
[10:22:47.742]                     is.null <- base::is.null
[10:22:47.742]                     muffled <- FALSE
[10:22:47.742]                     if (inherits(cond, "message")) {
[10:22:47.742]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:47.742]                       if (muffled) 
[10:22:47.742]                         invokeRestart("muffleMessage")
[10:22:47.742]                     }
[10:22:47.742]                     else if (inherits(cond, "warning")) {
[10:22:47.742]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:47.742]                       if (muffled) 
[10:22:47.742]                         invokeRestart("muffleWarning")
[10:22:47.742]                     }
[10:22:47.742]                     else if (inherits(cond, "condition")) {
[10:22:47.742]                       if (!is.null(pattern)) {
[10:22:47.742]                         computeRestarts <- base::computeRestarts
[10:22:47.742]                         grepl <- base::grepl
[10:22:47.742]                         restarts <- computeRestarts(cond)
[10:22:47.742]                         for (restart in restarts) {
[10:22:47.742]                           name <- restart$name
[10:22:47.742]                           if (is.null(name)) 
[10:22:47.742]                             next
[10:22:47.742]                           if (!grepl(pattern, name)) 
[10:22:47.742]                             next
[10:22:47.742]                           invokeRestart(restart)
[10:22:47.742]                           muffled <- TRUE
[10:22:47.742]                           break
[10:22:47.742]                         }
[10:22:47.742]                       }
[10:22:47.742]                     }
[10:22:47.742]                     invisible(muffled)
[10:22:47.742]                   }
[10:22:47.742]                   muffleCondition(cond)
[10:22:47.742]                 })
[10:22:47.742]             }))
[10:22:47.742]             future::FutureResult(value = ...future.value$value, 
[10:22:47.742]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:47.742]                   ...future.rng), globalenv = if (FALSE) 
[10:22:47.742]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:47.742]                     ...future.globalenv.names))
[10:22:47.742]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:47.742]         }, condition = base::local({
[10:22:47.742]             c <- base::c
[10:22:47.742]             inherits <- base::inherits
[10:22:47.742]             invokeRestart <- base::invokeRestart
[10:22:47.742]             length <- base::length
[10:22:47.742]             list <- base::list
[10:22:47.742]             seq.int <- base::seq.int
[10:22:47.742]             signalCondition <- base::signalCondition
[10:22:47.742]             sys.calls <- base::sys.calls
[10:22:47.742]             `[[` <- base::`[[`
[10:22:47.742]             `+` <- base::`+`
[10:22:47.742]             `<<-` <- base::`<<-`
[10:22:47.742]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:47.742]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:47.742]                   3L)]
[10:22:47.742]             }
[10:22:47.742]             function(cond) {
[10:22:47.742]                 is_error <- inherits(cond, "error")
[10:22:47.742]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:47.742]                   NULL)
[10:22:47.742]                 if (is_error) {
[10:22:47.742]                   sessionInformation <- function() {
[10:22:47.742]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:47.742]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:47.742]                       search = base::search(), system = base::Sys.info())
[10:22:47.742]                   }
[10:22:47.742]                   ...future.conditions[[length(...future.conditions) + 
[10:22:47.742]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:47.742]                     cond$call), session = sessionInformation(), 
[10:22:47.742]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:47.742]                   signalCondition(cond)
[10:22:47.742]                 }
[10:22:47.742]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:47.742]                 "immediateCondition"))) {
[10:22:47.742]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:47.742]                   ...future.conditions[[length(...future.conditions) + 
[10:22:47.742]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:47.742]                   if (TRUE && !signal) {
[10:22:47.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.742]                     {
[10:22:47.742]                       inherits <- base::inherits
[10:22:47.742]                       invokeRestart <- base::invokeRestart
[10:22:47.742]                       is.null <- base::is.null
[10:22:47.742]                       muffled <- FALSE
[10:22:47.742]                       if (inherits(cond, "message")) {
[10:22:47.742]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:47.742]                         if (muffled) 
[10:22:47.742]                           invokeRestart("muffleMessage")
[10:22:47.742]                       }
[10:22:47.742]                       else if (inherits(cond, "warning")) {
[10:22:47.742]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:47.742]                         if (muffled) 
[10:22:47.742]                           invokeRestart("muffleWarning")
[10:22:47.742]                       }
[10:22:47.742]                       else if (inherits(cond, "condition")) {
[10:22:47.742]                         if (!is.null(pattern)) {
[10:22:47.742]                           computeRestarts <- base::computeRestarts
[10:22:47.742]                           grepl <- base::grepl
[10:22:47.742]                           restarts <- computeRestarts(cond)
[10:22:47.742]                           for (restart in restarts) {
[10:22:47.742]                             name <- restart$name
[10:22:47.742]                             if (is.null(name)) 
[10:22:47.742]                               next
[10:22:47.742]                             if (!grepl(pattern, name)) 
[10:22:47.742]                               next
[10:22:47.742]                             invokeRestart(restart)
[10:22:47.742]                             muffled <- TRUE
[10:22:47.742]                             break
[10:22:47.742]                           }
[10:22:47.742]                         }
[10:22:47.742]                       }
[10:22:47.742]                       invisible(muffled)
[10:22:47.742]                     }
[10:22:47.742]                     muffleCondition(cond, pattern = "^muffle")
[10:22:47.742]                   }
[10:22:47.742]                 }
[10:22:47.742]                 else {
[10:22:47.742]                   if (TRUE) {
[10:22:47.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.742]                     {
[10:22:47.742]                       inherits <- base::inherits
[10:22:47.742]                       invokeRestart <- base::invokeRestart
[10:22:47.742]                       is.null <- base::is.null
[10:22:47.742]                       muffled <- FALSE
[10:22:47.742]                       if (inherits(cond, "message")) {
[10:22:47.742]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:47.742]                         if (muffled) 
[10:22:47.742]                           invokeRestart("muffleMessage")
[10:22:47.742]                       }
[10:22:47.742]                       else if (inherits(cond, "warning")) {
[10:22:47.742]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:47.742]                         if (muffled) 
[10:22:47.742]                           invokeRestart("muffleWarning")
[10:22:47.742]                       }
[10:22:47.742]                       else if (inherits(cond, "condition")) {
[10:22:47.742]                         if (!is.null(pattern)) {
[10:22:47.742]                           computeRestarts <- base::computeRestarts
[10:22:47.742]                           grepl <- base::grepl
[10:22:47.742]                           restarts <- computeRestarts(cond)
[10:22:47.742]                           for (restart in restarts) {
[10:22:47.742]                             name <- restart$name
[10:22:47.742]                             if (is.null(name)) 
[10:22:47.742]                               next
[10:22:47.742]                             if (!grepl(pattern, name)) 
[10:22:47.742]                               next
[10:22:47.742]                             invokeRestart(restart)
[10:22:47.742]                             muffled <- TRUE
[10:22:47.742]                             break
[10:22:47.742]                           }
[10:22:47.742]                         }
[10:22:47.742]                       }
[10:22:47.742]                       invisible(muffled)
[10:22:47.742]                     }
[10:22:47.742]                     muffleCondition(cond, pattern = "^muffle")
[10:22:47.742]                   }
[10:22:47.742]                 }
[10:22:47.742]             }
[10:22:47.742]         }))
[10:22:47.742]     }, error = function(ex) {
[10:22:47.742]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:47.742]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:47.742]                 ...future.rng), started = ...future.startTime, 
[10:22:47.742]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:47.742]             version = "1.8"), class = "FutureResult")
[10:22:47.742]     }, finally = {
[10:22:47.742]         if (!identical(...future.workdir, getwd())) 
[10:22:47.742]             setwd(...future.workdir)
[10:22:47.742]         {
[10:22:47.742]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:47.742]                 ...future.oldOptions$nwarnings <- NULL
[10:22:47.742]             }
[10:22:47.742]             base::options(...future.oldOptions)
[10:22:47.742]             if (.Platform$OS.type == "windows") {
[10:22:47.742]                 old_names <- names(...future.oldEnvVars)
[10:22:47.742]                 envs <- base::Sys.getenv()
[10:22:47.742]                 names <- names(envs)
[10:22:47.742]                 common <- intersect(names, old_names)
[10:22:47.742]                 added <- setdiff(names, old_names)
[10:22:47.742]                 removed <- setdiff(old_names, names)
[10:22:47.742]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:47.742]                   envs[common]]
[10:22:47.742]                 NAMES <- toupper(changed)
[10:22:47.742]                 args <- list()
[10:22:47.742]                 for (kk in seq_along(NAMES)) {
[10:22:47.742]                   name <- changed[[kk]]
[10:22:47.742]                   NAME <- NAMES[[kk]]
[10:22:47.742]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.742]                     next
[10:22:47.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:47.742]                 }
[10:22:47.742]                 NAMES <- toupper(added)
[10:22:47.742]                 for (kk in seq_along(NAMES)) {
[10:22:47.742]                   name <- added[[kk]]
[10:22:47.742]                   NAME <- NAMES[[kk]]
[10:22:47.742]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.742]                     next
[10:22:47.742]                   args[[name]] <- ""
[10:22:47.742]                 }
[10:22:47.742]                 NAMES <- toupper(removed)
[10:22:47.742]                 for (kk in seq_along(NAMES)) {
[10:22:47.742]                   name <- removed[[kk]]
[10:22:47.742]                   NAME <- NAMES[[kk]]
[10:22:47.742]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.742]                     next
[10:22:47.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:47.742]                 }
[10:22:47.742]                 if (length(args) > 0) 
[10:22:47.742]                   base::do.call(base::Sys.setenv, args = args)
[10:22:47.742]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:47.742]             }
[10:22:47.742]             else {
[10:22:47.742]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:47.742]             }
[10:22:47.742]             {
[10:22:47.742]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:47.742]                   0L) {
[10:22:47.742]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:47.742]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:47.742]                   base::options(opts)
[10:22:47.742]                 }
[10:22:47.742]                 {
[10:22:47.742]                   {
[10:22:47.742]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:47.742]                     NULL
[10:22:47.742]                   }
[10:22:47.742]                   options(future.plan = NULL)
[10:22:47.742]                   if (is.na(NA_character_)) 
[10:22:47.742]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:47.742]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:47.742]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:47.742]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:47.742]                     envir = parent.frame()) 
[10:22:47.742]                   {
[10:22:47.742]                     if (is.function(workers)) 
[10:22:47.742]                       workers <- workers()
[10:22:47.742]                     workers <- structure(as.integer(workers), 
[10:22:47.742]                       class = class(workers))
[10:22:47.742]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:47.742]                       workers >= 1)
[10:22:47.742]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:47.742]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:47.742]                     }
[10:22:47.742]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:47.742]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:47.742]                       envir = envir)
[10:22:47.742]                     if (!future$lazy) 
[10:22:47.742]                       future <- run(future)
[10:22:47.742]                     invisible(future)
[10:22:47.742]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:47.742]                 }
[10:22:47.742]             }
[10:22:47.742]         }
[10:22:47.742]     })
[10:22:47.742]     if (TRUE) {
[10:22:47.742]         base::sink(type = "output", split = FALSE)
[10:22:47.742]         if (TRUE) {
[10:22:47.742]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:47.742]         }
[10:22:47.742]         else {
[10:22:47.742]             ...future.result["stdout"] <- base::list(NULL)
[10:22:47.742]         }
[10:22:47.742]         base::close(...future.stdout)
[10:22:47.742]         ...future.stdout <- NULL
[10:22:47.742]     }
[10:22:47.742]     ...future.result$conditions <- ...future.conditions
[10:22:47.742]     ...future.result$finished <- base::Sys.time()
[10:22:47.742]     ...future.result
[10:22:47.742] }
[10:22:47.745] Exporting 5 global objects (1.12 KiB) to cluster node #2 ...
[10:22:47.746] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:22:47.746] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:22:47.746] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[10:22:47.747] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[10:22:47.747] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #2 ...
[10:22:47.747] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #2 ... DONE
[10:22:47.747] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:22:47.748] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:22:47.748] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[10:22:47.748] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[10:22:47.748] Exporting 5 global objects (1.12 KiB) to cluster node #2 ... DONE
[10:22:47.749] MultisessionFuture started
[10:22:47.749] - Launch lazy future ... done
[10:22:47.749] run() for ‘MultisessionFuture’ ... done
[10:22:47.749] Created future:
[10:22:47.749] MultisessionFuture:
[10:22:47.749] Label: ‘future_apply-2’
[10:22:47.749] Expression:
[10:22:47.749] {
[10:22:47.749]     do.call(function(...) {
[10:22:47.749]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.749]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:47.749]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.749]             on.exit(options(oopts), add = TRUE)
[10:22:47.749]         }
[10:22:47.749]         {
[10:22:47.749]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:47.749]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.749]                 ...future.FUN(...future.X_jj, ...)
[10:22:47.749]             })
[10:22:47.749]         }
[10:22:47.749]     }, args = future.call.arguments)
[10:22:47.749] }
[10:22:47.749] Lazy evaluation: FALSE
[10:22:47.749] Asynchronous evaluation: TRUE
[10:22:47.749] Local evaluation: TRUE
[10:22:47.749] Environment: R_GlobalEnv
[10:22:47.749] Capture standard output: TRUE
[10:22:47.749] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:47.749] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:47.749] Packages: <none>
[10:22:47.749] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:47.749] Resolved: FALSE
[10:22:47.749] Value: <not collected>
[10:22:47.749] Conditions captured: <none>
[10:22:47.749] Early signaling: FALSE
[10:22:47.749] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:47.749] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:47.761] Chunk #2 of 2 ... DONE
[10:22:47.761] Launching 2 futures (chunks) ... DONE
[10:22:47.761] Resolving 2 futures (chunks) ...
[10:22:47.761] resolve() on list ...
[10:22:47.762]  recursive: 0
[10:22:47.762]  length: 2
[10:22:47.762] 
[10:22:47.762] receiveMessageFromWorker() for ClusterFuture ...
[10:22:47.762] - Validating connection of MultisessionFuture
[10:22:47.763] - received message: FutureResult
[10:22:47.763] - Received FutureResult
[10:22:47.763] - Erased future from FutureRegistry
[10:22:47.763] result() for ClusterFuture ...
[10:22:47.763] - result already collected: FutureResult
[10:22:47.763] result() for ClusterFuture ... done
[10:22:47.763] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:47.763] Future #1
[10:22:47.763] result() for ClusterFuture ...
[10:22:47.764] - result already collected: FutureResult
[10:22:47.764] result() for ClusterFuture ... done
[10:22:47.764] result() for ClusterFuture ...
[10:22:47.764] - result already collected: FutureResult
[10:22:47.764] result() for ClusterFuture ... done
[10:22:47.764] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:22:47.764] - nx: 2
[10:22:47.764] - relay: TRUE
[10:22:47.764] - stdout: TRUE
[10:22:47.764] - signal: TRUE
[10:22:47.764] - resignal: FALSE
[10:22:47.765] - force: TRUE
[10:22:47.765] - relayed: [n=2] FALSE, FALSE
[10:22:47.765] - queued futures: [n=2] FALSE, FALSE
[10:22:47.765]  - until=1
[10:22:47.765]  - relaying element #1
[10:22:47.765] result() for ClusterFuture ...
[10:22:47.765] - result already collected: FutureResult
[10:22:47.765] result() for ClusterFuture ... done
[10:22:47.765] result() for ClusterFuture ...
[10:22:47.765] - result already collected: FutureResult
[10:22:47.765] result() for ClusterFuture ... done
[10:22:47.766] result() for ClusterFuture ...
[10:22:47.766] - result already collected: FutureResult
[10:22:47.766] result() for ClusterFuture ... done
[10:22:47.766] result() for ClusterFuture ...
[10:22:47.766] - result already collected: FutureResult
[10:22:47.766] result() for ClusterFuture ... done
[10:22:47.766] - relayed: [n=2] TRUE, FALSE
[10:22:47.766] - queued futures: [n=2] TRUE, FALSE
[10:22:47.766] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:22:47.766]  length: 1 (resolved future 1)
[10:22:47.794] receiveMessageFromWorker() for ClusterFuture ...
[10:22:47.794] - Validating connection of MultisessionFuture
[10:22:47.795] - received message: FutureResult
[10:22:47.795] - Received FutureResult
[10:22:47.795] - Erased future from FutureRegistry
[10:22:47.795] result() for ClusterFuture ...
[10:22:47.795] - result already collected: FutureResult
[10:22:47.795] result() for ClusterFuture ... done
[10:22:47.795] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:47.795] Future #2
[10:22:47.795] result() for ClusterFuture ...
[10:22:47.795] - result already collected: FutureResult
[10:22:47.796] result() for ClusterFuture ... done
[10:22:47.796] result() for ClusterFuture ...
[10:22:47.796] - result already collected: FutureResult
[10:22:47.796] result() for ClusterFuture ... done
[10:22:47.796] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:22:47.796] - nx: 2
[10:22:47.796] - relay: TRUE
[10:22:47.796] - stdout: TRUE
[10:22:47.796] - signal: TRUE
[10:22:47.796] - resignal: FALSE
[10:22:47.796] - force: TRUE
[10:22:47.797] - relayed: [n=2] TRUE, FALSE
[10:22:47.797] - queued futures: [n=2] TRUE, FALSE
[10:22:47.797]  - until=2
[10:22:47.797]  - relaying element #2
[10:22:47.797] result() for ClusterFuture ...
[10:22:47.797] - result already collected: FutureResult
[10:22:47.797] result() for ClusterFuture ... done
[10:22:47.797] result() for ClusterFuture ...
[10:22:47.797] - result already collected: FutureResult
[10:22:47.797] result() for ClusterFuture ... done
[10:22:47.798] result() for ClusterFuture ...
[10:22:47.798] - result already collected: FutureResult
[10:22:47.798] result() for ClusterFuture ... done
[10:22:47.798] result() for ClusterFuture ...
[10:22:47.798] - result already collected: FutureResult
[10:22:47.798] result() for ClusterFuture ... done
[10:22:47.798] - relayed: [n=2] TRUE, TRUE
[10:22:47.798] - queued futures: [n=2] TRUE, TRUE
[10:22:47.798] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:22:47.798]  length: 0 (resolved future 2)
[10:22:47.798] Relaying remaining futures
[10:22:47.799] signalConditionsASAP(NULL, pos=0) ...
[10:22:47.799] - nx: 2
[10:22:47.799] - relay: TRUE
[10:22:47.799] - stdout: TRUE
[10:22:47.799] - signal: TRUE
[10:22:47.799] - resignal: FALSE
[10:22:47.799] - force: TRUE
[10:22:47.799] - relayed: [n=2] TRUE, TRUE
[10:22:47.799] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:22:47.799] - relayed: [n=2] TRUE, TRUE
[10:22:47.799] - queued futures: [n=2] TRUE, TRUE
[10:22:47.800] signalConditionsASAP(NULL, pos=0) ... done
[10:22:47.800] resolve() on list ... DONE
[10:22:47.800] result() for ClusterFuture ...
[10:22:47.800] - result already collected: FutureResult
[10:22:47.800] result() for ClusterFuture ... done
[10:22:47.800] result() for ClusterFuture ...
[10:22:47.800] - result already collected: FutureResult
[10:22:47.800] result() for ClusterFuture ... done
[10:22:47.800] result() for ClusterFuture ...
[10:22:47.800] - result already collected: FutureResult
[10:22:47.800] result() for ClusterFuture ... done
[10:22:47.801] result() for ClusterFuture ...
[10:22:47.801] - result already collected: FutureResult
[10:22:47.801] result() for ClusterFuture ... done
[10:22:47.801]  - Number of value chunks collected: 2
[10:22:47.801] Resolving 2 futures (chunks) ... DONE
[10:22:47.801] Reducing values from 2 chunks ...
[10:22:47.801]  - Number of values collected after concatenation: 2
[10:22:47.801]  - Number of values expected: 2
[10:22:47.801] Reducing values from 2 chunks ... DONE
[10:22:47.801] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[10:22:47.802] getGlobalsAndPackagesXApply() ...
[10:22:47.802]  - future.globals: TRUE
[10:22:47.802] getGlobalsAndPackages() ...
[10:22:47.802] Searching for globals...
[10:22:47.804] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[10:22:47.805] Searching for globals ... DONE
[10:22:47.805] Resolving globals: FALSE
[10:22:47.805] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[10:22:47.806] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[10:22:47.806] - globals: [1] ‘FUN’
[10:22:47.806] 
[10:22:47.806] getGlobalsAndPackages() ... DONE
[10:22:47.806]  - globals found/used: [n=1] ‘FUN’
[10:22:47.806]  - needed namespaces: [n=0] 
[10:22:47.806] Finding globals ... DONE
[10:22:47.806]  - use_args: TRUE
[10:22:47.806]  - Getting '...' globals ...
[10:22:47.807] resolve() on list ...
[10:22:47.807]  recursive: 0
[10:22:47.807]  length: 1
[10:22:47.807]  elements: ‘...’
[10:22:47.807]  length: 0 (resolved future 1)
[10:22:47.807] resolve() on list ... DONE
[10:22:47.807]    - '...' content: [n=0] 
[10:22:47.807] List of 1
[10:22:47.807]  $ ...: list()
[10:22:47.807]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:47.807]  - attr(*, "where")=List of 1
[10:22:47.807]   ..$ ...:<environment: 0x55ca4e3e6a78> 
[10:22:47.807]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:47.807]  - attr(*, "resolved")= logi TRUE
[10:22:47.807]  - attr(*, "total_size")= num NA
[10:22:47.810]  - Getting '...' globals ... DONE
[10:22:47.810] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:47.810] List of 2
[10:22:47.810]  $ ...future.FUN:function (x)  
[10:22:47.810]  $ ...          : list()
[10:22:47.810]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:47.810]  - attr(*, "where")=List of 2
[10:22:47.810]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:47.810]   ..$ ...          :<environment: 0x55ca4e3e6a78> 
[10:22:47.810]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:47.810]  - attr(*, "resolved")= logi FALSE
[10:22:47.810]  - attr(*, "total_size")= num 9888
[10:22:47.813] Packages to be attached in all futures: [n=0] 
[10:22:47.813] getGlobalsAndPackagesXApply() ... DONE
[10:22:47.817] future_lapply() ...
[10:22:47.821] Number of chunks: 2
[10:22:47.821] getGlobalsAndPackagesXApply() ...
[10:22:47.821]  - future.globals: <name-value list> with names ‘list()’
[10:22:47.822]  - use_args: TRUE
[10:22:47.822] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:22:47.822] List of 2
[10:22:47.822]  $ ...          : list()
[10:22:47.822]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:47.822]  $ ...future.FUN:function (x)  
[10:22:47.822]  - attr(*, "where")=List of 2
[10:22:47.822]   ..$ ...          :<environment: 0x55ca4e3e6a78> 
[10:22:47.822]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[10:22:47.822]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:47.822]  - attr(*, "resolved")= logi FALSE
[10:22:47.822]  - attr(*, "total_size")= num NA
[10:22:47.825] Packages to be attached in all futures: [n=0] 
[10:22:47.825] getGlobalsAndPackagesXApply() ... DONE
[10:22:47.825] Number of futures (= number of chunks): 2
[10:22:47.825] Launching 2 futures (chunks) ...
[10:22:47.825] Chunk #1 of 2 ...
[10:22:47.825]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:47.825]  - seeds: <none>
[10:22:47.826]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.826] getGlobalsAndPackages() ...
[10:22:47.826] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.826] Resolving globals: FALSE
[10:22:47.826] Tweak future expression to call with '...' arguments ...
[10:22:47.826] {
[10:22:47.826]     do.call(function(...) {
[10:22:47.826]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.826]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:47.826]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.826]             on.exit(options(oopts), add = TRUE)
[10:22:47.826]         }
[10:22:47.826]         {
[10:22:47.826]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:47.826]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.826]                 ...future.FUN(...future.X_jj, ...)
[10:22:47.826]             })
[10:22:47.826]         }
[10:22:47.826]     }, args = future.call.arguments)
[10:22:47.826] }
[10:22:47.826] Tweak future expression to call with '...' arguments ... DONE
[10:22:47.827] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.827] 
[10:22:47.827] getGlobalsAndPackages() ... DONE
[10:22:47.827] run() for ‘Future’ ...
[10:22:47.827] - state: ‘created’
[10:22:47.827] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:47.841] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:47.842] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:47.842]   - Field: ‘node’
[10:22:47.842]   - Field: ‘label’
[10:22:47.842]   - Field: ‘local’
[10:22:47.842]   - Field: ‘owner’
[10:22:47.842]   - Field: ‘envir’
[10:22:47.842]   - Field: ‘workers’
[10:22:47.842]   - Field: ‘packages’
[10:22:47.842]   - Field: ‘gc’
[10:22:47.842]   - Field: ‘conditions’
[10:22:47.842]   - Field: ‘persistent’
[10:22:47.843]   - Field: ‘expr’
[10:22:47.843]   - Field: ‘uuid’
[10:22:47.843]   - Field: ‘seed’
[10:22:47.843]   - Field: ‘version’
[10:22:47.843]   - Field: ‘result’
[10:22:47.843]   - Field: ‘asynchronous’
[10:22:47.843]   - Field: ‘calls’
[10:22:47.843]   - Field: ‘globals’
[10:22:47.843]   - Field: ‘stdout’
[10:22:47.843]   - Field: ‘earlySignal’
[10:22:47.843]   - Field: ‘lazy’
[10:22:47.844]   - Field: ‘state’
[10:22:47.844] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:47.844] - Launch lazy future ...
[10:22:47.844] Packages needed by the future expression (n = 0): <none>
[10:22:47.844] Packages needed by future strategies (n = 0): <none>
[10:22:47.845] {
[10:22:47.845]     {
[10:22:47.845]         {
[10:22:47.845]             ...future.startTime <- base::Sys.time()
[10:22:47.845]             {
[10:22:47.845]                 {
[10:22:47.845]                   {
[10:22:47.845]                     {
[10:22:47.845]                       base::local({
[10:22:47.845]                         has_future <- base::requireNamespace("future", 
[10:22:47.845]                           quietly = TRUE)
[10:22:47.845]                         if (has_future) {
[10:22:47.845]                           ns <- base::getNamespace("future")
[10:22:47.845]                           version <- ns[[".package"]][["version"]]
[10:22:47.845]                           if (is.null(version)) 
[10:22:47.845]                             version <- utils::packageVersion("future")
[10:22:47.845]                         }
[10:22:47.845]                         else {
[10:22:47.845]                           version <- NULL
[10:22:47.845]                         }
[10:22:47.845]                         if (!has_future || version < "1.8.0") {
[10:22:47.845]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:47.845]                             "", base::R.version$version.string), 
[10:22:47.845]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:47.845]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:47.845]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:47.845]                               "release", "version")], collapse = " "), 
[10:22:47.845]                             hostname = base::Sys.info()[["nodename"]])
[10:22:47.845]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:47.845]                             info)
[10:22:47.845]                           info <- base::paste(info, collapse = "; ")
[10:22:47.845]                           if (!has_future) {
[10:22:47.845]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:47.845]                               info)
[10:22:47.845]                           }
[10:22:47.845]                           else {
[10:22:47.845]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:47.845]                               info, version)
[10:22:47.845]                           }
[10:22:47.845]                           base::stop(msg)
[10:22:47.845]                         }
[10:22:47.845]                       })
[10:22:47.845]                     }
[10:22:47.845]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:47.845]                     base::options(mc.cores = 1L)
[10:22:47.845]                   }
[10:22:47.845]                   options(future.plan = NULL)
[10:22:47.845]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:47.845]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:47.845]                 }
[10:22:47.845]                 ...future.workdir <- getwd()
[10:22:47.845]             }
[10:22:47.845]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:47.845]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:47.845]         }
[10:22:47.845]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:47.845]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:47.845]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:47.845]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:47.845]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:47.845]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:47.845]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:47.845]             base::names(...future.oldOptions))
[10:22:47.845]     }
[10:22:47.845]     if (FALSE) {
[10:22:47.845]     }
[10:22:47.845]     else {
[10:22:47.845]         if (TRUE) {
[10:22:47.845]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:47.845]                 open = "w")
[10:22:47.845]         }
[10:22:47.845]         else {
[10:22:47.845]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:47.845]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:47.845]         }
[10:22:47.845]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:47.845]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:47.845]             base::sink(type = "output", split = FALSE)
[10:22:47.845]             base::close(...future.stdout)
[10:22:47.845]         }, add = TRUE)
[10:22:47.845]     }
[10:22:47.845]     ...future.frame <- base::sys.nframe()
[10:22:47.845]     ...future.conditions <- base::list()
[10:22:47.845]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:47.845]     if (FALSE) {
[10:22:47.845]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:47.845]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:47.845]     }
[10:22:47.845]     ...future.result <- base::tryCatch({
[10:22:47.845]         base::withCallingHandlers({
[10:22:47.845]             ...future.value <- base::withVisible(base::local({
[10:22:47.845]                 ...future.makeSendCondition <- base::local({
[10:22:47.845]                   sendCondition <- NULL
[10:22:47.845]                   function(frame = 1L) {
[10:22:47.845]                     if (is.function(sendCondition)) 
[10:22:47.845]                       return(sendCondition)
[10:22:47.845]                     ns <- getNamespace("parallel")
[10:22:47.845]                     if (exists("sendData", mode = "function", 
[10:22:47.845]                       envir = ns)) {
[10:22:47.845]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:47.845]                         envir = ns)
[10:22:47.845]                       envir <- sys.frame(frame)
[10:22:47.845]                       master <- NULL
[10:22:47.845]                       while (!identical(envir, .GlobalEnv) && 
[10:22:47.845]                         !identical(envir, emptyenv())) {
[10:22:47.845]                         if (exists("master", mode = "list", envir = envir, 
[10:22:47.845]                           inherits = FALSE)) {
[10:22:47.845]                           master <- get("master", mode = "list", 
[10:22:47.845]                             envir = envir, inherits = FALSE)
[10:22:47.845]                           if (inherits(master, c("SOCKnode", 
[10:22:47.845]                             "SOCK0node"))) {
[10:22:47.845]                             sendCondition <<- function(cond) {
[10:22:47.845]                               data <- list(type = "VALUE", value = cond, 
[10:22:47.845]                                 success = TRUE)
[10:22:47.845]                               parallel_sendData(master, data)
[10:22:47.845]                             }
[10:22:47.845]                             return(sendCondition)
[10:22:47.845]                           }
[10:22:47.845]                         }
[10:22:47.845]                         frame <- frame + 1L
[10:22:47.845]                         envir <- sys.frame(frame)
[10:22:47.845]                       }
[10:22:47.845]                     }
[10:22:47.845]                     sendCondition <<- function(cond) NULL
[10:22:47.845]                   }
[10:22:47.845]                 })
[10:22:47.845]                 withCallingHandlers({
[10:22:47.845]                   {
[10:22:47.845]                     do.call(function(...) {
[10:22:47.845]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.845]                       if (!identical(...future.globals.maxSize.org, 
[10:22:47.845]                         ...future.globals.maxSize)) {
[10:22:47.845]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.845]                         on.exit(options(oopts), add = TRUE)
[10:22:47.845]                       }
[10:22:47.845]                       {
[10:22:47.845]                         lapply(seq_along(...future.elements_ii), 
[10:22:47.845]                           FUN = function(jj) {
[10:22:47.845]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.845]                             ...future.FUN(...future.X_jj, ...)
[10:22:47.845]                           })
[10:22:47.845]                       }
[10:22:47.845]                     }, args = future.call.arguments)
[10:22:47.845]                   }
[10:22:47.845]                 }, immediateCondition = function(cond) {
[10:22:47.845]                   sendCondition <- ...future.makeSendCondition()
[10:22:47.845]                   sendCondition(cond)
[10:22:47.845]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.845]                   {
[10:22:47.845]                     inherits <- base::inherits
[10:22:47.845]                     invokeRestart <- base::invokeRestart
[10:22:47.845]                     is.null <- base::is.null
[10:22:47.845]                     muffled <- FALSE
[10:22:47.845]                     if (inherits(cond, "message")) {
[10:22:47.845]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:47.845]                       if (muffled) 
[10:22:47.845]                         invokeRestart("muffleMessage")
[10:22:47.845]                     }
[10:22:47.845]                     else if (inherits(cond, "warning")) {
[10:22:47.845]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:47.845]                       if (muffled) 
[10:22:47.845]                         invokeRestart("muffleWarning")
[10:22:47.845]                     }
[10:22:47.845]                     else if (inherits(cond, "condition")) {
[10:22:47.845]                       if (!is.null(pattern)) {
[10:22:47.845]                         computeRestarts <- base::computeRestarts
[10:22:47.845]                         grepl <- base::grepl
[10:22:47.845]                         restarts <- computeRestarts(cond)
[10:22:47.845]                         for (restart in restarts) {
[10:22:47.845]                           name <- restart$name
[10:22:47.845]                           if (is.null(name)) 
[10:22:47.845]                             next
[10:22:47.845]                           if (!grepl(pattern, name)) 
[10:22:47.845]                             next
[10:22:47.845]                           invokeRestart(restart)
[10:22:47.845]                           muffled <- TRUE
[10:22:47.845]                           break
[10:22:47.845]                         }
[10:22:47.845]                       }
[10:22:47.845]                     }
[10:22:47.845]                     invisible(muffled)
[10:22:47.845]                   }
[10:22:47.845]                   muffleCondition(cond)
[10:22:47.845]                 })
[10:22:47.845]             }))
[10:22:47.845]             future::FutureResult(value = ...future.value$value, 
[10:22:47.845]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:47.845]                   ...future.rng), globalenv = if (FALSE) 
[10:22:47.845]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:47.845]                     ...future.globalenv.names))
[10:22:47.845]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:47.845]         }, condition = base::local({
[10:22:47.845]             c <- base::c
[10:22:47.845]             inherits <- base::inherits
[10:22:47.845]             invokeRestart <- base::invokeRestart
[10:22:47.845]             length <- base::length
[10:22:47.845]             list <- base::list
[10:22:47.845]             seq.int <- base::seq.int
[10:22:47.845]             signalCondition <- base::signalCondition
[10:22:47.845]             sys.calls <- base::sys.calls
[10:22:47.845]             `[[` <- base::`[[`
[10:22:47.845]             `+` <- base::`+`
[10:22:47.845]             `<<-` <- base::`<<-`
[10:22:47.845]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:47.845]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:47.845]                   3L)]
[10:22:47.845]             }
[10:22:47.845]             function(cond) {
[10:22:47.845]                 is_error <- inherits(cond, "error")
[10:22:47.845]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:47.845]                   NULL)
[10:22:47.845]                 if (is_error) {
[10:22:47.845]                   sessionInformation <- function() {
[10:22:47.845]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:47.845]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:47.845]                       search = base::search(), system = base::Sys.info())
[10:22:47.845]                   }
[10:22:47.845]                   ...future.conditions[[length(...future.conditions) + 
[10:22:47.845]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:47.845]                     cond$call), session = sessionInformation(), 
[10:22:47.845]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:47.845]                   signalCondition(cond)
[10:22:47.845]                 }
[10:22:47.845]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:47.845]                 "immediateCondition"))) {
[10:22:47.845]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:47.845]                   ...future.conditions[[length(...future.conditions) + 
[10:22:47.845]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:47.845]                   if (TRUE && !signal) {
[10:22:47.845]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.845]                     {
[10:22:47.845]                       inherits <- base::inherits
[10:22:47.845]                       invokeRestart <- base::invokeRestart
[10:22:47.845]                       is.null <- base::is.null
[10:22:47.845]                       muffled <- FALSE
[10:22:47.845]                       if (inherits(cond, "message")) {
[10:22:47.845]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:47.845]                         if (muffled) 
[10:22:47.845]                           invokeRestart("muffleMessage")
[10:22:47.845]                       }
[10:22:47.845]                       else if (inherits(cond, "warning")) {
[10:22:47.845]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:47.845]                         if (muffled) 
[10:22:47.845]                           invokeRestart("muffleWarning")
[10:22:47.845]                       }
[10:22:47.845]                       else if (inherits(cond, "condition")) {
[10:22:47.845]                         if (!is.null(pattern)) {
[10:22:47.845]                           computeRestarts <- base::computeRestarts
[10:22:47.845]                           grepl <- base::grepl
[10:22:47.845]                           restarts <- computeRestarts(cond)
[10:22:47.845]                           for (restart in restarts) {
[10:22:47.845]                             name <- restart$name
[10:22:47.845]                             if (is.null(name)) 
[10:22:47.845]                               next
[10:22:47.845]                             if (!grepl(pattern, name)) 
[10:22:47.845]                               next
[10:22:47.845]                             invokeRestart(restart)
[10:22:47.845]                             muffled <- TRUE
[10:22:47.845]                             break
[10:22:47.845]                           }
[10:22:47.845]                         }
[10:22:47.845]                       }
[10:22:47.845]                       invisible(muffled)
[10:22:47.845]                     }
[10:22:47.845]                     muffleCondition(cond, pattern = "^muffle")
[10:22:47.845]                   }
[10:22:47.845]                 }
[10:22:47.845]                 else {
[10:22:47.845]                   if (TRUE) {
[10:22:47.845]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.845]                     {
[10:22:47.845]                       inherits <- base::inherits
[10:22:47.845]                       invokeRestart <- base::invokeRestart
[10:22:47.845]                       is.null <- base::is.null
[10:22:47.845]                       muffled <- FALSE
[10:22:47.845]                       if (inherits(cond, "message")) {
[10:22:47.845]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:47.845]                         if (muffled) 
[10:22:47.845]                           invokeRestart("muffleMessage")
[10:22:47.845]                       }
[10:22:47.845]                       else if (inherits(cond, "warning")) {
[10:22:47.845]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:47.845]                         if (muffled) 
[10:22:47.845]                           invokeRestart("muffleWarning")
[10:22:47.845]                       }
[10:22:47.845]                       else if (inherits(cond, "condition")) {
[10:22:47.845]                         if (!is.null(pattern)) {
[10:22:47.845]                           computeRestarts <- base::computeRestarts
[10:22:47.845]                           grepl <- base::grepl
[10:22:47.845]                           restarts <- computeRestarts(cond)
[10:22:47.845]                           for (restart in restarts) {
[10:22:47.845]                             name <- restart$name
[10:22:47.845]                             if (is.null(name)) 
[10:22:47.845]                               next
[10:22:47.845]                             if (!grepl(pattern, name)) 
[10:22:47.845]                               next
[10:22:47.845]                             invokeRestart(restart)
[10:22:47.845]                             muffled <- TRUE
[10:22:47.845]                             break
[10:22:47.845]                           }
[10:22:47.845]                         }
[10:22:47.845]                       }
[10:22:47.845]                       invisible(muffled)
[10:22:47.845]                     }
[10:22:47.845]                     muffleCondition(cond, pattern = "^muffle")
[10:22:47.845]                   }
[10:22:47.845]                 }
[10:22:47.845]             }
[10:22:47.845]         }))
[10:22:47.845]     }, error = function(ex) {
[10:22:47.845]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:47.845]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:47.845]                 ...future.rng), started = ...future.startTime, 
[10:22:47.845]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:47.845]             version = "1.8"), class = "FutureResult")
[10:22:47.845]     }, finally = {
[10:22:47.845]         if (!identical(...future.workdir, getwd())) 
[10:22:47.845]             setwd(...future.workdir)
[10:22:47.845]         {
[10:22:47.845]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:47.845]                 ...future.oldOptions$nwarnings <- NULL
[10:22:47.845]             }
[10:22:47.845]             base::options(...future.oldOptions)
[10:22:47.845]             if (.Platform$OS.type == "windows") {
[10:22:47.845]                 old_names <- names(...future.oldEnvVars)
[10:22:47.845]                 envs <- base::Sys.getenv()
[10:22:47.845]                 names <- names(envs)
[10:22:47.845]                 common <- intersect(names, old_names)
[10:22:47.845]                 added <- setdiff(names, old_names)
[10:22:47.845]                 removed <- setdiff(old_names, names)
[10:22:47.845]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:47.845]                   envs[common]]
[10:22:47.845]                 NAMES <- toupper(changed)
[10:22:47.845]                 args <- list()
[10:22:47.845]                 for (kk in seq_along(NAMES)) {
[10:22:47.845]                   name <- changed[[kk]]
[10:22:47.845]                   NAME <- NAMES[[kk]]
[10:22:47.845]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.845]                     next
[10:22:47.845]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:47.845]                 }
[10:22:47.845]                 NAMES <- toupper(added)
[10:22:47.845]                 for (kk in seq_along(NAMES)) {
[10:22:47.845]                   name <- added[[kk]]
[10:22:47.845]                   NAME <- NAMES[[kk]]
[10:22:47.845]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.845]                     next
[10:22:47.845]                   args[[name]] <- ""
[10:22:47.845]                 }
[10:22:47.845]                 NAMES <- toupper(removed)
[10:22:47.845]                 for (kk in seq_along(NAMES)) {
[10:22:47.845]                   name <- removed[[kk]]
[10:22:47.845]                   NAME <- NAMES[[kk]]
[10:22:47.845]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.845]                     next
[10:22:47.845]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:47.845]                 }
[10:22:47.845]                 if (length(args) > 0) 
[10:22:47.845]                   base::do.call(base::Sys.setenv, args = args)
[10:22:47.845]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:47.845]             }
[10:22:47.845]             else {
[10:22:47.845]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:47.845]             }
[10:22:47.845]             {
[10:22:47.845]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:47.845]                   0L) {
[10:22:47.845]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:47.845]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:47.845]                   base::options(opts)
[10:22:47.845]                 }
[10:22:47.845]                 {
[10:22:47.845]                   {
[10:22:47.845]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:47.845]                     NULL
[10:22:47.845]                   }
[10:22:47.845]                   options(future.plan = NULL)
[10:22:47.845]                   if (is.na(NA_character_)) 
[10:22:47.845]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:47.845]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:47.845]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:47.845]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:47.845]                     envir = parent.frame()) 
[10:22:47.845]                   {
[10:22:47.845]                     if (is.function(workers)) 
[10:22:47.845]                       workers <- workers()
[10:22:47.845]                     workers <- structure(as.integer(workers), 
[10:22:47.845]                       class = class(workers))
[10:22:47.845]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:47.845]                       workers >= 1)
[10:22:47.845]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:47.845]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:47.845]                     }
[10:22:47.845]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:47.845]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:47.845]                       envir = envir)
[10:22:47.845]                     if (!future$lazy) 
[10:22:47.845]                       future <- run(future)
[10:22:47.845]                     invisible(future)
[10:22:47.845]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:47.845]                 }
[10:22:47.845]             }
[10:22:47.845]         }
[10:22:47.845]     })
[10:22:47.845]     if (TRUE) {
[10:22:47.845]         base::sink(type = "output", split = FALSE)
[10:22:47.845]         if (TRUE) {
[10:22:47.845]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:47.845]         }
[10:22:47.845]         else {
[10:22:47.845]             ...future.result["stdout"] <- base::list(NULL)
[10:22:47.845]         }
[10:22:47.845]         base::close(...future.stdout)
[10:22:47.845]         ...future.stdout <- NULL
[10:22:47.845]     }
[10:22:47.845]     ...future.result$conditions <- ...future.conditions
[10:22:47.845]     ...future.result$finished <- base::Sys.time()
[10:22:47.845]     ...future.result
[10:22:47.845] }
[10:22:47.848] Exporting 5 global objects (9.77 KiB) to cluster node #1 ...
[10:22:47.848] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:22:47.848] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:22:47.848] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #1 ...
[10:22:47.849] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #1 ... DONE
[10:22:47.849] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[10:22:47.849] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[10:22:47.849] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:22:47.850] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:22:47.850] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[10:22:47.850] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[10:22:47.850] Exporting 5 global objects (9.77 KiB) to cluster node #1 ... DONE
[10:22:47.853] MultisessionFuture started
[10:22:47.853] - Launch lazy future ... done
[10:22:47.853] run() for ‘MultisessionFuture’ ... done
[10:22:47.853] Created future:
[10:22:47.853] MultisessionFuture:
[10:22:47.853] Label: ‘future_apply-1’
[10:22:47.853] Expression:
[10:22:47.853] {
[10:22:47.853]     do.call(function(...) {
[10:22:47.853]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.853]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:47.853]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.853]             on.exit(options(oopts), add = TRUE)
[10:22:47.853]         }
[10:22:47.853]         {
[10:22:47.853]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:47.853]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.853]                 ...future.FUN(...future.X_jj, ...)
[10:22:47.853]             })
[10:22:47.853]         }
[10:22:47.853]     }, args = future.call.arguments)
[10:22:47.853] }
[10:22:47.853] Lazy evaluation: FALSE
[10:22:47.853] Asynchronous evaluation: TRUE
[10:22:47.853] Local evaluation: TRUE
[10:22:47.853] Environment: R_GlobalEnv
[10:22:47.853] Capture standard output: TRUE
[10:22:47.853] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:47.853] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:47.853] Packages: <none>
[10:22:47.853] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:47.853] Resolved: FALSE
[10:22:47.853] Value: <not collected>
[10:22:47.853] Conditions captured: <none>
[10:22:47.853] Early signaling: FALSE
[10:22:47.853] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:47.853] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:47.865] Chunk #1 of 2 ... DONE
[10:22:47.865] Chunk #2 of 2 ...
[10:22:47.865]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:47.865]  - seeds: <none>
[10:22:47.865]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.866] getGlobalsAndPackages() ...
[10:22:47.866] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.866] Resolving globals: FALSE
[10:22:47.866] Tweak future expression to call with '...' arguments ...
[10:22:47.866] {
[10:22:47.866]     do.call(function(...) {
[10:22:47.866]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.866]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:47.866]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.866]             on.exit(options(oopts), add = TRUE)
[10:22:47.866]         }
[10:22:47.866]         {
[10:22:47.866]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:47.866]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.866]                 ...future.FUN(...future.X_jj, ...)
[10:22:47.866]             })
[10:22:47.866]         }
[10:22:47.866]     }, args = future.call.arguments)
[10:22:47.866] }
[10:22:47.866] Tweak future expression to call with '...' arguments ... DONE
[10:22:47.867] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.867] 
[10:22:47.867] getGlobalsAndPackages() ... DONE
[10:22:47.867] run() for ‘Future’ ...
[10:22:47.867] - state: ‘created’
[10:22:47.867] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:47.881] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:47.881] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:47.881]   - Field: ‘node’
[10:22:47.882]   - Field: ‘label’
[10:22:47.882]   - Field: ‘local’
[10:22:47.882]   - Field: ‘owner’
[10:22:47.882]   - Field: ‘envir’
[10:22:47.882]   - Field: ‘workers’
[10:22:47.882]   - Field: ‘packages’
[10:22:47.882]   - Field: ‘gc’
[10:22:47.882]   - Field: ‘conditions’
[10:22:47.882]   - Field: ‘persistent’
[10:22:47.882]   - Field: ‘expr’
[10:22:47.882]   - Field: ‘uuid’
[10:22:47.883]   - Field: ‘seed’
[10:22:47.883]   - Field: ‘version’
[10:22:47.883]   - Field: ‘result’
[10:22:47.883]   - Field: ‘asynchronous’
[10:22:47.883]   - Field: ‘calls’
[10:22:47.883]   - Field: ‘globals’
[10:22:47.883]   - Field: ‘stdout’
[10:22:47.883]   - Field: ‘earlySignal’
[10:22:47.883]   - Field: ‘lazy’
[10:22:47.883]   - Field: ‘state’
[10:22:47.883] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:47.884] - Launch lazy future ...
[10:22:47.884] Packages needed by the future expression (n = 0): <none>
[10:22:47.884] Packages needed by future strategies (n = 0): <none>
[10:22:47.884] {
[10:22:47.884]     {
[10:22:47.884]         {
[10:22:47.884]             ...future.startTime <- base::Sys.time()
[10:22:47.884]             {
[10:22:47.884]                 {
[10:22:47.884]                   {
[10:22:47.884]                     {
[10:22:47.884]                       base::local({
[10:22:47.884]                         has_future <- base::requireNamespace("future", 
[10:22:47.884]                           quietly = TRUE)
[10:22:47.884]                         if (has_future) {
[10:22:47.884]                           ns <- base::getNamespace("future")
[10:22:47.884]                           version <- ns[[".package"]][["version"]]
[10:22:47.884]                           if (is.null(version)) 
[10:22:47.884]                             version <- utils::packageVersion("future")
[10:22:47.884]                         }
[10:22:47.884]                         else {
[10:22:47.884]                           version <- NULL
[10:22:47.884]                         }
[10:22:47.884]                         if (!has_future || version < "1.8.0") {
[10:22:47.884]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:47.884]                             "", base::R.version$version.string), 
[10:22:47.884]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:47.884]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:47.884]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:47.884]                               "release", "version")], collapse = " "), 
[10:22:47.884]                             hostname = base::Sys.info()[["nodename"]])
[10:22:47.884]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:47.884]                             info)
[10:22:47.884]                           info <- base::paste(info, collapse = "; ")
[10:22:47.884]                           if (!has_future) {
[10:22:47.884]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:47.884]                               info)
[10:22:47.884]                           }
[10:22:47.884]                           else {
[10:22:47.884]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:47.884]                               info, version)
[10:22:47.884]                           }
[10:22:47.884]                           base::stop(msg)
[10:22:47.884]                         }
[10:22:47.884]                       })
[10:22:47.884]                     }
[10:22:47.884]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:47.884]                     base::options(mc.cores = 1L)
[10:22:47.884]                   }
[10:22:47.884]                   options(future.plan = NULL)
[10:22:47.884]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:47.884]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:47.884]                 }
[10:22:47.884]                 ...future.workdir <- getwd()
[10:22:47.884]             }
[10:22:47.884]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:47.884]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:47.884]         }
[10:22:47.884]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:47.884]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:47.884]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:47.884]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:47.884]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:47.884]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:47.884]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:47.884]             base::names(...future.oldOptions))
[10:22:47.884]     }
[10:22:47.884]     if (FALSE) {
[10:22:47.884]     }
[10:22:47.884]     else {
[10:22:47.884]         if (TRUE) {
[10:22:47.884]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:47.884]                 open = "w")
[10:22:47.884]         }
[10:22:47.884]         else {
[10:22:47.884]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:47.884]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:47.884]         }
[10:22:47.884]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:47.884]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:47.884]             base::sink(type = "output", split = FALSE)
[10:22:47.884]             base::close(...future.stdout)
[10:22:47.884]         }, add = TRUE)
[10:22:47.884]     }
[10:22:47.884]     ...future.frame <- base::sys.nframe()
[10:22:47.884]     ...future.conditions <- base::list()
[10:22:47.884]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:47.884]     if (FALSE) {
[10:22:47.884]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:47.884]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:47.884]     }
[10:22:47.884]     ...future.result <- base::tryCatch({
[10:22:47.884]         base::withCallingHandlers({
[10:22:47.884]             ...future.value <- base::withVisible(base::local({
[10:22:47.884]                 ...future.makeSendCondition <- base::local({
[10:22:47.884]                   sendCondition <- NULL
[10:22:47.884]                   function(frame = 1L) {
[10:22:47.884]                     if (is.function(sendCondition)) 
[10:22:47.884]                       return(sendCondition)
[10:22:47.884]                     ns <- getNamespace("parallel")
[10:22:47.884]                     if (exists("sendData", mode = "function", 
[10:22:47.884]                       envir = ns)) {
[10:22:47.884]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:47.884]                         envir = ns)
[10:22:47.884]                       envir <- sys.frame(frame)
[10:22:47.884]                       master <- NULL
[10:22:47.884]                       while (!identical(envir, .GlobalEnv) && 
[10:22:47.884]                         !identical(envir, emptyenv())) {
[10:22:47.884]                         if (exists("master", mode = "list", envir = envir, 
[10:22:47.884]                           inherits = FALSE)) {
[10:22:47.884]                           master <- get("master", mode = "list", 
[10:22:47.884]                             envir = envir, inherits = FALSE)
[10:22:47.884]                           if (inherits(master, c("SOCKnode", 
[10:22:47.884]                             "SOCK0node"))) {
[10:22:47.884]                             sendCondition <<- function(cond) {
[10:22:47.884]                               data <- list(type = "VALUE", value = cond, 
[10:22:47.884]                                 success = TRUE)
[10:22:47.884]                               parallel_sendData(master, data)
[10:22:47.884]                             }
[10:22:47.884]                             return(sendCondition)
[10:22:47.884]                           }
[10:22:47.884]                         }
[10:22:47.884]                         frame <- frame + 1L
[10:22:47.884]                         envir <- sys.frame(frame)
[10:22:47.884]                       }
[10:22:47.884]                     }
[10:22:47.884]                     sendCondition <<- function(cond) NULL
[10:22:47.884]                   }
[10:22:47.884]                 })
[10:22:47.884]                 withCallingHandlers({
[10:22:47.884]                   {
[10:22:47.884]                     do.call(function(...) {
[10:22:47.884]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.884]                       if (!identical(...future.globals.maxSize.org, 
[10:22:47.884]                         ...future.globals.maxSize)) {
[10:22:47.884]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.884]                         on.exit(options(oopts), add = TRUE)
[10:22:47.884]                       }
[10:22:47.884]                       {
[10:22:47.884]                         lapply(seq_along(...future.elements_ii), 
[10:22:47.884]                           FUN = function(jj) {
[10:22:47.884]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.884]                             ...future.FUN(...future.X_jj, ...)
[10:22:47.884]                           })
[10:22:47.884]                       }
[10:22:47.884]                     }, args = future.call.arguments)
[10:22:47.884]                   }
[10:22:47.884]                 }, immediateCondition = function(cond) {
[10:22:47.884]                   sendCondition <- ...future.makeSendCondition()
[10:22:47.884]                   sendCondition(cond)
[10:22:47.884]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.884]                   {
[10:22:47.884]                     inherits <- base::inherits
[10:22:47.884]                     invokeRestart <- base::invokeRestart
[10:22:47.884]                     is.null <- base::is.null
[10:22:47.884]                     muffled <- FALSE
[10:22:47.884]                     if (inherits(cond, "message")) {
[10:22:47.884]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:47.884]                       if (muffled) 
[10:22:47.884]                         invokeRestart("muffleMessage")
[10:22:47.884]                     }
[10:22:47.884]                     else if (inherits(cond, "warning")) {
[10:22:47.884]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:47.884]                       if (muffled) 
[10:22:47.884]                         invokeRestart("muffleWarning")
[10:22:47.884]                     }
[10:22:47.884]                     else if (inherits(cond, "condition")) {
[10:22:47.884]                       if (!is.null(pattern)) {
[10:22:47.884]                         computeRestarts <- base::computeRestarts
[10:22:47.884]                         grepl <- base::grepl
[10:22:47.884]                         restarts <- computeRestarts(cond)
[10:22:47.884]                         for (restart in restarts) {
[10:22:47.884]                           name <- restart$name
[10:22:47.884]                           if (is.null(name)) 
[10:22:47.884]                             next
[10:22:47.884]                           if (!grepl(pattern, name)) 
[10:22:47.884]                             next
[10:22:47.884]                           invokeRestart(restart)
[10:22:47.884]                           muffled <- TRUE
[10:22:47.884]                           break
[10:22:47.884]                         }
[10:22:47.884]                       }
[10:22:47.884]                     }
[10:22:47.884]                     invisible(muffled)
[10:22:47.884]                   }
[10:22:47.884]                   muffleCondition(cond)
[10:22:47.884]                 })
[10:22:47.884]             }))
[10:22:47.884]             future::FutureResult(value = ...future.value$value, 
[10:22:47.884]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:47.884]                   ...future.rng), globalenv = if (FALSE) 
[10:22:47.884]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:47.884]                     ...future.globalenv.names))
[10:22:47.884]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:47.884]         }, condition = base::local({
[10:22:47.884]             c <- base::c
[10:22:47.884]             inherits <- base::inherits
[10:22:47.884]             invokeRestart <- base::invokeRestart
[10:22:47.884]             length <- base::length
[10:22:47.884]             list <- base::list
[10:22:47.884]             seq.int <- base::seq.int
[10:22:47.884]             signalCondition <- base::signalCondition
[10:22:47.884]             sys.calls <- base::sys.calls
[10:22:47.884]             `[[` <- base::`[[`
[10:22:47.884]             `+` <- base::`+`
[10:22:47.884]             `<<-` <- base::`<<-`
[10:22:47.884]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:47.884]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:47.884]                   3L)]
[10:22:47.884]             }
[10:22:47.884]             function(cond) {
[10:22:47.884]                 is_error <- inherits(cond, "error")
[10:22:47.884]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:47.884]                   NULL)
[10:22:47.884]                 if (is_error) {
[10:22:47.884]                   sessionInformation <- function() {
[10:22:47.884]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:47.884]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:47.884]                       search = base::search(), system = base::Sys.info())
[10:22:47.884]                   }
[10:22:47.884]                   ...future.conditions[[length(...future.conditions) + 
[10:22:47.884]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:47.884]                     cond$call), session = sessionInformation(), 
[10:22:47.884]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:47.884]                   signalCondition(cond)
[10:22:47.884]                 }
[10:22:47.884]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:47.884]                 "immediateCondition"))) {
[10:22:47.884]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:47.884]                   ...future.conditions[[length(...future.conditions) + 
[10:22:47.884]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:47.884]                   if (TRUE && !signal) {
[10:22:47.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.884]                     {
[10:22:47.884]                       inherits <- base::inherits
[10:22:47.884]                       invokeRestart <- base::invokeRestart
[10:22:47.884]                       is.null <- base::is.null
[10:22:47.884]                       muffled <- FALSE
[10:22:47.884]                       if (inherits(cond, "message")) {
[10:22:47.884]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:47.884]                         if (muffled) 
[10:22:47.884]                           invokeRestart("muffleMessage")
[10:22:47.884]                       }
[10:22:47.884]                       else if (inherits(cond, "warning")) {
[10:22:47.884]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:47.884]                         if (muffled) 
[10:22:47.884]                           invokeRestart("muffleWarning")
[10:22:47.884]                       }
[10:22:47.884]                       else if (inherits(cond, "condition")) {
[10:22:47.884]                         if (!is.null(pattern)) {
[10:22:47.884]                           computeRestarts <- base::computeRestarts
[10:22:47.884]                           grepl <- base::grepl
[10:22:47.884]                           restarts <- computeRestarts(cond)
[10:22:47.884]                           for (restart in restarts) {
[10:22:47.884]                             name <- restart$name
[10:22:47.884]                             if (is.null(name)) 
[10:22:47.884]                               next
[10:22:47.884]                             if (!grepl(pattern, name)) 
[10:22:47.884]                               next
[10:22:47.884]                             invokeRestart(restart)
[10:22:47.884]                             muffled <- TRUE
[10:22:47.884]                             break
[10:22:47.884]                           }
[10:22:47.884]                         }
[10:22:47.884]                       }
[10:22:47.884]                       invisible(muffled)
[10:22:47.884]                     }
[10:22:47.884]                     muffleCondition(cond, pattern = "^muffle")
[10:22:47.884]                   }
[10:22:47.884]                 }
[10:22:47.884]                 else {
[10:22:47.884]                   if (TRUE) {
[10:22:47.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.884]                     {
[10:22:47.884]                       inherits <- base::inherits
[10:22:47.884]                       invokeRestart <- base::invokeRestart
[10:22:47.884]                       is.null <- base::is.null
[10:22:47.884]                       muffled <- FALSE
[10:22:47.884]                       if (inherits(cond, "message")) {
[10:22:47.884]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:47.884]                         if (muffled) 
[10:22:47.884]                           invokeRestart("muffleMessage")
[10:22:47.884]                       }
[10:22:47.884]                       else if (inherits(cond, "warning")) {
[10:22:47.884]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:47.884]                         if (muffled) 
[10:22:47.884]                           invokeRestart("muffleWarning")
[10:22:47.884]                       }
[10:22:47.884]                       else if (inherits(cond, "condition")) {
[10:22:47.884]                         if (!is.null(pattern)) {
[10:22:47.884]                           computeRestarts <- base::computeRestarts
[10:22:47.884]                           grepl <- base::grepl
[10:22:47.884]                           restarts <- computeRestarts(cond)
[10:22:47.884]                           for (restart in restarts) {
[10:22:47.884]                             name <- restart$name
[10:22:47.884]                             if (is.null(name)) 
[10:22:47.884]                               next
[10:22:47.884]                             if (!grepl(pattern, name)) 
[10:22:47.884]                               next
[10:22:47.884]                             invokeRestart(restart)
[10:22:47.884]                             muffled <- TRUE
[10:22:47.884]                             break
[10:22:47.884]                           }
[10:22:47.884]                         }
[10:22:47.884]                       }
[10:22:47.884]                       invisible(muffled)
[10:22:47.884]                     }
[10:22:47.884]                     muffleCondition(cond, pattern = "^muffle")
[10:22:47.884]                   }
[10:22:47.884]                 }
[10:22:47.884]             }
[10:22:47.884]         }))
[10:22:47.884]     }, error = function(ex) {
[10:22:47.884]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:47.884]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:47.884]                 ...future.rng), started = ...future.startTime, 
[10:22:47.884]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:47.884]             version = "1.8"), class = "FutureResult")
[10:22:47.884]     }, finally = {
[10:22:47.884]         if (!identical(...future.workdir, getwd())) 
[10:22:47.884]             setwd(...future.workdir)
[10:22:47.884]         {
[10:22:47.884]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:47.884]                 ...future.oldOptions$nwarnings <- NULL
[10:22:47.884]             }
[10:22:47.884]             base::options(...future.oldOptions)
[10:22:47.884]             if (.Platform$OS.type == "windows") {
[10:22:47.884]                 old_names <- names(...future.oldEnvVars)
[10:22:47.884]                 envs <- base::Sys.getenv()
[10:22:47.884]                 names <- names(envs)
[10:22:47.884]                 common <- intersect(names, old_names)
[10:22:47.884]                 added <- setdiff(names, old_names)
[10:22:47.884]                 removed <- setdiff(old_names, names)
[10:22:47.884]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:47.884]                   envs[common]]
[10:22:47.884]                 NAMES <- toupper(changed)
[10:22:47.884]                 args <- list()
[10:22:47.884]                 for (kk in seq_along(NAMES)) {
[10:22:47.884]                   name <- changed[[kk]]
[10:22:47.884]                   NAME <- NAMES[[kk]]
[10:22:47.884]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.884]                     next
[10:22:47.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:47.884]                 }
[10:22:47.884]                 NAMES <- toupper(added)
[10:22:47.884]                 for (kk in seq_along(NAMES)) {
[10:22:47.884]                   name <- added[[kk]]
[10:22:47.884]                   NAME <- NAMES[[kk]]
[10:22:47.884]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.884]                     next
[10:22:47.884]                   args[[name]] <- ""
[10:22:47.884]                 }
[10:22:47.884]                 NAMES <- toupper(removed)
[10:22:47.884]                 for (kk in seq_along(NAMES)) {
[10:22:47.884]                   name <- removed[[kk]]
[10:22:47.884]                   NAME <- NAMES[[kk]]
[10:22:47.884]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.884]                     next
[10:22:47.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:47.884]                 }
[10:22:47.884]                 if (length(args) > 0) 
[10:22:47.884]                   base::do.call(base::Sys.setenv, args = args)
[10:22:47.884]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:47.884]             }
[10:22:47.884]             else {
[10:22:47.884]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:47.884]             }
[10:22:47.884]             {
[10:22:47.884]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:47.884]                   0L) {
[10:22:47.884]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:47.884]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:47.884]                   base::options(opts)
[10:22:47.884]                 }
[10:22:47.884]                 {
[10:22:47.884]                   {
[10:22:47.884]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:47.884]                     NULL
[10:22:47.884]                   }
[10:22:47.884]                   options(future.plan = NULL)
[10:22:47.884]                   if (is.na(NA_character_)) 
[10:22:47.884]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:47.884]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:47.884]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:47.884]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:47.884]                     envir = parent.frame()) 
[10:22:47.884]                   {
[10:22:47.884]                     if (is.function(workers)) 
[10:22:47.884]                       workers <- workers()
[10:22:47.884]                     workers <- structure(as.integer(workers), 
[10:22:47.884]                       class = class(workers))
[10:22:47.884]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:47.884]                       workers >= 1)
[10:22:47.884]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:47.884]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:47.884]                     }
[10:22:47.884]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:47.884]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:47.884]                       envir = envir)
[10:22:47.884]                     if (!future$lazy) 
[10:22:47.884]                       future <- run(future)
[10:22:47.884]                     invisible(future)
[10:22:47.884]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:47.884]                 }
[10:22:47.884]             }
[10:22:47.884]         }
[10:22:47.884]     })
[10:22:47.884]     if (TRUE) {
[10:22:47.884]         base::sink(type = "output", split = FALSE)
[10:22:47.884]         if (TRUE) {
[10:22:47.884]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:47.884]         }
[10:22:47.884]         else {
[10:22:47.884]             ...future.result["stdout"] <- base::list(NULL)
[10:22:47.884]         }
[10:22:47.884]         base::close(...future.stdout)
[10:22:47.884]         ...future.stdout <- NULL
[10:22:47.884]     }
[10:22:47.884]     ...future.result$conditions <- ...future.conditions
[10:22:47.884]     ...future.result$finished <- base::Sys.time()
[10:22:47.884]     ...future.result
[10:22:47.884] }
[10:22:47.887] Exporting 5 global objects (9.77 KiB) to cluster node #2 ...
[10:22:47.888] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:22:47.888] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:22:47.888] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #2 ...
[10:22:47.888] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #2 ... DONE
[10:22:47.889] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[10:22:47.889] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[10:22:47.889] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:22:47.889] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:22:47.889] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[10:22:47.890] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[10:22:47.890] Exporting 5 global objects (9.77 KiB) to cluster node #2 ... DONE
[10:22:47.890] MultisessionFuture started
[10:22:47.890] - Launch lazy future ... done
[10:22:47.891] run() for ‘MultisessionFuture’ ... done
[10:22:47.891] Created future:
[10:22:47.891] MultisessionFuture:
[10:22:47.891] Label: ‘future_apply-2’
[10:22:47.891] Expression:
[10:22:47.891] {
[10:22:47.891]     do.call(function(...) {
[10:22:47.891]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.891]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:47.891]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.891]             on.exit(options(oopts), add = TRUE)
[10:22:47.891]         }
[10:22:47.891]         {
[10:22:47.891]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:47.891]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.891]                 ...future.FUN(...future.X_jj, ...)
[10:22:47.891]             })
[10:22:47.891]         }
[10:22:47.891]     }, args = future.call.arguments)
[10:22:47.891] }
[10:22:47.891] Lazy evaluation: FALSE
[10:22:47.891] Asynchronous evaluation: TRUE
[10:22:47.891] Local evaluation: TRUE
[10:22:47.891] Environment: R_GlobalEnv
[10:22:47.891] Capture standard output: TRUE
[10:22:47.891] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:22:47.891] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:47.891] Packages: <none>
[10:22:47.891] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:22:47.891] Resolved: FALSE
[10:22:47.891] Value: <not collected>
[10:22:47.891] Conditions captured: <none>
[10:22:47.891] Early signaling: FALSE
[10:22:47.891] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:47.891] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:47.902] Chunk #2 of 2 ... DONE
[10:22:47.902] Launching 2 futures (chunks) ... DONE
[10:22:47.902] Resolving 2 futures (chunks) ...
[10:22:47.902] resolve() on list ...
[10:22:47.903]  recursive: 0
[10:22:47.903]  length: 2
[10:22:47.903] 
[10:22:47.903] receiveMessageFromWorker() for ClusterFuture ...
[10:22:47.903] - Validating connection of MultisessionFuture
[10:22:47.903] - received message: FutureResult
[10:22:47.904] - Received FutureResult
[10:22:47.904] - Erased future from FutureRegistry
[10:22:47.904] result() for ClusterFuture ...
[10:22:47.904] - result already collected: FutureResult
[10:22:47.904] result() for ClusterFuture ... done
[10:22:47.904] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:47.904] Future #1
[10:22:47.904] result() for ClusterFuture ...
[10:22:47.904] - result already collected: FutureResult
[10:22:47.904] result() for ClusterFuture ... done
[10:22:47.905] result() for ClusterFuture ...
[10:22:47.905] - result already collected: FutureResult
[10:22:47.905] result() for ClusterFuture ... done
[10:22:47.905] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:22:47.905] - nx: 2
[10:22:47.905] - relay: TRUE
[10:22:47.905] - stdout: TRUE
[10:22:47.905] - signal: TRUE
[10:22:47.905] - resignal: FALSE
[10:22:47.905] - force: TRUE
[10:22:47.905] - relayed: [n=2] FALSE, FALSE
[10:22:47.906] - queued futures: [n=2] FALSE, FALSE
[10:22:47.906]  - until=1
[10:22:47.906]  - relaying element #1
[10:22:47.906] result() for ClusterFuture ...
[10:22:47.906] - result already collected: FutureResult
[10:22:47.906] result() for ClusterFuture ... done
[10:22:47.906] result() for ClusterFuture ...
[10:22:47.906] - result already collected: FutureResult
[10:22:47.906] result() for ClusterFuture ... done
[10:22:47.906] result() for ClusterFuture ...
[10:22:47.906] - result already collected: FutureResult
[10:22:47.907] result() for ClusterFuture ... done
[10:22:47.907] result() for ClusterFuture ...
[10:22:47.907] - result already collected: FutureResult
[10:22:47.907] result() for ClusterFuture ... done
[10:22:47.907] - relayed: [n=2] TRUE, FALSE
[10:22:47.907] - queued futures: [n=2] TRUE, FALSE
[10:22:47.907] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:22:47.907]  length: 1 (resolved future 1)
[10:22:47.938] receiveMessageFromWorker() for ClusterFuture ...
[10:22:47.938] - Validating connection of MultisessionFuture
[10:22:47.938] - received message: FutureResult
[10:22:47.939] - Received FutureResult
[10:22:47.939] - Erased future from FutureRegistry
[10:22:47.939] result() for ClusterFuture ...
[10:22:47.939] - result already collected: FutureResult
[10:22:47.939] result() for ClusterFuture ... done
[10:22:47.939] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:47.939] Future #2
[10:22:47.939] result() for ClusterFuture ...
[10:22:47.939] - result already collected: FutureResult
[10:22:47.939] result() for ClusterFuture ... done
[10:22:47.939] result() for ClusterFuture ...
[10:22:47.940] - result already collected: FutureResult
[10:22:47.940] result() for ClusterFuture ... done
[10:22:47.940] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:22:47.940] - nx: 2
[10:22:47.940] - relay: TRUE
[10:22:47.940] - stdout: TRUE
[10:22:47.940] - signal: TRUE
[10:22:47.940] - resignal: FALSE
[10:22:47.940] - force: TRUE
[10:22:47.940] - relayed: [n=2] TRUE, FALSE
[10:22:47.940] - queued futures: [n=2] TRUE, FALSE
[10:22:47.941]  - until=2
[10:22:47.941]  - relaying element #2
[10:22:47.941] result() for ClusterFuture ...
[10:22:47.941] - result already collected: FutureResult
[10:22:47.941] result() for ClusterFuture ... done
[10:22:47.941] result() for ClusterFuture ...
[10:22:47.941] - result already collected: FutureResult
[10:22:47.941] result() for ClusterFuture ... done
[10:22:47.941] result() for ClusterFuture ...
[10:22:47.941] - result already collected: FutureResult
[10:22:47.941] result() for ClusterFuture ... done
[10:22:47.942] result() for ClusterFuture ...
[10:22:47.942] - result already collected: FutureResult
[10:22:47.942] result() for ClusterFuture ... done
[10:22:47.942] - relayed: [n=2] TRUE, TRUE
[10:22:47.942] - queued futures: [n=2] TRUE, TRUE
[10:22:47.942] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:22:47.942]  length: 0 (resolved future 2)
[10:22:47.942] Relaying remaining futures
[10:22:47.942] signalConditionsASAP(NULL, pos=0) ...
[10:22:47.942] - nx: 2
[10:22:47.942] - relay: TRUE
[10:22:47.943] - stdout: TRUE
[10:22:47.943] - signal: TRUE
[10:22:47.943] - resignal: FALSE
[10:22:47.943] - force: TRUE
[10:22:47.943] - relayed: [n=2] TRUE, TRUE
[10:22:47.943] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:22:47.943] - relayed: [n=2] TRUE, TRUE
[10:22:47.943] - queued futures: [n=2] TRUE, TRUE
[10:22:47.943] signalConditionsASAP(NULL, pos=0) ... done
[10:22:47.943] resolve() on list ... DONE
[10:22:47.944] result() for ClusterFuture ...
[10:22:47.944] - result already collected: FutureResult
[10:22:47.944] result() for ClusterFuture ... done
[10:22:47.944] result() for ClusterFuture ...
[10:22:47.944] - result already collected: FutureResult
[10:22:47.944] result() for ClusterFuture ... done
[10:22:47.944] result() for ClusterFuture ...
[10:22:47.944] - result already collected: FutureResult
[10:22:47.944] result() for ClusterFuture ... done
[10:22:47.944] result() for ClusterFuture ...
[10:22:47.944] - result already collected: FutureResult
[10:22:47.945] result() for ClusterFuture ... done
[10:22:47.945]  - Number of value chunks collected: 2
[10:22:47.945] Resolving 2 futures (chunks) ... DONE
[10:22:47.945] Reducing values from 2 chunks ...
[10:22:47.945]  - Number of values collected after concatenation: 2
[10:22:47.945]  - Number of values expected: 2
[10:22:47.945] Reducing values from 2 chunks ... DONE
[10:22:47.945] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[10:22:47.945] getGlobalsAndPackagesXApply() ...
[10:22:47.946]  - future.globals: TRUE
[10:22:47.946] getGlobalsAndPackages() ...
[10:22:47.946] Searching for globals...
[10:22:47.949] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[10:22:47.949] Searching for globals ... DONE
[10:22:47.949] Resolving globals: FALSE
[10:22:47.949] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[10:22:47.950] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[10:22:47.950] - globals: [1] ‘FUN’
[10:22:47.950] 
[10:22:47.950] getGlobalsAndPackages() ... DONE
[10:22:47.950]  - globals found/used: [n=1] ‘FUN’
[10:22:47.950]  - needed namespaces: [n=0] 
[10:22:47.950] Finding globals ... DONE
[10:22:47.950]  - use_args: TRUE
[10:22:47.951]  - Getting '...' globals ...
[10:22:47.951] resolve() on list ...
[10:22:47.951]  recursive: 0
[10:22:47.951]  length: 1
[10:22:47.951]  elements: ‘...’
[10:22:47.951]  length: 0 (resolved future 1)
[10:22:47.951] resolve() on list ... DONE
[10:22:47.951]    - '...' content: [n=0] 
[10:22:47.952] List of 1
[10:22:47.952]  $ ...: list()
[10:22:47.952]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:47.952]  - attr(*, "where")=List of 1
[10:22:47.952]   ..$ ...:<environment: 0x55ca4dcb00f0> 
[10:22:47.952]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:47.952]  - attr(*, "resolved")= logi TRUE
[10:22:47.952]  - attr(*, "total_size")= num NA
[10:22:47.954]  - Getting '...' globals ... DONE
[10:22:47.955] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:22:47.955] List of 2
[10:22:47.955]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[10:22:47.955]  $ ...          : list()
[10:22:47.955]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:47.955]  - attr(*, "where")=List of 2
[10:22:47.955]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:22:47.955]   ..$ ...          :<environment: 0x55ca4dcb00f0> 
[10:22:47.955]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:47.955]  - attr(*, "resolved")= logi FALSE
[10:22:47.955]  - attr(*, "total_size")= num 36296
[10:22:47.958] Packages to be attached in all futures: [n=0] 
[10:22:47.958] getGlobalsAndPackagesXApply() ... DONE
[10:22:47.962] future_lapply() ...
[10:22:47.965] Generating random seeds ...
[10:22:47.965] Generating random seed streams for 2 elements ...
[10:22:47.965] Generating random seed streams for 2 elements ... DONE
[10:22:47.965] Generating random seeds ... DONE
[10:22:47.966] Will set RNG state on exit: 10407, -1740443544, 1714611839, -2033231636, -421214229, -1257848103, -514386634
[10:22:47.970] Number of chunks: 2
[10:22:47.970] getGlobalsAndPackagesXApply() ...
[10:22:47.970]  - future.globals: <name-value list> with names ‘list()’
[10:22:47.970]  - use_args: TRUE
[10:22:47.970] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:22:47.970] List of 2
[10:22:47.970]  $ ...          : list()
[10:22:47.970]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:22:47.970]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[10:22:47.970]  - attr(*, "where")=List of 2
[10:22:47.970]   ..$ ...          :<environment: 0x55ca4dcb00f0> 
[10:22:47.970]   ..$ ...future.FUN:<environment: namespace:base> 
[10:22:47.970]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:47.970]  - attr(*, "resolved")= logi FALSE
[10:22:47.970]  - attr(*, "total_size")= num NA
[10:22:47.975] Packages to be attached in all futures: [n=0] 
[10:22:47.975] getGlobalsAndPackagesXApply() ... DONE
[10:22:47.975] Number of futures (= number of chunks): 2
[10:22:47.975] Launching 2 futures (chunks) ...
[10:22:47.975] Chunk #1 of 2 ...
[10:22:47.975]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:47.976]  - seeds: [1] <seeds>
[10:22:47.976]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.976] getGlobalsAndPackages() ...
[10:22:47.976] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.976] Resolving globals: FALSE
[10:22:47.976] Tweak future expression to call with '...' arguments ...
[10:22:47.976] {
[10:22:47.976]     do.call(function(...) {
[10:22:47.976]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.976]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:47.976]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.976]             on.exit(options(oopts), add = TRUE)
[10:22:47.976]         }
[10:22:47.976]         {
[10:22:47.976]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:47.976]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.976]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:22:47.976]                   envir = globalenv(), inherits = FALSE)
[10:22:47.976]                 ...future.FUN(...future.X_jj, ...)
[10:22:47.976]             })
[10:22:47.976]         }
[10:22:47.976]     }, args = future.call.arguments)
[10:22:47.976] }
[10:22:47.977] Tweak future expression to call with '...' arguments ... DONE
[10:22:47.977] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:47.977] 
[10:22:47.977] getGlobalsAndPackages() ... DONE
[10:22:47.978] run() for ‘Future’ ...
[10:22:47.978] - state: ‘created’
[10:22:47.978] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:47.994] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:47.994] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:47.994]   - Field: ‘node’
[10:22:47.994]   - Field: ‘label’
[10:22:47.994]   - Field: ‘local’
[10:22:47.994]   - Field: ‘owner’
[10:22:47.994]   - Field: ‘envir’
[10:22:47.995]   - Field: ‘workers’
[10:22:47.995]   - Field: ‘packages’
[10:22:47.995]   - Field: ‘gc’
[10:22:47.995]   - Field: ‘conditions’
[10:22:47.995]   - Field: ‘persistent’
[10:22:47.995]   - Field: ‘expr’
[10:22:47.995]   - Field: ‘uuid’
[10:22:47.995]   - Field: ‘seed’
[10:22:47.995]   - Field: ‘version’
[10:22:47.995]   - Field: ‘result’
[10:22:47.995]   - Field: ‘asynchronous’
[10:22:47.996]   - Field: ‘calls’
[10:22:47.996]   - Field: ‘globals’
[10:22:47.996]   - Field: ‘stdout’
[10:22:47.996]   - Field: ‘earlySignal’
[10:22:47.996]   - Field: ‘lazy’
[10:22:47.996]   - Field: ‘state’
[10:22:47.996] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:47.996] - Launch lazy future ...
[10:22:47.996] Packages needed by the future expression (n = 0): <none>
[10:22:47.997] Packages needed by future strategies (n = 0): <none>
[10:22:47.997] {
[10:22:47.997]     {
[10:22:47.997]         {
[10:22:47.997]             ...future.startTime <- base::Sys.time()
[10:22:47.997]             {
[10:22:47.997]                 {
[10:22:47.997]                   {
[10:22:47.997]                     {
[10:22:47.997]                       base::local({
[10:22:47.997]                         has_future <- base::requireNamespace("future", 
[10:22:47.997]                           quietly = TRUE)
[10:22:47.997]                         if (has_future) {
[10:22:47.997]                           ns <- base::getNamespace("future")
[10:22:47.997]                           version <- ns[[".package"]][["version"]]
[10:22:47.997]                           if (is.null(version)) 
[10:22:47.997]                             version <- utils::packageVersion("future")
[10:22:47.997]                         }
[10:22:47.997]                         else {
[10:22:47.997]                           version <- NULL
[10:22:47.997]                         }
[10:22:47.997]                         if (!has_future || version < "1.8.0") {
[10:22:47.997]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:47.997]                             "", base::R.version$version.string), 
[10:22:47.997]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:47.997]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:47.997]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:47.997]                               "release", "version")], collapse = " "), 
[10:22:47.997]                             hostname = base::Sys.info()[["nodename"]])
[10:22:47.997]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:47.997]                             info)
[10:22:47.997]                           info <- base::paste(info, collapse = "; ")
[10:22:47.997]                           if (!has_future) {
[10:22:47.997]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:47.997]                               info)
[10:22:47.997]                           }
[10:22:47.997]                           else {
[10:22:47.997]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:47.997]                               info, version)
[10:22:47.997]                           }
[10:22:47.997]                           base::stop(msg)
[10:22:47.997]                         }
[10:22:47.997]                       })
[10:22:47.997]                     }
[10:22:47.997]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:47.997]                     base::options(mc.cores = 1L)
[10:22:47.997]                   }
[10:22:47.997]                   options(future.plan = NULL)
[10:22:47.997]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:47.997]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:47.997]                 }
[10:22:47.997]                 ...future.workdir <- getwd()
[10:22:47.997]             }
[10:22:47.997]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:47.997]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:47.997]         }
[10:22:47.997]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:47.997]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:47.997]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:47.997]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:47.997]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:47.997]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:47.997]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:47.997]             base::names(...future.oldOptions))
[10:22:47.997]     }
[10:22:47.997]     if (FALSE) {
[10:22:47.997]     }
[10:22:47.997]     else {
[10:22:47.997]         if (TRUE) {
[10:22:47.997]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:47.997]                 open = "w")
[10:22:47.997]         }
[10:22:47.997]         else {
[10:22:47.997]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:47.997]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:47.997]         }
[10:22:47.997]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:47.997]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:47.997]             base::sink(type = "output", split = FALSE)
[10:22:47.997]             base::close(...future.stdout)
[10:22:47.997]         }, add = TRUE)
[10:22:47.997]     }
[10:22:47.997]     ...future.frame <- base::sys.nframe()
[10:22:47.997]     ...future.conditions <- base::list()
[10:22:47.997]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:47.997]     if (FALSE) {
[10:22:47.997]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:47.997]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:47.997]     }
[10:22:47.997]     ...future.result <- base::tryCatch({
[10:22:47.997]         base::withCallingHandlers({
[10:22:47.997]             ...future.value <- base::withVisible(base::local({
[10:22:47.997]                 ...future.makeSendCondition <- base::local({
[10:22:47.997]                   sendCondition <- NULL
[10:22:47.997]                   function(frame = 1L) {
[10:22:47.997]                     if (is.function(sendCondition)) 
[10:22:47.997]                       return(sendCondition)
[10:22:47.997]                     ns <- getNamespace("parallel")
[10:22:47.997]                     if (exists("sendData", mode = "function", 
[10:22:47.997]                       envir = ns)) {
[10:22:47.997]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:47.997]                         envir = ns)
[10:22:47.997]                       envir <- sys.frame(frame)
[10:22:47.997]                       master <- NULL
[10:22:47.997]                       while (!identical(envir, .GlobalEnv) && 
[10:22:47.997]                         !identical(envir, emptyenv())) {
[10:22:47.997]                         if (exists("master", mode = "list", envir = envir, 
[10:22:47.997]                           inherits = FALSE)) {
[10:22:47.997]                           master <- get("master", mode = "list", 
[10:22:47.997]                             envir = envir, inherits = FALSE)
[10:22:47.997]                           if (inherits(master, c("SOCKnode", 
[10:22:47.997]                             "SOCK0node"))) {
[10:22:47.997]                             sendCondition <<- function(cond) {
[10:22:47.997]                               data <- list(type = "VALUE", value = cond, 
[10:22:47.997]                                 success = TRUE)
[10:22:47.997]                               parallel_sendData(master, data)
[10:22:47.997]                             }
[10:22:47.997]                             return(sendCondition)
[10:22:47.997]                           }
[10:22:47.997]                         }
[10:22:47.997]                         frame <- frame + 1L
[10:22:47.997]                         envir <- sys.frame(frame)
[10:22:47.997]                       }
[10:22:47.997]                     }
[10:22:47.997]                     sendCondition <<- function(cond) NULL
[10:22:47.997]                   }
[10:22:47.997]                 })
[10:22:47.997]                 withCallingHandlers({
[10:22:47.997]                   {
[10:22:47.997]                     do.call(function(...) {
[10:22:47.997]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:47.997]                       if (!identical(...future.globals.maxSize.org, 
[10:22:47.997]                         ...future.globals.maxSize)) {
[10:22:47.997]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:47.997]                         on.exit(options(oopts), add = TRUE)
[10:22:47.997]                       }
[10:22:47.997]                       {
[10:22:47.997]                         lapply(seq_along(...future.elements_ii), 
[10:22:47.997]                           FUN = function(jj) {
[10:22:47.997]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:47.997]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:22:47.997]                               envir = globalenv(), inherits = FALSE)
[10:22:47.997]                             ...future.FUN(...future.X_jj, ...)
[10:22:47.997]                           })
[10:22:47.997]                       }
[10:22:47.997]                     }, args = future.call.arguments)
[10:22:47.997]                   }
[10:22:47.997]                 }, immediateCondition = function(cond) {
[10:22:47.997]                   sendCondition <- ...future.makeSendCondition()
[10:22:47.997]                   sendCondition(cond)
[10:22:47.997]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.997]                   {
[10:22:47.997]                     inherits <- base::inherits
[10:22:47.997]                     invokeRestart <- base::invokeRestart
[10:22:47.997]                     is.null <- base::is.null
[10:22:47.997]                     muffled <- FALSE
[10:22:47.997]                     if (inherits(cond, "message")) {
[10:22:47.997]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:47.997]                       if (muffled) 
[10:22:47.997]                         invokeRestart("muffleMessage")
[10:22:47.997]                     }
[10:22:47.997]                     else if (inherits(cond, "warning")) {
[10:22:47.997]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:47.997]                       if (muffled) 
[10:22:47.997]                         invokeRestart("muffleWarning")
[10:22:47.997]                     }
[10:22:47.997]                     else if (inherits(cond, "condition")) {
[10:22:47.997]                       if (!is.null(pattern)) {
[10:22:47.997]                         computeRestarts <- base::computeRestarts
[10:22:47.997]                         grepl <- base::grepl
[10:22:47.997]                         restarts <- computeRestarts(cond)
[10:22:47.997]                         for (restart in restarts) {
[10:22:47.997]                           name <- restart$name
[10:22:47.997]                           if (is.null(name)) 
[10:22:47.997]                             next
[10:22:47.997]                           if (!grepl(pattern, name)) 
[10:22:47.997]                             next
[10:22:47.997]                           invokeRestart(restart)
[10:22:47.997]                           muffled <- TRUE
[10:22:47.997]                           break
[10:22:47.997]                         }
[10:22:47.997]                       }
[10:22:47.997]                     }
[10:22:47.997]                     invisible(muffled)
[10:22:47.997]                   }
[10:22:47.997]                   muffleCondition(cond)
[10:22:47.997]                 })
[10:22:47.997]             }))
[10:22:47.997]             future::FutureResult(value = ...future.value$value, 
[10:22:47.997]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:47.997]                   ...future.rng), globalenv = if (FALSE) 
[10:22:47.997]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:47.997]                     ...future.globalenv.names))
[10:22:47.997]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:47.997]         }, condition = base::local({
[10:22:47.997]             c <- base::c
[10:22:47.997]             inherits <- base::inherits
[10:22:47.997]             invokeRestart <- base::invokeRestart
[10:22:47.997]             length <- base::length
[10:22:47.997]             list <- base::list
[10:22:47.997]             seq.int <- base::seq.int
[10:22:47.997]             signalCondition <- base::signalCondition
[10:22:47.997]             sys.calls <- base::sys.calls
[10:22:47.997]             `[[` <- base::`[[`
[10:22:47.997]             `+` <- base::`+`
[10:22:47.997]             `<<-` <- base::`<<-`
[10:22:47.997]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:47.997]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:47.997]                   3L)]
[10:22:47.997]             }
[10:22:47.997]             function(cond) {
[10:22:47.997]                 is_error <- inherits(cond, "error")
[10:22:47.997]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:47.997]                   NULL)
[10:22:47.997]                 if (is_error) {
[10:22:47.997]                   sessionInformation <- function() {
[10:22:47.997]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:47.997]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:47.997]                       search = base::search(), system = base::Sys.info())
[10:22:47.997]                   }
[10:22:47.997]                   ...future.conditions[[length(...future.conditions) + 
[10:22:47.997]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:47.997]                     cond$call), session = sessionInformation(), 
[10:22:47.997]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:47.997]                   signalCondition(cond)
[10:22:47.997]                 }
[10:22:47.997]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[10:22:47.997]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:47.997]                   ...future.conditions[[length(...future.conditions) + 
[10:22:47.997]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:47.997]                   if (TRUE && !signal) {
[10:22:47.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.997]                     {
[10:22:47.997]                       inherits <- base::inherits
[10:22:47.997]                       invokeRestart <- base::invokeRestart
[10:22:47.997]                       is.null <- base::is.null
[10:22:47.997]                       muffled <- FALSE
[10:22:47.997]                       if (inherits(cond, "message")) {
[10:22:47.997]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:47.997]                         if (muffled) 
[10:22:47.997]                           invokeRestart("muffleMessage")
[10:22:47.997]                       }
[10:22:47.997]                       else if (inherits(cond, "warning")) {
[10:22:47.997]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:47.997]                         if (muffled) 
[10:22:47.997]                           invokeRestart("muffleWarning")
[10:22:47.997]                       }
[10:22:47.997]                       else if (inherits(cond, "condition")) {
[10:22:47.997]                         if (!is.null(pattern)) {
[10:22:47.997]                           computeRestarts <- base::computeRestarts
[10:22:47.997]                           grepl <- base::grepl
[10:22:47.997]                           restarts <- computeRestarts(cond)
[10:22:47.997]                           for (restart in restarts) {
[10:22:47.997]                             name <- restart$name
[10:22:47.997]                             if (is.null(name)) 
[10:22:47.997]                               next
[10:22:47.997]                             if (!grepl(pattern, name)) 
[10:22:47.997]                               next
[10:22:47.997]                             invokeRestart(restart)
[10:22:47.997]                             muffled <- TRUE
[10:22:47.997]                             break
[10:22:47.997]                           }
[10:22:47.997]                         }
[10:22:47.997]                       }
[10:22:47.997]                       invisible(muffled)
[10:22:47.997]                     }
[10:22:47.997]                     muffleCondition(cond, pattern = "^muffle")
[10:22:47.997]                   }
[10:22:47.997]                 }
[10:22:47.997]                 else {
[10:22:47.997]                   if (TRUE) {
[10:22:47.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.997]                     {
[10:22:47.997]                       inherits <- base::inherits
[10:22:47.997]                       invokeRestart <- base::invokeRestart
[10:22:47.997]                       is.null <- base::is.null
[10:22:47.997]                       muffled <- FALSE
[10:22:47.997]                       if (inherits(cond, "message")) {
[10:22:47.997]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:47.997]                         if (muffled) 
[10:22:47.997]                           invokeRestart("muffleMessage")
[10:22:47.997]                       }
[10:22:47.997]                       else if (inherits(cond, "warning")) {
[10:22:47.997]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:47.997]                         if (muffled) 
[10:22:47.997]                           invokeRestart("muffleWarning")
[10:22:47.997]                       }
[10:22:47.997]                       else if (inherits(cond, "condition")) {
[10:22:47.997]                         if (!is.null(pattern)) {
[10:22:47.997]                           computeRestarts <- base::computeRestarts
[10:22:47.997]                           grepl <- base::grepl
[10:22:47.997]                           restarts <- computeRestarts(cond)
[10:22:47.997]                           for (restart in restarts) {
[10:22:47.997]                             name <- restart$name
[10:22:47.997]                             if (is.null(name)) 
[10:22:47.997]                               next
[10:22:47.997]                             if (!grepl(pattern, name)) 
[10:22:47.997]                               next
[10:22:47.997]                             invokeRestart(restart)
[10:22:47.997]                             muffled <- TRUE
[10:22:47.997]                             break
[10:22:47.997]                           }
[10:22:47.997]                         }
[10:22:47.997]                       }
[10:22:47.997]                       invisible(muffled)
[10:22:47.997]                     }
[10:22:47.997]                     muffleCondition(cond, pattern = "^muffle")
[10:22:47.997]                   }
[10:22:47.997]                 }
[10:22:47.997]             }
[10:22:47.997]         }))
[10:22:47.997]     }, error = function(ex) {
[10:22:47.997]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:47.997]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:47.997]                 ...future.rng), started = ...future.startTime, 
[10:22:47.997]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:47.997]             version = "1.8"), class = "FutureResult")
[10:22:47.997]     }, finally = {
[10:22:47.997]         if (!identical(...future.workdir, getwd())) 
[10:22:47.997]             setwd(...future.workdir)
[10:22:47.997]         {
[10:22:47.997]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:47.997]                 ...future.oldOptions$nwarnings <- NULL
[10:22:47.997]             }
[10:22:47.997]             base::options(...future.oldOptions)
[10:22:47.997]             if (.Platform$OS.type == "windows") {
[10:22:47.997]                 old_names <- names(...future.oldEnvVars)
[10:22:47.997]                 envs <- base::Sys.getenv()
[10:22:47.997]                 names <- names(envs)
[10:22:47.997]                 common <- intersect(names, old_names)
[10:22:47.997]                 added <- setdiff(names, old_names)
[10:22:47.997]                 removed <- setdiff(old_names, names)
[10:22:47.997]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:47.997]                   envs[common]]
[10:22:47.997]                 NAMES <- toupper(changed)
[10:22:47.997]                 args <- list()
[10:22:47.997]                 for (kk in seq_along(NAMES)) {
[10:22:47.997]                   name <- changed[[kk]]
[10:22:47.997]                   NAME <- NAMES[[kk]]
[10:22:47.997]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.997]                     next
[10:22:47.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:47.997]                 }
[10:22:47.997]                 NAMES <- toupper(added)
[10:22:47.997]                 for (kk in seq_along(NAMES)) {
[10:22:47.997]                   name <- added[[kk]]
[10:22:47.997]                   NAME <- NAMES[[kk]]
[10:22:47.997]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.997]                     next
[10:22:47.997]                   args[[name]] <- ""
[10:22:47.997]                 }
[10:22:47.997]                 NAMES <- toupper(removed)
[10:22:47.997]                 for (kk in seq_along(NAMES)) {
[10:22:47.997]                   name <- removed[[kk]]
[10:22:47.997]                   NAME <- NAMES[[kk]]
[10:22:47.997]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.997]                     next
[10:22:47.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:47.997]                 }
[10:22:47.997]                 if (length(args) > 0) 
[10:22:47.997]                   base::do.call(base::Sys.setenv, args = args)
[10:22:47.997]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:47.997]             }
[10:22:47.997]             else {
[10:22:47.997]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:47.997]             }
[10:22:47.997]             {
[10:22:47.997]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:47.997]                   0L) {
[10:22:47.997]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:47.997]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:47.997]                   base::options(opts)
[10:22:47.997]                 }
[10:22:47.997]                 {
[10:22:47.997]                   {
[10:22:47.997]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:47.997]                     NULL
[10:22:47.997]                   }
[10:22:47.997]                   options(future.plan = NULL)
[10:22:47.997]                   if (is.na(NA_character_)) 
[10:22:47.997]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:47.997]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:47.997]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:47.997]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:47.997]                     envir = parent.frame()) 
[10:22:47.997]                   {
[10:22:47.997]                     if (is.function(workers)) 
[10:22:47.997]                       workers <- workers()
[10:22:47.997]                     workers <- structure(as.integer(workers), 
[10:22:47.997]                       class = class(workers))
[10:22:47.997]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:47.997]                       workers >= 1)
[10:22:47.997]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:47.997]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:47.997]                     }
[10:22:47.997]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:47.997]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:47.997]                       envir = envir)
[10:22:47.997]                     if (!future$lazy) 
[10:22:47.997]                       future <- run(future)
[10:22:47.997]                     invisible(future)
[10:22:47.997]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:47.997]                 }
[10:22:47.997]             }
[10:22:47.997]         }
[10:22:47.997]     })
[10:22:47.997]     if (TRUE) {
[10:22:47.997]         base::sink(type = "output", split = FALSE)
[10:22:47.997]         if (TRUE) {
[10:22:47.997]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:47.997]         }
[10:22:47.997]         else {
[10:22:47.997]             ...future.result["stdout"] <- base::list(NULL)
[10:22:47.997]         }
[10:22:47.997]         base::close(...future.stdout)
[10:22:47.997]         ...future.stdout <- NULL
[10:22:47.997]     }
[10:22:47.997]     ...future.result$conditions <- ...future.conditions
[10:22:47.997]     ...future.result$finished <- base::Sys.time()
[10:22:47.997]     ...future.result
[10:22:47.997] }
[10:22:48.000] Exporting 5 global objects (35.63 KiB) to cluster node #1 ...
[10:22:48.000] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:22:48.000] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:22:48.001] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ...
[10:22:48.042] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ... DONE
[10:22:48.042] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[10:22:48.042] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[10:22:48.042] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[10:22:48.043] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[10:22:48.043] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[10:22:48.043] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[10:22:48.043] Exporting 5 global objects (35.63 KiB) to cluster node #1 ... DONE
[10:22:48.044] MultisessionFuture started
[10:22:48.044] - Launch lazy future ... done
[10:22:48.044] run() for ‘MultisessionFuture’ ... done
[10:22:48.044] Created future:
[10:22:48.044] MultisessionFuture:
[10:22:48.044] Label: ‘future_apply-1’
[10:22:48.044] Expression:
[10:22:48.044] {
[10:22:48.044]     do.call(function(...) {
[10:22:48.044]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:48.044]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:48.044]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:48.044]             on.exit(options(oopts), add = TRUE)
[10:22:48.044]         }
[10:22:48.044]         {
[10:22:48.044]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:48.044]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:48.044]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:22:48.044]                   envir = globalenv(), inherits = FALSE)
[10:22:48.044]                 ...future.FUN(...future.X_jj, ...)
[10:22:48.044]             })
[10:22:48.044]         }
[10:22:48.044]     }, args = future.call.arguments)
[10:22:48.044] }
[10:22:48.044] Lazy evaluation: FALSE
[10:22:48.044] Asynchronous evaluation: TRUE
[10:22:48.044] Local evaluation: TRUE
[10:22:48.044] Environment: R_GlobalEnv
[10:22:48.044] Capture standard output: TRUE
[10:22:48.044] Capture condition classes: <none>
[10:22:48.044] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:48.044] Packages: <none>
[10:22:48.044] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:22:48.044] Resolved: FALSE
[10:22:48.044] Value: <not collected>
[10:22:48.044] Conditions captured: <none>
[10:22:48.044] Early signaling: FALSE
[10:22:48.044] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:48.044] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:48.056] Chunk #1 of 2 ... DONE
[10:22:48.056] Chunk #2 of 2 ...
[10:22:48.056]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:22:48.056]  - seeds: [1] <seeds>
[10:22:48.056]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:48.057] getGlobalsAndPackages() ...
[10:22:48.057] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:48.057] Resolving globals: FALSE
[10:22:48.057] Tweak future expression to call with '...' arguments ...
[10:22:48.057] {
[10:22:48.057]     do.call(function(...) {
[10:22:48.057]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:48.057]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:48.057]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:48.057]             on.exit(options(oopts), add = TRUE)
[10:22:48.057]         }
[10:22:48.057]         {
[10:22:48.057]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:48.057]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:48.057]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:22:48.057]                   envir = globalenv(), inherits = FALSE)
[10:22:48.057]                 ...future.FUN(...future.X_jj, ...)
[10:22:48.057]             })
[10:22:48.057]         }
[10:22:48.057]     }, args = future.call.arguments)
[10:22:48.057] }
[10:22:48.057] Tweak future expression to call with '...' arguments ... DONE
[10:22:48.058] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:22:48.058] 
[10:22:48.058] getGlobalsAndPackages() ... DONE
[10:22:48.058] run() for ‘Future’ ...
[10:22:48.058] - state: ‘created’
[10:22:48.058] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:48.072] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:48.072] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:48.072]   - Field: ‘node’
[10:22:48.072]   - Field: ‘label’
[10:22:48.073]   - Field: ‘local’
[10:22:48.073]   - Field: ‘owner’
[10:22:48.073]   - Field: ‘envir’
[10:22:48.073]   - Field: ‘workers’
[10:22:48.073]   - Field: ‘packages’
[10:22:48.073]   - Field: ‘gc’
[10:22:48.073]   - Field: ‘conditions’
[10:22:48.073]   - Field: ‘persistent’
[10:22:48.073]   - Field: ‘expr’
[10:22:48.073]   - Field: ‘uuid’
[10:22:48.074]   - Field: ‘seed’
[10:22:48.074]   - Field: ‘version’
[10:22:48.074]   - Field: ‘result’
[10:22:48.074]   - Field: ‘asynchronous’
[10:22:48.074]   - Field: ‘calls’
[10:22:48.074]   - Field: ‘globals’
[10:22:48.074]   - Field: ‘stdout’
[10:22:48.074]   - Field: ‘earlySignal’
[10:22:48.074]   - Field: ‘lazy’
[10:22:48.074]   - Field: ‘state’
[10:22:48.074] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:48.075] - Launch lazy future ...
[10:22:48.075] Packages needed by the future expression (n = 0): <none>
[10:22:48.075] Packages needed by future strategies (n = 0): <none>
[10:22:48.075] {
[10:22:48.075]     {
[10:22:48.075]         {
[10:22:48.075]             ...future.startTime <- base::Sys.time()
[10:22:48.075]             {
[10:22:48.075]                 {
[10:22:48.075]                   {
[10:22:48.075]                     {
[10:22:48.075]                       base::local({
[10:22:48.075]                         has_future <- base::requireNamespace("future", 
[10:22:48.075]                           quietly = TRUE)
[10:22:48.075]                         if (has_future) {
[10:22:48.075]                           ns <- base::getNamespace("future")
[10:22:48.075]                           version <- ns[[".package"]][["version"]]
[10:22:48.075]                           if (is.null(version)) 
[10:22:48.075]                             version <- utils::packageVersion("future")
[10:22:48.075]                         }
[10:22:48.075]                         else {
[10:22:48.075]                           version <- NULL
[10:22:48.075]                         }
[10:22:48.075]                         if (!has_future || version < "1.8.0") {
[10:22:48.075]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:48.075]                             "", base::R.version$version.string), 
[10:22:48.075]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:48.075]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:48.075]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:48.075]                               "release", "version")], collapse = " "), 
[10:22:48.075]                             hostname = base::Sys.info()[["nodename"]])
[10:22:48.075]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:48.075]                             info)
[10:22:48.075]                           info <- base::paste(info, collapse = "; ")
[10:22:48.075]                           if (!has_future) {
[10:22:48.075]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:48.075]                               info)
[10:22:48.075]                           }
[10:22:48.075]                           else {
[10:22:48.075]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:48.075]                               info, version)
[10:22:48.075]                           }
[10:22:48.075]                           base::stop(msg)
[10:22:48.075]                         }
[10:22:48.075]                       })
[10:22:48.075]                     }
[10:22:48.075]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:48.075]                     base::options(mc.cores = 1L)
[10:22:48.075]                   }
[10:22:48.075]                   options(future.plan = NULL)
[10:22:48.075]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.075]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:48.075]                 }
[10:22:48.075]                 ...future.workdir <- getwd()
[10:22:48.075]             }
[10:22:48.075]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:48.075]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:48.075]         }
[10:22:48.075]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:48.075]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:22:48.075]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:48.075]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:48.075]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:48.075]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:48.075]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:48.075]             base::names(...future.oldOptions))
[10:22:48.075]     }
[10:22:48.075]     if (FALSE) {
[10:22:48.075]     }
[10:22:48.075]     else {
[10:22:48.075]         if (TRUE) {
[10:22:48.075]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:48.075]                 open = "w")
[10:22:48.075]         }
[10:22:48.075]         else {
[10:22:48.075]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:48.075]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:48.075]         }
[10:22:48.075]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:48.075]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:48.075]             base::sink(type = "output", split = FALSE)
[10:22:48.075]             base::close(...future.stdout)
[10:22:48.075]         }, add = TRUE)
[10:22:48.075]     }
[10:22:48.075]     ...future.frame <- base::sys.nframe()
[10:22:48.075]     ...future.conditions <- base::list()
[10:22:48.075]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:48.075]     if (FALSE) {
[10:22:48.075]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:48.075]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:48.075]     }
[10:22:48.075]     ...future.result <- base::tryCatch({
[10:22:48.075]         base::withCallingHandlers({
[10:22:48.075]             ...future.value <- base::withVisible(base::local({
[10:22:48.075]                 ...future.makeSendCondition <- base::local({
[10:22:48.075]                   sendCondition <- NULL
[10:22:48.075]                   function(frame = 1L) {
[10:22:48.075]                     if (is.function(sendCondition)) 
[10:22:48.075]                       return(sendCondition)
[10:22:48.075]                     ns <- getNamespace("parallel")
[10:22:48.075]                     if (exists("sendData", mode = "function", 
[10:22:48.075]                       envir = ns)) {
[10:22:48.075]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:48.075]                         envir = ns)
[10:22:48.075]                       envir <- sys.frame(frame)
[10:22:48.075]                       master <- NULL
[10:22:48.075]                       while (!identical(envir, .GlobalEnv) && 
[10:22:48.075]                         !identical(envir, emptyenv())) {
[10:22:48.075]                         if (exists("master", mode = "list", envir = envir, 
[10:22:48.075]                           inherits = FALSE)) {
[10:22:48.075]                           master <- get("master", mode = "list", 
[10:22:48.075]                             envir = envir, inherits = FALSE)
[10:22:48.075]                           if (inherits(master, c("SOCKnode", 
[10:22:48.075]                             "SOCK0node"))) {
[10:22:48.075]                             sendCondition <<- function(cond) {
[10:22:48.075]                               data <- list(type = "VALUE", value = cond, 
[10:22:48.075]                                 success = TRUE)
[10:22:48.075]                               parallel_sendData(master, data)
[10:22:48.075]                             }
[10:22:48.075]                             return(sendCondition)
[10:22:48.075]                           }
[10:22:48.075]                         }
[10:22:48.075]                         frame <- frame + 1L
[10:22:48.075]                         envir <- sys.frame(frame)
[10:22:48.075]                       }
[10:22:48.075]                     }
[10:22:48.075]                     sendCondition <<- function(cond) NULL
[10:22:48.075]                   }
[10:22:48.075]                 })
[10:22:48.075]                 withCallingHandlers({
[10:22:48.075]                   {
[10:22:48.075]                     do.call(function(...) {
[10:22:48.075]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:48.075]                       if (!identical(...future.globals.maxSize.org, 
[10:22:48.075]                         ...future.globals.maxSize)) {
[10:22:48.075]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:48.075]                         on.exit(options(oopts), add = TRUE)
[10:22:48.075]                       }
[10:22:48.075]                       {
[10:22:48.075]                         lapply(seq_along(...future.elements_ii), 
[10:22:48.075]                           FUN = function(jj) {
[10:22:48.075]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:48.075]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:22:48.075]                               envir = globalenv(), inherits = FALSE)
[10:22:48.075]                             ...future.FUN(...future.X_jj, ...)
[10:22:48.075]                           })
[10:22:48.075]                       }
[10:22:48.075]                     }, args = future.call.arguments)
[10:22:48.075]                   }
[10:22:48.075]                 }, immediateCondition = function(cond) {
[10:22:48.075]                   sendCondition <- ...future.makeSendCondition()
[10:22:48.075]                   sendCondition(cond)
[10:22:48.075]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.075]                   {
[10:22:48.075]                     inherits <- base::inherits
[10:22:48.075]                     invokeRestart <- base::invokeRestart
[10:22:48.075]                     is.null <- base::is.null
[10:22:48.075]                     muffled <- FALSE
[10:22:48.075]                     if (inherits(cond, "message")) {
[10:22:48.075]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:48.075]                       if (muffled) 
[10:22:48.075]                         invokeRestart("muffleMessage")
[10:22:48.075]                     }
[10:22:48.075]                     else if (inherits(cond, "warning")) {
[10:22:48.075]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:48.075]                       if (muffled) 
[10:22:48.075]                         invokeRestart("muffleWarning")
[10:22:48.075]                     }
[10:22:48.075]                     else if (inherits(cond, "condition")) {
[10:22:48.075]                       if (!is.null(pattern)) {
[10:22:48.075]                         computeRestarts <- base::computeRestarts
[10:22:48.075]                         grepl <- base::grepl
[10:22:48.075]                         restarts <- computeRestarts(cond)
[10:22:48.075]                         for (restart in restarts) {
[10:22:48.075]                           name <- restart$name
[10:22:48.075]                           if (is.null(name)) 
[10:22:48.075]                             next
[10:22:48.075]                           if (!grepl(pattern, name)) 
[10:22:48.075]                             next
[10:22:48.075]                           invokeRestart(restart)
[10:22:48.075]                           muffled <- TRUE
[10:22:48.075]                           break
[10:22:48.075]                         }
[10:22:48.075]                       }
[10:22:48.075]                     }
[10:22:48.075]                     invisible(muffled)
[10:22:48.075]                   }
[10:22:48.075]                   muffleCondition(cond)
[10:22:48.075]                 })
[10:22:48.075]             }))
[10:22:48.075]             future::FutureResult(value = ...future.value$value, 
[10:22:48.075]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.075]                   ...future.rng), globalenv = if (FALSE) 
[10:22:48.075]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:48.075]                     ...future.globalenv.names))
[10:22:48.075]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:48.075]         }, condition = base::local({
[10:22:48.075]             c <- base::c
[10:22:48.075]             inherits <- base::inherits
[10:22:48.075]             invokeRestart <- base::invokeRestart
[10:22:48.075]             length <- base::length
[10:22:48.075]             list <- base::list
[10:22:48.075]             seq.int <- base::seq.int
[10:22:48.075]             signalCondition <- base::signalCondition
[10:22:48.075]             sys.calls <- base::sys.calls
[10:22:48.075]             `[[` <- base::`[[`
[10:22:48.075]             `+` <- base::`+`
[10:22:48.075]             `<<-` <- base::`<<-`
[10:22:48.075]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:48.075]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:48.075]                   3L)]
[10:22:48.075]             }
[10:22:48.075]             function(cond) {
[10:22:48.075]                 is_error <- inherits(cond, "error")
[10:22:48.075]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:48.075]                   NULL)
[10:22:48.075]                 if (is_error) {
[10:22:48.075]                   sessionInformation <- function() {
[10:22:48.075]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:48.075]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:48.075]                       search = base::search(), system = base::Sys.info())
[10:22:48.075]                   }
[10:22:48.075]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.075]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:48.075]                     cond$call), session = sessionInformation(), 
[10:22:48.075]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:48.075]                   signalCondition(cond)
[10:22:48.075]                 }
[10:22:48.075]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[10:22:48.075]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:48.075]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.075]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:48.075]                   if (TRUE && !signal) {
[10:22:48.075]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.075]                     {
[10:22:48.075]                       inherits <- base::inherits
[10:22:48.075]                       invokeRestart <- base::invokeRestart
[10:22:48.075]                       is.null <- base::is.null
[10:22:48.075]                       muffled <- FALSE
[10:22:48.075]                       if (inherits(cond, "message")) {
[10:22:48.075]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.075]                         if (muffled) 
[10:22:48.075]                           invokeRestart("muffleMessage")
[10:22:48.075]                       }
[10:22:48.075]                       else if (inherits(cond, "warning")) {
[10:22:48.075]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.075]                         if (muffled) 
[10:22:48.075]                           invokeRestart("muffleWarning")
[10:22:48.075]                       }
[10:22:48.075]                       else if (inherits(cond, "condition")) {
[10:22:48.075]                         if (!is.null(pattern)) {
[10:22:48.075]                           computeRestarts <- base::computeRestarts
[10:22:48.075]                           grepl <- base::grepl
[10:22:48.075]                           restarts <- computeRestarts(cond)
[10:22:48.075]                           for (restart in restarts) {
[10:22:48.075]                             name <- restart$name
[10:22:48.075]                             if (is.null(name)) 
[10:22:48.075]                               next
[10:22:48.075]                             if (!grepl(pattern, name)) 
[10:22:48.075]                               next
[10:22:48.075]                             invokeRestart(restart)
[10:22:48.075]                             muffled <- TRUE
[10:22:48.075]                             break
[10:22:48.075]                           }
[10:22:48.075]                         }
[10:22:48.075]                       }
[10:22:48.075]                       invisible(muffled)
[10:22:48.075]                     }
[10:22:48.075]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.075]                   }
[10:22:48.075]                 }
[10:22:48.075]                 else {
[10:22:48.075]                   if (TRUE) {
[10:22:48.075]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.075]                     {
[10:22:48.075]                       inherits <- base::inherits
[10:22:48.075]                       invokeRestart <- base::invokeRestart
[10:22:48.075]                       is.null <- base::is.null
[10:22:48.075]                       muffled <- FALSE
[10:22:48.075]                       if (inherits(cond, "message")) {
[10:22:48.075]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.075]                         if (muffled) 
[10:22:48.075]                           invokeRestart("muffleMessage")
[10:22:48.075]                       }
[10:22:48.075]                       else if (inherits(cond, "warning")) {
[10:22:48.075]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.075]                         if (muffled) 
[10:22:48.075]                           invokeRestart("muffleWarning")
[10:22:48.075]                       }
[10:22:48.075]                       else if (inherits(cond, "condition")) {
[10:22:48.075]                         if (!is.null(pattern)) {
[10:22:48.075]                           computeRestarts <- base::computeRestarts
[10:22:48.075]                           grepl <- base::grepl
[10:22:48.075]                           restarts <- computeRestarts(cond)
[10:22:48.075]                           for (restart in restarts) {
[10:22:48.075]                             name <- restart$name
[10:22:48.075]                             if (is.null(name)) 
[10:22:48.075]                               next
[10:22:48.075]                             if (!grepl(pattern, name)) 
[10:22:48.075]                               next
[10:22:48.075]                             invokeRestart(restart)
[10:22:48.075]                             muffled <- TRUE
[10:22:48.075]                             break
[10:22:48.075]                           }
[10:22:48.075]                         }
[10:22:48.075]                       }
[10:22:48.075]                       invisible(muffled)
[10:22:48.075]                     }
[10:22:48.075]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.075]                   }
[10:22:48.075]                 }
[10:22:48.075]             }
[10:22:48.075]         }))
[10:22:48.075]     }, error = function(ex) {
[10:22:48.075]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:48.075]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.075]                 ...future.rng), started = ...future.startTime, 
[10:22:48.075]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:48.075]             version = "1.8"), class = "FutureResult")
[10:22:48.075]     }, finally = {
[10:22:48.075]         if (!identical(...future.workdir, getwd())) 
[10:22:48.075]             setwd(...future.workdir)
[10:22:48.075]         {
[10:22:48.075]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:48.075]                 ...future.oldOptions$nwarnings <- NULL
[10:22:48.075]             }
[10:22:48.075]             base::options(...future.oldOptions)
[10:22:48.075]             if (.Platform$OS.type == "windows") {
[10:22:48.075]                 old_names <- names(...future.oldEnvVars)
[10:22:48.075]                 envs <- base::Sys.getenv()
[10:22:48.075]                 names <- names(envs)
[10:22:48.075]                 common <- intersect(names, old_names)
[10:22:48.075]                 added <- setdiff(names, old_names)
[10:22:48.075]                 removed <- setdiff(old_names, names)
[10:22:48.075]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:48.075]                   envs[common]]
[10:22:48.075]                 NAMES <- toupper(changed)
[10:22:48.075]                 args <- list()
[10:22:48.075]                 for (kk in seq_along(NAMES)) {
[10:22:48.075]                   name <- changed[[kk]]
[10:22:48.075]                   NAME <- NAMES[[kk]]
[10:22:48.075]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.075]                     next
[10:22:48.075]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.075]                 }
[10:22:48.075]                 NAMES <- toupper(added)
[10:22:48.075]                 for (kk in seq_along(NAMES)) {
[10:22:48.075]                   name <- added[[kk]]
[10:22:48.075]                   NAME <- NAMES[[kk]]
[10:22:48.075]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.075]                     next
[10:22:48.075]                   args[[name]] <- ""
[10:22:48.075]                 }
[10:22:48.075]                 NAMES <- toupper(removed)
[10:22:48.075]                 for (kk in seq_along(NAMES)) {
[10:22:48.075]                   name <- removed[[kk]]
[10:22:48.075]                   NAME <- NAMES[[kk]]
[10:22:48.075]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.075]                     next
[10:22:48.075]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.075]                 }
[10:22:48.075]                 if (length(args) > 0) 
[10:22:48.075]                   base::do.call(base::Sys.setenv, args = args)
[10:22:48.075]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:48.075]             }
[10:22:48.075]             else {
[10:22:48.075]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:48.075]             }
[10:22:48.075]             {
[10:22:48.075]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:48.075]                   0L) {
[10:22:48.075]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:48.075]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:48.075]                   base::options(opts)
[10:22:48.075]                 }
[10:22:48.075]                 {
[10:22:48.075]                   {
[10:22:48.075]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:48.075]                     NULL
[10:22:48.075]                   }
[10:22:48.075]                   options(future.plan = NULL)
[10:22:48.075]                   if (is.na(NA_character_)) 
[10:22:48.075]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.075]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:48.075]                   future::plan(list(function (..., workers = availableCores(), 
[10:22:48.075]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:48.075]                     envir = parent.frame()) 
[10:22:48.075]                   {
[10:22:48.075]                     if (is.function(workers)) 
[10:22:48.075]                       workers <- workers()
[10:22:48.075]                     workers <- structure(as.integer(workers), 
[10:22:48.075]                       class = class(workers))
[10:22:48.075]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:48.075]                       workers >= 1)
[10:22:48.075]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:48.075]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:48.075]                     }
[10:22:48.075]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:48.075]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:48.075]                       envir = envir)
[10:22:48.075]                     if (!future$lazy) 
[10:22:48.075]                       future <- run(future)
[10:22:48.075]                     invisible(future)
[10:22:48.075]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:48.075]                 }
[10:22:48.075]             }
[10:22:48.075]         }
[10:22:48.075]     })
[10:22:48.075]     if (TRUE) {
[10:22:48.075]         base::sink(type = "output", split = FALSE)
[10:22:48.075]         if (TRUE) {
[10:22:48.075]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:48.075]         }
[10:22:48.075]         else {
[10:22:48.075]             ...future.result["stdout"] <- base::list(NULL)
[10:22:48.075]         }
[10:22:48.075]         base::close(...future.stdout)
[10:22:48.075]         ...future.stdout <- NULL
[10:22:48.075]     }
[10:22:48.075]     ...future.result$conditions <- ...future.conditions
[10:22:48.075]     ...future.result$finished <- base::Sys.time()
[10:22:48.075]     ...future.result
[10:22:48.075] }
[10:22:48.078] Exporting 5 global objects (35.63 KiB) to cluster node #2 ...
[10:22:48.079] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:22:48.079] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:22:48.079] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #2 ...
[10:22:48.122] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #2 ... DONE
[10:22:48.123] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[10:22:48.123] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[10:22:48.124] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[10:22:48.124] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[10:22:48.125] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[10:22:48.125] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[10:22:48.126] Exporting 5 global objects (35.63 KiB) to cluster node #2 ... DONE
[10:22:48.127] MultisessionFuture started
[10:22:48.127] - Launch lazy future ... done
[10:22:48.127] run() for ‘MultisessionFuture’ ... done
[10:22:48.127] Created future:
[10:22:48.128] MultisessionFuture:
[10:22:48.128] Label: ‘future_apply-2’
[10:22:48.128] Expression:
[10:22:48.128] {
[10:22:48.128]     do.call(function(...) {
[10:22:48.128]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:22:48.128]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:22:48.128]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:22:48.128]             on.exit(options(oopts), add = TRUE)
[10:22:48.128]         }
[10:22:48.128]         {
[10:22:48.128]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:22:48.128]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:22:48.128]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:22:48.128]                   envir = globalenv(), inherits = FALSE)
[10:22:48.128]                 ...future.FUN(...future.X_jj, ...)
[10:22:48.128]             })
[10:22:48.128]         }
[10:22:48.128]     }, args = future.call.arguments)
[10:22:48.128] }
[10:22:48.128] Lazy evaluation: FALSE
[10:22:48.128] Asynchronous evaluation: TRUE
[10:22:48.128] Local evaluation: TRUE
[10:22:48.128] Environment: R_GlobalEnv
[10:22:48.128] Capture standard output: TRUE
[10:22:48.128] Capture condition classes: <none>
[10:22:48.128] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[10:22:48.128] Packages: <none>
[10:22:48.128] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:22:48.128] Resolved: FALSE
[10:22:48.128] Value: <not collected>
[10:22:48.128] Conditions captured: <none>
[10:22:48.128] Early signaling: FALSE
[10:22:48.128] Owner process: c32001f4-7766-b0c5-101c-ef38f14fd7f0
[10:22:48.128] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:48.143] Chunk #2 of 2 ... DONE
[10:22:48.144] Launching 2 futures (chunks) ... DONE
[10:22:48.144] Resolving 2 futures (chunks) ...
[10:22:48.144] resolve() on list ...
[10:22:48.144]  recursive: 0
[10:22:48.144]  length: 2
[10:22:48.144] 
[10:22:48.145] receiveMessageFromWorker() for ClusterFuture ...
[10:22:48.145] - Validating connection of MultisessionFuture
[10:22:48.145] - received message: FutureResult
[10:22:48.145] - Received FutureResult
[10:22:48.146] - Erased future from FutureRegistry
[10:22:48.146] result() for ClusterFuture ...
[10:22:48.146] - result already collected: FutureResult
[10:22:48.146] result() for ClusterFuture ... done
[10:22:48.146] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:48.146] Future #1
[10:22:48.146] result() for ClusterFuture ...
[10:22:48.147] - result already collected: FutureResult
[10:22:48.147] result() for ClusterFuture ... done
[10:22:48.147] result() for ClusterFuture ...
[10:22:48.147] - result already collected: FutureResult
[10:22:48.147] result() for ClusterFuture ... done
[10:22:48.147] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:22:48.147] - nx: 2
[10:22:48.147] - relay: TRUE
[10:22:48.148] - stdout: TRUE
[10:22:48.148] - signal: TRUE
[10:22:48.148] - resignal: FALSE
[10:22:48.148] - force: TRUE
[10:22:48.148] - relayed: [n=2] FALSE, FALSE
[10:22:48.148] - queued futures: [n=2] FALSE, FALSE
[10:22:48.148]  - until=1
[10:22:48.148]  - relaying element #1
[10:22:48.149] result() for ClusterFuture ...
[10:22:48.149] - result already collected: FutureResult
[10:22:48.149] result() for ClusterFuture ... done
[10:22:48.149] result() for ClusterFuture ...
[10:22:48.149] - result already collected: FutureResult
[10:22:48.149] result() for ClusterFuture ... done
[10:22:48.149] result() for ClusterFuture ...
[10:22:48.149] - result already collected: FutureResult
[10:22:48.150] result() for ClusterFuture ... done
[10:22:48.150] result() for ClusterFuture ...
[10:22:48.150] - result already collected: FutureResult
[10:22:48.150] result() for ClusterFuture ... done
[10:22:48.150] - relayed: [n=2] TRUE, FALSE
[10:22:48.150] - queued futures: [n=2] TRUE, FALSE
[10:22:48.150] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:22:48.151]  length: 1 (resolved future 1)
[10:22:48.175] receiveMessageFromWorker() for ClusterFuture ...
[10:22:48.175] - Validating connection of MultisessionFuture
[10:22:48.176] - received message: FutureResult
[10:22:48.176] - Received FutureResult
[10:22:48.176] - Erased future from FutureRegistry
[10:22:48.176] result() for ClusterFuture ...
[10:22:48.176] - result already collected: FutureResult
[10:22:48.176] result() for ClusterFuture ... done
[10:22:48.176] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:48.176] Future #2
[10:22:48.176] result() for ClusterFuture ...
[10:22:48.176] - result already collected: FutureResult
[10:22:48.177] result() for ClusterFuture ... done
[10:22:48.177] result() for ClusterFuture ...
[10:22:48.177] - result already collected: FutureResult
[10:22:48.177] result() for ClusterFuture ... done
[10:22:48.177] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:22:48.177] - nx: 2
[10:22:48.177] - relay: TRUE
[10:22:48.177] - stdout: TRUE
[10:22:48.177] - signal: TRUE
[10:22:48.177] - resignal: FALSE
[10:22:48.177] - force: TRUE
[10:22:48.178] - relayed: [n=2] TRUE, FALSE
[10:22:48.178] - queued futures: [n=2] TRUE, FALSE
[10:22:48.178]  - until=2
[10:22:48.178]  - relaying element #2
[10:22:48.178] result() for ClusterFuture ...
[10:22:48.178] - result already collected: FutureResult
[10:22:48.178] result() for ClusterFuture ... done
[10:22:48.178] result() for ClusterFuture ...
[10:22:48.178] - result already collected: FutureResult
[10:22:48.178] result() for ClusterFuture ... done
[10:22:48.178] result() for ClusterFuture ...
[10:22:48.179] - result already collected: FutureResult
[10:22:48.179] result() for ClusterFuture ... done
[10:22:48.179] result() for ClusterFuture ...
[10:22:48.179] - result already collected: FutureResult
[10:22:48.179] result() for ClusterFuture ... done
[10:22:48.179] - relayed: [n=2] TRUE, TRUE
[10:22:48.179] - queued futures: [n=2] TRUE, TRUE
[10:22:48.179] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:22:48.179]  length: 0 (resolved future 2)
[10:22:48.179] Relaying remaining futures
[10:22:48.179] signalConditionsASAP(NULL, pos=0) ...
[10:22:48.180] - nx: 2
[10:22:48.180] - relay: TRUE
[10:22:48.180] - stdout: TRUE
[10:22:48.180] - signal: TRUE
[10:22:48.180] - resignal: FALSE
[10:22:48.180] - force: TRUE
[10:22:48.180] - relayed: [n=2] TRUE, TRUE
[10:22:48.180] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:22:48.180] - relayed: [n=2] TRUE, TRUE
[10:22:48.180] - queued futures: [n=2] TRUE, TRUE
[10:22:48.180] signalConditionsASAP(NULL, pos=0) ... done
[10:22:48.181] resolve() on list ... DONE
[10:22:48.181] result() for ClusterFuture ...
[10:22:48.181] - result already collected: FutureResult
[10:22:48.181] result() for ClusterFuture ... done
[10:22:48.181] result() for ClusterFuture ...
[10:22:48.181] - result already collected: FutureResult
[10:22:48.181] result() for ClusterFuture ... done
[10:22:48.181] result() for ClusterFuture ...
[10:22:48.181] - result already collected: FutureResult
[10:22:48.181] result() for ClusterFuture ... done
[10:22:48.181] result() for ClusterFuture ...
[10:22:48.182] - result already collected: FutureResult
[10:22:48.182] result() for ClusterFuture ... done
[10:22:48.182]  - Number of value chunks collected: 2
[10:22:48.182] Resolving 2 futures (chunks) ... DONE
[10:22:48.182] Reducing values from 2 chunks ...
[10:22:48.182]  - Number of values collected after concatenation: 2
[10:22:48.182]  - Number of values expected: 2
[10:22:48.182] Reducing values from 2 chunks ... DONE
[10:22:48.182] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[10:22:48.183] plan(): Setting new future strategy stack:
[10:22:48.183] List of future strategies:
[10:22:48.183] 1. sequential:
[10:22:48.183]    - args: function (..., envir = parent.frame())
[10:22:48.183]    - tweaked: FALSE
[10:22:48.183]    - call: plan(sequential)
[10:22:48.183] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...")
*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...
> X <- matrix(nrow = 0L, ncol = 2L)
> y0 <- apply(X, MARGIN = 1L, FUN = identity)
> y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
> print(y1)
logical(0)
> stopifnot(identical(y1, y0))
>   
> 
> message("*** exceptions ...")
*** exceptions ...
> 
> ## Error: dim(X) must have a positive length
> res <- tryCatch({
+   y <- future_apply(1L, MARGIN = 1L, FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: 'X' must have named dimnames
> X <- matrix(1:2, nrow = 2L, ncol = 1L)
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "rows", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: not all elements of 'MARGIN' are names of dimensions
> X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "cols", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> 
> message("*** future_apply() ... DONE")
*** future_apply() ... DONE
> 
> source("incl/end.R")
[10:22:48.185] plan(): Setting new future strategy stack:
[10:22:48.186] List of future strategies:
[10:22:48.186] 1. FutureStrategy:
[10:22:48.186]    - args: function (..., envir = parent.frame())
[10:22:48.186]    - tweaked: FALSE
[10:22:48.186]    - call: future::plan(oplan)
[10:22:48.186] plan(): nbrOfWorkers() = 1
> 
