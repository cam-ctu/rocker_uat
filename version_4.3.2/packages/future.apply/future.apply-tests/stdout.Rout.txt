
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[13:21:47.683] plan(): Setting new future strategy stack:
[13:21:47.683] List of future strategies:
[13:21:47.683] 1. sequential:
[13:21:47.683]    - args: function (..., envir = parent.frame())
[13:21:47.683]    - tweaked: FALSE
[13:21:47.683]    - call: future::plan("sequential")
[13:21:47.698] plan(): nbrOfWorkers() = 1
> 
> message("*** future_*apply() and 'future.stdout' ...")
*** future_*apply() and 'future.stdout' ...
> 
> options(future.debug = TRUE)
> 
> truth <- list()
> 
> out <- utils::capture.output({
+   y <- lapply(1:0, FUN = function(x) {
+     print(x)
+   })
+ })
> truth[["lapply"]] <- list(value = y, stdout = out)
> 
> out <- utils::capture.output({
+   y <- mapply(1:0, 0:1, FUN = function(x, y) {
+     print(list(x = x, y = y))
+   })
+ })
> truth[["mapply"]] <- list(value = y, stdout = out)
> 
> for (cores in 1:availCores) {
+   message(sprintf("  - Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+   
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("* plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     for (fun in names(truth)) {
+       for (stdout in c(FALSE, TRUE, NA)) {
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ...", fun, stdout))
+   
+         out <- utils::capture.output({
+           if (fun == "lapply") {
+             y <- future_lapply(1:0, FUN = function(x) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+ 	      print(x)
+             }, future.stdout = stdout)
+ 	  } else if (fun == "mapply") {
+             y <- future_mapply(1:0, 0:1, FUN = function(x, y) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+               print(list(x = x, y = y))
+             }, future.stdout = stdout)
+ 	  }
+         })
+         stopifnot(identical(y, truth[[fun]]$value))
+   
+         if (isTRUE(stdout)) {
+           stopifnot(identical(out, truth[[fun]]$stdout))
+         } else if (is.na(stdout)) {
+         } else {
+           stopifnot(nchar(out) == 0)
+         }
+       
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ... DONE", fun, stdout))
+       } ## for (stdout ...)
+     } ## for (fun ...)
+     
+     message(sprintf("* plan('%s') ... DONE", strategy))
+   }
+   
+   message(sprintf("  - Testing with %d cores ... DONE", cores))
+ }
  - Testing with 1 cores ...
* plan('sequential') ...
[13:21:47.732] plan(): Setting new future strategy stack:
[13:21:47.732] List of future strategies:
[13:21:47.732] 1. sequential:
[13:21:47.732]    - args: function (..., envir = parent.frame())
[13:21:47.732]    - tweaked: FALSE
[13:21:47.732]    - call: plan(strategy)
[13:21:47.743] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[13:21:47.743] future_lapply() ...
[13:21:47.748] Number of chunks: 1
[13:21:47.749] getGlobalsAndPackagesXApply() ...
[13:21:47.749]  - future.globals: TRUE
[13:21:47.749] getGlobalsAndPackages() ...
[13:21:47.749] Searching for globals...
[13:21:47.752] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:21:47.752] Searching for globals ... DONE
[13:21:47.752] Resolving globals: FALSE
[13:21:47.753] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:21:47.754] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:21:47.754] - globals: [1] ‘FUN’
[13:21:47.754] 
[13:21:47.754] getGlobalsAndPackages() ... DONE
[13:21:47.754]  - globals found/used: [n=1] ‘FUN’
[13:21:47.754]  - needed namespaces: [n=0] 
[13:21:47.755] Finding globals ... DONE
[13:21:47.755]  - use_args: TRUE
[13:21:47.755]  - Getting '...' globals ...
[13:21:47.756] resolve() on list ...
[13:21:47.756]  recursive: 0
[13:21:47.756]  length: 1
[13:21:47.756]  elements: ‘...’
[13:21:47.756]  length: 0 (resolved future 1)
[13:21:47.756] resolve() on list ... DONE
[13:21:47.756]    - '...' content: [n=0] 
[13:21:47.757] List of 1
[13:21:47.757]  $ ...: list()
[13:21:47.757]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:47.757]  - attr(*, "where")=List of 1
[13:21:47.757]   ..$ ...:<environment: 0x55dd74703c08> 
[13:21:47.757]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:47.757]  - attr(*, "resolved")= logi TRUE
[13:21:47.757]  - attr(*, "total_size")= num NA
[13:21:47.764]  - Getting '...' globals ... DONE
[13:21:47.764] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:21:47.764] List of 2
[13:21:47.764]  $ ...future.FUN:function (x)  
[13:21:47.764]  $ ...          : list()
[13:21:47.764]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:47.764]  - attr(*, "where")=List of 2
[13:21:47.764]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:47.764]   ..$ ...          :<environment: 0x55dd74703c08> 
[13:21:47.764]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:47.764]  - attr(*, "resolved")= logi FALSE
[13:21:47.764]  - attr(*, "total_size")= num 4720
[13:21:47.767] Packages to be attached in all futures: [n=0] 
[13:21:47.767] getGlobalsAndPackagesXApply() ... DONE
[13:21:47.768] Number of futures (= number of chunks): 1
[13:21:47.768] Launching 1 futures (chunks) ...
[13:21:47.768] Chunk #1 of 1 ...
[13:21:47.768]  - Finding globals in 'X' for chunk #1 ...
[13:21:47.768] getGlobalsAndPackages() ...
[13:21:47.768] Searching for globals...
[13:21:47.769] 
[13:21:47.769] Searching for globals ... DONE
[13:21:47.769] - globals: [0] <none>
[13:21:47.769] getGlobalsAndPackages() ... DONE
[13:21:47.769]    + additional globals found: [n=0] 
[13:21:47.769]    + additional namespaces needed: [n=0] 
[13:21:47.769]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:47.769]  - seeds: <none>
[13:21:47.769]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:47.770] getGlobalsAndPackages() ...
[13:21:47.770] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:47.770] Resolving globals: FALSE
[13:21:47.770] Tweak future expression to call with '...' arguments ...
[13:21:47.770] {
[13:21:47.770]     do.call(function(...) {
[13:21:47.770]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:47.770]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:47.770]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:47.770]             on.exit(options(oopts), add = TRUE)
[13:21:47.770]         }
[13:21:47.770]         {
[13:21:47.770]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:47.770]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:47.770]                 ...future.FUN(...future.X_jj, ...)
[13:21:47.770]             })
[13:21:47.770]         }
[13:21:47.770]     }, args = future.call.arguments)
[13:21:47.770] }
[13:21:47.770] Tweak future expression to call with '...' arguments ... DONE
[13:21:47.771] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:47.771] 
[13:21:47.771] getGlobalsAndPackages() ... DONE
[13:21:47.772] run() for ‘Future’ ...
[13:21:47.772] - state: ‘created’
[13:21:47.772] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:47.772] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:47.772] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:47.772]   - Field: ‘label’
[13:21:47.773]   - Field: ‘local’
[13:21:47.773]   - Field: ‘owner’
[13:21:47.773]   - Field: ‘envir’
[13:21:47.773]   - Field: ‘packages’
[13:21:47.773]   - Field: ‘gc’
[13:21:47.773]   - Field: ‘conditions’
[13:21:47.773]   - Field: ‘expr’
[13:21:47.773]   - Field: ‘uuid’
[13:21:47.773]   - Field: ‘seed’
[13:21:47.773]   - Field: ‘version’
[13:21:47.774]   - Field: ‘result’
[13:21:47.774]   - Field: ‘asynchronous’
[13:21:47.774]   - Field: ‘calls’
[13:21:47.774]   - Field: ‘globals’
[13:21:47.774]   - Field: ‘stdout’
[13:21:47.774]   - Field: ‘earlySignal’
[13:21:47.774]   - Field: ‘lazy’
[13:21:47.774]   - Field: ‘state’
[13:21:47.774] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:47.774] - Launch lazy future ...
[13:21:47.775] Packages needed by the future expression (n = 0): <none>
[13:21:47.775] Packages needed by future strategies (n = 0): <none>
[13:21:47.776] {
[13:21:47.776]     {
[13:21:47.776]         {
[13:21:47.776]             ...future.startTime <- base::Sys.time()
[13:21:47.776]             {
[13:21:47.776]                 {
[13:21:47.776]                   {
[13:21:47.776]                     base::local({
[13:21:47.776]                       has_future <- base::requireNamespace("future", 
[13:21:47.776]                         quietly = TRUE)
[13:21:47.776]                       if (has_future) {
[13:21:47.776]                         ns <- base::getNamespace("future")
[13:21:47.776]                         version <- ns[[".package"]][["version"]]
[13:21:47.776]                         if (is.null(version)) 
[13:21:47.776]                           version <- utils::packageVersion("future")
[13:21:47.776]                       }
[13:21:47.776]                       else {
[13:21:47.776]                         version <- NULL
[13:21:47.776]                       }
[13:21:47.776]                       if (!has_future || version < "1.8.0") {
[13:21:47.776]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:47.776]                           "", base::R.version$version.string), 
[13:21:47.776]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:47.776]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:47.776]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:47.776]                             "release", "version")], collapse = " "), 
[13:21:47.776]                           hostname = base::Sys.info()[["nodename"]])
[13:21:47.776]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:47.776]                           info)
[13:21:47.776]                         info <- base::paste(info, collapse = "; ")
[13:21:47.776]                         if (!has_future) {
[13:21:47.776]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:47.776]                             info)
[13:21:47.776]                         }
[13:21:47.776]                         else {
[13:21:47.776]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:47.776]                             info, version)
[13:21:47.776]                         }
[13:21:47.776]                         base::stop(msg)
[13:21:47.776]                       }
[13:21:47.776]                     })
[13:21:47.776]                   }
[13:21:47.776]                   options(future.plan = NULL)
[13:21:47.776]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:47.776]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:47.776]                 }
[13:21:47.776]                 ...future.workdir <- getwd()
[13:21:47.776]             }
[13:21:47.776]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:47.776]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:47.776]         }
[13:21:47.776]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:47.776]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:47.776]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:47.776]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:47.776]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:47.776]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:47.776]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:47.776]             base::names(...future.oldOptions))
[13:21:47.776]     }
[13:21:47.776]     if (FALSE) {
[13:21:47.776]     }
[13:21:47.776]     else {
[13:21:47.776]         if (FALSE) {
[13:21:47.776]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:47.776]                 open = "w")
[13:21:47.776]         }
[13:21:47.776]         else {
[13:21:47.776]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:47.776]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:47.776]         }
[13:21:47.776]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:47.776]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:47.776]             base::sink(type = "output", split = FALSE)
[13:21:47.776]             base::close(...future.stdout)
[13:21:47.776]         }, add = TRUE)
[13:21:47.776]     }
[13:21:47.776]     ...future.frame <- base::sys.nframe()
[13:21:47.776]     ...future.conditions <- base::list()
[13:21:47.776]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:47.776]     if (FALSE) {
[13:21:47.776]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:47.776]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:47.776]     }
[13:21:47.776]     ...future.result <- base::tryCatch({
[13:21:47.776]         base::withCallingHandlers({
[13:21:47.776]             ...future.value <- base::withVisible(base::local({
[13:21:47.776]                 do.call(function(...) {
[13:21:47.776]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:47.776]                   if (!identical(...future.globals.maxSize.org, 
[13:21:47.776]                     ...future.globals.maxSize)) {
[13:21:47.776]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:47.776]                     on.exit(options(oopts), add = TRUE)
[13:21:47.776]                   }
[13:21:47.776]                   {
[13:21:47.776]                     lapply(seq_along(...future.elements_ii), 
[13:21:47.776]                       FUN = function(jj) {
[13:21:47.776]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:47.776]                         ...future.FUN(...future.X_jj, ...)
[13:21:47.776]                       })
[13:21:47.776]                   }
[13:21:47.776]                 }, args = future.call.arguments)
[13:21:47.776]             }))
[13:21:47.776]             future::FutureResult(value = ...future.value$value, 
[13:21:47.776]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:47.776]                   ...future.rng), globalenv = if (FALSE) 
[13:21:47.776]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:47.776]                     ...future.globalenv.names))
[13:21:47.776]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:47.776]         }, condition = base::local({
[13:21:47.776]             c <- base::c
[13:21:47.776]             inherits <- base::inherits
[13:21:47.776]             invokeRestart <- base::invokeRestart
[13:21:47.776]             length <- base::length
[13:21:47.776]             list <- base::list
[13:21:47.776]             seq.int <- base::seq.int
[13:21:47.776]             signalCondition <- base::signalCondition
[13:21:47.776]             sys.calls <- base::sys.calls
[13:21:47.776]             `[[` <- base::`[[`
[13:21:47.776]             `+` <- base::`+`
[13:21:47.776]             `<<-` <- base::`<<-`
[13:21:47.776]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:47.776]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:47.776]                   3L)]
[13:21:47.776]             }
[13:21:47.776]             function(cond) {
[13:21:47.776]                 is_error <- inherits(cond, "error")
[13:21:47.776]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:47.776]                   NULL)
[13:21:47.776]                 if (is_error) {
[13:21:47.776]                   sessionInformation <- function() {
[13:21:47.776]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:47.776]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:47.776]                       search = base::search(), system = base::Sys.info())
[13:21:47.776]                   }
[13:21:47.776]                   ...future.conditions[[length(...future.conditions) + 
[13:21:47.776]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:47.776]                     cond$call), session = sessionInformation(), 
[13:21:47.776]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:47.776]                   signalCondition(cond)
[13:21:47.776]                 }
[13:21:47.776]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:47.776]                 "immediateCondition"))) {
[13:21:47.776]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:47.776]                   ...future.conditions[[length(...future.conditions) + 
[13:21:47.776]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:47.776]                   if (TRUE && !signal) {
[13:21:47.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:47.776]                     {
[13:21:47.776]                       inherits <- base::inherits
[13:21:47.776]                       invokeRestart <- base::invokeRestart
[13:21:47.776]                       is.null <- base::is.null
[13:21:47.776]                       muffled <- FALSE
[13:21:47.776]                       if (inherits(cond, "message")) {
[13:21:47.776]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:47.776]                         if (muffled) 
[13:21:47.776]                           invokeRestart("muffleMessage")
[13:21:47.776]                       }
[13:21:47.776]                       else if (inherits(cond, "warning")) {
[13:21:47.776]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:47.776]                         if (muffled) 
[13:21:47.776]                           invokeRestart("muffleWarning")
[13:21:47.776]                       }
[13:21:47.776]                       else if (inherits(cond, "condition")) {
[13:21:47.776]                         if (!is.null(pattern)) {
[13:21:47.776]                           computeRestarts <- base::computeRestarts
[13:21:47.776]                           grepl <- base::grepl
[13:21:47.776]                           restarts <- computeRestarts(cond)
[13:21:47.776]                           for (restart in restarts) {
[13:21:47.776]                             name <- restart$name
[13:21:47.776]                             if (is.null(name)) 
[13:21:47.776]                               next
[13:21:47.776]                             if (!grepl(pattern, name)) 
[13:21:47.776]                               next
[13:21:47.776]                             invokeRestart(restart)
[13:21:47.776]                             muffled <- TRUE
[13:21:47.776]                             break
[13:21:47.776]                           }
[13:21:47.776]                         }
[13:21:47.776]                       }
[13:21:47.776]                       invisible(muffled)
[13:21:47.776]                     }
[13:21:47.776]                     muffleCondition(cond, pattern = "^muffle")
[13:21:47.776]                   }
[13:21:47.776]                 }
[13:21:47.776]                 else {
[13:21:47.776]                   if (TRUE) {
[13:21:47.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:47.776]                     {
[13:21:47.776]                       inherits <- base::inherits
[13:21:47.776]                       invokeRestart <- base::invokeRestart
[13:21:47.776]                       is.null <- base::is.null
[13:21:47.776]                       muffled <- FALSE
[13:21:47.776]                       if (inherits(cond, "message")) {
[13:21:47.776]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:47.776]                         if (muffled) 
[13:21:47.776]                           invokeRestart("muffleMessage")
[13:21:47.776]                       }
[13:21:47.776]                       else if (inherits(cond, "warning")) {
[13:21:47.776]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:47.776]                         if (muffled) 
[13:21:47.776]                           invokeRestart("muffleWarning")
[13:21:47.776]                       }
[13:21:47.776]                       else if (inherits(cond, "condition")) {
[13:21:47.776]                         if (!is.null(pattern)) {
[13:21:47.776]                           computeRestarts <- base::computeRestarts
[13:21:47.776]                           grepl <- base::grepl
[13:21:47.776]                           restarts <- computeRestarts(cond)
[13:21:47.776]                           for (restart in restarts) {
[13:21:47.776]                             name <- restart$name
[13:21:47.776]                             if (is.null(name)) 
[13:21:47.776]                               next
[13:21:47.776]                             if (!grepl(pattern, name)) 
[13:21:47.776]                               next
[13:21:47.776]                             invokeRestart(restart)
[13:21:47.776]                             muffled <- TRUE
[13:21:47.776]                             break
[13:21:47.776]                           }
[13:21:47.776]                         }
[13:21:47.776]                       }
[13:21:47.776]                       invisible(muffled)
[13:21:47.776]                     }
[13:21:47.776]                     muffleCondition(cond, pattern = "^muffle")
[13:21:47.776]                   }
[13:21:47.776]                 }
[13:21:47.776]             }
[13:21:47.776]         }))
[13:21:47.776]     }, error = function(ex) {
[13:21:47.776]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:47.776]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:47.776]                 ...future.rng), started = ...future.startTime, 
[13:21:47.776]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:47.776]             version = "1.8"), class = "FutureResult")
[13:21:47.776]     }, finally = {
[13:21:47.776]         if (!identical(...future.workdir, getwd())) 
[13:21:47.776]             setwd(...future.workdir)
[13:21:47.776]         {
[13:21:47.776]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:47.776]                 ...future.oldOptions$nwarnings <- NULL
[13:21:47.776]             }
[13:21:47.776]             base::options(...future.oldOptions)
[13:21:47.776]             if (.Platform$OS.type == "windows") {
[13:21:47.776]                 old_names <- names(...future.oldEnvVars)
[13:21:47.776]                 envs <- base::Sys.getenv()
[13:21:47.776]                 names <- names(envs)
[13:21:47.776]                 common <- intersect(names, old_names)
[13:21:47.776]                 added <- setdiff(names, old_names)
[13:21:47.776]                 removed <- setdiff(old_names, names)
[13:21:47.776]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:47.776]                   envs[common]]
[13:21:47.776]                 NAMES <- toupper(changed)
[13:21:47.776]                 args <- list()
[13:21:47.776]                 for (kk in seq_along(NAMES)) {
[13:21:47.776]                   name <- changed[[kk]]
[13:21:47.776]                   NAME <- NAMES[[kk]]
[13:21:47.776]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:47.776]                     next
[13:21:47.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:47.776]                 }
[13:21:47.776]                 NAMES <- toupper(added)
[13:21:47.776]                 for (kk in seq_along(NAMES)) {
[13:21:47.776]                   name <- added[[kk]]
[13:21:47.776]                   NAME <- NAMES[[kk]]
[13:21:47.776]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:47.776]                     next
[13:21:47.776]                   args[[name]] <- ""
[13:21:47.776]                 }
[13:21:47.776]                 NAMES <- toupper(removed)
[13:21:47.776]                 for (kk in seq_along(NAMES)) {
[13:21:47.776]                   name <- removed[[kk]]
[13:21:47.776]                   NAME <- NAMES[[kk]]
[13:21:47.776]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:47.776]                     next
[13:21:47.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:47.776]                 }
[13:21:47.776]                 if (length(args) > 0) 
[13:21:47.776]                   base::do.call(base::Sys.setenv, args = args)
[13:21:47.776]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:47.776]             }
[13:21:47.776]             else {
[13:21:47.776]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:47.776]             }
[13:21:47.776]             {
[13:21:47.776]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:47.776]                   0L) {
[13:21:47.776]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:47.776]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:47.776]                   base::options(opts)
[13:21:47.776]                 }
[13:21:47.776]                 {
[13:21:47.776]                   {
[13:21:47.776]                     NULL
[13:21:47.776]                     RNGkind("Mersenne-Twister")
[13:21:47.776]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:47.776]                       inherits = FALSE)
[13:21:47.776]                   }
[13:21:47.776]                   options(future.plan = NULL)
[13:21:47.776]                   if (is.na(NA_character_)) 
[13:21:47.776]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:47.776]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:47.776]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:47.776]                   {
[13:21:47.776]                     future <- SequentialFuture(..., envir = envir)
[13:21:47.776]                     if (!future$lazy) 
[13:21:47.776]                       future <- run(future)
[13:21:47.776]                     invisible(future)
[13:21:47.776]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:47.776]                 }
[13:21:47.776]             }
[13:21:47.776]         }
[13:21:47.776]     })
[13:21:47.776]     if (TRUE) {
[13:21:47.776]         base::sink(type = "output", split = FALSE)
[13:21:47.776]         if (FALSE) {
[13:21:47.776]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:47.776]         }
[13:21:47.776]         else {
[13:21:47.776]             ...future.result["stdout"] <- base::list(NULL)
[13:21:47.776]         }
[13:21:47.776]         base::close(...future.stdout)
[13:21:47.776]         ...future.stdout <- NULL
[13:21:47.776]     }
[13:21:47.776]     ...future.result$conditions <- ...future.conditions
[13:21:47.776]     ...future.result$finished <- base::Sys.time()
[13:21:47.776]     ...future.result
[13:21:47.776] }
[13:21:47.778] assign_globals() ...
[13:21:47.778] List of 5
[13:21:47.778]  $ ...future.FUN            :function (x)  
[13:21:47.778]  $ future.call.arguments    : list()
[13:21:47.778]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:47.778]  $ ...future.elements_ii    :List of 2
[13:21:47.778]   ..$ : int 1
[13:21:47.778]   ..$ : int 0
[13:21:47.778]  $ ...future.seeds_ii       : NULL
[13:21:47.778]  $ ...future.globals.maxSize: NULL
[13:21:47.778]  - attr(*, "where")=List of 5
[13:21:47.778]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:47.778]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:47.778]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:47.778]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:47.778]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:47.778]  - attr(*, "resolved")= logi FALSE
[13:21:47.778]  - attr(*, "total_size")= num 4720
[13:21:47.778]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:47.778]  - attr(*, "already-done")= logi TRUE
[13:21:47.783] - reassign environment for ‘...future.FUN’
[13:21:47.783] - copied ‘...future.FUN’ to environment
[13:21:47.783] - copied ‘future.call.arguments’ to environment
[13:21:47.783] - copied ‘...future.elements_ii’ to environment
[13:21:47.783] - copied ‘...future.seeds_ii’ to environment
[13:21:47.784] - copied ‘...future.globals.maxSize’ to environment
[13:21:47.784] assign_globals() ... done
[13:21:47.784] plan(): Setting new future strategy stack:
[13:21:47.784] List of future strategies:
[13:21:47.784] 1. sequential:
[13:21:47.784]    - args: function (..., envir = parent.frame())
[13:21:47.784]    - tweaked: FALSE
[13:21:47.784]    - call: NULL
[13:21:47.785] plan(): nbrOfWorkers() = 1
[13:21:48.287] plan(): Setting new future strategy stack:
[13:21:48.287] List of future strategies:
[13:21:48.287] 1. sequential:
[13:21:48.287]    - args: function (..., envir = parent.frame())
[13:21:48.287]    - tweaked: FALSE
[13:21:48.287]    - call: plan(strategy)
[13:21:48.287] plan(): nbrOfWorkers() = 1
[13:21:48.288] SequentialFuture started (and completed)
[13:21:48.288] - Launch lazy future ... done
[13:21:48.288] run() for ‘SequentialFuture’ ... done
[13:21:48.288] Created future:
[13:21:48.289] SequentialFuture:
[13:21:48.289] Label: ‘future_lapply-1’
[13:21:48.289] Expression:
[13:21:48.289] {
[13:21:48.289]     do.call(function(...) {
[13:21:48.289]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:48.289]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:48.289]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:48.289]             on.exit(options(oopts), add = TRUE)
[13:21:48.289]         }
[13:21:48.289]         {
[13:21:48.289]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:48.289]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:48.289]                 ...future.FUN(...future.X_jj, ...)
[13:21:48.289]             })
[13:21:48.289]         }
[13:21:48.289]     }, args = future.call.arguments)
[13:21:48.289] }
[13:21:48.289] Lazy evaluation: FALSE
[13:21:48.289] Asynchronous evaluation: FALSE
[13:21:48.289] Local evaluation: TRUE
[13:21:48.289] Environment: R_GlobalEnv
[13:21:48.289] Capture standard output: FALSE
[13:21:48.289] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:48.289] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:48.289] Packages: <none>
[13:21:48.289] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:48.289] Resolved: TRUE
[13:21:48.289] Value: 112 bytes of class ‘list’
[13:21:48.289] Early signaling: FALSE
[13:21:48.289] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:21:48.289] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:48.290] Chunk #1 of 1 ... DONE
[13:21:48.290] Launching 1 futures (chunks) ... DONE
[13:21:48.290] Resolving 1 futures (chunks) ...
[13:21:48.290] resolve() on list ...
[13:21:48.291]  recursive: 0
[13:21:48.291]  length: 1
[13:21:48.291] 
[13:21:48.291] resolved() for ‘SequentialFuture’ ...
[13:21:48.291] - state: ‘finished’
[13:21:48.291] - run: TRUE
[13:21:48.291] - result: ‘FutureResult’
[13:21:48.291] resolved() for ‘SequentialFuture’ ... done
[13:21:48.291] Future #1
[13:21:48.292] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:48.292] - nx: 1
[13:21:48.292] - relay: TRUE
[13:21:48.292] - stdout: TRUE
[13:21:48.292] - signal: TRUE
[13:21:48.292] - resignal: FALSE
[13:21:48.292] - force: TRUE
[13:21:48.293] - relayed: [n=1] FALSE
[13:21:48.293] - queued futures: [n=1] FALSE
[13:21:48.293]  - until=1
[13:21:48.293]  - relaying element #1
[13:21:48.293] - relayed: [n=1] TRUE
[13:21:48.293] - queued futures: [n=1] TRUE
[13:21:48.293] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:48.293]  length: 0 (resolved future 1)
[13:21:48.293] Relaying remaining futures
[13:21:48.294] signalConditionsASAP(NULL, pos=0) ...
[13:21:48.296] - nx: 1
[13:21:48.296] - relay: TRUE
[13:21:48.296] - stdout: TRUE
[13:21:48.296] - signal: TRUE
[13:21:48.296] - resignal: FALSE
[13:21:48.296] - force: TRUE
[13:21:48.296] - relayed: [n=1] TRUE
[13:21:48.296] - queued futures: [n=1] TRUE
 - flush all
[13:21:48.297] - relayed: [n=1] TRUE
[13:21:48.297] - queued futures: [n=1] TRUE
[13:21:48.297] signalConditionsASAP(NULL, pos=0) ... done
[13:21:48.297] resolve() on list ... DONE
[13:21:48.297]  - Number of value chunks collected: 1
[13:21:48.297] Resolving 1 futures (chunks) ... DONE
[13:21:48.297] Reducing values from 1 chunks ...
[13:21:48.297]  - Number of values collected after concatenation: 2
[13:21:48.297]  - Number of values expected: 2
[13:21:48.298] Reducing values from 1 chunks ... DONE
[13:21:48.298] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[13:21:48.298] future_lapply() ...
[13:21:48.299] Number of chunks: 1
[13:21:48.299] getGlobalsAndPackagesXApply() ...
[13:21:48.299]  - future.globals: TRUE
[13:21:48.299] getGlobalsAndPackages() ...
[13:21:48.299] Searching for globals...
[13:21:48.301] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:21:48.301] Searching for globals ... DONE
[13:21:48.301] Resolving globals: FALSE
[13:21:48.301] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:21:48.302] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:21:48.302] - globals: [1] ‘FUN’
[13:21:48.302] 
[13:21:48.302] getGlobalsAndPackages() ... DONE
[13:21:48.302]  - globals found/used: [n=1] ‘FUN’
[13:21:48.302]  - needed namespaces: [n=0] 
[13:21:48.302] Finding globals ... DONE
[13:21:48.302]  - use_args: TRUE
[13:21:48.302]  - Getting '...' globals ...
[13:21:48.303] resolve() on list ...
[13:21:48.303]  recursive: 0
[13:21:48.303]  length: 1
[13:21:48.303]  elements: ‘...’
[13:21:48.303]  length: 0 (resolved future 1)
[13:21:48.303] resolve() on list ... DONE
[13:21:48.303]    - '...' content: [n=0] 
[13:21:48.303] List of 1
[13:21:48.303]  $ ...: list()
[13:21:48.303]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:48.303]  - attr(*, "where")=List of 1
[13:21:48.303]   ..$ ...:<environment: 0x55dd73270350> 
[13:21:48.303]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:48.303]  - attr(*, "resolved")= logi TRUE
[13:21:48.303]  - attr(*, "total_size")= num NA
[13:21:48.306]  - Getting '...' globals ... DONE
[13:21:48.306] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:21:48.306] List of 2
[13:21:48.306]  $ ...future.FUN:function (x)  
[13:21:48.306]  $ ...          : list()
[13:21:48.306]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:48.306]  - attr(*, "where")=List of 2
[13:21:48.306]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:48.306]   ..$ ...          :<environment: 0x55dd73270350> 
[13:21:48.306]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:48.306]  - attr(*, "resolved")= logi FALSE
[13:21:48.306]  - attr(*, "total_size")= num 4720
[13:21:48.309] Packages to be attached in all futures: [n=0] 
[13:21:48.309] getGlobalsAndPackagesXApply() ... DONE
[13:21:48.309] Number of futures (= number of chunks): 1
[13:21:48.309] Launching 1 futures (chunks) ...
[13:21:48.310] Chunk #1 of 1 ...
[13:21:48.310]  - Finding globals in 'X' for chunk #1 ...
[13:21:48.310] getGlobalsAndPackages() ...
[13:21:48.310] Searching for globals...
[13:21:48.310] 
[13:21:48.310] Searching for globals ... DONE
[13:21:48.310] - globals: [0] <none>
[13:21:48.310] getGlobalsAndPackages() ... DONE
[13:21:48.310]    + additional globals found: [n=0] 
[13:21:48.311]    + additional namespaces needed: [n=0] 
[13:21:48.311]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:48.311]  - seeds: <none>
[13:21:48.311]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:48.311] getGlobalsAndPackages() ...
[13:21:48.311] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:48.311] Resolving globals: FALSE
[13:21:48.311] Tweak future expression to call with '...' arguments ...
[13:21:48.311] {
[13:21:48.311]     do.call(function(...) {
[13:21:48.311]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:48.311]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:48.311]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:48.311]             on.exit(options(oopts), add = TRUE)
[13:21:48.311]         }
[13:21:48.311]         {
[13:21:48.311]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:48.311]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:48.311]                 ...future.FUN(...future.X_jj, ...)
[13:21:48.311]             })
[13:21:48.311]         }
[13:21:48.311]     }, args = future.call.arguments)
[13:21:48.311] }
[13:21:48.312] Tweak future expression to call with '...' arguments ... DONE
[13:21:48.312] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:48.312] 
[13:21:48.312] getGlobalsAndPackages() ... DONE
[13:21:48.313] run() for ‘Future’ ...
[13:21:48.313] - state: ‘created’
[13:21:48.313] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:48.313] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:48.313] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:48.313]   - Field: ‘label’
[13:21:48.313]   - Field: ‘local’
[13:21:48.313]   - Field: ‘owner’
[13:21:48.314]   - Field: ‘envir’
[13:21:48.314]   - Field: ‘packages’
[13:21:48.314]   - Field: ‘gc’
[13:21:48.314]   - Field: ‘conditions’
[13:21:48.314]   - Field: ‘expr’
[13:21:48.314]   - Field: ‘uuid’
[13:21:48.314]   - Field: ‘seed’
[13:21:48.314]   - Field: ‘version’
[13:21:48.314]   - Field: ‘result’
[13:21:48.314]   - Field: ‘asynchronous’
[13:21:48.315]   - Field: ‘calls’
[13:21:48.315]   - Field: ‘globals’
[13:21:48.315]   - Field: ‘stdout’
[13:21:48.315]   - Field: ‘earlySignal’
[13:21:48.315]   - Field: ‘lazy’
[13:21:48.315]   - Field: ‘state’
[13:21:48.315] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:48.315] - Launch lazy future ...
[13:21:48.315] Packages needed by the future expression (n = 0): <none>
[13:21:48.315] Packages needed by future strategies (n = 0): <none>
[13:21:48.316] {
[13:21:48.316]     {
[13:21:48.316]         {
[13:21:48.316]             ...future.startTime <- base::Sys.time()
[13:21:48.316]             {
[13:21:48.316]                 {
[13:21:48.316]                   {
[13:21:48.316]                     base::local({
[13:21:48.316]                       has_future <- base::requireNamespace("future", 
[13:21:48.316]                         quietly = TRUE)
[13:21:48.316]                       if (has_future) {
[13:21:48.316]                         ns <- base::getNamespace("future")
[13:21:48.316]                         version <- ns[[".package"]][["version"]]
[13:21:48.316]                         if (is.null(version)) 
[13:21:48.316]                           version <- utils::packageVersion("future")
[13:21:48.316]                       }
[13:21:48.316]                       else {
[13:21:48.316]                         version <- NULL
[13:21:48.316]                       }
[13:21:48.316]                       if (!has_future || version < "1.8.0") {
[13:21:48.316]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:48.316]                           "", base::R.version$version.string), 
[13:21:48.316]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:48.316]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:48.316]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:48.316]                             "release", "version")], collapse = " "), 
[13:21:48.316]                           hostname = base::Sys.info()[["nodename"]])
[13:21:48.316]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:48.316]                           info)
[13:21:48.316]                         info <- base::paste(info, collapse = "; ")
[13:21:48.316]                         if (!has_future) {
[13:21:48.316]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:48.316]                             info)
[13:21:48.316]                         }
[13:21:48.316]                         else {
[13:21:48.316]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:48.316]                             info, version)
[13:21:48.316]                         }
[13:21:48.316]                         base::stop(msg)
[13:21:48.316]                       }
[13:21:48.316]                     })
[13:21:48.316]                   }
[13:21:48.316]                   options(future.plan = NULL)
[13:21:48.316]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:48.316]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:48.316]                 }
[13:21:48.316]                 ...future.workdir <- getwd()
[13:21:48.316]             }
[13:21:48.316]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:48.316]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:48.316]         }
[13:21:48.316]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:48.316]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:48.316]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:48.316]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:48.316]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:48.316]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:48.316]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:48.316]             base::names(...future.oldOptions))
[13:21:48.316]     }
[13:21:48.316]     if (FALSE) {
[13:21:48.316]     }
[13:21:48.316]     else {
[13:21:48.316]         if (TRUE) {
[13:21:48.316]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:48.316]                 open = "w")
[13:21:48.316]         }
[13:21:48.316]         else {
[13:21:48.316]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:48.316]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:48.316]         }
[13:21:48.316]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:48.316]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:48.316]             base::sink(type = "output", split = FALSE)
[13:21:48.316]             base::close(...future.stdout)
[13:21:48.316]         }, add = TRUE)
[13:21:48.316]     }
[13:21:48.316]     ...future.frame <- base::sys.nframe()
[13:21:48.316]     ...future.conditions <- base::list()
[13:21:48.316]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:48.316]     if (FALSE) {
[13:21:48.316]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:48.316]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:48.316]     }
[13:21:48.316]     ...future.result <- base::tryCatch({
[13:21:48.316]         base::withCallingHandlers({
[13:21:48.316]             ...future.value <- base::withVisible(base::local({
[13:21:48.316]                 do.call(function(...) {
[13:21:48.316]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:48.316]                   if (!identical(...future.globals.maxSize.org, 
[13:21:48.316]                     ...future.globals.maxSize)) {
[13:21:48.316]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:48.316]                     on.exit(options(oopts), add = TRUE)
[13:21:48.316]                   }
[13:21:48.316]                   {
[13:21:48.316]                     lapply(seq_along(...future.elements_ii), 
[13:21:48.316]                       FUN = function(jj) {
[13:21:48.316]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:48.316]                         ...future.FUN(...future.X_jj, ...)
[13:21:48.316]                       })
[13:21:48.316]                   }
[13:21:48.316]                 }, args = future.call.arguments)
[13:21:48.316]             }))
[13:21:48.316]             future::FutureResult(value = ...future.value$value, 
[13:21:48.316]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:48.316]                   ...future.rng), globalenv = if (FALSE) 
[13:21:48.316]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:48.316]                     ...future.globalenv.names))
[13:21:48.316]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:48.316]         }, condition = base::local({
[13:21:48.316]             c <- base::c
[13:21:48.316]             inherits <- base::inherits
[13:21:48.316]             invokeRestart <- base::invokeRestart
[13:21:48.316]             length <- base::length
[13:21:48.316]             list <- base::list
[13:21:48.316]             seq.int <- base::seq.int
[13:21:48.316]             signalCondition <- base::signalCondition
[13:21:48.316]             sys.calls <- base::sys.calls
[13:21:48.316]             `[[` <- base::`[[`
[13:21:48.316]             `+` <- base::`+`
[13:21:48.316]             `<<-` <- base::`<<-`
[13:21:48.316]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:48.316]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:48.316]                   3L)]
[13:21:48.316]             }
[13:21:48.316]             function(cond) {
[13:21:48.316]                 is_error <- inherits(cond, "error")
[13:21:48.316]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:48.316]                   NULL)
[13:21:48.316]                 if (is_error) {
[13:21:48.316]                   sessionInformation <- function() {
[13:21:48.316]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:48.316]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:48.316]                       search = base::search(), system = base::Sys.info())
[13:21:48.316]                   }
[13:21:48.316]                   ...future.conditions[[length(...future.conditions) + 
[13:21:48.316]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:48.316]                     cond$call), session = sessionInformation(), 
[13:21:48.316]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:48.316]                   signalCondition(cond)
[13:21:48.316]                 }
[13:21:48.316]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:48.316]                 "immediateCondition"))) {
[13:21:48.316]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:48.316]                   ...future.conditions[[length(...future.conditions) + 
[13:21:48.316]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:48.316]                   if (TRUE && !signal) {
[13:21:48.316]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:48.316]                     {
[13:21:48.316]                       inherits <- base::inherits
[13:21:48.316]                       invokeRestart <- base::invokeRestart
[13:21:48.316]                       is.null <- base::is.null
[13:21:48.316]                       muffled <- FALSE
[13:21:48.316]                       if (inherits(cond, "message")) {
[13:21:48.316]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:48.316]                         if (muffled) 
[13:21:48.316]                           invokeRestart("muffleMessage")
[13:21:48.316]                       }
[13:21:48.316]                       else if (inherits(cond, "warning")) {
[13:21:48.316]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:48.316]                         if (muffled) 
[13:21:48.316]                           invokeRestart("muffleWarning")
[13:21:48.316]                       }
[13:21:48.316]                       else if (inherits(cond, "condition")) {
[13:21:48.316]                         if (!is.null(pattern)) {
[13:21:48.316]                           computeRestarts <- base::computeRestarts
[13:21:48.316]                           grepl <- base::grepl
[13:21:48.316]                           restarts <- computeRestarts(cond)
[13:21:48.316]                           for (restart in restarts) {
[13:21:48.316]                             name <- restart$name
[13:21:48.316]                             if (is.null(name)) 
[13:21:48.316]                               next
[13:21:48.316]                             if (!grepl(pattern, name)) 
[13:21:48.316]                               next
[13:21:48.316]                             invokeRestart(restart)
[13:21:48.316]                             muffled <- TRUE
[13:21:48.316]                             break
[13:21:48.316]                           }
[13:21:48.316]                         }
[13:21:48.316]                       }
[13:21:48.316]                       invisible(muffled)
[13:21:48.316]                     }
[13:21:48.316]                     muffleCondition(cond, pattern = "^muffle")
[13:21:48.316]                   }
[13:21:48.316]                 }
[13:21:48.316]                 else {
[13:21:48.316]                   if (TRUE) {
[13:21:48.316]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:48.316]                     {
[13:21:48.316]                       inherits <- base::inherits
[13:21:48.316]                       invokeRestart <- base::invokeRestart
[13:21:48.316]                       is.null <- base::is.null
[13:21:48.316]                       muffled <- FALSE
[13:21:48.316]                       if (inherits(cond, "message")) {
[13:21:48.316]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:48.316]                         if (muffled) 
[13:21:48.316]                           invokeRestart("muffleMessage")
[13:21:48.316]                       }
[13:21:48.316]                       else if (inherits(cond, "warning")) {
[13:21:48.316]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:48.316]                         if (muffled) 
[13:21:48.316]                           invokeRestart("muffleWarning")
[13:21:48.316]                       }
[13:21:48.316]                       else if (inherits(cond, "condition")) {
[13:21:48.316]                         if (!is.null(pattern)) {
[13:21:48.316]                           computeRestarts <- base::computeRestarts
[13:21:48.316]                           grepl <- base::grepl
[13:21:48.316]                           restarts <- computeRestarts(cond)
[13:21:48.316]                           for (restart in restarts) {
[13:21:48.316]                             name <- restart$name
[13:21:48.316]                             if (is.null(name)) 
[13:21:48.316]                               next
[13:21:48.316]                             if (!grepl(pattern, name)) 
[13:21:48.316]                               next
[13:21:48.316]                             invokeRestart(restart)
[13:21:48.316]                             muffled <- TRUE
[13:21:48.316]                             break
[13:21:48.316]                           }
[13:21:48.316]                         }
[13:21:48.316]                       }
[13:21:48.316]                       invisible(muffled)
[13:21:48.316]                     }
[13:21:48.316]                     muffleCondition(cond, pattern = "^muffle")
[13:21:48.316]                   }
[13:21:48.316]                 }
[13:21:48.316]             }
[13:21:48.316]         }))
[13:21:48.316]     }, error = function(ex) {
[13:21:48.316]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:48.316]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:48.316]                 ...future.rng), started = ...future.startTime, 
[13:21:48.316]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:48.316]             version = "1.8"), class = "FutureResult")
[13:21:48.316]     }, finally = {
[13:21:48.316]         if (!identical(...future.workdir, getwd())) 
[13:21:48.316]             setwd(...future.workdir)
[13:21:48.316]         {
[13:21:48.316]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:48.316]                 ...future.oldOptions$nwarnings <- NULL
[13:21:48.316]             }
[13:21:48.316]             base::options(...future.oldOptions)
[13:21:48.316]             if (.Platform$OS.type == "windows") {
[13:21:48.316]                 old_names <- names(...future.oldEnvVars)
[13:21:48.316]                 envs <- base::Sys.getenv()
[13:21:48.316]                 names <- names(envs)
[13:21:48.316]                 common <- intersect(names, old_names)
[13:21:48.316]                 added <- setdiff(names, old_names)
[13:21:48.316]                 removed <- setdiff(old_names, names)
[13:21:48.316]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:48.316]                   envs[common]]
[13:21:48.316]                 NAMES <- toupper(changed)
[13:21:48.316]                 args <- list()
[13:21:48.316]                 for (kk in seq_along(NAMES)) {
[13:21:48.316]                   name <- changed[[kk]]
[13:21:48.316]                   NAME <- NAMES[[kk]]
[13:21:48.316]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:48.316]                     next
[13:21:48.316]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:48.316]                 }
[13:21:48.316]                 NAMES <- toupper(added)
[13:21:48.316]                 for (kk in seq_along(NAMES)) {
[13:21:48.316]                   name <- added[[kk]]
[13:21:48.316]                   NAME <- NAMES[[kk]]
[13:21:48.316]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:48.316]                     next
[13:21:48.316]                   args[[name]] <- ""
[13:21:48.316]                 }
[13:21:48.316]                 NAMES <- toupper(removed)
[13:21:48.316]                 for (kk in seq_along(NAMES)) {
[13:21:48.316]                   name <- removed[[kk]]
[13:21:48.316]                   NAME <- NAMES[[kk]]
[13:21:48.316]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:48.316]                     next
[13:21:48.316]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:48.316]                 }
[13:21:48.316]                 if (length(args) > 0) 
[13:21:48.316]                   base::do.call(base::Sys.setenv, args = args)
[13:21:48.316]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:48.316]             }
[13:21:48.316]             else {
[13:21:48.316]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:48.316]             }
[13:21:48.316]             {
[13:21:48.316]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:48.316]                   0L) {
[13:21:48.316]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:48.316]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:48.316]                   base::options(opts)
[13:21:48.316]                 }
[13:21:48.316]                 {
[13:21:48.316]                   {
[13:21:48.316]                     NULL
[13:21:48.316]                     RNGkind("Mersenne-Twister")
[13:21:48.316]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:48.316]                       inherits = FALSE)
[13:21:48.316]                   }
[13:21:48.316]                   options(future.plan = NULL)
[13:21:48.316]                   if (is.na(NA_character_)) 
[13:21:48.316]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:48.316]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:48.316]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:48.316]                   {
[13:21:48.316]                     future <- SequentialFuture(..., envir = envir)
[13:21:48.316]                     if (!future$lazy) 
[13:21:48.316]                       future <- run(future)
[13:21:48.316]                     invisible(future)
[13:21:48.316]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:48.316]                 }
[13:21:48.316]             }
[13:21:48.316]         }
[13:21:48.316]     })
[13:21:48.316]     if (TRUE) {
[13:21:48.316]         base::sink(type = "output", split = FALSE)
[13:21:48.316]         if (TRUE) {
[13:21:48.316]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:48.316]         }
[13:21:48.316]         else {
[13:21:48.316]             ...future.result["stdout"] <- base::list(NULL)
[13:21:48.316]         }
[13:21:48.316]         base::close(...future.stdout)
[13:21:48.316]         ...future.stdout <- NULL
[13:21:48.316]     }
[13:21:48.316]     ...future.result$conditions <- ...future.conditions
[13:21:48.316]     ...future.result$finished <- base::Sys.time()
[13:21:48.316]     ...future.result
[13:21:48.316] }
[13:21:48.318] assign_globals() ...
[13:21:48.318] List of 5
[13:21:48.318]  $ ...future.FUN            :function (x)  
[13:21:48.318]  $ future.call.arguments    : list()
[13:21:48.318]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:48.318]  $ ...future.elements_ii    :List of 2
[13:21:48.318]   ..$ : int 1
[13:21:48.318]   ..$ : int 0
[13:21:48.318]  $ ...future.seeds_ii       : NULL
[13:21:48.318]  $ ...future.globals.maxSize: NULL
[13:21:48.318]  - attr(*, "where")=List of 5
[13:21:48.318]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:48.318]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:48.318]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:48.318]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:48.318]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:48.318]  - attr(*, "resolved")= logi FALSE
[13:21:48.318]  - attr(*, "total_size")= num 4720
[13:21:48.318]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:48.318]  - attr(*, "already-done")= logi TRUE
[13:21:48.325] - reassign environment for ‘...future.FUN’
[13:21:48.325] - copied ‘...future.FUN’ to environment
[13:21:48.325] - copied ‘future.call.arguments’ to environment
[13:21:48.325] - copied ‘...future.elements_ii’ to environment
[13:21:48.325] - copied ‘...future.seeds_ii’ to environment
[13:21:48.325] - copied ‘...future.globals.maxSize’ to environment
[13:21:48.325] assign_globals() ... done
[13:21:48.326] plan(): Setting new future strategy stack:
[13:21:48.326] List of future strategies:
[13:21:48.326] 1. sequential:
[13:21:48.326]    - args: function (..., envir = parent.frame())
[13:21:48.326]    - tweaked: FALSE
[13:21:48.326]    - call: NULL
[13:21:48.326] plan(): nbrOfWorkers() = 1
[13:21:48.828] plan(): Setting new future strategy stack:
[13:21:48.828] List of future strategies:
[13:21:48.828] 1. sequential:
[13:21:48.828]    - args: function (..., envir = parent.frame())
[13:21:48.828]    - tweaked: FALSE
[13:21:48.828]    - call: plan(strategy)
[13:21:48.829] plan(): nbrOfWorkers() = 1
[13:21:48.829] SequentialFuture started (and completed)
[13:21:48.829] - Launch lazy future ... done
[13:21:48.829] run() for ‘SequentialFuture’ ... done
[13:21:48.829] Created future:
[13:21:48.829] SequentialFuture:
[13:21:48.829] Label: ‘future_lapply-1’
[13:21:48.829] Expression:
[13:21:48.829] {
[13:21:48.829]     do.call(function(...) {
[13:21:48.829]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:48.829]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:48.829]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:48.829]             on.exit(options(oopts), add = TRUE)
[13:21:48.829]         }
[13:21:48.829]         {
[13:21:48.829]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:48.829]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:48.829]                 ...future.FUN(...future.X_jj, ...)
[13:21:48.829]             })
[13:21:48.829]         }
[13:21:48.829]     }, args = future.call.arguments)
[13:21:48.829] }
[13:21:48.829] Lazy evaluation: FALSE
[13:21:48.829] Asynchronous evaluation: FALSE
[13:21:48.829] Local evaluation: TRUE
[13:21:48.829] Environment: R_GlobalEnv
[13:21:48.829] Capture standard output: TRUE
[13:21:48.829] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:48.829] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:48.829] Packages: <none>
[13:21:48.829] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:48.829] Resolved: TRUE
[13:21:48.829] Value: 112 bytes of class ‘list’
[13:21:48.829] Early signaling: FALSE
[13:21:48.829] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:21:48.829] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:48.830] Chunk #1 of 1 ... DONE
[13:21:48.831] Launching 1 futures (chunks) ... DONE
[13:21:48.831] Resolving 1 futures (chunks) ...
[13:21:48.831] resolve() on list ...
[13:21:48.831]  recursive: 0
[13:21:48.831]  length: 1
[13:21:48.831] 
[13:21:48.831] resolved() for ‘SequentialFuture’ ...
[13:21:48.831] - state: ‘finished’
[13:21:48.831] - run: TRUE
[13:21:48.831] - result: ‘FutureResult’
[13:21:48.832] resolved() for ‘SequentialFuture’ ... done
[13:21:48.832] Future #1
[13:21:48.832] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:48.832] - nx: 1
[13:21:48.832] - relay: TRUE
[13:21:48.832] - stdout: TRUE
[13:21:48.832] - signal: TRUE
[13:21:48.832] - resignal: FALSE
[13:21:48.832] - force: TRUE
[13:21:48.832] - relayed: [n=1] FALSE
[13:21:48.832] - queued futures: [n=1] FALSE
[13:21:48.833]  - until=1
[13:21:48.833]  - relaying element #1
[13:21:48.833] - relayed: [n=1] TRUE
[13:21:48.833] - queued futures: [n=1] TRUE
[13:21:48.833] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:48.833]  length: 0 (resolved future 1)
[13:21:48.833] Relaying remaining futures
[13:21:48.833] signalConditionsASAP(NULL, pos=0) ...
[13:21:48.833] - nx: 1
[13:21:48.833] - relay: TRUE
[13:21:48.834] - stdout: TRUE
[13:21:48.834] - signal: TRUE
[13:21:48.834] - resignal: FALSE
[13:21:48.834] - force: TRUE
[13:21:48.834] - relayed: [n=1] TRUE
[13:21:48.834] - queued futures: [n=1] TRUE
 - flush all
[13:21:48.834] - relayed: [n=1] TRUE
[13:21:48.834] - queued futures: [n=1] TRUE
[13:21:48.834] signalConditionsASAP(NULL, pos=0) ... done
[13:21:48.834] resolve() on list ... DONE
[13:21:48.835]  - Number of value chunks collected: 1
[13:21:48.835] Resolving 1 futures (chunks) ... DONE
[13:21:48.835] Reducing values from 1 chunks ...
[13:21:48.835]  - Number of values collected after concatenation: 2
[13:21:48.835]  - Number of values expected: 2
[13:21:48.835] Reducing values from 1 chunks ... DONE
[13:21:48.835] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[13:21:48.835] future_lapply() ...
[13:21:48.836] Number of chunks: 1
[13:21:48.836] getGlobalsAndPackagesXApply() ...
[13:21:48.836]  - future.globals: TRUE
[13:21:48.836] getGlobalsAndPackages() ...
[13:21:48.837] Searching for globals...
[13:21:48.838] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:21:48.838] Searching for globals ... DONE
[13:21:48.838] Resolving globals: FALSE
[13:21:48.838] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:21:48.839] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:21:48.839] - globals: [1] ‘FUN’
[13:21:48.839] 
[13:21:48.839] getGlobalsAndPackages() ... DONE
[13:21:48.839]  - globals found/used: [n=1] ‘FUN’
[13:21:48.839]  - needed namespaces: [n=0] 
[13:21:48.839] Finding globals ... DONE
[13:21:48.840]  - use_args: TRUE
[13:21:48.840]  - Getting '...' globals ...
[13:21:48.840] resolve() on list ...
[13:21:48.840]  recursive: 0
[13:21:48.840]  length: 1
[13:21:48.840]  elements: ‘...’
[13:21:48.840]  length: 0 (resolved future 1)
[13:21:48.840] resolve() on list ... DONE
[13:21:48.841]    - '...' content: [n=0] 
[13:21:48.841] List of 1
[13:21:48.841]  $ ...: list()
[13:21:48.841]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:48.841]  - attr(*, "where")=List of 1
[13:21:48.841]   ..$ ...:<environment: 0x55dd73f58b98> 
[13:21:48.841]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:48.841]  - attr(*, "resolved")= logi TRUE
[13:21:48.841]  - attr(*, "total_size")= num NA
[13:21:48.843]  - Getting '...' globals ... DONE
[13:21:48.843] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:21:48.843] List of 2
[13:21:48.843]  $ ...future.FUN:function (x)  
[13:21:48.843]  $ ...          : list()
[13:21:48.843]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:48.843]  - attr(*, "where")=List of 2
[13:21:48.843]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:48.843]   ..$ ...          :<environment: 0x55dd73f58b98> 
[13:21:48.843]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:48.843]  - attr(*, "resolved")= logi FALSE
[13:21:48.843]  - attr(*, "total_size")= num 4720
[13:21:48.846] Packages to be attached in all futures: [n=0] 
[13:21:48.846] getGlobalsAndPackagesXApply() ... DONE
[13:21:48.846] Number of futures (= number of chunks): 1
[13:21:48.847] Launching 1 futures (chunks) ...
[13:21:48.847] Chunk #1 of 1 ...
[13:21:48.847]  - Finding globals in 'X' for chunk #1 ...
[13:21:48.847] getGlobalsAndPackages() ...
[13:21:48.847] Searching for globals...
[13:21:48.847] 
[13:21:48.849] Searching for globals ... DONE
[13:21:48.849] - globals: [0] <none>
[13:21:48.849] getGlobalsAndPackages() ... DONE
[13:21:48.849]    + additional globals found: [n=0] 
[13:21:48.849]    + additional namespaces needed: [n=0] 
[13:21:48.849]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:48.849]  - seeds: <none>
[13:21:48.849]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:48.850] getGlobalsAndPackages() ...
[13:21:48.850] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:48.850] Resolving globals: FALSE
[13:21:48.850] Tweak future expression to call with '...' arguments ...
[13:21:48.850] {
[13:21:48.850]     do.call(function(...) {
[13:21:48.850]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:48.850]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:48.850]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:48.850]             on.exit(options(oopts), add = TRUE)
[13:21:48.850]         }
[13:21:48.850]         {
[13:21:48.850]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:48.850]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:48.850]                 ...future.FUN(...future.X_jj, ...)
[13:21:48.850]             })
[13:21:48.850]         }
[13:21:48.850]     }, args = future.call.arguments)
[13:21:48.850] }
[13:21:48.850] Tweak future expression to call with '...' arguments ... DONE
[13:21:48.851] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:48.851] 
[13:21:48.851] getGlobalsAndPackages() ... DONE
[13:21:48.851] run() for ‘Future’ ...
[13:21:48.851] - state: ‘created’
[13:21:48.851] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:48.852] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:48.852] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:48.852]   - Field: ‘label’
[13:21:48.852]   - Field: ‘local’
[13:21:48.852]   - Field: ‘owner’
[13:21:48.852]   - Field: ‘envir’
[13:21:48.852]   - Field: ‘packages’
[13:21:48.852]   - Field: ‘gc’
[13:21:48.852]   - Field: ‘conditions’
[13:21:48.853]   - Field: ‘expr’
[13:21:48.853]   - Field: ‘uuid’
[13:21:48.853]   - Field: ‘seed’
[13:21:48.853]   - Field: ‘version’
[13:21:48.853]   - Field: ‘result’
[13:21:48.853]   - Field: ‘asynchronous’
[13:21:48.853]   - Field: ‘calls’
[13:21:48.853]   - Field: ‘globals’
[13:21:48.853]   - Field: ‘stdout’
[13:21:48.853]   - Field: ‘earlySignal’
[13:21:48.853]   - Field: ‘lazy’
[13:21:48.854]   - Field: ‘state’
[13:21:48.854] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:48.854] - Launch lazy future ...
[13:21:48.854] Packages needed by the future expression (n = 0): <none>
[13:21:48.854] Packages needed by future strategies (n = 0): <none>
[13:21:48.854] {
[13:21:48.854]     {
[13:21:48.854]         {
[13:21:48.854]             ...future.startTime <- base::Sys.time()
[13:21:48.854]             {
[13:21:48.854]                 {
[13:21:48.854]                   {
[13:21:48.854]                     base::local({
[13:21:48.854]                       has_future <- base::requireNamespace("future", 
[13:21:48.854]                         quietly = TRUE)
[13:21:48.854]                       if (has_future) {
[13:21:48.854]                         ns <- base::getNamespace("future")
[13:21:48.854]                         version <- ns[[".package"]][["version"]]
[13:21:48.854]                         if (is.null(version)) 
[13:21:48.854]                           version <- utils::packageVersion("future")
[13:21:48.854]                       }
[13:21:48.854]                       else {
[13:21:48.854]                         version <- NULL
[13:21:48.854]                       }
[13:21:48.854]                       if (!has_future || version < "1.8.0") {
[13:21:48.854]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:48.854]                           "", base::R.version$version.string), 
[13:21:48.854]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:48.854]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:48.854]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:48.854]                             "release", "version")], collapse = " "), 
[13:21:48.854]                           hostname = base::Sys.info()[["nodename"]])
[13:21:48.854]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:48.854]                           info)
[13:21:48.854]                         info <- base::paste(info, collapse = "; ")
[13:21:48.854]                         if (!has_future) {
[13:21:48.854]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:48.854]                             info)
[13:21:48.854]                         }
[13:21:48.854]                         else {
[13:21:48.854]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:48.854]                             info, version)
[13:21:48.854]                         }
[13:21:48.854]                         base::stop(msg)
[13:21:48.854]                       }
[13:21:48.854]                     })
[13:21:48.854]                   }
[13:21:48.854]                   options(future.plan = NULL)
[13:21:48.854]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:48.854]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:48.854]                 }
[13:21:48.854]                 ...future.workdir <- getwd()
[13:21:48.854]             }
[13:21:48.854]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:48.854]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:48.854]         }
[13:21:48.854]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:48.854]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:48.854]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:48.854]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:48.854]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:48.854]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:48.854]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:48.854]             base::names(...future.oldOptions))
[13:21:48.854]     }
[13:21:48.854]     if (TRUE) {
[13:21:48.854]     }
[13:21:48.854]     else {
[13:21:48.854]         if (NA) {
[13:21:48.854]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:48.854]                 open = "w")
[13:21:48.854]         }
[13:21:48.854]         else {
[13:21:48.854]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:48.854]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:48.854]         }
[13:21:48.854]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:48.854]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:48.854]             base::sink(type = "output", split = FALSE)
[13:21:48.854]             base::close(...future.stdout)
[13:21:48.854]         }, add = TRUE)
[13:21:48.854]     }
[13:21:48.854]     ...future.frame <- base::sys.nframe()
[13:21:48.854]     ...future.conditions <- base::list()
[13:21:48.854]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:48.854]     if (FALSE) {
[13:21:48.854]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:48.854]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:48.854]     }
[13:21:48.854]     ...future.result <- base::tryCatch({
[13:21:48.854]         base::withCallingHandlers({
[13:21:48.854]             ...future.value <- base::withVisible(base::local({
[13:21:48.854]                 do.call(function(...) {
[13:21:48.854]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:48.854]                   if (!identical(...future.globals.maxSize.org, 
[13:21:48.854]                     ...future.globals.maxSize)) {
[13:21:48.854]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:48.854]                     on.exit(options(oopts), add = TRUE)
[13:21:48.854]                   }
[13:21:48.854]                   {
[13:21:48.854]                     lapply(seq_along(...future.elements_ii), 
[13:21:48.854]                       FUN = function(jj) {
[13:21:48.854]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:48.854]                         ...future.FUN(...future.X_jj, ...)
[13:21:48.854]                       })
[13:21:48.854]                   }
[13:21:48.854]                 }, args = future.call.arguments)
[13:21:48.854]             }))
[13:21:48.854]             future::FutureResult(value = ...future.value$value, 
[13:21:48.854]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:48.854]                   ...future.rng), globalenv = if (FALSE) 
[13:21:48.854]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:48.854]                     ...future.globalenv.names))
[13:21:48.854]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:48.854]         }, condition = base::local({
[13:21:48.854]             c <- base::c
[13:21:48.854]             inherits <- base::inherits
[13:21:48.854]             invokeRestart <- base::invokeRestart
[13:21:48.854]             length <- base::length
[13:21:48.854]             list <- base::list
[13:21:48.854]             seq.int <- base::seq.int
[13:21:48.854]             signalCondition <- base::signalCondition
[13:21:48.854]             sys.calls <- base::sys.calls
[13:21:48.854]             `[[` <- base::`[[`
[13:21:48.854]             `+` <- base::`+`
[13:21:48.854]             `<<-` <- base::`<<-`
[13:21:48.854]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:48.854]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:48.854]                   3L)]
[13:21:48.854]             }
[13:21:48.854]             function(cond) {
[13:21:48.854]                 is_error <- inherits(cond, "error")
[13:21:48.854]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:48.854]                   NULL)
[13:21:48.854]                 if (is_error) {
[13:21:48.854]                   sessionInformation <- function() {
[13:21:48.854]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:48.854]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:48.854]                       search = base::search(), system = base::Sys.info())
[13:21:48.854]                   }
[13:21:48.854]                   ...future.conditions[[length(...future.conditions) + 
[13:21:48.854]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:48.854]                     cond$call), session = sessionInformation(), 
[13:21:48.854]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:48.854]                   signalCondition(cond)
[13:21:48.854]                 }
[13:21:48.854]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:48.854]                 "immediateCondition"))) {
[13:21:48.854]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:48.854]                   ...future.conditions[[length(...future.conditions) + 
[13:21:48.854]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:48.854]                   if (TRUE && !signal) {
[13:21:48.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:48.854]                     {
[13:21:48.854]                       inherits <- base::inherits
[13:21:48.854]                       invokeRestart <- base::invokeRestart
[13:21:48.854]                       is.null <- base::is.null
[13:21:48.854]                       muffled <- FALSE
[13:21:48.854]                       if (inherits(cond, "message")) {
[13:21:48.854]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:48.854]                         if (muffled) 
[13:21:48.854]                           invokeRestart("muffleMessage")
[13:21:48.854]                       }
[13:21:48.854]                       else if (inherits(cond, "warning")) {
[13:21:48.854]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:48.854]                         if (muffled) 
[13:21:48.854]                           invokeRestart("muffleWarning")
[13:21:48.854]                       }
[13:21:48.854]                       else if (inherits(cond, "condition")) {
[13:21:48.854]                         if (!is.null(pattern)) {
[13:21:48.854]                           computeRestarts <- base::computeRestarts
[13:21:48.854]                           grepl <- base::grepl
[13:21:48.854]                           restarts <- computeRestarts(cond)
[13:21:48.854]                           for (restart in restarts) {
[13:21:48.854]                             name <- restart$name
[13:21:48.854]                             if (is.null(name)) 
[13:21:48.854]                               next
[13:21:48.854]                             if (!grepl(pattern, name)) 
[13:21:48.854]                               next
[13:21:48.854]                             invokeRestart(restart)
[13:21:48.854]                             muffled <- TRUE
[13:21:48.854]                             break
[13:21:48.854]                           }
[13:21:48.854]                         }
[13:21:48.854]                       }
[13:21:48.854]                       invisible(muffled)
[13:21:48.854]                     }
[13:21:48.854]                     muffleCondition(cond, pattern = "^muffle")
[13:21:48.854]                   }
[13:21:48.854]                 }
[13:21:48.854]                 else {
[13:21:48.854]                   if (TRUE) {
[13:21:48.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:48.854]                     {
[13:21:48.854]                       inherits <- base::inherits
[13:21:48.854]                       invokeRestart <- base::invokeRestart
[13:21:48.854]                       is.null <- base::is.null
[13:21:48.854]                       muffled <- FALSE
[13:21:48.854]                       if (inherits(cond, "message")) {
[13:21:48.854]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:48.854]                         if (muffled) 
[13:21:48.854]                           invokeRestart("muffleMessage")
[13:21:48.854]                       }
[13:21:48.854]                       else if (inherits(cond, "warning")) {
[13:21:48.854]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:48.854]                         if (muffled) 
[13:21:48.854]                           invokeRestart("muffleWarning")
[13:21:48.854]                       }
[13:21:48.854]                       else if (inherits(cond, "condition")) {
[13:21:48.854]                         if (!is.null(pattern)) {
[13:21:48.854]                           computeRestarts <- base::computeRestarts
[13:21:48.854]                           grepl <- base::grepl
[13:21:48.854]                           restarts <- computeRestarts(cond)
[13:21:48.854]                           for (restart in restarts) {
[13:21:48.854]                             name <- restart$name
[13:21:48.854]                             if (is.null(name)) 
[13:21:48.854]                               next
[13:21:48.854]                             if (!grepl(pattern, name)) 
[13:21:48.854]                               next
[13:21:48.854]                             invokeRestart(restart)
[13:21:48.854]                             muffled <- TRUE
[13:21:48.854]                             break
[13:21:48.854]                           }
[13:21:48.854]                         }
[13:21:48.854]                       }
[13:21:48.854]                       invisible(muffled)
[13:21:48.854]                     }
[13:21:48.854]                     muffleCondition(cond, pattern = "^muffle")
[13:21:48.854]                   }
[13:21:48.854]                 }
[13:21:48.854]             }
[13:21:48.854]         }))
[13:21:48.854]     }, error = function(ex) {
[13:21:48.854]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:48.854]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:48.854]                 ...future.rng), started = ...future.startTime, 
[13:21:48.854]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:48.854]             version = "1.8"), class = "FutureResult")
[13:21:48.854]     }, finally = {
[13:21:48.854]         if (!identical(...future.workdir, getwd())) 
[13:21:48.854]             setwd(...future.workdir)
[13:21:48.854]         {
[13:21:48.854]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:48.854]                 ...future.oldOptions$nwarnings <- NULL
[13:21:48.854]             }
[13:21:48.854]             base::options(...future.oldOptions)
[13:21:48.854]             if (.Platform$OS.type == "windows") {
[13:21:48.854]                 old_names <- names(...future.oldEnvVars)
[13:21:48.854]                 envs <- base::Sys.getenv()
[13:21:48.854]                 names <- names(envs)
[13:21:48.854]                 common <- intersect(names, old_names)
[13:21:48.854]                 added <- setdiff(names, old_names)
[13:21:48.854]                 removed <- setdiff(old_names, names)
[13:21:48.854]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:48.854]                   envs[common]]
[13:21:48.854]                 NAMES <- toupper(changed)
[13:21:48.854]                 args <- list()
[13:21:48.854]                 for (kk in seq_along(NAMES)) {
[13:21:48.854]                   name <- changed[[kk]]
[13:21:48.854]                   NAME <- NAMES[[kk]]
[13:21:48.854]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:48.854]                     next
[13:21:48.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:48.854]                 }
[13:21:48.854]                 NAMES <- toupper(added)
[13:21:48.854]                 for (kk in seq_along(NAMES)) {
[13:21:48.854]                   name <- added[[kk]]
[13:21:48.854]                   NAME <- NAMES[[kk]]
[13:21:48.854]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:48.854]                     next
[13:21:48.854]                   args[[name]] <- ""
[13:21:48.854]                 }
[13:21:48.854]                 NAMES <- toupper(removed)
[13:21:48.854]                 for (kk in seq_along(NAMES)) {
[13:21:48.854]                   name <- removed[[kk]]
[13:21:48.854]                   NAME <- NAMES[[kk]]
[13:21:48.854]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:48.854]                     next
[13:21:48.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:48.854]                 }
[13:21:48.854]                 if (length(args) > 0) 
[13:21:48.854]                   base::do.call(base::Sys.setenv, args = args)
[13:21:48.854]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:48.854]             }
[13:21:48.854]             else {
[13:21:48.854]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:48.854]             }
[13:21:48.854]             {
[13:21:48.854]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:48.854]                   0L) {
[13:21:48.854]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:48.854]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:48.854]                   base::options(opts)
[13:21:48.854]                 }
[13:21:48.854]                 {
[13:21:48.854]                   {
[13:21:48.854]                     NULL
[13:21:48.854]                     RNGkind("Mersenne-Twister")
[13:21:48.854]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:48.854]                       inherits = FALSE)
[13:21:48.854]                   }
[13:21:48.854]                   options(future.plan = NULL)
[13:21:48.854]                   if (is.na(NA_character_)) 
[13:21:48.854]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:48.854]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:48.854]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:48.854]                   {
[13:21:48.854]                     future <- SequentialFuture(..., envir = envir)
[13:21:48.854]                     if (!future$lazy) 
[13:21:48.854]                       future <- run(future)
[13:21:48.854]                     invisible(future)
[13:21:48.854]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:48.854]                 }
[13:21:48.854]             }
[13:21:48.854]         }
[13:21:48.854]     })
[13:21:48.854]     if (FALSE) {
[13:21:48.854]         base::sink(type = "output", split = FALSE)
[13:21:48.854]         if (NA) {
[13:21:48.854]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:48.854]         }
[13:21:48.854]         else {
[13:21:48.854]             ...future.result["stdout"] <- base::list(NULL)
[13:21:48.854]         }
[13:21:48.854]         base::close(...future.stdout)
[13:21:48.854]         ...future.stdout <- NULL
[13:21:48.854]     }
[13:21:48.854]     ...future.result$conditions <- ...future.conditions
[13:21:48.854]     ...future.result$finished <- base::Sys.time()
[13:21:48.854]     ...future.result
[13:21:48.854] }
[13:21:48.856] assign_globals() ...
[13:21:48.856] List of 5
[13:21:48.856]  $ ...future.FUN            :function (x)  
[13:21:48.856]  $ future.call.arguments    : list()
[13:21:48.856]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:48.856]  $ ...future.elements_ii    :List of 2
[13:21:48.856]   ..$ : int 1
[13:21:48.856]   ..$ : int 0
[13:21:48.856]  $ ...future.seeds_ii       : NULL
[13:21:48.856]  $ ...future.globals.maxSize: NULL
[13:21:48.856]  - attr(*, "where")=List of 5
[13:21:48.856]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:48.856]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:48.856]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:48.856]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:48.856]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:48.856]  - attr(*, "resolved")= logi FALSE
[13:21:48.856]  - attr(*, "total_size")= num 4720
[13:21:48.856]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:48.856]  - attr(*, "already-done")= logi TRUE
[13:21:48.861] - reassign environment for ‘...future.FUN’
[13:21:48.861] - copied ‘...future.FUN’ to environment
[13:21:48.861] - copied ‘future.call.arguments’ to environment
[13:21:48.861] - copied ‘...future.elements_ii’ to environment
[13:21:48.862] - copied ‘...future.seeds_ii’ to environment
[13:21:48.862] - copied ‘...future.globals.maxSize’ to environment
[13:21:48.862] assign_globals() ... done
[13:21:48.862] plan(): Setting new future strategy stack:
[13:21:48.862] List of future strategies:
[13:21:48.862] 1. sequential:
[13:21:48.862]    - args: function (..., envir = parent.frame())
[13:21:48.862]    - tweaked: FALSE
[13:21:48.862]    - call: NULL
[13:21:48.862] plan(): nbrOfWorkers() = 1
[13:21:49.364] plan(): Setting new future strategy stack:
[13:21:49.364] List of future strategies:
[13:21:49.364] 1. sequential:
[13:21:49.364]    - args: function (..., envir = parent.frame())
[13:21:49.364]    - tweaked: FALSE
[13:21:49.364]    - call: plan(strategy)
[13:21:49.365] plan(): nbrOfWorkers() = 1
[13:21:49.365] SequentialFuture started (and completed)
[13:21:49.365] - Launch lazy future ... done
[13:21:49.365] run() for ‘SequentialFuture’ ... done
[13:21:49.365] Created future:
[13:21:49.365] SequentialFuture:
[13:21:49.365] Label: ‘future_lapply-1’
[13:21:49.365] Expression:
[13:21:49.365] {
[13:21:49.365]     do.call(function(...) {
[13:21:49.365]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:49.365]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:49.365]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:49.365]             on.exit(options(oopts), add = TRUE)
[13:21:49.365]         }
[13:21:49.365]         {
[13:21:49.365]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:49.365]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:49.365]                 ...future.FUN(...future.X_jj, ...)
[13:21:49.365]             })
[13:21:49.365]         }
[13:21:49.365]     }, args = future.call.arguments)
[13:21:49.365] }
[13:21:49.365] Lazy evaluation: FALSE
[13:21:49.365] Asynchronous evaluation: FALSE
[13:21:49.365] Local evaluation: TRUE
[13:21:49.365] Environment: R_GlobalEnv
[13:21:49.365] Capture standard output: NA
[13:21:49.365] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:49.365] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:49.365] Packages: <none>
[13:21:49.365] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:49.365] Resolved: TRUE
[13:21:49.365] Value: 112 bytes of class ‘list’
[13:21:49.365] Early signaling: FALSE
[13:21:49.365] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:21:49.365] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:49.367] Chunk #1 of 1 ... DONE
[13:21:49.367] Launching 1 futures (chunks) ... DONE
[13:21:49.367] Resolving 1 futures (chunks) ...
[13:21:49.367] resolve() on list ...
[13:21:49.367]  recursive: 0
[13:21:49.367]  length: 1
[13:21:49.367] 
[13:21:49.367] resolved() for ‘SequentialFuture’ ...
[13:21:49.367] - state: ‘finished’
[13:21:49.367] - run: TRUE
[13:21:49.367] - result: ‘FutureResult’
[13:21:49.368] resolved() for ‘SequentialFuture’ ... done
[13:21:49.368] Future #1
[13:21:49.368] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:49.368] - nx: 1
[13:21:49.368] - relay: TRUE
[13:21:49.368] - stdout: TRUE
[13:21:49.368] - signal: TRUE
[13:21:49.368] - resignal: FALSE
[13:21:49.368] - force: TRUE
[13:21:49.368] - relayed: [n=1] FALSE
[13:21:49.369] - queued futures: [n=1] FALSE
[13:21:49.369]  - until=1
[13:21:49.369]  - relaying element #1
[13:21:49.369] - relayed: [n=1] TRUE
[13:21:49.369] - queued futures: [n=1] TRUE
[13:21:49.369] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:49.369]  length: 0 (resolved future 1)
[13:21:49.369] Relaying remaining futures
[13:21:49.369] signalConditionsASAP(NULL, pos=0) ...
[13:21:49.369] - nx: 1
[13:21:49.369] - relay: TRUE
[13:21:49.370] - stdout: TRUE
[13:21:49.370] - signal: TRUE
[13:21:49.370] - resignal: FALSE
[13:21:49.370] - force: TRUE
[13:21:49.370] - relayed: [n=1] TRUE
[13:21:49.370] - queued futures: [n=1] TRUE
 - flush all
[13:21:49.370] - relayed: [n=1] TRUE
[13:21:49.370] - queued futures: [n=1] TRUE
[13:21:49.370] signalConditionsASAP(NULL, pos=0) ... done
[13:21:49.370] resolve() on list ... DONE
[13:21:49.371]  - Number of value chunks collected: 1
[13:21:49.371] Resolving 1 futures (chunks) ... DONE
[13:21:49.371] Reducing values from 1 chunks ...
[13:21:49.371]  - Number of values collected after concatenation: 2
[13:21:49.371]  - Number of values expected: 2
[13:21:49.371] Reducing values from 1 chunks ... DONE
[13:21:49.371] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[13:21:49.371] future_mapply() ...
[13:21:49.372] Number of chunks: 1
[13:21:49.372] getGlobalsAndPackagesXApply() ...
[13:21:49.372]  - future.globals: TRUE
[13:21:49.372] getGlobalsAndPackages() ...
[13:21:49.372] Searching for globals...
[13:21:49.373] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:21:49.374] Searching for globals ... DONE
[13:21:49.374] Resolving globals: FALSE
[13:21:49.374] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:21:49.374] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:21:49.376] - globals: [1] ‘FUN’
[13:21:49.376] 
[13:21:49.377] getGlobalsAndPackages() ... DONE
[13:21:49.377]  - globals found/used: [n=1] ‘FUN’
[13:21:49.377]  - needed namespaces: [n=0] 
[13:21:49.377] Finding globals ... DONE
[13:21:49.377] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:21:49.377] List of 2
[13:21:49.377]  $ ...future.FUN:function (x, y)  
[13:21:49.377]  $ MoreArgs     : NULL
[13:21:49.377]  - attr(*, "where")=List of 2
[13:21:49.377]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:49.377]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:21:49.377]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:49.377]  - attr(*, "resolved")= logi FALSE
[13:21:49.377]  - attr(*, "total_size")= num NA
[13:21:49.380] Packages to be attached in all futures: [n=0] 
[13:21:49.380] getGlobalsAndPackagesXApply() ... DONE
[13:21:49.380] Number of futures (= number of chunks): 1
[13:21:49.380] Launching 1 futures (chunks) ...
[13:21:49.380] Chunk #1 of 1 ...
[13:21:49.380]  - Finding globals in '...' for chunk #1 ...
[13:21:49.380] getGlobalsAndPackages() ...
[13:21:49.381] Searching for globals...
[13:21:49.381] 
[13:21:49.381] Searching for globals ... DONE
[13:21:49.381] - globals: [0] <none>
[13:21:49.381] getGlobalsAndPackages() ... DONE
[13:21:49.381]    + additional globals found: [n=0] 
[13:21:49.381]    + additional namespaces needed: [n=0] 
[13:21:49.381]  - Finding globals in '...' for chunk #1 ... DONE
[13:21:49.382]  - seeds: <none>
[13:21:49.382]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:49.382] getGlobalsAndPackages() ...
[13:21:49.382] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:49.382] Resolving globals: FALSE
[13:21:49.382] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[13:21:49.383] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:21:49.383] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:49.383] 
[13:21:49.383] getGlobalsAndPackages() ... DONE
[13:21:49.384] run() for ‘Future’ ...
[13:21:49.384] - state: ‘created’
[13:21:49.384] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:49.384] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:49.384] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:49.384]   - Field: ‘label’
[13:21:49.384]   - Field: ‘local’
[13:21:49.384]   - Field: ‘owner’
[13:21:49.385]   - Field: ‘envir’
[13:21:49.385]   - Field: ‘packages’
[13:21:49.385]   - Field: ‘gc’
[13:21:49.385]   - Field: ‘conditions’
[13:21:49.385]   - Field: ‘expr’
[13:21:49.385]   - Field: ‘uuid’
[13:21:49.385]   - Field: ‘seed’
[13:21:49.385]   - Field: ‘version’
[13:21:49.385]   - Field: ‘result’
[13:21:49.385]   - Field: ‘asynchronous’
[13:21:49.385]   - Field: ‘calls’
[13:21:49.386]   - Field: ‘globals’
[13:21:49.386]   - Field: ‘stdout’
[13:21:49.386]   - Field: ‘earlySignal’
[13:21:49.386]   - Field: ‘lazy’
[13:21:49.386]   - Field: ‘state’
[13:21:49.386] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:49.386] - Launch lazy future ...
[13:21:49.386] Packages needed by the future expression (n = 0): <none>
[13:21:49.386] Packages needed by future strategies (n = 0): <none>
[13:21:49.387] {
[13:21:49.387]     {
[13:21:49.387]         {
[13:21:49.387]             ...future.startTime <- base::Sys.time()
[13:21:49.387]             {
[13:21:49.387]                 {
[13:21:49.387]                   {
[13:21:49.387]                     base::local({
[13:21:49.387]                       has_future <- base::requireNamespace("future", 
[13:21:49.387]                         quietly = TRUE)
[13:21:49.387]                       if (has_future) {
[13:21:49.387]                         ns <- base::getNamespace("future")
[13:21:49.387]                         version <- ns[[".package"]][["version"]]
[13:21:49.387]                         if (is.null(version)) 
[13:21:49.387]                           version <- utils::packageVersion("future")
[13:21:49.387]                       }
[13:21:49.387]                       else {
[13:21:49.387]                         version <- NULL
[13:21:49.387]                       }
[13:21:49.387]                       if (!has_future || version < "1.8.0") {
[13:21:49.387]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:49.387]                           "", base::R.version$version.string), 
[13:21:49.387]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:49.387]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:49.387]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:49.387]                             "release", "version")], collapse = " "), 
[13:21:49.387]                           hostname = base::Sys.info()[["nodename"]])
[13:21:49.387]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:49.387]                           info)
[13:21:49.387]                         info <- base::paste(info, collapse = "; ")
[13:21:49.387]                         if (!has_future) {
[13:21:49.387]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:49.387]                             info)
[13:21:49.387]                         }
[13:21:49.387]                         else {
[13:21:49.387]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:49.387]                             info, version)
[13:21:49.387]                         }
[13:21:49.387]                         base::stop(msg)
[13:21:49.387]                       }
[13:21:49.387]                     })
[13:21:49.387]                   }
[13:21:49.387]                   options(future.plan = NULL)
[13:21:49.387]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:49.387]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:49.387]                 }
[13:21:49.387]                 ...future.workdir <- getwd()
[13:21:49.387]             }
[13:21:49.387]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:49.387]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:49.387]         }
[13:21:49.387]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:49.387]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:49.387]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:49.387]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:49.387]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:49.387]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:49.387]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:49.387]             base::names(...future.oldOptions))
[13:21:49.387]     }
[13:21:49.387]     if (FALSE) {
[13:21:49.387]     }
[13:21:49.387]     else {
[13:21:49.387]         if (FALSE) {
[13:21:49.387]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:49.387]                 open = "w")
[13:21:49.387]         }
[13:21:49.387]         else {
[13:21:49.387]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:49.387]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:49.387]         }
[13:21:49.387]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:49.387]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:49.387]             base::sink(type = "output", split = FALSE)
[13:21:49.387]             base::close(...future.stdout)
[13:21:49.387]         }, add = TRUE)
[13:21:49.387]     }
[13:21:49.387]     ...future.frame <- base::sys.nframe()
[13:21:49.387]     ...future.conditions <- base::list()
[13:21:49.387]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:49.387]     if (FALSE) {
[13:21:49.387]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:49.387]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:49.387]     }
[13:21:49.387]     ...future.result <- base::tryCatch({
[13:21:49.387]         base::withCallingHandlers({
[13:21:49.387]             ...future.value <- base::withVisible(base::local({
[13:21:49.387]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:49.387]                 if (!identical(...future.globals.maxSize.org, 
[13:21:49.387]                   ...future.globals.maxSize)) {
[13:21:49.387]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:49.387]                   on.exit(options(oopts), add = TRUE)
[13:21:49.387]                 }
[13:21:49.387]                 {
[13:21:49.387]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:21:49.387]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:21:49.387]                     USE.NAMES = FALSE)
[13:21:49.387]                   do.call(mapply, args = args)
[13:21:49.387]                 }
[13:21:49.387]             }))
[13:21:49.387]             future::FutureResult(value = ...future.value$value, 
[13:21:49.387]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:49.387]                   ...future.rng), globalenv = if (FALSE) 
[13:21:49.387]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:49.387]                     ...future.globalenv.names))
[13:21:49.387]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:49.387]         }, condition = base::local({
[13:21:49.387]             c <- base::c
[13:21:49.387]             inherits <- base::inherits
[13:21:49.387]             invokeRestart <- base::invokeRestart
[13:21:49.387]             length <- base::length
[13:21:49.387]             list <- base::list
[13:21:49.387]             seq.int <- base::seq.int
[13:21:49.387]             signalCondition <- base::signalCondition
[13:21:49.387]             sys.calls <- base::sys.calls
[13:21:49.387]             `[[` <- base::`[[`
[13:21:49.387]             `+` <- base::`+`
[13:21:49.387]             `<<-` <- base::`<<-`
[13:21:49.387]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:49.387]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:49.387]                   3L)]
[13:21:49.387]             }
[13:21:49.387]             function(cond) {
[13:21:49.387]                 is_error <- inherits(cond, "error")
[13:21:49.387]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:49.387]                   NULL)
[13:21:49.387]                 if (is_error) {
[13:21:49.387]                   sessionInformation <- function() {
[13:21:49.387]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:49.387]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:49.387]                       search = base::search(), system = base::Sys.info())
[13:21:49.387]                   }
[13:21:49.387]                   ...future.conditions[[length(...future.conditions) + 
[13:21:49.387]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:49.387]                     cond$call), session = sessionInformation(), 
[13:21:49.387]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:49.387]                   signalCondition(cond)
[13:21:49.387]                 }
[13:21:49.387]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:49.387]                 "immediateCondition"))) {
[13:21:49.387]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:49.387]                   ...future.conditions[[length(...future.conditions) + 
[13:21:49.387]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:49.387]                   if (TRUE && !signal) {
[13:21:49.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:49.387]                     {
[13:21:49.387]                       inherits <- base::inherits
[13:21:49.387]                       invokeRestart <- base::invokeRestart
[13:21:49.387]                       is.null <- base::is.null
[13:21:49.387]                       muffled <- FALSE
[13:21:49.387]                       if (inherits(cond, "message")) {
[13:21:49.387]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:49.387]                         if (muffled) 
[13:21:49.387]                           invokeRestart("muffleMessage")
[13:21:49.387]                       }
[13:21:49.387]                       else if (inherits(cond, "warning")) {
[13:21:49.387]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:49.387]                         if (muffled) 
[13:21:49.387]                           invokeRestart("muffleWarning")
[13:21:49.387]                       }
[13:21:49.387]                       else if (inherits(cond, "condition")) {
[13:21:49.387]                         if (!is.null(pattern)) {
[13:21:49.387]                           computeRestarts <- base::computeRestarts
[13:21:49.387]                           grepl <- base::grepl
[13:21:49.387]                           restarts <- computeRestarts(cond)
[13:21:49.387]                           for (restart in restarts) {
[13:21:49.387]                             name <- restart$name
[13:21:49.387]                             if (is.null(name)) 
[13:21:49.387]                               next
[13:21:49.387]                             if (!grepl(pattern, name)) 
[13:21:49.387]                               next
[13:21:49.387]                             invokeRestart(restart)
[13:21:49.387]                             muffled <- TRUE
[13:21:49.387]                             break
[13:21:49.387]                           }
[13:21:49.387]                         }
[13:21:49.387]                       }
[13:21:49.387]                       invisible(muffled)
[13:21:49.387]                     }
[13:21:49.387]                     muffleCondition(cond, pattern = "^muffle")
[13:21:49.387]                   }
[13:21:49.387]                 }
[13:21:49.387]                 else {
[13:21:49.387]                   if (TRUE) {
[13:21:49.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:49.387]                     {
[13:21:49.387]                       inherits <- base::inherits
[13:21:49.387]                       invokeRestart <- base::invokeRestart
[13:21:49.387]                       is.null <- base::is.null
[13:21:49.387]                       muffled <- FALSE
[13:21:49.387]                       if (inherits(cond, "message")) {
[13:21:49.387]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:49.387]                         if (muffled) 
[13:21:49.387]                           invokeRestart("muffleMessage")
[13:21:49.387]                       }
[13:21:49.387]                       else if (inherits(cond, "warning")) {
[13:21:49.387]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:49.387]                         if (muffled) 
[13:21:49.387]                           invokeRestart("muffleWarning")
[13:21:49.387]                       }
[13:21:49.387]                       else if (inherits(cond, "condition")) {
[13:21:49.387]                         if (!is.null(pattern)) {
[13:21:49.387]                           computeRestarts <- base::computeRestarts
[13:21:49.387]                           grepl <- base::grepl
[13:21:49.387]                           restarts <- computeRestarts(cond)
[13:21:49.387]                           for (restart in restarts) {
[13:21:49.387]                             name <- restart$name
[13:21:49.387]                             if (is.null(name)) 
[13:21:49.387]                               next
[13:21:49.387]                             if (!grepl(pattern, name)) 
[13:21:49.387]                               next
[13:21:49.387]                             invokeRestart(restart)
[13:21:49.387]                             muffled <- TRUE
[13:21:49.387]                             break
[13:21:49.387]                           }
[13:21:49.387]                         }
[13:21:49.387]                       }
[13:21:49.387]                       invisible(muffled)
[13:21:49.387]                     }
[13:21:49.387]                     muffleCondition(cond, pattern = "^muffle")
[13:21:49.387]                   }
[13:21:49.387]                 }
[13:21:49.387]             }
[13:21:49.387]         }))
[13:21:49.387]     }, error = function(ex) {
[13:21:49.387]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:49.387]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:49.387]                 ...future.rng), started = ...future.startTime, 
[13:21:49.387]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:49.387]             version = "1.8"), class = "FutureResult")
[13:21:49.387]     }, finally = {
[13:21:49.387]         if (!identical(...future.workdir, getwd())) 
[13:21:49.387]             setwd(...future.workdir)
[13:21:49.387]         {
[13:21:49.387]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:49.387]                 ...future.oldOptions$nwarnings <- NULL
[13:21:49.387]             }
[13:21:49.387]             base::options(...future.oldOptions)
[13:21:49.387]             if (.Platform$OS.type == "windows") {
[13:21:49.387]                 old_names <- names(...future.oldEnvVars)
[13:21:49.387]                 envs <- base::Sys.getenv()
[13:21:49.387]                 names <- names(envs)
[13:21:49.387]                 common <- intersect(names, old_names)
[13:21:49.387]                 added <- setdiff(names, old_names)
[13:21:49.387]                 removed <- setdiff(old_names, names)
[13:21:49.387]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:49.387]                   envs[common]]
[13:21:49.387]                 NAMES <- toupper(changed)
[13:21:49.387]                 args <- list()
[13:21:49.387]                 for (kk in seq_along(NAMES)) {
[13:21:49.387]                   name <- changed[[kk]]
[13:21:49.387]                   NAME <- NAMES[[kk]]
[13:21:49.387]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:49.387]                     next
[13:21:49.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:49.387]                 }
[13:21:49.387]                 NAMES <- toupper(added)
[13:21:49.387]                 for (kk in seq_along(NAMES)) {
[13:21:49.387]                   name <- added[[kk]]
[13:21:49.387]                   NAME <- NAMES[[kk]]
[13:21:49.387]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:49.387]                     next
[13:21:49.387]                   args[[name]] <- ""
[13:21:49.387]                 }
[13:21:49.387]                 NAMES <- toupper(removed)
[13:21:49.387]                 for (kk in seq_along(NAMES)) {
[13:21:49.387]                   name <- removed[[kk]]
[13:21:49.387]                   NAME <- NAMES[[kk]]
[13:21:49.387]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:49.387]                     next
[13:21:49.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:49.387]                 }
[13:21:49.387]                 if (length(args) > 0) 
[13:21:49.387]                   base::do.call(base::Sys.setenv, args = args)
[13:21:49.387]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:49.387]             }
[13:21:49.387]             else {
[13:21:49.387]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:49.387]             }
[13:21:49.387]             {
[13:21:49.387]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:49.387]                   0L) {
[13:21:49.387]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:49.387]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:49.387]                   base::options(opts)
[13:21:49.387]                 }
[13:21:49.387]                 {
[13:21:49.387]                   {
[13:21:49.387]                     NULL
[13:21:49.387]                     RNGkind("Mersenne-Twister")
[13:21:49.387]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:49.387]                       inherits = FALSE)
[13:21:49.387]                   }
[13:21:49.387]                   options(future.plan = NULL)
[13:21:49.387]                   if (is.na(NA_character_)) 
[13:21:49.387]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:49.387]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:49.387]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:49.387]                   {
[13:21:49.387]                     future <- SequentialFuture(..., envir = envir)
[13:21:49.387]                     if (!future$lazy) 
[13:21:49.387]                       future <- run(future)
[13:21:49.387]                     invisible(future)
[13:21:49.387]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:49.387]                 }
[13:21:49.387]             }
[13:21:49.387]         }
[13:21:49.387]     })
[13:21:49.387]     if (TRUE) {
[13:21:49.387]         base::sink(type = "output", split = FALSE)
[13:21:49.387]         if (FALSE) {
[13:21:49.387]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:49.387]         }
[13:21:49.387]         else {
[13:21:49.387]             ...future.result["stdout"] <- base::list(NULL)
[13:21:49.387]         }
[13:21:49.387]         base::close(...future.stdout)
[13:21:49.387]         ...future.stdout <- NULL
[13:21:49.387]     }
[13:21:49.387]     ...future.result$conditions <- ...future.conditions
[13:21:49.387]     ...future.result$finished <- base::Sys.time()
[13:21:49.387]     ...future.result
[13:21:49.387] }
[13:21:49.389] assign_globals() ...
[13:21:49.389] List of 5
[13:21:49.389]  $ ...future.FUN            :function (x, y)  
[13:21:49.389]  $ MoreArgs                 : NULL
[13:21:49.389]  $ ...future.elements_ii    :List of 2
[13:21:49.389]   ..$ :List of 2
[13:21:49.389]   .. ..$ : int 1
[13:21:49.389]   .. ..$ : int 0
[13:21:49.389]   ..$ :List of 2
[13:21:49.389]   .. ..$ : int 0
[13:21:49.389]   .. ..$ : int 1
[13:21:49.389]  $ ...future.seeds_ii       : NULL
[13:21:49.389]  $ ...future.globals.maxSize: NULL
[13:21:49.389]  - attr(*, "where")=List of 5
[13:21:49.389]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:49.389]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:21:49.389]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:49.389]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:49.389]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:49.389]  - attr(*, "resolved")= logi FALSE
[13:21:49.389]  - attr(*, "total_size")= num 6480
[13:21:49.389]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:49.389]  - attr(*, "already-done")= logi TRUE
[13:21:49.394] - reassign environment for ‘...future.FUN’
[13:21:49.394] - copied ‘...future.FUN’ to environment
[13:21:49.395] - copied ‘MoreArgs’ to environment
[13:21:49.395] - copied ‘...future.elements_ii’ to environment
[13:21:49.395] - copied ‘...future.seeds_ii’ to environment
[13:21:49.395] - copied ‘...future.globals.maxSize’ to environment
[13:21:49.395] assign_globals() ... done
[13:21:49.395] plan(): Setting new future strategy stack:
[13:21:49.395] List of future strategies:
[13:21:49.395] 1. sequential:
[13:21:49.395]    - args: function (..., envir = parent.frame())
[13:21:49.395]    - tweaked: FALSE
[13:21:49.395]    - call: NULL
[13:21:49.396] plan(): nbrOfWorkers() = 1
[13:21:49.898] plan(): Setting new future strategy stack:
[13:21:49.898] List of future strategies:
[13:21:49.898] 1. sequential:
[13:21:49.898]    - args: function (..., envir = parent.frame())
[13:21:49.898]    - tweaked: FALSE
[13:21:49.898]    - call: plan(strategy)
[13:21:49.898] plan(): nbrOfWorkers() = 1
[13:21:49.899] SequentialFuture started (and completed)
[13:21:49.899] - Launch lazy future ... done
[13:21:49.899] run() for ‘SequentialFuture’ ... done
[13:21:49.899] Created future:
[13:21:49.899] SequentialFuture:
[13:21:49.899] Label: ‘future_mapply-1’
[13:21:49.899] Expression:
[13:21:49.899] {
[13:21:49.899]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:49.899]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:49.899]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:49.899]         on.exit(options(oopts), add = TRUE)
[13:21:49.899]     }
[13:21:49.899]     {
[13:21:49.899]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:21:49.899]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:21:49.899]         do.call(mapply, args = args)
[13:21:49.899]     }
[13:21:49.899] }
[13:21:49.899] Lazy evaluation: FALSE
[13:21:49.899] Asynchronous evaluation: FALSE
[13:21:49.899] Local evaluation: TRUE
[13:21:49.899] Environment: R_GlobalEnv
[13:21:49.899] Capture standard output: FALSE
[13:21:49.899] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:49.899] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:49.899] Packages: <none>
[13:21:49.899] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:49.899] Resolved: TRUE
[13:21:49.899] Value: 224 bytes of class ‘list’
[13:21:49.899] Early signaling: FALSE
[13:21:49.899] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:21:49.899] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:49.900] Chunk #1 of 1 ... DONE
[13:21:49.900] Launching 1 futures (chunks) ... DONE
[13:21:49.900] Resolving 1 futures (chunks) ...
[13:21:49.901] resolve() on list ...
[13:21:49.901]  recursive: 0
[13:21:49.901]  length: 1
[13:21:49.901] 
[13:21:49.901] resolved() for ‘SequentialFuture’ ...
[13:21:49.901] - state: ‘finished’
[13:21:49.901] - run: TRUE
[13:21:49.901] - result: ‘FutureResult’
[13:21:49.901] resolved() for ‘SequentialFuture’ ... done
[13:21:49.901] Future #1
[13:21:49.902] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:49.902] - nx: 1
[13:21:49.902] - relay: TRUE
[13:21:49.902] - stdout: TRUE
[13:21:49.902] - signal: TRUE
[13:21:49.902] - resignal: FALSE
[13:21:49.902] - force: TRUE
[13:21:49.902] - relayed: [n=1] FALSE
[13:21:49.902] - queued futures: [n=1] FALSE
[13:21:49.902]  - until=1
[13:21:49.902]  - relaying element #1
[13:21:49.904] - relayed: [n=1] TRUE
[13:21:49.905] - queued futures: [n=1] TRUE
[13:21:49.905] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:49.905]  length: 0 (resolved future 1)
[13:21:49.905] Relaying remaining futures
[13:21:49.905] signalConditionsASAP(NULL, pos=0) ...
[13:21:49.905] - nx: 1
[13:21:49.905] - relay: TRUE
[13:21:49.905] - stdout: TRUE
[13:21:49.905] - signal: TRUE
[13:21:49.905] - resignal: FALSE
[13:21:49.905] - force: TRUE
[13:21:49.905] - relayed: [n=1] TRUE
[13:21:49.906] - queued futures: [n=1] TRUE
 - flush all
[13:21:49.906] - relayed: [n=1] TRUE
[13:21:49.906] - queued futures: [n=1] TRUE
[13:21:49.906] signalConditionsASAP(NULL, pos=0) ... done
[13:21:49.906] resolve() on list ... DONE
[13:21:49.906]  - Number of value chunks collected: 1
[13:21:49.906] Resolving 1 futures (chunks) ... DONE
[13:21:49.906] Reducing values from 1 chunks ...
[13:21:49.906]  - Number of values collected after concatenation: 2
[13:21:49.907]  - Number of values expected: 2
[13:21:49.907] Reducing values from 1 chunks ... DONE
[13:21:49.907] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[13:21:49.907] future_mapply() ...
[13:21:49.907] Number of chunks: 1
[13:21:49.907] getGlobalsAndPackagesXApply() ...
[13:21:49.907]  - future.globals: TRUE
[13:21:49.908] getGlobalsAndPackages() ...
[13:21:49.908] Searching for globals...
[13:21:49.909] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:21:49.909] Searching for globals ... DONE
[13:21:49.909] Resolving globals: FALSE
[13:21:49.910] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:21:49.910] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:21:49.910] - globals: [1] ‘FUN’
[13:21:49.911] 
[13:21:49.911] getGlobalsAndPackages() ... DONE
[13:21:49.911]  - globals found/used: [n=1] ‘FUN’
[13:21:49.911]  - needed namespaces: [n=0] 
[13:21:49.911] Finding globals ... DONE
[13:21:49.911] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:21:49.911] List of 2
[13:21:49.911]  $ ...future.FUN:function (x, y)  
[13:21:49.911]  $ MoreArgs     : NULL
[13:21:49.911]  - attr(*, "where")=List of 2
[13:21:49.911]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:49.911]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:21:49.911]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:49.911]  - attr(*, "resolved")= logi FALSE
[13:21:49.911]  - attr(*, "total_size")= num NA
[13:21:49.914] Packages to be attached in all futures: [n=0] 
[13:21:49.914] getGlobalsAndPackagesXApply() ... DONE
[13:21:49.914] Number of futures (= number of chunks): 1
[13:21:49.914] Launching 1 futures (chunks) ...
[13:21:49.914] Chunk #1 of 1 ...
[13:21:49.914]  - Finding globals in '...' for chunk #1 ...
[13:21:49.914] getGlobalsAndPackages() ...
[13:21:49.915] Searching for globals...
[13:21:49.915] 
[13:21:49.915] Searching for globals ... DONE
[13:21:49.915] - globals: [0] <none>
[13:21:49.915] getGlobalsAndPackages() ... DONE
[13:21:49.915]    + additional globals found: [n=0] 
[13:21:49.915]    + additional namespaces needed: [n=0] 
[13:21:49.915]  - Finding globals in '...' for chunk #1 ... DONE
[13:21:49.916]  - seeds: <none>
[13:21:49.916]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:49.916] getGlobalsAndPackages() ...
[13:21:49.916] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:49.916] Resolving globals: FALSE
[13:21:49.916] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[13:21:49.917] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:21:49.917] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:49.917] 
[13:21:49.917] getGlobalsAndPackages() ... DONE
[13:21:49.917] run() for ‘Future’ ...
[13:21:49.918] - state: ‘created’
[13:21:49.918] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:49.918] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:49.918] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:49.918]   - Field: ‘label’
[13:21:49.918]   - Field: ‘local’
[13:21:49.918]   - Field: ‘owner’
[13:21:49.918]   - Field: ‘envir’
[13:21:49.919]   - Field: ‘packages’
[13:21:49.919]   - Field: ‘gc’
[13:21:49.919]   - Field: ‘conditions’
[13:21:49.919]   - Field: ‘expr’
[13:21:49.919]   - Field: ‘uuid’
[13:21:49.919]   - Field: ‘seed’
[13:21:49.919]   - Field: ‘version’
[13:21:49.919]   - Field: ‘result’
[13:21:49.919]   - Field: ‘asynchronous’
[13:21:49.919]   - Field: ‘calls’
[13:21:49.920]   - Field: ‘globals’
[13:21:49.920]   - Field: ‘stdout’
[13:21:49.920]   - Field: ‘earlySignal’
[13:21:49.920]   - Field: ‘lazy’
[13:21:49.920]   - Field: ‘state’
[13:21:49.920] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:49.920] - Launch lazy future ...
[13:21:49.920] Packages needed by the future expression (n = 0): <none>
[13:21:49.920] Packages needed by future strategies (n = 0): <none>
[13:21:49.921] {
[13:21:49.921]     {
[13:21:49.921]         {
[13:21:49.921]             ...future.startTime <- base::Sys.time()
[13:21:49.921]             {
[13:21:49.921]                 {
[13:21:49.921]                   {
[13:21:49.921]                     base::local({
[13:21:49.921]                       has_future <- base::requireNamespace("future", 
[13:21:49.921]                         quietly = TRUE)
[13:21:49.921]                       if (has_future) {
[13:21:49.921]                         ns <- base::getNamespace("future")
[13:21:49.921]                         version <- ns[[".package"]][["version"]]
[13:21:49.921]                         if (is.null(version)) 
[13:21:49.921]                           version <- utils::packageVersion("future")
[13:21:49.921]                       }
[13:21:49.921]                       else {
[13:21:49.921]                         version <- NULL
[13:21:49.921]                       }
[13:21:49.921]                       if (!has_future || version < "1.8.0") {
[13:21:49.921]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:49.921]                           "", base::R.version$version.string), 
[13:21:49.921]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:49.921]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:49.921]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:49.921]                             "release", "version")], collapse = " "), 
[13:21:49.921]                           hostname = base::Sys.info()[["nodename"]])
[13:21:49.921]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:49.921]                           info)
[13:21:49.921]                         info <- base::paste(info, collapse = "; ")
[13:21:49.921]                         if (!has_future) {
[13:21:49.921]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:49.921]                             info)
[13:21:49.921]                         }
[13:21:49.921]                         else {
[13:21:49.921]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:49.921]                             info, version)
[13:21:49.921]                         }
[13:21:49.921]                         base::stop(msg)
[13:21:49.921]                       }
[13:21:49.921]                     })
[13:21:49.921]                   }
[13:21:49.921]                   options(future.plan = NULL)
[13:21:49.921]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:49.921]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:49.921]                 }
[13:21:49.921]                 ...future.workdir <- getwd()
[13:21:49.921]             }
[13:21:49.921]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:49.921]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:49.921]         }
[13:21:49.921]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:49.921]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:49.921]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:49.921]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:49.921]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:49.921]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:49.921]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:49.921]             base::names(...future.oldOptions))
[13:21:49.921]     }
[13:21:49.921]     if (FALSE) {
[13:21:49.921]     }
[13:21:49.921]     else {
[13:21:49.921]         if (TRUE) {
[13:21:49.921]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:49.921]                 open = "w")
[13:21:49.921]         }
[13:21:49.921]         else {
[13:21:49.921]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:49.921]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:49.921]         }
[13:21:49.921]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:49.921]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:49.921]             base::sink(type = "output", split = FALSE)
[13:21:49.921]             base::close(...future.stdout)
[13:21:49.921]         }, add = TRUE)
[13:21:49.921]     }
[13:21:49.921]     ...future.frame <- base::sys.nframe()
[13:21:49.921]     ...future.conditions <- base::list()
[13:21:49.921]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:49.921]     if (FALSE) {
[13:21:49.921]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:49.921]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:49.921]     }
[13:21:49.921]     ...future.result <- base::tryCatch({
[13:21:49.921]         base::withCallingHandlers({
[13:21:49.921]             ...future.value <- base::withVisible(base::local({
[13:21:49.921]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:49.921]                 if (!identical(...future.globals.maxSize.org, 
[13:21:49.921]                   ...future.globals.maxSize)) {
[13:21:49.921]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:49.921]                   on.exit(options(oopts), add = TRUE)
[13:21:49.921]                 }
[13:21:49.921]                 {
[13:21:49.921]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:21:49.921]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:21:49.921]                     USE.NAMES = FALSE)
[13:21:49.921]                   do.call(mapply, args = args)
[13:21:49.921]                 }
[13:21:49.921]             }))
[13:21:49.921]             future::FutureResult(value = ...future.value$value, 
[13:21:49.921]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:49.921]                   ...future.rng), globalenv = if (FALSE) 
[13:21:49.921]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:49.921]                     ...future.globalenv.names))
[13:21:49.921]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:49.921]         }, condition = base::local({
[13:21:49.921]             c <- base::c
[13:21:49.921]             inherits <- base::inherits
[13:21:49.921]             invokeRestart <- base::invokeRestart
[13:21:49.921]             length <- base::length
[13:21:49.921]             list <- base::list
[13:21:49.921]             seq.int <- base::seq.int
[13:21:49.921]             signalCondition <- base::signalCondition
[13:21:49.921]             sys.calls <- base::sys.calls
[13:21:49.921]             `[[` <- base::`[[`
[13:21:49.921]             `+` <- base::`+`
[13:21:49.921]             `<<-` <- base::`<<-`
[13:21:49.921]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:49.921]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:49.921]                   3L)]
[13:21:49.921]             }
[13:21:49.921]             function(cond) {
[13:21:49.921]                 is_error <- inherits(cond, "error")
[13:21:49.921]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:49.921]                   NULL)
[13:21:49.921]                 if (is_error) {
[13:21:49.921]                   sessionInformation <- function() {
[13:21:49.921]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:49.921]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:49.921]                       search = base::search(), system = base::Sys.info())
[13:21:49.921]                   }
[13:21:49.921]                   ...future.conditions[[length(...future.conditions) + 
[13:21:49.921]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:49.921]                     cond$call), session = sessionInformation(), 
[13:21:49.921]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:49.921]                   signalCondition(cond)
[13:21:49.921]                 }
[13:21:49.921]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:49.921]                 "immediateCondition"))) {
[13:21:49.921]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:49.921]                   ...future.conditions[[length(...future.conditions) + 
[13:21:49.921]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:49.921]                   if (TRUE && !signal) {
[13:21:49.921]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:49.921]                     {
[13:21:49.921]                       inherits <- base::inherits
[13:21:49.921]                       invokeRestart <- base::invokeRestart
[13:21:49.921]                       is.null <- base::is.null
[13:21:49.921]                       muffled <- FALSE
[13:21:49.921]                       if (inherits(cond, "message")) {
[13:21:49.921]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:49.921]                         if (muffled) 
[13:21:49.921]                           invokeRestart("muffleMessage")
[13:21:49.921]                       }
[13:21:49.921]                       else if (inherits(cond, "warning")) {
[13:21:49.921]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:49.921]                         if (muffled) 
[13:21:49.921]                           invokeRestart("muffleWarning")
[13:21:49.921]                       }
[13:21:49.921]                       else if (inherits(cond, "condition")) {
[13:21:49.921]                         if (!is.null(pattern)) {
[13:21:49.921]                           computeRestarts <- base::computeRestarts
[13:21:49.921]                           grepl <- base::grepl
[13:21:49.921]                           restarts <- computeRestarts(cond)
[13:21:49.921]                           for (restart in restarts) {
[13:21:49.921]                             name <- restart$name
[13:21:49.921]                             if (is.null(name)) 
[13:21:49.921]                               next
[13:21:49.921]                             if (!grepl(pattern, name)) 
[13:21:49.921]                               next
[13:21:49.921]                             invokeRestart(restart)
[13:21:49.921]                             muffled <- TRUE
[13:21:49.921]                             break
[13:21:49.921]                           }
[13:21:49.921]                         }
[13:21:49.921]                       }
[13:21:49.921]                       invisible(muffled)
[13:21:49.921]                     }
[13:21:49.921]                     muffleCondition(cond, pattern = "^muffle")
[13:21:49.921]                   }
[13:21:49.921]                 }
[13:21:49.921]                 else {
[13:21:49.921]                   if (TRUE) {
[13:21:49.921]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:49.921]                     {
[13:21:49.921]                       inherits <- base::inherits
[13:21:49.921]                       invokeRestart <- base::invokeRestart
[13:21:49.921]                       is.null <- base::is.null
[13:21:49.921]                       muffled <- FALSE
[13:21:49.921]                       if (inherits(cond, "message")) {
[13:21:49.921]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:49.921]                         if (muffled) 
[13:21:49.921]                           invokeRestart("muffleMessage")
[13:21:49.921]                       }
[13:21:49.921]                       else if (inherits(cond, "warning")) {
[13:21:49.921]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:49.921]                         if (muffled) 
[13:21:49.921]                           invokeRestart("muffleWarning")
[13:21:49.921]                       }
[13:21:49.921]                       else if (inherits(cond, "condition")) {
[13:21:49.921]                         if (!is.null(pattern)) {
[13:21:49.921]                           computeRestarts <- base::computeRestarts
[13:21:49.921]                           grepl <- base::grepl
[13:21:49.921]                           restarts <- computeRestarts(cond)
[13:21:49.921]                           for (restart in restarts) {
[13:21:49.921]                             name <- restart$name
[13:21:49.921]                             if (is.null(name)) 
[13:21:49.921]                               next
[13:21:49.921]                             if (!grepl(pattern, name)) 
[13:21:49.921]                               next
[13:21:49.921]                             invokeRestart(restart)
[13:21:49.921]                             muffled <- TRUE
[13:21:49.921]                             break
[13:21:49.921]                           }
[13:21:49.921]                         }
[13:21:49.921]                       }
[13:21:49.921]                       invisible(muffled)
[13:21:49.921]                     }
[13:21:49.921]                     muffleCondition(cond, pattern = "^muffle")
[13:21:49.921]                   }
[13:21:49.921]                 }
[13:21:49.921]             }
[13:21:49.921]         }))
[13:21:49.921]     }, error = function(ex) {
[13:21:49.921]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:49.921]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:49.921]                 ...future.rng), started = ...future.startTime, 
[13:21:49.921]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:49.921]             version = "1.8"), class = "FutureResult")
[13:21:49.921]     }, finally = {
[13:21:49.921]         if (!identical(...future.workdir, getwd())) 
[13:21:49.921]             setwd(...future.workdir)
[13:21:49.921]         {
[13:21:49.921]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:49.921]                 ...future.oldOptions$nwarnings <- NULL
[13:21:49.921]             }
[13:21:49.921]             base::options(...future.oldOptions)
[13:21:49.921]             if (.Platform$OS.type == "windows") {
[13:21:49.921]                 old_names <- names(...future.oldEnvVars)
[13:21:49.921]                 envs <- base::Sys.getenv()
[13:21:49.921]                 names <- names(envs)
[13:21:49.921]                 common <- intersect(names, old_names)
[13:21:49.921]                 added <- setdiff(names, old_names)
[13:21:49.921]                 removed <- setdiff(old_names, names)
[13:21:49.921]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:49.921]                   envs[common]]
[13:21:49.921]                 NAMES <- toupper(changed)
[13:21:49.921]                 args <- list()
[13:21:49.921]                 for (kk in seq_along(NAMES)) {
[13:21:49.921]                   name <- changed[[kk]]
[13:21:49.921]                   NAME <- NAMES[[kk]]
[13:21:49.921]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:49.921]                     next
[13:21:49.921]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:49.921]                 }
[13:21:49.921]                 NAMES <- toupper(added)
[13:21:49.921]                 for (kk in seq_along(NAMES)) {
[13:21:49.921]                   name <- added[[kk]]
[13:21:49.921]                   NAME <- NAMES[[kk]]
[13:21:49.921]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:49.921]                     next
[13:21:49.921]                   args[[name]] <- ""
[13:21:49.921]                 }
[13:21:49.921]                 NAMES <- toupper(removed)
[13:21:49.921]                 for (kk in seq_along(NAMES)) {
[13:21:49.921]                   name <- removed[[kk]]
[13:21:49.921]                   NAME <- NAMES[[kk]]
[13:21:49.921]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:49.921]                     next
[13:21:49.921]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:49.921]                 }
[13:21:49.921]                 if (length(args) > 0) 
[13:21:49.921]                   base::do.call(base::Sys.setenv, args = args)
[13:21:49.921]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:49.921]             }
[13:21:49.921]             else {
[13:21:49.921]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:49.921]             }
[13:21:49.921]             {
[13:21:49.921]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:49.921]                   0L) {
[13:21:49.921]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:49.921]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:49.921]                   base::options(opts)
[13:21:49.921]                 }
[13:21:49.921]                 {
[13:21:49.921]                   {
[13:21:49.921]                     NULL
[13:21:49.921]                     RNGkind("Mersenne-Twister")
[13:21:49.921]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:49.921]                       inherits = FALSE)
[13:21:49.921]                   }
[13:21:49.921]                   options(future.plan = NULL)
[13:21:49.921]                   if (is.na(NA_character_)) 
[13:21:49.921]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:49.921]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:49.921]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:49.921]                   {
[13:21:49.921]                     future <- SequentialFuture(..., envir = envir)
[13:21:49.921]                     if (!future$lazy) 
[13:21:49.921]                       future <- run(future)
[13:21:49.921]                     invisible(future)
[13:21:49.921]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:49.921]                 }
[13:21:49.921]             }
[13:21:49.921]         }
[13:21:49.921]     })
[13:21:49.921]     if (TRUE) {
[13:21:49.921]         base::sink(type = "output", split = FALSE)
[13:21:49.921]         if (TRUE) {
[13:21:49.921]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:49.921]         }
[13:21:49.921]         else {
[13:21:49.921]             ...future.result["stdout"] <- base::list(NULL)
[13:21:49.921]         }
[13:21:49.921]         base::close(...future.stdout)
[13:21:49.921]         ...future.stdout <- NULL
[13:21:49.921]     }
[13:21:49.921]     ...future.result$conditions <- ...future.conditions
[13:21:49.921]     ...future.result$finished <- base::Sys.time()
[13:21:49.921]     ...future.result
[13:21:49.921] }
[13:21:49.923] assign_globals() ...
[13:21:49.923] List of 5
[13:21:49.923]  $ ...future.FUN            :function (x, y)  
[13:21:49.923]  $ MoreArgs                 : NULL
[13:21:49.923]  $ ...future.elements_ii    :List of 2
[13:21:49.923]   ..$ :List of 2
[13:21:49.923]   .. ..$ : int 1
[13:21:49.923]   .. ..$ : int 0
[13:21:49.923]   ..$ :List of 2
[13:21:49.923]   .. ..$ : int 0
[13:21:49.923]   .. ..$ : int 1
[13:21:49.923]  $ ...future.seeds_ii       : NULL
[13:21:49.923]  $ ...future.globals.maxSize: NULL
[13:21:49.923]  - attr(*, "where")=List of 5
[13:21:49.923]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:49.923]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:21:49.923]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:49.923]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:49.923]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:49.923]  - attr(*, "resolved")= logi FALSE
[13:21:49.923]  - attr(*, "total_size")= num 6480
[13:21:49.923]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:49.923]  - attr(*, "already-done")= logi TRUE
[13:21:49.930] - reassign environment for ‘...future.FUN’
[13:21:49.930] - copied ‘...future.FUN’ to environment
[13:21:49.930] - copied ‘MoreArgs’ to environment
[13:21:49.930] - copied ‘...future.elements_ii’ to environment
[13:21:49.930] - copied ‘...future.seeds_ii’ to environment
[13:21:49.931] - copied ‘...future.globals.maxSize’ to environment
[13:21:49.931] assign_globals() ... done
[13:21:49.931] plan(): Setting new future strategy stack:
[13:21:49.931] List of future strategies:
[13:21:49.931] 1. sequential:
[13:21:49.931]    - args: function (..., envir = parent.frame())
[13:21:49.931]    - tweaked: FALSE
[13:21:49.931]    - call: NULL
[13:21:49.931] plan(): nbrOfWorkers() = 1
[13:21:50.433] plan(): Setting new future strategy stack:
[13:21:50.433] List of future strategies:
[13:21:50.433] 1. sequential:
[13:21:50.433]    - args: function (..., envir = parent.frame())
[13:21:50.433]    - tweaked: FALSE
[13:21:50.433]    - call: plan(strategy)
[13:21:50.434] plan(): nbrOfWorkers() = 1
[13:21:50.434] SequentialFuture started (and completed)
[13:21:50.434] - Launch lazy future ... done
[13:21:50.434] run() for ‘SequentialFuture’ ... done
[13:21:50.434] Created future:
[13:21:50.435] SequentialFuture:
[13:21:50.435] Label: ‘future_mapply-1’
[13:21:50.435] Expression:
[13:21:50.435] {
[13:21:50.435]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:50.435]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:50.435]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:50.435]         on.exit(options(oopts), add = TRUE)
[13:21:50.435]     }
[13:21:50.435]     {
[13:21:50.435]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:21:50.435]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:21:50.435]         do.call(mapply, args = args)
[13:21:50.435]     }
[13:21:50.435] }
[13:21:50.435] Lazy evaluation: FALSE
[13:21:50.435] Asynchronous evaluation: FALSE
[13:21:50.435] Local evaluation: TRUE
[13:21:50.435] Environment: R_GlobalEnv
[13:21:50.435] Capture standard output: TRUE
[13:21:50.435] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:50.435] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:50.435] Packages: <none>
[13:21:50.435] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:50.435] Resolved: TRUE
[13:21:50.435] Value: 224 bytes of class ‘list’
[13:21:50.435] Early signaling: FALSE
[13:21:50.435] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:21:50.435] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:50.436] Chunk #1 of 1 ... DONE
[13:21:50.436] Launching 1 futures (chunks) ... DONE
[13:21:50.436] Resolving 1 futures (chunks) ...
[13:21:50.436] resolve() on list ...
[13:21:50.436]  recursive: 0
[13:21:50.436]  length: 1
[13:21:50.436] 
[13:21:50.436] resolved() for ‘SequentialFuture’ ...
[13:21:50.436] - state: ‘finished’
[13:21:50.436] - run: TRUE
[13:21:50.437] - result: ‘FutureResult’
[13:21:50.437] resolved() for ‘SequentialFuture’ ... done
[13:21:50.437] Future #1
[13:21:50.437] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:50.437] - nx: 1
[13:21:50.437] - relay: TRUE
[13:21:50.437] - stdout: TRUE
[13:21:50.437] - signal: TRUE
[13:21:50.437] - resignal: FALSE
[13:21:50.437] - force: TRUE
[13:21:50.437] - relayed: [n=1] FALSE
[13:21:50.438] - queued futures: [n=1] FALSE
[13:21:50.438]  - until=1
[13:21:50.438]  - relaying element #1
[13:21:50.438] - relayed: [n=1] TRUE
[13:21:50.438] - queued futures: [n=1] TRUE
[13:21:50.438] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:50.438]  length: 0 (resolved future 1)
[13:21:50.438] Relaying remaining futures
[13:21:50.438] signalConditionsASAP(NULL, pos=0) ...
[13:21:50.439] - nx: 1
[13:21:50.439] - relay: TRUE
[13:21:50.439] - stdout: TRUE
[13:21:50.439] - signal: TRUE
[13:21:50.439] - resignal: FALSE
[13:21:50.439] - force: TRUE
[13:21:50.439] - relayed: [n=1] TRUE
[13:21:50.439] - queued futures: [n=1] TRUE
 - flush all
[13:21:50.439] - relayed: [n=1] TRUE
[13:21:50.439] - queued futures: [n=1] TRUE
[13:21:50.439] signalConditionsASAP(NULL, pos=0) ... done
[13:21:50.440] resolve() on list ... DONE
[13:21:50.440]  - Number of value chunks collected: 1
[13:21:50.440] Resolving 1 futures (chunks) ... DONE
[13:21:50.440] Reducing values from 1 chunks ...
[13:21:50.440]  - Number of values collected after concatenation: 2
[13:21:50.440]  - Number of values expected: 2
[13:21:50.440] Reducing values from 1 chunks ... DONE
[13:21:50.440] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[13:21:50.441] future_mapply() ...
[13:21:50.441] Number of chunks: 1
[13:21:50.441] getGlobalsAndPackagesXApply() ...
[13:21:50.441]  - future.globals: TRUE
[13:21:50.441] getGlobalsAndPackages() ...
[13:21:50.441] Searching for globals...
[13:21:50.443] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:21:50.443] Searching for globals ... DONE
[13:21:50.443] Resolving globals: FALSE
[13:21:50.443] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:21:50.444] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:21:50.444] - globals: [1] ‘FUN’
[13:21:50.444] 
[13:21:50.444] getGlobalsAndPackages() ... DONE
[13:21:50.444]  - globals found/used: [n=1] ‘FUN’
[13:21:50.444]  - needed namespaces: [n=0] 
[13:21:50.444] Finding globals ... DONE
[13:21:50.445] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:21:50.445] List of 2
[13:21:50.445]  $ ...future.FUN:function (x, y)  
[13:21:50.445]  $ MoreArgs     : NULL
[13:21:50.445]  - attr(*, "where")=List of 2
[13:21:50.445]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:50.445]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:21:50.445]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:50.445]  - attr(*, "resolved")= logi FALSE
[13:21:50.445]  - attr(*, "total_size")= num NA
[13:21:50.447] Packages to be attached in all futures: [n=0] 
[13:21:50.447] getGlobalsAndPackagesXApply() ... DONE
[13:21:50.447] Number of futures (= number of chunks): 1
[13:21:50.448] Launching 1 futures (chunks) ...
[13:21:50.448] Chunk #1 of 1 ...
[13:21:50.448]  - Finding globals in '...' for chunk #1 ...
[13:21:50.448] getGlobalsAndPackages() ...
[13:21:50.448] Searching for globals...
[13:21:50.448] 
[13:21:50.448] Searching for globals ... DONE
[13:21:50.448] - globals: [0] <none>
[13:21:50.449] getGlobalsAndPackages() ... DONE
[13:21:50.449]    + additional globals found: [n=0] 
[13:21:50.449]    + additional namespaces needed: [n=0] 
[13:21:50.449]  - Finding globals in '...' for chunk #1 ... DONE
[13:21:50.449]  - seeds: <none>
[13:21:50.449]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:50.449] getGlobalsAndPackages() ...
[13:21:50.449] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:50.449] Resolving globals: FALSE
[13:21:50.450] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[13:21:50.450] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:21:50.450] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:50.450] 
[13:21:50.451] getGlobalsAndPackages() ... DONE
[13:21:50.451] run() for ‘Future’ ...
[13:21:50.451] - state: ‘created’
[13:21:50.451] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:50.451] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:50.451] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:50.452]   - Field: ‘label’
[13:21:50.452]   - Field: ‘local’
[13:21:50.452]   - Field: ‘owner’
[13:21:50.452]   - Field: ‘envir’
[13:21:50.452]   - Field: ‘packages’
[13:21:50.452]   - Field: ‘gc’
[13:21:50.452]   - Field: ‘conditions’
[13:21:50.452]   - Field: ‘expr’
[13:21:50.452]   - Field: ‘uuid’
[13:21:50.452]   - Field: ‘seed’
[13:21:50.452]   - Field: ‘version’
[13:21:50.453]   - Field: ‘result’
[13:21:50.453]   - Field: ‘asynchronous’
[13:21:50.453]   - Field: ‘calls’
[13:21:50.453]   - Field: ‘globals’
[13:21:50.453]   - Field: ‘stdout’
[13:21:50.453]   - Field: ‘earlySignal’
[13:21:50.453]   - Field: ‘lazy’
[13:21:50.453]   - Field: ‘state’
[13:21:50.453] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:50.453] - Launch lazy future ...
[13:21:50.454] Packages needed by the future expression (n = 0): <none>
[13:21:50.454] Packages needed by future strategies (n = 0): <none>
[13:21:50.454] {
[13:21:50.454]     {
[13:21:50.454]         {
[13:21:50.454]             ...future.startTime <- base::Sys.time()
[13:21:50.454]             {
[13:21:50.454]                 {
[13:21:50.454]                   {
[13:21:50.454]                     base::local({
[13:21:50.454]                       has_future <- base::requireNamespace("future", 
[13:21:50.454]                         quietly = TRUE)
[13:21:50.454]                       if (has_future) {
[13:21:50.454]                         ns <- base::getNamespace("future")
[13:21:50.454]                         version <- ns[[".package"]][["version"]]
[13:21:50.454]                         if (is.null(version)) 
[13:21:50.454]                           version <- utils::packageVersion("future")
[13:21:50.454]                       }
[13:21:50.454]                       else {
[13:21:50.454]                         version <- NULL
[13:21:50.454]                       }
[13:21:50.454]                       if (!has_future || version < "1.8.0") {
[13:21:50.454]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:50.454]                           "", base::R.version$version.string), 
[13:21:50.454]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:50.454]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:50.454]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:50.454]                             "release", "version")], collapse = " "), 
[13:21:50.454]                           hostname = base::Sys.info()[["nodename"]])
[13:21:50.454]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:50.454]                           info)
[13:21:50.454]                         info <- base::paste(info, collapse = "; ")
[13:21:50.454]                         if (!has_future) {
[13:21:50.454]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:50.454]                             info)
[13:21:50.454]                         }
[13:21:50.454]                         else {
[13:21:50.454]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:50.454]                             info, version)
[13:21:50.454]                         }
[13:21:50.454]                         base::stop(msg)
[13:21:50.454]                       }
[13:21:50.454]                     })
[13:21:50.454]                   }
[13:21:50.454]                   options(future.plan = NULL)
[13:21:50.454]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:50.454]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:50.454]                 }
[13:21:50.454]                 ...future.workdir <- getwd()
[13:21:50.454]             }
[13:21:50.454]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:50.454]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:50.454]         }
[13:21:50.454]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:50.454]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:50.454]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:50.454]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:50.454]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:50.454]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:50.454]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:50.454]             base::names(...future.oldOptions))
[13:21:50.454]     }
[13:21:50.454]     if (TRUE) {
[13:21:50.454]     }
[13:21:50.454]     else {
[13:21:50.454]         if (NA) {
[13:21:50.454]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:50.454]                 open = "w")
[13:21:50.454]         }
[13:21:50.454]         else {
[13:21:50.454]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:50.454]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:50.454]         }
[13:21:50.454]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:50.454]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:50.454]             base::sink(type = "output", split = FALSE)
[13:21:50.454]             base::close(...future.stdout)
[13:21:50.454]         }, add = TRUE)
[13:21:50.454]     }
[13:21:50.454]     ...future.frame <- base::sys.nframe()
[13:21:50.454]     ...future.conditions <- base::list()
[13:21:50.454]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:50.454]     if (FALSE) {
[13:21:50.454]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:50.454]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:50.454]     }
[13:21:50.454]     ...future.result <- base::tryCatch({
[13:21:50.454]         base::withCallingHandlers({
[13:21:50.454]             ...future.value <- base::withVisible(base::local({
[13:21:50.454]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:50.454]                 if (!identical(...future.globals.maxSize.org, 
[13:21:50.454]                   ...future.globals.maxSize)) {
[13:21:50.454]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:50.454]                   on.exit(options(oopts), add = TRUE)
[13:21:50.454]                 }
[13:21:50.454]                 {
[13:21:50.454]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:21:50.454]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:21:50.454]                     USE.NAMES = FALSE)
[13:21:50.454]                   do.call(mapply, args = args)
[13:21:50.454]                 }
[13:21:50.454]             }))
[13:21:50.454]             future::FutureResult(value = ...future.value$value, 
[13:21:50.454]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:50.454]                   ...future.rng), globalenv = if (FALSE) 
[13:21:50.454]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:50.454]                     ...future.globalenv.names))
[13:21:50.454]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:50.454]         }, condition = base::local({
[13:21:50.454]             c <- base::c
[13:21:50.454]             inherits <- base::inherits
[13:21:50.454]             invokeRestart <- base::invokeRestart
[13:21:50.454]             length <- base::length
[13:21:50.454]             list <- base::list
[13:21:50.454]             seq.int <- base::seq.int
[13:21:50.454]             signalCondition <- base::signalCondition
[13:21:50.454]             sys.calls <- base::sys.calls
[13:21:50.454]             `[[` <- base::`[[`
[13:21:50.454]             `+` <- base::`+`
[13:21:50.454]             `<<-` <- base::`<<-`
[13:21:50.454]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:50.454]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:50.454]                   3L)]
[13:21:50.454]             }
[13:21:50.454]             function(cond) {
[13:21:50.454]                 is_error <- inherits(cond, "error")
[13:21:50.454]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:50.454]                   NULL)
[13:21:50.454]                 if (is_error) {
[13:21:50.454]                   sessionInformation <- function() {
[13:21:50.454]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:50.454]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:50.454]                       search = base::search(), system = base::Sys.info())
[13:21:50.454]                   }
[13:21:50.454]                   ...future.conditions[[length(...future.conditions) + 
[13:21:50.454]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:50.454]                     cond$call), session = sessionInformation(), 
[13:21:50.454]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:50.454]                   signalCondition(cond)
[13:21:50.454]                 }
[13:21:50.454]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:50.454]                 "immediateCondition"))) {
[13:21:50.454]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:50.454]                   ...future.conditions[[length(...future.conditions) + 
[13:21:50.454]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:50.454]                   if (TRUE && !signal) {
[13:21:50.454]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:50.454]                     {
[13:21:50.454]                       inherits <- base::inherits
[13:21:50.454]                       invokeRestart <- base::invokeRestart
[13:21:50.454]                       is.null <- base::is.null
[13:21:50.454]                       muffled <- FALSE
[13:21:50.454]                       if (inherits(cond, "message")) {
[13:21:50.454]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:50.454]                         if (muffled) 
[13:21:50.454]                           invokeRestart("muffleMessage")
[13:21:50.454]                       }
[13:21:50.454]                       else if (inherits(cond, "warning")) {
[13:21:50.454]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:50.454]                         if (muffled) 
[13:21:50.454]                           invokeRestart("muffleWarning")
[13:21:50.454]                       }
[13:21:50.454]                       else if (inherits(cond, "condition")) {
[13:21:50.454]                         if (!is.null(pattern)) {
[13:21:50.454]                           computeRestarts <- base::computeRestarts
[13:21:50.454]                           grepl <- base::grepl
[13:21:50.454]                           restarts <- computeRestarts(cond)
[13:21:50.454]                           for (restart in restarts) {
[13:21:50.454]                             name <- restart$name
[13:21:50.454]                             if (is.null(name)) 
[13:21:50.454]                               next
[13:21:50.454]                             if (!grepl(pattern, name)) 
[13:21:50.454]                               next
[13:21:50.454]                             invokeRestart(restart)
[13:21:50.454]                             muffled <- TRUE
[13:21:50.454]                             break
[13:21:50.454]                           }
[13:21:50.454]                         }
[13:21:50.454]                       }
[13:21:50.454]                       invisible(muffled)
[13:21:50.454]                     }
[13:21:50.454]                     muffleCondition(cond, pattern = "^muffle")
[13:21:50.454]                   }
[13:21:50.454]                 }
[13:21:50.454]                 else {
[13:21:50.454]                   if (TRUE) {
[13:21:50.454]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:50.454]                     {
[13:21:50.454]                       inherits <- base::inherits
[13:21:50.454]                       invokeRestart <- base::invokeRestart
[13:21:50.454]                       is.null <- base::is.null
[13:21:50.454]                       muffled <- FALSE
[13:21:50.454]                       if (inherits(cond, "message")) {
[13:21:50.454]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:50.454]                         if (muffled) 
[13:21:50.454]                           invokeRestart("muffleMessage")
[13:21:50.454]                       }
[13:21:50.454]                       else if (inherits(cond, "warning")) {
[13:21:50.454]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:50.454]                         if (muffled) 
[13:21:50.454]                           invokeRestart("muffleWarning")
[13:21:50.454]                       }
[13:21:50.454]                       else if (inherits(cond, "condition")) {
[13:21:50.454]                         if (!is.null(pattern)) {
[13:21:50.454]                           computeRestarts <- base::computeRestarts
[13:21:50.454]                           grepl <- base::grepl
[13:21:50.454]                           restarts <- computeRestarts(cond)
[13:21:50.454]                           for (restart in restarts) {
[13:21:50.454]                             name <- restart$name
[13:21:50.454]                             if (is.null(name)) 
[13:21:50.454]                               next
[13:21:50.454]                             if (!grepl(pattern, name)) 
[13:21:50.454]                               next
[13:21:50.454]                             invokeRestart(restart)
[13:21:50.454]                             muffled <- TRUE
[13:21:50.454]                             break
[13:21:50.454]                           }
[13:21:50.454]                         }
[13:21:50.454]                       }
[13:21:50.454]                       invisible(muffled)
[13:21:50.454]                     }
[13:21:50.454]                     muffleCondition(cond, pattern = "^muffle")
[13:21:50.454]                   }
[13:21:50.454]                 }
[13:21:50.454]             }
[13:21:50.454]         }))
[13:21:50.454]     }, error = function(ex) {
[13:21:50.454]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:50.454]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:50.454]                 ...future.rng), started = ...future.startTime, 
[13:21:50.454]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:50.454]             version = "1.8"), class = "FutureResult")
[13:21:50.454]     }, finally = {
[13:21:50.454]         if (!identical(...future.workdir, getwd())) 
[13:21:50.454]             setwd(...future.workdir)
[13:21:50.454]         {
[13:21:50.454]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:50.454]                 ...future.oldOptions$nwarnings <- NULL
[13:21:50.454]             }
[13:21:50.454]             base::options(...future.oldOptions)
[13:21:50.454]             if (.Platform$OS.type == "windows") {
[13:21:50.454]                 old_names <- names(...future.oldEnvVars)
[13:21:50.454]                 envs <- base::Sys.getenv()
[13:21:50.454]                 names <- names(envs)
[13:21:50.454]                 common <- intersect(names, old_names)
[13:21:50.454]                 added <- setdiff(names, old_names)
[13:21:50.454]                 removed <- setdiff(old_names, names)
[13:21:50.454]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:50.454]                   envs[common]]
[13:21:50.454]                 NAMES <- toupper(changed)
[13:21:50.454]                 args <- list()
[13:21:50.454]                 for (kk in seq_along(NAMES)) {
[13:21:50.454]                   name <- changed[[kk]]
[13:21:50.454]                   NAME <- NAMES[[kk]]
[13:21:50.454]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:50.454]                     next
[13:21:50.454]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:50.454]                 }
[13:21:50.454]                 NAMES <- toupper(added)
[13:21:50.454]                 for (kk in seq_along(NAMES)) {
[13:21:50.454]                   name <- added[[kk]]
[13:21:50.454]                   NAME <- NAMES[[kk]]
[13:21:50.454]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:50.454]                     next
[13:21:50.454]                   args[[name]] <- ""
[13:21:50.454]                 }
[13:21:50.454]                 NAMES <- toupper(removed)
[13:21:50.454]                 for (kk in seq_along(NAMES)) {
[13:21:50.454]                   name <- removed[[kk]]
[13:21:50.454]                   NAME <- NAMES[[kk]]
[13:21:50.454]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:50.454]                     next
[13:21:50.454]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:50.454]                 }
[13:21:50.454]                 if (length(args) > 0) 
[13:21:50.454]                   base::do.call(base::Sys.setenv, args = args)
[13:21:50.454]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:50.454]             }
[13:21:50.454]             else {
[13:21:50.454]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:50.454]             }
[13:21:50.454]             {
[13:21:50.454]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:50.454]                   0L) {
[13:21:50.454]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:50.454]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:50.454]                   base::options(opts)
[13:21:50.454]                 }
[13:21:50.454]                 {
[13:21:50.454]                   {
[13:21:50.454]                     NULL
[13:21:50.454]                     RNGkind("Mersenne-Twister")
[13:21:50.454]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:50.454]                       inherits = FALSE)
[13:21:50.454]                   }
[13:21:50.454]                   options(future.plan = NULL)
[13:21:50.454]                   if (is.na(NA_character_)) 
[13:21:50.454]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:50.454]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:50.454]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:50.454]                   {
[13:21:50.454]                     future <- SequentialFuture(..., envir = envir)
[13:21:50.454]                     if (!future$lazy) 
[13:21:50.454]                       future <- run(future)
[13:21:50.454]                     invisible(future)
[13:21:50.454]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:50.454]                 }
[13:21:50.454]             }
[13:21:50.454]         }
[13:21:50.454]     })
[13:21:50.454]     if (FALSE) {
[13:21:50.454]         base::sink(type = "output", split = FALSE)
[13:21:50.454]         if (NA) {
[13:21:50.454]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:50.454]         }
[13:21:50.454]         else {
[13:21:50.454]             ...future.result["stdout"] <- base::list(NULL)
[13:21:50.454]         }
[13:21:50.454]         base::close(...future.stdout)
[13:21:50.454]         ...future.stdout <- NULL
[13:21:50.454]     }
[13:21:50.454]     ...future.result$conditions <- ...future.conditions
[13:21:50.454]     ...future.result$finished <- base::Sys.time()
[13:21:50.454]     ...future.result
[13:21:50.454] }
[13:21:50.458] assign_globals() ...
[13:21:50.458] List of 5
[13:21:50.458]  $ ...future.FUN            :function (x, y)  
[13:21:50.458]  $ MoreArgs                 : NULL
[13:21:50.458]  $ ...future.elements_ii    :List of 2
[13:21:50.458]   ..$ :List of 2
[13:21:50.458]   .. ..$ : int 1
[13:21:50.458]   .. ..$ : int 0
[13:21:50.458]   ..$ :List of 2
[13:21:50.458]   .. ..$ : int 0
[13:21:50.458]   .. ..$ : int 1
[13:21:50.458]  $ ...future.seeds_ii       : NULL
[13:21:50.458]  $ ...future.globals.maxSize: NULL
[13:21:50.458]  - attr(*, "where")=List of 5
[13:21:50.458]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:50.458]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:21:50.458]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:50.458]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:50.458]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:50.458]  - attr(*, "resolved")= logi FALSE
[13:21:50.458]  - attr(*, "total_size")= num 6480
[13:21:50.458]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:50.458]  - attr(*, "already-done")= logi TRUE
[13:21:50.463] - reassign environment for ‘...future.FUN’
[13:21:50.463] - copied ‘...future.FUN’ to environment
[13:21:50.464] - copied ‘MoreArgs’ to environment
[13:21:50.464] - copied ‘...future.elements_ii’ to environment
[13:21:50.464] - copied ‘...future.seeds_ii’ to environment
[13:21:50.464] - copied ‘...future.globals.maxSize’ to environment
[13:21:50.464] assign_globals() ... done
[13:21:50.464] plan(): Setting new future strategy stack:
[13:21:50.464] List of future strategies:
[13:21:50.464] 1. sequential:
[13:21:50.464]    - args: function (..., envir = parent.frame())
[13:21:50.464]    - tweaked: FALSE
[13:21:50.464]    - call: NULL
[13:21:50.465] plan(): nbrOfWorkers() = 1
[13:21:50.966] plan(): Setting new future strategy stack:
[13:21:50.967] List of future strategies:
[13:21:50.967] 1. sequential:
[13:21:50.967]    - args: function (..., envir = parent.frame())
[13:21:50.967]    - tweaked: FALSE
[13:21:50.967]    - call: plan(strategy)
[13:21:50.967] plan(): nbrOfWorkers() = 1
[13:21:50.967] SequentialFuture started (and completed)
[13:21:50.967] - Launch lazy future ... done
[13:21:50.967] run() for ‘SequentialFuture’ ... done
[13:21:50.968] Created future:
[13:21:50.968] SequentialFuture:
[13:21:50.968] Label: ‘future_mapply-1’
[13:21:50.968] Expression:
[13:21:50.968] {
[13:21:50.968]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:50.968]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:50.968]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:50.968]         on.exit(options(oopts), add = TRUE)
[13:21:50.968]     }
[13:21:50.968]     {
[13:21:50.968]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:21:50.968]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:21:50.968]         do.call(mapply, args = args)
[13:21:50.968]     }
[13:21:50.968] }
[13:21:50.968] Lazy evaluation: FALSE
[13:21:50.968] Asynchronous evaluation: FALSE
[13:21:50.968] Local evaluation: TRUE
[13:21:50.968] Environment: R_GlobalEnv
[13:21:50.968] Capture standard output: NA
[13:21:50.968] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:50.968] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:50.968] Packages: <none>
[13:21:50.968] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:50.968] Resolved: TRUE
[13:21:50.968] Value: 224 bytes of class ‘list’
[13:21:50.968] Early signaling: FALSE
[13:21:50.968] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:21:50.968] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:50.969] Chunk #1 of 1 ... DONE
[13:21:50.969] Launching 1 futures (chunks) ... DONE
[13:21:50.969] Resolving 1 futures (chunks) ...
[13:21:50.969] resolve() on list ...
[13:21:50.969]  recursive: 0
[13:21:50.969]  length: 1
[13:21:50.969] 
[13:21:50.969] resolved() for ‘SequentialFuture’ ...
[13:21:50.969] - state: ‘finished’
[13:21:50.970] - run: TRUE
[13:21:50.970] - result: ‘FutureResult’
[13:21:50.970] resolved() for ‘SequentialFuture’ ... done
[13:21:50.970] Future #1
[13:21:50.970] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:50.970] - nx: 1
[13:21:50.970] - relay: TRUE
[13:21:50.970] - stdout: TRUE
[13:21:50.970] - signal: TRUE
[13:21:50.970] - resignal: FALSE
[13:21:50.971] - force: TRUE
[13:21:50.971] - relayed: [n=1] FALSE
[13:21:50.971] - queued futures: [n=1] FALSE
[13:21:50.971]  - until=1
[13:21:50.971]  - relaying element #1
[13:21:50.971] - relayed: [n=1] TRUE
[13:21:50.971] - queued futures: [n=1] TRUE
[13:21:50.971] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:50.971]  length: 0 (resolved future 1)
[13:21:50.971] Relaying remaining futures
[13:21:50.971] signalConditionsASAP(NULL, pos=0) ...
[13:21:50.972] - nx: 1
[13:21:50.972] - relay: TRUE
[13:21:50.972] - stdout: TRUE
[13:21:50.972] - signal: TRUE
[13:21:50.972] - resignal: FALSE
[13:21:50.972] - force: TRUE
[13:21:50.972] - relayed: [n=1] TRUE
[13:21:50.972] - queued futures: [n=1] TRUE
 - flush all
[13:21:50.972] - relayed: [n=1] TRUE
[13:21:50.972] - queued futures: [n=1] TRUE
[13:21:50.972] signalConditionsASAP(NULL, pos=0) ... done
[13:21:50.973] resolve() on list ... DONE
[13:21:50.973]  - Number of value chunks collected: 1
[13:21:50.973] Resolving 1 futures (chunks) ... DONE
[13:21:50.973] Reducing values from 1 chunks ...
[13:21:50.973]  - Number of values collected after concatenation: 2
[13:21:50.973]  - Number of values expected: 2
[13:21:50.973] Reducing values from 1 chunks ... DONE
[13:21:50.973] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('sequential') ... DONE
* plan('multicore') ...
[13:21:50.974] plan(): Setting new future strategy stack:
[13:21:50.974] List of future strategies:
[13:21:50.974] 1. multicore:
[13:21:50.974]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:50.974]    - tweaked: FALSE
[13:21:50.974]    - call: plan(strategy)
[13:21:50.978] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[13:21:50.978] future_lapply() ...
[13:21:50.982] Number of chunks: 1
[13:21:50.982] getGlobalsAndPackagesXApply() ...
[13:21:50.982]  - future.globals: TRUE
[13:21:50.982] getGlobalsAndPackages() ...
[13:21:50.983] Searching for globals...
[13:21:50.984] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:21:50.984] Searching for globals ... DONE
[13:21:50.984] Resolving globals: FALSE
[13:21:50.985] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:21:50.985] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:21:50.985] - globals: [1] ‘FUN’
[13:21:50.985] 
[13:21:50.985] getGlobalsAndPackages() ... DONE
[13:21:50.985]  - globals found/used: [n=1] ‘FUN’
[13:21:50.986]  - needed namespaces: [n=0] 
[13:21:50.986] Finding globals ... DONE
[13:21:50.986]  - use_args: TRUE
[13:21:50.986]  - Getting '...' globals ...
[13:21:50.986] resolve() on list ...
[13:21:50.988]  recursive: 0
[13:21:50.988]  length: 1
[13:21:50.988]  elements: ‘...’
[13:21:50.988]  length: 0 (resolved future 1)
[13:21:50.988] resolve() on list ... DONE
[13:21:50.989]    - '...' content: [n=0] 
[13:21:50.989] List of 1
[13:21:50.989]  $ ...: list()
[13:21:50.989]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:50.989]  - attr(*, "where")=List of 1
[13:21:50.989]   ..$ ...:<environment: 0x55dd746f74b8> 
[13:21:50.989]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:50.989]  - attr(*, "resolved")= logi TRUE
[13:21:50.989]  - attr(*, "total_size")= num NA
[13:21:50.991]  - Getting '...' globals ... DONE
[13:21:50.991] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:21:50.992] List of 2
[13:21:50.992]  $ ...future.FUN:function (x)  
[13:21:50.992]  $ ...          : list()
[13:21:50.992]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:50.992]  - attr(*, "where")=List of 2
[13:21:50.992]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:50.992]   ..$ ...          :<environment: 0x55dd746f74b8> 
[13:21:50.992]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:50.992]  - attr(*, "resolved")= logi FALSE
[13:21:50.992]  - attr(*, "total_size")= num 4720
[13:21:50.994] Packages to be attached in all futures: [n=0] 
[13:21:50.994] getGlobalsAndPackagesXApply() ... DONE
[13:21:50.995] Number of futures (= number of chunks): 1
[13:21:50.995] Launching 1 futures (chunks) ...
[13:21:50.995] Chunk #1 of 1 ...
[13:21:50.995]  - Finding globals in 'X' for chunk #1 ...
[13:21:50.995] getGlobalsAndPackages() ...
[13:21:50.995] Searching for globals...
[13:21:50.995] 
[13:21:50.995] Searching for globals ... DONE
[13:21:50.996] - globals: [0] <none>
[13:21:50.996] getGlobalsAndPackages() ... DONE
[13:21:50.996]    + additional globals found: [n=0] 
[13:21:50.996]    + additional namespaces needed: [n=0] 
[13:21:50.996]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:50.996]  - seeds: <none>
[13:21:50.996]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:50.996] getGlobalsAndPackages() ...
[13:21:50.996] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:50.997] Resolving globals: FALSE
[13:21:50.997] Tweak future expression to call with '...' arguments ...
[13:21:50.997] {
[13:21:50.997]     do.call(function(...) {
[13:21:50.997]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:50.997]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:50.997]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:50.997]             on.exit(options(oopts), add = TRUE)
[13:21:50.997]         }
[13:21:50.997]         {
[13:21:50.997]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:50.997]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:50.997]                 ...future.FUN(...future.X_jj, ...)
[13:21:50.997]             })
[13:21:50.997]         }
[13:21:50.997]     }, args = future.call.arguments)
[13:21:50.997] }
[13:21:50.997] Tweak future expression to call with '...' arguments ... DONE
[13:21:50.997] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:50.998] 
[13:21:50.998] getGlobalsAndPackages() ... DONE
[13:21:50.998] run() for ‘Future’ ...
[13:21:50.998] - state: ‘created’
[13:21:50.998] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:51.002] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:51.002] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:51.002]   - Field: ‘label’
[13:21:51.002]   - Field: ‘local’
[13:21:51.002]   - Field: ‘owner’
[13:21:51.002]   - Field: ‘envir’
[13:21:51.003]   - Field: ‘packages’
[13:21:51.003]   - Field: ‘gc’
[13:21:51.003]   - Field: ‘conditions’
[13:21:51.003]   - Field: ‘expr’
[13:21:51.003]   - Field: ‘uuid’
[13:21:51.003]   - Field: ‘seed’
[13:21:51.003]   - Field: ‘version’
[13:21:51.003]   - Field: ‘result’
[13:21:51.003]   - Field: ‘asynchronous’
[13:21:51.003]   - Field: ‘calls’
[13:21:51.004]   - Field: ‘globals’
[13:21:51.004]   - Field: ‘stdout’
[13:21:51.004]   - Field: ‘earlySignal’
[13:21:51.004]   - Field: ‘lazy’
[13:21:51.004]   - Field: ‘state’
[13:21:51.004] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:51.004] - Launch lazy future ...
[13:21:51.004] Packages needed by the future expression (n = 0): <none>
[13:21:51.004] Packages needed by future strategies (n = 0): <none>
[13:21:51.005] {
[13:21:51.005]     {
[13:21:51.005]         {
[13:21:51.005]             ...future.startTime <- base::Sys.time()
[13:21:51.005]             {
[13:21:51.005]                 {
[13:21:51.005]                   {
[13:21:51.005]                     base::local({
[13:21:51.005]                       has_future <- base::requireNamespace("future", 
[13:21:51.005]                         quietly = TRUE)
[13:21:51.005]                       if (has_future) {
[13:21:51.005]                         ns <- base::getNamespace("future")
[13:21:51.005]                         version <- ns[[".package"]][["version"]]
[13:21:51.005]                         if (is.null(version)) 
[13:21:51.005]                           version <- utils::packageVersion("future")
[13:21:51.005]                       }
[13:21:51.005]                       else {
[13:21:51.005]                         version <- NULL
[13:21:51.005]                       }
[13:21:51.005]                       if (!has_future || version < "1.8.0") {
[13:21:51.005]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:51.005]                           "", base::R.version$version.string), 
[13:21:51.005]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:51.005]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:51.005]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:51.005]                             "release", "version")], collapse = " "), 
[13:21:51.005]                           hostname = base::Sys.info()[["nodename"]])
[13:21:51.005]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:51.005]                           info)
[13:21:51.005]                         info <- base::paste(info, collapse = "; ")
[13:21:51.005]                         if (!has_future) {
[13:21:51.005]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:51.005]                             info)
[13:21:51.005]                         }
[13:21:51.005]                         else {
[13:21:51.005]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:51.005]                             info, version)
[13:21:51.005]                         }
[13:21:51.005]                         base::stop(msg)
[13:21:51.005]                       }
[13:21:51.005]                     })
[13:21:51.005]                   }
[13:21:51.005]                   options(future.plan = NULL)
[13:21:51.005]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:51.005]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:51.005]                 }
[13:21:51.005]                 ...future.workdir <- getwd()
[13:21:51.005]             }
[13:21:51.005]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:51.005]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:51.005]         }
[13:21:51.005]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:51.005]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:51.005]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:51.005]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:51.005]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:51.005]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:51.005]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:51.005]             base::names(...future.oldOptions))
[13:21:51.005]     }
[13:21:51.005]     if (FALSE) {
[13:21:51.005]     }
[13:21:51.005]     else {
[13:21:51.005]         if (FALSE) {
[13:21:51.005]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:51.005]                 open = "w")
[13:21:51.005]         }
[13:21:51.005]         else {
[13:21:51.005]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:51.005]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:51.005]         }
[13:21:51.005]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:51.005]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:51.005]             base::sink(type = "output", split = FALSE)
[13:21:51.005]             base::close(...future.stdout)
[13:21:51.005]         }, add = TRUE)
[13:21:51.005]     }
[13:21:51.005]     ...future.frame <- base::sys.nframe()
[13:21:51.005]     ...future.conditions <- base::list()
[13:21:51.005]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:51.005]     if (FALSE) {
[13:21:51.005]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:51.005]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:51.005]     }
[13:21:51.005]     ...future.result <- base::tryCatch({
[13:21:51.005]         base::withCallingHandlers({
[13:21:51.005]             ...future.value <- base::withVisible(base::local({
[13:21:51.005]                 do.call(function(...) {
[13:21:51.005]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:51.005]                   if (!identical(...future.globals.maxSize.org, 
[13:21:51.005]                     ...future.globals.maxSize)) {
[13:21:51.005]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:51.005]                     on.exit(options(oopts), add = TRUE)
[13:21:51.005]                   }
[13:21:51.005]                   {
[13:21:51.005]                     lapply(seq_along(...future.elements_ii), 
[13:21:51.005]                       FUN = function(jj) {
[13:21:51.005]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:51.005]                         ...future.FUN(...future.X_jj, ...)
[13:21:51.005]                       })
[13:21:51.005]                   }
[13:21:51.005]                 }, args = future.call.arguments)
[13:21:51.005]             }))
[13:21:51.005]             future::FutureResult(value = ...future.value$value, 
[13:21:51.005]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:51.005]                   ...future.rng), globalenv = if (FALSE) 
[13:21:51.005]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:51.005]                     ...future.globalenv.names))
[13:21:51.005]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:51.005]         }, condition = base::local({
[13:21:51.005]             c <- base::c
[13:21:51.005]             inherits <- base::inherits
[13:21:51.005]             invokeRestart <- base::invokeRestart
[13:21:51.005]             length <- base::length
[13:21:51.005]             list <- base::list
[13:21:51.005]             seq.int <- base::seq.int
[13:21:51.005]             signalCondition <- base::signalCondition
[13:21:51.005]             sys.calls <- base::sys.calls
[13:21:51.005]             `[[` <- base::`[[`
[13:21:51.005]             `+` <- base::`+`
[13:21:51.005]             `<<-` <- base::`<<-`
[13:21:51.005]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:51.005]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:51.005]                   3L)]
[13:21:51.005]             }
[13:21:51.005]             function(cond) {
[13:21:51.005]                 is_error <- inherits(cond, "error")
[13:21:51.005]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:51.005]                   NULL)
[13:21:51.005]                 if (is_error) {
[13:21:51.005]                   sessionInformation <- function() {
[13:21:51.005]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:51.005]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:51.005]                       search = base::search(), system = base::Sys.info())
[13:21:51.005]                   }
[13:21:51.005]                   ...future.conditions[[length(...future.conditions) + 
[13:21:51.005]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:51.005]                     cond$call), session = sessionInformation(), 
[13:21:51.005]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:51.005]                   signalCondition(cond)
[13:21:51.005]                 }
[13:21:51.005]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:51.005]                 "immediateCondition"))) {
[13:21:51.005]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:51.005]                   ...future.conditions[[length(...future.conditions) + 
[13:21:51.005]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:51.005]                   if (TRUE && !signal) {
[13:21:51.005]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:51.005]                     {
[13:21:51.005]                       inherits <- base::inherits
[13:21:51.005]                       invokeRestart <- base::invokeRestart
[13:21:51.005]                       is.null <- base::is.null
[13:21:51.005]                       muffled <- FALSE
[13:21:51.005]                       if (inherits(cond, "message")) {
[13:21:51.005]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:51.005]                         if (muffled) 
[13:21:51.005]                           invokeRestart("muffleMessage")
[13:21:51.005]                       }
[13:21:51.005]                       else if (inherits(cond, "warning")) {
[13:21:51.005]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:51.005]                         if (muffled) 
[13:21:51.005]                           invokeRestart("muffleWarning")
[13:21:51.005]                       }
[13:21:51.005]                       else if (inherits(cond, "condition")) {
[13:21:51.005]                         if (!is.null(pattern)) {
[13:21:51.005]                           computeRestarts <- base::computeRestarts
[13:21:51.005]                           grepl <- base::grepl
[13:21:51.005]                           restarts <- computeRestarts(cond)
[13:21:51.005]                           for (restart in restarts) {
[13:21:51.005]                             name <- restart$name
[13:21:51.005]                             if (is.null(name)) 
[13:21:51.005]                               next
[13:21:51.005]                             if (!grepl(pattern, name)) 
[13:21:51.005]                               next
[13:21:51.005]                             invokeRestart(restart)
[13:21:51.005]                             muffled <- TRUE
[13:21:51.005]                             break
[13:21:51.005]                           }
[13:21:51.005]                         }
[13:21:51.005]                       }
[13:21:51.005]                       invisible(muffled)
[13:21:51.005]                     }
[13:21:51.005]                     muffleCondition(cond, pattern = "^muffle")
[13:21:51.005]                   }
[13:21:51.005]                 }
[13:21:51.005]                 else {
[13:21:51.005]                   if (TRUE) {
[13:21:51.005]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:51.005]                     {
[13:21:51.005]                       inherits <- base::inherits
[13:21:51.005]                       invokeRestart <- base::invokeRestart
[13:21:51.005]                       is.null <- base::is.null
[13:21:51.005]                       muffled <- FALSE
[13:21:51.005]                       if (inherits(cond, "message")) {
[13:21:51.005]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:51.005]                         if (muffled) 
[13:21:51.005]                           invokeRestart("muffleMessage")
[13:21:51.005]                       }
[13:21:51.005]                       else if (inherits(cond, "warning")) {
[13:21:51.005]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:51.005]                         if (muffled) 
[13:21:51.005]                           invokeRestart("muffleWarning")
[13:21:51.005]                       }
[13:21:51.005]                       else if (inherits(cond, "condition")) {
[13:21:51.005]                         if (!is.null(pattern)) {
[13:21:51.005]                           computeRestarts <- base::computeRestarts
[13:21:51.005]                           grepl <- base::grepl
[13:21:51.005]                           restarts <- computeRestarts(cond)
[13:21:51.005]                           for (restart in restarts) {
[13:21:51.005]                             name <- restart$name
[13:21:51.005]                             if (is.null(name)) 
[13:21:51.005]                               next
[13:21:51.005]                             if (!grepl(pattern, name)) 
[13:21:51.005]                               next
[13:21:51.005]                             invokeRestart(restart)
[13:21:51.005]                             muffled <- TRUE
[13:21:51.005]                             break
[13:21:51.005]                           }
[13:21:51.005]                         }
[13:21:51.005]                       }
[13:21:51.005]                       invisible(muffled)
[13:21:51.005]                     }
[13:21:51.005]                     muffleCondition(cond, pattern = "^muffle")
[13:21:51.005]                   }
[13:21:51.005]                 }
[13:21:51.005]             }
[13:21:51.005]         }))
[13:21:51.005]     }, error = function(ex) {
[13:21:51.005]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:51.005]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:51.005]                 ...future.rng), started = ...future.startTime, 
[13:21:51.005]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:51.005]             version = "1.8"), class = "FutureResult")
[13:21:51.005]     }, finally = {
[13:21:51.005]         if (!identical(...future.workdir, getwd())) 
[13:21:51.005]             setwd(...future.workdir)
[13:21:51.005]         {
[13:21:51.005]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:51.005]                 ...future.oldOptions$nwarnings <- NULL
[13:21:51.005]             }
[13:21:51.005]             base::options(...future.oldOptions)
[13:21:51.005]             if (.Platform$OS.type == "windows") {
[13:21:51.005]                 old_names <- names(...future.oldEnvVars)
[13:21:51.005]                 envs <- base::Sys.getenv()
[13:21:51.005]                 names <- names(envs)
[13:21:51.005]                 common <- intersect(names, old_names)
[13:21:51.005]                 added <- setdiff(names, old_names)
[13:21:51.005]                 removed <- setdiff(old_names, names)
[13:21:51.005]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:51.005]                   envs[common]]
[13:21:51.005]                 NAMES <- toupper(changed)
[13:21:51.005]                 args <- list()
[13:21:51.005]                 for (kk in seq_along(NAMES)) {
[13:21:51.005]                   name <- changed[[kk]]
[13:21:51.005]                   NAME <- NAMES[[kk]]
[13:21:51.005]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:51.005]                     next
[13:21:51.005]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:51.005]                 }
[13:21:51.005]                 NAMES <- toupper(added)
[13:21:51.005]                 for (kk in seq_along(NAMES)) {
[13:21:51.005]                   name <- added[[kk]]
[13:21:51.005]                   NAME <- NAMES[[kk]]
[13:21:51.005]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:51.005]                     next
[13:21:51.005]                   args[[name]] <- ""
[13:21:51.005]                 }
[13:21:51.005]                 NAMES <- toupper(removed)
[13:21:51.005]                 for (kk in seq_along(NAMES)) {
[13:21:51.005]                   name <- removed[[kk]]
[13:21:51.005]                   NAME <- NAMES[[kk]]
[13:21:51.005]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:51.005]                     next
[13:21:51.005]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:51.005]                 }
[13:21:51.005]                 if (length(args) > 0) 
[13:21:51.005]                   base::do.call(base::Sys.setenv, args = args)
[13:21:51.005]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:51.005]             }
[13:21:51.005]             else {
[13:21:51.005]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:51.005]             }
[13:21:51.005]             {
[13:21:51.005]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:51.005]                   0L) {
[13:21:51.005]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:51.005]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:51.005]                   base::options(opts)
[13:21:51.005]                 }
[13:21:51.005]                 {
[13:21:51.005]                   {
[13:21:51.005]                     NULL
[13:21:51.005]                     RNGkind("Mersenne-Twister")
[13:21:51.005]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:51.005]                       inherits = FALSE)
[13:21:51.005]                   }
[13:21:51.005]                   options(future.plan = NULL)
[13:21:51.005]                   if (is.na(NA_character_)) 
[13:21:51.005]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:51.005]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:51.005]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:51.005]                     envir = parent.frame()) 
[13:21:51.005]                   {
[13:21:51.005]                     default_workers <- missing(workers)
[13:21:51.005]                     if (is.function(workers)) 
[13:21:51.005]                       workers <- workers()
[13:21:51.005]                     workers <- structure(as.integer(workers), 
[13:21:51.005]                       class = class(workers))
[13:21:51.005]                     stop_if_not(is.finite(workers), workers >= 
[13:21:51.005]                       1L)
[13:21:51.005]                     if ((workers == 1L && !inherits(workers, 
[13:21:51.005]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:51.005]                       if (default_workers) 
[13:21:51.005]                         supportsMulticore(warn = TRUE)
[13:21:51.005]                       return(sequential(..., envir = envir))
[13:21:51.005]                     }
[13:21:51.005]                     oopts <- options(mc.cores = workers)
[13:21:51.005]                     on.exit(options(oopts))
[13:21:51.005]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:51.005]                       envir = envir)
[13:21:51.005]                     if (!future$lazy) 
[13:21:51.005]                       future <- run(future)
[13:21:51.005]                     invisible(future)
[13:21:51.005]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:51.005]                 }
[13:21:51.005]             }
[13:21:51.005]         }
[13:21:51.005]     })
[13:21:51.005]     if (TRUE) {
[13:21:51.005]         base::sink(type = "output", split = FALSE)
[13:21:51.005]         if (FALSE) {
[13:21:51.005]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:51.005]         }
[13:21:51.005]         else {
[13:21:51.005]             ...future.result["stdout"] <- base::list(NULL)
[13:21:51.005]         }
[13:21:51.005]         base::close(...future.stdout)
[13:21:51.005]         ...future.stdout <- NULL
[13:21:51.005]     }
[13:21:51.005]     ...future.result$conditions <- ...future.conditions
[13:21:51.005]     ...future.result$finished <- base::Sys.time()
[13:21:51.005]     ...future.result
[13:21:51.005] }
[13:21:51.007] assign_globals() ...
[13:21:51.007] List of 5
[13:21:51.007]  $ ...future.FUN            :function (x)  
[13:21:51.007]  $ future.call.arguments    : list()
[13:21:51.007]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:51.007]  $ ...future.elements_ii    :List of 2
[13:21:51.007]   ..$ : int 1
[13:21:51.007]   ..$ : int 0
[13:21:51.007]  $ ...future.seeds_ii       : NULL
[13:21:51.007]  $ ...future.globals.maxSize: NULL
[13:21:51.007]  - attr(*, "where")=List of 5
[13:21:51.007]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:51.007]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:51.007]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:51.007]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:51.007]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:51.007]  - attr(*, "resolved")= logi FALSE
[13:21:51.007]  - attr(*, "total_size")= num 4720
[13:21:51.007]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:51.007]  - attr(*, "already-done")= logi TRUE
[13:21:51.012] - reassign environment for ‘...future.FUN’
[13:21:51.012] - copied ‘...future.FUN’ to environment
[13:21:51.012] - copied ‘future.call.arguments’ to environment
[13:21:51.012] - copied ‘...future.elements_ii’ to environment
[13:21:51.012] - copied ‘...future.seeds_ii’ to environment
[13:21:51.013] - copied ‘...future.globals.maxSize’ to environment
[13:21:51.013] assign_globals() ... done
[13:21:51.013] plan(): Setting new future strategy stack:
[13:21:51.013] List of future strategies:
[13:21:51.013] 1. sequential:
[13:21:51.013]    - args: function (..., envir = parent.frame())
[13:21:51.013]    - tweaked: FALSE
[13:21:51.013]    - call: NULL
[13:21:51.013] plan(): nbrOfWorkers() = 1
[13:21:51.515] plan(): Setting new future strategy stack:
[13:21:51.515] List of future strategies:
[13:21:51.515] 1. multicore:
[13:21:51.515]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:51.515]    - tweaked: FALSE
[13:21:51.515]    - call: plan(strategy)
[13:21:51.521] plan(): nbrOfWorkers() = 1
[13:21:51.521] SequentialFuture started (and completed)
[13:21:51.522] - Launch lazy future ... done
[13:21:51.522] run() for ‘SequentialFuture’ ... done
[13:21:51.522] Created future:
[13:21:51.522] SequentialFuture:
[13:21:51.522] Label: ‘future_lapply-1’
[13:21:51.522] Expression:
[13:21:51.522] {
[13:21:51.522]     do.call(function(...) {
[13:21:51.522]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:51.522]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:51.522]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:51.522]             on.exit(options(oopts), add = TRUE)
[13:21:51.522]         }
[13:21:51.522]         {
[13:21:51.522]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:51.522]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:51.522]                 ...future.FUN(...future.X_jj, ...)
[13:21:51.522]             })
[13:21:51.522]         }
[13:21:51.522]     }, args = future.call.arguments)
[13:21:51.522] }
[13:21:51.522] Lazy evaluation: FALSE
[13:21:51.522] Asynchronous evaluation: FALSE
[13:21:51.522] Local evaluation: TRUE
[13:21:51.522] Environment: R_GlobalEnv
[13:21:51.522] Capture standard output: FALSE
[13:21:51.522] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:51.522] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:51.522] Packages: <none>
[13:21:51.522] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:51.522] Resolved: TRUE
[13:21:51.522] Value: 112 bytes of class ‘list’
[13:21:51.522] Early signaling: FALSE
[13:21:51.522] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:21:51.522] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:51.523] Chunk #1 of 1 ... DONE
[13:21:51.523] Launching 1 futures (chunks) ... DONE
[13:21:51.523] Resolving 1 futures (chunks) ...
[13:21:51.523] resolve() on list ...
[13:21:51.523]  recursive: 0
[13:21:51.523]  length: 1
[13:21:51.524] 
[13:21:51.524] resolved() for ‘SequentialFuture’ ...
[13:21:51.524] - state: ‘finished’
[13:21:51.524] - run: TRUE
[13:21:51.524] - result: ‘FutureResult’
[13:21:51.524] resolved() for ‘SequentialFuture’ ... done
[13:21:51.524] Future #1
[13:21:51.524] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:51.524] - nx: 1
[13:21:51.525] - relay: TRUE
[13:21:51.525] - stdout: TRUE
[13:21:51.525] - signal: TRUE
[13:21:51.525] - resignal: FALSE
[13:21:51.525] - force: TRUE
[13:21:51.525] - relayed: [n=1] FALSE
[13:21:51.525] - queued futures: [n=1] FALSE
[13:21:51.525]  - until=1
[13:21:51.525]  - relaying element #1
[13:21:51.525] - relayed: [n=1] TRUE
[13:21:51.525] - queued futures: [n=1] TRUE
[13:21:51.526] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:51.526]  length: 0 (resolved future 1)
[13:21:51.526] Relaying remaining futures
[13:21:51.526] signalConditionsASAP(NULL, pos=0) ...
[13:21:51.526] - nx: 1
[13:21:51.526] - relay: TRUE
[13:21:51.526] - stdout: TRUE
[13:21:51.526] - signal: TRUE
[13:21:51.526] - resignal: FALSE
[13:21:51.526] - force: TRUE
[13:21:51.526] - relayed: [n=1] TRUE
[13:21:51.526] - queued futures: [n=1] TRUE
 - flush all
[13:21:51.527] - relayed: [n=1] TRUE
[13:21:51.527] - queued futures: [n=1] TRUE
[13:21:51.527] signalConditionsASAP(NULL, pos=0) ... done
[13:21:51.527] resolve() on list ... DONE
[13:21:51.527]  - Number of value chunks collected: 1
[13:21:51.527] Resolving 1 futures (chunks) ... DONE
[13:21:51.527] Reducing values from 1 chunks ...
[13:21:51.527]  - Number of values collected after concatenation: 2
[13:21:51.527]  - Number of values expected: 2
[13:21:51.527] Reducing values from 1 chunks ... DONE
[13:21:51.528] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[13:21:51.528] future_lapply() ...
[13:21:51.532] Number of chunks: 1
[13:21:51.532] getGlobalsAndPackagesXApply() ...
[13:21:51.532]  - future.globals: TRUE
[13:21:51.532] getGlobalsAndPackages() ...
[13:21:51.532] Searching for globals...
[13:21:51.534] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:21:51.534] Searching for globals ... DONE
[13:21:51.534] Resolving globals: FALSE
[13:21:51.534] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:21:51.535] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:21:51.535] - globals: [1] ‘FUN’
[13:21:51.535] 
[13:21:51.535] getGlobalsAndPackages() ... DONE
[13:21:51.535]  - globals found/used: [n=1] ‘FUN’
[13:21:51.535]  - needed namespaces: [n=0] 
[13:21:51.535] Finding globals ... DONE
[13:21:51.535]  - use_args: TRUE
[13:21:51.535]  - Getting '...' globals ...
[13:21:51.536] resolve() on list ...
[13:21:51.536]  recursive: 0
[13:21:51.536]  length: 1
[13:21:51.536]  elements: ‘...’
[13:21:51.536]  length: 0 (resolved future 1)
[13:21:51.536] resolve() on list ... DONE
[13:21:51.536]    - '...' content: [n=0] 
[13:21:51.536] List of 1
[13:21:51.536]  $ ...: list()
[13:21:51.536]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:51.536]  - attr(*, "where")=List of 1
[13:21:51.536]   ..$ ...:<environment: 0x55dd73281f50> 
[13:21:51.536]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:51.536]  - attr(*, "resolved")= logi TRUE
[13:21:51.536]  - attr(*, "total_size")= num NA
[13:21:51.539]  - Getting '...' globals ... DONE
[13:21:51.539] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:21:51.539] List of 2
[13:21:51.539]  $ ...future.FUN:function (x)  
[13:21:51.539]  $ ...          : list()
[13:21:51.539]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:51.539]  - attr(*, "where")=List of 2
[13:21:51.539]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:51.539]   ..$ ...          :<environment: 0x55dd73281f50> 
[13:21:51.539]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:51.539]  - attr(*, "resolved")= logi FALSE
[13:21:51.539]  - attr(*, "total_size")= num 4720
[13:21:51.542] Packages to be attached in all futures: [n=0] 
[13:21:51.542] getGlobalsAndPackagesXApply() ... DONE
[13:21:51.542] Number of futures (= number of chunks): 1
[13:21:51.542] Launching 1 futures (chunks) ...
[13:21:51.542] Chunk #1 of 1 ...
[13:21:51.543]  - Finding globals in 'X' for chunk #1 ...
[13:21:51.543] getGlobalsAndPackages() ...
[13:21:51.543] Searching for globals...
[13:21:51.543] 
[13:21:51.543] Searching for globals ... DONE
[13:21:51.543] - globals: [0] <none>
[13:21:51.543] getGlobalsAndPackages() ... DONE
[13:21:51.543]    + additional globals found: [n=0] 
[13:21:51.543]    + additional namespaces needed: [n=0] 
[13:21:51.544]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:51.544]  - seeds: <none>
[13:21:51.544]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:51.544] getGlobalsAndPackages() ...
[13:21:51.544] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:51.544] Resolving globals: FALSE
[13:21:51.544] Tweak future expression to call with '...' arguments ...
[13:21:51.544] {
[13:21:51.544]     do.call(function(...) {
[13:21:51.544]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:51.544]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:51.544]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:51.544]             on.exit(options(oopts), add = TRUE)
[13:21:51.544]         }
[13:21:51.544]         {
[13:21:51.544]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:51.544]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:51.544]                 ...future.FUN(...future.X_jj, ...)
[13:21:51.544]             })
[13:21:51.544]         }
[13:21:51.544]     }, args = future.call.arguments)
[13:21:51.544] }
[13:21:51.545] Tweak future expression to call with '...' arguments ... DONE
[13:21:51.546] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:51.547] 
[13:21:51.547] getGlobalsAndPackages() ... DONE
[13:21:51.547] run() for ‘Future’ ...
[13:21:51.547] - state: ‘created’
[13:21:51.547] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:51.551] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:51.551] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:51.551]   - Field: ‘label’
[13:21:51.551]   - Field: ‘local’
[13:21:51.551]   - Field: ‘owner’
[13:21:51.551]   - Field: ‘envir’
[13:21:51.551]   - Field: ‘packages’
[13:21:51.552]   - Field: ‘gc’
[13:21:51.552]   - Field: ‘conditions’
[13:21:51.552]   - Field: ‘expr’
[13:21:51.552]   - Field: ‘uuid’
[13:21:51.552]   - Field: ‘seed’
[13:21:51.552]   - Field: ‘version’
[13:21:51.552]   - Field: ‘result’
[13:21:51.552]   - Field: ‘asynchronous’
[13:21:51.552]   - Field: ‘calls’
[13:21:51.552]   - Field: ‘globals’
[13:21:51.553]   - Field: ‘stdout’
[13:21:51.553]   - Field: ‘earlySignal’
[13:21:51.553]   - Field: ‘lazy’
[13:21:51.553]   - Field: ‘state’
[13:21:51.553] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:51.553] - Launch lazy future ...
[13:21:51.553] Packages needed by the future expression (n = 0): <none>
[13:21:51.553] Packages needed by future strategies (n = 0): <none>
[13:21:51.554] {
[13:21:51.554]     {
[13:21:51.554]         {
[13:21:51.554]             ...future.startTime <- base::Sys.time()
[13:21:51.554]             {
[13:21:51.554]                 {
[13:21:51.554]                   {
[13:21:51.554]                     base::local({
[13:21:51.554]                       has_future <- base::requireNamespace("future", 
[13:21:51.554]                         quietly = TRUE)
[13:21:51.554]                       if (has_future) {
[13:21:51.554]                         ns <- base::getNamespace("future")
[13:21:51.554]                         version <- ns[[".package"]][["version"]]
[13:21:51.554]                         if (is.null(version)) 
[13:21:51.554]                           version <- utils::packageVersion("future")
[13:21:51.554]                       }
[13:21:51.554]                       else {
[13:21:51.554]                         version <- NULL
[13:21:51.554]                       }
[13:21:51.554]                       if (!has_future || version < "1.8.0") {
[13:21:51.554]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:51.554]                           "", base::R.version$version.string), 
[13:21:51.554]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:51.554]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:51.554]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:51.554]                             "release", "version")], collapse = " "), 
[13:21:51.554]                           hostname = base::Sys.info()[["nodename"]])
[13:21:51.554]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:51.554]                           info)
[13:21:51.554]                         info <- base::paste(info, collapse = "; ")
[13:21:51.554]                         if (!has_future) {
[13:21:51.554]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:51.554]                             info)
[13:21:51.554]                         }
[13:21:51.554]                         else {
[13:21:51.554]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:51.554]                             info, version)
[13:21:51.554]                         }
[13:21:51.554]                         base::stop(msg)
[13:21:51.554]                       }
[13:21:51.554]                     })
[13:21:51.554]                   }
[13:21:51.554]                   options(future.plan = NULL)
[13:21:51.554]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:51.554]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:51.554]                 }
[13:21:51.554]                 ...future.workdir <- getwd()
[13:21:51.554]             }
[13:21:51.554]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:51.554]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:51.554]         }
[13:21:51.554]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:51.554]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:51.554]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:51.554]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:51.554]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:51.554]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:51.554]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:51.554]             base::names(...future.oldOptions))
[13:21:51.554]     }
[13:21:51.554]     if (FALSE) {
[13:21:51.554]     }
[13:21:51.554]     else {
[13:21:51.554]         if (TRUE) {
[13:21:51.554]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:51.554]                 open = "w")
[13:21:51.554]         }
[13:21:51.554]         else {
[13:21:51.554]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:51.554]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:51.554]         }
[13:21:51.554]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:51.554]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:51.554]             base::sink(type = "output", split = FALSE)
[13:21:51.554]             base::close(...future.stdout)
[13:21:51.554]         }, add = TRUE)
[13:21:51.554]     }
[13:21:51.554]     ...future.frame <- base::sys.nframe()
[13:21:51.554]     ...future.conditions <- base::list()
[13:21:51.554]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:51.554]     if (FALSE) {
[13:21:51.554]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:51.554]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:51.554]     }
[13:21:51.554]     ...future.result <- base::tryCatch({
[13:21:51.554]         base::withCallingHandlers({
[13:21:51.554]             ...future.value <- base::withVisible(base::local({
[13:21:51.554]                 do.call(function(...) {
[13:21:51.554]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:51.554]                   if (!identical(...future.globals.maxSize.org, 
[13:21:51.554]                     ...future.globals.maxSize)) {
[13:21:51.554]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:51.554]                     on.exit(options(oopts), add = TRUE)
[13:21:51.554]                   }
[13:21:51.554]                   {
[13:21:51.554]                     lapply(seq_along(...future.elements_ii), 
[13:21:51.554]                       FUN = function(jj) {
[13:21:51.554]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:51.554]                         ...future.FUN(...future.X_jj, ...)
[13:21:51.554]                       })
[13:21:51.554]                   }
[13:21:51.554]                 }, args = future.call.arguments)
[13:21:51.554]             }))
[13:21:51.554]             future::FutureResult(value = ...future.value$value, 
[13:21:51.554]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:51.554]                   ...future.rng), globalenv = if (FALSE) 
[13:21:51.554]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:51.554]                     ...future.globalenv.names))
[13:21:51.554]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:51.554]         }, condition = base::local({
[13:21:51.554]             c <- base::c
[13:21:51.554]             inherits <- base::inherits
[13:21:51.554]             invokeRestart <- base::invokeRestart
[13:21:51.554]             length <- base::length
[13:21:51.554]             list <- base::list
[13:21:51.554]             seq.int <- base::seq.int
[13:21:51.554]             signalCondition <- base::signalCondition
[13:21:51.554]             sys.calls <- base::sys.calls
[13:21:51.554]             `[[` <- base::`[[`
[13:21:51.554]             `+` <- base::`+`
[13:21:51.554]             `<<-` <- base::`<<-`
[13:21:51.554]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:51.554]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:51.554]                   3L)]
[13:21:51.554]             }
[13:21:51.554]             function(cond) {
[13:21:51.554]                 is_error <- inherits(cond, "error")
[13:21:51.554]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:51.554]                   NULL)
[13:21:51.554]                 if (is_error) {
[13:21:51.554]                   sessionInformation <- function() {
[13:21:51.554]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:51.554]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:51.554]                       search = base::search(), system = base::Sys.info())
[13:21:51.554]                   }
[13:21:51.554]                   ...future.conditions[[length(...future.conditions) + 
[13:21:51.554]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:51.554]                     cond$call), session = sessionInformation(), 
[13:21:51.554]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:51.554]                   signalCondition(cond)
[13:21:51.554]                 }
[13:21:51.554]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:51.554]                 "immediateCondition"))) {
[13:21:51.554]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:51.554]                   ...future.conditions[[length(...future.conditions) + 
[13:21:51.554]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:51.554]                   if (TRUE && !signal) {
[13:21:51.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:51.554]                     {
[13:21:51.554]                       inherits <- base::inherits
[13:21:51.554]                       invokeRestart <- base::invokeRestart
[13:21:51.554]                       is.null <- base::is.null
[13:21:51.554]                       muffled <- FALSE
[13:21:51.554]                       if (inherits(cond, "message")) {
[13:21:51.554]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:51.554]                         if (muffled) 
[13:21:51.554]                           invokeRestart("muffleMessage")
[13:21:51.554]                       }
[13:21:51.554]                       else if (inherits(cond, "warning")) {
[13:21:51.554]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:51.554]                         if (muffled) 
[13:21:51.554]                           invokeRestart("muffleWarning")
[13:21:51.554]                       }
[13:21:51.554]                       else if (inherits(cond, "condition")) {
[13:21:51.554]                         if (!is.null(pattern)) {
[13:21:51.554]                           computeRestarts <- base::computeRestarts
[13:21:51.554]                           grepl <- base::grepl
[13:21:51.554]                           restarts <- computeRestarts(cond)
[13:21:51.554]                           for (restart in restarts) {
[13:21:51.554]                             name <- restart$name
[13:21:51.554]                             if (is.null(name)) 
[13:21:51.554]                               next
[13:21:51.554]                             if (!grepl(pattern, name)) 
[13:21:51.554]                               next
[13:21:51.554]                             invokeRestart(restart)
[13:21:51.554]                             muffled <- TRUE
[13:21:51.554]                             break
[13:21:51.554]                           }
[13:21:51.554]                         }
[13:21:51.554]                       }
[13:21:51.554]                       invisible(muffled)
[13:21:51.554]                     }
[13:21:51.554]                     muffleCondition(cond, pattern = "^muffle")
[13:21:51.554]                   }
[13:21:51.554]                 }
[13:21:51.554]                 else {
[13:21:51.554]                   if (TRUE) {
[13:21:51.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:51.554]                     {
[13:21:51.554]                       inherits <- base::inherits
[13:21:51.554]                       invokeRestart <- base::invokeRestart
[13:21:51.554]                       is.null <- base::is.null
[13:21:51.554]                       muffled <- FALSE
[13:21:51.554]                       if (inherits(cond, "message")) {
[13:21:51.554]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:51.554]                         if (muffled) 
[13:21:51.554]                           invokeRestart("muffleMessage")
[13:21:51.554]                       }
[13:21:51.554]                       else if (inherits(cond, "warning")) {
[13:21:51.554]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:51.554]                         if (muffled) 
[13:21:51.554]                           invokeRestart("muffleWarning")
[13:21:51.554]                       }
[13:21:51.554]                       else if (inherits(cond, "condition")) {
[13:21:51.554]                         if (!is.null(pattern)) {
[13:21:51.554]                           computeRestarts <- base::computeRestarts
[13:21:51.554]                           grepl <- base::grepl
[13:21:51.554]                           restarts <- computeRestarts(cond)
[13:21:51.554]                           for (restart in restarts) {
[13:21:51.554]                             name <- restart$name
[13:21:51.554]                             if (is.null(name)) 
[13:21:51.554]                               next
[13:21:51.554]                             if (!grepl(pattern, name)) 
[13:21:51.554]                               next
[13:21:51.554]                             invokeRestart(restart)
[13:21:51.554]                             muffled <- TRUE
[13:21:51.554]                             break
[13:21:51.554]                           }
[13:21:51.554]                         }
[13:21:51.554]                       }
[13:21:51.554]                       invisible(muffled)
[13:21:51.554]                     }
[13:21:51.554]                     muffleCondition(cond, pattern = "^muffle")
[13:21:51.554]                   }
[13:21:51.554]                 }
[13:21:51.554]             }
[13:21:51.554]         }))
[13:21:51.554]     }, error = function(ex) {
[13:21:51.554]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:51.554]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:51.554]                 ...future.rng), started = ...future.startTime, 
[13:21:51.554]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:51.554]             version = "1.8"), class = "FutureResult")
[13:21:51.554]     }, finally = {
[13:21:51.554]         if (!identical(...future.workdir, getwd())) 
[13:21:51.554]             setwd(...future.workdir)
[13:21:51.554]         {
[13:21:51.554]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:51.554]                 ...future.oldOptions$nwarnings <- NULL
[13:21:51.554]             }
[13:21:51.554]             base::options(...future.oldOptions)
[13:21:51.554]             if (.Platform$OS.type == "windows") {
[13:21:51.554]                 old_names <- names(...future.oldEnvVars)
[13:21:51.554]                 envs <- base::Sys.getenv()
[13:21:51.554]                 names <- names(envs)
[13:21:51.554]                 common <- intersect(names, old_names)
[13:21:51.554]                 added <- setdiff(names, old_names)
[13:21:51.554]                 removed <- setdiff(old_names, names)
[13:21:51.554]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:51.554]                   envs[common]]
[13:21:51.554]                 NAMES <- toupper(changed)
[13:21:51.554]                 args <- list()
[13:21:51.554]                 for (kk in seq_along(NAMES)) {
[13:21:51.554]                   name <- changed[[kk]]
[13:21:51.554]                   NAME <- NAMES[[kk]]
[13:21:51.554]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:51.554]                     next
[13:21:51.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:51.554]                 }
[13:21:51.554]                 NAMES <- toupper(added)
[13:21:51.554]                 for (kk in seq_along(NAMES)) {
[13:21:51.554]                   name <- added[[kk]]
[13:21:51.554]                   NAME <- NAMES[[kk]]
[13:21:51.554]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:51.554]                     next
[13:21:51.554]                   args[[name]] <- ""
[13:21:51.554]                 }
[13:21:51.554]                 NAMES <- toupper(removed)
[13:21:51.554]                 for (kk in seq_along(NAMES)) {
[13:21:51.554]                   name <- removed[[kk]]
[13:21:51.554]                   NAME <- NAMES[[kk]]
[13:21:51.554]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:51.554]                     next
[13:21:51.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:51.554]                 }
[13:21:51.554]                 if (length(args) > 0) 
[13:21:51.554]                   base::do.call(base::Sys.setenv, args = args)
[13:21:51.554]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:51.554]             }
[13:21:51.554]             else {
[13:21:51.554]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:51.554]             }
[13:21:51.554]             {
[13:21:51.554]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:51.554]                   0L) {
[13:21:51.554]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:51.554]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:51.554]                   base::options(opts)
[13:21:51.554]                 }
[13:21:51.554]                 {
[13:21:51.554]                   {
[13:21:51.554]                     NULL
[13:21:51.554]                     RNGkind("Mersenne-Twister")
[13:21:51.554]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:51.554]                       inherits = FALSE)
[13:21:51.554]                   }
[13:21:51.554]                   options(future.plan = NULL)
[13:21:51.554]                   if (is.na(NA_character_)) 
[13:21:51.554]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:51.554]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:51.554]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:51.554]                     envir = parent.frame()) 
[13:21:51.554]                   {
[13:21:51.554]                     default_workers <- missing(workers)
[13:21:51.554]                     if (is.function(workers)) 
[13:21:51.554]                       workers <- workers()
[13:21:51.554]                     workers <- structure(as.integer(workers), 
[13:21:51.554]                       class = class(workers))
[13:21:51.554]                     stop_if_not(is.finite(workers), workers >= 
[13:21:51.554]                       1L)
[13:21:51.554]                     if ((workers == 1L && !inherits(workers, 
[13:21:51.554]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:51.554]                       if (default_workers) 
[13:21:51.554]                         supportsMulticore(warn = TRUE)
[13:21:51.554]                       return(sequential(..., envir = envir))
[13:21:51.554]                     }
[13:21:51.554]                     oopts <- options(mc.cores = workers)
[13:21:51.554]                     on.exit(options(oopts))
[13:21:51.554]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:51.554]                       envir = envir)
[13:21:51.554]                     if (!future$lazy) 
[13:21:51.554]                       future <- run(future)
[13:21:51.554]                     invisible(future)
[13:21:51.554]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:51.554]                 }
[13:21:51.554]             }
[13:21:51.554]         }
[13:21:51.554]     })
[13:21:51.554]     if (TRUE) {
[13:21:51.554]         base::sink(type = "output", split = FALSE)
[13:21:51.554]         if (TRUE) {
[13:21:51.554]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:51.554]         }
[13:21:51.554]         else {
[13:21:51.554]             ...future.result["stdout"] <- base::list(NULL)
[13:21:51.554]         }
[13:21:51.554]         base::close(...future.stdout)
[13:21:51.554]         ...future.stdout <- NULL
[13:21:51.554]     }
[13:21:51.554]     ...future.result$conditions <- ...future.conditions
[13:21:51.554]     ...future.result$finished <- base::Sys.time()
[13:21:51.554]     ...future.result
[13:21:51.554] }
[13:21:51.556] assign_globals() ...
[13:21:51.556] List of 5
[13:21:51.556]  $ ...future.FUN            :function (x)  
[13:21:51.556]  $ future.call.arguments    : list()
[13:21:51.556]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:51.556]  $ ...future.elements_ii    :List of 2
[13:21:51.556]   ..$ : int 1
[13:21:51.556]   ..$ : int 0
[13:21:51.556]  $ ...future.seeds_ii       : NULL
[13:21:51.556]  $ ...future.globals.maxSize: NULL
[13:21:51.556]  - attr(*, "where")=List of 5
[13:21:51.556]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:51.556]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:51.556]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:51.556]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:51.556]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:51.556]  - attr(*, "resolved")= logi FALSE
[13:21:51.556]  - attr(*, "total_size")= num 4720
[13:21:51.556]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:51.556]  - attr(*, "already-done")= logi TRUE
[13:21:51.561] - reassign environment for ‘...future.FUN’
[13:21:51.561] - copied ‘...future.FUN’ to environment
[13:21:51.561] - copied ‘future.call.arguments’ to environment
[13:21:51.561] - copied ‘...future.elements_ii’ to environment
[13:21:51.561] - copied ‘...future.seeds_ii’ to environment
[13:21:51.561] - copied ‘...future.globals.maxSize’ to environment
[13:21:51.561] assign_globals() ... done
[13:21:51.562] plan(): Setting new future strategy stack:
[13:21:51.562] List of future strategies:
[13:21:51.562] 1. sequential:
[13:21:51.562]    - args: function (..., envir = parent.frame())
[13:21:51.562]    - tweaked: FALSE
[13:21:51.562]    - call: NULL
[13:21:51.562] plan(): nbrOfWorkers() = 1
[13:21:52.064] plan(): Setting new future strategy stack:
[13:21:52.064] List of future strategies:
[13:21:52.064] 1. multicore:
[13:21:52.064]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:52.064]    - tweaked: FALSE
[13:21:52.064]    - call: plan(strategy)
[13:21:52.068] plan(): nbrOfWorkers() = 1
[13:21:52.068] SequentialFuture started (and completed)
[13:21:52.068] - Launch lazy future ... done
[13:21:52.069] run() for ‘SequentialFuture’ ... done
[13:21:52.069] Created future:
[13:21:52.069] SequentialFuture:
[13:21:52.069] Label: ‘future_lapply-1’
[13:21:52.069] Expression:
[13:21:52.069] {
[13:21:52.069]     do.call(function(...) {
[13:21:52.069]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:52.069]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:52.069]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:52.069]             on.exit(options(oopts), add = TRUE)
[13:21:52.069]         }
[13:21:52.069]         {
[13:21:52.069]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:52.069]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:52.069]                 ...future.FUN(...future.X_jj, ...)
[13:21:52.069]             })
[13:21:52.069]         }
[13:21:52.069]     }, args = future.call.arguments)
[13:21:52.069] }
[13:21:52.069] Lazy evaluation: FALSE
[13:21:52.069] Asynchronous evaluation: FALSE
[13:21:52.069] Local evaluation: TRUE
[13:21:52.069] Environment: R_GlobalEnv
[13:21:52.069] Capture standard output: TRUE
[13:21:52.069] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:52.069] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:52.069] Packages: <none>
[13:21:52.069] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:52.069] Resolved: TRUE
[13:21:52.069] Value: 112 bytes of class ‘list’
[13:21:52.069] Early signaling: FALSE
[13:21:52.069] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:21:52.069] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:52.070] Chunk #1 of 1 ... DONE
[13:21:52.070] Launching 1 futures (chunks) ... DONE
[13:21:52.070] Resolving 1 futures (chunks) ...
[13:21:52.070] resolve() on list ...
[13:21:52.070]  recursive: 0
[13:21:52.070]  length: 1
[13:21:52.071] 
[13:21:52.071] resolved() for ‘SequentialFuture’ ...
[13:21:52.071] - state: ‘finished’
[13:21:52.071] - run: TRUE
[13:21:52.071] - result: ‘FutureResult’
[13:21:52.071] resolved() for ‘SequentialFuture’ ... done
[13:21:52.071] Future #1
[13:21:52.071] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:52.071] - nx: 1
[13:21:52.071] - relay: TRUE
[13:21:52.072] - stdout: TRUE
[13:21:52.072] - signal: TRUE
[13:21:52.072] - resignal: FALSE
[13:21:52.072] - force: TRUE
[13:21:52.072] - relayed: [n=1] FALSE
[13:21:52.072] - queued futures: [n=1] FALSE
[13:21:52.072]  - until=1
[13:21:52.072]  - relaying element #1
[13:21:52.072] - relayed: [n=1] TRUE
[13:21:52.072] - queued futures: [n=1] TRUE
[13:21:52.073] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:52.073]  length: 0 (resolved future 1)
[13:21:52.073] Relaying remaining futures
[13:21:52.073] signalConditionsASAP(NULL, pos=0) ...
[13:21:52.073] - nx: 1
[13:21:52.073] - relay: TRUE
[13:21:52.073] - stdout: TRUE
[13:21:52.073] - signal: TRUE
[13:21:52.073] - resignal: FALSE
[13:21:52.073] - force: TRUE
[13:21:52.073] - relayed: [n=1] TRUE
[13:21:52.073] - queued futures: [n=1] TRUE
 - flush all
[13:21:52.074] - relayed: [n=1] TRUE
[13:21:52.074] - queued futures: [n=1] TRUE
[13:21:52.074] signalConditionsASAP(NULL, pos=0) ... done
[13:21:52.074] resolve() on list ... DONE
[13:21:52.074]  - Number of value chunks collected: 1
[13:21:52.074] Resolving 1 futures (chunks) ... DONE
[13:21:52.074] Reducing values from 1 chunks ...
[13:21:52.074]  - Number of values collected after concatenation: 2
[13:21:52.074]  - Number of values expected: 2
[13:21:52.074] Reducing values from 1 chunks ... DONE
[13:21:52.075] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[13:21:52.075] future_lapply() ...
[13:21:52.079] Number of chunks: 1
[13:21:52.081] getGlobalsAndPackagesXApply() ...
[13:21:52.081]  - future.globals: TRUE
[13:21:52.081] getGlobalsAndPackages() ...
[13:21:52.081] Searching for globals...
[13:21:52.082] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:21:52.083] Searching for globals ... DONE
[13:21:52.083] Resolving globals: FALSE
[13:21:52.083] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:21:52.083] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:21:52.083] - globals: [1] ‘FUN’
[13:21:52.084] 
[13:21:52.084] getGlobalsAndPackages() ... DONE
[13:21:52.084]  - globals found/used: [n=1] ‘FUN’
[13:21:52.084]  - needed namespaces: [n=0] 
[13:21:52.084] Finding globals ... DONE
[13:21:52.084]  - use_args: TRUE
[13:21:52.084]  - Getting '...' globals ...
[13:21:52.084] resolve() on list ...
[13:21:52.085]  recursive: 0
[13:21:52.085]  length: 1
[13:21:52.085]  elements: ‘...’
[13:21:52.085]  length: 0 (resolved future 1)
[13:21:52.085] resolve() on list ... DONE
[13:21:52.085]    - '...' content: [n=0] 
[13:21:52.085] List of 1
[13:21:52.085]  $ ...: list()
[13:21:52.085]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:52.085]  - attr(*, "where")=List of 1
[13:21:52.085]   ..$ ...:<environment: 0x55dd74ad6a10> 
[13:21:52.085]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:52.085]  - attr(*, "resolved")= logi TRUE
[13:21:52.085]  - attr(*, "total_size")= num NA
[13:21:52.088]  - Getting '...' globals ... DONE
[13:21:52.088] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:21:52.088] List of 2
[13:21:52.088]  $ ...future.FUN:function (x)  
[13:21:52.088]  $ ...          : list()
[13:21:52.088]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:52.088]  - attr(*, "where")=List of 2
[13:21:52.088]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:52.088]   ..$ ...          :<environment: 0x55dd74ad6a10> 
[13:21:52.088]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:52.088]  - attr(*, "resolved")= logi FALSE
[13:21:52.088]  - attr(*, "total_size")= num 4720
[13:21:52.091] Packages to be attached in all futures: [n=0] 
[13:21:52.091] getGlobalsAndPackagesXApply() ... DONE
[13:21:52.091] Number of futures (= number of chunks): 1
[13:21:52.091] Launching 1 futures (chunks) ...
[13:21:52.091] Chunk #1 of 1 ...
[13:21:52.091]  - Finding globals in 'X' for chunk #1 ...
[13:21:52.091] getGlobalsAndPackages() ...
[13:21:52.091] Searching for globals...
[13:21:52.092] 
[13:21:52.092] Searching for globals ... DONE
[13:21:52.092] - globals: [0] <none>
[13:21:52.092] getGlobalsAndPackages() ... DONE
[13:21:52.092]    + additional globals found: [n=0] 
[13:21:52.092]    + additional namespaces needed: [n=0] 
[13:21:52.092]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:52.092]  - seeds: <none>
[13:21:52.092]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:52.093] getGlobalsAndPackages() ...
[13:21:52.093] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:52.093] Resolving globals: FALSE
[13:21:52.093] Tweak future expression to call with '...' arguments ...
[13:21:52.093] {
[13:21:52.093]     do.call(function(...) {
[13:21:52.093]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:52.093]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:52.093]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:52.093]             on.exit(options(oopts), add = TRUE)
[13:21:52.093]         }
[13:21:52.093]         {
[13:21:52.093]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:52.093]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:52.093]                 ...future.FUN(...future.X_jj, ...)
[13:21:52.093]             })
[13:21:52.093]         }
[13:21:52.093]     }, args = future.call.arguments)
[13:21:52.093] }
[13:21:52.093] Tweak future expression to call with '...' arguments ... DONE
[13:21:52.094] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:52.094] 
[13:21:52.094] getGlobalsAndPackages() ... DONE
[13:21:52.094] run() for ‘Future’ ...
[13:21:52.094] - state: ‘created’
[13:21:52.094] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:52.098] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:52.098] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:52.098]   - Field: ‘label’
[13:21:52.098]   - Field: ‘local’
[13:21:52.099]   - Field: ‘owner’
[13:21:52.099]   - Field: ‘envir’
[13:21:52.099]   - Field: ‘packages’
[13:21:52.099]   - Field: ‘gc’
[13:21:52.099]   - Field: ‘conditions’
[13:21:52.099]   - Field: ‘expr’
[13:21:52.099]   - Field: ‘uuid’
[13:21:52.099]   - Field: ‘seed’
[13:21:52.099]   - Field: ‘version’
[13:21:52.099]   - Field: ‘result’
[13:21:52.099]   - Field: ‘asynchronous’
[13:21:52.100]   - Field: ‘calls’
[13:21:52.100]   - Field: ‘globals’
[13:21:52.100]   - Field: ‘stdout’
[13:21:52.100]   - Field: ‘earlySignal’
[13:21:52.100]   - Field: ‘lazy’
[13:21:52.100]   - Field: ‘state’
[13:21:52.100] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:52.100] - Launch lazy future ...
[13:21:52.100] Packages needed by the future expression (n = 0): <none>
[13:21:52.101] Packages needed by future strategies (n = 0): <none>
[13:21:52.101] {
[13:21:52.101]     {
[13:21:52.101]         {
[13:21:52.101]             ...future.startTime <- base::Sys.time()
[13:21:52.101]             {
[13:21:52.101]                 {
[13:21:52.101]                   {
[13:21:52.101]                     base::local({
[13:21:52.101]                       has_future <- base::requireNamespace("future", 
[13:21:52.101]                         quietly = TRUE)
[13:21:52.101]                       if (has_future) {
[13:21:52.101]                         ns <- base::getNamespace("future")
[13:21:52.101]                         version <- ns[[".package"]][["version"]]
[13:21:52.101]                         if (is.null(version)) 
[13:21:52.101]                           version <- utils::packageVersion("future")
[13:21:52.101]                       }
[13:21:52.101]                       else {
[13:21:52.101]                         version <- NULL
[13:21:52.101]                       }
[13:21:52.101]                       if (!has_future || version < "1.8.0") {
[13:21:52.101]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:52.101]                           "", base::R.version$version.string), 
[13:21:52.101]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:52.101]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:52.101]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:52.101]                             "release", "version")], collapse = " "), 
[13:21:52.101]                           hostname = base::Sys.info()[["nodename"]])
[13:21:52.101]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:52.101]                           info)
[13:21:52.101]                         info <- base::paste(info, collapse = "; ")
[13:21:52.101]                         if (!has_future) {
[13:21:52.101]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:52.101]                             info)
[13:21:52.101]                         }
[13:21:52.101]                         else {
[13:21:52.101]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:52.101]                             info, version)
[13:21:52.101]                         }
[13:21:52.101]                         base::stop(msg)
[13:21:52.101]                       }
[13:21:52.101]                     })
[13:21:52.101]                   }
[13:21:52.101]                   options(future.plan = NULL)
[13:21:52.101]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:52.101]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:52.101]                 }
[13:21:52.101]                 ...future.workdir <- getwd()
[13:21:52.101]             }
[13:21:52.101]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:52.101]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:52.101]         }
[13:21:52.101]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:52.101]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:52.101]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:52.101]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:52.101]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:52.101]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:52.101]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:52.101]             base::names(...future.oldOptions))
[13:21:52.101]     }
[13:21:52.101]     if (TRUE) {
[13:21:52.101]     }
[13:21:52.101]     else {
[13:21:52.101]         if (NA) {
[13:21:52.101]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:52.101]                 open = "w")
[13:21:52.101]         }
[13:21:52.101]         else {
[13:21:52.101]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:52.101]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:52.101]         }
[13:21:52.101]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:52.101]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:52.101]             base::sink(type = "output", split = FALSE)
[13:21:52.101]             base::close(...future.stdout)
[13:21:52.101]         }, add = TRUE)
[13:21:52.101]     }
[13:21:52.101]     ...future.frame <- base::sys.nframe()
[13:21:52.101]     ...future.conditions <- base::list()
[13:21:52.101]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:52.101]     if (FALSE) {
[13:21:52.101]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:52.101]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:52.101]     }
[13:21:52.101]     ...future.result <- base::tryCatch({
[13:21:52.101]         base::withCallingHandlers({
[13:21:52.101]             ...future.value <- base::withVisible(base::local({
[13:21:52.101]                 do.call(function(...) {
[13:21:52.101]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:52.101]                   if (!identical(...future.globals.maxSize.org, 
[13:21:52.101]                     ...future.globals.maxSize)) {
[13:21:52.101]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:52.101]                     on.exit(options(oopts), add = TRUE)
[13:21:52.101]                   }
[13:21:52.101]                   {
[13:21:52.101]                     lapply(seq_along(...future.elements_ii), 
[13:21:52.101]                       FUN = function(jj) {
[13:21:52.101]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:52.101]                         ...future.FUN(...future.X_jj, ...)
[13:21:52.101]                       })
[13:21:52.101]                   }
[13:21:52.101]                 }, args = future.call.arguments)
[13:21:52.101]             }))
[13:21:52.101]             future::FutureResult(value = ...future.value$value, 
[13:21:52.101]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:52.101]                   ...future.rng), globalenv = if (FALSE) 
[13:21:52.101]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:52.101]                     ...future.globalenv.names))
[13:21:52.101]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:52.101]         }, condition = base::local({
[13:21:52.101]             c <- base::c
[13:21:52.101]             inherits <- base::inherits
[13:21:52.101]             invokeRestart <- base::invokeRestart
[13:21:52.101]             length <- base::length
[13:21:52.101]             list <- base::list
[13:21:52.101]             seq.int <- base::seq.int
[13:21:52.101]             signalCondition <- base::signalCondition
[13:21:52.101]             sys.calls <- base::sys.calls
[13:21:52.101]             `[[` <- base::`[[`
[13:21:52.101]             `+` <- base::`+`
[13:21:52.101]             `<<-` <- base::`<<-`
[13:21:52.101]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:52.101]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:52.101]                   3L)]
[13:21:52.101]             }
[13:21:52.101]             function(cond) {
[13:21:52.101]                 is_error <- inherits(cond, "error")
[13:21:52.101]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:52.101]                   NULL)
[13:21:52.101]                 if (is_error) {
[13:21:52.101]                   sessionInformation <- function() {
[13:21:52.101]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:52.101]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:52.101]                       search = base::search(), system = base::Sys.info())
[13:21:52.101]                   }
[13:21:52.101]                   ...future.conditions[[length(...future.conditions) + 
[13:21:52.101]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:52.101]                     cond$call), session = sessionInformation(), 
[13:21:52.101]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:52.101]                   signalCondition(cond)
[13:21:52.101]                 }
[13:21:52.101]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:52.101]                 "immediateCondition"))) {
[13:21:52.101]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:52.101]                   ...future.conditions[[length(...future.conditions) + 
[13:21:52.101]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:52.101]                   if (TRUE && !signal) {
[13:21:52.101]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:52.101]                     {
[13:21:52.101]                       inherits <- base::inherits
[13:21:52.101]                       invokeRestart <- base::invokeRestart
[13:21:52.101]                       is.null <- base::is.null
[13:21:52.101]                       muffled <- FALSE
[13:21:52.101]                       if (inherits(cond, "message")) {
[13:21:52.101]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:52.101]                         if (muffled) 
[13:21:52.101]                           invokeRestart("muffleMessage")
[13:21:52.101]                       }
[13:21:52.101]                       else if (inherits(cond, "warning")) {
[13:21:52.101]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:52.101]                         if (muffled) 
[13:21:52.101]                           invokeRestart("muffleWarning")
[13:21:52.101]                       }
[13:21:52.101]                       else if (inherits(cond, "condition")) {
[13:21:52.101]                         if (!is.null(pattern)) {
[13:21:52.101]                           computeRestarts <- base::computeRestarts
[13:21:52.101]                           grepl <- base::grepl
[13:21:52.101]                           restarts <- computeRestarts(cond)
[13:21:52.101]                           for (restart in restarts) {
[13:21:52.101]                             name <- restart$name
[13:21:52.101]                             if (is.null(name)) 
[13:21:52.101]                               next
[13:21:52.101]                             if (!grepl(pattern, name)) 
[13:21:52.101]                               next
[13:21:52.101]                             invokeRestart(restart)
[13:21:52.101]                             muffled <- TRUE
[13:21:52.101]                             break
[13:21:52.101]                           }
[13:21:52.101]                         }
[13:21:52.101]                       }
[13:21:52.101]                       invisible(muffled)
[13:21:52.101]                     }
[13:21:52.101]                     muffleCondition(cond, pattern = "^muffle")
[13:21:52.101]                   }
[13:21:52.101]                 }
[13:21:52.101]                 else {
[13:21:52.101]                   if (TRUE) {
[13:21:52.101]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:52.101]                     {
[13:21:52.101]                       inherits <- base::inherits
[13:21:52.101]                       invokeRestart <- base::invokeRestart
[13:21:52.101]                       is.null <- base::is.null
[13:21:52.101]                       muffled <- FALSE
[13:21:52.101]                       if (inherits(cond, "message")) {
[13:21:52.101]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:52.101]                         if (muffled) 
[13:21:52.101]                           invokeRestart("muffleMessage")
[13:21:52.101]                       }
[13:21:52.101]                       else if (inherits(cond, "warning")) {
[13:21:52.101]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:52.101]                         if (muffled) 
[13:21:52.101]                           invokeRestart("muffleWarning")
[13:21:52.101]                       }
[13:21:52.101]                       else if (inherits(cond, "condition")) {
[13:21:52.101]                         if (!is.null(pattern)) {
[13:21:52.101]                           computeRestarts <- base::computeRestarts
[13:21:52.101]                           grepl <- base::grepl
[13:21:52.101]                           restarts <- computeRestarts(cond)
[13:21:52.101]                           for (restart in restarts) {
[13:21:52.101]                             name <- restart$name
[13:21:52.101]                             if (is.null(name)) 
[13:21:52.101]                               next
[13:21:52.101]                             if (!grepl(pattern, name)) 
[13:21:52.101]                               next
[13:21:52.101]                             invokeRestart(restart)
[13:21:52.101]                             muffled <- TRUE
[13:21:52.101]                             break
[13:21:52.101]                           }
[13:21:52.101]                         }
[13:21:52.101]                       }
[13:21:52.101]                       invisible(muffled)
[13:21:52.101]                     }
[13:21:52.101]                     muffleCondition(cond, pattern = "^muffle")
[13:21:52.101]                   }
[13:21:52.101]                 }
[13:21:52.101]             }
[13:21:52.101]         }))
[13:21:52.101]     }, error = function(ex) {
[13:21:52.101]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:52.101]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:52.101]                 ...future.rng), started = ...future.startTime, 
[13:21:52.101]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:52.101]             version = "1.8"), class = "FutureResult")
[13:21:52.101]     }, finally = {
[13:21:52.101]         if (!identical(...future.workdir, getwd())) 
[13:21:52.101]             setwd(...future.workdir)
[13:21:52.101]         {
[13:21:52.101]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:52.101]                 ...future.oldOptions$nwarnings <- NULL
[13:21:52.101]             }
[13:21:52.101]             base::options(...future.oldOptions)
[13:21:52.101]             if (.Platform$OS.type == "windows") {
[13:21:52.101]                 old_names <- names(...future.oldEnvVars)
[13:21:52.101]                 envs <- base::Sys.getenv()
[13:21:52.101]                 names <- names(envs)
[13:21:52.101]                 common <- intersect(names, old_names)
[13:21:52.101]                 added <- setdiff(names, old_names)
[13:21:52.101]                 removed <- setdiff(old_names, names)
[13:21:52.101]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:52.101]                   envs[common]]
[13:21:52.101]                 NAMES <- toupper(changed)
[13:21:52.101]                 args <- list()
[13:21:52.101]                 for (kk in seq_along(NAMES)) {
[13:21:52.101]                   name <- changed[[kk]]
[13:21:52.101]                   NAME <- NAMES[[kk]]
[13:21:52.101]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:52.101]                     next
[13:21:52.101]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:52.101]                 }
[13:21:52.101]                 NAMES <- toupper(added)
[13:21:52.101]                 for (kk in seq_along(NAMES)) {
[13:21:52.101]                   name <- added[[kk]]
[13:21:52.101]                   NAME <- NAMES[[kk]]
[13:21:52.101]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:52.101]                     next
[13:21:52.101]                   args[[name]] <- ""
[13:21:52.101]                 }
[13:21:52.101]                 NAMES <- toupper(removed)
[13:21:52.101]                 for (kk in seq_along(NAMES)) {
[13:21:52.101]                   name <- removed[[kk]]
[13:21:52.101]                   NAME <- NAMES[[kk]]
[13:21:52.101]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:52.101]                     next
[13:21:52.101]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:52.101]                 }
[13:21:52.101]                 if (length(args) > 0) 
[13:21:52.101]                   base::do.call(base::Sys.setenv, args = args)
[13:21:52.101]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:52.101]             }
[13:21:52.101]             else {
[13:21:52.101]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:52.101]             }
[13:21:52.101]             {
[13:21:52.101]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:52.101]                   0L) {
[13:21:52.101]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:52.101]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:52.101]                   base::options(opts)
[13:21:52.101]                 }
[13:21:52.101]                 {
[13:21:52.101]                   {
[13:21:52.101]                     NULL
[13:21:52.101]                     RNGkind("Mersenne-Twister")
[13:21:52.101]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:52.101]                       inherits = FALSE)
[13:21:52.101]                   }
[13:21:52.101]                   options(future.plan = NULL)
[13:21:52.101]                   if (is.na(NA_character_)) 
[13:21:52.101]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:52.101]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:52.101]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:52.101]                     envir = parent.frame()) 
[13:21:52.101]                   {
[13:21:52.101]                     default_workers <- missing(workers)
[13:21:52.101]                     if (is.function(workers)) 
[13:21:52.101]                       workers <- workers()
[13:21:52.101]                     workers <- structure(as.integer(workers), 
[13:21:52.101]                       class = class(workers))
[13:21:52.101]                     stop_if_not(is.finite(workers), workers >= 
[13:21:52.101]                       1L)
[13:21:52.101]                     if ((workers == 1L && !inherits(workers, 
[13:21:52.101]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:52.101]                       if (default_workers) 
[13:21:52.101]                         supportsMulticore(warn = TRUE)
[13:21:52.101]                       return(sequential(..., envir = envir))
[13:21:52.101]                     }
[13:21:52.101]                     oopts <- options(mc.cores = workers)
[13:21:52.101]                     on.exit(options(oopts))
[13:21:52.101]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:52.101]                       envir = envir)
[13:21:52.101]                     if (!future$lazy) 
[13:21:52.101]                       future <- run(future)
[13:21:52.101]                     invisible(future)
[13:21:52.101]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:52.101]                 }
[13:21:52.101]             }
[13:21:52.101]         }
[13:21:52.101]     })
[13:21:52.101]     if (FALSE) {
[13:21:52.101]         base::sink(type = "output", split = FALSE)
[13:21:52.101]         if (NA) {
[13:21:52.101]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:52.101]         }
[13:21:52.101]         else {
[13:21:52.101]             ...future.result["stdout"] <- base::list(NULL)
[13:21:52.101]         }
[13:21:52.101]         base::close(...future.stdout)
[13:21:52.101]         ...future.stdout <- NULL
[13:21:52.101]     }
[13:21:52.101]     ...future.result$conditions <- ...future.conditions
[13:21:52.101]     ...future.result$finished <- base::Sys.time()
[13:21:52.101]     ...future.result
[13:21:52.101] }
[13:21:52.103] assign_globals() ...
[13:21:52.103] List of 5
[13:21:52.103]  $ ...future.FUN            :function (x)  
[13:21:52.103]  $ future.call.arguments    : list()
[13:21:52.103]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:52.103]  $ ...future.elements_ii    :List of 2
[13:21:52.103]   ..$ : int 1
[13:21:52.103]   ..$ : int 0
[13:21:52.103]  $ ...future.seeds_ii       : NULL
[13:21:52.103]  $ ...future.globals.maxSize: NULL
[13:21:52.103]  - attr(*, "where")=List of 5
[13:21:52.103]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:52.103]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:52.103]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:52.103]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:52.103]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:52.103]  - attr(*, "resolved")= logi FALSE
[13:21:52.103]  - attr(*, "total_size")= num 4720
[13:21:52.103]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:52.103]  - attr(*, "already-done")= logi TRUE
[13:21:52.110] - reassign environment for ‘...future.FUN’
[13:21:52.110] - copied ‘...future.FUN’ to environment
[13:21:52.110] - copied ‘future.call.arguments’ to environment
[13:21:52.110] - copied ‘...future.elements_ii’ to environment
[13:21:52.110] - copied ‘...future.seeds_ii’ to environment
[13:21:52.110] - copied ‘...future.globals.maxSize’ to environment
[13:21:52.110] assign_globals() ... done
[13:21:52.111] plan(): Setting new future strategy stack:
[13:21:52.111] List of future strategies:
[13:21:52.111] 1. sequential:
[13:21:52.111]    - args: function (..., envir = parent.frame())
[13:21:52.111]    - tweaked: FALSE
[13:21:52.111]    - call: NULL
[13:21:52.111] plan(): nbrOfWorkers() = 1
[13:21:52.613] plan(): Setting new future strategy stack:
[13:21:52.613] List of future strategies:
[13:21:52.613] 1. multicore:
[13:21:52.613]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:52.613]    - tweaked: FALSE
[13:21:52.613]    - call: plan(strategy)
[13:21:52.617] plan(): nbrOfWorkers() = 1
[13:21:52.617] SequentialFuture started (and completed)
[13:21:52.617] - Launch lazy future ... done
[13:21:52.617] run() for ‘SequentialFuture’ ... done
[13:21:52.617] Created future:
[13:21:52.617] SequentialFuture:
[13:21:52.617] Label: ‘future_lapply-1’
[13:21:52.617] Expression:
[13:21:52.617] {
[13:21:52.617]     do.call(function(...) {
[13:21:52.617]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:52.617]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:52.617]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:52.617]             on.exit(options(oopts), add = TRUE)
[13:21:52.617]         }
[13:21:52.617]         {
[13:21:52.617]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:52.617]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:52.617]                 ...future.FUN(...future.X_jj, ...)
[13:21:52.617]             })
[13:21:52.617]         }
[13:21:52.617]     }, args = future.call.arguments)
[13:21:52.617] }
[13:21:52.617] Lazy evaluation: FALSE
[13:21:52.617] Asynchronous evaluation: FALSE
[13:21:52.617] Local evaluation: TRUE
[13:21:52.617] Environment: R_GlobalEnv
[13:21:52.617] Capture standard output: NA
[13:21:52.617] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:52.617] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:52.617] Packages: <none>
[13:21:52.617] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:52.617] Resolved: TRUE
[13:21:52.617] Value: 112 bytes of class ‘list’
[13:21:52.617] Early signaling: FALSE
[13:21:52.617] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:21:52.617] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:52.618] Chunk #1 of 1 ... DONE
[13:21:52.619] Launching 1 futures (chunks) ... DONE
[13:21:52.619] Resolving 1 futures (chunks) ...
[13:21:52.619] resolve() on list ...
[13:21:52.619]  recursive: 0
[13:21:52.619]  length: 1
[13:21:52.619] 
[13:21:52.619] resolved() for ‘SequentialFuture’ ...
[13:21:52.619] - state: ‘finished’
[13:21:52.619] - run: TRUE
[13:21:52.619] - result: ‘FutureResult’
[13:21:52.620] resolved() for ‘SequentialFuture’ ... done
[13:21:52.620] Future #1
[13:21:52.620] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:52.620] - nx: 1
[13:21:52.620] - relay: TRUE
[13:21:52.620] - stdout: TRUE
[13:21:52.620] - signal: TRUE
[13:21:52.620] - resignal: FALSE
[13:21:52.620] - force: TRUE
[13:21:52.620] - relayed: [n=1] FALSE
[13:21:52.621] - queued futures: [n=1] FALSE
[13:21:52.621]  - until=1
[13:21:52.621]  - relaying element #1
[13:21:52.621] - relayed: [n=1] TRUE
[13:21:52.621] - queued futures: [n=1] TRUE
[13:21:52.621] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:52.621]  length: 0 (resolved future 1)
[13:21:52.621] Relaying remaining futures
[13:21:52.621] signalConditionsASAP(NULL, pos=0) ...
[13:21:52.621] - nx: 1
[13:21:52.622] - relay: TRUE
[13:21:52.622] - stdout: TRUE
[13:21:52.622] - signal: TRUE
[13:21:52.622] - resignal: FALSE
[13:21:52.622] - force: TRUE
[13:21:52.622] - relayed: [n=1] TRUE
[13:21:52.622] - queued futures: [n=1] TRUE
 - flush all
[13:21:52.622] - relayed: [n=1] TRUE
[13:21:52.622] - queued futures: [n=1] TRUE
[13:21:52.622] signalConditionsASAP(NULL, pos=0) ... done
[13:21:52.622] resolve() on list ... DONE
[13:21:52.623]  - Number of value chunks collected: 1
[13:21:52.623] Resolving 1 futures (chunks) ... DONE
[13:21:52.623] Reducing values from 1 chunks ...
[13:21:52.623]  - Number of values collected after concatenation: 2
[13:21:52.623]  - Number of values expected: 2
[13:21:52.623] Reducing values from 1 chunks ... DONE
[13:21:52.623] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[13:21:52.623] future_mapply() ...
[13:21:52.627] Number of chunks: 1
[13:21:52.627] getGlobalsAndPackagesXApply() ...
[13:21:52.627]  - future.globals: TRUE
[13:21:52.627] getGlobalsAndPackages() ...
[13:21:52.627] Searching for globals...
[13:21:52.629] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:21:52.629] Searching for globals ... DONE
[13:21:52.629] Resolving globals: FALSE
[13:21:52.629] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:21:52.630] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:21:52.630] - globals: [1] ‘FUN’
[13:21:52.630] 
[13:21:52.630] getGlobalsAndPackages() ... DONE
[13:21:52.630]  - globals found/used: [n=1] ‘FUN’
[13:21:52.630]  - needed namespaces: [n=0] 
[13:21:52.630] Finding globals ... DONE
[13:21:52.631] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:21:52.631] List of 2
[13:21:52.631]  $ ...future.FUN:function (x, y)  
[13:21:52.631]  $ MoreArgs     : NULL
[13:21:52.631]  - attr(*, "where")=List of 2
[13:21:52.631]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:52.631]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:21:52.631]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:52.631]  - attr(*, "resolved")= logi FALSE
[13:21:52.631]  - attr(*, "total_size")= num NA
[13:21:52.633] Packages to be attached in all futures: [n=0] 
[13:21:52.633] getGlobalsAndPackagesXApply() ... DONE
[13:21:52.634] Number of futures (= number of chunks): 1
[13:21:52.634] Launching 1 futures (chunks) ...
[13:21:52.634] Chunk #1 of 1 ...
[13:21:52.634]  - Finding globals in '...' for chunk #1 ...
[13:21:52.634] getGlobalsAndPackages() ...
[13:21:52.634] Searching for globals...
[13:21:52.634] 
[13:21:52.634] Searching for globals ... DONE
[13:21:52.635] - globals: [0] <none>
[13:21:52.635] getGlobalsAndPackages() ... DONE
[13:21:52.635]    + additional globals found: [n=0] 
[13:21:52.635]    + additional namespaces needed: [n=0] 
[13:21:52.635]  - Finding globals in '...' for chunk #1 ... DONE
[13:21:52.635]  - seeds: <none>
[13:21:52.635]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:52.635] getGlobalsAndPackages() ...
[13:21:52.635] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:52.635] Resolving globals: FALSE
[13:21:52.638] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[13:21:52.638] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:21:52.638] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:52.638] 
[13:21:52.638] getGlobalsAndPackages() ... DONE
[13:21:52.639] run() for ‘Future’ ...
[13:21:52.639] - state: ‘created’
[13:21:52.639] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:52.643] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:52.643] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:52.643]   - Field: ‘label’
[13:21:52.643]   - Field: ‘local’
[13:21:52.644]   - Field: ‘owner’
[13:21:52.644]   - Field: ‘envir’
[13:21:52.644]   - Field: ‘packages’
[13:21:52.644]   - Field: ‘gc’
[13:21:52.644]   - Field: ‘conditions’
[13:21:52.644]   - Field: ‘expr’
[13:21:52.644]   - Field: ‘uuid’
[13:21:52.644]   - Field: ‘seed’
[13:21:52.645]   - Field: ‘version’
[13:21:52.645]   - Field: ‘result’
[13:21:52.645]   - Field: ‘asynchronous’
[13:21:52.645]   - Field: ‘calls’
[13:21:52.645]   - Field: ‘globals’
[13:21:52.645]   - Field: ‘stdout’
[13:21:52.645]   - Field: ‘earlySignal’
[13:21:52.645]   - Field: ‘lazy’
[13:21:52.645]   - Field: ‘state’
[13:21:52.645] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:52.646] - Launch lazy future ...
[13:21:52.646] Packages needed by the future expression (n = 0): <none>
[13:21:52.646] Packages needed by future strategies (n = 0): <none>
[13:21:52.646] {
[13:21:52.646]     {
[13:21:52.646]         {
[13:21:52.646]             ...future.startTime <- base::Sys.time()
[13:21:52.646]             {
[13:21:52.646]                 {
[13:21:52.646]                   {
[13:21:52.646]                     base::local({
[13:21:52.646]                       has_future <- base::requireNamespace("future", 
[13:21:52.646]                         quietly = TRUE)
[13:21:52.646]                       if (has_future) {
[13:21:52.646]                         ns <- base::getNamespace("future")
[13:21:52.646]                         version <- ns[[".package"]][["version"]]
[13:21:52.646]                         if (is.null(version)) 
[13:21:52.646]                           version <- utils::packageVersion("future")
[13:21:52.646]                       }
[13:21:52.646]                       else {
[13:21:52.646]                         version <- NULL
[13:21:52.646]                       }
[13:21:52.646]                       if (!has_future || version < "1.8.0") {
[13:21:52.646]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:52.646]                           "", base::R.version$version.string), 
[13:21:52.646]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:52.646]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:52.646]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:52.646]                             "release", "version")], collapse = " "), 
[13:21:52.646]                           hostname = base::Sys.info()[["nodename"]])
[13:21:52.646]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:52.646]                           info)
[13:21:52.646]                         info <- base::paste(info, collapse = "; ")
[13:21:52.646]                         if (!has_future) {
[13:21:52.646]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:52.646]                             info)
[13:21:52.646]                         }
[13:21:52.646]                         else {
[13:21:52.646]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:52.646]                             info, version)
[13:21:52.646]                         }
[13:21:52.646]                         base::stop(msg)
[13:21:52.646]                       }
[13:21:52.646]                     })
[13:21:52.646]                   }
[13:21:52.646]                   options(future.plan = NULL)
[13:21:52.646]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:52.646]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:52.646]                 }
[13:21:52.646]                 ...future.workdir <- getwd()
[13:21:52.646]             }
[13:21:52.646]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:52.646]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:52.646]         }
[13:21:52.646]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:52.646]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:52.646]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:52.646]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:52.646]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:52.646]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:52.646]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:52.646]             base::names(...future.oldOptions))
[13:21:52.646]     }
[13:21:52.646]     if (FALSE) {
[13:21:52.646]     }
[13:21:52.646]     else {
[13:21:52.646]         if (FALSE) {
[13:21:52.646]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:52.646]                 open = "w")
[13:21:52.646]         }
[13:21:52.646]         else {
[13:21:52.646]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:52.646]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:52.646]         }
[13:21:52.646]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:52.646]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:52.646]             base::sink(type = "output", split = FALSE)
[13:21:52.646]             base::close(...future.stdout)
[13:21:52.646]         }, add = TRUE)
[13:21:52.646]     }
[13:21:52.646]     ...future.frame <- base::sys.nframe()
[13:21:52.646]     ...future.conditions <- base::list()
[13:21:52.646]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:52.646]     if (FALSE) {
[13:21:52.646]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:52.646]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:52.646]     }
[13:21:52.646]     ...future.result <- base::tryCatch({
[13:21:52.646]         base::withCallingHandlers({
[13:21:52.646]             ...future.value <- base::withVisible(base::local({
[13:21:52.646]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:52.646]                 if (!identical(...future.globals.maxSize.org, 
[13:21:52.646]                   ...future.globals.maxSize)) {
[13:21:52.646]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:52.646]                   on.exit(options(oopts), add = TRUE)
[13:21:52.646]                 }
[13:21:52.646]                 {
[13:21:52.646]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:21:52.646]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:21:52.646]                     USE.NAMES = FALSE)
[13:21:52.646]                   do.call(mapply, args = args)
[13:21:52.646]                 }
[13:21:52.646]             }))
[13:21:52.646]             future::FutureResult(value = ...future.value$value, 
[13:21:52.646]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:52.646]                   ...future.rng), globalenv = if (FALSE) 
[13:21:52.646]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:52.646]                     ...future.globalenv.names))
[13:21:52.646]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:52.646]         }, condition = base::local({
[13:21:52.646]             c <- base::c
[13:21:52.646]             inherits <- base::inherits
[13:21:52.646]             invokeRestart <- base::invokeRestart
[13:21:52.646]             length <- base::length
[13:21:52.646]             list <- base::list
[13:21:52.646]             seq.int <- base::seq.int
[13:21:52.646]             signalCondition <- base::signalCondition
[13:21:52.646]             sys.calls <- base::sys.calls
[13:21:52.646]             `[[` <- base::`[[`
[13:21:52.646]             `+` <- base::`+`
[13:21:52.646]             `<<-` <- base::`<<-`
[13:21:52.646]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:52.646]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:52.646]                   3L)]
[13:21:52.646]             }
[13:21:52.646]             function(cond) {
[13:21:52.646]                 is_error <- inherits(cond, "error")
[13:21:52.646]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:52.646]                   NULL)
[13:21:52.646]                 if (is_error) {
[13:21:52.646]                   sessionInformation <- function() {
[13:21:52.646]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:52.646]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:52.646]                       search = base::search(), system = base::Sys.info())
[13:21:52.646]                   }
[13:21:52.646]                   ...future.conditions[[length(...future.conditions) + 
[13:21:52.646]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:52.646]                     cond$call), session = sessionInformation(), 
[13:21:52.646]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:52.646]                   signalCondition(cond)
[13:21:52.646]                 }
[13:21:52.646]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:52.646]                 "immediateCondition"))) {
[13:21:52.646]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:52.646]                   ...future.conditions[[length(...future.conditions) + 
[13:21:52.646]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:52.646]                   if (TRUE && !signal) {
[13:21:52.646]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:52.646]                     {
[13:21:52.646]                       inherits <- base::inherits
[13:21:52.646]                       invokeRestart <- base::invokeRestart
[13:21:52.646]                       is.null <- base::is.null
[13:21:52.646]                       muffled <- FALSE
[13:21:52.646]                       if (inherits(cond, "message")) {
[13:21:52.646]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:52.646]                         if (muffled) 
[13:21:52.646]                           invokeRestart("muffleMessage")
[13:21:52.646]                       }
[13:21:52.646]                       else if (inherits(cond, "warning")) {
[13:21:52.646]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:52.646]                         if (muffled) 
[13:21:52.646]                           invokeRestart("muffleWarning")
[13:21:52.646]                       }
[13:21:52.646]                       else if (inherits(cond, "condition")) {
[13:21:52.646]                         if (!is.null(pattern)) {
[13:21:52.646]                           computeRestarts <- base::computeRestarts
[13:21:52.646]                           grepl <- base::grepl
[13:21:52.646]                           restarts <- computeRestarts(cond)
[13:21:52.646]                           for (restart in restarts) {
[13:21:52.646]                             name <- restart$name
[13:21:52.646]                             if (is.null(name)) 
[13:21:52.646]                               next
[13:21:52.646]                             if (!grepl(pattern, name)) 
[13:21:52.646]                               next
[13:21:52.646]                             invokeRestart(restart)
[13:21:52.646]                             muffled <- TRUE
[13:21:52.646]                             break
[13:21:52.646]                           }
[13:21:52.646]                         }
[13:21:52.646]                       }
[13:21:52.646]                       invisible(muffled)
[13:21:52.646]                     }
[13:21:52.646]                     muffleCondition(cond, pattern = "^muffle")
[13:21:52.646]                   }
[13:21:52.646]                 }
[13:21:52.646]                 else {
[13:21:52.646]                   if (TRUE) {
[13:21:52.646]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:52.646]                     {
[13:21:52.646]                       inherits <- base::inherits
[13:21:52.646]                       invokeRestart <- base::invokeRestart
[13:21:52.646]                       is.null <- base::is.null
[13:21:52.646]                       muffled <- FALSE
[13:21:52.646]                       if (inherits(cond, "message")) {
[13:21:52.646]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:52.646]                         if (muffled) 
[13:21:52.646]                           invokeRestart("muffleMessage")
[13:21:52.646]                       }
[13:21:52.646]                       else if (inherits(cond, "warning")) {
[13:21:52.646]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:52.646]                         if (muffled) 
[13:21:52.646]                           invokeRestart("muffleWarning")
[13:21:52.646]                       }
[13:21:52.646]                       else if (inherits(cond, "condition")) {
[13:21:52.646]                         if (!is.null(pattern)) {
[13:21:52.646]                           computeRestarts <- base::computeRestarts
[13:21:52.646]                           grepl <- base::grepl
[13:21:52.646]                           restarts <- computeRestarts(cond)
[13:21:52.646]                           for (restart in restarts) {
[13:21:52.646]                             name <- restart$name
[13:21:52.646]                             if (is.null(name)) 
[13:21:52.646]                               next
[13:21:52.646]                             if (!grepl(pattern, name)) 
[13:21:52.646]                               next
[13:21:52.646]                             invokeRestart(restart)
[13:21:52.646]                             muffled <- TRUE
[13:21:52.646]                             break
[13:21:52.646]                           }
[13:21:52.646]                         }
[13:21:52.646]                       }
[13:21:52.646]                       invisible(muffled)
[13:21:52.646]                     }
[13:21:52.646]                     muffleCondition(cond, pattern = "^muffle")
[13:21:52.646]                   }
[13:21:52.646]                 }
[13:21:52.646]             }
[13:21:52.646]         }))
[13:21:52.646]     }, error = function(ex) {
[13:21:52.646]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:52.646]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:52.646]                 ...future.rng), started = ...future.startTime, 
[13:21:52.646]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:52.646]             version = "1.8"), class = "FutureResult")
[13:21:52.646]     }, finally = {
[13:21:52.646]         if (!identical(...future.workdir, getwd())) 
[13:21:52.646]             setwd(...future.workdir)
[13:21:52.646]         {
[13:21:52.646]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:52.646]                 ...future.oldOptions$nwarnings <- NULL
[13:21:52.646]             }
[13:21:52.646]             base::options(...future.oldOptions)
[13:21:52.646]             if (.Platform$OS.type == "windows") {
[13:21:52.646]                 old_names <- names(...future.oldEnvVars)
[13:21:52.646]                 envs <- base::Sys.getenv()
[13:21:52.646]                 names <- names(envs)
[13:21:52.646]                 common <- intersect(names, old_names)
[13:21:52.646]                 added <- setdiff(names, old_names)
[13:21:52.646]                 removed <- setdiff(old_names, names)
[13:21:52.646]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:52.646]                   envs[common]]
[13:21:52.646]                 NAMES <- toupper(changed)
[13:21:52.646]                 args <- list()
[13:21:52.646]                 for (kk in seq_along(NAMES)) {
[13:21:52.646]                   name <- changed[[kk]]
[13:21:52.646]                   NAME <- NAMES[[kk]]
[13:21:52.646]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:52.646]                     next
[13:21:52.646]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:52.646]                 }
[13:21:52.646]                 NAMES <- toupper(added)
[13:21:52.646]                 for (kk in seq_along(NAMES)) {
[13:21:52.646]                   name <- added[[kk]]
[13:21:52.646]                   NAME <- NAMES[[kk]]
[13:21:52.646]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:52.646]                     next
[13:21:52.646]                   args[[name]] <- ""
[13:21:52.646]                 }
[13:21:52.646]                 NAMES <- toupper(removed)
[13:21:52.646]                 for (kk in seq_along(NAMES)) {
[13:21:52.646]                   name <- removed[[kk]]
[13:21:52.646]                   NAME <- NAMES[[kk]]
[13:21:52.646]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:52.646]                     next
[13:21:52.646]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:52.646]                 }
[13:21:52.646]                 if (length(args) > 0) 
[13:21:52.646]                   base::do.call(base::Sys.setenv, args = args)
[13:21:52.646]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:52.646]             }
[13:21:52.646]             else {
[13:21:52.646]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:52.646]             }
[13:21:52.646]             {
[13:21:52.646]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:52.646]                   0L) {
[13:21:52.646]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:52.646]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:52.646]                   base::options(opts)
[13:21:52.646]                 }
[13:21:52.646]                 {
[13:21:52.646]                   {
[13:21:52.646]                     NULL
[13:21:52.646]                     RNGkind("Mersenne-Twister")
[13:21:52.646]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:52.646]                       inherits = FALSE)
[13:21:52.646]                   }
[13:21:52.646]                   options(future.plan = NULL)
[13:21:52.646]                   if (is.na(NA_character_)) 
[13:21:52.646]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:52.646]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:52.646]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:52.646]                     envir = parent.frame()) 
[13:21:52.646]                   {
[13:21:52.646]                     default_workers <- missing(workers)
[13:21:52.646]                     if (is.function(workers)) 
[13:21:52.646]                       workers <- workers()
[13:21:52.646]                     workers <- structure(as.integer(workers), 
[13:21:52.646]                       class = class(workers))
[13:21:52.646]                     stop_if_not(is.finite(workers), workers >= 
[13:21:52.646]                       1L)
[13:21:52.646]                     if ((workers == 1L && !inherits(workers, 
[13:21:52.646]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:52.646]                       if (default_workers) 
[13:21:52.646]                         supportsMulticore(warn = TRUE)
[13:21:52.646]                       return(sequential(..., envir = envir))
[13:21:52.646]                     }
[13:21:52.646]                     oopts <- options(mc.cores = workers)
[13:21:52.646]                     on.exit(options(oopts))
[13:21:52.646]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:52.646]                       envir = envir)
[13:21:52.646]                     if (!future$lazy) 
[13:21:52.646]                       future <- run(future)
[13:21:52.646]                     invisible(future)
[13:21:52.646]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:52.646]                 }
[13:21:52.646]             }
[13:21:52.646]         }
[13:21:52.646]     })
[13:21:52.646]     if (TRUE) {
[13:21:52.646]         base::sink(type = "output", split = FALSE)
[13:21:52.646]         if (FALSE) {
[13:21:52.646]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:52.646]         }
[13:21:52.646]         else {
[13:21:52.646]             ...future.result["stdout"] <- base::list(NULL)
[13:21:52.646]         }
[13:21:52.646]         base::close(...future.stdout)
[13:21:52.646]         ...future.stdout <- NULL
[13:21:52.646]     }
[13:21:52.646]     ...future.result$conditions <- ...future.conditions
[13:21:52.646]     ...future.result$finished <- base::Sys.time()
[13:21:52.646]     ...future.result
[13:21:52.646] }
[13:21:52.648] assign_globals() ...
[13:21:52.648] List of 5
[13:21:52.648]  $ ...future.FUN            :function (x, y)  
[13:21:52.648]  $ MoreArgs                 : NULL
[13:21:52.648]  $ ...future.elements_ii    :List of 2
[13:21:52.648]   ..$ :List of 2
[13:21:52.648]   .. ..$ : int 1
[13:21:52.648]   .. ..$ : int 0
[13:21:52.648]   ..$ :List of 2
[13:21:52.648]   .. ..$ : int 0
[13:21:52.648]   .. ..$ : int 1
[13:21:52.648]  $ ...future.seeds_ii       : NULL
[13:21:52.648]  $ ...future.globals.maxSize: NULL
[13:21:52.648]  - attr(*, "where")=List of 5
[13:21:52.648]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:52.648]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:21:52.648]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:52.648]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:52.648]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:52.648]  - attr(*, "resolved")= logi FALSE
[13:21:52.648]  - attr(*, "total_size")= num 6480
[13:21:52.648]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:52.648]  - attr(*, "already-done")= logi TRUE
[13:21:52.654] - reassign environment for ‘...future.FUN’
[13:21:52.654] - copied ‘...future.FUN’ to environment
[13:21:52.654] - copied ‘MoreArgs’ to environment
[13:21:52.654] - copied ‘...future.elements_ii’ to environment
[13:21:52.654] - copied ‘...future.seeds_ii’ to environment
[13:21:52.655] - copied ‘...future.globals.maxSize’ to environment
[13:21:52.655] assign_globals() ... done
[13:21:52.655] plan(): Setting new future strategy stack:
[13:21:52.655] List of future strategies:
[13:21:52.655] 1. sequential:
[13:21:52.655]    - args: function (..., envir = parent.frame())
[13:21:52.655]    - tweaked: FALSE
[13:21:52.655]    - call: NULL
[13:21:52.655] plan(): nbrOfWorkers() = 1
[13:21:53.157] plan(): Setting new future strategy stack:
[13:21:53.157] List of future strategies:
[13:21:53.157] 1. multicore:
[13:21:53.157]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:53.157]    - tweaked: FALSE
[13:21:53.157]    - call: plan(strategy)
[13:21:53.162] plan(): nbrOfWorkers() = 1
[13:21:53.162] SequentialFuture started (and completed)
[13:21:53.162] - Launch lazy future ... done
[13:21:53.162] run() for ‘SequentialFuture’ ... done
[13:21:53.162] Created future:
[13:21:53.162] SequentialFuture:
[13:21:53.162] Label: ‘future_mapply-1’
[13:21:53.162] Expression:
[13:21:53.162] {
[13:21:53.162]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:53.162]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:53.162]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:53.162]         on.exit(options(oopts), add = TRUE)
[13:21:53.162]     }
[13:21:53.162]     {
[13:21:53.162]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:21:53.162]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:21:53.162]         do.call(mapply, args = args)
[13:21:53.162]     }
[13:21:53.162] }
[13:21:53.162] Lazy evaluation: FALSE
[13:21:53.162] Asynchronous evaluation: FALSE
[13:21:53.162] Local evaluation: TRUE
[13:21:53.162] Environment: R_GlobalEnv
[13:21:53.162] Capture standard output: FALSE
[13:21:53.162] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:53.162] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:53.162] Packages: <none>
[13:21:53.162] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:53.162] Resolved: TRUE
[13:21:53.162] Value: 224 bytes of class ‘list’
[13:21:53.162] Early signaling: FALSE
[13:21:53.162] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:21:53.162] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:53.163] Chunk #1 of 1 ... DONE
[13:21:53.163] Launching 1 futures (chunks) ... DONE
[13:21:53.163] Resolving 1 futures (chunks) ...
[13:21:53.164] resolve() on list ...
[13:21:53.164]  recursive: 0
[13:21:53.164]  length: 1
[13:21:53.164] 
[13:21:53.164] resolved() for ‘SequentialFuture’ ...
[13:21:53.164] - state: ‘finished’
[13:21:53.164] - run: TRUE
[13:21:53.164] - result: ‘FutureResult’
[13:21:53.165] resolved() for ‘SequentialFuture’ ... done
[13:21:53.165] Future #1
[13:21:53.165] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:53.165] - nx: 1
[13:21:53.165] - relay: TRUE
[13:21:53.165] - stdout: TRUE
[13:21:53.165] - signal: TRUE
[13:21:53.165] - resignal: FALSE
[13:21:53.165] - force: TRUE
[13:21:53.165] - relayed: [n=1] FALSE
[13:21:53.165] - queued futures: [n=1] FALSE
[13:21:53.166]  - until=1
[13:21:53.166]  - relaying element #1
[13:21:53.166] - relayed: [n=1] TRUE
[13:21:53.166] - queued futures: [n=1] TRUE
[13:21:53.166] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:53.166]  length: 0 (resolved future 1)
[13:21:53.166] Relaying remaining futures
[13:21:53.166] signalConditionsASAP(NULL, pos=0) ...
[13:21:53.166] - nx: 1
[13:21:53.166] - relay: TRUE
[13:21:53.166] - stdout: TRUE
[13:21:53.167] - signal: TRUE
[13:21:53.167] - resignal: FALSE
[13:21:53.167] - force: TRUE
[13:21:53.167] - relayed: [n=1] TRUE
[13:21:53.167] - queued futures: [n=1] TRUE
 - flush all
[13:21:53.167] - relayed: [n=1] TRUE
[13:21:53.167] - queued futures: [n=1] TRUE
[13:21:53.167] signalConditionsASAP(NULL, pos=0) ... done
[13:21:53.167] resolve() on list ... DONE
[13:21:53.167]  - Number of value chunks collected: 1
[13:21:53.168] Resolving 1 futures (chunks) ... DONE
[13:21:53.168] Reducing values from 1 chunks ...
[13:21:53.168]  - Number of values collected after concatenation: 2
[13:21:53.168]  - Number of values expected: 2
[13:21:53.168] Reducing values from 1 chunks ... DONE
[13:21:53.168] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[13:21:53.168] future_mapply() ...
[13:21:53.174] Number of chunks: 1
[13:21:53.174] getGlobalsAndPackagesXApply() ...
[13:21:53.175]  - future.globals: TRUE
[13:21:53.175] getGlobalsAndPackages() ...
[13:21:53.175] Searching for globals...
[13:21:53.177] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:21:53.177] Searching for globals ... DONE
[13:21:53.177] Resolving globals: FALSE
[13:21:53.178] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:21:53.178] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:21:53.178] - globals: [1] ‘FUN’
[13:21:53.178] 
[13:21:53.178] getGlobalsAndPackages() ... DONE
[13:21:53.179]  - globals found/used: [n=1] ‘FUN’
[13:21:53.179]  - needed namespaces: [n=0] 
[13:21:53.179] Finding globals ... DONE
[13:21:53.179] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:21:53.179] List of 2
[13:21:53.179]  $ ...future.FUN:function (x, y)  
[13:21:53.179]  $ MoreArgs     : NULL
[13:21:53.179]  - attr(*, "where")=List of 2
[13:21:53.179]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:53.179]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:21:53.179]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:53.179]  - attr(*, "resolved")= logi FALSE
[13:21:53.179]  - attr(*, "total_size")= num NA
[13:21:53.182] Packages to be attached in all futures: [n=0] 
[13:21:53.182] getGlobalsAndPackagesXApply() ... DONE
[13:21:53.182] Number of futures (= number of chunks): 1
[13:21:53.182] Launching 1 futures (chunks) ...
[13:21:53.183] Chunk #1 of 1 ...
[13:21:53.183]  - Finding globals in '...' for chunk #1 ...
[13:21:53.183] getGlobalsAndPackages() ...
[13:21:53.183] Searching for globals...
[13:21:53.183] 
[13:21:53.183] Searching for globals ... DONE
[13:21:53.183] - globals: [0] <none>
[13:21:53.184] getGlobalsAndPackages() ... DONE
[13:21:53.184]    + additional globals found: [n=0] 
[13:21:53.184]    + additional namespaces needed: [n=0] 
[13:21:53.184]  - Finding globals in '...' for chunk #1 ... DONE
[13:21:53.184]  - seeds: <none>
[13:21:53.184]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:53.184] getGlobalsAndPackages() ...
[13:21:53.184] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:53.184] Resolving globals: FALSE
[13:21:53.185] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[13:21:53.185] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:21:53.185] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:53.186] 
[13:21:53.186] getGlobalsAndPackages() ... DONE
[13:21:53.186] run() for ‘Future’ ...
[13:21:53.186] - state: ‘created’
[13:21:53.186] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:53.190] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:53.190] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:53.191]   - Field: ‘label’
[13:21:53.191]   - Field: ‘local’
[13:21:53.191]   - Field: ‘owner’
[13:21:53.191]   - Field: ‘envir’
[13:21:53.191]   - Field: ‘packages’
[13:21:53.191]   - Field: ‘gc’
[13:21:53.191]   - Field: ‘conditions’
[13:21:53.191]   - Field: ‘expr’
[13:21:53.192]   - Field: ‘uuid’
[13:21:53.192]   - Field: ‘seed’
[13:21:53.192]   - Field: ‘version’
[13:21:53.192]   - Field: ‘result’
[13:21:53.192]   - Field: ‘asynchronous’
[13:21:53.192]   - Field: ‘calls’
[13:21:53.192]   - Field: ‘globals’
[13:21:53.192]   - Field: ‘stdout’
[13:21:53.192]   - Field: ‘earlySignal’
[13:21:53.193]   - Field: ‘lazy’
[13:21:53.193]   - Field: ‘state’
[13:21:53.193] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:53.193] - Launch lazy future ...
[13:21:53.193] Packages needed by the future expression (n = 0): <none>
[13:21:53.193] Packages needed by future strategies (n = 0): <none>
[13:21:53.194] {
[13:21:53.194]     {
[13:21:53.194]         {
[13:21:53.194]             ...future.startTime <- base::Sys.time()
[13:21:53.194]             {
[13:21:53.194]                 {
[13:21:53.194]                   {
[13:21:53.194]                     base::local({
[13:21:53.194]                       has_future <- base::requireNamespace("future", 
[13:21:53.194]                         quietly = TRUE)
[13:21:53.194]                       if (has_future) {
[13:21:53.194]                         ns <- base::getNamespace("future")
[13:21:53.194]                         version <- ns[[".package"]][["version"]]
[13:21:53.194]                         if (is.null(version)) 
[13:21:53.194]                           version <- utils::packageVersion("future")
[13:21:53.194]                       }
[13:21:53.194]                       else {
[13:21:53.194]                         version <- NULL
[13:21:53.194]                       }
[13:21:53.194]                       if (!has_future || version < "1.8.0") {
[13:21:53.194]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:53.194]                           "", base::R.version$version.string), 
[13:21:53.194]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:53.194]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:53.194]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:53.194]                             "release", "version")], collapse = " "), 
[13:21:53.194]                           hostname = base::Sys.info()[["nodename"]])
[13:21:53.194]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:53.194]                           info)
[13:21:53.194]                         info <- base::paste(info, collapse = "; ")
[13:21:53.194]                         if (!has_future) {
[13:21:53.194]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:53.194]                             info)
[13:21:53.194]                         }
[13:21:53.194]                         else {
[13:21:53.194]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:53.194]                             info, version)
[13:21:53.194]                         }
[13:21:53.194]                         base::stop(msg)
[13:21:53.194]                       }
[13:21:53.194]                     })
[13:21:53.194]                   }
[13:21:53.194]                   options(future.plan = NULL)
[13:21:53.194]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:53.194]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:53.194]                 }
[13:21:53.194]                 ...future.workdir <- getwd()
[13:21:53.194]             }
[13:21:53.194]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:53.194]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:53.194]         }
[13:21:53.194]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:53.194]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:53.194]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:53.194]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:53.194]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:53.194]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:53.194]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:53.194]             base::names(...future.oldOptions))
[13:21:53.194]     }
[13:21:53.194]     if (FALSE) {
[13:21:53.194]     }
[13:21:53.194]     else {
[13:21:53.194]         if (TRUE) {
[13:21:53.194]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:53.194]                 open = "w")
[13:21:53.194]         }
[13:21:53.194]         else {
[13:21:53.194]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:53.194]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:53.194]         }
[13:21:53.194]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:53.194]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:53.194]             base::sink(type = "output", split = FALSE)
[13:21:53.194]             base::close(...future.stdout)
[13:21:53.194]         }, add = TRUE)
[13:21:53.194]     }
[13:21:53.194]     ...future.frame <- base::sys.nframe()
[13:21:53.194]     ...future.conditions <- base::list()
[13:21:53.194]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:53.194]     if (FALSE) {
[13:21:53.194]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:53.194]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:53.194]     }
[13:21:53.194]     ...future.result <- base::tryCatch({
[13:21:53.194]         base::withCallingHandlers({
[13:21:53.194]             ...future.value <- base::withVisible(base::local({
[13:21:53.194]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:53.194]                 if (!identical(...future.globals.maxSize.org, 
[13:21:53.194]                   ...future.globals.maxSize)) {
[13:21:53.194]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:53.194]                   on.exit(options(oopts), add = TRUE)
[13:21:53.194]                 }
[13:21:53.194]                 {
[13:21:53.194]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:21:53.194]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:21:53.194]                     USE.NAMES = FALSE)
[13:21:53.194]                   do.call(mapply, args = args)
[13:21:53.194]                 }
[13:21:53.194]             }))
[13:21:53.194]             future::FutureResult(value = ...future.value$value, 
[13:21:53.194]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:53.194]                   ...future.rng), globalenv = if (FALSE) 
[13:21:53.194]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:53.194]                     ...future.globalenv.names))
[13:21:53.194]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:53.194]         }, condition = base::local({
[13:21:53.194]             c <- base::c
[13:21:53.194]             inherits <- base::inherits
[13:21:53.194]             invokeRestart <- base::invokeRestart
[13:21:53.194]             length <- base::length
[13:21:53.194]             list <- base::list
[13:21:53.194]             seq.int <- base::seq.int
[13:21:53.194]             signalCondition <- base::signalCondition
[13:21:53.194]             sys.calls <- base::sys.calls
[13:21:53.194]             `[[` <- base::`[[`
[13:21:53.194]             `+` <- base::`+`
[13:21:53.194]             `<<-` <- base::`<<-`
[13:21:53.194]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:53.194]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:53.194]                   3L)]
[13:21:53.194]             }
[13:21:53.194]             function(cond) {
[13:21:53.194]                 is_error <- inherits(cond, "error")
[13:21:53.194]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:53.194]                   NULL)
[13:21:53.194]                 if (is_error) {
[13:21:53.194]                   sessionInformation <- function() {
[13:21:53.194]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:53.194]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:53.194]                       search = base::search(), system = base::Sys.info())
[13:21:53.194]                   }
[13:21:53.194]                   ...future.conditions[[length(...future.conditions) + 
[13:21:53.194]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:53.194]                     cond$call), session = sessionInformation(), 
[13:21:53.194]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:53.194]                   signalCondition(cond)
[13:21:53.194]                 }
[13:21:53.194]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:53.194]                 "immediateCondition"))) {
[13:21:53.194]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:53.194]                   ...future.conditions[[length(...future.conditions) + 
[13:21:53.194]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:53.194]                   if (TRUE && !signal) {
[13:21:53.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:53.194]                     {
[13:21:53.194]                       inherits <- base::inherits
[13:21:53.194]                       invokeRestart <- base::invokeRestart
[13:21:53.194]                       is.null <- base::is.null
[13:21:53.194]                       muffled <- FALSE
[13:21:53.194]                       if (inherits(cond, "message")) {
[13:21:53.194]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:53.194]                         if (muffled) 
[13:21:53.194]                           invokeRestart("muffleMessage")
[13:21:53.194]                       }
[13:21:53.194]                       else if (inherits(cond, "warning")) {
[13:21:53.194]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:53.194]                         if (muffled) 
[13:21:53.194]                           invokeRestart("muffleWarning")
[13:21:53.194]                       }
[13:21:53.194]                       else if (inherits(cond, "condition")) {
[13:21:53.194]                         if (!is.null(pattern)) {
[13:21:53.194]                           computeRestarts <- base::computeRestarts
[13:21:53.194]                           grepl <- base::grepl
[13:21:53.194]                           restarts <- computeRestarts(cond)
[13:21:53.194]                           for (restart in restarts) {
[13:21:53.194]                             name <- restart$name
[13:21:53.194]                             if (is.null(name)) 
[13:21:53.194]                               next
[13:21:53.194]                             if (!grepl(pattern, name)) 
[13:21:53.194]                               next
[13:21:53.194]                             invokeRestart(restart)
[13:21:53.194]                             muffled <- TRUE
[13:21:53.194]                             break
[13:21:53.194]                           }
[13:21:53.194]                         }
[13:21:53.194]                       }
[13:21:53.194]                       invisible(muffled)
[13:21:53.194]                     }
[13:21:53.194]                     muffleCondition(cond, pattern = "^muffle")
[13:21:53.194]                   }
[13:21:53.194]                 }
[13:21:53.194]                 else {
[13:21:53.194]                   if (TRUE) {
[13:21:53.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:53.194]                     {
[13:21:53.194]                       inherits <- base::inherits
[13:21:53.194]                       invokeRestart <- base::invokeRestart
[13:21:53.194]                       is.null <- base::is.null
[13:21:53.194]                       muffled <- FALSE
[13:21:53.194]                       if (inherits(cond, "message")) {
[13:21:53.194]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:53.194]                         if (muffled) 
[13:21:53.194]                           invokeRestart("muffleMessage")
[13:21:53.194]                       }
[13:21:53.194]                       else if (inherits(cond, "warning")) {
[13:21:53.194]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:53.194]                         if (muffled) 
[13:21:53.194]                           invokeRestart("muffleWarning")
[13:21:53.194]                       }
[13:21:53.194]                       else if (inherits(cond, "condition")) {
[13:21:53.194]                         if (!is.null(pattern)) {
[13:21:53.194]                           computeRestarts <- base::computeRestarts
[13:21:53.194]                           grepl <- base::grepl
[13:21:53.194]                           restarts <- computeRestarts(cond)
[13:21:53.194]                           for (restart in restarts) {
[13:21:53.194]                             name <- restart$name
[13:21:53.194]                             if (is.null(name)) 
[13:21:53.194]                               next
[13:21:53.194]                             if (!grepl(pattern, name)) 
[13:21:53.194]                               next
[13:21:53.194]                             invokeRestart(restart)
[13:21:53.194]                             muffled <- TRUE
[13:21:53.194]                             break
[13:21:53.194]                           }
[13:21:53.194]                         }
[13:21:53.194]                       }
[13:21:53.194]                       invisible(muffled)
[13:21:53.194]                     }
[13:21:53.194]                     muffleCondition(cond, pattern = "^muffle")
[13:21:53.194]                   }
[13:21:53.194]                 }
[13:21:53.194]             }
[13:21:53.194]         }))
[13:21:53.194]     }, error = function(ex) {
[13:21:53.194]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:53.194]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:53.194]                 ...future.rng), started = ...future.startTime, 
[13:21:53.194]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:53.194]             version = "1.8"), class = "FutureResult")
[13:21:53.194]     }, finally = {
[13:21:53.194]         if (!identical(...future.workdir, getwd())) 
[13:21:53.194]             setwd(...future.workdir)
[13:21:53.194]         {
[13:21:53.194]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:53.194]                 ...future.oldOptions$nwarnings <- NULL
[13:21:53.194]             }
[13:21:53.194]             base::options(...future.oldOptions)
[13:21:53.194]             if (.Platform$OS.type == "windows") {
[13:21:53.194]                 old_names <- names(...future.oldEnvVars)
[13:21:53.194]                 envs <- base::Sys.getenv()
[13:21:53.194]                 names <- names(envs)
[13:21:53.194]                 common <- intersect(names, old_names)
[13:21:53.194]                 added <- setdiff(names, old_names)
[13:21:53.194]                 removed <- setdiff(old_names, names)
[13:21:53.194]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:53.194]                   envs[common]]
[13:21:53.194]                 NAMES <- toupper(changed)
[13:21:53.194]                 args <- list()
[13:21:53.194]                 for (kk in seq_along(NAMES)) {
[13:21:53.194]                   name <- changed[[kk]]
[13:21:53.194]                   NAME <- NAMES[[kk]]
[13:21:53.194]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:53.194]                     next
[13:21:53.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:53.194]                 }
[13:21:53.194]                 NAMES <- toupper(added)
[13:21:53.194]                 for (kk in seq_along(NAMES)) {
[13:21:53.194]                   name <- added[[kk]]
[13:21:53.194]                   NAME <- NAMES[[kk]]
[13:21:53.194]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:53.194]                     next
[13:21:53.194]                   args[[name]] <- ""
[13:21:53.194]                 }
[13:21:53.194]                 NAMES <- toupper(removed)
[13:21:53.194]                 for (kk in seq_along(NAMES)) {
[13:21:53.194]                   name <- removed[[kk]]
[13:21:53.194]                   NAME <- NAMES[[kk]]
[13:21:53.194]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:53.194]                     next
[13:21:53.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:53.194]                 }
[13:21:53.194]                 if (length(args) > 0) 
[13:21:53.194]                   base::do.call(base::Sys.setenv, args = args)
[13:21:53.194]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:53.194]             }
[13:21:53.194]             else {
[13:21:53.194]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:53.194]             }
[13:21:53.194]             {
[13:21:53.194]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:53.194]                   0L) {
[13:21:53.194]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:53.194]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:53.194]                   base::options(opts)
[13:21:53.194]                 }
[13:21:53.194]                 {
[13:21:53.194]                   {
[13:21:53.194]                     NULL
[13:21:53.194]                     RNGkind("Mersenne-Twister")
[13:21:53.194]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:53.194]                       inherits = FALSE)
[13:21:53.194]                   }
[13:21:53.194]                   options(future.plan = NULL)
[13:21:53.194]                   if (is.na(NA_character_)) 
[13:21:53.194]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:53.194]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:53.194]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:53.194]                     envir = parent.frame()) 
[13:21:53.194]                   {
[13:21:53.194]                     default_workers <- missing(workers)
[13:21:53.194]                     if (is.function(workers)) 
[13:21:53.194]                       workers <- workers()
[13:21:53.194]                     workers <- structure(as.integer(workers), 
[13:21:53.194]                       class = class(workers))
[13:21:53.194]                     stop_if_not(is.finite(workers), workers >= 
[13:21:53.194]                       1L)
[13:21:53.194]                     if ((workers == 1L && !inherits(workers, 
[13:21:53.194]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:53.194]                       if (default_workers) 
[13:21:53.194]                         supportsMulticore(warn = TRUE)
[13:21:53.194]                       return(sequential(..., envir = envir))
[13:21:53.194]                     }
[13:21:53.194]                     oopts <- options(mc.cores = workers)
[13:21:53.194]                     on.exit(options(oopts))
[13:21:53.194]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:53.194]                       envir = envir)
[13:21:53.194]                     if (!future$lazy) 
[13:21:53.194]                       future <- run(future)
[13:21:53.194]                     invisible(future)
[13:21:53.194]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:53.194]                 }
[13:21:53.194]             }
[13:21:53.194]         }
[13:21:53.194]     })
[13:21:53.194]     if (TRUE) {
[13:21:53.194]         base::sink(type = "output", split = FALSE)
[13:21:53.194]         if (TRUE) {
[13:21:53.194]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:53.194]         }
[13:21:53.194]         else {
[13:21:53.194]             ...future.result["stdout"] <- base::list(NULL)
[13:21:53.194]         }
[13:21:53.194]         base::close(...future.stdout)
[13:21:53.194]         ...future.stdout <- NULL
[13:21:53.194]     }
[13:21:53.194]     ...future.result$conditions <- ...future.conditions
[13:21:53.194]     ...future.result$finished <- base::Sys.time()
[13:21:53.194]     ...future.result
[13:21:53.194] }
[13:21:53.195] assign_globals() ...
[13:21:53.196] List of 5
[13:21:53.196]  $ ...future.FUN            :function (x, y)  
[13:21:53.196]  $ MoreArgs                 : NULL
[13:21:53.196]  $ ...future.elements_ii    :List of 2
[13:21:53.196]   ..$ :List of 2
[13:21:53.196]   .. ..$ : int 1
[13:21:53.196]   .. ..$ : int 0
[13:21:53.196]   ..$ :List of 2
[13:21:53.196]   .. ..$ : int 0
[13:21:53.196]   .. ..$ : int 1
[13:21:53.196]  $ ...future.seeds_ii       : NULL
[13:21:53.196]  $ ...future.globals.maxSize: NULL
[13:21:53.196]  - attr(*, "where")=List of 5
[13:21:53.196]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:53.196]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:21:53.196]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:53.196]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:53.196]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:53.196]  - attr(*, "resolved")= logi FALSE
[13:21:53.196]  - attr(*, "total_size")= num 6480
[13:21:53.196]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:53.196]  - attr(*, "already-done")= logi TRUE
[13:21:53.203] - reassign environment for ‘...future.FUN’
[13:21:53.203] - copied ‘...future.FUN’ to environment
[13:21:53.204] - copied ‘MoreArgs’ to environment
[13:21:53.204] - copied ‘...future.elements_ii’ to environment
[13:21:53.204] - copied ‘...future.seeds_ii’ to environment
[13:21:53.204] - copied ‘...future.globals.maxSize’ to environment
[13:21:53.204] assign_globals() ... done
[13:21:53.204] plan(): Setting new future strategy stack:
[13:21:53.204] List of future strategies:
[13:21:53.204] 1. sequential:
[13:21:53.204]    - args: function (..., envir = parent.frame())
[13:21:53.204]    - tweaked: FALSE
[13:21:53.204]    - call: NULL
[13:21:53.205] plan(): nbrOfWorkers() = 1
[13:21:53.706] plan(): Setting new future strategy stack:
[13:21:53.707] List of future strategies:
[13:21:53.707] 1. multicore:
[13:21:53.707]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:53.707]    - tweaked: FALSE
[13:21:53.707]    - call: plan(strategy)
[13:21:53.710] plan(): nbrOfWorkers() = 1
[13:21:53.711] SequentialFuture started (and completed)
[13:21:53.711] - Launch lazy future ... done
[13:21:53.711] run() for ‘SequentialFuture’ ... done
[13:21:53.711] Created future:
[13:21:53.711] SequentialFuture:
[13:21:53.711] Label: ‘future_mapply-1’
[13:21:53.711] Expression:
[13:21:53.711] {
[13:21:53.711]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:53.711]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:53.711]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:53.711]         on.exit(options(oopts), add = TRUE)
[13:21:53.711]     }
[13:21:53.711]     {
[13:21:53.711]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:21:53.711]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:21:53.711]         do.call(mapply, args = args)
[13:21:53.711]     }
[13:21:53.711] }
[13:21:53.711] Lazy evaluation: FALSE
[13:21:53.711] Asynchronous evaluation: FALSE
[13:21:53.711] Local evaluation: TRUE
[13:21:53.711] Environment: R_GlobalEnv
[13:21:53.711] Capture standard output: TRUE
[13:21:53.711] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:53.711] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:53.711] Packages: <none>
[13:21:53.711] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:53.711] Resolved: TRUE
[13:21:53.711] Value: 224 bytes of class ‘list’
[13:21:53.711] Early signaling: FALSE
[13:21:53.711] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:21:53.711] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:53.712] Chunk #1 of 1 ... DONE
[13:21:53.712] Launching 1 futures (chunks) ... DONE
[13:21:53.712] Resolving 1 futures (chunks) ...
[13:21:53.713] resolve() on list ...
[13:21:53.713]  recursive: 0
[13:21:53.713]  length: 1
[13:21:53.713] 
[13:21:53.713] resolved() for ‘SequentialFuture’ ...
[13:21:53.713] - state: ‘finished’
[13:21:53.713] - run: TRUE
[13:21:53.713] - result: ‘FutureResult’
[13:21:53.713] resolved() for ‘SequentialFuture’ ... done
[13:21:53.713] Future #1
[13:21:53.714] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:53.714] - nx: 1
[13:21:53.714] - relay: TRUE
[13:21:53.714] - stdout: TRUE
[13:21:53.714] - signal: TRUE
[13:21:53.714] - resignal: FALSE
[13:21:53.714] - force: TRUE
[13:21:53.714] - relayed: [n=1] FALSE
[13:21:53.714] - queued futures: [n=1] FALSE
[13:21:53.714]  - until=1
[13:21:53.714]  - relaying element #1
[13:21:53.715] - relayed: [n=1] TRUE
[13:21:53.715] - queued futures: [n=1] TRUE
[13:21:53.715] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:53.715]  length: 0 (resolved future 1)
[13:21:53.715] Relaying remaining futures
[13:21:53.715] signalConditionsASAP(NULL, pos=0) ...
[13:21:53.715] - nx: 1
[13:21:53.715] - relay: TRUE
[13:21:53.715] - stdout: TRUE
[13:21:53.715] - signal: TRUE
[13:21:53.716] - resignal: FALSE
[13:21:53.716] - force: TRUE
[13:21:53.716] - relayed: [n=1] TRUE
[13:21:53.716] - queued futures: [n=1] TRUE
 - flush all
[13:21:53.716] - relayed: [n=1] TRUE
[13:21:53.716] - queued futures: [n=1] TRUE
[13:21:53.716] signalConditionsASAP(NULL, pos=0) ... done
[13:21:53.716] resolve() on list ... DONE
[13:21:53.716]  - Number of value chunks collected: 1
[13:21:53.716] Resolving 1 futures (chunks) ... DONE
[13:21:53.717] Reducing values from 1 chunks ...
[13:21:53.717]  - Number of values collected after concatenation: 2
[13:21:53.717]  - Number of values expected: 2
[13:21:53.717] Reducing values from 1 chunks ... DONE
[13:21:53.717] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[13:21:53.717] future_mapply() ...
[13:21:53.721] Number of chunks: 1
[13:21:53.721] getGlobalsAndPackagesXApply() ...
[13:21:53.721]  - future.globals: TRUE
[13:21:53.721] getGlobalsAndPackages() ...
[13:21:53.721] Searching for globals...
[13:21:53.723] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:21:53.723] Searching for globals ... DONE
[13:21:53.723] Resolving globals: FALSE
[13:21:53.724] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:21:53.724] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:21:53.724] - globals: [1] ‘FUN’
[13:21:53.724] 
[13:21:53.724] getGlobalsAndPackages() ... DONE
[13:21:53.724]  - globals found/used: [n=1] ‘FUN’
[13:21:53.725]  - needed namespaces: [n=0] 
[13:21:53.725] Finding globals ... DONE
[13:21:53.725] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:21:53.725] List of 2
[13:21:53.725]  $ ...future.FUN:function (x, y)  
[13:21:53.725]  $ MoreArgs     : NULL
[13:21:53.725]  - attr(*, "where")=List of 2
[13:21:53.725]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:53.725]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:21:53.725]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:53.725]  - attr(*, "resolved")= logi FALSE
[13:21:53.725]  - attr(*, "total_size")= num NA
[13:21:53.727] Packages to be attached in all futures: [n=0] 
[13:21:53.728] getGlobalsAndPackagesXApply() ... DONE
[13:21:53.728] Number of futures (= number of chunks): 1
[13:21:53.728] Launching 1 futures (chunks) ...
[13:21:53.728] Chunk #1 of 1 ...
[13:21:53.728]  - Finding globals in '...' for chunk #1 ...
[13:21:53.728] getGlobalsAndPackages() ...
[13:21:53.728] Searching for globals...
[13:21:53.729] 
[13:21:53.729] Searching for globals ... DONE
[13:21:53.729] - globals: [0] <none>
[13:21:53.729] getGlobalsAndPackages() ... DONE
[13:21:53.729]    + additional globals found: [n=0] 
[13:21:53.729]    + additional namespaces needed: [n=0] 
[13:21:53.729]  - Finding globals in '...' for chunk #1 ... DONE
[13:21:53.729]  - seeds: <none>
[13:21:53.729]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:53.729] getGlobalsAndPackages() ...
[13:21:53.730] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:53.730] Resolving globals: FALSE
[13:21:53.730] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[13:21:53.731] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:21:53.731] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:53.731] 
[13:21:53.731] getGlobalsAndPackages() ... DONE
[13:21:53.733] run() for ‘Future’ ...
[13:21:53.733] - state: ‘created’
[13:21:53.733] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:53.737] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:53.738] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:53.738]   - Field: ‘label’
[13:21:53.738]   - Field: ‘local’
[13:21:53.738]   - Field: ‘owner’
[13:21:53.738]   - Field: ‘envir’
[13:21:53.738]   - Field: ‘packages’
[13:21:53.738]   - Field: ‘gc’
[13:21:53.739]   - Field: ‘conditions’
[13:21:53.739]   - Field: ‘expr’
[13:21:53.739]   - Field: ‘uuid’
[13:21:53.739]   - Field: ‘seed’
[13:21:53.739]   - Field: ‘version’
[13:21:53.739]   - Field: ‘result’
[13:21:53.739]   - Field: ‘asynchronous’
[13:21:53.739]   - Field: ‘calls’
[13:21:53.739]   - Field: ‘globals’
[13:21:53.739]   - Field: ‘stdout’
[13:21:53.740]   - Field: ‘earlySignal’
[13:21:53.740]   - Field: ‘lazy’
[13:21:53.740]   - Field: ‘state’
[13:21:53.740] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:53.740] - Launch lazy future ...
[13:21:53.740] Packages needed by the future expression (n = 0): <none>
[13:21:53.740] Packages needed by future strategies (n = 0): <none>
[13:21:53.741] {
[13:21:53.741]     {
[13:21:53.741]         {
[13:21:53.741]             ...future.startTime <- base::Sys.time()
[13:21:53.741]             {
[13:21:53.741]                 {
[13:21:53.741]                   {
[13:21:53.741]                     base::local({
[13:21:53.741]                       has_future <- base::requireNamespace("future", 
[13:21:53.741]                         quietly = TRUE)
[13:21:53.741]                       if (has_future) {
[13:21:53.741]                         ns <- base::getNamespace("future")
[13:21:53.741]                         version <- ns[[".package"]][["version"]]
[13:21:53.741]                         if (is.null(version)) 
[13:21:53.741]                           version <- utils::packageVersion("future")
[13:21:53.741]                       }
[13:21:53.741]                       else {
[13:21:53.741]                         version <- NULL
[13:21:53.741]                       }
[13:21:53.741]                       if (!has_future || version < "1.8.0") {
[13:21:53.741]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:53.741]                           "", base::R.version$version.string), 
[13:21:53.741]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:53.741]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:53.741]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:53.741]                             "release", "version")], collapse = " "), 
[13:21:53.741]                           hostname = base::Sys.info()[["nodename"]])
[13:21:53.741]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:53.741]                           info)
[13:21:53.741]                         info <- base::paste(info, collapse = "; ")
[13:21:53.741]                         if (!has_future) {
[13:21:53.741]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:53.741]                             info)
[13:21:53.741]                         }
[13:21:53.741]                         else {
[13:21:53.741]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:53.741]                             info, version)
[13:21:53.741]                         }
[13:21:53.741]                         base::stop(msg)
[13:21:53.741]                       }
[13:21:53.741]                     })
[13:21:53.741]                   }
[13:21:53.741]                   options(future.plan = NULL)
[13:21:53.741]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:53.741]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:53.741]                 }
[13:21:53.741]                 ...future.workdir <- getwd()
[13:21:53.741]             }
[13:21:53.741]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:53.741]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:53.741]         }
[13:21:53.741]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:53.741]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:53.741]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:53.741]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:53.741]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:53.741]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:53.741]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:53.741]             base::names(...future.oldOptions))
[13:21:53.741]     }
[13:21:53.741]     if (TRUE) {
[13:21:53.741]     }
[13:21:53.741]     else {
[13:21:53.741]         if (NA) {
[13:21:53.741]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:53.741]                 open = "w")
[13:21:53.741]         }
[13:21:53.741]         else {
[13:21:53.741]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:53.741]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:53.741]         }
[13:21:53.741]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:53.741]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:53.741]             base::sink(type = "output", split = FALSE)
[13:21:53.741]             base::close(...future.stdout)
[13:21:53.741]         }, add = TRUE)
[13:21:53.741]     }
[13:21:53.741]     ...future.frame <- base::sys.nframe()
[13:21:53.741]     ...future.conditions <- base::list()
[13:21:53.741]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:53.741]     if (FALSE) {
[13:21:53.741]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:53.741]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:53.741]     }
[13:21:53.741]     ...future.result <- base::tryCatch({
[13:21:53.741]         base::withCallingHandlers({
[13:21:53.741]             ...future.value <- base::withVisible(base::local({
[13:21:53.741]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:53.741]                 if (!identical(...future.globals.maxSize.org, 
[13:21:53.741]                   ...future.globals.maxSize)) {
[13:21:53.741]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:53.741]                   on.exit(options(oopts), add = TRUE)
[13:21:53.741]                 }
[13:21:53.741]                 {
[13:21:53.741]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:21:53.741]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:21:53.741]                     USE.NAMES = FALSE)
[13:21:53.741]                   do.call(mapply, args = args)
[13:21:53.741]                 }
[13:21:53.741]             }))
[13:21:53.741]             future::FutureResult(value = ...future.value$value, 
[13:21:53.741]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:53.741]                   ...future.rng), globalenv = if (FALSE) 
[13:21:53.741]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:53.741]                     ...future.globalenv.names))
[13:21:53.741]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:53.741]         }, condition = base::local({
[13:21:53.741]             c <- base::c
[13:21:53.741]             inherits <- base::inherits
[13:21:53.741]             invokeRestart <- base::invokeRestart
[13:21:53.741]             length <- base::length
[13:21:53.741]             list <- base::list
[13:21:53.741]             seq.int <- base::seq.int
[13:21:53.741]             signalCondition <- base::signalCondition
[13:21:53.741]             sys.calls <- base::sys.calls
[13:21:53.741]             `[[` <- base::`[[`
[13:21:53.741]             `+` <- base::`+`
[13:21:53.741]             `<<-` <- base::`<<-`
[13:21:53.741]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:53.741]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:53.741]                   3L)]
[13:21:53.741]             }
[13:21:53.741]             function(cond) {
[13:21:53.741]                 is_error <- inherits(cond, "error")
[13:21:53.741]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:53.741]                   NULL)
[13:21:53.741]                 if (is_error) {
[13:21:53.741]                   sessionInformation <- function() {
[13:21:53.741]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:53.741]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:53.741]                       search = base::search(), system = base::Sys.info())
[13:21:53.741]                   }
[13:21:53.741]                   ...future.conditions[[length(...future.conditions) + 
[13:21:53.741]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:53.741]                     cond$call), session = sessionInformation(), 
[13:21:53.741]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:53.741]                   signalCondition(cond)
[13:21:53.741]                 }
[13:21:53.741]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:53.741]                 "immediateCondition"))) {
[13:21:53.741]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:53.741]                   ...future.conditions[[length(...future.conditions) + 
[13:21:53.741]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:53.741]                   if (TRUE && !signal) {
[13:21:53.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:53.741]                     {
[13:21:53.741]                       inherits <- base::inherits
[13:21:53.741]                       invokeRestart <- base::invokeRestart
[13:21:53.741]                       is.null <- base::is.null
[13:21:53.741]                       muffled <- FALSE
[13:21:53.741]                       if (inherits(cond, "message")) {
[13:21:53.741]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:53.741]                         if (muffled) 
[13:21:53.741]                           invokeRestart("muffleMessage")
[13:21:53.741]                       }
[13:21:53.741]                       else if (inherits(cond, "warning")) {
[13:21:53.741]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:53.741]                         if (muffled) 
[13:21:53.741]                           invokeRestart("muffleWarning")
[13:21:53.741]                       }
[13:21:53.741]                       else if (inherits(cond, "condition")) {
[13:21:53.741]                         if (!is.null(pattern)) {
[13:21:53.741]                           computeRestarts <- base::computeRestarts
[13:21:53.741]                           grepl <- base::grepl
[13:21:53.741]                           restarts <- computeRestarts(cond)
[13:21:53.741]                           for (restart in restarts) {
[13:21:53.741]                             name <- restart$name
[13:21:53.741]                             if (is.null(name)) 
[13:21:53.741]                               next
[13:21:53.741]                             if (!grepl(pattern, name)) 
[13:21:53.741]                               next
[13:21:53.741]                             invokeRestart(restart)
[13:21:53.741]                             muffled <- TRUE
[13:21:53.741]                             break
[13:21:53.741]                           }
[13:21:53.741]                         }
[13:21:53.741]                       }
[13:21:53.741]                       invisible(muffled)
[13:21:53.741]                     }
[13:21:53.741]                     muffleCondition(cond, pattern = "^muffle")
[13:21:53.741]                   }
[13:21:53.741]                 }
[13:21:53.741]                 else {
[13:21:53.741]                   if (TRUE) {
[13:21:53.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:53.741]                     {
[13:21:53.741]                       inherits <- base::inherits
[13:21:53.741]                       invokeRestart <- base::invokeRestart
[13:21:53.741]                       is.null <- base::is.null
[13:21:53.741]                       muffled <- FALSE
[13:21:53.741]                       if (inherits(cond, "message")) {
[13:21:53.741]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:53.741]                         if (muffled) 
[13:21:53.741]                           invokeRestart("muffleMessage")
[13:21:53.741]                       }
[13:21:53.741]                       else if (inherits(cond, "warning")) {
[13:21:53.741]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:53.741]                         if (muffled) 
[13:21:53.741]                           invokeRestart("muffleWarning")
[13:21:53.741]                       }
[13:21:53.741]                       else if (inherits(cond, "condition")) {
[13:21:53.741]                         if (!is.null(pattern)) {
[13:21:53.741]                           computeRestarts <- base::computeRestarts
[13:21:53.741]                           grepl <- base::grepl
[13:21:53.741]                           restarts <- computeRestarts(cond)
[13:21:53.741]                           for (restart in restarts) {
[13:21:53.741]                             name <- restart$name
[13:21:53.741]                             if (is.null(name)) 
[13:21:53.741]                               next
[13:21:53.741]                             if (!grepl(pattern, name)) 
[13:21:53.741]                               next
[13:21:53.741]                             invokeRestart(restart)
[13:21:53.741]                             muffled <- TRUE
[13:21:53.741]                             break
[13:21:53.741]                           }
[13:21:53.741]                         }
[13:21:53.741]                       }
[13:21:53.741]                       invisible(muffled)
[13:21:53.741]                     }
[13:21:53.741]                     muffleCondition(cond, pattern = "^muffle")
[13:21:53.741]                   }
[13:21:53.741]                 }
[13:21:53.741]             }
[13:21:53.741]         }))
[13:21:53.741]     }, error = function(ex) {
[13:21:53.741]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:53.741]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:53.741]                 ...future.rng), started = ...future.startTime, 
[13:21:53.741]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:53.741]             version = "1.8"), class = "FutureResult")
[13:21:53.741]     }, finally = {
[13:21:53.741]         if (!identical(...future.workdir, getwd())) 
[13:21:53.741]             setwd(...future.workdir)
[13:21:53.741]         {
[13:21:53.741]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:53.741]                 ...future.oldOptions$nwarnings <- NULL
[13:21:53.741]             }
[13:21:53.741]             base::options(...future.oldOptions)
[13:21:53.741]             if (.Platform$OS.type == "windows") {
[13:21:53.741]                 old_names <- names(...future.oldEnvVars)
[13:21:53.741]                 envs <- base::Sys.getenv()
[13:21:53.741]                 names <- names(envs)
[13:21:53.741]                 common <- intersect(names, old_names)
[13:21:53.741]                 added <- setdiff(names, old_names)
[13:21:53.741]                 removed <- setdiff(old_names, names)
[13:21:53.741]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:53.741]                   envs[common]]
[13:21:53.741]                 NAMES <- toupper(changed)
[13:21:53.741]                 args <- list()
[13:21:53.741]                 for (kk in seq_along(NAMES)) {
[13:21:53.741]                   name <- changed[[kk]]
[13:21:53.741]                   NAME <- NAMES[[kk]]
[13:21:53.741]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:53.741]                     next
[13:21:53.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:53.741]                 }
[13:21:53.741]                 NAMES <- toupper(added)
[13:21:53.741]                 for (kk in seq_along(NAMES)) {
[13:21:53.741]                   name <- added[[kk]]
[13:21:53.741]                   NAME <- NAMES[[kk]]
[13:21:53.741]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:53.741]                     next
[13:21:53.741]                   args[[name]] <- ""
[13:21:53.741]                 }
[13:21:53.741]                 NAMES <- toupper(removed)
[13:21:53.741]                 for (kk in seq_along(NAMES)) {
[13:21:53.741]                   name <- removed[[kk]]
[13:21:53.741]                   NAME <- NAMES[[kk]]
[13:21:53.741]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:53.741]                     next
[13:21:53.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:53.741]                 }
[13:21:53.741]                 if (length(args) > 0) 
[13:21:53.741]                   base::do.call(base::Sys.setenv, args = args)
[13:21:53.741]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:53.741]             }
[13:21:53.741]             else {
[13:21:53.741]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:53.741]             }
[13:21:53.741]             {
[13:21:53.741]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:53.741]                   0L) {
[13:21:53.741]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:53.741]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:53.741]                   base::options(opts)
[13:21:53.741]                 }
[13:21:53.741]                 {
[13:21:53.741]                   {
[13:21:53.741]                     NULL
[13:21:53.741]                     RNGkind("Mersenne-Twister")
[13:21:53.741]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:53.741]                       inherits = FALSE)
[13:21:53.741]                   }
[13:21:53.741]                   options(future.plan = NULL)
[13:21:53.741]                   if (is.na(NA_character_)) 
[13:21:53.741]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:53.741]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:53.741]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:53.741]                     envir = parent.frame()) 
[13:21:53.741]                   {
[13:21:53.741]                     default_workers <- missing(workers)
[13:21:53.741]                     if (is.function(workers)) 
[13:21:53.741]                       workers <- workers()
[13:21:53.741]                     workers <- structure(as.integer(workers), 
[13:21:53.741]                       class = class(workers))
[13:21:53.741]                     stop_if_not(is.finite(workers), workers >= 
[13:21:53.741]                       1L)
[13:21:53.741]                     if ((workers == 1L && !inherits(workers, 
[13:21:53.741]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:53.741]                       if (default_workers) 
[13:21:53.741]                         supportsMulticore(warn = TRUE)
[13:21:53.741]                       return(sequential(..., envir = envir))
[13:21:53.741]                     }
[13:21:53.741]                     oopts <- options(mc.cores = workers)
[13:21:53.741]                     on.exit(options(oopts))
[13:21:53.741]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:53.741]                       envir = envir)
[13:21:53.741]                     if (!future$lazy) 
[13:21:53.741]                       future <- run(future)
[13:21:53.741]                     invisible(future)
[13:21:53.741]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:53.741]                 }
[13:21:53.741]             }
[13:21:53.741]         }
[13:21:53.741]     })
[13:21:53.741]     if (FALSE) {
[13:21:53.741]         base::sink(type = "output", split = FALSE)
[13:21:53.741]         if (NA) {
[13:21:53.741]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:53.741]         }
[13:21:53.741]         else {
[13:21:53.741]             ...future.result["stdout"] <- base::list(NULL)
[13:21:53.741]         }
[13:21:53.741]         base::close(...future.stdout)
[13:21:53.741]         ...future.stdout <- NULL
[13:21:53.741]     }
[13:21:53.741]     ...future.result$conditions <- ...future.conditions
[13:21:53.741]     ...future.result$finished <- base::Sys.time()
[13:21:53.741]     ...future.result
[13:21:53.741] }
[13:21:53.743] assign_globals() ...
[13:21:53.743] List of 5
[13:21:53.743]  $ ...future.FUN            :function (x, y)  
[13:21:53.743]  $ MoreArgs                 : NULL
[13:21:53.743]  $ ...future.elements_ii    :List of 2
[13:21:53.743]   ..$ :List of 2
[13:21:53.743]   .. ..$ : int 1
[13:21:53.743]   .. ..$ : int 0
[13:21:53.743]   ..$ :List of 2
[13:21:53.743]   .. ..$ : int 0
[13:21:53.743]   .. ..$ : int 1
[13:21:53.743]  $ ...future.seeds_ii       : NULL
[13:21:53.743]  $ ...future.globals.maxSize: NULL
[13:21:53.743]  - attr(*, "where")=List of 5
[13:21:53.743]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:53.743]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:21:53.743]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:53.743]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:53.743]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:53.743]  - attr(*, "resolved")= logi FALSE
[13:21:53.743]  - attr(*, "total_size")= num 6480
[13:21:53.743]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:53.743]  - attr(*, "already-done")= logi TRUE
[13:21:53.749] - reassign environment for ‘...future.FUN’
[13:21:53.749] - copied ‘...future.FUN’ to environment
[13:21:53.749] - copied ‘MoreArgs’ to environment
[13:21:53.749] - copied ‘...future.elements_ii’ to environment
[13:21:53.749] - copied ‘...future.seeds_ii’ to environment
[13:21:53.749] - copied ‘...future.globals.maxSize’ to environment
[13:21:53.749] assign_globals() ... done
[13:21:53.750] plan(): Setting new future strategy stack:
[13:21:53.750] List of future strategies:
[13:21:53.750] 1. sequential:
[13:21:53.750]    - args: function (..., envir = parent.frame())
[13:21:53.750]    - tweaked: FALSE
[13:21:53.750]    - call: NULL
[13:21:53.750] plan(): nbrOfWorkers() = 1
[13:21:54.252] plan(): Setting new future strategy stack:
[13:21:54.252] List of future strategies:
[13:21:54.252] 1. multicore:
[13:21:54.252]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:54.252]    - tweaked: FALSE
[13:21:54.252]    - call: plan(strategy)
[13:21:54.256] plan(): nbrOfWorkers() = 1
[13:21:54.256] SequentialFuture started (and completed)
[13:21:54.256] - Launch lazy future ... done
[13:21:54.256] run() for ‘SequentialFuture’ ... done
[13:21:54.256] Created future:
[13:21:54.256] SequentialFuture:
[13:21:54.256] Label: ‘future_mapply-1’
[13:21:54.256] Expression:
[13:21:54.256] {
[13:21:54.256]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:54.256]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:54.256]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:54.256]         on.exit(options(oopts), add = TRUE)
[13:21:54.256]     }
[13:21:54.256]     {
[13:21:54.256]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:21:54.256]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:21:54.256]         do.call(mapply, args = args)
[13:21:54.256]     }
[13:21:54.256] }
[13:21:54.256] Lazy evaluation: FALSE
[13:21:54.256] Asynchronous evaluation: FALSE
[13:21:54.256] Local evaluation: TRUE
[13:21:54.256] Environment: R_GlobalEnv
[13:21:54.256] Capture standard output: NA
[13:21:54.256] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:54.256] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:54.256] Packages: <none>
[13:21:54.256] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:54.256] Resolved: TRUE
[13:21:54.256] Value: 224 bytes of class ‘list’
[13:21:54.256] Early signaling: FALSE
[13:21:54.256] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:21:54.256] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:54.257] Chunk #1 of 1 ... DONE
[13:21:54.258] Launching 1 futures (chunks) ... DONE
[13:21:54.258] Resolving 1 futures (chunks) ...
[13:21:54.258] resolve() on list ...
[13:21:54.258]  recursive: 0
[13:21:54.258]  length: 1
[13:21:54.258] 
[13:21:54.258] resolved() for ‘SequentialFuture’ ...
[13:21:54.258] - state: ‘finished’
[13:21:54.258] - run: TRUE
[13:21:54.258] - result: ‘FutureResult’
[13:21:54.259] resolved() for ‘SequentialFuture’ ... done
[13:21:54.259] Future #1
[13:21:54.259] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:54.259] - nx: 1
[13:21:54.259] - relay: TRUE
[13:21:54.259] - stdout: TRUE
[13:21:54.259] - signal: TRUE
[13:21:54.259] - resignal: FALSE
[13:21:54.259] - force: TRUE
[13:21:54.259] - relayed: [n=1] FALSE
[13:21:54.259] - queued futures: [n=1] FALSE
[13:21:54.260]  - until=1
[13:21:54.260]  - relaying element #1
[13:21:54.260] - relayed: [n=1] TRUE
[13:21:54.260] - queued futures: [n=1] TRUE
[13:21:54.260] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:54.260]  length: 0 (resolved future 1)
[13:21:54.260] Relaying remaining futures
[13:21:54.260] signalConditionsASAP(NULL, pos=0) ...
[13:21:54.260] - nx: 1
[13:21:54.260] - relay: TRUE
[13:21:54.261] - stdout: TRUE
[13:21:54.261] - signal: TRUE
[13:21:54.261] - resignal: FALSE
[13:21:54.261] - force: TRUE
[13:21:54.261] - relayed: [n=1] TRUE
[13:21:54.261] - queued futures: [n=1] TRUE
 - flush all
[13:21:54.261] - relayed: [n=1] TRUE
[13:21:54.261] - queued futures: [n=1] TRUE
[13:21:54.261] signalConditionsASAP(NULL, pos=0) ... done
[13:21:54.261] resolve() on list ... DONE
[13:21:54.262]  - Number of value chunks collected: 1
[13:21:54.262] Resolving 1 futures (chunks) ... DONE
[13:21:54.262] Reducing values from 1 chunks ...
[13:21:54.262]  - Number of values collected after concatenation: 2
[13:21:54.262]  - Number of values expected: 2
[13:21:54.262] Reducing values from 1 chunks ... DONE
[13:21:54.262] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[13:21:54.263] plan(): Setting new future strategy stack:
[13:21:54.263] List of future strategies:
[13:21:54.263] 1. multisession:
[13:21:54.263]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:21:54.263]    - tweaked: FALSE
[13:21:54.263]    - call: plan(strategy)
[13:21:54.290] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:21:54.291] multisession:
[13:21:54.291] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:21:54.291] - tweaked: FALSE
[13:21:54.291] - call: plan(strategy)
[13:21:54.295] getGlobalsAndPackages() ...
[13:21:54.295] Not searching for globals
[13:21:54.295] - globals: [0] <none>
[13:21:54.296] getGlobalsAndPackages() ... DONE
[13:21:54.296] Packages needed by the future expression (n = 0): <none>
[13:21:54.296] Packages needed by future strategies (n = 0): <none>
[13:21:54.297] {
[13:21:54.297]     {
[13:21:54.297]         {
[13:21:54.297]             ...future.startTime <- base::Sys.time()
[13:21:54.297]             {
[13:21:54.297]                 {
[13:21:54.297]                   {
[13:21:54.297]                     base::local({
[13:21:54.297]                       has_future <- base::requireNamespace("future", 
[13:21:54.297]                         quietly = TRUE)
[13:21:54.297]                       if (has_future) {
[13:21:54.297]                         ns <- base::getNamespace("future")
[13:21:54.297]                         version <- ns[[".package"]][["version"]]
[13:21:54.297]                         if (is.null(version)) 
[13:21:54.297]                           version <- utils::packageVersion("future")
[13:21:54.297]                       }
[13:21:54.297]                       else {
[13:21:54.297]                         version <- NULL
[13:21:54.297]                       }
[13:21:54.297]                       if (!has_future || version < "1.8.0") {
[13:21:54.297]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:54.297]                           "", base::R.version$version.string), 
[13:21:54.297]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:54.297]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:54.297]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:54.297]                             "release", "version")], collapse = " "), 
[13:21:54.297]                           hostname = base::Sys.info()[["nodename"]])
[13:21:54.297]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:54.297]                           info)
[13:21:54.297]                         info <- base::paste(info, collapse = "; ")
[13:21:54.297]                         if (!has_future) {
[13:21:54.297]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:54.297]                             info)
[13:21:54.297]                         }
[13:21:54.297]                         else {
[13:21:54.297]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:54.297]                             info, version)
[13:21:54.297]                         }
[13:21:54.297]                         base::stop(msg)
[13:21:54.297]                       }
[13:21:54.297]                     })
[13:21:54.297]                   }
[13:21:54.297]                   options(future.plan = NULL)
[13:21:54.297]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:54.297]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:54.297]                 }
[13:21:54.297]                 ...future.workdir <- getwd()
[13:21:54.297]             }
[13:21:54.297]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:54.297]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:54.297]         }
[13:21:54.297]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:54.297]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:54.297]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:54.297]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:54.297]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:54.297]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:54.297]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:54.297]             base::names(...future.oldOptions))
[13:21:54.297]     }
[13:21:54.297]     if (FALSE) {
[13:21:54.297]     }
[13:21:54.297]     else {
[13:21:54.297]         if (TRUE) {
[13:21:54.297]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:54.297]                 open = "w")
[13:21:54.297]         }
[13:21:54.297]         else {
[13:21:54.297]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:54.297]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:54.297]         }
[13:21:54.297]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:54.297]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:54.297]             base::sink(type = "output", split = FALSE)
[13:21:54.297]             base::close(...future.stdout)
[13:21:54.297]         }, add = TRUE)
[13:21:54.297]     }
[13:21:54.297]     ...future.frame <- base::sys.nframe()
[13:21:54.297]     ...future.conditions <- base::list()
[13:21:54.297]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:54.297]     if (FALSE) {
[13:21:54.297]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:54.297]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:54.297]     }
[13:21:54.297]     ...future.result <- base::tryCatch({
[13:21:54.297]         base::withCallingHandlers({
[13:21:54.297]             ...future.value <- base::withVisible(base::local(NA))
[13:21:54.297]             future::FutureResult(value = ...future.value$value, 
[13:21:54.297]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:54.297]                   ...future.rng), globalenv = if (FALSE) 
[13:21:54.297]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:54.297]                     ...future.globalenv.names))
[13:21:54.297]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:54.297]         }, condition = base::local({
[13:21:54.297]             c <- base::c
[13:21:54.297]             inherits <- base::inherits
[13:21:54.297]             invokeRestart <- base::invokeRestart
[13:21:54.297]             length <- base::length
[13:21:54.297]             list <- base::list
[13:21:54.297]             seq.int <- base::seq.int
[13:21:54.297]             signalCondition <- base::signalCondition
[13:21:54.297]             sys.calls <- base::sys.calls
[13:21:54.297]             `[[` <- base::`[[`
[13:21:54.297]             `+` <- base::`+`
[13:21:54.297]             `<<-` <- base::`<<-`
[13:21:54.297]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:54.297]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:54.297]                   3L)]
[13:21:54.297]             }
[13:21:54.297]             function(cond) {
[13:21:54.297]                 is_error <- inherits(cond, "error")
[13:21:54.297]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:54.297]                   NULL)
[13:21:54.297]                 if (is_error) {
[13:21:54.297]                   sessionInformation <- function() {
[13:21:54.297]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:54.297]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:54.297]                       search = base::search(), system = base::Sys.info())
[13:21:54.297]                   }
[13:21:54.297]                   ...future.conditions[[length(...future.conditions) + 
[13:21:54.297]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:54.297]                     cond$call), session = sessionInformation(), 
[13:21:54.297]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:54.297]                   signalCondition(cond)
[13:21:54.297]                 }
[13:21:54.297]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:54.297]                 "immediateCondition"))) {
[13:21:54.297]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:54.297]                   ...future.conditions[[length(...future.conditions) + 
[13:21:54.297]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:54.297]                   if (TRUE && !signal) {
[13:21:54.297]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:54.297]                     {
[13:21:54.297]                       inherits <- base::inherits
[13:21:54.297]                       invokeRestart <- base::invokeRestart
[13:21:54.297]                       is.null <- base::is.null
[13:21:54.297]                       muffled <- FALSE
[13:21:54.297]                       if (inherits(cond, "message")) {
[13:21:54.297]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:54.297]                         if (muffled) 
[13:21:54.297]                           invokeRestart("muffleMessage")
[13:21:54.297]                       }
[13:21:54.297]                       else if (inherits(cond, "warning")) {
[13:21:54.297]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:54.297]                         if (muffled) 
[13:21:54.297]                           invokeRestart("muffleWarning")
[13:21:54.297]                       }
[13:21:54.297]                       else if (inherits(cond, "condition")) {
[13:21:54.297]                         if (!is.null(pattern)) {
[13:21:54.297]                           computeRestarts <- base::computeRestarts
[13:21:54.297]                           grepl <- base::grepl
[13:21:54.297]                           restarts <- computeRestarts(cond)
[13:21:54.297]                           for (restart in restarts) {
[13:21:54.297]                             name <- restart$name
[13:21:54.297]                             if (is.null(name)) 
[13:21:54.297]                               next
[13:21:54.297]                             if (!grepl(pattern, name)) 
[13:21:54.297]                               next
[13:21:54.297]                             invokeRestart(restart)
[13:21:54.297]                             muffled <- TRUE
[13:21:54.297]                             break
[13:21:54.297]                           }
[13:21:54.297]                         }
[13:21:54.297]                       }
[13:21:54.297]                       invisible(muffled)
[13:21:54.297]                     }
[13:21:54.297]                     muffleCondition(cond, pattern = "^muffle")
[13:21:54.297]                   }
[13:21:54.297]                 }
[13:21:54.297]                 else {
[13:21:54.297]                   if (TRUE) {
[13:21:54.297]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:54.297]                     {
[13:21:54.297]                       inherits <- base::inherits
[13:21:54.297]                       invokeRestart <- base::invokeRestart
[13:21:54.297]                       is.null <- base::is.null
[13:21:54.297]                       muffled <- FALSE
[13:21:54.297]                       if (inherits(cond, "message")) {
[13:21:54.297]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:54.297]                         if (muffled) 
[13:21:54.297]                           invokeRestart("muffleMessage")
[13:21:54.297]                       }
[13:21:54.297]                       else if (inherits(cond, "warning")) {
[13:21:54.297]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:54.297]                         if (muffled) 
[13:21:54.297]                           invokeRestart("muffleWarning")
[13:21:54.297]                       }
[13:21:54.297]                       else if (inherits(cond, "condition")) {
[13:21:54.297]                         if (!is.null(pattern)) {
[13:21:54.297]                           computeRestarts <- base::computeRestarts
[13:21:54.297]                           grepl <- base::grepl
[13:21:54.297]                           restarts <- computeRestarts(cond)
[13:21:54.297]                           for (restart in restarts) {
[13:21:54.297]                             name <- restart$name
[13:21:54.297]                             if (is.null(name)) 
[13:21:54.297]                               next
[13:21:54.297]                             if (!grepl(pattern, name)) 
[13:21:54.297]                               next
[13:21:54.297]                             invokeRestart(restart)
[13:21:54.297]                             muffled <- TRUE
[13:21:54.297]                             break
[13:21:54.297]                           }
[13:21:54.297]                         }
[13:21:54.297]                       }
[13:21:54.297]                       invisible(muffled)
[13:21:54.297]                     }
[13:21:54.297]                     muffleCondition(cond, pattern = "^muffle")
[13:21:54.297]                   }
[13:21:54.297]                 }
[13:21:54.297]             }
[13:21:54.297]         }))
[13:21:54.297]     }, error = function(ex) {
[13:21:54.297]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:54.297]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:54.297]                 ...future.rng), started = ...future.startTime, 
[13:21:54.297]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:54.297]             version = "1.8"), class = "FutureResult")
[13:21:54.297]     }, finally = {
[13:21:54.297]         if (!identical(...future.workdir, getwd())) 
[13:21:54.297]             setwd(...future.workdir)
[13:21:54.297]         {
[13:21:54.297]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:54.297]                 ...future.oldOptions$nwarnings <- NULL
[13:21:54.297]             }
[13:21:54.297]             base::options(...future.oldOptions)
[13:21:54.297]             if (.Platform$OS.type == "windows") {
[13:21:54.297]                 old_names <- names(...future.oldEnvVars)
[13:21:54.297]                 envs <- base::Sys.getenv()
[13:21:54.297]                 names <- names(envs)
[13:21:54.297]                 common <- intersect(names, old_names)
[13:21:54.297]                 added <- setdiff(names, old_names)
[13:21:54.297]                 removed <- setdiff(old_names, names)
[13:21:54.297]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:54.297]                   envs[common]]
[13:21:54.297]                 NAMES <- toupper(changed)
[13:21:54.297]                 args <- list()
[13:21:54.297]                 for (kk in seq_along(NAMES)) {
[13:21:54.297]                   name <- changed[[kk]]
[13:21:54.297]                   NAME <- NAMES[[kk]]
[13:21:54.297]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:54.297]                     next
[13:21:54.297]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:54.297]                 }
[13:21:54.297]                 NAMES <- toupper(added)
[13:21:54.297]                 for (kk in seq_along(NAMES)) {
[13:21:54.297]                   name <- added[[kk]]
[13:21:54.297]                   NAME <- NAMES[[kk]]
[13:21:54.297]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:54.297]                     next
[13:21:54.297]                   args[[name]] <- ""
[13:21:54.297]                 }
[13:21:54.297]                 NAMES <- toupper(removed)
[13:21:54.297]                 for (kk in seq_along(NAMES)) {
[13:21:54.297]                   name <- removed[[kk]]
[13:21:54.297]                   NAME <- NAMES[[kk]]
[13:21:54.297]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:54.297]                     next
[13:21:54.297]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:54.297]                 }
[13:21:54.297]                 if (length(args) > 0) 
[13:21:54.297]                   base::do.call(base::Sys.setenv, args = args)
[13:21:54.297]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:54.297]             }
[13:21:54.297]             else {
[13:21:54.297]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:54.297]             }
[13:21:54.297]             {
[13:21:54.297]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:54.297]                   0L) {
[13:21:54.297]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:54.297]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:54.297]                   base::options(opts)
[13:21:54.297]                 }
[13:21:54.297]                 {
[13:21:54.297]                   {
[13:21:54.297]                     NULL
[13:21:54.297]                     RNGkind("Mersenne-Twister")
[13:21:54.297]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:54.297]                       inherits = FALSE)
[13:21:54.297]                   }
[13:21:54.297]                   options(future.plan = NULL)
[13:21:54.297]                   if (is.na(NA_character_)) 
[13:21:54.297]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:54.297]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:54.297]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:54.297]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:54.297]                     envir = parent.frame()) 
[13:21:54.297]                   {
[13:21:54.297]                     if (is.function(workers)) 
[13:21:54.297]                       workers <- workers()
[13:21:54.297]                     workers <- structure(as.integer(workers), 
[13:21:54.297]                       class = class(workers))
[13:21:54.297]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:54.297]                       workers >= 1)
[13:21:54.297]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:54.297]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:54.297]                     }
[13:21:54.297]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:54.297]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:54.297]                       envir = envir)
[13:21:54.297]                     if (!future$lazy) 
[13:21:54.297]                       future <- run(future)
[13:21:54.297]                     invisible(future)
[13:21:54.297]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:54.297]                 }
[13:21:54.297]             }
[13:21:54.297]         }
[13:21:54.297]     })
[13:21:54.297]     if (TRUE) {
[13:21:54.297]         base::sink(type = "output", split = FALSE)
[13:21:54.297]         if (TRUE) {
[13:21:54.297]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:54.297]         }
[13:21:54.297]         else {
[13:21:54.297]             ...future.result["stdout"] <- base::list(NULL)
[13:21:54.297]         }
[13:21:54.297]         base::close(...future.stdout)
[13:21:54.297]         ...future.stdout <- NULL
[13:21:54.297]     }
[13:21:54.297]     ...future.result$conditions <- ...future.conditions
[13:21:54.297]     ...future.result$finished <- base::Sys.time()
[13:21:54.297]     ...future.result
[13:21:54.297] }
[13:21:54.299] plan(): Setting new future strategy stack:
[13:21:54.299] List of future strategies:
[13:21:54.299] 1. sequential:
[13:21:54.299]    - args: function (..., envir = parent.frame())
[13:21:54.299]    - tweaked: FALSE
[13:21:54.299]    - call: NULL
[13:21:54.299] plan(): nbrOfWorkers() = 1
[13:21:54.300] plan(): Setting new future strategy stack:
[13:21:54.300] List of future strategies:
[13:21:54.300] 1. multisession:
[13:21:54.300]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:21:54.300]    - tweaked: FALSE
[13:21:54.300]    - call: plan(strategy)
[13:21:54.303] plan(): nbrOfWorkers() = 1
[13:21:54.304] SequentialFuture started (and completed)
[13:21:54.304] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:21:54.307] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[13:21:54.307] future_lapply() ...
[13:21:54.311] Number of chunks: 1
[13:21:54.311] getGlobalsAndPackagesXApply() ...
[13:21:54.311]  - future.globals: TRUE
[13:21:54.311] getGlobalsAndPackages() ...
[13:21:54.311] Searching for globals...
[13:21:54.313] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:21:54.313] Searching for globals ... DONE
[13:21:54.313] Resolving globals: FALSE
[13:21:54.313] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:21:54.314] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:21:54.314] - globals: [1] ‘FUN’
[13:21:54.314] 
[13:21:54.314] getGlobalsAndPackages() ... DONE
[13:21:54.314]  - globals found/used: [n=1] ‘FUN’
[13:21:54.314]  - needed namespaces: [n=0] 
[13:21:54.314] Finding globals ... DONE
[13:21:54.314]  - use_args: TRUE
[13:21:54.314]  - Getting '...' globals ...
[13:21:54.315] resolve() on list ...
[13:21:54.315]  recursive: 0
[13:21:54.315]  length: 1
[13:21:54.315]  elements: ‘...’
[13:21:54.315]  length: 0 (resolved future 1)
[13:21:54.315] resolve() on list ... DONE
[13:21:54.315]    - '...' content: [n=0] 
[13:21:54.315] List of 1
[13:21:54.315]  $ ...: list()
[13:21:54.315]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:54.315]  - attr(*, "where")=List of 1
[13:21:54.315]   ..$ ...:<environment: 0x55dd72d82388> 
[13:21:54.315]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:54.315]  - attr(*, "resolved")= logi TRUE
[13:21:54.315]  - attr(*, "total_size")= num NA
[13:21:54.318]  - Getting '...' globals ... DONE
[13:21:54.318] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:21:54.318] List of 2
[13:21:54.318]  $ ...future.FUN:function (x)  
[13:21:54.318]  $ ...          : list()
[13:21:54.318]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:54.318]  - attr(*, "where")=List of 2
[13:21:54.318]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:54.318]   ..$ ...          :<environment: 0x55dd72d82388> 
[13:21:54.318]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:54.318]  - attr(*, "resolved")= logi FALSE
[13:21:54.318]  - attr(*, "total_size")= num 4720
[13:21:54.321] Packages to be attached in all futures: [n=0] 
[13:21:54.321] getGlobalsAndPackagesXApply() ... DONE
[13:21:54.321] Number of futures (= number of chunks): 1
[13:21:54.321] Launching 1 futures (chunks) ...
[13:21:54.321] Chunk #1 of 1 ...
[13:21:54.322]  - Finding globals in 'X' for chunk #1 ...
[13:21:54.322] getGlobalsAndPackages() ...
[13:21:54.322] Searching for globals...
[13:21:54.322] 
[13:21:54.322] Searching for globals ... DONE
[13:21:54.322] - globals: [0] <none>
[13:21:54.322] getGlobalsAndPackages() ... DONE
[13:21:54.322]    + additional globals found: [n=0] 
[13:21:54.322]    + additional namespaces needed: [n=0] 
[13:21:54.323]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:54.323]  - seeds: <none>
[13:21:54.323]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:54.323] getGlobalsAndPackages() ...
[13:21:54.323] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:54.323] Resolving globals: FALSE
[13:21:54.323] Tweak future expression to call with '...' arguments ...
[13:21:54.323] {
[13:21:54.323]     do.call(function(...) {
[13:21:54.323]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:54.323]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:54.323]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:54.323]             on.exit(options(oopts), add = TRUE)
[13:21:54.323]         }
[13:21:54.323]         {
[13:21:54.323]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:54.323]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:54.323]                 ...future.FUN(...future.X_jj, ...)
[13:21:54.323]             })
[13:21:54.323]         }
[13:21:54.323]     }, args = future.call.arguments)
[13:21:54.323] }
[13:21:54.324] Tweak future expression to call with '...' arguments ... DONE
[13:21:54.324] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:54.324] 
[13:21:54.324] getGlobalsAndPackages() ... DONE
[13:21:54.325] run() for ‘Future’ ...
[13:21:54.325] - state: ‘created’
[13:21:54.325] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:54.329] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:54.329] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:54.329]   - Field: ‘label’
[13:21:54.329]   - Field: ‘local’
[13:21:54.329]   - Field: ‘owner’
[13:21:54.329]   - Field: ‘envir’
[13:21:54.330]   - Field: ‘packages’
[13:21:54.330]   - Field: ‘gc’
[13:21:54.330]   - Field: ‘conditions’
[13:21:54.330]   - Field: ‘expr’
[13:21:54.330]   - Field: ‘uuid’
[13:21:54.330]   - Field: ‘seed’
[13:21:54.332]   - Field: ‘version’
[13:21:54.332]   - Field: ‘result’
[13:21:54.332]   - Field: ‘asynchronous’
[13:21:54.332]   - Field: ‘calls’
[13:21:54.332]   - Field: ‘globals’
[13:21:54.332]   - Field: ‘stdout’
[13:21:54.333]   - Field: ‘earlySignal’
[13:21:54.333]   - Field: ‘lazy’
[13:21:54.333]   - Field: ‘state’
[13:21:54.333] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:54.333] - Launch lazy future ...
[13:21:54.333] Packages needed by the future expression (n = 0): <none>
[13:21:54.333] Packages needed by future strategies (n = 0): <none>
[13:21:54.334] {
[13:21:54.334]     {
[13:21:54.334]         {
[13:21:54.334]             ...future.startTime <- base::Sys.time()
[13:21:54.334]             {
[13:21:54.334]                 {
[13:21:54.334]                   {
[13:21:54.334]                     base::local({
[13:21:54.334]                       has_future <- base::requireNamespace("future", 
[13:21:54.334]                         quietly = TRUE)
[13:21:54.334]                       if (has_future) {
[13:21:54.334]                         ns <- base::getNamespace("future")
[13:21:54.334]                         version <- ns[[".package"]][["version"]]
[13:21:54.334]                         if (is.null(version)) 
[13:21:54.334]                           version <- utils::packageVersion("future")
[13:21:54.334]                       }
[13:21:54.334]                       else {
[13:21:54.334]                         version <- NULL
[13:21:54.334]                       }
[13:21:54.334]                       if (!has_future || version < "1.8.0") {
[13:21:54.334]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:54.334]                           "", base::R.version$version.string), 
[13:21:54.334]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:54.334]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:54.334]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:54.334]                             "release", "version")], collapse = " "), 
[13:21:54.334]                           hostname = base::Sys.info()[["nodename"]])
[13:21:54.334]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:54.334]                           info)
[13:21:54.334]                         info <- base::paste(info, collapse = "; ")
[13:21:54.334]                         if (!has_future) {
[13:21:54.334]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:54.334]                             info)
[13:21:54.334]                         }
[13:21:54.334]                         else {
[13:21:54.334]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:54.334]                             info, version)
[13:21:54.334]                         }
[13:21:54.334]                         base::stop(msg)
[13:21:54.334]                       }
[13:21:54.334]                     })
[13:21:54.334]                   }
[13:21:54.334]                   options(future.plan = NULL)
[13:21:54.334]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:54.334]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:54.334]                 }
[13:21:54.334]                 ...future.workdir <- getwd()
[13:21:54.334]             }
[13:21:54.334]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:54.334]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:54.334]         }
[13:21:54.334]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:54.334]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:54.334]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:54.334]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:54.334]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:54.334]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:54.334]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:54.334]             base::names(...future.oldOptions))
[13:21:54.334]     }
[13:21:54.334]     if (FALSE) {
[13:21:54.334]     }
[13:21:54.334]     else {
[13:21:54.334]         if (FALSE) {
[13:21:54.334]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:54.334]                 open = "w")
[13:21:54.334]         }
[13:21:54.334]         else {
[13:21:54.334]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:54.334]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:54.334]         }
[13:21:54.334]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:54.334]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:54.334]             base::sink(type = "output", split = FALSE)
[13:21:54.334]             base::close(...future.stdout)
[13:21:54.334]         }, add = TRUE)
[13:21:54.334]     }
[13:21:54.334]     ...future.frame <- base::sys.nframe()
[13:21:54.334]     ...future.conditions <- base::list()
[13:21:54.334]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:54.334]     if (FALSE) {
[13:21:54.334]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:54.334]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:54.334]     }
[13:21:54.334]     ...future.result <- base::tryCatch({
[13:21:54.334]         base::withCallingHandlers({
[13:21:54.334]             ...future.value <- base::withVisible(base::local({
[13:21:54.334]                 do.call(function(...) {
[13:21:54.334]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:54.334]                   if (!identical(...future.globals.maxSize.org, 
[13:21:54.334]                     ...future.globals.maxSize)) {
[13:21:54.334]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:54.334]                     on.exit(options(oopts), add = TRUE)
[13:21:54.334]                   }
[13:21:54.334]                   {
[13:21:54.334]                     lapply(seq_along(...future.elements_ii), 
[13:21:54.334]                       FUN = function(jj) {
[13:21:54.334]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:54.334]                         ...future.FUN(...future.X_jj, ...)
[13:21:54.334]                       })
[13:21:54.334]                   }
[13:21:54.334]                 }, args = future.call.arguments)
[13:21:54.334]             }))
[13:21:54.334]             future::FutureResult(value = ...future.value$value, 
[13:21:54.334]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:54.334]                   ...future.rng), globalenv = if (FALSE) 
[13:21:54.334]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:54.334]                     ...future.globalenv.names))
[13:21:54.334]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:54.334]         }, condition = base::local({
[13:21:54.334]             c <- base::c
[13:21:54.334]             inherits <- base::inherits
[13:21:54.334]             invokeRestart <- base::invokeRestart
[13:21:54.334]             length <- base::length
[13:21:54.334]             list <- base::list
[13:21:54.334]             seq.int <- base::seq.int
[13:21:54.334]             signalCondition <- base::signalCondition
[13:21:54.334]             sys.calls <- base::sys.calls
[13:21:54.334]             `[[` <- base::`[[`
[13:21:54.334]             `+` <- base::`+`
[13:21:54.334]             `<<-` <- base::`<<-`
[13:21:54.334]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:54.334]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:54.334]                   3L)]
[13:21:54.334]             }
[13:21:54.334]             function(cond) {
[13:21:54.334]                 is_error <- inherits(cond, "error")
[13:21:54.334]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:54.334]                   NULL)
[13:21:54.334]                 if (is_error) {
[13:21:54.334]                   sessionInformation <- function() {
[13:21:54.334]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:54.334]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:54.334]                       search = base::search(), system = base::Sys.info())
[13:21:54.334]                   }
[13:21:54.334]                   ...future.conditions[[length(...future.conditions) + 
[13:21:54.334]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:54.334]                     cond$call), session = sessionInformation(), 
[13:21:54.334]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:54.334]                   signalCondition(cond)
[13:21:54.334]                 }
[13:21:54.334]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:54.334]                 "immediateCondition"))) {
[13:21:54.334]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:54.334]                   ...future.conditions[[length(...future.conditions) + 
[13:21:54.334]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:54.334]                   if (TRUE && !signal) {
[13:21:54.334]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:54.334]                     {
[13:21:54.334]                       inherits <- base::inherits
[13:21:54.334]                       invokeRestart <- base::invokeRestart
[13:21:54.334]                       is.null <- base::is.null
[13:21:54.334]                       muffled <- FALSE
[13:21:54.334]                       if (inherits(cond, "message")) {
[13:21:54.334]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:54.334]                         if (muffled) 
[13:21:54.334]                           invokeRestart("muffleMessage")
[13:21:54.334]                       }
[13:21:54.334]                       else if (inherits(cond, "warning")) {
[13:21:54.334]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:54.334]                         if (muffled) 
[13:21:54.334]                           invokeRestart("muffleWarning")
[13:21:54.334]                       }
[13:21:54.334]                       else if (inherits(cond, "condition")) {
[13:21:54.334]                         if (!is.null(pattern)) {
[13:21:54.334]                           computeRestarts <- base::computeRestarts
[13:21:54.334]                           grepl <- base::grepl
[13:21:54.334]                           restarts <- computeRestarts(cond)
[13:21:54.334]                           for (restart in restarts) {
[13:21:54.334]                             name <- restart$name
[13:21:54.334]                             if (is.null(name)) 
[13:21:54.334]                               next
[13:21:54.334]                             if (!grepl(pattern, name)) 
[13:21:54.334]                               next
[13:21:54.334]                             invokeRestart(restart)
[13:21:54.334]                             muffled <- TRUE
[13:21:54.334]                             break
[13:21:54.334]                           }
[13:21:54.334]                         }
[13:21:54.334]                       }
[13:21:54.334]                       invisible(muffled)
[13:21:54.334]                     }
[13:21:54.334]                     muffleCondition(cond, pattern = "^muffle")
[13:21:54.334]                   }
[13:21:54.334]                 }
[13:21:54.334]                 else {
[13:21:54.334]                   if (TRUE) {
[13:21:54.334]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:54.334]                     {
[13:21:54.334]                       inherits <- base::inherits
[13:21:54.334]                       invokeRestart <- base::invokeRestart
[13:21:54.334]                       is.null <- base::is.null
[13:21:54.334]                       muffled <- FALSE
[13:21:54.334]                       if (inherits(cond, "message")) {
[13:21:54.334]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:54.334]                         if (muffled) 
[13:21:54.334]                           invokeRestart("muffleMessage")
[13:21:54.334]                       }
[13:21:54.334]                       else if (inherits(cond, "warning")) {
[13:21:54.334]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:54.334]                         if (muffled) 
[13:21:54.334]                           invokeRestart("muffleWarning")
[13:21:54.334]                       }
[13:21:54.334]                       else if (inherits(cond, "condition")) {
[13:21:54.334]                         if (!is.null(pattern)) {
[13:21:54.334]                           computeRestarts <- base::computeRestarts
[13:21:54.334]                           grepl <- base::grepl
[13:21:54.334]                           restarts <- computeRestarts(cond)
[13:21:54.334]                           for (restart in restarts) {
[13:21:54.334]                             name <- restart$name
[13:21:54.334]                             if (is.null(name)) 
[13:21:54.334]                               next
[13:21:54.334]                             if (!grepl(pattern, name)) 
[13:21:54.334]                               next
[13:21:54.334]                             invokeRestart(restart)
[13:21:54.334]                             muffled <- TRUE
[13:21:54.334]                             break
[13:21:54.334]                           }
[13:21:54.334]                         }
[13:21:54.334]                       }
[13:21:54.334]                       invisible(muffled)
[13:21:54.334]                     }
[13:21:54.334]                     muffleCondition(cond, pattern = "^muffle")
[13:21:54.334]                   }
[13:21:54.334]                 }
[13:21:54.334]             }
[13:21:54.334]         }))
[13:21:54.334]     }, error = function(ex) {
[13:21:54.334]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:54.334]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:54.334]                 ...future.rng), started = ...future.startTime, 
[13:21:54.334]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:54.334]             version = "1.8"), class = "FutureResult")
[13:21:54.334]     }, finally = {
[13:21:54.334]         if (!identical(...future.workdir, getwd())) 
[13:21:54.334]             setwd(...future.workdir)
[13:21:54.334]         {
[13:21:54.334]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:54.334]                 ...future.oldOptions$nwarnings <- NULL
[13:21:54.334]             }
[13:21:54.334]             base::options(...future.oldOptions)
[13:21:54.334]             if (.Platform$OS.type == "windows") {
[13:21:54.334]                 old_names <- names(...future.oldEnvVars)
[13:21:54.334]                 envs <- base::Sys.getenv()
[13:21:54.334]                 names <- names(envs)
[13:21:54.334]                 common <- intersect(names, old_names)
[13:21:54.334]                 added <- setdiff(names, old_names)
[13:21:54.334]                 removed <- setdiff(old_names, names)
[13:21:54.334]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:54.334]                   envs[common]]
[13:21:54.334]                 NAMES <- toupper(changed)
[13:21:54.334]                 args <- list()
[13:21:54.334]                 for (kk in seq_along(NAMES)) {
[13:21:54.334]                   name <- changed[[kk]]
[13:21:54.334]                   NAME <- NAMES[[kk]]
[13:21:54.334]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:54.334]                     next
[13:21:54.334]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:54.334]                 }
[13:21:54.334]                 NAMES <- toupper(added)
[13:21:54.334]                 for (kk in seq_along(NAMES)) {
[13:21:54.334]                   name <- added[[kk]]
[13:21:54.334]                   NAME <- NAMES[[kk]]
[13:21:54.334]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:54.334]                     next
[13:21:54.334]                   args[[name]] <- ""
[13:21:54.334]                 }
[13:21:54.334]                 NAMES <- toupper(removed)
[13:21:54.334]                 for (kk in seq_along(NAMES)) {
[13:21:54.334]                   name <- removed[[kk]]
[13:21:54.334]                   NAME <- NAMES[[kk]]
[13:21:54.334]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:54.334]                     next
[13:21:54.334]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:54.334]                 }
[13:21:54.334]                 if (length(args) > 0) 
[13:21:54.334]                   base::do.call(base::Sys.setenv, args = args)
[13:21:54.334]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:54.334]             }
[13:21:54.334]             else {
[13:21:54.334]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:54.334]             }
[13:21:54.334]             {
[13:21:54.334]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:54.334]                   0L) {
[13:21:54.334]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:54.334]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:54.334]                   base::options(opts)
[13:21:54.334]                 }
[13:21:54.334]                 {
[13:21:54.334]                   {
[13:21:54.334]                     NULL
[13:21:54.334]                     RNGkind("Mersenne-Twister")
[13:21:54.334]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:54.334]                       inherits = FALSE)
[13:21:54.334]                   }
[13:21:54.334]                   options(future.plan = NULL)
[13:21:54.334]                   if (is.na(NA_character_)) 
[13:21:54.334]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:54.334]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:54.334]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:54.334]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:54.334]                     envir = parent.frame()) 
[13:21:54.334]                   {
[13:21:54.334]                     if (is.function(workers)) 
[13:21:54.334]                       workers <- workers()
[13:21:54.334]                     workers <- structure(as.integer(workers), 
[13:21:54.334]                       class = class(workers))
[13:21:54.334]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:54.334]                       workers >= 1)
[13:21:54.334]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:54.334]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:54.334]                     }
[13:21:54.334]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:54.334]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:54.334]                       envir = envir)
[13:21:54.334]                     if (!future$lazy) 
[13:21:54.334]                       future <- run(future)
[13:21:54.334]                     invisible(future)
[13:21:54.334]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:54.334]                 }
[13:21:54.334]             }
[13:21:54.334]         }
[13:21:54.334]     })
[13:21:54.334]     if (TRUE) {
[13:21:54.334]         base::sink(type = "output", split = FALSE)
[13:21:54.334]         if (FALSE) {
[13:21:54.334]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:54.334]         }
[13:21:54.334]         else {
[13:21:54.334]             ...future.result["stdout"] <- base::list(NULL)
[13:21:54.334]         }
[13:21:54.334]         base::close(...future.stdout)
[13:21:54.334]         ...future.stdout <- NULL
[13:21:54.334]     }
[13:21:54.334]     ...future.result$conditions <- ...future.conditions
[13:21:54.334]     ...future.result$finished <- base::Sys.time()
[13:21:54.334]     ...future.result
[13:21:54.334] }
[13:21:54.336] assign_globals() ...
[13:21:54.336] List of 5
[13:21:54.336]  $ ...future.FUN            :function (x)  
[13:21:54.336]  $ future.call.arguments    : list()
[13:21:54.336]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:54.336]  $ ...future.elements_ii    :List of 2
[13:21:54.336]   ..$ : int 1
[13:21:54.336]   ..$ : int 0
[13:21:54.336]  $ ...future.seeds_ii       : NULL
[13:21:54.336]  $ ...future.globals.maxSize: NULL
[13:21:54.336]  - attr(*, "where")=List of 5
[13:21:54.336]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:54.336]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:54.336]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:54.336]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:54.336]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:54.336]  - attr(*, "resolved")= logi FALSE
[13:21:54.336]  - attr(*, "total_size")= num 4720
[13:21:54.336]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:54.336]  - attr(*, "already-done")= logi TRUE
[13:21:54.341] - reassign environment for ‘...future.FUN’
[13:21:54.341] - copied ‘...future.FUN’ to environment
[13:21:54.341] - copied ‘future.call.arguments’ to environment
[13:21:54.341] - copied ‘...future.elements_ii’ to environment
[13:21:54.341] - copied ‘...future.seeds_ii’ to environment
[13:21:54.342] - copied ‘...future.globals.maxSize’ to environment
[13:21:54.342] assign_globals() ... done
[13:21:54.342] plan(): Setting new future strategy stack:
[13:21:54.342] List of future strategies:
[13:21:54.342] 1. sequential:
[13:21:54.342]    - args: function (..., envir = parent.frame())
[13:21:54.342]    - tweaked: FALSE
[13:21:54.342]    - call: NULL
[13:21:54.342] plan(): nbrOfWorkers() = 1
[13:21:54.844] plan(): Setting new future strategy stack:
[13:21:54.844] List of future strategies:
[13:21:54.844] 1. multisession:
[13:21:54.844]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:21:54.844]    - tweaked: FALSE
[13:21:54.844]    - call: plan(strategy)
[13:21:54.848] plan(): nbrOfWorkers() = 1
[13:21:54.849] SequentialFuture started (and completed)
[13:21:54.849] - Launch lazy future ... done
[13:21:54.849] run() for ‘SequentialFuture’ ... done
[13:21:54.849] Created future:
[13:21:54.849] SequentialFuture:
[13:21:54.849] Label: ‘future_lapply-1’
[13:21:54.849] Expression:
[13:21:54.849] {
[13:21:54.849]     do.call(function(...) {
[13:21:54.849]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:54.849]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:54.849]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:54.849]             on.exit(options(oopts), add = TRUE)
[13:21:54.849]         }
[13:21:54.849]         {
[13:21:54.849]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:54.849]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:54.849]                 ...future.FUN(...future.X_jj, ...)
[13:21:54.849]             })
[13:21:54.849]         }
[13:21:54.849]     }, args = future.call.arguments)
[13:21:54.849] }
[13:21:54.849] Lazy evaluation: FALSE
[13:21:54.849] Asynchronous evaluation: FALSE
[13:21:54.849] Local evaluation: TRUE
[13:21:54.849] Environment: R_GlobalEnv
[13:21:54.849] Capture standard output: FALSE
[13:21:54.849] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:54.849] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:54.849] Packages: <none>
[13:21:54.849] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:54.849] Resolved: TRUE
[13:21:54.849] Value: 112 bytes of class ‘list’
[13:21:54.849] Early signaling: FALSE
[13:21:54.849] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:21:54.849] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:54.850] Chunk #1 of 1 ... DONE
[13:21:54.850] Launching 1 futures (chunks) ... DONE
[13:21:54.850] Resolving 1 futures (chunks) ...
[13:21:54.851] resolve() on list ...
[13:21:54.851]  recursive: 0
[13:21:54.851]  length: 1
[13:21:54.851] 
[13:21:54.851] resolved() for ‘SequentialFuture’ ...
[13:21:54.851] - state: ‘finished’
[13:21:54.851] - run: TRUE
[13:21:54.851] - result: ‘FutureResult’
[13:21:54.851] resolved() for ‘SequentialFuture’ ... done
[13:21:54.851] Future #1
[13:21:54.852] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:54.852] - nx: 1
[13:21:54.852] - relay: TRUE
[13:21:54.852] - stdout: TRUE
[13:21:54.852] - signal: TRUE
[13:21:54.852] - resignal: FALSE
[13:21:54.852] - force: TRUE
[13:21:54.852] - relayed: [n=1] FALSE
[13:21:54.852] - queued futures: [n=1] FALSE
[13:21:54.852]  - until=1
[13:21:54.852]  - relaying element #1
[13:21:54.853] - relayed: [n=1] TRUE
[13:21:54.853] - queued futures: [n=1] TRUE
[13:21:54.853] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:54.853]  length: 0 (resolved future 1)
[13:21:54.853] Relaying remaining futures
[13:21:54.853] signalConditionsASAP(NULL, pos=0) ...
[13:21:54.853] - nx: 1
[13:21:54.853] - relay: TRUE
[13:21:54.853] - stdout: TRUE
[13:21:54.853] - signal: TRUE
[13:21:54.854] - resignal: FALSE
[13:21:54.854] - force: TRUE
[13:21:54.854] - relayed: [n=1] TRUE
[13:21:54.854] - queued futures: [n=1] TRUE
 - flush all
[13:21:54.854] - relayed: [n=1] TRUE
[13:21:54.854] - queued futures: [n=1] TRUE
[13:21:54.854] signalConditionsASAP(NULL, pos=0) ... done
[13:21:54.854] resolve() on list ... DONE
[13:21:54.854]  - Number of value chunks collected: 1
[13:21:54.854] Resolving 1 futures (chunks) ... DONE
[13:21:54.854] Reducing values from 1 chunks ...
[13:21:54.855]  - Number of values collected after concatenation: 2
[13:21:54.855]  - Number of values expected: 2
[13:21:54.855] Reducing values from 1 chunks ... DONE
[13:21:54.855] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[13:21:54.855] future_lapply() ...
[13:21:54.859] Number of chunks: 1
[13:21:54.859] getGlobalsAndPackagesXApply() ...
[13:21:54.859]  - future.globals: TRUE
[13:21:54.859] getGlobalsAndPackages() ...
[13:21:54.859] Searching for globals...
[13:21:54.861] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:21:54.861] Searching for globals ... DONE
[13:21:54.861] Resolving globals: FALSE
[13:21:54.862] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:21:54.862] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:21:54.862] - globals: [1] ‘FUN’
[13:21:54.862] 
[13:21:54.862] getGlobalsAndPackages() ... DONE
[13:21:54.862]  - globals found/used: [n=1] ‘FUN’
[13:21:54.862]  - needed namespaces: [n=0] 
[13:21:54.863] Finding globals ... DONE
[13:21:54.863]  - use_args: TRUE
[13:21:54.863]  - Getting '...' globals ...
[13:21:54.863] resolve() on list ...
[13:21:54.863]  recursive: 0
[13:21:54.863]  length: 1
[13:21:54.863]  elements: ‘...’
[13:21:54.863]  length: 0 (resolved future 1)
[13:21:54.863] resolve() on list ... DONE
[13:21:54.864]    - '...' content: [n=0] 
[13:21:54.864] List of 1
[13:21:54.864]  $ ...: list()
[13:21:54.864]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:54.864]  - attr(*, "where")=List of 1
[13:21:54.864]   ..$ ...:<environment: 0x55dd74611e88> 
[13:21:54.864]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:54.864]  - attr(*, "resolved")= logi TRUE
[13:21:54.864]  - attr(*, "total_size")= num NA
[13:21:54.868]  - Getting '...' globals ... DONE
[13:21:54.868] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:21:54.869] List of 2
[13:21:54.869]  $ ...future.FUN:function (x)  
[13:21:54.869]  $ ...          : list()
[13:21:54.869]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:54.869]  - attr(*, "where")=List of 2
[13:21:54.869]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:54.869]   ..$ ...          :<environment: 0x55dd74611e88> 
[13:21:54.869]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:54.869]  - attr(*, "resolved")= logi FALSE
[13:21:54.869]  - attr(*, "total_size")= num 4720
[13:21:54.871] Packages to be attached in all futures: [n=0] 
[13:21:54.871] getGlobalsAndPackagesXApply() ... DONE
[13:21:54.872] Number of futures (= number of chunks): 1
[13:21:54.872] Launching 1 futures (chunks) ...
[13:21:54.872] Chunk #1 of 1 ...
[13:21:54.872]  - Finding globals in 'X' for chunk #1 ...
[13:21:54.872] getGlobalsAndPackages() ...
[13:21:54.872] Searching for globals...
[13:21:54.872] 
[13:21:54.872] Searching for globals ... DONE
[13:21:54.873] - globals: [0] <none>
[13:21:54.873] getGlobalsAndPackages() ... DONE
[13:21:54.873]    + additional globals found: [n=0] 
[13:21:54.873]    + additional namespaces needed: [n=0] 
[13:21:54.873]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:54.873]  - seeds: <none>
[13:21:54.873]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:54.873] getGlobalsAndPackages() ...
[13:21:54.873] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:54.873] Resolving globals: FALSE
[13:21:54.874] Tweak future expression to call with '...' arguments ...
[13:21:54.874] {
[13:21:54.874]     do.call(function(...) {
[13:21:54.874]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:54.874]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:54.874]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:54.874]             on.exit(options(oopts), add = TRUE)
[13:21:54.874]         }
[13:21:54.874]         {
[13:21:54.874]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:54.874]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:54.874]                 ...future.FUN(...future.X_jj, ...)
[13:21:54.874]             })
[13:21:54.874]         }
[13:21:54.874]     }, args = future.call.arguments)
[13:21:54.874] }
[13:21:54.874] Tweak future expression to call with '...' arguments ... DONE
[13:21:54.874] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:54.874] 
[13:21:54.874] getGlobalsAndPackages() ... DONE
[13:21:54.875] run() for ‘Future’ ...
[13:21:54.875] - state: ‘created’
[13:21:54.875] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:54.879] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:54.879] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:54.879]   - Field: ‘label’
[13:21:54.879]   - Field: ‘local’
[13:21:54.879]   - Field: ‘owner’
[13:21:54.879]   - Field: ‘envir’
[13:21:54.879]   - Field: ‘packages’
[13:21:54.879]   - Field: ‘gc’
[13:21:54.880]   - Field: ‘conditions’
[13:21:54.880]   - Field: ‘expr’
[13:21:54.880]   - Field: ‘uuid’
[13:21:54.880]   - Field: ‘seed’
[13:21:54.880]   - Field: ‘version’
[13:21:54.880]   - Field: ‘result’
[13:21:54.880]   - Field: ‘asynchronous’
[13:21:54.880]   - Field: ‘calls’
[13:21:54.880]   - Field: ‘globals’
[13:21:54.880]   - Field: ‘stdout’
[13:21:54.881]   - Field: ‘earlySignal’
[13:21:54.881]   - Field: ‘lazy’
[13:21:54.881]   - Field: ‘state’
[13:21:54.881] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:54.881] - Launch lazy future ...
[13:21:54.881] Packages needed by the future expression (n = 0): <none>
[13:21:54.881] Packages needed by future strategies (n = 0): <none>
[13:21:54.882] {
[13:21:54.882]     {
[13:21:54.882]         {
[13:21:54.882]             ...future.startTime <- base::Sys.time()
[13:21:54.882]             {
[13:21:54.882]                 {
[13:21:54.882]                   {
[13:21:54.882]                     base::local({
[13:21:54.882]                       has_future <- base::requireNamespace("future", 
[13:21:54.882]                         quietly = TRUE)
[13:21:54.882]                       if (has_future) {
[13:21:54.882]                         ns <- base::getNamespace("future")
[13:21:54.882]                         version <- ns[[".package"]][["version"]]
[13:21:54.882]                         if (is.null(version)) 
[13:21:54.882]                           version <- utils::packageVersion("future")
[13:21:54.882]                       }
[13:21:54.882]                       else {
[13:21:54.882]                         version <- NULL
[13:21:54.882]                       }
[13:21:54.882]                       if (!has_future || version < "1.8.0") {
[13:21:54.882]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:54.882]                           "", base::R.version$version.string), 
[13:21:54.882]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:54.882]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:54.882]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:54.882]                             "release", "version")], collapse = " "), 
[13:21:54.882]                           hostname = base::Sys.info()[["nodename"]])
[13:21:54.882]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:54.882]                           info)
[13:21:54.882]                         info <- base::paste(info, collapse = "; ")
[13:21:54.882]                         if (!has_future) {
[13:21:54.882]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:54.882]                             info)
[13:21:54.882]                         }
[13:21:54.882]                         else {
[13:21:54.882]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:54.882]                             info, version)
[13:21:54.882]                         }
[13:21:54.882]                         base::stop(msg)
[13:21:54.882]                       }
[13:21:54.882]                     })
[13:21:54.882]                   }
[13:21:54.882]                   options(future.plan = NULL)
[13:21:54.882]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:54.882]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:54.882]                 }
[13:21:54.882]                 ...future.workdir <- getwd()
[13:21:54.882]             }
[13:21:54.882]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:54.882]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:54.882]         }
[13:21:54.882]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:54.882]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:54.882]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:54.882]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:54.882]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:54.882]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:54.882]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:54.882]             base::names(...future.oldOptions))
[13:21:54.882]     }
[13:21:54.882]     if (FALSE) {
[13:21:54.882]     }
[13:21:54.882]     else {
[13:21:54.882]         if (TRUE) {
[13:21:54.882]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:54.882]                 open = "w")
[13:21:54.882]         }
[13:21:54.882]         else {
[13:21:54.882]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:54.882]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:54.882]         }
[13:21:54.882]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:54.882]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:54.882]             base::sink(type = "output", split = FALSE)
[13:21:54.882]             base::close(...future.stdout)
[13:21:54.882]         }, add = TRUE)
[13:21:54.882]     }
[13:21:54.882]     ...future.frame <- base::sys.nframe()
[13:21:54.882]     ...future.conditions <- base::list()
[13:21:54.882]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:54.882]     if (FALSE) {
[13:21:54.882]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:54.882]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:54.882]     }
[13:21:54.882]     ...future.result <- base::tryCatch({
[13:21:54.882]         base::withCallingHandlers({
[13:21:54.882]             ...future.value <- base::withVisible(base::local({
[13:21:54.882]                 do.call(function(...) {
[13:21:54.882]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:54.882]                   if (!identical(...future.globals.maxSize.org, 
[13:21:54.882]                     ...future.globals.maxSize)) {
[13:21:54.882]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:54.882]                     on.exit(options(oopts), add = TRUE)
[13:21:54.882]                   }
[13:21:54.882]                   {
[13:21:54.882]                     lapply(seq_along(...future.elements_ii), 
[13:21:54.882]                       FUN = function(jj) {
[13:21:54.882]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:54.882]                         ...future.FUN(...future.X_jj, ...)
[13:21:54.882]                       })
[13:21:54.882]                   }
[13:21:54.882]                 }, args = future.call.arguments)
[13:21:54.882]             }))
[13:21:54.882]             future::FutureResult(value = ...future.value$value, 
[13:21:54.882]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:54.882]                   ...future.rng), globalenv = if (FALSE) 
[13:21:54.882]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:54.882]                     ...future.globalenv.names))
[13:21:54.882]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:54.882]         }, condition = base::local({
[13:21:54.882]             c <- base::c
[13:21:54.882]             inherits <- base::inherits
[13:21:54.882]             invokeRestart <- base::invokeRestart
[13:21:54.882]             length <- base::length
[13:21:54.882]             list <- base::list
[13:21:54.882]             seq.int <- base::seq.int
[13:21:54.882]             signalCondition <- base::signalCondition
[13:21:54.882]             sys.calls <- base::sys.calls
[13:21:54.882]             `[[` <- base::`[[`
[13:21:54.882]             `+` <- base::`+`
[13:21:54.882]             `<<-` <- base::`<<-`
[13:21:54.882]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:54.882]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:54.882]                   3L)]
[13:21:54.882]             }
[13:21:54.882]             function(cond) {
[13:21:54.882]                 is_error <- inherits(cond, "error")
[13:21:54.882]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:54.882]                   NULL)
[13:21:54.882]                 if (is_error) {
[13:21:54.882]                   sessionInformation <- function() {
[13:21:54.882]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:54.882]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:54.882]                       search = base::search(), system = base::Sys.info())
[13:21:54.882]                   }
[13:21:54.882]                   ...future.conditions[[length(...future.conditions) + 
[13:21:54.882]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:54.882]                     cond$call), session = sessionInformation(), 
[13:21:54.882]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:54.882]                   signalCondition(cond)
[13:21:54.882]                 }
[13:21:54.882]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:54.882]                 "immediateCondition"))) {
[13:21:54.882]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:54.882]                   ...future.conditions[[length(...future.conditions) + 
[13:21:54.882]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:54.882]                   if (TRUE && !signal) {
[13:21:54.882]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:54.882]                     {
[13:21:54.882]                       inherits <- base::inherits
[13:21:54.882]                       invokeRestart <- base::invokeRestart
[13:21:54.882]                       is.null <- base::is.null
[13:21:54.882]                       muffled <- FALSE
[13:21:54.882]                       if (inherits(cond, "message")) {
[13:21:54.882]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:54.882]                         if (muffled) 
[13:21:54.882]                           invokeRestart("muffleMessage")
[13:21:54.882]                       }
[13:21:54.882]                       else if (inherits(cond, "warning")) {
[13:21:54.882]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:54.882]                         if (muffled) 
[13:21:54.882]                           invokeRestart("muffleWarning")
[13:21:54.882]                       }
[13:21:54.882]                       else if (inherits(cond, "condition")) {
[13:21:54.882]                         if (!is.null(pattern)) {
[13:21:54.882]                           computeRestarts <- base::computeRestarts
[13:21:54.882]                           grepl <- base::grepl
[13:21:54.882]                           restarts <- computeRestarts(cond)
[13:21:54.882]                           for (restart in restarts) {
[13:21:54.882]                             name <- restart$name
[13:21:54.882]                             if (is.null(name)) 
[13:21:54.882]                               next
[13:21:54.882]                             if (!grepl(pattern, name)) 
[13:21:54.882]                               next
[13:21:54.882]                             invokeRestart(restart)
[13:21:54.882]                             muffled <- TRUE
[13:21:54.882]                             break
[13:21:54.882]                           }
[13:21:54.882]                         }
[13:21:54.882]                       }
[13:21:54.882]                       invisible(muffled)
[13:21:54.882]                     }
[13:21:54.882]                     muffleCondition(cond, pattern = "^muffle")
[13:21:54.882]                   }
[13:21:54.882]                 }
[13:21:54.882]                 else {
[13:21:54.882]                   if (TRUE) {
[13:21:54.882]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:54.882]                     {
[13:21:54.882]                       inherits <- base::inherits
[13:21:54.882]                       invokeRestart <- base::invokeRestart
[13:21:54.882]                       is.null <- base::is.null
[13:21:54.882]                       muffled <- FALSE
[13:21:54.882]                       if (inherits(cond, "message")) {
[13:21:54.882]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:54.882]                         if (muffled) 
[13:21:54.882]                           invokeRestart("muffleMessage")
[13:21:54.882]                       }
[13:21:54.882]                       else if (inherits(cond, "warning")) {
[13:21:54.882]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:54.882]                         if (muffled) 
[13:21:54.882]                           invokeRestart("muffleWarning")
[13:21:54.882]                       }
[13:21:54.882]                       else if (inherits(cond, "condition")) {
[13:21:54.882]                         if (!is.null(pattern)) {
[13:21:54.882]                           computeRestarts <- base::computeRestarts
[13:21:54.882]                           grepl <- base::grepl
[13:21:54.882]                           restarts <- computeRestarts(cond)
[13:21:54.882]                           for (restart in restarts) {
[13:21:54.882]                             name <- restart$name
[13:21:54.882]                             if (is.null(name)) 
[13:21:54.882]                               next
[13:21:54.882]                             if (!grepl(pattern, name)) 
[13:21:54.882]                               next
[13:21:54.882]                             invokeRestart(restart)
[13:21:54.882]                             muffled <- TRUE
[13:21:54.882]                             break
[13:21:54.882]                           }
[13:21:54.882]                         }
[13:21:54.882]                       }
[13:21:54.882]                       invisible(muffled)
[13:21:54.882]                     }
[13:21:54.882]                     muffleCondition(cond, pattern = "^muffle")
[13:21:54.882]                   }
[13:21:54.882]                 }
[13:21:54.882]             }
[13:21:54.882]         }))
[13:21:54.882]     }, error = function(ex) {
[13:21:54.882]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:54.882]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:54.882]                 ...future.rng), started = ...future.startTime, 
[13:21:54.882]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:54.882]             version = "1.8"), class = "FutureResult")
[13:21:54.882]     }, finally = {
[13:21:54.882]         if (!identical(...future.workdir, getwd())) 
[13:21:54.882]             setwd(...future.workdir)
[13:21:54.882]         {
[13:21:54.882]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:54.882]                 ...future.oldOptions$nwarnings <- NULL
[13:21:54.882]             }
[13:21:54.882]             base::options(...future.oldOptions)
[13:21:54.882]             if (.Platform$OS.type == "windows") {
[13:21:54.882]                 old_names <- names(...future.oldEnvVars)
[13:21:54.882]                 envs <- base::Sys.getenv()
[13:21:54.882]                 names <- names(envs)
[13:21:54.882]                 common <- intersect(names, old_names)
[13:21:54.882]                 added <- setdiff(names, old_names)
[13:21:54.882]                 removed <- setdiff(old_names, names)
[13:21:54.882]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:54.882]                   envs[common]]
[13:21:54.882]                 NAMES <- toupper(changed)
[13:21:54.882]                 args <- list()
[13:21:54.882]                 for (kk in seq_along(NAMES)) {
[13:21:54.882]                   name <- changed[[kk]]
[13:21:54.882]                   NAME <- NAMES[[kk]]
[13:21:54.882]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:54.882]                     next
[13:21:54.882]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:54.882]                 }
[13:21:54.882]                 NAMES <- toupper(added)
[13:21:54.882]                 for (kk in seq_along(NAMES)) {
[13:21:54.882]                   name <- added[[kk]]
[13:21:54.882]                   NAME <- NAMES[[kk]]
[13:21:54.882]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:54.882]                     next
[13:21:54.882]                   args[[name]] <- ""
[13:21:54.882]                 }
[13:21:54.882]                 NAMES <- toupper(removed)
[13:21:54.882]                 for (kk in seq_along(NAMES)) {
[13:21:54.882]                   name <- removed[[kk]]
[13:21:54.882]                   NAME <- NAMES[[kk]]
[13:21:54.882]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:54.882]                     next
[13:21:54.882]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:54.882]                 }
[13:21:54.882]                 if (length(args) > 0) 
[13:21:54.882]                   base::do.call(base::Sys.setenv, args = args)
[13:21:54.882]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:54.882]             }
[13:21:54.882]             else {
[13:21:54.882]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:54.882]             }
[13:21:54.882]             {
[13:21:54.882]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:54.882]                   0L) {
[13:21:54.882]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:54.882]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:54.882]                   base::options(opts)
[13:21:54.882]                 }
[13:21:54.882]                 {
[13:21:54.882]                   {
[13:21:54.882]                     NULL
[13:21:54.882]                     RNGkind("Mersenne-Twister")
[13:21:54.882]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:54.882]                       inherits = FALSE)
[13:21:54.882]                   }
[13:21:54.882]                   options(future.plan = NULL)
[13:21:54.882]                   if (is.na(NA_character_)) 
[13:21:54.882]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:54.882]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:54.882]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:54.882]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:54.882]                     envir = parent.frame()) 
[13:21:54.882]                   {
[13:21:54.882]                     if (is.function(workers)) 
[13:21:54.882]                       workers <- workers()
[13:21:54.882]                     workers <- structure(as.integer(workers), 
[13:21:54.882]                       class = class(workers))
[13:21:54.882]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:54.882]                       workers >= 1)
[13:21:54.882]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:54.882]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:54.882]                     }
[13:21:54.882]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:54.882]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:54.882]                       envir = envir)
[13:21:54.882]                     if (!future$lazy) 
[13:21:54.882]                       future <- run(future)
[13:21:54.882]                     invisible(future)
[13:21:54.882]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:54.882]                 }
[13:21:54.882]             }
[13:21:54.882]         }
[13:21:54.882]     })
[13:21:54.882]     if (TRUE) {
[13:21:54.882]         base::sink(type = "output", split = FALSE)
[13:21:54.882]         if (TRUE) {
[13:21:54.882]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:54.882]         }
[13:21:54.882]         else {
[13:21:54.882]             ...future.result["stdout"] <- base::list(NULL)
[13:21:54.882]         }
[13:21:54.882]         base::close(...future.stdout)
[13:21:54.882]         ...future.stdout <- NULL
[13:21:54.882]     }
[13:21:54.882]     ...future.result$conditions <- ...future.conditions
[13:21:54.882]     ...future.result$finished <- base::Sys.time()
[13:21:54.882]     ...future.result
[13:21:54.882] }
[13:21:54.883] assign_globals() ...
[13:21:54.884] List of 5
[13:21:54.884]  $ ...future.FUN            :function (x)  
[13:21:54.884]  $ future.call.arguments    : list()
[13:21:54.884]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:54.884]  $ ...future.elements_ii    :List of 2
[13:21:54.884]   ..$ : int 1
[13:21:54.884]   ..$ : int 0
[13:21:54.884]  $ ...future.seeds_ii       : NULL
[13:21:54.884]  $ ...future.globals.maxSize: NULL
[13:21:54.884]  - attr(*, "where")=List of 5
[13:21:54.884]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:54.884]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:54.884]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:54.884]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:54.884]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:54.884]  - attr(*, "resolved")= logi FALSE
[13:21:54.884]  - attr(*, "total_size")= num 4720
[13:21:54.884]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:54.884]  - attr(*, "already-done")= logi TRUE
[13:21:54.888] - reassign environment for ‘...future.FUN’
[13:21:54.889] - copied ‘...future.FUN’ to environment
[13:21:54.889] - copied ‘future.call.arguments’ to environment
[13:21:54.889] - copied ‘...future.elements_ii’ to environment
[13:21:54.889] - copied ‘...future.seeds_ii’ to environment
[13:21:54.889] - copied ‘...future.globals.maxSize’ to environment
[13:21:54.889] assign_globals() ... done
[13:21:54.889] plan(): Setting new future strategy stack:
[13:21:54.889] List of future strategies:
[13:21:54.889] 1. sequential:
[13:21:54.889]    - args: function (..., envir = parent.frame())
[13:21:54.889]    - tweaked: FALSE
[13:21:54.889]    - call: NULL
[13:21:54.890] plan(): nbrOfWorkers() = 1
[13:21:55.391] plan(): Setting new future strategy stack:
[13:21:55.392] List of future strategies:
[13:21:55.392] 1. multisession:
[13:21:55.392]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:21:55.392]    - tweaked: FALSE
[13:21:55.392]    - call: plan(strategy)
[13:21:55.396] plan(): nbrOfWorkers() = 1
[13:21:55.396] SequentialFuture started (and completed)
[13:21:55.396] - Launch lazy future ... done
[13:21:55.396] run() for ‘SequentialFuture’ ... done
[13:21:55.396] Created future:
[13:21:55.396] SequentialFuture:
[13:21:55.396] Label: ‘future_lapply-1’
[13:21:55.396] Expression:
[13:21:55.396] {
[13:21:55.396]     do.call(function(...) {
[13:21:55.396]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:55.396]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:55.396]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:55.396]             on.exit(options(oopts), add = TRUE)
[13:21:55.396]         }
[13:21:55.396]         {
[13:21:55.396]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:55.396]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:55.396]                 ...future.FUN(...future.X_jj, ...)
[13:21:55.396]             })
[13:21:55.396]         }
[13:21:55.396]     }, args = future.call.arguments)
[13:21:55.396] }
[13:21:55.396] Lazy evaluation: FALSE
[13:21:55.396] Asynchronous evaluation: FALSE
[13:21:55.396] Local evaluation: TRUE
[13:21:55.396] Environment: R_GlobalEnv
[13:21:55.396] Capture standard output: TRUE
[13:21:55.396] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:55.396] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:55.396] Packages: <none>
[13:21:55.396] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:55.396] Resolved: TRUE
[13:21:55.396] Value: 112 bytes of class ‘list’
[13:21:55.396] Early signaling: FALSE
[13:21:55.396] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:21:55.396] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:55.398] Chunk #1 of 1 ... DONE
[13:21:55.398] Launching 1 futures (chunks) ... DONE
[13:21:55.398] Resolving 1 futures (chunks) ...
[13:21:55.398] resolve() on list ...
[13:21:55.398]  recursive: 0
[13:21:55.398]  length: 1
[13:21:55.398] 
[13:21:55.398] resolved() for ‘SequentialFuture’ ...
[13:21:55.398] - state: ‘finished’
[13:21:55.398] - run: TRUE
[13:21:55.399] - result: ‘FutureResult’
[13:21:55.399] resolved() for ‘SequentialFuture’ ... done
[13:21:55.399] Future #1
[13:21:55.401] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:55.401] - nx: 1
[13:21:55.401] - relay: TRUE
[13:21:55.401] - stdout: TRUE
[13:21:55.401] - signal: TRUE
[13:21:55.401] - resignal: FALSE
[13:21:55.401] - force: TRUE
[13:21:55.401] - relayed: [n=1] FALSE
[13:21:55.401] - queued futures: [n=1] FALSE
[13:21:55.402]  - until=1
[13:21:55.402]  - relaying element #1
[13:21:55.402] - relayed: [n=1] TRUE
[13:21:55.402] - queued futures: [n=1] TRUE
[13:21:55.402] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:55.402]  length: 0 (resolved future 1)
[13:21:55.402] Relaying remaining futures
[13:21:55.402] signalConditionsASAP(NULL, pos=0) ...
[13:21:55.403] - nx: 1
[13:21:55.403] - relay: TRUE
[13:21:55.403] - stdout: TRUE
[13:21:55.403] - signal: TRUE
[13:21:55.403] - resignal: FALSE
[13:21:55.403] - force: TRUE
[13:21:55.403] - relayed: [n=1] TRUE
[13:21:55.403] - queued futures: [n=1] TRUE
 - flush all
[13:21:55.403] - relayed: [n=1] TRUE
[13:21:55.403] - queued futures: [n=1] TRUE
[13:21:55.404] signalConditionsASAP(NULL, pos=0) ... done
[13:21:55.404] resolve() on list ... DONE
[13:21:55.404]  - Number of value chunks collected: 1
[13:21:55.404] Resolving 1 futures (chunks) ... DONE
[13:21:55.404] Reducing values from 1 chunks ...
[13:21:55.404]  - Number of values collected after concatenation: 2
[13:21:55.404]  - Number of values expected: 2
[13:21:55.404] Reducing values from 1 chunks ... DONE
[13:21:55.404] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[13:21:55.405] future_lapply() ...
[13:21:55.409] Number of chunks: 1
[13:21:55.409] getGlobalsAndPackagesXApply() ...
[13:21:55.409]  - future.globals: TRUE
[13:21:55.409] getGlobalsAndPackages() ...
[13:21:55.409] Searching for globals...
[13:21:55.411] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:21:55.411] Searching for globals ... DONE
[13:21:55.411] Resolving globals: FALSE
[13:21:55.411] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:21:55.412] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:21:55.412] - globals: [1] ‘FUN’
[13:21:55.412] 
[13:21:55.412] getGlobalsAndPackages() ... DONE
[13:21:55.412]  - globals found/used: [n=1] ‘FUN’
[13:21:55.412]  - needed namespaces: [n=0] 
[13:21:55.412] Finding globals ... DONE
[13:21:55.412]  - use_args: TRUE
[13:21:55.412]  - Getting '...' globals ...
[13:21:55.413] resolve() on list ...
[13:21:55.413]  recursive: 0
[13:21:55.413]  length: 1
[13:21:55.413]  elements: ‘...’
[13:21:55.413]  length: 0 (resolved future 1)
[13:21:55.413] resolve() on list ... DONE
[13:21:55.413]    - '...' content: [n=0] 
[13:21:55.413] List of 1
[13:21:55.413]  $ ...: list()
[13:21:55.413]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:55.413]  - attr(*, "where")=List of 1
[13:21:55.413]   ..$ ...:<environment: 0x55dd732e8cb8> 
[13:21:55.413]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:55.413]  - attr(*, "resolved")= logi TRUE
[13:21:55.413]  - attr(*, "total_size")= num NA
[13:21:55.416]  - Getting '...' globals ... DONE
[13:21:55.416] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:21:55.416] List of 2
[13:21:55.416]  $ ...future.FUN:function (x)  
[13:21:55.416]  $ ...          : list()
[13:21:55.416]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:55.416]  - attr(*, "where")=List of 2
[13:21:55.416]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:55.416]   ..$ ...          :<environment: 0x55dd732e8cb8> 
[13:21:55.416]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:55.416]  - attr(*, "resolved")= logi FALSE
[13:21:55.416]  - attr(*, "total_size")= num 4720
[13:21:55.419] Packages to be attached in all futures: [n=0] 
[13:21:55.419] getGlobalsAndPackagesXApply() ... DONE
[13:21:55.419] Number of futures (= number of chunks): 1
[13:21:55.419] Launching 1 futures (chunks) ...
[13:21:55.419] Chunk #1 of 1 ...
[13:21:55.419]  - Finding globals in 'X' for chunk #1 ...
[13:21:55.420] getGlobalsAndPackages() ...
[13:21:55.420] Searching for globals...
[13:21:55.420] 
[13:21:55.420] Searching for globals ... DONE
[13:21:55.420] - globals: [0] <none>
[13:21:55.420] getGlobalsAndPackages() ... DONE
[13:21:55.420]    + additional globals found: [n=0] 
[13:21:55.420]    + additional namespaces needed: [n=0] 
[13:21:55.421]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:55.421]  - seeds: <none>
[13:21:55.421]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:55.421] getGlobalsAndPackages() ...
[13:21:55.421] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:55.421] Resolving globals: FALSE
[13:21:55.421] Tweak future expression to call with '...' arguments ...
[13:21:55.421] {
[13:21:55.421]     do.call(function(...) {
[13:21:55.421]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:55.421]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:55.421]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:55.421]             on.exit(options(oopts), add = TRUE)
[13:21:55.421]         }
[13:21:55.421]         {
[13:21:55.421]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:55.421]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:55.421]                 ...future.FUN(...future.X_jj, ...)
[13:21:55.421]             })
[13:21:55.421]         }
[13:21:55.421]     }, args = future.call.arguments)
[13:21:55.421] }
[13:21:55.422] Tweak future expression to call with '...' arguments ... DONE
[13:21:55.422] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:55.422] 
[13:21:55.422] getGlobalsAndPackages() ... DONE
[13:21:55.422] run() for ‘Future’ ...
[13:21:55.422] - state: ‘created’
[13:21:55.423] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:55.426] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:55.426] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:55.426]   - Field: ‘label’
[13:21:55.427]   - Field: ‘local’
[13:21:55.427]   - Field: ‘owner’
[13:21:55.427]   - Field: ‘envir’
[13:21:55.427]   - Field: ‘packages’
[13:21:55.427]   - Field: ‘gc’
[13:21:55.427]   - Field: ‘conditions’
[13:21:55.427]   - Field: ‘expr’
[13:21:55.427]   - Field: ‘uuid’
[13:21:55.427]   - Field: ‘seed’
[13:21:55.427]   - Field: ‘version’
[13:21:55.428]   - Field: ‘result’
[13:21:55.428]   - Field: ‘asynchronous’
[13:21:55.428]   - Field: ‘calls’
[13:21:55.428]   - Field: ‘globals’
[13:21:55.428]   - Field: ‘stdout’
[13:21:55.428]   - Field: ‘earlySignal’
[13:21:55.428]   - Field: ‘lazy’
[13:21:55.428]   - Field: ‘state’
[13:21:55.428] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:55.428] - Launch lazy future ...
[13:21:55.429] Packages needed by the future expression (n = 0): <none>
[13:21:55.429] Packages needed by future strategies (n = 0): <none>
[13:21:55.429] {
[13:21:55.429]     {
[13:21:55.429]         {
[13:21:55.429]             ...future.startTime <- base::Sys.time()
[13:21:55.429]             {
[13:21:55.429]                 {
[13:21:55.429]                   {
[13:21:55.429]                     base::local({
[13:21:55.429]                       has_future <- base::requireNamespace("future", 
[13:21:55.429]                         quietly = TRUE)
[13:21:55.429]                       if (has_future) {
[13:21:55.429]                         ns <- base::getNamespace("future")
[13:21:55.429]                         version <- ns[[".package"]][["version"]]
[13:21:55.429]                         if (is.null(version)) 
[13:21:55.429]                           version <- utils::packageVersion("future")
[13:21:55.429]                       }
[13:21:55.429]                       else {
[13:21:55.429]                         version <- NULL
[13:21:55.429]                       }
[13:21:55.429]                       if (!has_future || version < "1.8.0") {
[13:21:55.429]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:55.429]                           "", base::R.version$version.string), 
[13:21:55.429]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:55.429]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:55.429]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:55.429]                             "release", "version")], collapse = " "), 
[13:21:55.429]                           hostname = base::Sys.info()[["nodename"]])
[13:21:55.429]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:55.429]                           info)
[13:21:55.429]                         info <- base::paste(info, collapse = "; ")
[13:21:55.429]                         if (!has_future) {
[13:21:55.429]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:55.429]                             info)
[13:21:55.429]                         }
[13:21:55.429]                         else {
[13:21:55.429]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:55.429]                             info, version)
[13:21:55.429]                         }
[13:21:55.429]                         base::stop(msg)
[13:21:55.429]                       }
[13:21:55.429]                     })
[13:21:55.429]                   }
[13:21:55.429]                   options(future.plan = NULL)
[13:21:55.429]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:55.429]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:55.429]                 }
[13:21:55.429]                 ...future.workdir <- getwd()
[13:21:55.429]             }
[13:21:55.429]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:55.429]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:55.429]         }
[13:21:55.429]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:55.429]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:55.429]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:55.429]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:55.429]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:55.429]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:55.429]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:55.429]             base::names(...future.oldOptions))
[13:21:55.429]     }
[13:21:55.429]     if (TRUE) {
[13:21:55.429]     }
[13:21:55.429]     else {
[13:21:55.429]         if (NA) {
[13:21:55.429]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:55.429]                 open = "w")
[13:21:55.429]         }
[13:21:55.429]         else {
[13:21:55.429]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:55.429]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:55.429]         }
[13:21:55.429]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:55.429]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:55.429]             base::sink(type = "output", split = FALSE)
[13:21:55.429]             base::close(...future.stdout)
[13:21:55.429]         }, add = TRUE)
[13:21:55.429]     }
[13:21:55.429]     ...future.frame <- base::sys.nframe()
[13:21:55.429]     ...future.conditions <- base::list()
[13:21:55.429]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:55.429]     if (FALSE) {
[13:21:55.429]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:55.429]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:55.429]     }
[13:21:55.429]     ...future.result <- base::tryCatch({
[13:21:55.429]         base::withCallingHandlers({
[13:21:55.429]             ...future.value <- base::withVisible(base::local({
[13:21:55.429]                 do.call(function(...) {
[13:21:55.429]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:55.429]                   if (!identical(...future.globals.maxSize.org, 
[13:21:55.429]                     ...future.globals.maxSize)) {
[13:21:55.429]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:55.429]                     on.exit(options(oopts), add = TRUE)
[13:21:55.429]                   }
[13:21:55.429]                   {
[13:21:55.429]                     lapply(seq_along(...future.elements_ii), 
[13:21:55.429]                       FUN = function(jj) {
[13:21:55.429]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:55.429]                         ...future.FUN(...future.X_jj, ...)
[13:21:55.429]                       })
[13:21:55.429]                   }
[13:21:55.429]                 }, args = future.call.arguments)
[13:21:55.429]             }))
[13:21:55.429]             future::FutureResult(value = ...future.value$value, 
[13:21:55.429]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:55.429]                   ...future.rng), globalenv = if (FALSE) 
[13:21:55.429]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:55.429]                     ...future.globalenv.names))
[13:21:55.429]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:55.429]         }, condition = base::local({
[13:21:55.429]             c <- base::c
[13:21:55.429]             inherits <- base::inherits
[13:21:55.429]             invokeRestart <- base::invokeRestart
[13:21:55.429]             length <- base::length
[13:21:55.429]             list <- base::list
[13:21:55.429]             seq.int <- base::seq.int
[13:21:55.429]             signalCondition <- base::signalCondition
[13:21:55.429]             sys.calls <- base::sys.calls
[13:21:55.429]             `[[` <- base::`[[`
[13:21:55.429]             `+` <- base::`+`
[13:21:55.429]             `<<-` <- base::`<<-`
[13:21:55.429]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:55.429]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:55.429]                   3L)]
[13:21:55.429]             }
[13:21:55.429]             function(cond) {
[13:21:55.429]                 is_error <- inherits(cond, "error")
[13:21:55.429]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:55.429]                   NULL)
[13:21:55.429]                 if (is_error) {
[13:21:55.429]                   sessionInformation <- function() {
[13:21:55.429]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:55.429]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:55.429]                       search = base::search(), system = base::Sys.info())
[13:21:55.429]                   }
[13:21:55.429]                   ...future.conditions[[length(...future.conditions) + 
[13:21:55.429]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:55.429]                     cond$call), session = sessionInformation(), 
[13:21:55.429]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:55.429]                   signalCondition(cond)
[13:21:55.429]                 }
[13:21:55.429]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:55.429]                 "immediateCondition"))) {
[13:21:55.429]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:55.429]                   ...future.conditions[[length(...future.conditions) + 
[13:21:55.429]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:55.429]                   if (TRUE && !signal) {
[13:21:55.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:55.429]                     {
[13:21:55.429]                       inherits <- base::inherits
[13:21:55.429]                       invokeRestart <- base::invokeRestart
[13:21:55.429]                       is.null <- base::is.null
[13:21:55.429]                       muffled <- FALSE
[13:21:55.429]                       if (inherits(cond, "message")) {
[13:21:55.429]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:55.429]                         if (muffled) 
[13:21:55.429]                           invokeRestart("muffleMessage")
[13:21:55.429]                       }
[13:21:55.429]                       else if (inherits(cond, "warning")) {
[13:21:55.429]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:55.429]                         if (muffled) 
[13:21:55.429]                           invokeRestart("muffleWarning")
[13:21:55.429]                       }
[13:21:55.429]                       else if (inherits(cond, "condition")) {
[13:21:55.429]                         if (!is.null(pattern)) {
[13:21:55.429]                           computeRestarts <- base::computeRestarts
[13:21:55.429]                           grepl <- base::grepl
[13:21:55.429]                           restarts <- computeRestarts(cond)
[13:21:55.429]                           for (restart in restarts) {
[13:21:55.429]                             name <- restart$name
[13:21:55.429]                             if (is.null(name)) 
[13:21:55.429]                               next
[13:21:55.429]                             if (!grepl(pattern, name)) 
[13:21:55.429]                               next
[13:21:55.429]                             invokeRestart(restart)
[13:21:55.429]                             muffled <- TRUE
[13:21:55.429]                             break
[13:21:55.429]                           }
[13:21:55.429]                         }
[13:21:55.429]                       }
[13:21:55.429]                       invisible(muffled)
[13:21:55.429]                     }
[13:21:55.429]                     muffleCondition(cond, pattern = "^muffle")
[13:21:55.429]                   }
[13:21:55.429]                 }
[13:21:55.429]                 else {
[13:21:55.429]                   if (TRUE) {
[13:21:55.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:55.429]                     {
[13:21:55.429]                       inherits <- base::inherits
[13:21:55.429]                       invokeRestart <- base::invokeRestart
[13:21:55.429]                       is.null <- base::is.null
[13:21:55.429]                       muffled <- FALSE
[13:21:55.429]                       if (inherits(cond, "message")) {
[13:21:55.429]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:55.429]                         if (muffled) 
[13:21:55.429]                           invokeRestart("muffleMessage")
[13:21:55.429]                       }
[13:21:55.429]                       else if (inherits(cond, "warning")) {
[13:21:55.429]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:55.429]                         if (muffled) 
[13:21:55.429]                           invokeRestart("muffleWarning")
[13:21:55.429]                       }
[13:21:55.429]                       else if (inherits(cond, "condition")) {
[13:21:55.429]                         if (!is.null(pattern)) {
[13:21:55.429]                           computeRestarts <- base::computeRestarts
[13:21:55.429]                           grepl <- base::grepl
[13:21:55.429]                           restarts <- computeRestarts(cond)
[13:21:55.429]                           for (restart in restarts) {
[13:21:55.429]                             name <- restart$name
[13:21:55.429]                             if (is.null(name)) 
[13:21:55.429]                               next
[13:21:55.429]                             if (!grepl(pattern, name)) 
[13:21:55.429]                               next
[13:21:55.429]                             invokeRestart(restart)
[13:21:55.429]                             muffled <- TRUE
[13:21:55.429]                             break
[13:21:55.429]                           }
[13:21:55.429]                         }
[13:21:55.429]                       }
[13:21:55.429]                       invisible(muffled)
[13:21:55.429]                     }
[13:21:55.429]                     muffleCondition(cond, pattern = "^muffle")
[13:21:55.429]                   }
[13:21:55.429]                 }
[13:21:55.429]             }
[13:21:55.429]         }))
[13:21:55.429]     }, error = function(ex) {
[13:21:55.429]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:55.429]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:55.429]                 ...future.rng), started = ...future.startTime, 
[13:21:55.429]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:55.429]             version = "1.8"), class = "FutureResult")
[13:21:55.429]     }, finally = {
[13:21:55.429]         if (!identical(...future.workdir, getwd())) 
[13:21:55.429]             setwd(...future.workdir)
[13:21:55.429]         {
[13:21:55.429]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:55.429]                 ...future.oldOptions$nwarnings <- NULL
[13:21:55.429]             }
[13:21:55.429]             base::options(...future.oldOptions)
[13:21:55.429]             if (.Platform$OS.type == "windows") {
[13:21:55.429]                 old_names <- names(...future.oldEnvVars)
[13:21:55.429]                 envs <- base::Sys.getenv()
[13:21:55.429]                 names <- names(envs)
[13:21:55.429]                 common <- intersect(names, old_names)
[13:21:55.429]                 added <- setdiff(names, old_names)
[13:21:55.429]                 removed <- setdiff(old_names, names)
[13:21:55.429]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:55.429]                   envs[common]]
[13:21:55.429]                 NAMES <- toupper(changed)
[13:21:55.429]                 args <- list()
[13:21:55.429]                 for (kk in seq_along(NAMES)) {
[13:21:55.429]                   name <- changed[[kk]]
[13:21:55.429]                   NAME <- NAMES[[kk]]
[13:21:55.429]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:55.429]                     next
[13:21:55.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:55.429]                 }
[13:21:55.429]                 NAMES <- toupper(added)
[13:21:55.429]                 for (kk in seq_along(NAMES)) {
[13:21:55.429]                   name <- added[[kk]]
[13:21:55.429]                   NAME <- NAMES[[kk]]
[13:21:55.429]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:55.429]                     next
[13:21:55.429]                   args[[name]] <- ""
[13:21:55.429]                 }
[13:21:55.429]                 NAMES <- toupper(removed)
[13:21:55.429]                 for (kk in seq_along(NAMES)) {
[13:21:55.429]                   name <- removed[[kk]]
[13:21:55.429]                   NAME <- NAMES[[kk]]
[13:21:55.429]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:55.429]                     next
[13:21:55.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:55.429]                 }
[13:21:55.429]                 if (length(args) > 0) 
[13:21:55.429]                   base::do.call(base::Sys.setenv, args = args)
[13:21:55.429]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:55.429]             }
[13:21:55.429]             else {
[13:21:55.429]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:55.429]             }
[13:21:55.429]             {
[13:21:55.429]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:55.429]                   0L) {
[13:21:55.429]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:55.429]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:55.429]                   base::options(opts)
[13:21:55.429]                 }
[13:21:55.429]                 {
[13:21:55.429]                   {
[13:21:55.429]                     NULL
[13:21:55.429]                     RNGkind("Mersenne-Twister")
[13:21:55.429]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:55.429]                       inherits = FALSE)
[13:21:55.429]                   }
[13:21:55.429]                   options(future.plan = NULL)
[13:21:55.429]                   if (is.na(NA_character_)) 
[13:21:55.429]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:55.429]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:55.429]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:55.429]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:55.429]                     envir = parent.frame()) 
[13:21:55.429]                   {
[13:21:55.429]                     if (is.function(workers)) 
[13:21:55.429]                       workers <- workers()
[13:21:55.429]                     workers <- structure(as.integer(workers), 
[13:21:55.429]                       class = class(workers))
[13:21:55.429]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:55.429]                       workers >= 1)
[13:21:55.429]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:55.429]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:55.429]                     }
[13:21:55.429]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:55.429]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:55.429]                       envir = envir)
[13:21:55.429]                     if (!future$lazy) 
[13:21:55.429]                       future <- run(future)
[13:21:55.429]                     invisible(future)
[13:21:55.429]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:55.429]                 }
[13:21:55.429]             }
[13:21:55.429]         }
[13:21:55.429]     })
[13:21:55.429]     if (FALSE) {
[13:21:55.429]         base::sink(type = "output", split = FALSE)
[13:21:55.429]         if (NA) {
[13:21:55.429]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:55.429]         }
[13:21:55.429]         else {
[13:21:55.429]             ...future.result["stdout"] <- base::list(NULL)
[13:21:55.429]         }
[13:21:55.429]         base::close(...future.stdout)
[13:21:55.429]         ...future.stdout <- NULL
[13:21:55.429]     }
[13:21:55.429]     ...future.result$conditions <- ...future.conditions
[13:21:55.429]     ...future.result$finished <- base::Sys.time()
[13:21:55.429]     ...future.result
[13:21:55.429] }
[13:21:55.431] assign_globals() ...
[13:21:55.431] List of 5
[13:21:55.431]  $ ...future.FUN            :function (x)  
[13:21:55.431]  $ future.call.arguments    : list()
[13:21:55.431]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:55.431]  $ ...future.elements_ii    :List of 2
[13:21:55.431]   ..$ : int 1
[13:21:55.431]   ..$ : int 0
[13:21:55.431]  $ ...future.seeds_ii       : NULL
[13:21:55.431]  $ ...future.globals.maxSize: NULL
[13:21:55.431]  - attr(*, "where")=List of 5
[13:21:55.431]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:55.431]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:55.431]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:55.431]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:55.431]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:55.431]  - attr(*, "resolved")= logi FALSE
[13:21:55.431]  - attr(*, "total_size")= num 4720
[13:21:55.431]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:55.431]  - attr(*, "already-done")= logi TRUE
[13:21:55.438] - reassign environment for ‘...future.FUN’
[13:21:55.438] - copied ‘...future.FUN’ to environment
[13:21:55.438] - copied ‘future.call.arguments’ to environment
[13:21:55.438] - copied ‘...future.elements_ii’ to environment
[13:21:55.438] - copied ‘...future.seeds_ii’ to environment
[13:21:55.439] - copied ‘...future.globals.maxSize’ to environment
[13:21:55.439] assign_globals() ... done
[13:21:55.439] plan(): Setting new future strategy stack:
[13:21:55.439] List of future strategies:
[13:21:55.439] 1. sequential:
[13:21:55.439]    - args: function (..., envir = parent.frame())
[13:21:55.439]    - tweaked: FALSE
[13:21:55.439]    - call: NULL
[13:21:55.439] plan(): nbrOfWorkers() = 1
[13:21:55.941] plan(): Setting new future strategy stack:
[13:21:55.941] List of future strategies:
[13:21:55.941] 1. multisession:
[13:21:55.941]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:21:55.941]    - tweaked: FALSE
[13:21:55.941]    - call: plan(strategy)
[13:21:55.945] plan(): nbrOfWorkers() = 1
[13:21:55.945] SequentialFuture started (and completed)
[13:21:55.946] - Launch lazy future ... done
[13:21:55.946] run() for ‘SequentialFuture’ ... done
[13:21:55.946] Created future:
[13:21:55.946] SequentialFuture:
[13:21:55.946] Label: ‘future_lapply-1’
[13:21:55.946] Expression:
[13:21:55.946] {
[13:21:55.946]     do.call(function(...) {
[13:21:55.946]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:55.946]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:55.946]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:55.946]             on.exit(options(oopts), add = TRUE)
[13:21:55.946]         }
[13:21:55.946]         {
[13:21:55.946]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:55.946]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:55.946]                 ...future.FUN(...future.X_jj, ...)
[13:21:55.946]             })
[13:21:55.946]         }
[13:21:55.946]     }, args = future.call.arguments)
[13:21:55.946] }
[13:21:55.946] Lazy evaluation: FALSE
[13:21:55.946] Asynchronous evaluation: FALSE
[13:21:55.946] Local evaluation: TRUE
[13:21:55.946] Environment: R_GlobalEnv
[13:21:55.946] Capture standard output: NA
[13:21:55.946] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:55.946] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:55.946] Packages: <none>
[13:21:55.946] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:55.946] Resolved: TRUE
[13:21:55.946] Value: 112 bytes of class ‘list’
[13:21:55.946] Early signaling: FALSE
[13:21:55.946] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:21:55.946] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:55.947] Chunk #1 of 1 ... DONE
[13:21:55.947] Launching 1 futures (chunks) ... DONE
[13:21:55.947] Resolving 1 futures (chunks) ...
[13:21:55.947] resolve() on list ...
[13:21:55.947]  recursive: 0
[13:21:55.947]  length: 1
[13:21:55.948] 
[13:21:55.948] resolved() for ‘SequentialFuture’ ...
[13:21:55.948] - state: ‘finished’
[13:21:55.948] - run: TRUE
[13:21:55.948] - result: ‘FutureResult’
[13:21:55.948] resolved() for ‘SequentialFuture’ ... done
[13:21:55.948] Future #1
[13:21:55.948] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:55.948] - nx: 1
[13:21:55.948] - relay: TRUE
[13:21:55.949] - stdout: TRUE
[13:21:55.949] - signal: TRUE
[13:21:55.949] - resignal: FALSE
[13:21:55.949] - force: TRUE
[13:21:55.949] - relayed: [n=1] FALSE
[13:21:55.949] - queued futures: [n=1] FALSE
[13:21:55.949]  - until=1
[13:21:55.949]  - relaying element #1
[13:21:55.949] - relayed: [n=1] TRUE
[13:21:55.949] - queued futures: [n=1] TRUE
[13:21:55.950] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:55.950]  length: 0 (resolved future 1)
[13:21:55.950] Relaying remaining futures
[13:21:55.950] signalConditionsASAP(NULL, pos=0) ...
[13:21:55.950] - nx: 1
[13:21:55.950] - relay: TRUE
[13:21:55.950] - stdout: TRUE
[13:21:55.950] - signal: TRUE
[13:21:55.950] - resignal: FALSE
[13:21:55.950] - force: TRUE
[13:21:55.950] - relayed: [n=1] TRUE
[13:21:55.950] - queued futures: [n=1] TRUE
 - flush all
[13:21:55.951] - relayed: [n=1] TRUE
[13:21:55.951] - queued futures: [n=1] TRUE
[13:21:55.951] signalConditionsASAP(NULL, pos=0) ... done
[13:21:55.951] resolve() on list ... DONE
[13:21:55.951]  - Number of value chunks collected: 1
[13:21:55.951] Resolving 1 futures (chunks) ... DONE
[13:21:55.951] Reducing values from 1 chunks ...
[13:21:55.951]  - Number of values collected after concatenation: 2
[13:21:55.951]  - Number of values expected: 2
[13:21:55.951] Reducing values from 1 chunks ... DONE
[13:21:55.952] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[13:21:55.952] future_mapply() ...
[13:21:55.955] Number of chunks: 1
[13:21:55.955] getGlobalsAndPackagesXApply() ...
[13:21:55.955]  - future.globals: TRUE
[13:21:55.955] getGlobalsAndPackages() ...
[13:21:55.955] Searching for globals...
[13:21:55.957] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:21:55.957] Searching for globals ... DONE
[13:21:55.957] Resolving globals: FALSE
[13:21:55.958] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:21:55.958] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:21:55.958] - globals: [1] ‘FUN’
[13:21:55.958] 
[13:21:55.958] getGlobalsAndPackages() ... DONE
[13:21:55.958]  - globals found/used: [n=1] ‘FUN’
[13:21:55.959]  - needed namespaces: [n=0] 
[13:21:55.959] Finding globals ... DONE
[13:21:55.959] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:21:55.959] List of 2
[13:21:55.959]  $ ...future.FUN:function (x, y)  
[13:21:55.959]  $ MoreArgs     : NULL
[13:21:55.959]  - attr(*, "where")=List of 2
[13:21:55.959]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:55.959]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:21:55.959]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:55.959]  - attr(*, "resolved")= logi FALSE
[13:21:55.959]  - attr(*, "total_size")= num NA
[13:21:55.961] Packages to be attached in all futures: [n=0] 
[13:21:55.962] getGlobalsAndPackagesXApply() ... DONE
[13:21:55.962] Number of futures (= number of chunks): 1
[13:21:55.962] Launching 1 futures (chunks) ...
[13:21:55.962] Chunk #1 of 1 ...
[13:21:55.962]  - Finding globals in '...' for chunk #1 ...
[13:21:55.962] getGlobalsAndPackages() ...
[13:21:55.962] Searching for globals...
[13:21:55.963] 
[13:21:55.963] Searching for globals ... DONE
[13:21:55.963] - globals: [0] <none>
[13:21:55.964] getGlobalsAndPackages() ... DONE
[13:21:55.964]    + additional globals found: [n=0] 
[13:21:55.965]    + additional namespaces needed: [n=0] 
[13:21:55.965]  - Finding globals in '...' for chunk #1 ... DONE
[13:21:55.965]  - seeds: <none>
[13:21:55.965]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:55.965] getGlobalsAndPackages() ...
[13:21:55.965] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:55.965] Resolving globals: FALSE
[13:21:55.966] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[13:21:55.966] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:21:55.966] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:55.967] 
[13:21:55.967] getGlobalsAndPackages() ... DONE
[13:21:55.967] run() for ‘Future’ ...
[13:21:55.967] - state: ‘created’
[13:21:55.967] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:55.971] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:55.971] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:55.971]   - Field: ‘label’
[13:21:55.971]   - Field: ‘local’
[13:21:55.971]   - Field: ‘owner’
[13:21:55.971]   - Field: ‘envir’
[13:21:55.971]   - Field: ‘packages’
[13:21:55.971]   - Field: ‘gc’
[13:21:55.972]   - Field: ‘conditions’
[13:21:55.972]   - Field: ‘expr’
[13:21:55.972]   - Field: ‘uuid’
[13:21:55.972]   - Field: ‘seed’
[13:21:55.972]   - Field: ‘version’
[13:21:55.972]   - Field: ‘result’
[13:21:55.972]   - Field: ‘asynchronous’
[13:21:55.972]   - Field: ‘calls’
[13:21:55.972]   - Field: ‘globals’
[13:21:55.972]   - Field: ‘stdout’
[13:21:55.973]   - Field: ‘earlySignal’
[13:21:55.973]   - Field: ‘lazy’
[13:21:55.973]   - Field: ‘state’
[13:21:55.973] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:55.973] - Launch lazy future ...
[13:21:55.973] Packages needed by the future expression (n = 0): <none>
[13:21:55.973] Packages needed by future strategies (n = 0): <none>
[13:21:55.974] {
[13:21:55.974]     {
[13:21:55.974]         {
[13:21:55.974]             ...future.startTime <- base::Sys.time()
[13:21:55.974]             {
[13:21:55.974]                 {
[13:21:55.974]                   {
[13:21:55.974]                     base::local({
[13:21:55.974]                       has_future <- base::requireNamespace("future", 
[13:21:55.974]                         quietly = TRUE)
[13:21:55.974]                       if (has_future) {
[13:21:55.974]                         ns <- base::getNamespace("future")
[13:21:55.974]                         version <- ns[[".package"]][["version"]]
[13:21:55.974]                         if (is.null(version)) 
[13:21:55.974]                           version <- utils::packageVersion("future")
[13:21:55.974]                       }
[13:21:55.974]                       else {
[13:21:55.974]                         version <- NULL
[13:21:55.974]                       }
[13:21:55.974]                       if (!has_future || version < "1.8.0") {
[13:21:55.974]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:55.974]                           "", base::R.version$version.string), 
[13:21:55.974]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:55.974]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:55.974]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:55.974]                             "release", "version")], collapse = " "), 
[13:21:55.974]                           hostname = base::Sys.info()[["nodename"]])
[13:21:55.974]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:55.974]                           info)
[13:21:55.974]                         info <- base::paste(info, collapse = "; ")
[13:21:55.974]                         if (!has_future) {
[13:21:55.974]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:55.974]                             info)
[13:21:55.974]                         }
[13:21:55.974]                         else {
[13:21:55.974]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:55.974]                             info, version)
[13:21:55.974]                         }
[13:21:55.974]                         base::stop(msg)
[13:21:55.974]                       }
[13:21:55.974]                     })
[13:21:55.974]                   }
[13:21:55.974]                   options(future.plan = NULL)
[13:21:55.974]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:55.974]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:55.974]                 }
[13:21:55.974]                 ...future.workdir <- getwd()
[13:21:55.974]             }
[13:21:55.974]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:55.974]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:55.974]         }
[13:21:55.974]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:55.974]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:55.974]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:55.974]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:55.974]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:55.974]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:55.974]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:55.974]             base::names(...future.oldOptions))
[13:21:55.974]     }
[13:21:55.974]     if (FALSE) {
[13:21:55.974]     }
[13:21:55.974]     else {
[13:21:55.974]         if (FALSE) {
[13:21:55.974]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:55.974]                 open = "w")
[13:21:55.974]         }
[13:21:55.974]         else {
[13:21:55.974]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:55.974]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:55.974]         }
[13:21:55.974]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:55.974]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:55.974]             base::sink(type = "output", split = FALSE)
[13:21:55.974]             base::close(...future.stdout)
[13:21:55.974]         }, add = TRUE)
[13:21:55.974]     }
[13:21:55.974]     ...future.frame <- base::sys.nframe()
[13:21:55.974]     ...future.conditions <- base::list()
[13:21:55.974]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:55.974]     if (FALSE) {
[13:21:55.974]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:55.974]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:55.974]     }
[13:21:55.974]     ...future.result <- base::tryCatch({
[13:21:55.974]         base::withCallingHandlers({
[13:21:55.974]             ...future.value <- base::withVisible(base::local({
[13:21:55.974]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:55.974]                 if (!identical(...future.globals.maxSize.org, 
[13:21:55.974]                   ...future.globals.maxSize)) {
[13:21:55.974]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:55.974]                   on.exit(options(oopts), add = TRUE)
[13:21:55.974]                 }
[13:21:55.974]                 {
[13:21:55.974]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:21:55.974]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:21:55.974]                     USE.NAMES = FALSE)
[13:21:55.974]                   do.call(mapply, args = args)
[13:21:55.974]                 }
[13:21:55.974]             }))
[13:21:55.974]             future::FutureResult(value = ...future.value$value, 
[13:21:55.974]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:55.974]                   ...future.rng), globalenv = if (FALSE) 
[13:21:55.974]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:55.974]                     ...future.globalenv.names))
[13:21:55.974]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:55.974]         }, condition = base::local({
[13:21:55.974]             c <- base::c
[13:21:55.974]             inherits <- base::inherits
[13:21:55.974]             invokeRestart <- base::invokeRestart
[13:21:55.974]             length <- base::length
[13:21:55.974]             list <- base::list
[13:21:55.974]             seq.int <- base::seq.int
[13:21:55.974]             signalCondition <- base::signalCondition
[13:21:55.974]             sys.calls <- base::sys.calls
[13:21:55.974]             `[[` <- base::`[[`
[13:21:55.974]             `+` <- base::`+`
[13:21:55.974]             `<<-` <- base::`<<-`
[13:21:55.974]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:55.974]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:55.974]                   3L)]
[13:21:55.974]             }
[13:21:55.974]             function(cond) {
[13:21:55.974]                 is_error <- inherits(cond, "error")
[13:21:55.974]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:55.974]                   NULL)
[13:21:55.974]                 if (is_error) {
[13:21:55.974]                   sessionInformation <- function() {
[13:21:55.974]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:55.974]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:55.974]                       search = base::search(), system = base::Sys.info())
[13:21:55.974]                   }
[13:21:55.974]                   ...future.conditions[[length(...future.conditions) + 
[13:21:55.974]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:55.974]                     cond$call), session = sessionInformation(), 
[13:21:55.974]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:55.974]                   signalCondition(cond)
[13:21:55.974]                 }
[13:21:55.974]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:55.974]                 "immediateCondition"))) {
[13:21:55.974]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:55.974]                   ...future.conditions[[length(...future.conditions) + 
[13:21:55.974]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:55.974]                   if (TRUE && !signal) {
[13:21:55.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:55.974]                     {
[13:21:55.974]                       inherits <- base::inherits
[13:21:55.974]                       invokeRestart <- base::invokeRestart
[13:21:55.974]                       is.null <- base::is.null
[13:21:55.974]                       muffled <- FALSE
[13:21:55.974]                       if (inherits(cond, "message")) {
[13:21:55.974]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:55.974]                         if (muffled) 
[13:21:55.974]                           invokeRestart("muffleMessage")
[13:21:55.974]                       }
[13:21:55.974]                       else if (inherits(cond, "warning")) {
[13:21:55.974]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:55.974]                         if (muffled) 
[13:21:55.974]                           invokeRestart("muffleWarning")
[13:21:55.974]                       }
[13:21:55.974]                       else if (inherits(cond, "condition")) {
[13:21:55.974]                         if (!is.null(pattern)) {
[13:21:55.974]                           computeRestarts <- base::computeRestarts
[13:21:55.974]                           grepl <- base::grepl
[13:21:55.974]                           restarts <- computeRestarts(cond)
[13:21:55.974]                           for (restart in restarts) {
[13:21:55.974]                             name <- restart$name
[13:21:55.974]                             if (is.null(name)) 
[13:21:55.974]                               next
[13:21:55.974]                             if (!grepl(pattern, name)) 
[13:21:55.974]                               next
[13:21:55.974]                             invokeRestart(restart)
[13:21:55.974]                             muffled <- TRUE
[13:21:55.974]                             break
[13:21:55.974]                           }
[13:21:55.974]                         }
[13:21:55.974]                       }
[13:21:55.974]                       invisible(muffled)
[13:21:55.974]                     }
[13:21:55.974]                     muffleCondition(cond, pattern = "^muffle")
[13:21:55.974]                   }
[13:21:55.974]                 }
[13:21:55.974]                 else {
[13:21:55.974]                   if (TRUE) {
[13:21:55.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:55.974]                     {
[13:21:55.974]                       inherits <- base::inherits
[13:21:55.974]                       invokeRestart <- base::invokeRestart
[13:21:55.974]                       is.null <- base::is.null
[13:21:55.974]                       muffled <- FALSE
[13:21:55.974]                       if (inherits(cond, "message")) {
[13:21:55.974]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:55.974]                         if (muffled) 
[13:21:55.974]                           invokeRestart("muffleMessage")
[13:21:55.974]                       }
[13:21:55.974]                       else if (inherits(cond, "warning")) {
[13:21:55.974]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:55.974]                         if (muffled) 
[13:21:55.974]                           invokeRestart("muffleWarning")
[13:21:55.974]                       }
[13:21:55.974]                       else if (inherits(cond, "condition")) {
[13:21:55.974]                         if (!is.null(pattern)) {
[13:21:55.974]                           computeRestarts <- base::computeRestarts
[13:21:55.974]                           grepl <- base::grepl
[13:21:55.974]                           restarts <- computeRestarts(cond)
[13:21:55.974]                           for (restart in restarts) {
[13:21:55.974]                             name <- restart$name
[13:21:55.974]                             if (is.null(name)) 
[13:21:55.974]                               next
[13:21:55.974]                             if (!grepl(pattern, name)) 
[13:21:55.974]                               next
[13:21:55.974]                             invokeRestart(restart)
[13:21:55.974]                             muffled <- TRUE
[13:21:55.974]                             break
[13:21:55.974]                           }
[13:21:55.974]                         }
[13:21:55.974]                       }
[13:21:55.974]                       invisible(muffled)
[13:21:55.974]                     }
[13:21:55.974]                     muffleCondition(cond, pattern = "^muffle")
[13:21:55.974]                   }
[13:21:55.974]                 }
[13:21:55.974]             }
[13:21:55.974]         }))
[13:21:55.974]     }, error = function(ex) {
[13:21:55.974]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:55.974]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:55.974]                 ...future.rng), started = ...future.startTime, 
[13:21:55.974]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:55.974]             version = "1.8"), class = "FutureResult")
[13:21:55.974]     }, finally = {
[13:21:55.974]         if (!identical(...future.workdir, getwd())) 
[13:21:55.974]             setwd(...future.workdir)
[13:21:55.974]         {
[13:21:55.974]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:55.974]                 ...future.oldOptions$nwarnings <- NULL
[13:21:55.974]             }
[13:21:55.974]             base::options(...future.oldOptions)
[13:21:55.974]             if (.Platform$OS.type == "windows") {
[13:21:55.974]                 old_names <- names(...future.oldEnvVars)
[13:21:55.974]                 envs <- base::Sys.getenv()
[13:21:55.974]                 names <- names(envs)
[13:21:55.974]                 common <- intersect(names, old_names)
[13:21:55.974]                 added <- setdiff(names, old_names)
[13:21:55.974]                 removed <- setdiff(old_names, names)
[13:21:55.974]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:55.974]                   envs[common]]
[13:21:55.974]                 NAMES <- toupper(changed)
[13:21:55.974]                 args <- list()
[13:21:55.974]                 for (kk in seq_along(NAMES)) {
[13:21:55.974]                   name <- changed[[kk]]
[13:21:55.974]                   NAME <- NAMES[[kk]]
[13:21:55.974]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:55.974]                     next
[13:21:55.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:55.974]                 }
[13:21:55.974]                 NAMES <- toupper(added)
[13:21:55.974]                 for (kk in seq_along(NAMES)) {
[13:21:55.974]                   name <- added[[kk]]
[13:21:55.974]                   NAME <- NAMES[[kk]]
[13:21:55.974]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:55.974]                     next
[13:21:55.974]                   args[[name]] <- ""
[13:21:55.974]                 }
[13:21:55.974]                 NAMES <- toupper(removed)
[13:21:55.974]                 for (kk in seq_along(NAMES)) {
[13:21:55.974]                   name <- removed[[kk]]
[13:21:55.974]                   NAME <- NAMES[[kk]]
[13:21:55.974]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:55.974]                     next
[13:21:55.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:55.974]                 }
[13:21:55.974]                 if (length(args) > 0) 
[13:21:55.974]                   base::do.call(base::Sys.setenv, args = args)
[13:21:55.974]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:55.974]             }
[13:21:55.974]             else {
[13:21:55.974]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:55.974]             }
[13:21:55.974]             {
[13:21:55.974]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:55.974]                   0L) {
[13:21:55.974]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:55.974]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:55.974]                   base::options(opts)
[13:21:55.974]                 }
[13:21:55.974]                 {
[13:21:55.974]                   {
[13:21:55.974]                     NULL
[13:21:55.974]                     RNGkind("Mersenne-Twister")
[13:21:55.974]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:55.974]                       inherits = FALSE)
[13:21:55.974]                   }
[13:21:55.974]                   options(future.plan = NULL)
[13:21:55.974]                   if (is.na(NA_character_)) 
[13:21:55.974]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:55.974]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:55.974]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:55.974]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:55.974]                     envir = parent.frame()) 
[13:21:55.974]                   {
[13:21:55.974]                     if (is.function(workers)) 
[13:21:55.974]                       workers <- workers()
[13:21:55.974]                     workers <- structure(as.integer(workers), 
[13:21:55.974]                       class = class(workers))
[13:21:55.974]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:55.974]                       workers >= 1)
[13:21:55.974]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:55.974]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:55.974]                     }
[13:21:55.974]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:55.974]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:55.974]                       envir = envir)
[13:21:55.974]                     if (!future$lazy) 
[13:21:55.974]                       future <- run(future)
[13:21:55.974]                     invisible(future)
[13:21:55.974]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:55.974]                 }
[13:21:55.974]             }
[13:21:55.974]         }
[13:21:55.974]     })
[13:21:55.974]     if (TRUE) {
[13:21:55.974]         base::sink(type = "output", split = FALSE)
[13:21:55.974]         if (FALSE) {
[13:21:55.974]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:55.974]         }
[13:21:55.974]         else {
[13:21:55.974]             ...future.result["stdout"] <- base::list(NULL)
[13:21:55.974]         }
[13:21:55.974]         base::close(...future.stdout)
[13:21:55.974]         ...future.stdout <- NULL
[13:21:55.974]     }
[13:21:55.974]     ...future.result$conditions <- ...future.conditions
[13:21:55.974]     ...future.result$finished <- base::Sys.time()
[13:21:55.974]     ...future.result
[13:21:55.974] }
[13:21:55.975] assign_globals() ...
[13:21:55.976] List of 5
[13:21:55.976]  $ ...future.FUN            :function (x, y)  
[13:21:55.976]  $ MoreArgs                 : NULL
[13:21:55.976]  $ ...future.elements_ii    :List of 2
[13:21:55.976]   ..$ :List of 2
[13:21:55.976]   .. ..$ : int 1
[13:21:55.976]   .. ..$ : int 0
[13:21:55.976]   ..$ :List of 2
[13:21:55.976]   .. ..$ : int 0
[13:21:55.976]   .. ..$ : int 1
[13:21:55.976]  $ ...future.seeds_ii       : NULL
[13:21:55.976]  $ ...future.globals.maxSize: NULL
[13:21:55.976]  - attr(*, "where")=List of 5
[13:21:55.976]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:55.976]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:21:55.976]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:55.976]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:55.976]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:55.976]  - attr(*, "resolved")= logi FALSE
[13:21:55.976]  - attr(*, "total_size")= num 6480
[13:21:55.976]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:55.976]  - attr(*, "already-done")= logi TRUE
[13:21:55.981] - reassign environment for ‘...future.FUN’
[13:21:55.981] - copied ‘...future.FUN’ to environment
[13:21:55.982] - copied ‘MoreArgs’ to environment
[13:21:55.982] - copied ‘...future.elements_ii’ to environment
[13:21:55.982] - copied ‘...future.seeds_ii’ to environment
[13:21:55.982] - copied ‘...future.globals.maxSize’ to environment
[13:21:55.982] assign_globals() ... done
[13:21:55.982] plan(): Setting new future strategy stack:
[13:21:55.982] List of future strategies:
[13:21:55.982] 1. sequential:
[13:21:55.982]    - args: function (..., envir = parent.frame())
[13:21:55.982]    - tweaked: FALSE
[13:21:55.982]    - call: NULL
[13:21:55.983] plan(): nbrOfWorkers() = 1
[13:21:56.484] plan(): Setting new future strategy stack:
[13:21:56.485] List of future strategies:
[13:21:56.485] 1. multisession:
[13:21:56.485]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:21:56.485]    - tweaked: FALSE
[13:21:56.485]    - call: plan(strategy)
[13:21:56.489] plan(): nbrOfWorkers() = 1
[13:21:56.489] SequentialFuture started (and completed)
[13:21:56.489] - Launch lazy future ... done
[13:21:56.489] run() for ‘SequentialFuture’ ... done
[13:21:56.489] Created future:
[13:21:56.489] SequentialFuture:
[13:21:56.489] Label: ‘future_mapply-1’
[13:21:56.489] Expression:
[13:21:56.489] {
[13:21:56.489]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:56.489]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:56.489]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:56.489]         on.exit(options(oopts), add = TRUE)
[13:21:56.489]     }
[13:21:56.489]     {
[13:21:56.489]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:21:56.489]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:21:56.489]         do.call(mapply, args = args)
[13:21:56.489]     }
[13:21:56.489] }
[13:21:56.489] Lazy evaluation: FALSE
[13:21:56.489] Asynchronous evaluation: FALSE
[13:21:56.489] Local evaluation: TRUE
[13:21:56.489] Environment: R_GlobalEnv
[13:21:56.489] Capture standard output: FALSE
[13:21:56.489] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:56.489] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:56.489] Packages: <none>
[13:21:56.489] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:56.489] Resolved: TRUE
[13:21:56.489] Value: 224 bytes of class ‘list’
[13:21:56.489] Early signaling: FALSE
[13:21:56.489] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:21:56.489] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:56.490] Chunk #1 of 1 ... DONE
[13:21:56.490] Launching 1 futures (chunks) ... DONE
[13:21:56.490] Resolving 1 futures (chunks) ...
[13:21:56.491] resolve() on list ...
[13:21:56.491]  recursive: 0
[13:21:56.491]  length: 1
[13:21:56.491] 
[13:21:56.491] resolved() for ‘SequentialFuture’ ...
[13:21:56.491] - state: ‘finished’
[13:21:56.491] - run: TRUE
[13:21:56.491] - result: ‘FutureResult’
[13:21:56.491] resolved() for ‘SequentialFuture’ ... done
[13:21:56.491] Future #1
[13:21:56.492] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:56.492] - nx: 1
[13:21:56.492] - relay: TRUE
[13:21:56.492] - stdout: TRUE
[13:21:56.492] - signal: TRUE
[13:21:56.492] - resignal: FALSE
[13:21:56.492] - force: TRUE
[13:21:56.492] - relayed: [n=1] FALSE
[13:21:56.492] - queued futures: [n=1] FALSE
[13:21:56.492]  - until=1
[13:21:56.493]  - relaying element #1
[13:21:56.493] - relayed: [n=1] TRUE
[13:21:56.493] - queued futures: [n=1] TRUE
[13:21:56.493] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:56.493]  length: 0 (resolved future 1)
[13:21:56.493] Relaying remaining futures
[13:21:56.493] signalConditionsASAP(NULL, pos=0) ...
[13:21:56.493] - nx: 1
[13:21:56.493] - relay: TRUE
[13:21:56.493] - stdout: TRUE
[13:21:56.493] - signal: TRUE
[13:21:56.494] - resignal: FALSE
[13:21:56.494] - force: TRUE
[13:21:56.494] - relayed: [n=1] TRUE
[13:21:56.494] - queued futures: [n=1] TRUE
 - flush all
[13:21:56.494] - relayed: [n=1] TRUE
[13:21:56.494] - queued futures: [n=1] TRUE
[13:21:56.494] signalConditionsASAP(NULL, pos=0) ... done
[13:21:56.494] resolve() on list ... DONE
[13:21:56.494]  - Number of value chunks collected: 1
[13:21:56.494] Resolving 1 futures (chunks) ... DONE
[13:21:56.495] Reducing values from 1 chunks ...
[13:21:56.495]  - Number of values collected after concatenation: 2
[13:21:56.495]  - Number of values expected: 2
[13:21:56.495] Reducing values from 1 chunks ... DONE
[13:21:56.495] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[13:21:56.495] future_mapply() ...
[13:21:56.500] Number of chunks: 1
[13:21:56.500] getGlobalsAndPackagesXApply() ...
[13:21:56.500]  - future.globals: TRUE
[13:21:56.501] getGlobalsAndPackages() ...
[13:21:56.501] Searching for globals...
[13:21:56.502] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:21:56.503] Searching for globals ... DONE
[13:21:56.503] Resolving globals: FALSE
[13:21:56.503] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:21:56.504] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:21:56.504] - globals: [1] ‘FUN’
[13:21:56.504] 
[13:21:56.504] getGlobalsAndPackages() ... DONE
[13:21:56.504]  - globals found/used: [n=1] ‘FUN’
[13:21:56.504]  - needed namespaces: [n=0] 
[13:21:56.504] Finding globals ... DONE
[13:21:56.504] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:21:56.504] List of 2
[13:21:56.504]  $ ...future.FUN:function (x, y)  
[13:21:56.504]  $ MoreArgs     : NULL
[13:21:56.504]  - attr(*, "where")=List of 2
[13:21:56.504]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:56.504]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:21:56.504]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:56.504]  - attr(*, "resolved")= logi FALSE
[13:21:56.504]  - attr(*, "total_size")= num NA
[13:21:56.507] Packages to be attached in all futures: [n=0] 
[13:21:56.507] getGlobalsAndPackagesXApply() ... DONE
[13:21:56.507] Number of futures (= number of chunks): 1
[13:21:56.507] Launching 1 futures (chunks) ...
[13:21:56.507] Chunk #1 of 1 ...
[13:21:56.508]  - Finding globals in '...' for chunk #1 ...
[13:21:56.508] getGlobalsAndPackages() ...
[13:21:56.508] Searching for globals...
[13:21:56.508] 
[13:21:56.508] Searching for globals ... DONE
[13:21:56.508] - globals: [0] <none>
[13:21:56.508] getGlobalsAndPackages() ... DONE
[13:21:56.508]    + additional globals found: [n=0] 
[13:21:56.509]    + additional namespaces needed: [n=0] 
[13:21:56.509]  - Finding globals in '...' for chunk #1 ... DONE
[13:21:56.509]  - seeds: <none>
[13:21:56.509]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:56.509] getGlobalsAndPackages() ...
[13:21:56.509] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:56.509] Resolving globals: FALSE
[13:21:56.510] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[13:21:56.510] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:21:56.510] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:56.510] 
[13:21:56.510] getGlobalsAndPackages() ... DONE
[13:21:56.511] run() for ‘Future’ ...
[13:21:56.511] - state: ‘created’
[13:21:56.511] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:56.515] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:56.515] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:56.515]   - Field: ‘label’
[13:21:56.515]   - Field: ‘local’
[13:21:56.515]   - Field: ‘owner’
[13:21:56.515]   - Field: ‘envir’
[13:21:56.516]   - Field: ‘packages’
[13:21:56.516]   - Field: ‘gc’
[13:21:56.516]   - Field: ‘conditions’
[13:21:56.516]   - Field: ‘expr’
[13:21:56.516]   - Field: ‘uuid’
[13:21:56.516]   - Field: ‘seed’
[13:21:56.516]   - Field: ‘version’
[13:21:56.516]   - Field: ‘result’
[13:21:56.516]   - Field: ‘asynchronous’
[13:21:56.517]   - Field: ‘calls’
[13:21:56.517]   - Field: ‘globals’
[13:21:56.517]   - Field: ‘stdout’
[13:21:56.517]   - Field: ‘earlySignal’
[13:21:56.517]   - Field: ‘lazy’
[13:21:56.517]   - Field: ‘state’
[13:21:56.517] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:56.517] - Launch lazy future ...
[13:21:56.517] Packages needed by the future expression (n = 0): <none>
[13:21:56.518] Packages needed by future strategies (n = 0): <none>
[13:21:56.518] {
[13:21:56.518]     {
[13:21:56.518]         {
[13:21:56.518]             ...future.startTime <- base::Sys.time()
[13:21:56.518]             {
[13:21:56.518]                 {
[13:21:56.518]                   {
[13:21:56.518]                     base::local({
[13:21:56.518]                       has_future <- base::requireNamespace("future", 
[13:21:56.518]                         quietly = TRUE)
[13:21:56.518]                       if (has_future) {
[13:21:56.518]                         ns <- base::getNamespace("future")
[13:21:56.518]                         version <- ns[[".package"]][["version"]]
[13:21:56.518]                         if (is.null(version)) 
[13:21:56.518]                           version <- utils::packageVersion("future")
[13:21:56.518]                       }
[13:21:56.518]                       else {
[13:21:56.518]                         version <- NULL
[13:21:56.518]                       }
[13:21:56.518]                       if (!has_future || version < "1.8.0") {
[13:21:56.518]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:56.518]                           "", base::R.version$version.string), 
[13:21:56.518]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:56.518]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:56.518]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:56.518]                             "release", "version")], collapse = " "), 
[13:21:56.518]                           hostname = base::Sys.info()[["nodename"]])
[13:21:56.518]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:56.518]                           info)
[13:21:56.518]                         info <- base::paste(info, collapse = "; ")
[13:21:56.518]                         if (!has_future) {
[13:21:56.518]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:56.518]                             info)
[13:21:56.518]                         }
[13:21:56.518]                         else {
[13:21:56.518]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:56.518]                             info, version)
[13:21:56.518]                         }
[13:21:56.518]                         base::stop(msg)
[13:21:56.518]                       }
[13:21:56.518]                     })
[13:21:56.518]                   }
[13:21:56.518]                   options(future.plan = NULL)
[13:21:56.518]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:56.518]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:56.518]                 }
[13:21:56.518]                 ...future.workdir <- getwd()
[13:21:56.518]             }
[13:21:56.518]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:56.518]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:56.518]         }
[13:21:56.518]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:56.518]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:56.518]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:56.518]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:56.518]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:56.518]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:56.518]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:56.518]             base::names(...future.oldOptions))
[13:21:56.518]     }
[13:21:56.518]     if (FALSE) {
[13:21:56.518]     }
[13:21:56.518]     else {
[13:21:56.518]         if (TRUE) {
[13:21:56.518]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:56.518]                 open = "w")
[13:21:56.518]         }
[13:21:56.518]         else {
[13:21:56.518]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:56.518]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:56.518]         }
[13:21:56.518]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:56.518]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:56.518]             base::sink(type = "output", split = FALSE)
[13:21:56.518]             base::close(...future.stdout)
[13:21:56.518]         }, add = TRUE)
[13:21:56.518]     }
[13:21:56.518]     ...future.frame <- base::sys.nframe()
[13:21:56.518]     ...future.conditions <- base::list()
[13:21:56.518]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:56.518]     if (FALSE) {
[13:21:56.518]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:56.518]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:56.518]     }
[13:21:56.518]     ...future.result <- base::tryCatch({
[13:21:56.518]         base::withCallingHandlers({
[13:21:56.518]             ...future.value <- base::withVisible(base::local({
[13:21:56.518]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:56.518]                 if (!identical(...future.globals.maxSize.org, 
[13:21:56.518]                   ...future.globals.maxSize)) {
[13:21:56.518]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:56.518]                   on.exit(options(oopts), add = TRUE)
[13:21:56.518]                 }
[13:21:56.518]                 {
[13:21:56.518]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:21:56.518]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:21:56.518]                     USE.NAMES = FALSE)
[13:21:56.518]                   do.call(mapply, args = args)
[13:21:56.518]                 }
[13:21:56.518]             }))
[13:21:56.518]             future::FutureResult(value = ...future.value$value, 
[13:21:56.518]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:56.518]                   ...future.rng), globalenv = if (FALSE) 
[13:21:56.518]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:56.518]                     ...future.globalenv.names))
[13:21:56.518]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:56.518]         }, condition = base::local({
[13:21:56.518]             c <- base::c
[13:21:56.518]             inherits <- base::inherits
[13:21:56.518]             invokeRestart <- base::invokeRestart
[13:21:56.518]             length <- base::length
[13:21:56.518]             list <- base::list
[13:21:56.518]             seq.int <- base::seq.int
[13:21:56.518]             signalCondition <- base::signalCondition
[13:21:56.518]             sys.calls <- base::sys.calls
[13:21:56.518]             `[[` <- base::`[[`
[13:21:56.518]             `+` <- base::`+`
[13:21:56.518]             `<<-` <- base::`<<-`
[13:21:56.518]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:56.518]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:56.518]                   3L)]
[13:21:56.518]             }
[13:21:56.518]             function(cond) {
[13:21:56.518]                 is_error <- inherits(cond, "error")
[13:21:56.518]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:56.518]                   NULL)
[13:21:56.518]                 if (is_error) {
[13:21:56.518]                   sessionInformation <- function() {
[13:21:56.518]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:56.518]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:56.518]                       search = base::search(), system = base::Sys.info())
[13:21:56.518]                   }
[13:21:56.518]                   ...future.conditions[[length(...future.conditions) + 
[13:21:56.518]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:56.518]                     cond$call), session = sessionInformation(), 
[13:21:56.518]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:56.518]                   signalCondition(cond)
[13:21:56.518]                 }
[13:21:56.518]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:56.518]                 "immediateCondition"))) {
[13:21:56.518]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:56.518]                   ...future.conditions[[length(...future.conditions) + 
[13:21:56.518]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:56.518]                   if (TRUE && !signal) {
[13:21:56.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:56.518]                     {
[13:21:56.518]                       inherits <- base::inherits
[13:21:56.518]                       invokeRestart <- base::invokeRestart
[13:21:56.518]                       is.null <- base::is.null
[13:21:56.518]                       muffled <- FALSE
[13:21:56.518]                       if (inherits(cond, "message")) {
[13:21:56.518]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:56.518]                         if (muffled) 
[13:21:56.518]                           invokeRestart("muffleMessage")
[13:21:56.518]                       }
[13:21:56.518]                       else if (inherits(cond, "warning")) {
[13:21:56.518]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:56.518]                         if (muffled) 
[13:21:56.518]                           invokeRestart("muffleWarning")
[13:21:56.518]                       }
[13:21:56.518]                       else if (inherits(cond, "condition")) {
[13:21:56.518]                         if (!is.null(pattern)) {
[13:21:56.518]                           computeRestarts <- base::computeRestarts
[13:21:56.518]                           grepl <- base::grepl
[13:21:56.518]                           restarts <- computeRestarts(cond)
[13:21:56.518]                           for (restart in restarts) {
[13:21:56.518]                             name <- restart$name
[13:21:56.518]                             if (is.null(name)) 
[13:21:56.518]                               next
[13:21:56.518]                             if (!grepl(pattern, name)) 
[13:21:56.518]                               next
[13:21:56.518]                             invokeRestart(restart)
[13:21:56.518]                             muffled <- TRUE
[13:21:56.518]                             break
[13:21:56.518]                           }
[13:21:56.518]                         }
[13:21:56.518]                       }
[13:21:56.518]                       invisible(muffled)
[13:21:56.518]                     }
[13:21:56.518]                     muffleCondition(cond, pattern = "^muffle")
[13:21:56.518]                   }
[13:21:56.518]                 }
[13:21:56.518]                 else {
[13:21:56.518]                   if (TRUE) {
[13:21:56.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:56.518]                     {
[13:21:56.518]                       inherits <- base::inherits
[13:21:56.518]                       invokeRestart <- base::invokeRestart
[13:21:56.518]                       is.null <- base::is.null
[13:21:56.518]                       muffled <- FALSE
[13:21:56.518]                       if (inherits(cond, "message")) {
[13:21:56.518]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:56.518]                         if (muffled) 
[13:21:56.518]                           invokeRestart("muffleMessage")
[13:21:56.518]                       }
[13:21:56.518]                       else if (inherits(cond, "warning")) {
[13:21:56.518]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:56.518]                         if (muffled) 
[13:21:56.518]                           invokeRestart("muffleWarning")
[13:21:56.518]                       }
[13:21:56.518]                       else if (inherits(cond, "condition")) {
[13:21:56.518]                         if (!is.null(pattern)) {
[13:21:56.518]                           computeRestarts <- base::computeRestarts
[13:21:56.518]                           grepl <- base::grepl
[13:21:56.518]                           restarts <- computeRestarts(cond)
[13:21:56.518]                           for (restart in restarts) {
[13:21:56.518]                             name <- restart$name
[13:21:56.518]                             if (is.null(name)) 
[13:21:56.518]                               next
[13:21:56.518]                             if (!grepl(pattern, name)) 
[13:21:56.518]                               next
[13:21:56.518]                             invokeRestart(restart)
[13:21:56.518]                             muffled <- TRUE
[13:21:56.518]                             break
[13:21:56.518]                           }
[13:21:56.518]                         }
[13:21:56.518]                       }
[13:21:56.518]                       invisible(muffled)
[13:21:56.518]                     }
[13:21:56.518]                     muffleCondition(cond, pattern = "^muffle")
[13:21:56.518]                   }
[13:21:56.518]                 }
[13:21:56.518]             }
[13:21:56.518]         }))
[13:21:56.518]     }, error = function(ex) {
[13:21:56.518]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:56.518]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:56.518]                 ...future.rng), started = ...future.startTime, 
[13:21:56.518]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:56.518]             version = "1.8"), class = "FutureResult")
[13:21:56.518]     }, finally = {
[13:21:56.518]         if (!identical(...future.workdir, getwd())) 
[13:21:56.518]             setwd(...future.workdir)
[13:21:56.518]         {
[13:21:56.518]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:56.518]                 ...future.oldOptions$nwarnings <- NULL
[13:21:56.518]             }
[13:21:56.518]             base::options(...future.oldOptions)
[13:21:56.518]             if (.Platform$OS.type == "windows") {
[13:21:56.518]                 old_names <- names(...future.oldEnvVars)
[13:21:56.518]                 envs <- base::Sys.getenv()
[13:21:56.518]                 names <- names(envs)
[13:21:56.518]                 common <- intersect(names, old_names)
[13:21:56.518]                 added <- setdiff(names, old_names)
[13:21:56.518]                 removed <- setdiff(old_names, names)
[13:21:56.518]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:56.518]                   envs[common]]
[13:21:56.518]                 NAMES <- toupper(changed)
[13:21:56.518]                 args <- list()
[13:21:56.518]                 for (kk in seq_along(NAMES)) {
[13:21:56.518]                   name <- changed[[kk]]
[13:21:56.518]                   NAME <- NAMES[[kk]]
[13:21:56.518]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:56.518]                     next
[13:21:56.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:56.518]                 }
[13:21:56.518]                 NAMES <- toupper(added)
[13:21:56.518]                 for (kk in seq_along(NAMES)) {
[13:21:56.518]                   name <- added[[kk]]
[13:21:56.518]                   NAME <- NAMES[[kk]]
[13:21:56.518]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:56.518]                     next
[13:21:56.518]                   args[[name]] <- ""
[13:21:56.518]                 }
[13:21:56.518]                 NAMES <- toupper(removed)
[13:21:56.518]                 for (kk in seq_along(NAMES)) {
[13:21:56.518]                   name <- removed[[kk]]
[13:21:56.518]                   NAME <- NAMES[[kk]]
[13:21:56.518]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:56.518]                     next
[13:21:56.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:56.518]                 }
[13:21:56.518]                 if (length(args) > 0) 
[13:21:56.518]                   base::do.call(base::Sys.setenv, args = args)
[13:21:56.518]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:56.518]             }
[13:21:56.518]             else {
[13:21:56.518]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:56.518]             }
[13:21:56.518]             {
[13:21:56.518]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:56.518]                   0L) {
[13:21:56.518]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:56.518]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:56.518]                   base::options(opts)
[13:21:56.518]                 }
[13:21:56.518]                 {
[13:21:56.518]                   {
[13:21:56.518]                     NULL
[13:21:56.518]                     RNGkind("Mersenne-Twister")
[13:21:56.518]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:56.518]                       inherits = FALSE)
[13:21:56.518]                   }
[13:21:56.518]                   options(future.plan = NULL)
[13:21:56.518]                   if (is.na(NA_character_)) 
[13:21:56.518]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:56.518]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:56.518]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:56.518]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:56.518]                     envir = parent.frame()) 
[13:21:56.518]                   {
[13:21:56.518]                     if (is.function(workers)) 
[13:21:56.518]                       workers <- workers()
[13:21:56.518]                     workers <- structure(as.integer(workers), 
[13:21:56.518]                       class = class(workers))
[13:21:56.518]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:56.518]                       workers >= 1)
[13:21:56.518]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:56.518]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:56.518]                     }
[13:21:56.518]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:56.518]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:56.518]                       envir = envir)
[13:21:56.518]                     if (!future$lazy) 
[13:21:56.518]                       future <- run(future)
[13:21:56.518]                     invisible(future)
[13:21:56.518]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:56.518]                 }
[13:21:56.518]             }
[13:21:56.518]         }
[13:21:56.518]     })
[13:21:56.518]     if (TRUE) {
[13:21:56.518]         base::sink(type = "output", split = FALSE)
[13:21:56.518]         if (TRUE) {
[13:21:56.518]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:56.518]         }
[13:21:56.518]         else {
[13:21:56.518]             ...future.result["stdout"] <- base::list(NULL)
[13:21:56.518]         }
[13:21:56.518]         base::close(...future.stdout)
[13:21:56.518]         ...future.stdout <- NULL
[13:21:56.518]     }
[13:21:56.518]     ...future.result$conditions <- ...future.conditions
[13:21:56.518]     ...future.result$finished <- base::Sys.time()
[13:21:56.518]     ...future.result
[13:21:56.518] }
[13:21:56.520] assign_globals() ...
[13:21:56.520] List of 5
[13:21:56.520]  $ ...future.FUN            :function (x, y)  
[13:21:56.520]  $ MoreArgs                 : NULL
[13:21:56.520]  $ ...future.elements_ii    :List of 2
[13:21:56.520]   ..$ :List of 2
[13:21:56.520]   .. ..$ : int 1
[13:21:56.520]   .. ..$ : int 0
[13:21:56.520]   ..$ :List of 2
[13:21:56.520]   .. ..$ : int 0
[13:21:56.520]   .. ..$ : int 1
[13:21:56.520]  $ ...future.seeds_ii       : NULL
[13:21:56.520]  $ ...future.globals.maxSize: NULL
[13:21:56.520]  - attr(*, "where")=List of 5
[13:21:56.520]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:56.520]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:21:56.520]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:56.520]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:56.520]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:56.520]  - attr(*, "resolved")= logi FALSE
[13:21:56.520]  - attr(*, "total_size")= num 6480
[13:21:56.520]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:56.520]  - attr(*, "already-done")= logi TRUE
[13:21:56.526] - reassign environment for ‘...future.FUN’
[13:21:56.526] - copied ‘...future.FUN’ to environment
[13:21:56.526] - copied ‘MoreArgs’ to environment
[13:21:56.526] - copied ‘...future.elements_ii’ to environment
[13:21:56.526] - copied ‘...future.seeds_ii’ to environment
[13:21:56.526] - copied ‘...future.globals.maxSize’ to environment
[13:21:56.526] assign_globals() ... done
[13:21:56.527] plan(): Setting new future strategy stack:
[13:21:56.527] List of future strategies:
[13:21:56.527] 1. sequential:
[13:21:56.527]    - args: function (..., envir = parent.frame())
[13:21:56.527]    - tweaked: FALSE
[13:21:56.527]    - call: NULL
[13:21:56.527] plan(): nbrOfWorkers() = 1
[13:21:57.029] plan(): Setting new future strategy stack:
[13:21:57.029] List of future strategies:
[13:21:57.029] 1. multisession:
[13:21:57.029]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:21:57.029]    - tweaked: FALSE
[13:21:57.029]    - call: plan(strategy)
[13:21:57.035] plan(): nbrOfWorkers() = 1
[13:21:57.035] SequentialFuture started (and completed)
[13:21:57.035] - Launch lazy future ... done
[13:21:57.035] run() for ‘SequentialFuture’ ... done
[13:21:57.035] Created future:
[13:21:57.036] SequentialFuture:
[13:21:57.036] Label: ‘future_mapply-1’
[13:21:57.036] Expression:
[13:21:57.036] {
[13:21:57.036]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:57.036]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:57.036]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:57.036]         on.exit(options(oopts), add = TRUE)
[13:21:57.036]     }
[13:21:57.036]     {
[13:21:57.036]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:21:57.036]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:21:57.036]         do.call(mapply, args = args)
[13:21:57.036]     }
[13:21:57.036] }
[13:21:57.036] Lazy evaluation: FALSE
[13:21:57.036] Asynchronous evaluation: FALSE
[13:21:57.036] Local evaluation: TRUE
[13:21:57.036] Environment: R_GlobalEnv
[13:21:57.036] Capture standard output: TRUE
[13:21:57.036] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:57.036] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:57.036] Packages: <none>
[13:21:57.036] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:57.036] Resolved: TRUE
[13:21:57.036] Value: 224 bytes of class ‘list’
[13:21:57.036] Early signaling: FALSE
[13:21:57.036] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:21:57.036] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:57.037] Chunk #1 of 1 ... DONE
[13:21:57.037] Launching 1 futures (chunks) ... DONE
[13:21:57.037] Resolving 1 futures (chunks) ...
[13:21:57.037] resolve() on list ...
[13:21:57.037]  recursive: 0
[13:21:57.037]  length: 1
[13:21:57.037] 
[13:21:57.037] resolved() for ‘SequentialFuture’ ...
[13:21:57.038] - state: ‘finished’
[13:21:57.038] - run: TRUE
[13:21:57.038] - result: ‘FutureResult’
[13:21:57.038] resolved() for ‘SequentialFuture’ ... done
[13:21:57.038] Future #1
[13:21:57.038] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:57.038] - nx: 1
[13:21:57.038] - relay: TRUE
[13:21:57.038] - stdout: TRUE
[13:21:57.038] - signal: TRUE
[13:21:57.038] - resignal: FALSE
[13:21:57.039] - force: TRUE
[13:21:57.039] - relayed: [n=1] FALSE
[13:21:57.039] - queued futures: [n=1] FALSE
[13:21:57.039]  - until=1
[13:21:57.039]  - relaying element #1
[13:21:57.039] - relayed: [n=1] TRUE
[13:21:57.039] - queued futures: [n=1] TRUE
[13:21:57.039] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:57.039]  length: 0 (resolved future 1)
[13:21:57.040] Relaying remaining futures
[13:21:57.040] signalConditionsASAP(NULL, pos=0) ...
[13:21:57.040] - nx: 1
[13:21:57.040] - relay: TRUE
[13:21:57.040] - stdout: TRUE
[13:21:57.040] - signal: TRUE
[13:21:57.040] - resignal: FALSE
[13:21:57.040] - force: TRUE
[13:21:57.040] - relayed: [n=1] TRUE
[13:21:57.040] - queued futures: [n=1] TRUE
 - flush all
[13:21:57.040] - relayed: [n=1] TRUE
[13:21:57.041] - queued futures: [n=1] TRUE
[13:21:57.041] signalConditionsASAP(NULL, pos=0) ... done
[13:21:57.041] resolve() on list ... DONE
[13:21:57.041]  - Number of value chunks collected: 1
[13:21:57.041] Resolving 1 futures (chunks) ... DONE
[13:21:57.041] Reducing values from 1 chunks ...
[13:21:57.041]  - Number of values collected after concatenation: 2
[13:21:57.041]  - Number of values expected: 2
[13:21:57.041] Reducing values from 1 chunks ... DONE
[13:21:57.041] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[13:21:57.042] future_mapply() ...
[13:21:57.045] Number of chunks: 1
[13:21:57.045] getGlobalsAndPackagesXApply() ...
[13:21:57.045]  - future.globals: TRUE
[13:21:57.045] getGlobalsAndPackages() ...
[13:21:57.045] Searching for globals...
[13:21:57.047] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:21:57.047] Searching for globals ... DONE
[13:21:57.047] Resolving globals: FALSE
[13:21:57.048] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:21:57.048] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:21:57.048] - globals: [1] ‘FUN’
[13:21:57.048] 
[13:21:57.048] getGlobalsAndPackages() ... DONE
[13:21:57.048]  - globals found/used: [n=1] ‘FUN’
[13:21:57.049]  - needed namespaces: [n=0] 
[13:21:57.049] Finding globals ... DONE
[13:21:57.049] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:21:57.049] List of 2
[13:21:57.049]  $ ...future.FUN:function (x, y)  
[13:21:57.049]  $ MoreArgs     : NULL
[13:21:57.049]  - attr(*, "where")=List of 2
[13:21:57.049]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:57.049]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:21:57.049]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:57.049]  - attr(*, "resolved")= logi FALSE
[13:21:57.049]  - attr(*, "total_size")= num NA
[13:21:57.051] Packages to be attached in all futures: [n=0] 
[13:21:57.052] getGlobalsAndPackagesXApply() ... DONE
[13:21:57.052] Number of futures (= number of chunks): 1
[13:21:57.052] Launching 1 futures (chunks) ...
[13:21:57.052] Chunk #1 of 1 ...
[13:21:57.052]  - Finding globals in '...' for chunk #1 ...
[13:21:57.052] getGlobalsAndPackages() ...
[13:21:57.052] Searching for globals...
[13:21:57.053] 
[13:21:57.053] Searching for globals ... DONE
[13:21:57.053] - globals: [0] <none>
[13:21:57.053] getGlobalsAndPackages() ... DONE
[13:21:57.053]    + additional globals found: [n=0] 
[13:21:57.053]    + additional namespaces needed: [n=0] 
[13:21:57.053]  - Finding globals in '...' for chunk #1 ... DONE
[13:21:57.053]  - seeds: <none>
[13:21:57.053]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:57.054] getGlobalsAndPackages() ...
[13:21:57.054] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:57.054] Resolving globals: FALSE
[13:21:57.054] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[13:21:57.055] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:21:57.055] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:57.055] 
[13:21:57.055] getGlobalsAndPackages() ... DONE
[13:21:57.055] run() for ‘Future’ ...
[13:21:57.055] - state: ‘created’
[13:21:57.056] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:57.059] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:57.059] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:57.059]   - Field: ‘label’
[13:21:57.060]   - Field: ‘local’
[13:21:57.060]   - Field: ‘owner’
[13:21:57.060]   - Field: ‘envir’
[13:21:57.060]   - Field: ‘packages’
[13:21:57.060]   - Field: ‘gc’
[13:21:57.060]   - Field: ‘conditions’
[13:21:57.060]   - Field: ‘expr’
[13:21:57.060]   - Field: ‘uuid’
[13:21:57.060]   - Field: ‘seed’
[13:21:57.061]   - Field: ‘version’
[13:21:57.061]   - Field: ‘result’
[13:21:57.061]   - Field: ‘asynchronous’
[13:21:57.061]   - Field: ‘calls’
[13:21:57.061]   - Field: ‘globals’
[13:21:57.061]   - Field: ‘stdout’
[13:21:57.061]   - Field: ‘earlySignal’
[13:21:57.061]   - Field: ‘lazy’
[13:21:57.061]   - Field: ‘state’
[13:21:57.061] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:57.061] - Launch lazy future ...
[13:21:57.062] Packages needed by the future expression (n = 0): <none>
[13:21:57.062] Packages needed by future strategies (n = 0): <none>
[13:21:57.062] {
[13:21:57.062]     {
[13:21:57.062]         {
[13:21:57.062]             ...future.startTime <- base::Sys.time()
[13:21:57.062]             {
[13:21:57.062]                 {
[13:21:57.062]                   {
[13:21:57.062]                     base::local({
[13:21:57.062]                       has_future <- base::requireNamespace("future", 
[13:21:57.062]                         quietly = TRUE)
[13:21:57.062]                       if (has_future) {
[13:21:57.062]                         ns <- base::getNamespace("future")
[13:21:57.062]                         version <- ns[[".package"]][["version"]]
[13:21:57.062]                         if (is.null(version)) 
[13:21:57.062]                           version <- utils::packageVersion("future")
[13:21:57.062]                       }
[13:21:57.062]                       else {
[13:21:57.062]                         version <- NULL
[13:21:57.062]                       }
[13:21:57.062]                       if (!has_future || version < "1.8.0") {
[13:21:57.062]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:57.062]                           "", base::R.version$version.string), 
[13:21:57.062]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:57.062]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:57.062]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:57.062]                             "release", "version")], collapse = " "), 
[13:21:57.062]                           hostname = base::Sys.info()[["nodename"]])
[13:21:57.062]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:57.062]                           info)
[13:21:57.062]                         info <- base::paste(info, collapse = "; ")
[13:21:57.062]                         if (!has_future) {
[13:21:57.062]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:57.062]                             info)
[13:21:57.062]                         }
[13:21:57.062]                         else {
[13:21:57.062]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:57.062]                             info, version)
[13:21:57.062]                         }
[13:21:57.062]                         base::stop(msg)
[13:21:57.062]                       }
[13:21:57.062]                     })
[13:21:57.062]                   }
[13:21:57.062]                   options(future.plan = NULL)
[13:21:57.062]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:57.062]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:57.062]                 }
[13:21:57.062]                 ...future.workdir <- getwd()
[13:21:57.062]             }
[13:21:57.062]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:57.062]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:57.062]         }
[13:21:57.062]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:57.062]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:57.062]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:57.062]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:57.062]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:57.062]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:57.062]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:57.062]             base::names(...future.oldOptions))
[13:21:57.062]     }
[13:21:57.062]     if (TRUE) {
[13:21:57.062]     }
[13:21:57.062]     else {
[13:21:57.062]         if (NA) {
[13:21:57.062]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:57.062]                 open = "w")
[13:21:57.062]         }
[13:21:57.062]         else {
[13:21:57.062]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:57.062]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:57.062]         }
[13:21:57.062]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:57.062]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:57.062]             base::sink(type = "output", split = FALSE)
[13:21:57.062]             base::close(...future.stdout)
[13:21:57.062]         }, add = TRUE)
[13:21:57.062]     }
[13:21:57.062]     ...future.frame <- base::sys.nframe()
[13:21:57.062]     ...future.conditions <- base::list()
[13:21:57.062]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:57.062]     if (FALSE) {
[13:21:57.062]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:57.062]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:57.062]     }
[13:21:57.062]     ...future.result <- base::tryCatch({
[13:21:57.062]         base::withCallingHandlers({
[13:21:57.062]             ...future.value <- base::withVisible(base::local({
[13:21:57.062]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:57.062]                 if (!identical(...future.globals.maxSize.org, 
[13:21:57.062]                   ...future.globals.maxSize)) {
[13:21:57.062]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:57.062]                   on.exit(options(oopts), add = TRUE)
[13:21:57.062]                 }
[13:21:57.062]                 {
[13:21:57.062]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:21:57.062]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:21:57.062]                     USE.NAMES = FALSE)
[13:21:57.062]                   do.call(mapply, args = args)
[13:21:57.062]                 }
[13:21:57.062]             }))
[13:21:57.062]             future::FutureResult(value = ...future.value$value, 
[13:21:57.062]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:57.062]                   ...future.rng), globalenv = if (FALSE) 
[13:21:57.062]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:57.062]                     ...future.globalenv.names))
[13:21:57.062]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:57.062]         }, condition = base::local({
[13:21:57.062]             c <- base::c
[13:21:57.062]             inherits <- base::inherits
[13:21:57.062]             invokeRestart <- base::invokeRestart
[13:21:57.062]             length <- base::length
[13:21:57.062]             list <- base::list
[13:21:57.062]             seq.int <- base::seq.int
[13:21:57.062]             signalCondition <- base::signalCondition
[13:21:57.062]             sys.calls <- base::sys.calls
[13:21:57.062]             `[[` <- base::`[[`
[13:21:57.062]             `+` <- base::`+`
[13:21:57.062]             `<<-` <- base::`<<-`
[13:21:57.062]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:57.062]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:57.062]                   3L)]
[13:21:57.062]             }
[13:21:57.062]             function(cond) {
[13:21:57.062]                 is_error <- inherits(cond, "error")
[13:21:57.062]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:57.062]                   NULL)
[13:21:57.062]                 if (is_error) {
[13:21:57.062]                   sessionInformation <- function() {
[13:21:57.062]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:57.062]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:57.062]                       search = base::search(), system = base::Sys.info())
[13:21:57.062]                   }
[13:21:57.062]                   ...future.conditions[[length(...future.conditions) + 
[13:21:57.062]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:57.062]                     cond$call), session = sessionInformation(), 
[13:21:57.062]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:57.062]                   signalCondition(cond)
[13:21:57.062]                 }
[13:21:57.062]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:57.062]                 "immediateCondition"))) {
[13:21:57.062]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:57.062]                   ...future.conditions[[length(...future.conditions) + 
[13:21:57.062]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:57.062]                   if (TRUE && !signal) {
[13:21:57.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:57.062]                     {
[13:21:57.062]                       inherits <- base::inherits
[13:21:57.062]                       invokeRestart <- base::invokeRestart
[13:21:57.062]                       is.null <- base::is.null
[13:21:57.062]                       muffled <- FALSE
[13:21:57.062]                       if (inherits(cond, "message")) {
[13:21:57.062]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:57.062]                         if (muffled) 
[13:21:57.062]                           invokeRestart("muffleMessage")
[13:21:57.062]                       }
[13:21:57.062]                       else if (inherits(cond, "warning")) {
[13:21:57.062]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:57.062]                         if (muffled) 
[13:21:57.062]                           invokeRestart("muffleWarning")
[13:21:57.062]                       }
[13:21:57.062]                       else if (inherits(cond, "condition")) {
[13:21:57.062]                         if (!is.null(pattern)) {
[13:21:57.062]                           computeRestarts <- base::computeRestarts
[13:21:57.062]                           grepl <- base::grepl
[13:21:57.062]                           restarts <- computeRestarts(cond)
[13:21:57.062]                           for (restart in restarts) {
[13:21:57.062]                             name <- restart$name
[13:21:57.062]                             if (is.null(name)) 
[13:21:57.062]                               next
[13:21:57.062]                             if (!grepl(pattern, name)) 
[13:21:57.062]                               next
[13:21:57.062]                             invokeRestart(restart)
[13:21:57.062]                             muffled <- TRUE
[13:21:57.062]                             break
[13:21:57.062]                           }
[13:21:57.062]                         }
[13:21:57.062]                       }
[13:21:57.062]                       invisible(muffled)
[13:21:57.062]                     }
[13:21:57.062]                     muffleCondition(cond, pattern = "^muffle")
[13:21:57.062]                   }
[13:21:57.062]                 }
[13:21:57.062]                 else {
[13:21:57.062]                   if (TRUE) {
[13:21:57.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:57.062]                     {
[13:21:57.062]                       inherits <- base::inherits
[13:21:57.062]                       invokeRestart <- base::invokeRestart
[13:21:57.062]                       is.null <- base::is.null
[13:21:57.062]                       muffled <- FALSE
[13:21:57.062]                       if (inherits(cond, "message")) {
[13:21:57.062]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:57.062]                         if (muffled) 
[13:21:57.062]                           invokeRestart("muffleMessage")
[13:21:57.062]                       }
[13:21:57.062]                       else if (inherits(cond, "warning")) {
[13:21:57.062]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:57.062]                         if (muffled) 
[13:21:57.062]                           invokeRestart("muffleWarning")
[13:21:57.062]                       }
[13:21:57.062]                       else if (inherits(cond, "condition")) {
[13:21:57.062]                         if (!is.null(pattern)) {
[13:21:57.062]                           computeRestarts <- base::computeRestarts
[13:21:57.062]                           grepl <- base::grepl
[13:21:57.062]                           restarts <- computeRestarts(cond)
[13:21:57.062]                           for (restart in restarts) {
[13:21:57.062]                             name <- restart$name
[13:21:57.062]                             if (is.null(name)) 
[13:21:57.062]                               next
[13:21:57.062]                             if (!grepl(pattern, name)) 
[13:21:57.062]                               next
[13:21:57.062]                             invokeRestart(restart)
[13:21:57.062]                             muffled <- TRUE
[13:21:57.062]                             break
[13:21:57.062]                           }
[13:21:57.062]                         }
[13:21:57.062]                       }
[13:21:57.062]                       invisible(muffled)
[13:21:57.062]                     }
[13:21:57.062]                     muffleCondition(cond, pattern = "^muffle")
[13:21:57.062]                   }
[13:21:57.062]                 }
[13:21:57.062]             }
[13:21:57.062]         }))
[13:21:57.062]     }, error = function(ex) {
[13:21:57.062]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:57.062]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:57.062]                 ...future.rng), started = ...future.startTime, 
[13:21:57.062]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:57.062]             version = "1.8"), class = "FutureResult")
[13:21:57.062]     }, finally = {
[13:21:57.062]         if (!identical(...future.workdir, getwd())) 
[13:21:57.062]             setwd(...future.workdir)
[13:21:57.062]         {
[13:21:57.062]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:57.062]                 ...future.oldOptions$nwarnings <- NULL
[13:21:57.062]             }
[13:21:57.062]             base::options(...future.oldOptions)
[13:21:57.062]             if (.Platform$OS.type == "windows") {
[13:21:57.062]                 old_names <- names(...future.oldEnvVars)
[13:21:57.062]                 envs <- base::Sys.getenv()
[13:21:57.062]                 names <- names(envs)
[13:21:57.062]                 common <- intersect(names, old_names)
[13:21:57.062]                 added <- setdiff(names, old_names)
[13:21:57.062]                 removed <- setdiff(old_names, names)
[13:21:57.062]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:57.062]                   envs[common]]
[13:21:57.062]                 NAMES <- toupper(changed)
[13:21:57.062]                 args <- list()
[13:21:57.062]                 for (kk in seq_along(NAMES)) {
[13:21:57.062]                   name <- changed[[kk]]
[13:21:57.062]                   NAME <- NAMES[[kk]]
[13:21:57.062]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:57.062]                     next
[13:21:57.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:57.062]                 }
[13:21:57.062]                 NAMES <- toupper(added)
[13:21:57.062]                 for (kk in seq_along(NAMES)) {
[13:21:57.062]                   name <- added[[kk]]
[13:21:57.062]                   NAME <- NAMES[[kk]]
[13:21:57.062]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:57.062]                     next
[13:21:57.062]                   args[[name]] <- ""
[13:21:57.062]                 }
[13:21:57.062]                 NAMES <- toupper(removed)
[13:21:57.062]                 for (kk in seq_along(NAMES)) {
[13:21:57.062]                   name <- removed[[kk]]
[13:21:57.062]                   NAME <- NAMES[[kk]]
[13:21:57.062]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:57.062]                     next
[13:21:57.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:57.062]                 }
[13:21:57.062]                 if (length(args) > 0) 
[13:21:57.062]                   base::do.call(base::Sys.setenv, args = args)
[13:21:57.062]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:57.062]             }
[13:21:57.062]             else {
[13:21:57.062]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:57.062]             }
[13:21:57.062]             {
[13:21:57.062]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:57.062]                   0L) {
[13:21:57.062]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:57.062]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:57.062]                   base::options(opts)
[13:21:57.062]                 }
[13:21:57.062]                 {
[13:21:57.062]                   {
[13:21:57.062]                     NULL
[13:21:57.062]                     RNGkind("Mersenne-Twister")
[13:21:57.062]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:57.062]                       inherits = FALSE)
[13:21:57.062]                   }
[13:21:57.062]                   options(future.plan = NULL)
[13:21:57.062]                   if (is.na(NA_character_)) 
[13:21:57.062]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:57.062]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:57.062]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:57.062]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:57.062]                     envir = parent.frame()) 
[13:21:57.062]                   {
[13:21:57.062]                     if (is.function(workers)) 
[13:21:57.062]                       workers <- workers()
[13:21:57.062]                     workers <- structure(as.integer(workers), 
[13:21:57.062]                       class = class(workers))
[13:21:57.062]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:57.062]                       workers >= 1)
[13:21:57.062]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:57.062]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:57.062]                     }
[13:21:57.062]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:57.062]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:57.062]                       envir = envir)
[13:21:57.062]                     if (!future$lazy) 
[13:21:57.062]                       future <- run(future)
[13:21:57.062]                     invisible(future)
[13:21:57.062]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:57.062]                 }
[13:21:57.062]             }
[13:21:57.062]         }
[13:21:57.062]     })
[13:21:57.062]     if (FALSE) {
[13:21:57.062]         base::sink(type = "output", split = FALSE)
[13:21:57.062]         if (NA) {
[13:21:57.062]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:57.062]         }
[13:21:57.062]         else {
[13:21:57.062]             ...future.result["stdout"] <- base::list(NULL)
[13:21:57.062]         }
[13:21:57.062]         base::close(...future.stdout)
[13:21:57.062]         ...future.stdout <- NULL
[13:21:57.062]     }
[13:21:57.062]     ...future.result$conditions <- ...future.conditions
[13:21:57.062]     ...future.result$finished <- base::Sys.time()
[13:21:57.062]     ...future.result
[13:21:57.062] }
[13:21:57.064] assign_globals() ...
[13:21:57.064] List of 5
[13:21:57.064]  $ ...future.FUN            :function (x, y)  
[13:21:57.064]  $ MoreArgs                 : NULL
[13:21:57.064]  $ ...future.elements_ii    :List of 2
[13:21:57.064]   ..$ :List of 2
[13:21:57.064]   .. ..$ : int 1
[13:21:57.064]   .. ..$ : int 0
[13:21:57.064]   ..$ :List of 2
[13:21:57.064]   .. ..$ : int 0
[13:21:57.064]   .. ..$ : int 1
[13:21:57.064]  $ ...future.seeds_ii       : NULL
[13:21:57.064]  $ ...future.globals.maxSize: NULL
[13:21:57.064]  - attr(*, "where")=List of 5
[13:21:57.064]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:57.064]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:21:57.064]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:57.064]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:57.064]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:57.064]  - attr(*, "resolved")= logi FALSE
[13:21:57.064]  - attr(*, "total_size")= num 6480
[13:21:57.064]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:57.064]  - attr(*, "already-done")= logi TRUE
[13:21:57.072] - reassign environment for ‘...future.FUN’
[13:21:57.072] - copied ‘...future.FUN’ to environment
[13:21:57.072] - copied ‘MoreArgs’ to environment
[13:21:57.072] - copied ‘...future.elements_ii’ to environment
[13:21:57.073] - copied ‘...future.seeds_ii’ to environment
[13:21:57.073] - copied ‘...future.globals.maxSize’ to environment
[13:21:57.073] assign_globals() ... done
[13:21:57.073] plan(): Setting new future strategy stack:
[13:21:57.073] List of future strategies:
[13:21:57.073] 1. sequential:
[13:21:57.073]    - args: function (..., envir = parent.frame())
[13:21:57.073]    - tweaked: FALSE
[13:21:57.073]    - call: NULL
[13:21:57.073] plan(): nbrOfWorkers() = 1
[13:21:57.575] plan(): Setting new future strategy stack:
[13:21:57.575] List of future strategies:
[13:21:57.575] 1. multisession:
[13:21:57.575]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:21:57.575]    - tweaked: FALSE
[13:21:57.575]    - call: plan(strategy)
[13:21:57.580] plan(): nbrOfWorkers() = 1
[13:21:57.580] SequentialFuture started (and completed)
[13:21:57.580] - Launch lazy future ... done
[13:21:57.580] run() for ‘SequentialFuture’ ... done
[13:21:57.580] Created future:
[13:21:57.580] SequentialFuture:
[13:21:57.580] Label: ‘future_mapply-1’
[13:21:57.580] Expression:
[13:21:57.580] {
[13:21:57.580]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:57.580]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:57.580]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:57.580]         on.exit(options(oopts), add = TRUE)
[13:21:57.580]     }
[13:21:57.580]     {
[13:21:57.580]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:21:57.580]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:21:57.580]         do.call(mapply, args = args)
[13:21:57.580]     }
[13:21:57.580] }
[13:21:57.580] Lazy evaluation: FALSE
[13:21:57.580] Asynchronous evaluation: FALSE
[13:21:57.580] Local evaluation: TRUE
[13:21:57.580] Environment: R_GlobalEnv
[13:21:57.580] Capture standard output: NA
[13:21:57.580] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:57.580] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:57.580] Packages: <none>
[13:21:57.580] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:57.580] Resolved: TRUE
[13:21:57.580] Value: 224 bytes of class ‘list’
[13:21:57.580] Early signaling: FALSE
[13:21:57.580] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:21:57.580] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:57.581] Chunk #1 of 1 ... DONE
[13:21:57.581] Launching 1 futures (chunks) ... DONE
[13:21:57.581] Resolving 1 futures (chunks) ...
[13:21:57.582] resolve() on list ...
[13:21:57.582]  recursive: 0
[13:21:57.582]  length: 1
[13:21:57.582] 
[13:21:57.582] resolved() for ‘SequentialFuture’ ...
[13:21:57.582] - state: ‘finished’
[13:21:57.582] - run: TRUE
[13:21:57.582] - result: ‘FutureResult’
[13:21:57.582] resolved() for ‘SequentialFuture’ ... done
[13:21:57.582] Future #1
[13:21:57.583] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:57.583] - nx: 1
[13:21:57.583] - relay: TRUE
[13:21:57.583] - stdout: TRUE
[13:21:57.583] - signal: TRUE
[13:21:57.583] - resignal: FALSE
[13:21:57.583] - force: TRUE
[13:21:57.583] - relayed: [n=1] FALSE
[13:21:57.583] - queued futures: [n=1] FALSE
[13:21:57.583]  - until=1
[13:21:57.583]  - relaying element #1
[13:21:57.584] - relayed: [n=1] TRUE
[13:21:57.584] - queued futures: [n=1] TRUE
[13:21:57.584] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:57.584]  length: 0 (resolved future 1)
[13:21:57.584] Relaying remaining futures
[13:21:57.584] signalConditionsASAP(NULL, pos=0) ...
[13:21:57.584] - nx: 1
[13:21:57.584] - relay: TRUE
[13:21:57.584] - stdout: TRUE
[13:21:57.584] - signal: TRUE
[13:21:57.585] - resignal: FALSE
[13:21:57.585] - force: TRUE
[13:21:57.585] - relayed: [n=1] TRUE
[13:21:57.585] - queued futures: [n=1] TRUE
 - flush all
[13:21:57.585] - relayed: [n=1] TRUE
[13:21:57.585] - queued futures: [n=1] TRUE
[13:21:57.585] signalConditionsASAP(NULL, pos=0) ... done
[13:21:57.585] resolve() on list ... DONE
[13:21:57.585]  - Number of value chunks collected: 1
[13:21:57.585] Resolving 1 futures (chunks) ... DONE
[13:21:57.586] Reducing values from 1 chunks ...
[13:21:57.586]  - Number of values collected after concatenation: 2
[13:21:57.586]  - Number of values expected: 2
[13:21:57.586] Reducing values from 1 chunks ... DONE
[13:21:57.586] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 1 cores ... DONE
  - Testing with 2 cores ...
* plan('multicore') ...
[13:21:57.590] plan(): Setting new future strategy stack:
[13:21:57.590] List of future strategies:
[13:21:57.590] 1. multicore:
[13:21:57.590]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:57.590]    - tweaked: FALSE
[13:21:57.590]    - call: plan(strategy)
[13:21:57.594] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[13:21:57.594] future_lapply() ...
[13:21:57.602] Number of chunks: 2
[13:21:57.602] getGlobalsAndPackagesXApply() ...
[13:21:57.602]  - future.globals: TRUE
[13:21:57.602] getGlobalsAndPackages() ...
[13:21:57.602] Searching for globals...
[13:21:57.604] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:21:57.604] Searching for globals ... DONE
[13:21:57.604] Resolving globals: FALSE
[13:21:57.604] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:21:57.605] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:21:57.605] - globals: [1] ‘FUN’
[13:21:57.605] 
[13:21:57.605] getGlobalsAndPackages() ... DONE
[13:21:57.605]  - globals found/used: [n=1] ‘FUN’
[13:21:57.605]  - needed namespaces: [n=0] 
[13:21:57.605] Finding globals ... DONE
[13:21:57.605]  - use_args: TRUE
[13:21:57.606]  - Getting '...' globals ...
[13:21:57.606] resolve() on list ...
[13:21:57.606]  recursive: 0
[13:21:57.606]  length: 1
[13:21:57.606]  elements: ‘...’
[13:21:57.606]  length: 0 (resolved future 1)
[13:21:57.606] resolve() on list ... DONE
[13:21:57.606]    - '...' content: [n=0] 
[13:21:57.607] List of 1
[13:21:57.607]  $ ...: list()
[13:21:57.607]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:57.607]  - attr(*, "where")=List of 1
[13:21:57.607]   ..$ ...:<environment: 0x55dd74a99eb0> 
[13:21:57.607]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:57.607]  - attr(*, "resolved")= logi TRUE
[13:21:57.607]  - attr(*, "total_size")= num NA
[13:21:57.609]  - Getting '...' globals ... DONE
[13:21:57.609] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:21:57.610] List of 2
[13:21:57.610]  $ ...future.FUN:function (x)  
[13:21:57.610]  $ ...          : list()
[13:21:57.610]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:57.610]  - attr(*, "where")=List of 2
[13:21:57.610]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:57.610]   ..$ ...          :<environment: 0x55dd74a99eb0> 
[13:21:57.610]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:57.610]  - attr(*, "resolved")= logi FALSE
[13:21:57.610]  - attr(*, "total_size")= num 4720
[13:21:57.612] Packages to be attached in all futures: [n=0] 
[13:21:57.612] getGlobalsAndPackagesXApply() ... DONE
[13:21:57.612] Number of futures (= number of chunks): 2
[13:21:57.613] Launching 2 futures (chunks) ...
[13:21:57.613] Chunk #1 of 2 ...
[13:21:57.613]  - Finding globals in 'X' for chunk #1 ...
[13:21:57.613] getGlobalsAndPackages() ...
[13:21:57.613] Searching for globals...
[13:21:57.613] 
[13:21:57.613] Searching for globals ... DONE
[13:21:57.613] - globals: [0] <none>
[13:21:57.614] getGlobalsAndPackages() ... DONE
[13:21:57.614]    + additional globals found: [n=0] 
[13:21:57.614]    + additional namespaces needed: [n=0] 
[13:21:57.614]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:57.614]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:57.614]  - seeds: <none>
[13:21:57.614]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:57.614] getGlobalsAndPackages() ...
[13:21:57.614] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:57.614] Resolving globals: FALSE
[13:21:57.615] Tweak future expression to call with '...' arguments ...
[13:21:57.615] {
[13:21:57.615]     do.call(function(...) {
[13:21:57.615]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:57.615]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:57.615]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:57.615]             on.exit(options(oopts), add = TRUE)
[13:21:57.615]         }
[13:21:57.615]         {
[13:21:57.615]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:57.615]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:57.615]                 ...future.FUN(...future.X_jj, ...)
[13:21:57.615]             })
[13:21:57.615]         }
[13:21:57.615]     }, args = future.call.arguments)
[13:21:57.615] }
[13:21:57.615] Tweak future expression to call with '...' arguments ... DONE
[13:21:57.615] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:57.615] 
[13:21:57.615] getGlobalsAndPackages() ... DONE
[13:21:57.616] run() for ‘Future’ ...
[13:21:57.616] - state: ‘created’
[13:21:57.616] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:57.620] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:57.620] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:57.620]   - Field: ‘label’
[13:21:57.621]   - Field: ‘local’
[13:21:57.621]   - Field: ‘owner’
[13:21:57.621]   - Field: ‘envir’
[13:21:57.621]   - Field: ‘workers’
[13:21:57.621]   - Field: ‘packages’
[13:21:57.621]   - Field: ‘gc’
[13:21:57.621]   - Field: ‘job’
[13:21:57.621]   - Field: ‘conditions’
[13:21:57.621]   - Field: ‘expr’
[13:21:57.621]   - Field: ‘uuid’
[13:21:57.622]   - Field: ‘seed’
[13:21:57.622]   - Field: ‘version’
[13:21:57.622]   - Field: ‘result’
[13:21:57.622]   - Field: ‘asynchronous’
[13:21:57.622]   - Field: ‘calls’
[13:21:57.622]   - Field: ‘globals’
[13:21:57.622]   - Field: ‘stdout’
[13:21:57.622]   - Field: ‘earlySignal’
[13:21:57.622]   - Field: ‘lazy’
[13:21:57.622]   - Field: ‘state’
[13:21:57.622] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:57.623] - Launch lazy future ...
[13:21:57.624] Packages needed by the future expression (n = 0): <none>
[13:21:57.624] Packages needed by future strategies (n = 0): <none>
[13:21:57.624] {
[13:21:57.624]     {
[13:21:57.624]         {
[13:21:57.624]             ...future.startTime <- base::Sys.time()
[13:21:57.624]             {
[13:21:57.624]                 {
[13:21:57.624]                   {
[13:21:57.624]                     {
[13:21:57.624]                       base::local({
[13:21:57.624]                         has_future <- base::requireNamespace("future", 
[13:21:57.624]                           quietly = TRUE)
[13:21:57.624]                         if (has_future) {
[13:21:57.624]                           ns <- base::getNamespace("future")
[13:21:57.624]                           version <- ns[[".package"]][["version"]]
[13:21:57.624]                           if (is.null(version)) 
[13:21:57.624]                             version <- utils::packageVersion("future")
[13:21:57.624]                         }
[13:21:57.624]                         else {
[13:21:57.624]                           version <- NULL
[13:21:57.624]                         }
[13:21:57.624]                         if (!has_future || version < "1.8.0") {
[13:21:57.624]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:57.624]                             "", base::R.version$version.string), 
[13:21:57.624]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:57.624]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:57.624]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:57.624]                               "release", "version")], collapse = " "), 
[13:21:57.624]                             hostname = base::Sys.info()[["nodename"]])
[13:21:57.624]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:57.624]                             info)
[13:21:57.624]                           info <- base::paste(info, collapse = "; ")
[13:21:57.624]                           if (!has_future) {
[13:21:57.624]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:57.624]                               info)
[13:21:57.624]                           }
[13:21:57.624]                           else {
[13:21:57.624]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:57.624]                               info, version)
[13:21:57.624]                           }
[13:21:57.624]                           base::stop(msg)
[13:21:57.624]                         }
[13:21:57.624]                       })
[13:21:57.624]                     }
[13:21:57.624]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:57.624]                     base::options(mc.cores = 1L)
[13:21:57.624]                   }
[13:21:57.624]                   options(future.plan = NULL)
[13:21:57.624]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:57.624]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:57.624]                 }
[13:21:57.624]                 ...future.workdir <- getwd()
[13:21:57.624]             }
[13:21:57.624]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:57.624]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:57.624]         }
[13:21:57.624]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:57.624]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:57.624]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:57.624]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:57.624]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:57.624]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:57.624]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:57.624]             base::names(...future.oldOptions))
[13:21:57.624]     }
[13:21:57.624]     if (FALSE) {
[13:21:57.624]     }
[13:21:57.624]     else {
[13:21:57.624]         if (FALSE) {
[13:21:57.624]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:57.624]                 open = "w")
[13:21:57.624]         }
[13:21:57.624]         else {
[13:21:57.624]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:57.624]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:57.624]         }
[13:21:57.624]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:57.624]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:57.624]             base::sink(type = "output", split = FALSE)
[13:21:57.624]             base::close(...future.stdout)
[13:21:57.624]         }, add = TRUE)
[13:21:57.624]     }
[13:21:57.624]     ...future.frame <- base::sys.nframe()
[13:21:57.624]     ...future.conditions <- base::list()
[13:21:57.624]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:57.624]     if (FALSE) {
[13:21:57.624]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:57.624]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:57.624]     }
[13:21:57.624]     ...future.result <- base::tryCatch({
[13:21:57.624]         base::withCallingHandlers({
[13:21:57.624]             ...future.value <- base::withVisible(base::local({
[13:21:57.624]                 withCallingHandlers({
[13:21:57.624]                   {
[13:21:57.624]                     do.call(function(...) {
[13:21:57.624]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:57.624]                       if (!identical(...future.globals.maxSize.org, 
[13:21:57.624]                         ...future.globals.maxSize)) {
[13:21:57.624]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:57.624]                         on.exit(options(oopts), add = TRUE)
[13:21:57.624]                       }
[13:21:57.624]                       {
[13:21:57.624]                         lapply(seq_along(...future.elements_ii), 
[13:21:57.624]                           FUN = function(jj) {
[13:21:57.624]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:57.624]                             ...future.FUN(...future.X_jj, ...)
[13:21:57.624]                           })
[13:21:57.624]                       }
[13:21:57.624]                     }, args = future.call.arguments)
[13:21:57.624]                   }
[13:21:57.624]                 }, immediateCondition = function(cond) {
[13:21:57.624]                   save_rds <- function (object, pathname, ...) 
[13:21:57.624]                   {
[13:21:57.624]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:57.624]                     if (file_test("-f", pathname_tmp)) {
[13:21:57.624]                       fi_tmp <- file.info(pathname_tmp)
[13:21:57.624]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:57.624]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:57.624]                         fi_tmp[["mtime"]])
[13:21:57.624]                     }
[13:21:57.624]                     tryCatch({
[13:21:57.624]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:57.624]                     }, error = function(ex) {
[13:21:57.624]                       msg <- conditionMessage(ex)
[13:21:57.624]                       fi_tmp <- file.info(pathname_tmp)
[13:21:57.624]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:57.624]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:57.624]                         fi_tmp[["mtime"]], msg)
[13:21:57.624]                       ex$message <- msg
[13:21:57.624]                       stop(ex)
[13:21:57.624]                     })
[13:21:57.624]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:57.624]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:57.624]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:57.624]                       fi_tmp <- file.info(pathname_tmp)
[13:21:57.624]                       fi <- file.info(pathname)
[13:21:57.624]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:57.624]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:57.624]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:57.624]                         fi[["size"]], fi[["mtime"]])
[13:21:57.624]                       stop(msg)
[13:21:57.624]                     }
[13:21:57.624]                     invisible(pathname)
[13:21:57.624]                   }
[13:21:57.624]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:57.624]                     rootPath = tempdir()) 
[13:21:57.624]                   {
[13:21:57.624]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:57.624]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:57.624]                       tmpdir = path, fileext = ".rds")
[13:21:57.624]                     save_rds(obj, file)
[13:21:57.624]                   }
[13:21:57.624]                   saveImmediateCondition(cond, path = "/tmp/Rtmp78O1Lc/.future/immediateConditions")
[13:21:57.624]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:57.624]                   {
[13:21:57.624]                     inherits <- base::inherits
[13:21:57.624]                     invokeRestart <- base::invokeRestart
[13:21:57.624]                     is.null <- base::is.null
[13:21:57.624]                     muffled <- FALSE
[13:21:57.624]                     if (inherits(cond, "message")) {
[13:21:57.624]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:57.624]                       if (muffled) 
[13:21:57.624]                         invokeRestart("muffleMessage")
[13:21:57.624]                     }
[13:21:57.624]                     else if (inherits(cond, "warning")) {
[13:21:57.624]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:57.624]                       if (muffled) 
[13:21:57.624]                         invokeRestart("muffleWarning")
[13:21:57.624]                     }
[13:21:57.624]                     else if (inherits(cond, "condition")) {
[13:21:57.624]                       if (!is.null(pattern)) {
[13:21:57.624]                         computeRestarts <- base::computeRestarts
[13:21:57.624]                         grepl <- base::grepl
[13:21:57.624]                         restarts <- computeRestarts(cond)
[13:21:57.624]                         for (restart in restarts) {
[13:21:57.624]                           name <- restart$name
[13:21:57.624]                           if (is.null(name)) 
[13:21:57.624]                             next
[13:21:57.624]                           if (!grepl(pattern, name)) 
[13:21:57.624]                             next
[13:21:57.624]                           invokeRestart(restart)
[13:21:57.624]                           muffled <- TRUE
[13:21:57.624]                           break
[13:21:57.624]                         }
[13:21:57.624]                       }
[13:21:57.624]                     }
[13:21:57.624]                     invisible(muffled)
[13:21:57.624]                   }
[13:21:57.624]                   muffleCondition(cond)
[13:21:57.624]                 })
[13:21:57.624]             }))
[13:21:57.624]             future::FutureResult(value = ...future.value$value, 
[13:21:57.624]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:57.624]                   ...future.rng), globalenv = if (FALSE) 
[13:21:57.624]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:57.624]                     ...future.globalenv.names))
[13:21:57.624]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:57.624]         }, condition = base::local({
[13:21:57.624]             c <- base::c
[13:21:57.624]             inherits <- base::inherits
[13:21:57.624]             invokeRestart <- base::invokeRestart
[13:21:57.624]             length <- base::length
[13:21:57.624]             list <- base::list
[13:21:57.624]             seq.int <- base::seq.int
[13:21:57.624]             signalCondition <- base::signalCondition
[13:21:57.624]             sys.calls <- base::sys.calls
[13:21:57.624]             `[[` <- base::`[[`
[13:21:57.624]             `+` <- base::`+`
[13:21:57.624]             `<<-` <- base::`<<-`
[13:21:57.624]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:57.624]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:57.624]                   3L)]
[13:21:57.624]             }
[13:21:57.624]             function(cond) {
[13:21:57.624]                 is_error <- inherits(cond, "error")
[13:21:57.624]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:57.624]                   NULL)
[13:21:57.624]                 if (is_error) {
[13:21:57.624]                   sessionInformation <- function() {
[13:21:57.624]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:57.624]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:57.624]                       search = base::search(), system = base::Sys.info())
[13:21:57.624]                   }
[13:21:57.624]                   ...future.conditions[[length(...future.conditions) + 
[13:21:57.624]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:57.624]                     cond$call), session = sessionInformation(), 
[13:21:57.624]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:57.624]                   signalCondition(cond)
[13:21:57.624]                 }
[13:21:57.624]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:57.624]                 "immediateCondition"))) {
[13:21:57.624]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:57.624]                   ...future.conditions[[length(...future.conditions) + 
[13:21:57.624]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:57.624]                   if (TRUE && !signal) {
[13:21:57.624]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:57.624]                     {
[13:21:57.624]                       inherits <- base::inherits
[13:21:57.624]                       invokeRestart <- base::invokeRestart
[13:21:57.624]                       is.null <- base::is.null
[13:21:57.624]                       muffled <- FALSE
[13:21:57.624]                       if (inherits(cond, "message")) {
[13:21:57.624]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:57.624]                         if (muffled) 
[13:21:57.624]                           invokeRestart("muffleMessage")
[13:21:57.624]                       }
[13:21:57.624]                       else if (inherits(cond, "warning")) {
[13:21:57.624]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:57.624]                         if (muffled) 
[13:21:57.624]                           invokeRestart("muffleWarning")
[13:21:57.624]                       }
[13:21:57.624]                       else if (inherits(cond, "condition")) {
[13:21:57.624]                         if (!is.null(pattern)) {
[13:21:57.624]                           computeRestarts <- base::computeRestarts
[13:21:57.624]                           grepl <- base::grepl
[13:21:57.624]                           restarts <- computeRestarts(cond)
[13:21:57.624]                           for (restart in restarts) {
[13:21:57.624]                             name <- restart$name
[13:21:57.624]                             if (is.null(name)) 
[13:21:57.624]                               next
[13:21:57.624]                             if (!grepl(pattern, name)) 
[13:21:57.624]                               next
[13:21:57.624]                             invokeRestart(restart)
[13:21:57.624]                             muffled <- TRUE
[13:21:57.624]                             break
[13:21:57.624]                           }
[13:21:57.624]                         }
[13:21:57.624]                       }
[13:21:57.624]                       invisible(muffled)
[13:21:57.624]                     }
[13:21:57.624]                     muffleCondition(cond, pattern = "^muffle")
[13:21:57.624]                   }
[13:21:57.624]                 }
[13:21:57.624]                 else {
[13:21:57.624]                   if (TRUE) {
[13:21:57.624]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:57.624]                     {
[13:21:57.624]                       inherits <- base::inherits
[13:21:57.624]                       invokeRestart <- base::invokeRestart
[13:21:57.624]                       is.null <- base::is.null
[13:21:57.624]                       muffled <- FALSE
[13:21:57.624]                       if (inherits(cond, "message")) {
[13:21:57.624]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:57.624]                         if (muffled) 
[13:21:57.624]                           invokeRestart("muffleMessage")
[13:21:57.624]                       }
[13:21:57.624]                       else if (inherits(cond, "warning")) {
[13:21:57.624]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:57.624]                         if (muffled) 
[13:21:57.624]                           invokeRestart("muffleWarning")
[13:21:57.624]                       }
[13:21:57.624]                       else if (inherits(cond, "condition")) {
[13:21:57.624]                         if (!is.null(pattern)) {
[13:21:57.624]                           computeRestarts <- base::computeRestarts
[13:21:57.624]                           grepl <- base::grepl
[13:21:57.624]                           restarts <- computeRestarts(cond)
[13:21:57.624]                           for (restart in restarts) {
[13:21:57.624]                             name <- restart$name
[13:21:57.624]                             if (is.null(name)) 
[13:21:57.624]                               next
[13:21:57.624]                             if (!grepl(pattern, name)) 
[13:21:57.624]                               next
[13:21:57.624]                             invokeRestart(restart)
[13:21:57.624]                             muffled <- TRUE
[13:21:57.624]                             break
[13:21:57.624]                           }
[13:21:57.624]                         }
[13:21:57.624]                       }
[13:21:57.624]                       invisible(muffled)
[13:21:57.624]                     }
[13:21:57.624]                     muffleCondition(cond, pattern = "^muffle")
[13:21:57.624]                   }
[13:21:57.624]                 }
[13:21:57.624]             }
[13:21:57.624]         }))
[13:21:57.624]     }, error = function(ex) {
[13:21:57.624]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:57.624]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:57.624]                 ...future.rng), started = ...future.startTime, 
[13:21:57.624]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:57.624]             version = "1.8"), class = "FutureResult")
[13:21:57.624]     }, finally = {
[13:21:57.624]         if (!identical(...future.workdir, getwd())) 
[13:21:57.624]             setwd(...future.workdir)
[13:21:57.624]         {
[13:21:57.624]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:57.624]                 ...future.oldOptions$nwarnings <- NULL
[13:21:57.624]             }
[13:21:57.624]             base::options(...future.oldOptions)
[13:21:57.624]             if (.Platform$OS.type == "windows") {
[13:21:57.624]                 old_names <- names(...future.oldEnvVars)
[13:21:57.624]                 envs <- base::Sys.getenv()
[13:21:57.624]                 names <- names(envs)
[13:21:57.624]                 common <- intersect(names, old_names)
[13:21:57.624]                 added <- setdiff(names, old_names)
[13:21:57.624]                 removed <- setdiff(old_names, names)
[13:21:57.624]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:57.624]                   envs[common]]
[13:21:57.624]                 NAMES <- toupper(changed)
[13:21:57.624]                 args <- list()
[13:21:57.624]                 for (kk in seq_along(NAMES)) {
[13:21:57.624]                   name <- changed[[kk]]
[13:21:57.624]                   NAME <- NAMES[[kk]]
[13:21:57.624]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:57.624]                     next
[13:21:57.624]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:57.624]                 }
[13:21:57.624]                 NAMES <- toupper(added)
[13:21:57.624]                 for (kk in seq_along(NAMES)) {
[13:21:57.624]                   name <- added[[kk]]
[13:21:57.624]                   NAME <- NAMES[[kk]]
[13:21:57.624]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:57.624]                     next
[13:21:57.624]                   args[[name]] <- ""
[13:21:57.624]                 }
[13:21:57.624]                 NAMES <- toupper(removed)
[13:21:57.624]                 for (kk in seq_along(NAMES)) {
[13:21:57.624]                   name <- removed[[kk]]
[13:21:57.624]                   NAME <- NAMES[[kk]]
[13:21:57.624]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:57.624]                     next
[13:21:57.624]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:57.624]                 }
[13:21:57.624]                 if (length(args) > 0) 
[13:21:57.624]                   base::do.call(base::Sys.setenv, args = args)
[13:21:57.624]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:57.624]             }
[13:21:57.624]             else {
[13:21:57.624]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:57.624]             }
[13:21:57.624]             {
[13:21:57.624]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:57.624]                   0L) {
[13:21:57.624]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:57.624]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:57.624]                   base::options(opts)
[13:21:57.624]                 }
[13:21:57.624]                 {
[13:21:57.624]                   {
[13:21:57.624]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:57.624]                     NULL
[13:21:57.624]                   }
[13:21:57.624]                   options(future.plan = NULL)
[13:21:57.624]                   if (is.na(NA_character_)) 
[13:21:57.624]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:57.624]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:57.624]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:57.624]                     envir = parent.frame()) 
[13:21:57.624]                   {
[13:21:57.624]                     default_workers <- missing(workers)
[13:21:57.624]                     if (is.function(workers)) 
[13:21:57.624]                       workers <- workers()
[13:21:57.624]                     workers <- structure(as.integer(workers), 
[13:21:57.624]                       class = class(workers))
[13:21:57.624]                     stop_if_not(is.finite(workers), workers >= 
[13:21:57.624]                       1L)
[13:21:57.624]                     if ((workers == 1L && !inherits(workers, 
[13:21:57.624]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:57.624]                       if (default_workers) 
[13:21:57.624]                         supportsMulticore(warn = TRUE)
[13:21:57.624]                       return(sequential(..., envir = envir))
[13:21:57.624]                     }
[13:21:57.624]                     oopts <- options(mc.cores = workers)
[13:21:57.624]                     on.exit(options(oopts))
[13:21:57.624]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:57.624]                       envir = envir)
[13:21:57.624]                     if (!future$lazy) 
[13:21:57.624]                       future <- run(future)
[13:21:57.624]                     invisible(future)
[13:21:57.624]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:57.624]                 }
[13:21:57.624]             }
[13:21:57.624]         }
[13:21:57.624]     })
[13:21:57.624]     if (TRUE) {
[13:21:57.624]         base::sink(type = "output", split = FALSE)
[13:21:57.624]         if (FALSE) {
[13:21:57.624]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:57.624]         }
[13:21:57.624]         else {
[13:21:57.624]             ...future.result["stdout"] <- base::list(NULL)
[13:21:57.624]         }
[13:21:57.624]         base::close(...future.stdout)
[13:21:57.624]         ...future.stdout <- NULL
[13:21:57.624]     }
[13:21:57.624]     ...future.result$conditions <- ...future.conditions
[13:21:57.624]     ...future.result$finished <- base::Sys.time()
[13:21:57.624]     ...future.result
[13:21:57.624] }
[13:21:57.627] assign_globals() ...
[13:21:57.627] List of 5
[13:21:57.627]  $ ...future.FUN            :function (x)  
[13:21:57.627]  $ future.call.arguments    : list()
[13:21:57.627]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:57.627]  $ ...future.elements_ii    :List of 1
[13:21:57.627]   ..$ : int 1
[13:21:57.627]  $ ...future.seeds_ii       : NULL
[13:21:57.627]  $ ...future.globals.maxSize: NULL
[13:21:57.627]  - attr(*, "where")=List of 5
[13:21:57.627]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:57.627]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:57.627]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:57.627]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:57.627]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:57.627]  - attr(*, "resolved")= logi FALSE
[13:21:57.627]  - attr(*, "total_size")= num 4720
[13:21:57.627]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:57.627]  - attr(*, "already-done")= logi TRUE
[13:21:57.635] - reassign environment for ‘...future.FUN’
[13:21:57.635] - copied ‘...future.FUN’ to environment
[13:21:57.635] - copied ‘future.call.arguments’ to environment
[13:21:57.635] - copied ‘...future.elements_ii’ to environment
[13:21:57.635] - copied ‘...future.seeds_ii’ to environment
[13:21:57.635] - copied ‘...future.globals.maxSize’ to environment
[13:21:57.635] assign_globals() ... done
[13:21:57.636] requestCore(): workers = 2
[13:21:57.639] MulticoreFuture started
[13:21:57.639] - Launch lazy future ... done
[13:21:57.640] plan(): Setting new future strategy stack:
[13:21:57.640] run() for ‘MulticoreFuture’ ... done
[13:21:57.641] Created future:
[13:21:57.640] List of future strategies:
[13:21:57.640] 1. sequential:
[13:21:57.640]    - args: function (..., envir = parent.frame())
[13:21:57.640]    - tweaked: FALSE
[13:21:57.640]    - call: NULL
[13:21:57.641] plan(): nbrOfWorkers() = 1
[13:21:57.641] MulticoreFuture:
[13:21:57.641] Label: ‘future_lapply-1’
[13:21:57.641] Expression:
[13:21:57.641] {
[13:21:57.641]     do.call(function(...) {
[13:21:57.641]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:57.641]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:57.641]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:57.641]             on.exit(options(oopts), add = TRUE)
[13:21:57.641]         }
[13:21:57.641]         {
[13:21:57.641]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:57.641]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:57.641]                 ...future.FUN(...future.X_jj, ...)
[13:21:57.641]             })
[13:21:57.641]         }
[13:21:57.641]     }, args = future.call.arguments)
[13:21:57.641] }
[13:21:57.641] Lazy evaluation: FALSE
[13:21:57.641] Asynchronous evaluation: TRUE
[13:21:57.641] Local evaluation: TRUE
[13:21:57.641] Environment: R_GlobalEnv
[13:21:57.641] Capture standard output: FALSE
[13:21:57.641] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:57.641] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:57.641] Packages: <none>
[13:21:57.641] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:57.641] Resolved: FALSE
[13:21:57.641] Value: <not collected>
[13:21:57.641] Conditions captured: <none>
[13:21:57.641] Early signaling: FALSE
[13:21:57.641] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:21:57.641] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:57.658] Chunk #1 of 2 ... DONE
[13:21:57.658] Chunk #2 of 2 ...
[13:21:57.658]  - Finding globals in 'X' for chunk #2 ...
[13:21:57.659] getGlobalsAndPackages() ...
[13:21:57.659] Searching for globals...
[13:21:57.660] 
[13:21:57.660] Searching for globals ... DONE
[13:21:57.660] - globals: [0] <none>
[13:21:57.660] getGlobalsAndPackages() ... DONE
[13:21:57.661]    + additional globals found: [n=0] 
[13:21:57.661]    + additional namespaces needed: [n=0] 
[13:21:57.661]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:57.661]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:57.662]  - seeds: <none>
[13:21:57.662]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:57.662] getGlobalsAndPackages() ...
[13:21:57.662] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:57.662] Resolving globals: FALSE
[13:21:57.663] Tweak future expression to call with '...' arguments ...
[13:21:57.663] {
[13:21:57.663]     do.call(function(...) {
[13:21:57.663]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:57.663]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:57.663]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:57.663]             on.exit(options(oopts), add = TRUE)
[13:21:57.663]         }
[13:21:57.663]         {
[13:21:57.663]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:57.663]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:57.663]                 ...future.FUN(...future.X_jj, ...)
[13:21:57.663]             })
[13:21:57.663]         }
[13:21:57.663]     }, args = future.call.arguments)
[13:21:57.663] }
[13:21:57.663] Tweak future expression to call with '...' arguments ... DONE
[13:21:57.664] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:57.665] 
[13:21:57.665] getGlobalsAndPackages() ... DONE
[13:21:57.665] run() for ‘Future’ ...
[13:21:57.666] - state: ‘created’
[13:21:57.666] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:57.672] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:57.672] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:57.672]   - Field: ‘label’
[13:21:57.672]   - Field: ‘local’
[13:21:57.672]   - Field: ‘owner’
[13:21:57.673]   - Field: ‘envir’
[13:21:57.673]   - Field: ‘workers’
[13:21:57.673]   - Field: ‘packages’
[13:21:57.673]   - Field: ‘gc’
[13:21:57.673]   - Field: ‘job’
[13:21:57.673]   - Field: ‘conditions’
[13:21:57.673]   - Field: ‘expr’
[13:21:57.674]   - Field: ‘uuid’
[13:21:57.674]   - Field: ‘seed’
[13:21:57.674]   - Field: ‘version’
[13:21:57.674]   - Field: ‘result’
[13:21:57.674]   - Field: ‘asynchronous’
[13:21:57.674]   - Field: ‘calls’
[13:21:57.674]   - Field: ‘globals’
[13:21:57.675]   - Field: ‘stdout’
[13:21:57.675]   - Field: ‘earlySignal’
[13:21:57.675]   - Field: ‘lazy’
[13:21:57.675]   - Field: ‘state’
[13:21:57.675] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:57.675] - Launch lazy future ...
[13:21:57.676] Packages needed by the future expression (n = 0): <none>
[13:21:57.676] Packages needed by future strategies (n = 0): <none>
[13:21:57.677] {
[13:21:57.677]     {
[13:21:57.677]         {
[13:21:57.677]             ...future.startTime <- base::Sys.time()
[13:21:57.677]             {
[13:21:57.677]                 {
[13:21:57.677]                   {
[13:21:57.677]                     {
[13:21:57.677]                       base::local({
[13:21:57.677]                         has_future <- base::requireNamespace("future", 
[13:21:57.677]                           quietly = TRUE)
[13:21:57.677]                         if (has_future) {
[13:21:57.677]                           ns <- base::getNamespace("future")
[13:21:57.677]                           version <- ns[[".package"]][["version"]]
[13:21:57.677]                           if (is.null(version)) 
[13:21:57.677]                             version <- utils::packageVersion("future")
[13:21:57.677]                         }
[13:21:57.677]                         else {
[13:21:57.677]                           version <- NULL
[13:21:57.677]                         }
[13:21:57.677]                         if (!has_future || version < "1.8.0") {
[13:21:57.677]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:57.677]                             "", base::R.version$version.string), 
[13:21:57.677]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:57.677]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:57.677]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:57.677]                               "release", "version")], collapse = " "), 
[13:21:57.677]                             hostname = base::Sys.info()[["nodename"]])
[13:21:57.677]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:57.677]                             info)
[13:21:57.677]                           info <- base::paste(info, collapse = "; ")
[13:21:57.677]                           if (!has_future) {
[13:21:57.677]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:57.677]                               info)
[13:21:57.677]                           }
[13:21:57.677]                           else {
[13:21:57.677]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:57.677]                               info, version)
[13:21:57.677]                           }
[13:21:57.677]                           base::stop(msg)
[13:21:57.677]                         }
[13:21:57.677]                       })
[13:21:57.677]                     }
[13:21:57.677]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:57.677]                     base::options(mc.cores = 1L)
[13:21:57.677]                   }
[13:21:57.677]                   options(future.plan = NULL)
[13:21:57.677]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:57.677]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:57.677]                 }
[13:21:57.677]                 ...future.workdir <- getwd()
[13:21:57.677]             }
[13:21:57.677]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:57.677]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:57.677]         }
[13:21:57.677]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:57.677]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:57.677]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:57.677]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:57.677]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:57.677]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:57.677]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:57.677]             base::names(...future.oldOptions))
[13:21:57.677]     }
[13:21:57.677]     if (FALSE) {
[13:21:57.677]     }
[13:21:57.677]     else {
[13:21:57.677]         if (FALSE) {
[13:21:57.677]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:57.677]                 open = "w")
[13:21:57.677]         }
[13:21:57.677]         else {
[13:21:57.677]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:57.677]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:57.677]         }
[13:21:57.677]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:57.677]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:57.677]             base::sink(type = "output", split = FALSE)
[13:21:57.677]             base::close(...future.stdout)
[13:21:57.677]         }, add = TRUE)
[13:21:57.677]     }
[13:21:57.677]     ...future.frame <- base::sys.nframe()
[13:21:57.677]     ...future.conditions <- base::list()
[13:21:57.677]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:57.677]     if (FALSE) {
[13:21:57.677]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:57.677]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:57.677]     }
[13:21:57.677]     ...future.result <- base::tryCatch({
[13:21:57.677]         base::withCallingHandlers({
[13:21:57.677]             ...future.value <- base::withVisible(base::local({
[13:21:57.677]                 withCallingHandlers({
[13:21:57.677]                   {
[13:21:57.677]                     do.call(function(...) {
[13:21:57.677]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:57.677]                       if (!identical(...future.globals.maxSize.org, 
[13:21:57.677]                         ...future.globals.maxSize)) {
[13:21:57.677]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:57.677]                         on.exit(options(oopts), add = TRUE)
[13:21:57.677]                       }
[13:21:57.677]                       {
[13:21:57.677]                         lapply(seq_along(...future.elements_ii), 
[13:21:57.677]                           FUN = function(jj) {
[13:21:57.677]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:57.677]                             ...future.FUN(...future.X_jj, ...)
[13:21:57.677]                           })
[13:21:57.677]                       }
[13:21:57.677]                     }, args = future.call.arguments)
[13:21:57.677]                   }
[13:21:57.677]                 }, immediateCondition = function(cond) {
[13:21:57.677]                   save_rds <- function (object, pathname, ...) 
[13:21:57.677]                   {
[13:21:57.677]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:57.677]                     if (file_test("-f", pathname_tmp)) {
[13:21:57.677]                       fi_tmp <- file.info(pathname_tmp)
[13:21:57.677]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:57.677]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:57.677]                         fi_tmp[["mtime"]])
[13:21:57.677]                     }
[13:21:57.677]                     tryCatch({
[13:21:57.677]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:57.677]                     }, error = function(ex) {
[13:21:57.677]                       msg <- conditionMessage(ex)
[13:21:57.677]                       fi_tmp <- file.info(pathname_tmp)
[13:21:57.677]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:57.677]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:57.677]                         fi_tmp[["mtime"]], msg)
[13:21:57.677]                       ex$message <- msg
[13:21:57.677]                       stop(ex)
[13:21:57.677]                     })
[13:21:57.677]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:57.677]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:57.677]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:57.677]                       fi_tmp <- file.info(pathname_tmp)
[13:21:57.677]                       fi <- file.info(pathname)
[13:21:57.677]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:57.677]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:57.677]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:57.677]                         fi[["size"]], fi[["mtime"]])
[13:21:57.677]                       stop(msg)
[13:21:57.677]                     }
[13:21:57.677]                     invisible(pathname)
[13:21:57.677]                   }
[13:21:57.677]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:57.677]                     rootPath = tempdir()) 
[13:21:57.677]                   {
[13:21:57.677]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:57.677]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:57.677]                       tmpdir = path, fileext = ".rds")
[13:21:57.677]                     save_rds(obj, file)
[13:21:57.677]                   }
[13:21:57.677]                   saveImmediateCondition(cond, path = "/tmp/Rtmp78O1Lc/.future/immediateConditions")
[13:21:57.677]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:57.677]                   {
[13:21:57.677]                     inherits <- base::inherits
[13:21:57.677]                     invokeRestart <- base::invokeRestart
[13:21:57.677]                     is.null <- base::is.null
[13:21:57.677]                     muffled <- FALSE
[13:21:57.677]                     if (inherits(cond, "message")) {
[13:21:57.677]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:57.677]                       if (muffled) 
[13:21:57.677]                         invokeRestart("muffleMessage")
[13:21:57.677]                     }
[13:21:57.677]                     else if (inherits(cond, "warning")) {
[13:21:57.677]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:57.677]                       if (muffled) 
[13:21:57.677]                         invokeRestart("muffleWarning")
[13:21:57.677]                     }
[13:21:57.677]                     else if (inherits(cond, "condition")) {
[13:21:57.677]                       if (!is.null(pattern)) {
[13:21:57.677]                         computeRestarts <- base::computeRestarts
[13:21:57.677]                         grepl <- base::grepl
[13:21:57.677]                         restarts <- computeRestarts(cond)
[13:21:57.677]                         for (restart in restarts) {
[13:21:57.677]                           name <- restart$name
[13:21:57.677]                           if (is.null(name)) 
[13:21:57.677]                             next
[13:21:57.677]                           if (!grepl(pattern, name)) 
[13:21:57.677]                             next
[13:21:57.677]                           invokeRestart(restart)
[13:21:57.677]                           muffled <- TRUE
[13:21:57.677]                           break
[13:21:57.677]                         }
[13:21:57.677]                       }
[13:21:57.677]                     }
[13:21:57.677]                     invisible(muffled)
[13:21:57.677]                   }
[13:21:57.677]                   muffleCondition(cond)
[13:21:57.677]                 })
[13:21:57.677]             }))
[13:21:57.677]             future::FutureResult(value = ...future.value$value, 
[13:21:57.677]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:57.677]                   ...future.rng), globalenv = if (FALSE) 
[13:21:57.677]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:57.677]                     ...future.globalenv.names))
[13:21:57.677]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:57.677]         }, condition = base::local({
[13:21:57.677]             c <- base::c
[13:21:57.677]             inherits <- base::inherits
[13:21:57.677]             invokeRestart <- base::invokeRestart
[13:21:57.677]             length <- base::length
[13:21:57.677]             list <- base::list
[13:21:57.677]             seq.int <- base::seq.int
[13:21:57.677]             signalCondition <- base::signalCondition
[13:21:57.677]             sys.calls <- base::sys.calls
[13:21:57.677]             `[[` <- base::`[[`
[13:21:57.677]             `+` <- base::`+`
[13:21:57.677]             `<<-` <- base::`<<-`
[13:21:57.677]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:57.677]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:57.677]                   3L)]
[13:21:57.677]             }
[13:21:57.677]             function(cond) {
[13:21:57.677]                 is_error <- inherits(cond, "error")
[13:21:57.677]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:57.677]                   NULL)
[13:21:57.677]                 if (is_error) {
[13:21:57.677]                   sessionInformation <- function() {
[13:21:57.677]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:57.677]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:57.677]                       search = base::search(), system = base::Sys.info())
[13:21:57.677]                   }
[13:21:57.677]                   ...future.conditions[[length(...future.conditions) + 
[13:21:57.677]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:57.677]                     cond$call), session = sessionInformation(), 
[13:21:57.677]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:57.677]                   signalCondition(cond)
[13:21:57.677]                 }
[13:21:57.677]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:57.677]                 "immediateCondition"))) {
[13:21:57.677]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:57.677]                   ...future.conditions[[length(...future.conditions) + 
[13:21:57.677]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:57.677]                   if (TRUE && !signal) {
[13:21:57.677]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:57.677]                     {
[13:21:57.677]                       inherits <- base::inherits
[13:21:57.677]                       invokeRestart <- base::invokeRestart
[13:21:57.677]                       is.null <- base::is.null
[13:21:57.677]                       muffled <- FALSE
[13:21:57.677]                       if (inherits(cond, "message")) {
[13:21:57.677]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:57.677]                         if (muffled) 
[13:21:57.677]                           invokeRestart("muffleMessage")
[13:21:57.677]                       }
[13:21:57.677]                       else if (inherits(cond, "warning")) {
[13:21:57.677]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:57.677]                         if (muffled) 
[13:21:57.677]                           invokeRestart("muffleWarning")
[13:21:57.677]                       }
[13:21:57.677]                       else if (inherits(cond, "condition")) {
[13:21:57.677]                         if (!is.null(pattern)) {
[13:21:57.677]                           computeRestarts <- base::computeRestarts
[13:21:57.677]                           grepl <- base::grepl
[13:21:57.677]                           restarts <- computeRestarts(cond)
[13:21:57.677]                           for (restart in restarts) {
[13:21:57.677]                             name <- restart$name
[13:21:57.677]                             if (is.null(name)) 
[13:21:57.677]                               next
[13:21:57.677]                             if (!grepl(pattern, name)) 
[13:21:57.677]                               next
[13:21:57.677]                             invokeRestart(restart)
[13:21:57.677]                             muffled <- TRUE
[13:21:57.677]                             break
[13:21:57.677]                           }
[13:21:57.677]                         }
[13:21:57.677]                       }
[13:21:57.677]                       invisible(muffled)
[13:21:57.677]                     }
[13:21:57.677]                     muffleCondition(cond, pattern = "^muffle")
[13:21:57.677]                   }
[13:21:57.677]                 }
[13:21:57.677]                 else {
[13:21:57.677]                   if (TRUE) {
[13:21:57.677]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:57.677]                     {
[13:21:57.677]                       inherits <- base::inherits
[13:21:57.677]                       invokeRestart <- base::invokeRestart
[13:21:57.677]                       is.null <- base::is.null
[13:21:57.677]                       muffled <- FALSE
[13:21:57.677]                       if (inherits(cond, "message")) {
[13:21:57.677]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:57.677]                         if (muffled) 
[13:21:57.677]                           invokeRestart("muffleMessage")
[13:21:57.677]                       }
[13:21:57.677]                       else if (inherits(cond, "warning")) {
[13:21:57.677]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:57.677]                         if (muffled) 
[13:21:57.677]                           invokeRestart("muffleWarning")
[13:21:57.677]                       }
[13:21:57.677]                       else if (inherits(cond, "condition")) {
[13:21:57.677]                         if (!is.null(pattern)) {
[13:21:57.677]                           computeRestarts <- base::computeRestarts
[13:21:57.677]                           grepl <- base::grepl
[13:21:57.677]                           restarts <- computeRestarts(cond)
[13:21:57.677]                           for (restart in restarts) {
[13:21:57.677]                             name <- restart$name
[13:21:57.677]                             if (is.null(name)) 
[13:21:57.677]                               next
[13:21:57.677]                             if (!grepl(pattern, name)) 
[13:21:57.677]                               next
[13:21:57.677]                             invokeRestart(restart)
[13:21:57.677]                             muffled <- TRUE
[13:21:57.677]                             break
[13:21:57.677]                           }
[13:21:57.677]                         }
[13:21:57.677]                       }
[13:21:57.677]                       invisible(muffled)
[13:21:57.677]                     }
[13:21:57.677]                     muffleCondition(cond, pattern = "^muffle")
[13:21:57.677]                   }
[13:21:57.677]                 }
[13:21:57.677]             }
[13:21:57.677]         }))
[13:21:57.677]     }, error = function(ex) {
[13:21:57.677]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:57.677]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:57.677]                 ...future.rng), started = ...future.startTime, 
[13:21:57.677]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:57.677]             version = "1.8"), class = "FutureResult")
[13:21:57.677]     }, finally = {
[13:21:57.677]         if (!identical(...future.workdir, getwd())) 
[13:21:57.677]             setwd(...future.workdir)
[13:21:57.677]         {
[13:21:57.677]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:57.677]                 ...future.oldOptions$nwarnings <- NULL
[13:21:57.677]             }
[13:21:57.677]             base::options(...future.oldOptions)
[13:21:57.677]             if (.Platform$OS.type == "windows") {
[13:21:57.677]                 old_names <- names(...future.oldEnvVars)
[13:21:57.677]                 envs <- base::Sys.getenv()
[13:21:57.677]                 names <- names(envs)
[13:21:57.677]                 common <- intersect(names, old_names)
[13:21:57.677]                 added <- setdiff(names, old_names)
[13:21:57.677]                 removed <- setdiff(old_names, names)
[13:21:57.677]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:57.677]                   envs[common]]
[13:21:57.677]                 NAMES <- toupper(changed)
[13:21:57.677]                 args <- list()
[13:21:57.677]                 for (kk in seq_along(NAMES)) {
[13:21:57.677]                   name <- changed[[kk]]
[13:21:57.677]                   NAME <- NAMES[[kk]]
[13:21:57.677]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:57.677]                     next
[13:21:57.677]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:57.677]                 }
[13:21:57.677]                 NAMES <- toupper(added)
[13:21:57.677]                 for (kk in seq_along(NAMES)) {
[13:21:57.677]                   name <- added[[kk]]
[13:21:57.677]                   NAME <- NAMES[[kk]]
[13:21:57.677]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:57.677]                     next
[13:21:57.677]                   args[[name]] <- ""
[13:21:57.677]                 }
[13:21:57.677]                 NAMES <- toupper(removed)
[13:21:57.677]                 for (kk in seq_along(NAMES)) {
[13:21:57.677]                   name <- removed[[kk]]
[13:21:57.677]                   NAME <- NAMES[[kk]]
[13:21:57.677]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:57.677]                     next
[13:21:57.677]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:57.677]                 }
[13:21:57.677]                 if (length(args) > 0) 
[13:21:57.677]                   base::do.call(base::Sys.setenv, args = args)
[13:21:57.677]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:57.677]             }
[13:21:57.677]             else {
[13:21:57.677]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:57.677]             }
[13:21:57.677]             {
[13:21:57.677]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:57.677]                   0L) {
[13:21:57.677]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:57.677]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:57.677]                   base::options(opts)
[13:21:57.677]                 }
[13:21:57.677]                 {
[13:21:57.677]                   {
[13:21:57.677]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:57.677]                     NULL
[13:21:57.677]                   }
[13:21:57.677]                   options(future.plan = NULL)
[13:21:57.677]                   if (is.na(NA_character_)) 
[13:21:57.677]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:57.677]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:57.677]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:57.677]                     envir = parent.frame()) 
[13:21:57.677]                   {
[13:21:57.677]                     default_workers <- missing(workers)
[13:21:57.677]                     if (is.function(workers)) 
[13:21:57.677]                       workers <- workers()
[13:21:57.677]                     workers <- structure(as.integer(workers), 
[13:21:57.677]                       class = class(workers))
[13:21:57.677]                     stop_if_not(is.finite(workers), workers >= 
[13:21:57.677]                       1L)
[13:21:57.677]                     if ((workers == 1L && !inherits(workers, 
[13:21:57.677]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:57.677]                       if (default_workers) 
[13:21:57.677]                         supportsMulticore(warn = TRUE)
[13:21:57.677]                       return(sequential(..., envir = envir))
[13:21:57.677]                     }
[13:21:57.677]                     oopts <- options(mc.cores = workers)
[13:21:57.677]                     on.exit(options(oopts))
[13:21:57.677]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:57.677]                       envir = envir)
[13:21:57.677]                     if (!future$lazy) 
[13:21:57.677]                       future <- run(future)
[13:21:57.677]                     invisible(future)
[13:21:57.677]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:57.677]                 }
[13:21:57.677]             }
[13:21:57.677]         }
[13:21:57.677]     })
[13:21:57.677]     if (TRUE) {
[13:21:57.677]         base::sink(type = "output", split = FALSE)
[13:21:57.677]         if (FALSE) {
[13:21:57.677]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:57.677]         }
[13:21:57.677]         else {
[13:21:57.677]             ...future.result["stdout"] <- base::list(NULL)
[13:21:57.677]         }
[13:21:57.677]         base::close(...future.stdout)
[13:21:57.677]         ...future.stdout <- NULL
[13:21:57.677]     }
[13:21:57.677]     ...future.result$conditions <- ...future.conditions
[13:21:57.677]     ...future.result$finished <- base::Sys.time()
[13:21:57.677]     ...future.result
[13:21:57.677] }
[13:21:57.680] assign_globals() ...
[13:21:57.681] List of 5
[13:21:57.681]  $ ...future.FUN            :function (x)  
[13:21:57.681]  $ future.call.arguments    : list()
[13:21:57.681]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:57.681]  $ ...future.elements_ii    :List of 1
[13:21:57.681]   ..$ : int 0
[13:21:57.681]  $ ...future.seeds_ii       : NULL
[13:21:57.681]  $ ...future.globals.maxSize: NULL
[13:21:57.681]  - attr(*, "where")=List of 5
[13:21:57.681]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:57.681]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:57.681]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:57.681]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:57.681]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:57.681]  - attr(*, "resolved")= logi FALSE
[13:21:57.681]  - attr(*, "total_size")= num 4720
[13:21:57.681]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:57.681]  - attr(*, "already-done")= logi TRUE
[13:21:57.688] - reassign environment for ‘...future.FUN’
[13:21:57.688] - copied ‘...future.FUN’ to environment
[13:21:57.688] - copied ‘future.call.arguments’ to environment
[13:21:57.689] - copied ‘...future.elements_ii’ to environment
[13:21:57.689] - copied ‘...future.seeds_ii’ to environment
[13:21:57.689] - copied ‘...future.globals.maxSize’ to environment
[13:21:57.689] assign_globals() ... done
[13:21:57.689] requestCore(): workers = 2
[13:21:57.698] MulticoreFuture started
[13:21:57.699] - Launch lazy future ... done
[13:21:57.699] plan(): Setting new future strategy stack:
[13:21:57.699] run() for ‘MulticoreFuture’ ... done
[13:21:57.700] Created future:
[13:21:57.700] List of future strategies:
[13:21:57.700] 1. sequential:
[13:21:57.700]    - args: function (..., envir = parent.frame())
[13:21:57.700]    - tweaked: FALSE
[13:21:57.700]    - call: NULL
[13:21:57.701] plan(): nbrOfWorkers() = 1
[13:21:57.704] plan(): Setting new future strategy stack:
[13:21:57.704] List of future strategies:
[13:21:57.704] 1. multicore:
[13:21:57.704]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:57.704]    - tweaked: FALSE
[13:21:57.704]    - call: plan(strategy)
[13:21:57.710] plan(): nbrOfWorkers() = 2
[13:21:57.700] MulticoreFuture:
[13:21:57.700] Label: ‘future_lapply-2’
[13:21:57.700] Expression:
[13:21:57.700] {
[13:21:57.700]     do.call(function(...) {
[13:21:57.700]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:57.700]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:57.700]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:57.700]             on.exit(options(oopts), add = TRUE)
[13:21:57.700]         }
[13:21:57.700]         {
[13:21:57.700]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:57.700]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:57.700]                 ...future.FUN(...future.X_jj, ...)
[13:21:57.700]             })
[13:21:57.700]         }
[13:21:57.700]     }, args = future.call.arguments)
[13:21:57.700] }
[13:21:57.700] Lazy evaluation: FALSE
[13:21:57.700] Asynchronous evaluation: TRUE
[13:21:57.700] Local evaluation: TRUE
[13:21:57.700] Environment: R_GlobalEnv
[13:21:57.700] Capture standard output: FALSE
[13:21:57.700] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:57.700] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:57.700] Packages: <none>
[13:21:57.700] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:57.700] Resolved: TRUE
[13:21:57.700] Value: <not collected>
[13:21:57.700] Conditions captured: <none>
[13:21:57.700] Early signaling: FALSE
[13:21:57.700] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:21:57.700] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:57.712] Chunk #2 of 2 ... DONE
[13:21:57.712] Launching 2 futures (chunks) ... DONE
[13:21:57.712] Resolving 2 futures (chunks) ...
[13:21:57.712] resolve() on list ...
[13:21:57.712]  recursive: 0
[13:21:57.713]  length: 2
[13:21:57.713] 
[13:21:57.724] Future #2
[13:21:57.725] result() for MulticoreFuture ...
[13:21:57.727] result() for MulticoreFuture ...
[13:21:57.727] result() for MulticoreFuture ... done
[13:21:57.728] result() for MulticoreFuture ... done
[13:21:57.728] result() for MulticoreFuture ...
[13:21:57.728] result() for MulticoreFuture ... done
[13:21:57.728] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:21:57.729] - nx: 2
[13:21:57.729] - relay: TRUE
[13:21:57.729] - stdout: TRUE
[13:21:57.729] - signal: TRUE
[13:21:57.729] - resignal: FALSE
[13:21:57.729] - force: TRUE
[13:21:57.730] - relayed: [n=2] FALSE, FALSE
[13:21:57.730] - queued futures: [n=2] FALSE, FALSE
[13:21:57.730]  - until=1
[13:21:57.730]  - relaying element #1
[13:21:57.730] - relayed: [n=2] FALSE, FALSE
[13:21:57.730] - queued futures: [n=2] FALSE, TRUE
[13:21:57.731] signalConditionsASAP(NULL, pos=2) ... done
[13:21:57.731]  length: 1 (resolved future 2)
[13:21:58.145] plan(): Setting new future strategy stack:
[13:21:58.145] List of future strategies:
[13:21:58.145] 1. multicore:
[13:21:58.145]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:58.145]    - tweaked: FALSE
[13:21:58.145]    - call: plan(strategy)
[13:21:58.150] plan(): nbrOfWorkers() = 2
[13:21:58.151] Future #1
[13:21:58.151] result() for MulticoreFuture ...
[13:21:58.152] result() for MulticoreFuture ...
[13:21:58.152] result() for MulticoreFuture ... done
[13:21:58.152] result() for MulticoreFuture ... done
[13:21:58.152] result() for MulticoreFuture ...
[13:21:58.152] result() for MulticoreFuture ... done
[13:21:58.153] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:21:58.153] - nx: 2
[13:21:58.153] - relay: TRUE
[13:21:58.153] - stdout: TRUE
[13:21:58.153] - signal: TRUE
[13:21:58.153] - resignal: FALSE
[13:21:58.153] - force: TRUE
[13:21:58.154] - relayed: [n=2] FALSE, FALSE
[13:21:58.154] - queued futures: [n=2] FALSE, TRUE
[13:21:58.154]  - until=1
[13:21:58.154]  - relaying element #1
[13:21:58.154] result() for MulticoreFuture ...
[13:21:58.154] result() for MulticoreFuture ... done
[13:21:58.155] result() for MulticoreFuture ...
[13:21:58.155] result() for MulticoreFuture ... done
[13:21:58.155] result() for MulticoreFuture ...
[13:21:58.155] result() for MulticoreFuture ... done
[13:21:58.155] result() for MulticoreFuture ...
[13:21:58.155] result() for MulticoreFuture ... done
[13:21:58.155] - relayed: [n=2] TRUE, FALSE
[13:21:58.156] - queued futures: [n=2] TRUE, TRUE
[13:21:58.156] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:21:58.156]  length: 0 (resolved future 1)
[13:21:58.156] Relaying remaining futures
[13:21:58.156] signalConditionsASAP(NULL, pos=0) ...
[13:21:58.156] - nx: 2
[13:21:58.156] - relay: TRUE
[13:21:58.157] - stdout: TRUE
[13:21:58.157] - signal: TRUE
[13:21:58.157] - resignal: FALSE
[13:21:58.157] - force: TRUE
[13:21:58.157] - relayed: [n=2] TRUE, FALSE
[13:21:58.157] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:58.157]  - relaying element #2
[13:21:58.157] result() for MulticoreFuture ...
[13:21:58.157] result() for MulticoreFuture ... done
[13:21:58.158] result() for MulticoreFuture ...
[13:21:58.158] result() for MulticoreFuture ... done
[13:21:58.158] result() for MulticoreFuture ...
[13:21:58.158] result() for MulticoreFuture ... done
[13:21:58.158] result() for MulticoreFuture ...
[13:21:58.158] result() for MulticoreFuture ... done
[13:21:58.158] - relayed: [n=2] TRUE, TRUE
[13:21:58.158] - queued futures: [n=2] TRUE, TRUE
[13:21:58.158] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[13:21:58.159] resolve() on list ... DONE
[13:21:58.159] result() for MulticoreFuture ...
[13:21:58.159] result() for MulticoreFuture ... done
[13:21:58.159] result() for MulticoreFuture ...
[13:21:58.159] result() for MulticoreFuture ... done
[13:21:58.159] result() for MulticoreFuture ...
[13:21:58.159] result() for MulticoreFuture ... done
[13:21:58.159] result() for MulticoreFuture ...
[13:21:58.159] result() for MulticoreFuture ... done
[13:21:58.160]  - Number of value chunks collected: 2
[13:21:58.160] Resolving 2 futures (chunks) ... DONE
[13:21:58.160] Reducing values from 2 chunks ...
[13:21:58.160]  - Number of values collected after concatenation: 2
[13:21:58.160]  - Number of values expected: 2
[13:21:58.160] Reducing values from 2 chunks ... DONE
[13:21:58.160] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[13:21:58.161] future_lapply() ...
[13:21:58.166] Number of chunks: 2
[13:21:58.166] getGlobalsAndPackagesXApply() ...
[13:21:58.166]  - future.globals: TRUE
[13:21:58.166] getGlobalsAndPackages() ...
[13:21:58.166] Searching for globals...
[13:21:58.168] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:21:58.168] Searching for globals ... DONE
[13:21:58.168] Resolving globals: FALSE
[13:21:58.169] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:21:58.169] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:21:58.169] - globals: [1] ‘FUN’
[13:21:58.169] 
[13:21:58.169] getGlobalsAndPackages() ... DONE
[13:21:58.169]  - globals found/used: [n=1] ‘FUN’
[13:21:58.170]  - needed namespaces: [n=0] 
[13:21:58.170] Finding globals ... DONE
[13:21:58.170]  - use_args: TRUE
[13:21:58.170]  - Getting '...' globals ...
[13:21:58.170] resolve() on list ...
[13:21:58.170]  recursive: 0
[13:21:58.170]  length: 1
[13:21:58.171]  elements: ‘...’
[13:21:58.171]  length: 0 (resolved future 1)
[13:21:58.171] resolve() on list ... DONE
[13:21:58.171]    - '...' content: [n=0] 
[13:21:58.171] List of 1
[13:21:58.171]  $ ...: list()
[13:21:58.171]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:58.171]  - attr(*, "where")=List of 1
[13:21:58.171]   ..$ ...:<environment: 0x55dd740420a0> 
[13:21:58.171]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:58.171]  - attr(*, "resolved")= logi TRUE
[13:21:58.171]  - attr(*, "total_size")= num NA
[13:21:58.176]  - Getting '...' globals ... DONE
[13:21:58.177] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:21:58.177] List of 2
[13:21:58.177]  $ ...future.FUN:function (x)  
[13:21:58.177]  $ ...          : list()
[13:21:58.177]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:58.177]  - attr(*, "where")=List of 2
[13:21:58.177]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:58.177]   ..$ ...          :<environment: 0x55dd740420a0> 
[13:21:58.177]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:58.177]  - attr(*, "resolved")= logi FALSE
[13:21:58.177]  - attr(*, "total_size")= num 4720
[13:21:58.179] Packages to be attached in all futures: [n=0] 
[13:21:58.180] getGlobalsAndPackagesXApply() ... DONE
[13:21:58.180] Number of futures (= number of chunks): 2
[13:21:58.180] Launching 2 futures (chunks) ...
[13:21:58.180] Chunk #1 of 2 ...
[13:21:58.180]  - Finding globals in 'X' for chunk #1 ...
[13:21:58.180] getGlobalsAndPackages() ...
[13:21:58.180] Searching for globals...
[13:21:58.181] 
[13:21:58.181] Searching for globals ... DONE
[13:21:58.181] - globals: [0] <none>
[13:21:58.181] getGlobalsAndPackages() ... DONE
[13:21:58.181]    + additional globals found: [n=0] 
[13:21:58.181]    + additional namespaces needed: [n=0] 
[13:21:58.181]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:58.181]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:58.181]  - seeds: <none>
[13:21:58.181]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:58.182] getGlobalsAndPackages() ...
[13:21:58.182] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:58.182] Resolving globals: FALSE
[13:21:58.182] Tweak future expression to call with '...' arguments ...
[13:21:58.182] {
[13:21:58.182]     do.call(function(...) {
[13:21:58.182]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:58.182]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:58.182]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:58.182]             on.exit(options(oopts), add = TRUE)
[13:21:58.182]         }
[13:21:58.182]         {
[13:21:58.182]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:58.182]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:58.182]                 ...future.FUN(...future.X_jj, ...)
[13:21:58.182]             })
[13:21:58.182]         }
[13:21:58.182]     }, args = future.call.arguments)
[13:21:58.182] }
[13:21:58.182] Tweak future expression to call with '...' arguments ... DONE
[13:21:58.183] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:58.183] 
[13:21:58.183] getGlobalsAndPackages() ... DONE
[13:21:58.183] run() for ‘Future’ ...
[13:21:58.183] - state: ‘created’
[13:21:58.183] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:58.187] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:58.188] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:58.188]   - Field: ‘label’
[13:21:58.188]   - Field: ‘local’
[13:21:58.188]   - Field: ‘owner’
[13:21:58.188]   - Field: ‘envir’
[13:21:58.188]   - Field: ‘workers’
[13:21:58.188]   - Field: ‘packages’
[13:21:58.188]   - Field: ‘gc’
[13:21:58.188]   - Field: ‘job’
[13:21:58.189]   - Field: ‘conditions’
[13:21:58.189]   - Field: ‘expr’
[13:21:58.189]   - Field: ‘uuid’
[13:21:58.189]   - Field: ‘seed’
[13:21:58.189]   - Field: ‘version’
[13:21:58.189]   - Field: ‘result’
[13:21:58.189]   - Field: ‘asynchronous’
[13:21:58.189]   - Field: ‘calls’
[13:21:58.189]   - Field: ‘globals’
[13:21:58.189]   - Field: ‘stdout’
[13:21:58.190]   - Field: ‘earlySignal’
[13:21:58.190]   - Field: ‘lazy’
[13:21:58.190]   - Field: ‘state’
[13:21:58.190] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:58.190] - Launch lazy future ...
[13:21:58.190] Packages needed by the future expression (n = 0): <none>
[13:21:58.190] Packages needed by future strategies (n = 0): <none>
[13:21:58.191] {
[13:21:58.191]     {
[13:21:58.191]         {
[13:21:58.191]             ...future.startTime <- base::Sys.time()
[13:21:58.191]             {
[13:21:58.191]                 {
[13:21:58.191]                   {
[13:21:58.191]                     {
[13:21:58.191]                       base::local({
[13:21:58.191]                         has_future <- base::requireNamespace("future", 
[13:21:58.191]                           quietly = TRUE)
[13:21:58.191]                         if (has_future) {
[13:21:58.191]                           ns <- base::getNamespace("future")
[13:21:58.191]                           version <- ns[[".package"]][["version"]]
[13:21:58.191]                           if (is.null(version)) 
[13:21:58.191]                             version <- utils::packageVersion("future")
[13:21:58.191]                         }
[13:21:58.191]                         else {
[13:21:58.191]                           version <- NULL
[13:21:58.191]                         }
[13:21:58.191]                         if (!has_future || version < "1.8.0") {
[13:21:58.191]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:58.191]                             "", base::R.version$version.string), 
[13:21:58.191]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:58.191]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:58.191]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:58.191]                               "release", "version")], collapse = " "), 
[13:21:58.191]                             hostname = base::Sys.info()[["nodename"]])
[13:21:58.191]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:58.191]                             info)
[13:21:58.191]                           info <- base::paste(info, collapse = "; ")
[13:21:58.191]                           if (!has_future) {
[13:21:58.191]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:58.191]                               info)
[13:21:58.191]                           }
[13:21:58.191]                           else {
[13:21:58.191]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:58.191]                               info, version)
[13:21:58.191]                           }
[13:21:58.191]                           base::stop(msg)
[13:21:58.191]                         }
[13:21:58.191]                       })
[13:21:58.191]                     }
[13:21:58.191]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:58.191]                     base::options(mc.cores = 1L)
[13:21:58.191]                   }
[13:21:58.191]                   options(future.plan = NULL)
[13:21:58.191]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:58.191]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:58.191]                 }
[13:21:58.191]                 ...future.workdir <- getwd()
[13:21:58.191]             }
[13:21:58.191]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:58.191]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:58.191]         }
[13:21:58.191]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:58.191]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:58.191]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:58.191]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:58.191]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:58.191]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:58.191]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:58.191]             base::names(...future.oldOptions))
[13:21:58.191]     }
[13:21:58.191]     if (FALSE) {
[13:21:58.191]     }
[13:21:58.191]     else {
[13:21:58.191]         if (TRUE) {
[13:21:58.191]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:58.191]                 open = "w")
[13:21:58.191]         }
[13:21:58.191]         else {
[13:21:58.191]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:58.191]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:58.191]         }
[13:21:58.191]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:58.191]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:58.191]             base::sink(type = "output", split = FALSE)
[13:21:58.191]             base::close(...future.stdout)
[13:21:58.191]         }, add = TRUE)
[13:21:58.191]     }
[13:21:58.191]     ...future.frame <- base::sys.nframe()
[13:21:58.191]     ...future.conditions <- base::list()
[13:21:58.191]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:58.191]     if (FALSE) {
[13:21:58.191]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:58.191]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:58.191]     }
[13:21:58.191]     ...future.result <- base::tryCatch({
[13:21:58.191]         base::withCallingHandlers({
[13:21:58.191]             ...future.value <- base::withVisible(base::local({
[13:21:58.191]                 withCallingHandlers({
[13:21:58.191]                   {
[13:21:58.191]                     do.call(function(...) {
[13:21:58.191]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:58.191]                       if (!identical(...future.globals.maxSize.org, 
[13:21:58.191]                         ...future.globals.maxSize)) {
[13:21:58.191]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:58.191]                         on.exit(options(oopts), add = TRUE)
[13:21:58.191]                       }
[13:21:58.191]                       {
[13:21:58.191]                         lapply(seq_along(...future.elements_ii), 
[13:21:58.191]                           FUN = function(jj) {
[13:21:58.191]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:58.191]                             ...future.FUN(...future.X_jj, ...)
[13:21:58.191]                           })
[13:21:58.191]                       }
[13:21:58.191]                     }, args = future.call.arguments)
[13:21:58.191]                   }
[13:21:58.191]                 }, immediateCondition = function(cond) {
[13:21:58.191]                   save_rds <- function (object, pathname, ...) 
[13:21:58.191]                   {
[13:21:58.191]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:58.191]                     if (file_test("-f", pathname_tmp)) {
[13:21:58.191]                       fi_tmp <- file.info(pathname_tmp)
[13:21:58.191]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:58.191]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:58.191]                         fi_tmp[["mtime"]])
[13:21:58.191]                     }
[13:21:58.191]                     tryCatch({
[13:21:58.191]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:58.191]                     }, error = function(ex) {
[13:21:58.191]                       msg <- conditionMessage(ex)
[13:21:58.191]                       fi_tmp <- file.info(pathname_tmp)
[13:21:58.191]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:58.191]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:58.191]                         fi_tmp[["mtime"]], msg)
[13:21:58.191]                       ex$message <- msg
[13:21:58.191]                       stop(ex)
[13:21:58.191]                     })
[13:21:58.191]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:58.191]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:58.191]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:58.191]                       fi_tmp <- file.info(pathname_tmp)
[13:21:58.191]                       fi <- file.info(pathname)
[13:21:58.191]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:58.191]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:58.191]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:58.191]                         fi[["size"]], fi[["mtime"]])
[13:21:58.191]                       stop(msg)
[13:21:58.191]                     }
[13:21:58.191]                     invisible(pathname)
[13:21:58.191]                   }
[13:21:58.191]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:58.191]                     rootPath = tempdir()) 
[13:21:58.191]                   {
[13:21:58.191]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:58.191]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:58.191]                       tmpdir = path, fileext = ".rds")
[13:21:58.191]                     save_rds(obj, file)
[13:21:58.191]                   }
[13:21:58.191]                   saveImmediateCondition(cond, path = "/tmp/Rtmp78O1Lc/.future/immediateConditions")
[13:21:58.191]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:58.191]                   {
[13:21:58.191]                     inherits <- base::inherits
[13:21:58.191]                     invokeRestart <- base::invokeRestart
[13:21:58.191]                     is.null <- base::is.null
[13:21:58.191]                     muffled <- FALSE
[13:21:58.191]                     if (inherits(cond, "message")) {
[13:21:58.191]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:58.191]                       if (muffled) 
[13:21:58.191]                         invokeRestart("muffleMessage")
[13:21:58.191]                     }
[13:21:58.191]                     else if (inherits(cond, "warning")) {
[13:21:58.191]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:58.191]                       if (muffled) 
[13:21:58.191]                         invokeRestart("muffleWarning")
[13:21:58.191]                     }
[13:21:58.191]                     else if (inherits(cond, "condition")) {
[13:21:58.191]                       if (!is.null(pattern)) {
[13:21:58.191]                         computeRestarts <- base::computeRestarts
[13:21:58.191]                         grepl <- base::grepl
[13:21:58.191]                         restarts <- computeRestarts(cond)
[13:21:58.191]                         for (restart in restarts) {
[13:21:58.191]                           name <- restart$name
[13:21:58.191]                           if (is.null(name)) 
[13:21:58.191]                             next
[13:21:58.191]                           if (!grepl(pattern, name)) 
[13:21:58.191]                             next
[13:21:58.191]                           invokeRestart(restart)
[13:21:58.191]                           muffled <- TRUE
[13:21:58.191]                           break
[13:21:58.191]                         }
[13:21:58.191]                       }
[13:21:58.191]                     }
[13:21:58.191]                     invisible(muffled)
[13:21:58.191]                   }
[13:21:58.191]                   muffleCondition(cond)
[13:21:58.191]                 })
[13:21:58.191]             }))
[13:21:58.191]             future::FutureResult(value = ...future.value$value, 
[13:21:58.191]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:58.191]                   ...future.rng), globalenv = if (FALSE) 
[13:21:58.191]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:58.191]                     ...future.globalenv.names))
[13:21:58.191]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:58.191]         }, condition = base::local({
[13:21:58.191]             c <- base::c
[13:21:58.191]             inherits <- base::inherits
[13:21:58.191]             invokeRestart <- base::invokeRestart
[13:21:58.191]             length <- base::length
[13:21:58.191]             list <- base::list
[13:21:58.191]             seq.int <- base::seq.int
[13:21:58.191]             signalCondition <- base::signalCondition
[13:21:58.191]             sys.calls <- base::sys.calls
[13:21:58.191]             `[[` <- base::`[[`
[13:21:58.191]             `+` <- base::`+`
[13:21:58.191]             `<<-` <- base::`<<-`
[13:21:58.191]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:58.191]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:58.191]                   3L)]
[13:21:58.191]             }
[13:21:58.191]             function(cond) {
[13:21:58.191]                 is_error <- inherits(cond, "error")
[13:21:58.191]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:58.191]                   NULL)
[13:21:58.191]                 if (is_error) {
[13:21:58.191]                   sessionInformation <- function() {
[13:21:58.191]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:58.191]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:58.191]                       search = base::search(), system = base::Sys.info())
[13:21:58.191]                   }
[13:21:58.191]                   ...future.conditions[[length(...future.conditions) + 
[13:21:58.191]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:58.191]                     cond$call), session = sessionInformation(), 
[13:21:58.191]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:58.191]                   signalCondition(cond)
[13:21:58.191]                 }
[13:21:58.191]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:58.191]                 "immediateCondition"))) {
[13:21:58.191]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:58.191]                   ...future.conditions[[length(...future.conditions) + 
[13:21:58.191]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:58.191]                   if (TRUE && !signal) {
[13:21:58.191]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:58.191]                     {
[13:21:58.191]                       inherits <- base::inherits
[13:21:58.191]                       invokeRestart <- base::invokeRestart
[13:21:58.191]                       is.null <- base::is.null
[13:21:58.191]                       muffled <- FALSE
[13:21:58.191]                       if (inherits(cond, "message")) {
[13:21:58.191]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:58.191]                         if (muffled) 
[13:21:58.191]                           invokeRestart("muffleMessage")
[13:21:58.191]                       }
[13:21:58.191]                       else if (inherits(cond, "warning")) {
[13:21:58.191]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:58.191]                         if (muffled) 
[13:21:58.191]                           invokeRestart("muffleWarning")
[13:21:58.191]                       }
[13:21:58.191]                       else if (inherits(cond, "condition")) {
[13:21:58.191]                         if (!is.null(pattern)) {
[13:21:58.191]                           computeRestarts <- base::computeRestarts
[13:21:58.191]                           grepl <- base::grepl
[13:21:58.191]                           restarts <- computeRestarts(cond)
[13:21:58.191]                           for (restart in restarts) {
[13:21:58.191]                             name <- restart$name
[13:21:58.191]                             if (is.null(name)) 
[13:21:58.191]                               next
[13:21:58.191]                             if (!grepl(pattern, name)) 
[13:21:58.191]                               next
[13:21:58.191]                             invokeRestart(restart)
[13:21:58.191]                             muffled <- TRUE
[13:21:58.191]                             break
[13:21:58.191]                           }
[13:21:58.191]                         }
[13:21:58.191]                       }
[13:21:58.191]                       invisible(muffled)
[13:21:58.191]                     }
[13:21:58.191]                     muffleCondition(cond, pattern = "^muffle")
[13:21:58.191]                   }
[13:21:58.191]                 }
[13:21:58.191]                 else {
[13:21:58.191]                   if (TRUE) {
[13:21:58.191]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:58.191]                     {
[13:21:58.191]                       inherits <- base::inherits
[13:21:58.191]                       invokeRestart <- base::invokeRestart
[13:21:58.191]                       is.null <- base::is.null
[13:21:58.191]                       muffled <- FALSE
[13:21:58.191]                       if (inherits(cond, "message")) {
[13:21:58.191]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:58.191]                         if (muffled) 
[13:21:58.191]                           invokeRestart("muffleMessage")
[13:21:58.191]                       }
[13:21:58.191]                       else if (inherits(cond, "warning")) {
[13:21:58.191]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:58.191]                         if (muffled) 
[13:21:58.191]                           invokeRestart("muffleWarning")
[13:21:58.191]                       }
[13:21:58.191]                       else if (inherits(cond, "condition")) {
[13:21:58.191]                         if (!is.null(pattern)) {
[13:21:58.191]                           computeRestarts <- base::computeRestarts
[13:21:58.191]                           grepl <- base::grepl
[13:21:58.191]                           restarts <- computeRestarts(cond)
[13:21:58.191]                           for (restart in restarts) {
[13:21:58.191]                             name <- restart$name
[13:21:58.191]                             if (is.null(name)) 
[13:21:58.191]                               next
[13:21:58.191]                             if (!grepl(pattern, name)) 
[13:21:58.191]                               next
[13:21:58.191]                             invokeRestart(restart)
[13:21:58.191]                             muffled <- TRUE
[13:21:58.191]                             break
[13:21:58.191]                           }
[13:21:58.191]                         }
[13:21:58.191]                       }
[13:21:58.191]                       invisible(muffled)
[13:21:58.191]                     }
[13:21:58.191]                     muffleCondition(cond, pattern = "^muffle")
[13:21:58.191]                   }
[13:21:58.191]                 }
[13:21:58.191]             }
[13:21:58.191]         }))
[13:21:58.191]     }, error = function(ex) {
[13:21:58.191]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:58.191]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:58.191]                 ...future.rng), started = ...future.startTime, 
[13:21:58.191]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:58.191]             version = "1.8"), class = "FutureResult")
[13:21:58.191]     }, finally = {
[13:21:58.191]         if (!identical(...future.workdir, getwd())) 
[13:21:58.191]             setwd(...future.workdir)
[13:21:58.191]         {
[13:21:58.191]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:58.191]                 ...future.oldOptions$nwarnings <- NULL
[13:21:58.191]             }
[13:21:58.191]             base::options(...future.oldOptions)
[13:21:58.191]             if (.Platform$OS.type == "windows") {
[13:21:58.191]                 old_names <- names(...future.oldEnvVars)
[13:21:58.191]                 envs <- base::Sys.getenv()
[13:21:58.191]                 names <- names(envs)
[13:21:58.191]                 common <- intersect(names, old_names)
[13:21:58.191]                 added <- setdiff(names, old_names)
[13:21:58.191]                 removed <- setdiff(old_names, names)
[13:21:58.191]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:58.191]                   envs[common]]
[13:21:58.191]                 NAMES <- toupper(changed)
[13:21:58.191]                 args <- list()
[13:21:58.191]                 for (kk in seq_along(NAMES)) {
[13:21:58.191]                   name <- changed[[kk]]
[13:21:58.191]                   NAME <- NAMES[[kk]]
[13:21:58.191]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:58.191]                     next
[13:21:58.191]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:58.191]                 }
[13:21:58.191]                 NAMES <- toupper(added)
[13:21:58.191]                 for (kk in seq_along(NAMES)) {
[13:21:58.191]                   name <- added[[kk]]
[13:21:58.191]                   NAME <- NAMES[[kk]]
[13:21:58.191]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:58.191]                     next
[13:21:58.191]                   args[[name]] <- ""
[13:21:58.191]                 }
[13:21:58.191]                 NAMES <- toupper(removed)
[13:21:58.191]                 for (kk in seq_along(NAMES)) {
[13:21:58.191]                   name <- removed[[kk]]
[13:21:58.191]                   NAME <- NAMES[[kk]]
[13:21:58.191]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:58.191]                     next
[13:21:58.191]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:58.191]                 }
[13:21:58.191]                 if (length(args) > 0) 
[13:21:58.191]                   base::do.call(base::Sys.setenv, args = args)
[13:21:58.191]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:58.191]             }
[13:21:58.191]             else {
[13:21:58.191]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:58.191]             }
[13:21:58.191]             {
[13:21:58.191]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:58.191]                   0L) {
[13:21:58.191]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:58.191]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:58.191]                   base::options(opts)
[13:21:58.191]                 }
[13:21:58.191]                 {
[13:21:58.191]                   {
[13:21:58.191]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:58.191]                     NULL
[13:21:58.191]                   }
[13:21:58.191]                   options(future.plan = NULL)
[13:21:58.191]                   if (is.na(NA_character_)) 
[13:21:58.191]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:58.191]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:58.191]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:58.191]                     envir = parent.frame()) 
[13:21:58.191]                   {
[13:21:58.191]                     default_workers <- missing(workers)
[13:21:58.191]                     if (is.function(workers)) 
[13:21:58.191]                       workers <- workers()
[13:21:58.191]                     workers <- structure(as.integer(workers), 
[13:21:58.191]                       class = class(workers))
[13:21:58.191]                     stop_if_not(is.finite(workers), workers >= 
[13:21:58.191]                       1L)
[13:21:58.191]                     if ((workers == 1L && !inherits(workers, 
[13:21:58.191]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:58.191]                       if (default_workers) 
[13:21:58.191]                         supportsMulticore(warn = TRUE)
[13:21:58.191]                       return(sequential(..., envir = envir))
[13:21:58.191]                     }
[13:21:58.191]                     oopts <- options(mc.cores = workers)
[13:21:58.191]                     on.exit(options(oopts))
[13:21:58.191]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:58.191]                       envir = envir)
[13:21:58.191]                     if (!future$lazy) 
[13:21:58.191]                       future <- run(future)
[13:21:58.191]                     invisible(future)
[13:21:58.191]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:58.191]                 }
[13:21:58.191]             }
[13:21:58.191]         }
[13:21:58.191]     })
[13:21:58.191]     if (TRUE) {
[13:21:58.191]         base::sink(type = "output", split = FALSE)
[13:21:58.191]         if (TRUE) {
[13:21:58.191]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:58.191]         }
[13:21:58.191]         else {
[13:21:58.191]             ...future.result["stdout"] <- base::list(NULL)
[13:21:58.191]         }
[13:21:58.191]         base::close(...future.stdout)
[13:21:58.191]         ...future.stdout <- NULL
[13:21:58.191]     }
[13:21:58.191]     ...future.result$conditions <- ...future.conditions
[13:21:58.191]     ...future.result$finished <- base::Sys.time()
[13:21:58.191]     ...future.result
[13:21:58.191] }
[13:21:58.194] assign_globals() ...
[13:21:58.194] List of 5
[13:21:58.194]  $ ...future.FUN            :function (x)  
[13:21:58.194]  $ future.call.arguments    : list()
[13:21:58.194]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:58.194]  $ ...future.elements_ii    :List of 1
[13:21:58.194]   ..$ : int 1
[13:21:58.194]  $ ...future.seeds_ii       : NULL
[13:21:58.194]  $ ...future.globals.maxSize: NULL
[13:21:58.194]  - attr(*, "where")=List of 5
[13:21:58.194]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:58.194]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:58.194]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:58.194]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:58.194]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:58.194]  - attr(*, "resolved")= logi FALSE
[13:21:58.194]  - attr(*, "total_size")= num 4720
[13:21:58.194]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:58.194]  - attr(*, "already-done")= logi TRUE
[13:21:58.199] - reassign environment for ‘...future.FUN’
[13:21:58.199] - copied ‘...future.FUN’ to environment
[13:21:58.199] - copied ‘future.call.arguments’ to environment
[13:21:58.199] - copied ‘...future.elements_ii’ to environment
[13:21:58.199] - copied ‘...future.seeds_ii’ to environment
[13:21:58.199] - copied ‘...future.globals.maxSize’ to environment
[13:21:58.200] assign_globals() ... done
[13:21:58.200] requestCore(): workers = 2
[13:21:58.202] MulticoreFuture started
[13:21:58.202] - Launch lazy future ... done
[13:21:58.203] run() for ‘MulticoreFuture’ ... done
[13:21:58.203] Created future:
[13:21:58.203] plan(): Setting new future strategy stack:
[13:21:58.204] List of future strategies:
[13:21:58.204] 1. sequential:
[13:21:58.204]    - args: function (..., envir = parent.frame())
[13:21:58.204]    - tweaked: FALSE
[13:21:58.204]    - call: NULL
[13:21:58.204] plan(): nbrOfWorkers() = 1
[13:21:58.203] MulticoreFuture:
[13:21:58.203] Label: ‘future_lapply-1’
[13:21:58.203] Expression:
[13:21:58.203] {
[13:21:58.203]     do.call(function(...) {
[13:21:58.203]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:58.203]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:58.203]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:58.203]             on.exit(options(oopts), add = TRUE)
[13:21:58.203]         }
[13:21:58.203]         {
[13:21:58.203]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:58.203]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:58.203]                 ...future.FUN(...future.X_jj, ...)
[13:21:58.203]             })
[13:21:58.203]         }
[13:21:58.203]     }, args = future.call.arguments)
[13:21:58.203] }
[13:21:58.203] Lazy evaluation: FALSE
[13:21:58.203] Asynchronous evaluation: TRUE
[13:21:58.203] Local evaluation: TRUE
[13:21:58.203] Environment: R_GlobalEnv
[13:21:58.203] Capture standard output: TRUE
[13:21:58.203] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:58.203] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:58.203] Packages: <none>
[13:21:58.203] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:58.203] Resolved: FALSE
[13:21:58.203] Value: <not collected>
[13:21:58.203] Conditions captured: <none>
[13:21:58.203] Early signaling: FALSE
[13:21:58.203] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:21:58.203] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:58.217] Chunk #1 of 2 ... DONE
[13:21:58.221] Chunk #2 of 2 ...
[13:21:58.222]  - Finding globals in 'X' for chunk #2 ...
[13:21:58.222] getGlobalsAndPackages() ...
[13:21:58.223] Searching for globals...
[13:21:58.224] 
[13:21:58.224] Searching for globals ... DONE
[13:21:58.224] - globals: [0] <none>
[13:21:58.225] getGlobalsAndPackages() ... DONE
[13:21:58.225]    + additional globals found: [n=0] 
[13:21:58.225]    + additional namespaces needed: [n=0] 
[13:21:58.226]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:58.226]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:58.226]  - seeds: <none>
[13:21:58.226]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:58.227] getGlobalsAndPackages() ...
[13:21:58.227] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:58.227] Resolving globals: FALSE
[13:21:58.228] Tweak future expression to call with '...' arguments ...
[13:21:58.228] {
[13:21:58.228]     do.call(function(...) {
[13:21:58.228]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:58.228]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:58.228]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:58.228]             on.exit(options(oopts), add = TRUE)
[13:21:58.228]         }
[13:21:58.228]         {
[13:21:58.228]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:58.228]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:58.228]                 ...future.FUN(...future.X_jj, ...)
[13:21:58.228]             })
[13:21:58.228]         }
[13:21:58.228]     }, args = future.call.arguments)
[13:21:58.228] }
[13:21:58.228] Tweak future expression to call with '...' arguments ... DONE
[13:21:58.229] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:58.229] 
[13:21:58.229] getGlobalsAndPackages() ... DONE
[13:21:58.230] run() for ‘Future’ ...
[13:21:58.230] - state: ‘created’
[13:21:58.231] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:58.236] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:58.236] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:58.236]   - Field: ‘label’
[13:21:58.237]   - Field: ‘local’
[13:21:58.237]   - Field: ‘owner’
[13:21:58.237]   - Field: ‘envir’
[13:21:58.237]   - Field: ‘workers’
[13:21:58.237]   - Field: ‘packages’
[13:21:58.237]   - Field: ‘gc’
[13:21:58.237]   - Field: ‘job’
[13:21:58.238]   - Field: ‘conditions’
[13:21:58.238]   - Field: ‘expr’
[13:21:58.238]   - Field: ‘uuid’
[13:21:58.238]   - Field: ‘seed’
[13:21:58.238]   - Field: ‘version’
[13:21:58.238]   - Field: ‘result’
[13:21:58.239]   - Field: ‘asynchronous’
[13:21:58.239]   - Field: ‘calls’
[13:21:58.239]   - Field: ‘globals’
[13:21:58.239]   - Field: ‘stdout’
[13:21:58.239]   - Field: ‘earlySignal’
[13:21:58.239]   - Field: ‘lazy’
[13:21:58.239]   - Field: ‘state’
[13:21:58.239] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:58.240] - Launch lazy future ...
[13:21:58.240] Packages needed by the future expression (n = 0): <none>
[13:21:58.240] Packages needed by future strategies (n = 0): <none>
[13:21:58.241] {
[13:21:58.241]     {
[13:21:58.241]         {
[13:21:58.241]             ...future.startTime <- base::Sys.time()
[13:21:58.241]             {
[13:21:58.241]                 {
[13:21:58.241]                   {
[13:21:58.241]                     {
[13:21:58.241]                       base::local({
[13:21:58.241]                         has_future <- base::requireNamespace("future", 
[13:21:58.241]                           quietly = TRUE)
[13:21:58.241]                         if (has_future) {
[13:21:58.241]                           ns <- base::getNamespace("future")
[13:21:58.241]                           version <- ns[[".package"]][["version"]]
[13:21:58.241]                           if (is.null(version)) 
[13:21:58.241]                             version <- utils::packageVersion("future")
[13:21:58.241]                         }
[13:21:58.241]                         else {
[13:21:58.241]                           version <- NULL
[13:21:58.241]                         }
[13:21:58.241]                         if (!has_future || version < "1.8.0") {
[13:21:58.241]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:58.241]                             "", base::R.version$version.string), 
[13:21:58.241]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:58.241]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:58.241]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:58.241]                               "release", "version")], collapse = " "), 
[13:21:58.241]                             hostname = base::Sys.info()[["nodename"]])
[13:21:58.241]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:58.241]                             info)
[13:21:58.241]                           info <- base::paste(info, collapse = "; ")
[13:21:58.241]                           if (!has_future) {
[13:21:58.241]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:58.241]                               info)
[13:21:58.241]                           }
[13:21:58.241]                           else {
[13:21:58.241]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:58.241]                               info, version)
[13:21:58.241]                           }
[13:21:58.241]                           base::stop(msg)
[13:21:58.241]                         }
[13:21:58.241]                       })
[13:21:58.241]                     }
[13:21:58.241]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:58.241]                     base::options(mc.cores = 1L)
[13:21:58.241]                   }
[13:21:58.241]                   options(future.plan = NULL)
[13:21:58.241]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:58.241]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:58.241]                 }
[13:21:58.241]                 ...future.workdir <- getwd()
[13:21:58.241]             }
[13:21:58.241]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:58.241]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:58.241]         }
[13:21:58.241]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:58.241]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:58.241]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:58.241]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:58.241]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:58.241]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:58.241]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:58.241]             base::names(...future.oldOptions))
[13:21:58.241]     }
[13:21:58.241]     if (FALSE) {
[13:21:58.241]     }
[13:21:58.241]     else {
[13:21:58.241]         if (TRUE) {
[13:21:58.241]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:58.241]                 open = "w")
[13:21:58.241]         }
[13:21:58.241]         else {
[13:21:58.241]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:58.241]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:58.241]         }
[13:21:58.241]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:58.241]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:58.241]             base::sink(type = "output", split = FALSE)
[13:21:58.241]             base::close(...future.stdout)
[13:21:58.241]         }, add = TRUE)
[13:21:58.241]     }
[13:21:58.241]     ...future.frame <- base::sys.nframe()
[13:21:58.241]     ...future.conditions <- base::list()
[13:21:58.241]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:58.241]     if (FALSE) {
[13:21:58.241]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:58.241]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:58.241]     }
[13:21:58.241]     ...future.result <- base::tryCatch({
[13:21:58.241]         base::withCallingHandlers({
[13:21:58.241]             ...future.value <- base::withVisible(base::local({
[13:21:58.241]                 withCallingHandlers({
[13:21:58.241]                   {
[13:21:58.241]                     do.call(function(...) {
[13:21:58.241]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:58.241]                       if (!identical(...future.globals.maxSize.org, 
[13:21:58.241]                         ...future.globals.maxSize)) {
[13:21:58.241]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:58.241]                         on.exit(options(oopts), add = TRUE)
[13:21:58.241]                       }
[13:21:58.241]                       {
[13:21:58.241]                         lapply(seq_along(...future.elements_ii), 
[13:21:58.241]                           FUN = function(jj) {
[13:21:58.241]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:58.241]                             ...future.FUN(...future.X_jj, ...)
[13:21:58.241]                           })
[13:21:58.241]                       }
[13:21:58.241]                     }, args = future.call.arguments)
[13:21:58.241]                   }
[13:21:58.241]                 }, immediateCondition = function(cond) {
[13:21:58.241]                   save_rds <- function (object, pathname, ...) 
[13:21:58.241]                   {
[13:21:58.241]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:58.241]                     if (file_test("-f", pathname_tmp)) {
[13:21:58.241]                       fi_tmp <- file.info(pathname_tmp)
[13:21:58.241]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:58.241]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:58.241]                         fi_tmp[["mtime"]])
[13:21:58.241]                     }
[13:21:58.241]                     tryCatch({
[13:21:58.241]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:58.241]                     }, error = function(ex) {
[13:21:58.241]                       msg <- conditionMessage(ex)
[13:21:58.241]                       fi_tmp <- file.info(pathname_tmp)
[13:21:58.241]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:58.241]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:58.241]                         fi_tmp[["mtime"]], msg)
[13:21:58.241]                       ex$message <- msg
[13:21:58.241]                       stop(ex)
[13:21:58.241]                     })
[13:21:58.241]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:58.241]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:58.241]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:58.241]                       fi_tmp <- file.info(pathname_tmp)
[13:21:58.241]                       fi <- file.info(pathname)
[13:21:58.241]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:58.241]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:58.241]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:58.241]                         fi[["size"]], fi[["mtime"]])
[13:21:58.241]                       stop(msg)
[13:21:58.241]                     }
[13:21:58.241]                     invisible(pathname)
[13:21:58.241]                   }
[13:21:58.241]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:58.241]                     rootPath = tempdir()) 
[13:21:58.241]                   {
[13:21:58.241]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:58.241]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:58.241]                       tmpdir = path, fileext = ".rds")
[13:21:58.241]                     save_rds(obj, file)
[13:21:58.241]                   }
[13:21:58.241]                   saveImmediateCondition(cond, path = "/tmp/Rtmp78O1Lc/.future/immediateConditions")
[13:21:58.241]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:58.241]                   {
[13:21:58.241]                     inherits <- base::inherits
[13:21:58.241]                     invokeRestart <- base::invokeRestart
[13:21:58.241]                     is.null <- base::is.null
[13:21:58.241]                     muffled <- FALSE
[13:21:58.241]                     if (inherits(cond, "message")) {
[13:21:58.241]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:58.241]                       if (muffled) 
[13:21:58.241]                         invokeRestart("muffleMessage")
[13:21:58.241]                     }
[13:21:58.241]                     else if (inherits(cond, "warning")) {
[13:21:58.241]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:58.241]                       if (muffled) 
[13:21:58.241]                         invokeRestart("muffleWarning")
[13:21:58.241]                     }
[13:21:58.241]                     else if (inherits(cond, "condition")) {
[13:21:58.241]                       if (!is.null(pattern)) {
[13:21:58.241]                         computeRestarts <- base::computeRestarts
[13:21:58.241]                         grepl <- base::grepl
[13:21:58.241]                         restarts <- computeRestarts(cond)
[13:21:58.241]                         for (restart in restarts) {
[13:21:58.241]                           name <- restart$name
[13:21:58.241]                           if (is.null(name)) 
[13:21:58.241]                             next
[13:21:58.241]                           if (!grepl(pattern, name)) 
[13:21:58.241]                             next
[13:21:58.241]                           invokeRestart(restart)
[13:21:58.241]                           muffled <- TRUE
[13:21:58.241]                           break
[13:21:58.241]                         }
[13:21:58.241]                       }
[13:21:58.241]                     }
[13:21:58.241]                     invisible(muffled)
[13:21:58.241]                   }
[13:21:58.241]                   muffleCondition(cond)
[13:21:58.241]                 })
[13:21:58.241]             }))
[13:21:58.241]             future::FutureResult(value = ...future.value$value, 
[13:21:58.241]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:58.241]                   ...future.rng), globalenv = if (FALSE) 
[13:21:58.241]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:58.241]                     ...future.globalenv.names))
[13:21:58.241]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:58.241]         }, condition = base::local({
[13:21:58.241]             c <- base::c
[13:21:58.241]             inherits <- base::inherits
[13:21:58.241]             invokeRestart <- base::invokeRestart
[13:21:58.241]             length <- base::length
[13:21:58.241]             list <- base::list
[13:21:58.241]             seq.int <- base::seq.int
[13:21:58.241]             signalCondition <- base::signalCondition
[13:21:58.241]             sys.calls <- base::sys.calls
[13:21:58.241]             `[[` <- base::`[[`
[13:21:58.241]             `+` <- base::`+`
[13:21:58.241]             `<<-` <- base::`<<-`
[13:21:58.241]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:58.241]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:58.241]                   3L)]
[13:21:58.241]             }
[13:21:58.241]             function(cond) {
[13:21:58.241]                 is_error <- inherits(cond, "error")
[13:21:58.241]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:58.241]                   NULL)
[13:21:58.241]                 if (is_error) {
[13:21:58.241]                   sessionInformation <- function() {
[13:21:58.241]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:58.241]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:58.241]                       search = base::search(), system = base::Sys.info())
[13:21:58.241]                   }
[13:21:58.241]                   ...future.conditions[[length(...future.conditions) + 
[13:21:58.241]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:58.241]                     cond$call), session = sessionInformation(), 
[13:21:58.241]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:58.241]                   signalCondition(cond)
[13:21:58.241]                 }
[13:21:58.241]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:58.241]                 "immediateCondition"))) {
[13:21:58.241]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:58.241]                   ...future.conditions[[length(...future.conditions) + 
[13:21:58.241]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:58.241]                   if (TRUE && !signal) {
[13:21:58.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:58.241]                     {
[13:21:58.241]                       inherits <- base::inherits
[13:21:58.241]                       invokeRestart <- base::invokeRestart
[13:21:58.241]                       is.null <- base::is.null
[13:21:58.241]                       muffled <- FALSE
[13:21:58.241]                       if (inherits(cond, "message")) {
[13:21:58.241]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:58.241]                         if (muffled) 
[13:21:58.241]                           invokeRestart("muffleMessage")
[13:21:58.241]                       }
[13:21:58.241]                       else if (inherits(cond, "warning")) {
[13:21:58.241]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:58.241]                         if (muffled) 
[13:21:58.241]                           invokeRestart("muffleWarning")
[13:21:58.241]                       }
[13:21:58.241]                       else if (inherits(cond, "condition")) {
[13:21:58.241]                         if (!is.null(pattern)) {
[13:21:58.241]                           computeRestarts <- base::computeRestarts
[13:21:58.241]                           grepl <- base::grepl
[13:21:58.241]                           restarts <- computeRestarts(cond)
[13:21:58.241]                           for (restart in restarts) {
[13:21:58.241]                             name <- restart$name
[13:21:58.241]                             if (is.null(name)) 
[13:21:58.241]                               next
[13:21:58.241]                             if (!grepl(pattern, name)) 
[13:21:58.241]                               next
[13:21:58.241]                             invokeRestart(restart)
[13:21:58.241]                             muffled <- TRUE
[13:21:58.241]                             break
[13:21:58.241]                           }
[13:21:58.241]                         }
[13:21:58.241]                       }
[13:21:58.241]                       invisible(muffled)
[13:21:58.241]                     }
[13:21:58.241]                     muffleCondition(cond, pattern = "^muffle")
[13:21:58.241]                   }
[13:21:58.241]                 }
[13:21:58.241]                 else {
[13:21:58.241]                   if (TRUE) {
[13:21:58.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:58.241]                     {
[13:21:58.241]                       inherits <- base::inherits
[13:21:58.241]                       invokeRestart <- base::invokeRestart
[13:21:58.241]                       is.null <- base::is.null
[13:21:58.241]                       muffled <- FALSE
[13:21:58.241]                       if (inherits(cond, "message")) {
[13:21:58.241]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:58.241]                         if (muffled) 
[13:21:58.241]                           invokeRestart("muffleMessage")
[13:21:58.241]                       }
[13:21:58.241]                       else if (inherits(cond, "warning")) {
[13:21:58.241]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:58.241]                         if (muffled) 
[13:21:58.241]                           invokeRestart("muffleWarning")
[13:21:58.241]                       }
[13:21:58.241]                       else if (inherits(cond, "condition")) {
[13:21:58.241]                         if (!is.null(pattern)) {
[13:21:58.241]                           computeRestarts <- base::computeRestarts
[13:21:58.241]                           grepl <- base::grepl
[13:21:58.241]                           restarts <- computeRestarts(cond)
[13:21:58.241]                           for (restart in restarts) {
[13:21:58.241]                             name <- restart$name
[13:21:58.241]                             if (is.null(name)) 
[13:21:58.241]                               next
[13:21:58.241]                             if (!grepl(pattern, name)) 
[13:21:58.241]                               next
[13:21:58.241]                             invokeRestart(restart)
[13:21:58.241]                             muffled <- TRUE
[13:21:58.241]                             break
[13:21:58.241]                           }
[13:21:58.241]                         }
[13:21:58.241]                       }
[13:21:58.241]                       invisible(muffled)
[13:21:58.241]                     }
[13:21:58.241]                     muffleCondition(cond, pattern = "^muffle")
[13:21:58.241]                   }
[13:21:58.241]                 }
[13:21:58.241]             }
[13:21:58.241]         }))
[13:21:58.241]     }, error = function(ex) {
[13:21:58.241]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:58.241]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:58.241]                 ...future.rng), started = ...future.startTime, 
[13:21:58.241]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:58.241]             version = "1.8"), class = "FutureResult")
[13:21:58.241]     }, finally = {
[13:21:58.241]         if (!identical(...future.workdir, getwd())) 
[13:21:58.241]             setwd(...future.workdir)
[13:21:58.241]         {
[13:21:58.241]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:58.241]                 ...future.oldOptions$nwarnings <- NULL
[13:21:58.241]             }
[13:21:58.241]             base::options(...future.oldOptions)
[13:21:58.241]             if (.Platform$OS.type == "windows") {
[13:21:58.241]                 old_names <- names(...future.oldEnvVars)
[13:21:58.241]                 envs <- base::Sys.getenv()
[13:21:58.241]                 names <- names(envs)
[13:21:58.241]                 common <- intersect(names, old_names)
[13:21:58.241]                 added <- setdiff(names, old_names)
[13:21:58.241]                 removed <- setdiff(old_names, names)
[13:21:58.241]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:58.241]                   envs[common]]
[13:21:58.241]                 NAMES <- toupper(changed)
[13:21:58.241]                 args <- list()
[13:21:58.241]                 for (kk in seq_along(NAMES)) {
[13:21:58.241]                   name <- changed[[kk]]
[13:21:58.241]                   NAME <- NAMES[[kk]]
[13:21:58.241]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:58.241]                     next
[13:21:58.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:58.241]                 }
[13:21:58.241]                 NAMES <- toupper(added)
[13:21:58.241]                 for (kk in seq_along(NAMES)) {
[13:21:58.241]                   name <- added[[kk]]
[13:21:58.241]                   NAME <- NAMES[[kk]]
[13:21:58.241]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:58.241]                     next
[13:21:58.241]                   args[[name]] <- ""
[13:21:58.241]                 }
[13:21:58.241]                 NAMES <- toupper(removed)
[13:21:58.241]                 for (kk in seq_along(NAMES)) {
[13:21:58.241]                   name <- removed[[kk]]
[13:21:58.241]                   NAME <- NAMES[[kk]]
[13:21:58.241]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:58.241]                     next
[13:21:58.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:58.241]                 }
[13:21:58.241]                 if (length(args) > 0) 
[13:21:58.241]                   base::do.call(base::Sys.setenv, args = args)
[13:21:58.241]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:58.241]             }
[13:21:58.241]             else {
[13:21:58.241]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:58.241]             }
[13:21:58.241]             {
[13:21:58.241]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:58.241]                   0L) {
[13:21:58.241]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:58.241]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:58.241]                   base::options(opts)
[13:21:58.241]                 }
[13:21:58.241]                 {
[13:21:58.241]                   {
[13:21:58.241]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:58.241]                     NULL
[13:21:58.241]                   }
[13:21:58.241]                   options(future.plan = NULL)
[13:21:58.241]                   if (is.na(NA_character_)) 
[13:21:58.241]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:58.241]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:58.241]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:58.241]                     envir = parent.frame()) 
[13:21:58.241]                   {
[13:21:58.241]                     default_workers <- missing(workers)
[13:21:58.241]                     if (is.function(workers)) 
[13:21:58.241]                       workers <- workers()
[13:21:58.241]                     workers <- structure(as.integer(workers), 
[13:21:58.241]                       class = class(workers))
[13:21:58.241]                     stop_if_not(is.finite(workers), workers >= 
[13:21:58.241]                       1L)
[13:21:58.241]                     if ((workers == 1L && !inherits(workers, 
[13:21:58.241]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:58.241]                       if (default_workers) 
[13:21:58.241]                         supportsMulticore(warn = TRUE)
[13:21:58.241]                       return(sequential(..., envir = envir))
[13:21:58.241]                     }
[13:21:58.241]                     oopts <- options(mc.cores = workers)
[13:21:58.241]                     on.exit(options(oopts))
[13:21:58.241]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:58.241]                       envir = envir)
[13:21:58.241]                     if (!future$lazy) 
[13:21:58.241]                       future <- run(future)
[13:21:58.241]                     invisible(future)
[13:21:58.241]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:58.241]                 }
[13:21:58.241]             }
[13:21:58.241]         }
[13:21:58.241]     })
[13:21:58.241]     if (TRUE) {
[13:21:58.241]         base::sink(type = "output", split = FALSE)
[13:21:58.241]         if (TRUE) {
[13:21:58.241]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:58.241]         }
[13:21:58.241]         else {
[13:21:58.241]             ...future.result["stdout"] <- base::list(NULL)
[13:21:58.241]         }
[13:21:58.241]         base::close(...future.stdout)
[13:21:58.241]         ...future.stdout <- NULL
[13:21:58.241]     }
[13:21:58.241]     ...future.result$conditions <- ...future.conditions
[13:21:58.241]     ...future.result$finished <- base::Sys.time()
[13:21:58.241]     ...future.result
[13:21:58.241] }
[13:21:58.244] assign_globals() ...
[13:21:58.244] List of 5
[13:21:58.244]  $ ...future.FUN            :function (x)  
[13:21:58.244]  $ future.call.arguments    : list()
[13:21:58.244]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:58.244]  $ ...future.elements_ii    :List of 1
[13:21:58.244]   ..$ : int 0
[13:21:58.244]  $ ...future.seeds_ii       : NULL
[13:21:58.244]  $ ...future.globals.maxSize: NULL
[13:21:58.244]  - attr(*, "where")=List of 5
[13:21:58.244]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:58.244]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:58.244]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:58.244]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:58.244]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:58.244]  - attr(*, "resolved")= logi FALSE
[13:21:58.244]  - attr(*, "total_size")= num 4720
[13:21:58.244]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:58.244]  - attr(*, "already-done")= logi TRUE
[13:21:58.251] - reassign environment for ‘...future.FUN’
[13:21:58.251] - copied ‘...future.FUN’ to environment
[13:21:58.251] - copied ‘future.call.arguments’ to environment
[13:21:58.251] - copied ‘...future.elements_ii’ to environment
[13:21:58.251] - copied ‘...future.seeds_ii’ to environment
[13:21:58.251] - copied ‘...future.globals.maxSize’ to environment
[13:21:58.251] assign_globals() ... done
[13:21:58.252] requestCore(): workers = 2
[13:21:58.254] MulticoreFuture started
[13:21:58.254] - Launch lazy future ... done
[13:21:58.255] run() for ‘MulticoreFuture’ ... done
[13:21:58.255] Created future:
[13:21:58.255] plan(): Setting new future strategy stack:
[13:21:58.255] List of future strategies:
[13:21:58.255] 1. sequential:
[13:21:58.255]    - args: function (..., envir = parent.frame())
[13:21:58.255]    - tweaked: FALSE
[13:21:58.255]    - call: NULL
[13:21:58.256] plan(): nbrOfWorkers() = 1
[13:21:58.258] plan(): Setting new future strategy stack:
[13:21:58.259] List of future strategies:
[13:21:58.259] 1. multicore:
[13:21:58.259]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:58.259]    - tweaked: FALSE
[13:21:58.259]    - call: plan(strategy)
[13:21:58.264] plan(): nbrOfWorkers() = 2
[13:21:58.255] MulticoreFuture:
[13:21:58.255] Label: ‘future_lapply-2’
[13:21:58.255] Expression:
[13:21:58.255] {
[13:21:58.255]     do.call(function(...) {
[13:21:58.255]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:58.255]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:58.255]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:58.255]             on.exit(options(oopts), add = TRUE)
[13:21:58.255]         }
[13:21:58.255]         {
[13:21:58.255]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:58.255]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:58.255]                 ...future.FUN(...future.X_jj, ...)
[13:21:58.255]             })
[13:21:58.255]         }
[13:21:58.255]     }, args = future.call.arguments)
[13:21:58.255] }
[13:21:58.255] Lazy evaluation: FALSE
[13:21:58.255] Asynchronous evaluation: TRUE
[13:21:58.255] Local evaluation: TRUE
[13:21:58.255] Environment: R_GlobalEnv
[13:21:58.255] Capture standard output: TRUE
[13:21:58.255] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:58.255] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:58.255] Packages: <none>
[13:21:58.255] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:58.255] Resolved: TRUE
[13:21:58.255] Value: <not collected>
[13:21:58.255] Conditions captured: <none>
[13:21:58.255] Early signaling: FALSE
[13:21:58.255] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:21:58.255] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:58.265] Chunk #2 of 2 ... DONE
[13:21:58.265] Launching 2 futures (chunks) ... DONE
[13:21:58.265] Resolving 2 futures (chunks) ...
[13:21:58.266] resolve() on list ...
[13:21:58.266]  recursive: 0
[13:21:58.266]  length: 2
[13:21:58.266] 
[13:21:58.277] Future #2
[13:21:58.277] result() for MulticoreFuture ...
[13:21:58.278] result() for MulticoreFuture ...
[13:21:58.278] result() for MulticoreFuture ... done
[13:21:58.278] result() for MulticoreFuture ... done
[13:21:58.278] result() for MulticoreFuture ...
[13:21:58.278] result() for MulticoreFuture ... done
[13:21:58.279] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:21:58.279] - nx: 2
[13:21:58.279] - relay: TRUE
[13:21:58.279] - stdout: TRUE
[13:21:58.279] - signal: TRUE
[13:21:58.279] - resignal: FALSE
[13:21:58.279] - force: TRUE
[13:21:58.280] - relayed: [n=2] FALSE, FALSE
[13:21:58.280] - queued futures: [n=2] FALSE, FALSE
[13:21:58.280]  - until=1
[13:21:58.280]  - relaying element #1
[13:21:58.280] - relayed: [n=2] FALSE, FALSE
[13:21:58.281] - queued futures: [n=2] FALSE, TRUE
[13:21:58.281] signalConditionsASAP(NULL, pos=2) ... done
[13:21:58.281]  length: 1 (resolved future 2)
[13:21:58.707] plan(): Setting new future strategy stack:
[13:21:58.708] List of future strategies:
[13:21:58.708] 1. multicore:
[13:21:58.708]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:58.708]    - tweaked: FALSE
[13:21:58.708]    - call: plan(strategy)
[13:21:58.716] plan(): nbrOfWorkers() = 2
[13:21:58.721] Future #1
[13:21:58.722] result() for MulticoreFuture ...
[13:21:58.722] result() for MulticoreFuture ...
[13:21:58.723] result() for MulticoreFuture ... done
[13:21:58.723] result() for MulticoreFuture ... done
[13:21:58.725] result() for MulticoreFuture ...
[13:21:58.725] result() for MulticoreFuture ... done
[13:21:58.726] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:21:58.726] - nx: 2
[13:21:58.726] - relay: TRUE
[13:21:58.726] - stdout: TRUE
[13:21:58.726] - signal: TRUE
[13:21:58.727] - resignal: FALSE
[13:21:58.727] - force: TRUE
[13:21:58.727] - relayed: [n=2] FALSE, FALSE
[13:21:58.727] - queued futures: [n=2] FALSE, TRUE
[13:21:58.727]  - until=1
[13:21:58.727]  - relaying element #1
[13:21:58.728] result() for MulticoreFuture ...
[13:21:58.728] result() for MulticoreFuture ... done
[13:21:58.728] result() for MulticoreFuture ...
[13:21:58.728] result() for MulticoreFuture ... done
[13:21:58.728] result() for MulticoreFuture ...
[13:21:58.728] result() for MulticoreFuture ... done
[13:21:58.729] result() for MulticoreFuture ...
[13:21:58.729] result() for MulticoreFuture ... done
[13:21:58.729] - relayed: [n=2] TRUE, FALSE
[13:21:58.729] - queued futures: [n=2] TRUE, TRUE
[13:21:58.729] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:21:58.729]  length: 0 (resolved future 1)
[13:21:58.729] Relaying remaining futures
[13:21:58.729] signalConditionsASAP(NULL, pos=0) ...
[13:21:58.730] - nx: 2
[13:21:58.730] - relay: TRUE
[13:21:58.730] - stdout: TRUE
[13:21:58.730] - signal: TRUE
[13:21:58.730] - resignal: FALSE
[13:21:58.730] - force: TRUE
[13:21:58.730] - relayed: [n=2] TRUE, FALSE
[13:21:58.730] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:58.731]  - relaying element #2
[13:21:58.731] result() for MulticoreFuture ...
[13:21:58.731] result() for MulticoreFuture ... done
[13:21:58.731] result() for MulticoreFuture ...
[13:21:58.731] result() for MulticoreFuture ... done
[13:21:58.731] result() for MulticoreFuture ...
[13:21:58.731] result() for MulticoreFuture ... done
[13:21:58.731] result() for MulticoreFuture ...
[13:21:58.732] result() for MulticoreFuture ... done
[13:21:58.732] - relayed: [n=2] TRUE, TRUE
[13:21:58.732] - queued futures: [n=2] TRUE, TRUE
[13:21:58.732] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[13:21:58.732] resolve() on list ... DONE
[13:21:58.732] result() for MulticoreFuture ...
[13:21:58.732] result() for MulticoreFuture ... done
[13:21:58.733] result() for MulticoreFuture ...
[13:21:58.733] result() for MulticoreFuture ... done
[13:21:58.733] result() for MulticoreFuture ...
[13:21:58.733] result() for MulticoreFuture ... done
[13:21:58.733] result() for MulticoreFuture ...
[13:21:58.733] result() for MulticoreFuture ... done
[13:21:58.733]  - Number of value chunks collected: 2
[13:21:58.733] Resolving 2 futures (chunks) ... DONE
[13:21:58.733] Reducing values from 2 chunks ...
[13:21:58.734]  - Number of values collected after concatenation: 2
[13:21:58.734]  - Number of values expected: 2
[13:21:58.734] Reducing values from 2 chunks ... DONE
[13:21:58.734] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[13:21:58.734] future_lapply() ...
[13:21:58.739] Number of chunks: 2
[13:21:58.739] getGlobalsAndPackagesXApply() ...
[13:21:58.739]  - future.globals: TRUE
[13:21:58.740] getGlobalsAndPackages() ...
[13:21:58.740] Searching for globals...
[13:21:58.741] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:21:58.741] Searching for globals ... DONE
[13:21:58.742] Resolving globals: FALSE
[13:21:58.742] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:21:58.742] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:21:58.743] - globals: [1] ‘FUN’
[13:21:58.743] 
[13:21:58.743] getGlobalsAndPackages() ... DONE
[13:21:58.743]  - globals found/used: [n=1] ‘FUN’
[13:21:58.743]  - needed namespaces: [n=0] 
[13:21:58.743] Finding globals ... DONE
[13:21:58.743]  - use_args: TRUE
[13:21:58.743]  - Getting '...' globals ...
[13:21:58.744] resolve() on list ...
[13:21:58.744]  recursive: 0
[13:21:58.744]  length: 1
[13:21:58.744]  elements: ‘...’
[13:21:58.744]  length: 0 (resolved future 1)
[13:21:58.744] resolve() on list ... DONE
[13:21:58.744]    - '...' content: [n=0] 
[13:21:58.744] List of 1
[13:21:58.744]  $ ...: list()
[13:21:58.744]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:58.744]  - attr(*, "where")=List of 1
[13:21:58.744]   ..$ ...:<environment: 0x55dd72512740> 
[13:21:58.744]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:58.744]  - attr(*, "resolved")= logi TRUE
[13:21:58.744]  - attr(*, "total_size")= num NA
[13:21:58.747]  - Getting '...' globals ... DONE
[13:21:58.747] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:21:58.748] List of 2
[13:21:58.748]  $ ...future.FUN:function (x)  
[13:21:58.748]  $ ...          : list()
[13:21:58.748]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:58.748]  - attr(*, "where")=List of 2
[13:21:58.748]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:58.748]   ..$ ...          :<environment: 0x55dd72512740> 
[13:21:58.748]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:58.748]  - attr(*, "resolved")= logi FALSE
[13:21:58.748]  - attr(*, "total_size")= num 4720
[13:21:58.750] Packages to be attached in all futures: [n=0] 
[13:21:58.750] getGlobalsAndPackagesXApply() ... DONE
[13:21:58.751] Number of futures (= number of chunks): 2
[13:21:58.751] Launching 2 futures (chunks) ...
[13:21:58.751] Chunk #1 of 2 ...
[13:21:58.751]  - Finding globals in 'X' for chunk #1 ...
[13:21:58.751] getGlobalsAndPackages() ...
[13:21:58.751] Searching for globals...
[13:21:58.751] 
[13:21:58.752] Searching for globals ... DONE
[13:21:58.752] - globals: [0] <none>
[13:21:58.752] getGlobalsAndPackages() ... DONE
[13:21:58.752]    + additional globals found: [n=0] 
[13:21:58.752]    + additional namespaces needed: [n=0] 
[13:21:58.752]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:58.754]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:58.754]  - seeds: <none>
[13:21:58.754]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:58.754] getGlobalsAndPackages() ...
[13:21:58.754] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:58.754] Resolving globals: FALSE
[13:21:58.755] Tweak future expression to call with '...' arguments ...
[13:21:58.755] {
[13:21:58.755]     do.call(function(...) {
[13:21:58.755]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:58.755]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:58.755]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:58.755]             on.exit(options(oopts), add = TRUE)
[13:21:58.755]         }
[13:21:58.755]         {
[13:21:58.755]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:58.755]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:58.755]                 ...future.FUN(...future.X_jj, ...)
[13:21:58.755]             })
[13:21:58.755]         }
[13:21:58.755]     }, args = future.call.arguments)
[13:21:58.755] }
[13:21:58.755] Tweak future expression to call with '...' arguments ... DONE
[13:21:58.755] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:58.756] 
[13:21:58.756] getGlobalsAndPackages() ... DONE
[13:21:58.756] run() for ‘Future’ ...
[13:21:58.756] - state: ‘created’
[13:21:58.756] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:58.760] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:58.760] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:58.760]   - Field: ‘label’
[13:21:58.760]   - Field: ‘local’
[13:21:58.760]   - Field: ‘owner’
[13:21:58.761]   - Field: ‘envir’
[13:21:58.761]   - Field: ‘workers’
[13:21:58.761]   - Field: ‘packages’
[13:21:58.761]   - Field: ‘gc’
[13:21:58.761]   - Field: ‘job’
[13:21:58.761]   - Field: ‘conditions’
[13:21:58.761]   - Field: ‘expr’
[13:21:58.761]   - Field: ‘uuid’
[13:21:58.761]   - Field: ‘seed’
[13:21:58.761]   - Field: ‘version’
[13:21:58.762]   - Field: ‘result’
[13:21:58.762]   - Field: ‘asynchronous’
[13:21:58.762]   - Field: ‘calls’
[13:21:58.762]   - Field: ‘globals’
[13:21:58.762]   - Field: ‘stdout’
[13:21:58.762]   - Field: ‘earlySignal’
[13:21:58.762]   - Field: ‘lazy’
[13:21:58.762]   - Field: ‘state’
[13:21:58.762] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:58.762] - Launch lazy future ...
[13:21:58.763] Packages needed by the future expression (n = 0): <none>
[13:21:58.763] Packages needed by future strategies (n = 0): <none>
[13:21:58.763] {
[13:21:58.763]     {
[13:21:58.763]         {
[13:21:58.763]             ...future.startTime <- base::Sys.time()
[13:21:58.763]             {
[13:21:58.763]                 {
[13:21:58.763]                   {
[13:21:58.763]                     {
[13:21:58.763]                       base::local({
[13:21:58.763]                         has_future <- base::requireNamespace("future", 
[13:21:58.763]                           quietly = TRUE)
[13:21:58.763]                         if (has_future) {
[13:21:58.763]                           ns <- base::getNamespace("future")
[13:21:58.763]                           version <- ns[[".package"]][["version"]]
[13:21:58.763]                           if (is.null(version)) 
[13:21:58.763]                             version <- utils::packageVersion("future")
[13:21:58.763]                         }
[13:21:58.763]                         else {
[13:21:58.763]                           version <- NULL
[13:21:58.763]                         }
[13:21:58.763]                         if (!has_future || version < "1.8.0") {
[13:21:58.763]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:58.763]                             "", base::R.version$version.string), 
[13:21:58.763]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:58.763]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:58.763]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:58.763]                               "release", "version")], collapse = " "), 
[13:21:58.763]                             hostname = base::Sys.info()[["nodename"]])
[13:21:58.763]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:58.763]                             info)
[13:21:58.763]                           info <- base::paste(info, collapse = "; ")
[13:21:58.763]                           if (!has_future) {
[13:21:58.763]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:58.763]                               info)
[13:21:58.763]                           }
[13:21:58.763]                           else {
[13:21:58.763]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:58.763]                               info, version)
[13:21:58.763]                           }
[13:21:58.763]                           base::stop(msg)
[13:21:58.763]                         }
[13:21:58.763]                       })
[13:21:58.763]                     }
[13:21:58.763]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:58.763]                     base::options(mc.cores = 1L)
[13:21:58.763]                   }
[13:21:58.763]                   options(future.plan = NULL)
[13:21:58.763]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:58.763]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:58.763]                 }
[13:21:58.763]                 ...future.workdir <- getwd()
[13:21:58.763]             }
[13:21:58.763]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:58.763]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:58.763]         }
[13:21:58.763]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:58.763]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:58.763]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:58.763]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:58.763]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:58.763]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:58.763]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:58.763]             base::names(...future.oldOptions))
[13:21:58.763]     }
[13:21:58.763]     if (TRUE) {
[13:21:58.763]     }
[13:21:58.763]     else {
[13:21:58.763]         if (NA) {
[13:21:58.763]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:58.763]                 open = "w")
[13:21:58.763]         }
[13:21:58.763]         else {
[13:21:58.763]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:58.763]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:58.763]         }
[13:21:58.763]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:58.763]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:58.763]             base::sink(type = "output", split = FALSE)
[13:21:58.763]             base::close(...future.stdout)
[13:21:58.763]         }, add = TRUE)
[13:21:58.763]     }
[13:21:58.763]     ...future.frame <- base::sys.nframe()
[13:21:58.763]     ...future.conditions <- base::list()
[13:21:58.763]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:58.763]     if (FALSE) {
[13:21:58.763]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:58.763]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:58.763]     }
[13:21:58.763]     ...future.result <- base::tryCatch({
[13:21:58.763]         base::withCallingHandlers({
[13:21:58.763]             ...future.value <- base::withVisible(base::local({
[13:21:58.763]                 withCallingHandlers({
[13:21:58.763]                   {
[13:21:58.763]                     do.call(function(...) {
[13:21:58.763]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:58.763]                       if (!identical(...future.globals.maxSize.org, 
[13:21:58.763]                         ...future.globals.maxSize)) {
[13:21:58.763]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:58.763]                         on.exit(options(oopts), add = TRUE)
[13:21:58.763]                       }
[13:21:58.763]                       {
[13:21:58.763]                         lapply(seq_along(...future.elements_ii), 
[13:21:58.763]                           FUN = function(jj) {
[13:21:58.763]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:58.763]                             ...future.FUN(...future.X_jj, ...)
[13:21:58.763]                           })
[13:21:58.763]                       }
[13:21:58.763]                     }, args = future.call.arguments)
[13:21:58.763]                   }
[13:21:58.763]                 }, immediateCondition = function(cond) {
[13:21:58.763]                   save_rds <- function (object, pathname, ...) 
[13:21:58.763]                   {
[13:21:58.763]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:58.763]                     if (file_test("-f", pathname_tmp)) {
[13:21:58.763]                       fi_tmp <- file.info(pathname_tmp)
[13:21:58.763]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:58.763]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:58.763]                         fi_tmp[["mtime"]])
[13:21:58.763]                     }
[13:21:58.763]                     tryCatch({
[13:21:58.763]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:58.763]                     }, error = function(ex) {
[13:21:58.763]                       msg <- conditionMessage(ex)
[13:21:58.763]                       fi_tmp <- file.info(pathname_tmp)
[13:21:58.763]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:58.763]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:58.763]                         fi_tmp[["mtime"]], msg)
[13:21:58.763]                       ex$message <- msg
[13:21:58.763]                       stop(ex)
[13:21:58.763]                     })
[13:21:58.763]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:58.763]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:58.763]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:58.763]                       fi_tmp <- file.info(pathname_tmp)
[13:21:58.763]                       fi <- file.info(pathname)
[13:21:58.763]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:58.763]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:58.763]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:58.763]                         fi[["size"]], fi[["mtime"]])
[13:21:58.763]                       stop(msg)
[13:21:58.763]                     }
[13:21:58.763]                     invisible(pathname)
[13:21:58.763]                   }
[13:21:58.763]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:58.763]                     rootPath = tempdir()) 
[13:21:58.763]                   {
[13:21:58.763]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:58.763]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:58.763]                       tmpdir = path, fileext = ".rds")
[13:21:58.763]                     save_rds(obj, file)
[13:21:58.763]                   }
[13:21:58.763]                   saveImmediateCondition(cond, path = "/tmp/Rtmp78O1Lc/.future/immediateConditions")
[13:21:58.763]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:58.763]                   {
[13:21:58.763]                     inherits <- base::inherits
[13:21:58.763]                     invokeRestart <- base::invokeRestart
[13:21:58.763]                     is.null <- base::is.null
[13:21:58.763]                     muffled <- FALSE
[13:21:58.763]                     if (inherits(cond, "message")) {
[13:21:58.763]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:58.763]                       if (muffled) 
[13:21:58.763]                         invokeRestart("muffleMessage")
[13:21:58.763]                     }
[13:21:58.763]                     else if (inherits(cond, "warning")) {
[13:21:58.763]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:58.763]                       if (muffled) 
[13:21:58.763]                         invokeRestart("muffleWarning")
[13:21:58.763]                     }
[13:21:58.763]                     else if (inherits(cond, "condition")) {
[13:21:58.763]                       if (!is.null(pattern)) {
[13:21:58.763]                         computeRestarts <- base::computeRestarts
[13:21:58.763]                         grepl <- base::grepl
[13:21:58.763]                         restarts <- computeRestarts(cond)
[13:21:58.763]                         for (restart in restarts) {
[13:21:58.763]                           name <- restart$name
[13:21:58.763]                           if (is.null(name)) 
[13:21:58.763]                             next
[13:21:58.763]                           if (!grepl(pattern, name)) 
[13:21:58.763]                             next
[13:21:58.763]                           invokeRestart(restart)
[13:21:58.763]                           muffled <- TRUE
[13:21:58.763]                           break
[13:21:58.763]                         }
[13:21:58.763]                       }
[13:21:58.763]                     }
[13:21:58.763]                     invisible(muffled)
[13:21:58.763]                   }
[13:21:58.763]                   muffleCondition(cond)
[13:21:58.763]                 })
[13:21:58.763]             }))
[13:21:58.763]             future::FutureResult(value = ...future.value$value, 
[13:21:58.763]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:58.763]                   ...future.rng), globalenv = if (FALSE) 
[13:21:58.763]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:58.763]                     ...future.globalenv.names))
[13:21:58.763]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:58.763]         }, condition = base::local({
[13:21:58.763]             c <- base::c
[13:21:58.763]             inherits <- base::inherits
[13:21:58.763]             invokeRestart <- base::invokeRestart
[13:21:58.763]             length <- base::length
[13:21:58.763]             list <- base::list
[13:21:58.763]             seq.int <- base::seq.int
[13:21:58.763]             signalCondition <- base::signalCondition
[13:21:58.763]             sys.calls <- base::sys.calls
[13:21:58.763]             `[[` <- base::`[[`
[13:21:58.763]             `+` <- base::`+`
[13:21:58.763]             `<<-` <- base::`<<-`
[13:21:58.763]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:58.763]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:58.763]                   3L)]
[13:21:58.763]             }
[13:21:58.763]             function(cond) {
[13:21:58.763]                 is_error <- inherits(cond, "error")
[13:21:58.763]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:58.763]                   NULL)
[13:21:58.763]                 if (is_error) {
[13:21:58.763]                   sessionInformation <- function() {
[13:21:58.763]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:58.763]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:58.763]                       search = base::search(), system = base::Sys.info())
[13:21:58.763]                   }
[13:21:58.763]                   ...future.conditions[[length(...future.conditions) + 
[13:21:58.763]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:58.763]                     cond$call), session = sessionInformation(), 
[13:21:58.763]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:58.763]                   signalCondition(cond)
[13:21:58.763]                 }
[13:21:58.763]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:58.763]                 "immediateCondition"))) {
[13:21:58.763]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:58.763]                   ...future.conditions[[length(...future.conditions) + 
[13:21:58.763]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:58.763]                   if (TRUE && !signal) {
[13:21:58.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:58.763]                     {
[13:21:58.763]                       inherits <- base::inherits
[13:21:58.763]                       invokeRestart <- base::invokeRestart
[13:21:58.763]                       is.null <- base::is.null
[13:21:58.763]                       muffled <- FALSE
[13:21:58.763]                       if (inherits(cond, "message")) {
[13:21:58.763]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:58.763]                         if (muffled) 
[13:21:58.763]                           invokeRestart("muffleMessage")
[13:21:58.763]                       }
[13:21:58.763]                       else if (inherits(cond, "warning")) {
[13:21:58.763]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:58.763]                         if (muffled) 
[13:21:58.763]                           invokeRestart("muffleWarning")
[13:21:58.763]                       }
[13:21:58.763]                       else if (inherits(cond, "condition")) {
[13:21:58.763]                         if (!is.null(pattern)) {
[13:21:58.763]                           computeRestarts <- base::computeRestarts
[13:21:58.763]                           grepl <- base::grepl
[13:21:58.763]                           restarts <- computeRestarts(cond)
[13:21:58.763]                           for (restart in restarts) {
[13:21:58.763]                             name <- restart$name
[13:21:58.763]                             if (is.null(name)) 
[13:21:58.763]                               next
[13:21:58.763]                             if (!grepl(pattern, name)) 
[13:21:58.763]                               next
[13:21:58.763]                             invokeRestart(restart)
[13:21:58.763]                             muffled <- TRUE
[13:21:58.763]                             break
[13:21:58.763]                           }
[13:21:58.763]                         }
[13:21:58.763]                       }
[13:21:58.763]                       invisible(muffled)
[13:21:58.763]                     }
[13:21:58.763]                     muffleCondition(cond, pattern = "^muffle")
[13:21:58.763]                   }
[13:21:58.763]                 }
[13:21:58.763]                 else {
[13:21:58.763]                   if (TRUE) {
[13:21:58.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:58.763]                     {
[13:21:58.763]                       inherits <- base::inherits
[13:21:58.763]                       invokeRestart <- base::invokeRestart
[13:21:58.763]                       is.null <- base::is.null
[13:21:58.763]                       muffled <- FALSE
[13:21:58.763]                       if (inherits(cond, "message")) {
[13:21:58.763]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:58.763]                         if (muffled) 
[13:21:58.763]                           invokeRestart("muffleMessage")
[13:21:58.763]                       }
[13:21:58.763]                       else if (inherits(cond, "warning")) {
[13:21:58.763]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:58.763]                         if (muffled) 
[13:21:58.763]                           invokeRestart("muffleWarning")
[13:21:58.763]                       }
[13:21:58.763]                       else if (inherits(cond, "condition")) {
[13:21:58.763]                         if (!is.null(pattern)) {
[13:21:58.763]                           computeRestarts <- base::computeRestarts
[13:21:58.763]                           grepl <- base::grepl
[13:21:58.763]                           restarts <- computeRestarts(cond)
[13:21:58.763]                           for (restart in restarts) {
[13:21:58.763]                             name <- restart$name
[13:21:58.763]                             if (is.null(name)) 
[13:21:58.763]                               next
[13:21:58.763]                             if (!grepl(pattern, name)) 
[13:21:58.763]                               next
[13:21:58.763]                             invokeRestart(restart)
[13:21:58.763]                             muffled <- TRUE
[13:21:58.763]                             break
[13:21:58.763]                           }
[13:21:58.763]                         }
[13:21:58.763]                       }
[13:21:58.763]                       invisible(muffled)
[13:21:58.763]                     }
[13:21:58.763]                     muffleCondition(cond, pattern = "^muffle")
[13:21:58.763]                   }
[13:21:58.763]                 }
[13:21:58.763]             }
[13:21:58.763]         }))
[13:21:58.763]     }, error = function(ex) {
[13:21:58.763]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:58.763]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:58.763]                 ...future.rng), started = ...future.startTime, 
[13:21:58.763]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:58.763]             version = "1.8"), class = "FutureResult")
[13:21:58.763]     }, finally = {
[13:21:58.763]         if (!identical(...future.workdir, getwd())) 
[13:21:58.763]             setwd(...future.workdir)
[13:21:58.763]         {
[13:21:58.763]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:58.763]                 ...future.oldOptions$nwarnings <- NULL
[13:21:58.763]             }
[13:21:58.763]             base::options(...future.oldOptions)
[13:21:58.763]             if (.Platform$OS.type == "windows") {
[13:21:58.763]                 old_names <- names(...future.oldEnvVars)
[13:21:58.763]                 envs <- base::Sys.getenv()
[13:21:58.763]                 names <- names(envs)
[13:21:58.763]                 common <- intersect(names, old_names)
[13:21:58.763]                 added <- setdiff(names, old_names)
[13:21:58.763]                 removed <- setdiff(old_names, names)
[13:21:58.763]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:58.763]                   envs[common]]
[13:21:58.763]                 NAMES <- toupper(changed)
[13:21:58.763]                 args <- list()
[13:21:58.763]                 for (kk in seq_along(NAMES)) {
[13:21:58.763]                   name <- changed[[kk]]
[13:21:58.763]                   NAME <- NAMES[[kk]]
[13:21:58.763]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:58.763]                     next
[13:21:58.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:58.763]                 }
[13:21:58.763]                 NAMES <- toupper(added)
[13:21:58.763]                 for (kk in seq_along(NAMES)) {
[13:21:58.763]                   name <- added[[kk]]
[13:21:58.763]                   NAME <- NAMES[[kk]]
[13:21:58.763]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:58.763]                     next
[13:21:58.763]                   args[[name]] <- ""
[13:21:58.763]                 }
[13:21:58.763]                 NAMES <- toupper(removed)
[13:21:58.763]                 for (kk in seq_along(NAMES)) {
[13:21:58.763]                   name <- removed[[kk]]
[13:21:58.763]                   NAME <- NAMES[[kk]]
[13:21:58.763]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:58.763]                     next
[13:21:58.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:58.763]                 }
[13:21:58.763]                 if (length(args) > 0) 
[13:21:58.763]                   base::do.call(base::Sys.setenv, args = args)
[13:21:58.763]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:58.763]             }
[13:21:58.763]             else {
[13:21:58.763]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:58.763]             }
[13:21:58.763]             {
[13:21:58.763]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:58.763]                   0L) {
[13:21:58.763]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:58.763]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:58.763]                   base::options(opts)
[13:21:58.763]                 }
[13:21:58.763]                 {
[13:21:58.763]                   {
[13:21:58.763]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:58.763]                     NULL
[13:21:58.763]                   }
[13:21:58.763]                   options(future.plan = NULL)
[13:21:58.763]                   if (is.na(NA_character_)) 
[13:21:58.763]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:58.763]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:58.763]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:58.763]                     envir = parent.frame()) 
[13:21:58.763]                   {
[13:21:58.763]                     default_workers <- missing(workers)
[13:21:58.763]                     if (is.function(workers)) 
[13:21:58.763]                       workers <- workers()
[13:21:58.763]                     workers <- structure(as.integer(workers), 
[13:21:58.763]                       class = class(workers))
[13:21:58.763]                     stop_if_not(is.finite(workers), workers >= 
[13:21:58.763]                       1L)
[13:21:58.763]                     if ((workers == 1L && !inherits(workers, 
[13:21:58.763]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:58.763]                       if (default_workers) 
[13:21:58.763]                         supportsMulticore(warn = TRUE)
[13:21:58.763]                       return(sequential(..., envir = envir))
[13:21:58.763]                     }
[13:21:58.763]                     oopts <- options(mc.cores = workers)
[13:21:58.763]                     on.exit(options(oopts))
[13:21:58.763]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:58.763]                       envir = envir)
[13:21:58.763]                     if (!future$lazy) 
[13:21:58.763]                       future <- run(future)
[13:21:58.763]                     invisible(future)
[13:21:58.763]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:58.763]                 }
[13:21:58.763]             }
[13:21:58.763]         }
[13:21:58.763]     })
[13:21:58.763]     if (FALSE) {
[13:21:58.763]         base::sink(type = "output", split = FALSE)
[13:21:58.763]         if (NA) {
[13:21:58.763]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:58.763]         }
[13:21:58.763]         else {
[13:21:58.763]             ...future.result["stdout"] <- base::list(NULL)
[13:21:58.763]         }
[13:21:58.763]         base::close(...future.stdout)
[13:21:58.763]         ...future.stdout <- NULL
[13:21:58.763]     }
[13:21:58.763]     ...future.result$conditions <- ...future.conditions
[13:21:58.763]     ...future.result$finished <- base::Sys.time()
[13:21:58.763]     ...future.result
[13:21:58.763] }
[13:21:58.766] assign_globals() ...
[13:21:58.766] List of 5
[13:21:58.766]  $ ...future.FUN            :function (x)  
[13:21:58.766]  $ future.call.arguments    : list()
[13:21:58.766]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:58.766]  $ ...future.elements_ii    :List of 1
[13:21:58.766]   ..$ : int 1
[13:21:58.766]  $ ...future.seeds_ii       : NULL
[13:21:58.766]  $ ...future.globals.maxSize: NULL
[13:21:58.766]  - attr(*, "where")=List of 5
[13:21:58.766]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:58.766]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:58.766]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:58.766]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:58.766]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:58.766]  - attr(*, "resolved")= logi FALSE
[13:21:58.766]  - attr(*, "total_size")= num 4720
[13:21:58.766]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:58.766]  - attr(*, "already-done")= logi TRUE
[13:21:58.771] - reassign environment for ‘...future.FUN’
[13:21:58.771] - copied ‘...future.FUN’ to environment
[13:21:58.771] - copied ‘future.call.arguments’ to environment
[13:21:58.771] - copied ‘...future.elements_ii’ to environment
[13:21:58.771] - copied ‘...future.seeds_ii’ to environment
[13:21:58.771] - copied ‘...future.globals.maxSize’ to environment
[13:21:58.771] assign_globals() ... done
[13:21:58.771] requestCore(): workers = 2
[13:21:58.774] MulticoreFuture started
[13:21:58.774] - Launch lazy future ... done
[13:21:58.774] run() for ‘MulticoreFuture’ ... done
[13:21:58.774] Created future:
[13:21:58.775] plan(): Setting new future strategy stack:
[13:21:58.775] List of future strategies:
[13:21:58.775] 1. sequential:
[13:21:58.775]    - args: function (..., envir = parent.frame())
[13:21:58.775]    - tweaked: FALSE
[13:21:58.775]    - call: NULL
[13:21:58.776] plan(): nbrOfWorkers() = 1
[13:21:58.775] MulticoreFuture:
[13:21:58.775] Label: ‘future_lapply-1’
[13:21:58.775] Expression:
[13:21:58.775] {
[13:21:58.775]     do.call(function(...) {
[13:21:58.775]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:58.775]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:58.775]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:58.775]             on.exit(options(oopts), add = TRUE)
[13:21:58.775]         }
[13:21:58.775]         {
[13:21:58.775]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:58.775]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:58.775]                 ...future.FUN(...future.X_jj, ...)
[13:21:58.775]             })
[13:21:58.775]         }
[13:21:58.775]     }, args = future.call.arguments)
[13:21:58.775] }
[13:21:58.775] Lazy evaluation: FALSE
[13:21:58.775] Asynchronous evaluation: TRUE
[13:21:58.775] Local evaluation: TRUE
[13:21:58.775] Environment: R_GlobalEnv
[13:21:58.775] Capture standard output: NA
[13:21:58.775] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:58.775] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:58.775] Packages: <none>
[13:21:58.775] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:58.775] Resolved: FALSE
[13:21:58.775] Value: <not collected>
[13:21:58.775] Conditions captured: <none>
[13:21:58.775] Early signaling: FALSE
[13:21:58.775] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:21:58.775] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:58.788] Chunk #1 of 2 ... DONE
[13:21:58.788] Chunk #2 of 2 ...
[13:21:58.788]  - Finding globals in 'X' for chunk #2 ...
[13:21:58.789] getGlobalsAndPackages() ...
[13:21:58.789] Searching for globals...
[13:21:58.789] 
[13:21:58.789] Searching for globals ... DONE
[13:21:58.790] - globals: [0] <none>
[13:21:58.790] getGlobalsAndPackages() ... DONE
[13:21:58.790]    + additional globals found: [n=0] 
[13:21:58.790]    + additional namespaces needed: [n=0] 
[13:21:58.790]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:58.790]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:58.791]  - seeds: <none>
[13:21:58.791]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:58.791] getGlobalsAndPackages() ...
[13:21:58.791] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:58.791] Resolving globals: FALSE
[13:21:58.791] Tweak future expression to call with '...' arguments ...
[13:21:58.792] {
[13:21:58.792]     do.call(function(...) {
[13:21:58.792]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:58.792]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:58.792]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:58.792]             on.exit(options(oopts), add = TRUE)
[13:21:58.792]         }
[13:21:58.792]         {
[13:21:58.792]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:58.792]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:58.792]                 ...future.FUN(...future.X_jj, ...)
[13:21:58.792]             })
[13:21:58.792]         }
[13:21:58.792]     }, args = future.call.arguments)
[13:21:58.792] }
[13:21:58.792] Tweak future expression to call with '...' arguments ... DONE
[13:21:58.793] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:58.793] 
[13:21:58.793] getGlobalsAndPackages() ... DONE
[13:21:58.794] run() for ‘Future’ ...
[13:21:58.794] - state: ‘created’
[13:21:58.794] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:58.800] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:58.800] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:58.800]   - Field: ‘label’
[13:21:58.800]   - Field: ‘local’
[13:21:58.800]   - Field: ‘owner’
[13:21:58.800]   - Field: ‘envir’
[13:21:58.801]   - Field: ‘workers’
[13:21:58.801]   - Field: ‘packages’
[13:21:58.801]   - Field: ‘gc’
[13:21:58.801]   - Field: ‘job’
[13:21:58.801]   - Field: ‘conditions’
[13:21:58.801]   - Field: ‘expr’
[13:21:58.801]   - Field: ‘uuid’
[13:21:58.802]   - Field: ‘seed’
[13:21:58.802]   - Field: ‘version’
[13:21:58.802]   - Field: ‘result’
[13:21:58.802]   - Field: ‘asynchronous’
[13:21:58.802]   - Field: ‘calls’
[13:21:58.802]   - Field: ‘globals’
[13:21:58.806]   - Field: ‘stdout’
[13:21:58.806]   - Field: ‘earlySignal’
[13:21:58.807]   - Field: ‘lazy’
[13:21:58.807]   - Field: ‘state’
[13:21:58.807] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:58.807] - Launch lazy future ...
[13:21:58.808] Packages needed by the future expression (n = 0): <none>
[13:21:58.808] Packages needed by future strategies (n = 0): <none>
[13:21:58.810] {
[13:21:58.810]     {
[13:21:58.810]         {
[13:21:58.810]             ...future.startTime <- base::Sys.time()
[13:21:58.810]             {
[13:21:58.810]                 {
[13:21:58.810]                   {
[13:21:58.810]                     {
[13:21:58.810]                       base::local({
[13:21:58.810]                         has_future <- base::requireNamespace("future", 
[13:21:58.810]                           quietly = TRUE)
[13:21:58.810]                         if (has_future) {
[13:21:58.810]                           ns <- base::getNamespace("future")
[13:21:58.810]                           version <- ns[[".package"]][["version"]]
[13:21:58.810]                           if (is.null(version)) 
[13:21:58.810]                             version <- utils::packageVersion("future")
[13:21:58.810]                         }
[13:21:58.810]                         else {
[13:21:58.810]                           version <- NULL
[13:21:58.810]                         }
[13:21:58.810]                         if (!has_future || version < "1.8.0") {
[13:21:58.810]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:58.810]                             "", base::R.version$version.string), 
[13:21:58.810]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:58.810]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:58.810]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:58.810]                               "release", "version")], collapse = " "), 
[13:21:58.810]                             hostname = base::Sys.info()[["nodename"]])
[13:21:58.810]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:58.810]                             info)
[13:21:58.810]                           info <- base::paste(info, collapse = "; ")
[13:21:58.810]                           if (!has_future) {
[13:21:58.810]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:58.810]                               info)
[13:21:58.810]                           }
[13:21:58.810]                           else {
[13:21:58.810]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:58.810]                               info, version)
[13:21:58.810]                           }
[13:21:58.810]                           base::stop(msg)
[13:21:58.810]                         }
[13:21:58.810]                       })
[13:21:58.810]                     }
[13:21:58.810]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:58.810]                     base::options(mc.cores = 1L)
[13:21:58.810]                   }
[13:21:58.810]                   options(future.plan = NULL)
[13:21:58.810]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:58.810]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:58.810]                 }
[13:21:58.810]                 ...future.workdir <- getwd()
[13:21:58.810]             }
[13:21:58.810]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:58.810]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:58.810]         }
[13:21:58.810]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:58.810]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:58.810]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:58.810]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:58.810]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:58.810]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:58.810]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:58.810]             base::names(...future.oldOptions))
[13:21:58.810]     }
[13:21:58.810]     if (TRUE) {
[13:21:58.810]     }
[13:21:58.810]     else {
[13:21:58.810]         if (NA) {
[13:21:58.810]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:58.810]                 open = "w")
[13:21:58.810]         }
[13:21:58.810]         else {
[13:21:58.810]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:58.810]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:58.810]         }
[13:21:58.810]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:58.810]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:58.810]             base::sink(type = "output", split = FALSE)
[13:21:58.810]             base::close(...future.stdout)
[13:21:58.810]         }, add = TRUE)
[13:21:58.810]     }
[13:21:58.810]     ...future.frame <- base::sys.nframe()
[13:21:58.810]     ...future.conditions <- base::list()
[13:21:58.810]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:58.810]     if (FALSE) {
[13:21:58.810]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:58.810]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:58.810]     }
[13:21:58.810]     ...future.result <- base::tryCatch({
[13:21:58.810]         base::withCallingHandlers({
[13:21:58.810]             ...future.value <- base::withVisible(base::local({
[13:21:58.810]                 withCallingHandlers({
[13:21:58.810]                   {
[13:21:58.810]                     do.call(function(...) {
[13:21:58.810]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:58.810]                       if (!identical(...future.globals.maxSize.org, 
[13:21:58.810]                         ...future.globals.maxSize)) {
[13:21:58.810]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:58.810]                         on.exit(options(oopts), add = TRUE)
[13:21:58.810]                       }
[13:21:58.810]                       {
[13:21:58.810]                         lapply(seq_along(...future.elements_ii), 
[13:21:58.810]                           FUN = function(jj) {
[13:21:58.810]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:58.810]                             ...future.FUN(...future.X_jj, ...)
[13:21:58.810]                           })
[13:21:58.810]                       }
[13:21:58.810]                     }, args = future.call.arguments)
[13:21:58.810]                   }
[13:21:58.810]                 }, immediateCondition = function(cond) {
[13:21:58.810]                   save_rds <- function (object, pathname, ...) 
[13:21:58.810]                   {
[13:21:58.810]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:58.810]                     if (file_test("-f", pathname_tmp)) {
[13:21:58.810]                       fi_tmp <- file.info(pathname_tmp)
[13:21:58.810]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:58.810]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:58.810]                         fi_tmp[["mtime"]])
[13:21:58.810]                     }
[13:21:58.810]                     tryCatch({
[13:21:58.810]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:58.810]                     }, error = function(ex) {
[13:21:58.810]                       msg <- conditionMessage(ex)
[13:21:58.810]                       fi_tmp <- file.info(pathname_tmp)
[13:21:58.810]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:58.810]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:58.810]                         fi_tmp[["mtime"]], msg)
[13:21:58.810]                       ex$message <- msg
[13:21:58.810]                       stop(ex)
[13:21:58.810]                     })
[13:21:58.810]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:58.810]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:58.810]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:58.810]                       fi_tmp <- file.info(pathname_tmp)
[13:21:58.810]                       fi <- file.info(pathname)
[13:21:58.810]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:58.810]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:58.810]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:58.810]                         fi[["size"]], fi[["mtime"]])
[13:21:58.810]                       stop(msg)
[13:21:58.810]                     }
[13:21:58.810]                     invisible(pathname)
[13:21:58.810]                   }
[13:21:58.810]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:58.810]                     rootPath = tempdir()) 
[13:21:58.810]                   {
[13:21:58.810]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:58.810]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:58.810]                       tmpdir = path, fileext = ".rds")
[13:21:58.810]                     save_rds(obj, file)
[13:21:58.810]                   }
[13:21:58.810]                   saveImmediateCondition(cond, path = "/tmp/Rtmp78O1Lc/.future/immediateConditions")
[13:21:58.810]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:58.810]                   {
[13:21:58.810]                     inherits <- base::inherits
[13:21:58.810]                     invokeRestart <- base::invokeRestart
[13:21:58.810]                     is.null <- base::is.null
[13:21:58.810]                     muffled <- FALSE
[13:21:58.810]                     if (inherits(cond, "message")) {
[13:21:58.810]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:58.810]                       if (muffled) 
[13:21:58.810]                         invokeRestart("muffleMessage")
[13:21:58.810]                     }
[13:21:58.810]                     else if (inherits(cond, "warning")) {
[13:21:58.810]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:58.810]                       if (muffled) 
[13:21:58.810]                         invokeRestart("muffleWarning")
[13:21:58.810]                     }
[13:21:58.810]                     else if (inherits(cond, "condition")) {
[13:21:58.810]                       if (!is.null(pattern)) {
[13:21:58.810]                         computeRestarts <- base::computeRestarts
[13:21:58.810]                         grepl <- base::grepl
[13:21:58.810]                         restarts <- computeRestarts(cond)
[13:21:58.810]                         for (restart in restarts) {
[13:21:58.810]                           name <- restart$name
[13:21:58.810]                           if (is.null(name)) 
[13:21:58.810]                             next
[13:21:58.810]                           if (!grepl(pattern, name)) 
[13:21:58.810]                             next
[13:21:58.810]                           invokeRestart(restart)
[13:21:58.810]                           muffled <- TRUE
[13:21:58.810]                           break
[13:21:58.810]                         }
[13:21:58.810]                       }
[13:21:58.810]                     }
[13:21:58.810]                     invisible(muffled)
[13:21:58.810]                   }
[13:21:58.810]                   muffleCondition(cond)
[13:21:58.810]                 })
[13:21:58.810]             }))
[13:21:58.810]             future::FutureResult(value = ...future.value$value, 
[13:21:58.810]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:58.810]                   ...future.rng), globalenv = if (FALSE) 
[13:21:58.810]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:58.810]                     ...future.globalenv.names))
[13:21:58.810]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:58.810]         }, condition = base::local({
[13:21:58.810]             c <- base::c
[13:21:58.810]             inherits <- base::inherits
[13:21:58.810]             invokeRestart <- base::invokeRestart
[13:21:58.810]             length <- base::length
[13:21:58.810]             list <- base::list
[13:21:58.810]             seq.int <- base::seq.int
[13:21:58.810]             signalCondition <- base::signalCondition
[13:21:58.810]             sys.calls <- base::sys.calls
[13:21:58.810]             `[[` <- base::`[[`
[13:21:58.810]             `+` <- base::`+`
[13:21:58.810]             `<<-` <- base::`<<-`
[13:21:58.810]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:58.810]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:58.810]                   3L)]
[13:21:58.810]             }
[13:21:58.810]             function(cond) {
[13:21:58.810]                 is_error <- inherits(cond, "error")
[13:21:58.810]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:58.810]                   NULL)
[13:21:58.810]                 if (is_error) {
[13:21:58.810]                   sessionInformation <- function() {
[13:21:58.810]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:58.810]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:58.810]                       search = base::search(), system = base::Sys.info())
[13:21:58.810]                   }
[13:21:58.810]                   ...future.conditions[[length(...future.conditions) + 
[13:21:58.810]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:58.810]                     cond$call), session = sessionInformation(), 
[13:21:58.810]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:58.810]                   signalCondition(cond)
[13:21:58.810]                 }
[13:21:58.810]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:58.810]                 "immediateCondition"))) {
[13:21:58.810]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:58.810]                   ...future.conditions[[length(...future.conditions) + 
[13:21:58.810]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:58.810]                   if (TRUE && !signal) {
[13:21:58.810]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:58.810]                     {
[13:21:58.810]                       inherits <- base::inherits
[13:21:58.810]                       invokeRestart <- base::invokeRestart
[13:21:58.810]                       is.null <- base::is.null
[13:21:58.810]                       muffled <- FALSE
[13:21:58.810]                       if (inherits(cond, "message")) {
[13:21:58.810]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:58.810]                         if (muffled) 
[13:21:58.810]                           invokeRestart("muffleMessage")
[13:21:58.810]                       }
[13:21:58.810]                       else if (inherits(cond, "warning")) {
[13:21:58.810]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:58.810]                         if (muffled) 
[13:21:58.810]                           invokeRestart("muffleWarning")
[13:21:58.810]                       }
[13:21:58.810]                       else if (inherits(cond, "condition")) {
[13:21:58.810]                         if (!is.null(pattern)) {
[13:21:58.810]                           computeRestarts <- base::computeRestarts
[13:21:58.810]                           grepl <- base::grepl
[13:21:58.810]                           restarts <- computeRestarts(cond)
[13:21:58.810]                           for (restart in restarts) {
[13:21:58.810]                             name <- restart$name
[13:21:58.810]                             if (is.null(name)) 
[13:21:58.810]                               next
[13:21:58.810]                             if (!grepl(pattern, name)) 
[13:21:58.810]                               next
[13:21:58.810]                             invokeRestart(restart)
[13:21:58.810]                             muffled <- TRUE
[13:21:58.810]                             break
[13:21:58.810]                           }
[13:21:58.810]                         }
[13:21:58.810]                       }
[13:21:58.810]                       invisible(muffled)
[13:21:58.810]                     }
[13:21:58.810]                     muffleCondition(cond, pattern = "^muffle")
[13:21:58.810]                   }
[13:21:58.810]                 }
[13:21:58.810]                 else {
[13:21:58.810]                   if (TRUE) {
[13:21:58.810]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:58.810]                     {
[13:21:58.810]                       inherits <- base::inherits
[13:21:58.810]                       invokeRestart <- base::invokeRestart
[13:21:58.810]                       is.null <- base::is.null
[13:21:58.810]                       muffled <- FALSE
[13:21:58.810]                       if (inherits(cond, "message")) {
[13:21:58.810]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:58.810]                         if (muffled) 
[13:21:58.810]                           invokeRestart("muffleMessage")
[13:21:58.810]                       }
[13:21:58.810]                       else if (inherits(cond, "warning")) {
[13:21:58.810]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:58.810]                         if (muffled) 
[13:21:58.810]                           invokeRestart("muffleWarning")
[13:21:58.810]                       }
[13:21:58.810]                       else if (inherits(cond, "condition")) {
[13:21:58.810]                         if (!is.null(pattern)) {
[13:21:58.810]                           computeRestarts <- base::computeRestarts
[13:21:58.810]                           grepl <- base::grepl
[13:21:58.810]                           restarts <- computeRestarts(cond)
[13:21:58.810]                           for (restart in restarts) {
[13:21:58.810]                             name <- restart$name
[13:21:58.810]                             if (is.null(name)) 
[13:21:58.810]                               next
[13:21:58.810]                             if (!grepl(pattern, name)) 
[13:21:58.810]                               next
[13:21:58.810]                             invokeRestart(restart)
[13:21:58.810]                             muffled <- TRUE
[13:21:58.810]                             break
[13:21:58.810]                           }
[13:21:58.810]                         }
[13:21:58.810]                       }
[13:21:58.810]                       invisible(muffled)
[13:21:58.810]                     }
[13:21:58.810]                     muffleCondition(cond, pattern = "^muffle")
[13:21:58.810]                   }
[13:21:58.810]                 }
[13:21:58.810]             }
[13:21:58.810]         }))
[13:21:58.810]     }, error = function(ex) {
[13:21:58.810]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:58.810]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:58.810]                 ...future.rng), started = ...future.startTime, 
[13:21:58.810]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:58.810]             version = "1.8"), class = "FutureResult")
[13:21:58.810]     }, finally = {
[13:21:58.810]         if (!identical(...future.workdir, getwd())) 
[13:21:58.810]             setwd(...future.workdir)
[13:21:58.810]         {
[13:21:58.810]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:58.810]                 ...future.oldOptions$nwarnings <- NULL
[13:21:58.810]             }
[13:21:58.810]             base::options(...future.oldOptions)
[13:21:58.810]             if (.Platform$OS.type == "windows") {
[13:21:58.810]                 old_names <- names(...future.oldEnvVars)
[13:21:58.810]                 envs <- base::Sys.getenv()
[13:21:58.810]                 names <- names(envs)
[13:21:58.810]                 common <- intersect(names, old_names)
[13:21:58.810]                 added <- setdiff(names, old_names)
[13:21:58.810]                 removed <- setdiff(old_names, names)
[13:21:58.810]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:58.810]                   envs[common]]
[13:21:58.810]                 NAMES <- toupper(changed)
[13:21:58.810]                 args <- list()
[13:21:58.810]                 for (kk in seq_along(NAMES)) {
[13:21:58.810]                   name <- changed[[kk]]
[13:21:58.810]                   NAME <- NAMES[[kk]]
[13:21:58.810]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:58.810]                     next
[13:21:58.810]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:58.810]                 }
[13:21:58.810]                 NAMES <- toupper(added)
[13:21:58.810]                 for (kk in seq_along(NAMES)) {
[13:21:58.810]                   name <- added[[kk]]
[13:21:58.810]                   NAME <- NAMES[[kk]]
[13:21:58.810]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:58.810]                     next
[13:21:58.810]                   args[[name]] <- ""
[13:21:58.810]                 }
[13:21:58.810]                 NAMES <- toupper(removed)
[13:21:58.810]                 for (kk in seq_along(NAMES)) {
[13:21:58.810]                   name <- removed[[kk]]
[13:21:58.810]                   NAME <- NAMES[[kk]]
[13:21:58.810]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:58.810]                     next
[13:21:58.810]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:58.810]                 }
[13:21:58.810]                 if (length(args) > 0) 
[13:21:58.810]                   base::do.call(base::Sys.setenv, args = args)
[13:21:58.810]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:58.810]             }
[13:21:58.810]             else {
[13:21:58.810]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:58.810]             }
[13:21:58.810]             {
[13:21:58.810]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:58.810]                   0L) {
[13:21:58.810]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:58.810]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:58.810]                   base::options(opts)
[13:21:58.810]                 }
[13:21:58.810]                 {
[13:21:58.810]                   {
[13:21:58.810]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:58.810]                     NULL
[13:21:58.810]                   }
[13:21:58.810]                   options(future.plan = NULL)
[13:21:58.810]                   if (is.na(NA_character_)) 
[13:21:58.810]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:58.810]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:58.810]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:58.810]                     envir = parent.frame()) 
[13:21:58.810]                   {
[13:21:58.810]                     default_workers <- missing(workers)
[13:21:58.810]                     if (is.function(workers)) 
[13:21:58.810]                       workers <- workers()
[13:21:58.810]                     workers <- structure(as.integer(workers), 
[13:21:58.810]                       class = class(workers))
[13:21:58.810]                     stop_if_not(is.finite(workers), workers >= 
[13:21:58.810]                       1L)
[13:21:58.810]                     if ((workers == 1L && !inherits(workers, 
[13:21:58.810]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:58.810]                       if (default_workers) 
[13:21:58.810]                         supportsMulticore(warn = TRUE)
[13:21:58.810]                       return(sequential(..., envir = envir))
[13:21:58.810]                     }
[13:21:58.810]                     oopts <- options(mc.cores = workers)
[13:21:58.810]                     on.exit(options(oopts))
[13:21:58.810]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:58.810]                       envir = envir)
[13:21:58.810]                     if (!future$lazy) 
[13:21:58.810]                       future <- run(future)
[13:21:58.810]                     invisible(future)
[13:21:58.810]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:58.810]                 }
[13:21:58.810]             }
[13:21:58.810]         }
[13:21:58.810]     })
[13:21:58.810]     if (FALSE) {
[13:21:58.810]         base::sink(type = "output", split = FALSE)
[13:21:58.810]         if (NA) {
[13:21:58.810]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:58.810]         }
[13:21:58.810]         else {
[13:21:58.810]             ...future.result["stdout"] <- base::list(NULL)
[13:21:58.810]         }
[13:21:58.810]         base::close(...future.stdout)
[13:21:58.810]         ...future.stdout <- NULL
[13:21:58.810]     }
[13:21:58.810]     ...future.result$conditions <- ...future.conditions
[13:21:58.810]     ...future.result$finished <- base::Sys.time()
[13:21:58.810]     ...future.result
[13:21:58.810] }
[13:21:58.813] assign_globals() ...
[13:21:58.813] List of 5
[13:21:58.813]  $ ...future.FUN            :function (x)  
[13:21:58.813]  $ future.call.arguments    : list()
[13:21:58.813]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:58.813]  $ ...future.elements_ii    :List of 1
[13:21:58.813]   ..$ : int 0
[13:21:58.813]  $ ...future.seeds_ii       : NULL
[13:21:58.813]  $ ...future.globals.maxSize: NULL
[13:21:58.813]  - attr(*, "where")=List of 5
[13:21:58.813]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:58.813]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:58.813]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:58.813]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:58.813]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:58.813]  - attr(*, "resolved")= logi FALSE
[13:21:58.813]  - attr(*, "total_size")= num 4720
[13:21:58.813]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:58.813]  - attr(*, "already-done")= logi TRUE
[13:21:58.821] - reassign environment for ‘...future.FUN’
[13:21:58.821] - copied ‘...future.FUN’ to environment
[13:21:58.821] - copied ‘future.call.arguments’ to environment
[13:21:58.821] - copied ‘...future.elements_ii’ to environment
[13:21:58.821] - copied ‘...future.seeds_ii’ to environment
[13:21:58.822] - copied ‘...future.globals.maxSize’ to environment
[13:21:58.822] assign_globals() ... done
[13:21:58.822] requestCore(): workers = 2
[13:21:58.824] MulticoreFuture started
[13:21:58.824] - Launch lazy future ... done
[13:21:58.825] run() for ‘MulticoreFuture’ ... done
[13:21:58.825] Created future:
[13:21:58.825] plan(): Setting new future strategy stack:
[13:21:58.826] List of future strategies:
[13:21:58.826] 1. sequential:
[13:21:58.826]    - args: function (..., envir = parent.frame())
[13:21:58.826]    - tweaked: FALSE
[13:21:58.826]    - call: NULL
[13:21:58.826] plan(): nbrOfWorkers() = 1
[13:21:58.828] plan(): Setting new future strategy stack:
[13:21:58.829] List of future strategies:
[13:21:58.829] 1. multicore:
[13:21:58.829]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:58.829]    - tweaked: FALSE
[13:21:58.829]    - call: plan(strategy)
[13:21:58.834] plan(): nbrOfWorkers() = 2
[13:21:58.825] MulticoreFuture:
[13:21:58.825] Label: ‘future_lapply-2’
[13:21:58.825] Expression:
[13:21:58.825] {
[13:21:58.825]     do.call(function(...) {
[13:21:58.825]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:58.825]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:58.825]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:58.825]             on.exit(options(oopts), add = TRUE)
[13:21:58.825]         }
[13:21:58.825]         {
[13:21:58.825]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:58.825]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:58.825]                 ...future.FUN(...future.X_jj, ...)
[13:21:58.825]             })
[13:21:58.825]         }
[13:21:58.825]     }, args = future.call.arguments)
[13:21:58.825] }
[13:21:58.825] Lazy evaluation: FALSE
[13:21:58.825] Asynchronous evaluation: TRUE
[13:21:58.825] Local evaluation: TRUE
[13:21:58.825] Environment: R_GlobalEnv
[13:21:58.825] Capture standard output: NA
[13:21:58.825] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:58.825] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:58.825] Packages: <none>
[13:21:58.825] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:58.825] Resolved: TRUE
[13:21:58.825] Value: <not collected>
[13:21:58.825] Conditions captured: <none>
[13:21:58.825] Early signaling: FALSE
[13:21:58.825] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:21:58.825] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:58.835] Chunk #2 of 2 ... DONE
[13:21:58.835] Launching 2 futures (chunks) ... DONE
[13:21:58.835] Resolving 2 futures (chunks) ...
[13:21:58.835] resolve() on list ...
[13:21:58.836]  recursive: 0
[13:21:58.836]  length: 2
[13:21:58.836] 
[13:21:58.847] Future #2
[13:21:58.847] result() for MulticoreFuture ...
[13:21:58.848] result() for MulticoreFuture ...
[13:21:58.848] result() for MulticoreFuture ... done
[13:21:58.848] result() for MulticoreFuture ... done
[13:21:58.848] result() for MulticoreFuture ...
[13:21:58.848] result() for MulticoreFuture ... done
[13:21:58.849] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:21:58.849] - nx: 2
[13:21:58.849] - relay: TRUE
[13:21:58.849] - stdout: TRUE
[13:21:58.849] - signal: TRUE
[13:21:58.849] - resignal: FALSE
[13:21:58.849] - force: TRUE
[13:21:58.850] - relayed: [n=2] FALSE, FALSE
[13:21:58.850] - queued futures: [n=2] FALSE, FALSE
[13:21:58.850]  - until=1
[13:21:58.850]  - relaying element #1
[13:21:58.850] - relayed: [n=2] FALSE, FALSE
[13:21:58.850] - queued futures: [n=2] FALSE, TRUE
[13:21:58.850] signalConditionsASAP(NULL, pos=2) ... done
[13:21:58.851]  length: 1 (resolved future 2)
[13:21:59.279] plan(): Setting new future strategy stack:
[13:21:59.279] List of future strategies:
[13:21:59.279] 1. multicore:
[13:21:59.279]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:59.279]    - tweaked: FALSE
[13:21:59.279]    - call: plan(strategy)
[13:21:59.283] plan(): nbrOfWorkers() = 2
[13:21:59.290] Future #1
[13:21:59.290] result() for MulticoreFuture ...
[13:21:59.291] result() for MulticoreFuture ...
[13:21:59.291] result() for MulticoreFuture ... done
[13:21:59.291] result() for MulticoreFuture ... done
[13:21:59.291] result() for MulticoreFuture ...
[13:21:59.292] result() for MulticoreFuture ... done
[13:21:59.292] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:21:59.292] - nx: 2
[13:21:59.292] - relay: TRUE
[13:21:59.292] - stdout: TRUE
[13:21:59.292] - signal: TRUE
[13:21:59.292] - resignal: FALSE
[13:21:59.292] - force: TRUE
[13:21:59.293] - relayed: [n=2] FALSE, FALSE
[13:21:59.293] - queued futures: [n=2] FALSE, TRUE
[13:21:59.293]  - until=1
[13:21:59.293]  - relaying element #1
[13:21:59.293] result() for MulticoreFuture ...
[13:21:59.293] result() for MulticoreFuture ... done
[13:21:59.293] result() for MulticoreFuture ...
[13:21:59.293] result() for MulticoreFuture ... done
[13:21:59.294] result() for MulticoreFuture ...
[13:21:59.294] result() for MulticoreFuture ... done
[13:21:59.294] result() for MulticoreFuture ...
[13:21:59.294] result() for MulticoreFuture ... done
[13:21:59.294] - relayed: [n=2] TRUE, FALSE
[13:21:59.294] - queued futures: [n=2] TRUE, TRUE
[13:21:59.294] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:21:59.294]  length: 0 (resolved future 1)
[13:21:59.295] Relaying remaining futures
[13:21:59.295] signalConditionsASAP(NULL, pos=0) ...
[13:21:59.295] - nx: 2
[13:21:59.295] - relay: TRUE
[13:21:59.295] - stdout: TRUE
[13:21:59.295] - signal: TRUE
[13:21:59.295] - resignal: FALSE
[13:21:59.295] - force: TRUE
[13:21:59.295] - relayed: [n=2] TRUE, FALSE
[13:21:59.296] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:59.296]  - relaying element #2
[13:21:59.296] result() for MulticoreFuture ...
[13:21:59.296] result() for MulticoreFuture ... done
[13:21:59.296] result() for MulticoreFuture ...
[13:21:59.296] result() for MulticoreFuture ... done
[13:21:59.296] result() for MulticoreFuture ...
[13:21:59.297] result() for MulticoreFuture ... done
[13:21:59.297] result() for MulticoreFuture ...
[13:21:59.297] result() for MulticoreFuture ... done
[13:21:59.297] - relayed: [n=2] TRUE, TRUE
[13:21:59.297] - queued futures: [n=2] TRUE, TRUE
[13:21:59.297] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[13:21:59.297] resolve() on list ... DONE
[13:21:59.297] result() for MulticoreFuture ...
[13:21:59.297] result() for MulticoreFuture ... done
[13:21:59.298] result() for MulticoreFuture ...
[13:21:59.298] result() for MulticoreFuture ... done
[13:21:59.298] result() for MulticoreFuture ...
[13:21:59.298] result() for MulticoreFuture ... done
[13:21:59.298] result() for MulticoreFuture ...
[13:21:59.298] result() for MulticoreFuture ... done
[13:21:59.298]  - Number of value chunks collected: 2
[13:21:59.299] Resolving 2 futures (chunks) ... DONE
[13:21:59.299] Reducing values from 2 chunks ...
[13:21:59.301]  - Number of values collected after concatenation: 2
[13:21:59.301]  - Number of values expected: 2
[13:21:59.302] Reducing values from 2 chunks ... DONE
[13:21:59.302] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[13:21:59.302] future_mapply() ...
[13:21:59.307] Number of chunks: 2
[13:21:59.307] getGlobalsAndPackagesXApply() ...
[13:21:59.308]  - future.globals: TRUE
[13:21:59.308] getGlobalsAndPackages() ...
[13:21:59.308] Searching for globals...
[13:21:59.310] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:21:59.310] Searching for globals ... DONE
[13:21:59.310] Resolving globals: FALSE
[13:21:59.311] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:21:59.311] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:21:59.311] - globals: [1] ‘FUN’
[13:21:59.312] 
[13:21:59.312] getGlobalsAndPackages() ... DONE
[13:21:59.312]  - globals found/used: [n=1] ‘FUN’
[13:21:59.312]  - needed namespaces: [n=0] 
[13:21:59.312] Finding globals ... DONE
[13:21:59.312] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:21:59.312] List of 2
[13:21:59.312]  $ ...future.FUN:function (x, y)  
[13:21:59.312]  $ MoreArgs     : NULL
[13:21:59.312]  - attr(*, "where")=List of 2
[13:21:59.312]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:59.312]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:21:59.312]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:59.312]  - attr(*, "resolved")= logi FALSE
[13:21:59.312]  - attr(*, "total_size")= num NA
[13:21:59.315] Packages to be attached in all futures: [n=0] 
[13:21:59.315] getGlobalsAndPackagesXApply() ... DONE
[13:21:59.316] Number of futures (= number of chunks): 2
[13:21:59.316] Launching 2 futures (chunks) ...
[13:21:59.316] Chunk #1 of 2 ...
[13:21:59.316]  - Finding globals in '...' for chunk #1 ...
[13:21:59.316] getGlobalsAndPackages() ...
[13:21:59.316] Searching for globals...
[13:21:59.317] 
[13:21:59.317] Searching for globals ... DONE
[13:21:59.317] - globals: [0] <none>
[13:21:59.317] getGlobalsAndPackages() ... DONE
[13:21:59.317]    + additional globals found: [n=0] 
[13:21:59.317]    + additional namespaces needed: [n=0] 
[13:21:59.317]  - Finding globals in '...' for chunk #1 ... DONE
[13:21:59.317]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:59.317]  - seeds: <none>
[13:21:59.317]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:59.318] getGlobalsAndPackages() ...
[13:21:59.318] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:59.318] Resolving globals: FALSE
[13:21:59.318] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:21:59.319] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:21:59.319] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:59.319] 
[13:21:59.319] getGlobalsAndPackages() ... DONE
[13:21:59.319] run() for ‘Future’ ...
[13:21:59.320] - state: ‘created’
[13:21:59.320] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:59.324] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:59.324] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:59.324]   - Field: ‘label’
[13:21:59.324]   - Field: ‘local’
[13:21:59.324]   - Field: ‘owner’
[13:21:59.324]   - Field: ‘envir’
[13:21:59.324]   - Field: ‘workers’
[13:21:59.324]   - Field: ‘packages’
[13:21:59.325]   - Field: ‘gc’
[13:21:59.325]   - Field: ‘job’
[13:21:59.325]   - Field: ‘conditions’
[13:21:59.325]   - Field: ‘expr’
[13:21:59.325]   - Field: ‘uuid’
[13:21:59.325]   - Field: ‘seed’
[13:21:59.325]   - Field: ‘version’
[13:21:59.325]   - Field: ‘result’
[13:21:59.325]   - Field: ‘asynchronous’
[13:21:59.325]   - Field: ‘calls’
[13:21:59.325]   - Field: ‘globals’
[13:21:59.326]   - Field: ‘stdout’
[13:21:59.326]   - Field: ‘earlySignal’
[13:21:59.326]   - Field: ‘lazy’
[13:21:59.326]   - Field: ‘state’
[13:21:59.326] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:59.326] - Launch lazy future ...
[13:21:59.326] Packages needed by the future expression (n = 0): <none>
[13:21:59.326] Packages needed by future strategies (n = 0): <none>
[13:21:59.327] {
[13:21:59.327]     {
[13:21:59.327]         {
[13:21:59.327]             ...future.startTime <- base::Sys.time()
[13:21:59.327]             {
[13:21:59.327]                 {
[13:21:59.327]                   {
[13:21:59.327]                     {
[13:21:59.327]                       base::local({
[13:21:59.327]                         has_future <- base::requireNamespace("future", 
[13:21:59.327]                           quietly = TRUE)
[13:21:59.327]                         if (has_future) {
[13:21:59.327]                           ns <- base::getNamespace("future")
[13:21:59.327]                           version <- ns[[".package"]][["version"]]
[13:21:59.327]                           if (is.null(version)) 
[13:21:59.327]                             version <- utils::packageVersion("future")
[13:21:59.327]                         }
[13:21:59.327]                         else {
[13:21:59.327]                           version <- NULL
[13:21:59.327]                         }
[13:21:59.327]                         if (!has_future || version < "1.8.0") {
[13:21:59.327]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:59.327]                             "", base::R.version$version.string), 
[13:21:59.327]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:59.327]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:59.327]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:59.327]                               "release", "version")], collapse = " "), 
[13:21:59.327]                             hostname = base::Sys.info()[["nodename"]])
[13:21:59.327]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:59.327]                             info)
[13:21:59.327]                           info <- base::paste(info, collapse = "; ")
[13:21:59.327]                           if (!has_future) {
[13:21:59.327]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:59.327]                               info)
[13:21:59.327]                           }
[13:21:59.327]                           else {
[13:21:59.327]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:59.327]                               info, version)
[13:21:59.327]                           }
[13:21:59.327]                           base::stop(msg)
[13:21:59.327]                         }
[13:21:59.327]                       })
[13:21:59.327]                     }
[13:21:59.327]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:59.327]                     base::options(mc.cores = 1L)
[13:21:59.327]                   }
[13:21:59.327]                   options(future.plan = NULL)
[13:21:59.327]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:59.327]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:59.327]                 }
[13:21:59.327]                 ...future.workdir <- getwd()
[13:21:59.327]             }
[13:21:59.327]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:59.327]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:59.327]         }
[13:21:59.327]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:59.327]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:59.327]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:59.327]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:59.327]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:59.327]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:59.327]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:59.327]             base::names(...future.oldOptions))
[13:21:59.327]     }
[13:21:59.327]     if (FALSE) {
[13:21:59.327]     }
[13:21:59.327]     else {
[13:21:59.327]         if (FALSE) {
[13:21:59.327]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:59.327]                 open = "w")
[13:21:59.327]         }
[13:21:59.327]         else {
[13:21:59.327]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:59.327]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:59.327]         }
[13:21:59.327]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:59.327]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:59.327]             base::sink(type = "output", split = FALSE)
[13:21:59.327]             base::close(...future.stdout)
[13:21:59.327]         }, add = TRUE)
[13:21:59.327]     }
[13:21:59.327]     ...future.frame <- base::sys.nframe()
[13:21:59.327]     ...future.conditions <- base::list()
[13:21:59.327]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:59.327]     if (FALSE) {
[13:21:59.327]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:59.327]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:59.327]     }
[13:21:59.327]     ...future.result <- base::tryCatch({
[13:21:59.327]         base::withCallingHandlers({
[13:21:59.327]             ...future.value <- base::withVisible(base::local({
[13:21:59.327]                 withCallingHandlers({
[13:21:59.327]                   {
[13:21:59.327]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:59.327]                     if (!identical(...future.globals.maxSize.org, 
[13:21:59.327]                       ...future.globals.maxSize)) {
[13:21:59.327]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:59.327]                       on.exit(options(oopts), add = TRUE)
[13:21:59.327]                     }
[13:21:59.327]                     {
[13:21:59.327]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:21:59.327]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:21:59.327]                         USE.NAMES = FALSE)
[13:21:59.327]                       do.call(mapply, args = args)
[13:21:59.327]                     }
[13:21:59.327]                   }
[13:21:59.327]                 }, immediateCondition = function(cond) {
[13:21:59.327]                   save_rds <- function (object, pathname, ...) 
[13:21:59.327]                   {
[13:21:59.327]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:59.327]                     if (file_test("-f", pathname_tmp)) {
[13:21:59.327]                       fi_tmp <- file.info(pathname_tmp)
[13:21:59.327]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:59.327]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:59.327]                         fi_tmp[["mtime"]])
[13:21:59.327]                     }
[13:21:59.327]                     tryCatch({
[13:21:59.327]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:59.327]                     }, error = function(ex) {
[13:21:59.327]                       msg <- conditionMessage(ex)
[13:21:59.327]                       fi_tmp <- file.info(pathname_tmp)
[13:21:59.327]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:59.327]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:59.327]                         fi_tmp[["mtime"]], msg)
[13:21:59.327]                       ex$message <- msg
[13:21:59.327]                       stop(ex)
[13:21:59.327]                     })
[13:21:59.327]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:59.327]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:59.327]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:59.327]                       fi_tmp <- file.info(pathname_tmp)
[13:21:59.327]                       fi <- file.info(pathname)
[13:21:59.327]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:59.327]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:59.327]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:59.327]                         fi[["size"]], fi[["mtime"]])
[13:21:59.327]                       stop(msg)
[13:21:59.327]                     }
[13:21:59.327]                     invisible(pathname)
[13:21:59.327]                   }
[13:21:59.327]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:59.327]                     rootPath = tempdir()) 
[13:21:59.327]                   {
[13:21:59.327]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:59.327]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:59.327]                       tmpdir = path, fileext = ".rds")
[13:21:59.327]                     save_rds(obj, file)
[13:21:59.327]                   }
[13:21:59.327]                   saveImmediateCondition(cond, path = "/tmp/Rtmp78O1Lc/.future/immediateConditions")
[13:21:59.327]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.327]                   {
[13:21:59.327]                     inherits <- base::inherits
[13:21:59.327]                     invokeRestart <- base::invokeRestart
[13:21:59.327]                     is.null <- base::is.null
[13:21:59.327]                     muffled <- FALSE
[13:21:59.327]                     if (inherits(cond, "message")) {
[13:21:59.327]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:59.327]                       if (muffled) 
[13:21:59.327]                         invokeRestart("muffleMessage")
[13:21:59.327]                     }
[13:21:59.327]                     else if (inherits(cond, "warning")) {
[13:21:59.327]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:59.327]                       if (muffled) 
[13:21:59.327]                         invokeRestart("muffleWarning")
[13:21:59.327]                     }
[13:21:59.327]                     else if (inherits(cond, "condition")) {
[13:21:59.327]                       if (!is.null(pattern)) {
[13:21:59.327]                         computeRestarts <- base::computeRestarts
[13:21:59.327]                         grepl <- base::grepl
[13:21:59.327]                         restarts <- computeRestarts(cond)
[13:21:59.327]                         for (restart in restarts) {
[13:21:59.327]                           name <- restart$name
[13:21:59.327]                           if (is.null(name)) 
[13:21:59.327]                             next
[13:21:59.327]                           if (!grepl(pattern, name)) 
[13:21:59.327]                             next
[13:21:59.327]                           invokeRestart(restart)
[13:21:59.327]                           muffled <- TRUE
[13:21:59.327]                           break
[13:21:59.327]                         }
[13:21:59.327]                       }
[13:21:59.327]                     }
[13:21:59.327]                     invisible(muffled)
[13:21:59.327]                   }
[13:21:59.327]                   muffleCondition(cond)
[13:21:59.327]                 })
[13:21:59.327]             }))
[13:21:59.327]             future::FutureResult(value = ...future.value$value, 
[13:21:59.327]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:59.327]                   ...future.rng), globalenv = if (FALSE) 
[13:21:59.327]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:59.327]                     ...future.globalenv.names))
[13:21:59.327]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:59.327]         }, condition = base::local({
[13:21:59.327]             c <- base::c
[13:21:59.327]             inherits <- base::inherits
[13:21:59.327]             invokeRestart <- base::invokeRestart
[13:21:59.327]             length <- base::length
[13:21:59.327]             list <- base::list
[13:21:59.327]             seq.int <- base::seq.int
[13:21:59.327]             signalCondition <- base::signalCondition
[13:21:59.327]             sys.calls <- base::sys.calls
[13:21:59.327]             `[[` <- base::`[[`
[13:21:59.327]             `+` <- base::`+`
[13:21:59.327]             `<<-` <- base::`<<-`
[13:21:59.327]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:59.327]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:59.327]                   3L)]
[13:21:59.327]             }
[13:21:59.327]             function(cond) {
[13:21:59.327]                 is_error <- inherits(cond, "error")
[13:21:59.327]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:59.327]                   NULL)
[13:21:59.327]                 if (is_error) {
[13:21:59.327]                   sessionInformation <- function() {
[13:21:59.327]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:59.327]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:59.327]                       search = base::search(), system = base::Sys.info())
[13:21:59.327]                   }
[13:21:59.327]                   ...future.conditions[[length(...future.conditions) + 
[13:21:59.327]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:59.327]                     cond$call), session = sessionInformation(), 
[13:21:59.327]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:59.327]                   signalCondition(cond)
[13:21:59.327]                 }
[13:21:59.327]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:59.327]                 "immediateCondition"))) {
[13:21:59.327]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:59.327]                   ...future.conditions[[length(...future.conditions) + 
[13:21:59.327]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:59.327]                   if (TRUE && !signal) {
[13:21:59.327]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.327]                     {
[13:21:59.327]                       inherits <- base::inherits
[13:21:59.327]                       invokeRestart <- base::invokeRestart
[13:21:59.327]                       is.null <- base::is.null
[13:21:59.327]                       muffled <- FALSE
[13:21:59.327]                       if (inherits(cond, "message")) {
[13:21:59.327]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:59.327]                         if (muffled) 
[13:21:59.327]                           invokeRestart("muffleMessage")
[13:21:59.327]                       }
[13:21:59.327]                       else if (inherits(cond, "warning")) {
[13:21:59.327]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:59.327]                         if (muffled) 
[13:21:59.327]                           invokeRestart("muffleWarning")
[13:21:59.327]                       }
[13:21:59.327]                       else if (inherits(cond, "condition")) {
[13:21:59.327]                         if (!is.null(pattern)) {
[13:21:59.327]                           computeRestarts <- base::computeRestarts
[13:21:59.327]                           grepl <- base::grepl
[13:21:59.327]                           restarts <- computeRestarts(cond)
[13:21:59.327]                           for (restart in restarts) {
[13:21:59.327]                             name <- restart$name
[13:21:59.327]                             if (is.null(name)) 
[13:21:59.327]                               next
[13:21:59.327]                             if (!grepl(pattern, name)) 
[13:21:59.327]                               next
[13:21:59.327]                             invokeRestart(restart)
[13:21:59.327]                             muffled <- TRUE
[13:21:59.327]                             break
[13:21:59.327]                           }
[13:21:59.327]                         }
[13:21:59.327]                       }
[13:21:59.327]                       invisible(muffled)
[13:21:59.327]                     }
[13:21:59.327]                     muffleCondition(cond, pattern = "^muffle")
[13:21:59.327]                   }
[13:21:59.327]                 }
[13:21:59.327]                 else {
[13:21:59.327]                   if (TRUE) {
[13:21:59.327]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.327]                     {
[13:21:59.327]                       inherits <- base::inherits
[13:21:59.327]                       invokeRestart <- base::invokeRestart
[13:21:59.327]                       is.null <- base::is.null
[13:21:59.327]                       muffled <- FALSE
[13:21:59.327]                       if (inherits(cond, "message")) {
[13:21:59.327]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:59.327]                         if (muffled) 
[13:21:59.327]                           invokeRestart("muffleMessage")
[13:21:59.327]                       }
[13:21:59.327]                       else if (inherits(cond, "warning")) {
[13:21:59.327]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:59.327]                         if (muffled) 
[13:21:59.327]                           invokeRestart("muffleWarning")
[13:21:59.327]                       }
[13:21:59.327]                       else if (inherits(cond, "condition")) {
[13:21:59.327]                         if (!is.null(pattern)) {
[13:21:59.327]                           computeRestarts <- base::computeRestarts
[13:21:59.327]                           grepl <- base::grepl
[13:21:59.327]                           restarts <- computeRestarts(cond)
[13:21:59.327]                           for (restart in restarts) {
[13:21:59.327]                             name <- restart$name
[13:21:59.327]                             if (is.null(name)) 
[13:21:59.327]                               next
[13:21:59.327]                             if (!grepl(pattern, name)) 
[13:21:59.327]                               next
[13:21:59.327]                             invokeRestart(restart)
[13:21:59.327]                             muffled <- TRUE
[13:21:59.327]                             break
[13:21:59.327]                           }
[13:21:59.327]                         }
[13:21:59.327]                       }
[13:21:59.327]                       invisible(muffled)
[13:21:59.327]                     }
[13:21:59.327]                     muffleCondition(cond, pattern = "^muffle")
[13:21:59.327]                   }
[13:21:59.327]                 }
[13:21:59.327]             }
[13:21:59.327]         }))
[13:21:59.327]     }, error = function(ex) {
[13:21:59.327]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:59.327]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:59.327]                 ...future.rng), started = ...future.startTime, 
[13:21:59.327]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:59.327]             version = "1.8"), class = "FutureResult")
[13:21:59.327]     }, finally = {
[13:21:59.327]         if (!identical(...future.workdir, getwd())) 
[13:21:59.327]             setwd(...future.workdir)
[13:21:59.327]         {
[13:21:59.327]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:59.327]                 ...future.oldOptions$nwarnings <- NULL
[13:21:59.327]             }
[13:21:59.327]             base::options(...future.oldOptions)
[13:21:59.327]             if (.Platform$OS.type == "windows") {
[13:21:59.327]                 old_names <- names(...future.oldEnvVars)
[13:21:59.327]                 envs <- base::Sys.getenv()
[13:21:59.327]                 names <- names(envs)
[13:21:59.327]                 common <- intersect(names, old_names)
[13:21:59.327]                 added <- setdiff(names, old_names)
[13:21:59.327]                 removed <- setdiff(old_names, names)
[13:21:59.327]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:59.327]                   envs[common]]
[13:21:59.327]                 NAMES <- toupper(changed)
[13:21:59.327]                 args <- list()
[13:21:59.327]                 for (kk in seq_along(NAMES)) {
[13:21:59.327]                   name <- changed[[kk]]
[13:21:59.327]                   NAME <- NAMES[[kk]]
[13:21:59.327]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.327]                     next
[13:21:59.327]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:59.327]                 }
[13:21:59.327]                 NAMES <- toupper(added)
[13:21:59.327]                 for (kk in seq_along(NAMES)) {
[13:21:59.327]                   name <- added[[kk]]
[13:21:59.327]                   NAME <- NAMES[[kk]]
[13:21:59.327]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.327]                     next
[13:21:59.327]                   args[[name]] <- ""
[13:21:59.327]                 }
[13:21:59.327]                 NAMES <- toupper(removed)
[13:21:59.327]                 for (kk in seq_along(NAMES)) {
[13:21:59.327]                   name <- removed[[kk]]
[13:21:59.327]                   NAME <- NAMES[[kk]]
[13:21:59.327]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.327]                     next
[13:21:59.327]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:59.327]                 }
[13:21:59.327]                 if (length(args) > 0) 
[13:21:59.327]                   base::do.call(base::Sys.setenv, args = args)
[13:21:59.327]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:59.327]             }
[13:21:59.327]             else {
[13:21:59.327]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:59.327]             }
[13:21:59.327]             {
[13:21:59.327]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:59.327]                   0L) {
[13:21:59.327]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:59.327]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:59.327]                   base::options(opts)
[13:21:59.327]                 }
[13:21:59.327]                 {
[13:21:59.327]                   {
[13:21:59.327]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:59.327]                     NULL
[13:21:59.327]                   }
[13:21:59.327]                   options(future.plan = NULL)
[13:21:59.327]                   if (is.na(NA_character_)) 
[13:21:59.327]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:59.327]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:59.327]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:59.327]                     envir = parent.frame()) 
[13:21:59.327]                   {
[13:21:59.327]                     default_workers <- missing(workers)
[13:21:59.327]                     if (is.function(workers)) 
[13:21:59.327]                       workers <- workers()
[13:21:59.327]                     workers <- structure(as.integer(workers), 
[13:21:59.327]                       class = class(workers))
[13:21:59.327]                     stop_if_not(is.finite(workers), workers >= 
[13:21:59.327]                       1L)
[13:21:59.327]                     if ((workers == 1L && !inherits(workers, 
[13:21:59.327]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:59.327]                       if (default_workers) 
[13:21:59.327]                         supportsMulticore(warn = TRUE)
[13:21:59.327]                       return(sequential(..., envir = envir))
[13:21:59.327]                     }
[13:21:59.327]                     oopts <- options(mc.cores = workers)
[13:21:59.327]                     on.exit(options(oopts))
[13:21:59.327]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:59.327]                       envir = envir)
[13:21:59.327]                     if (!future$lazy) 
[13:21:59.327]                       future <- run(future)
[13:21:59.327]                     invisible(future)
[13:21:59.327]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:59.327]                 }
[13:21:59.327]             }
[13:21:59.327]         }
[13:21:59.327]     })
[13:21:59.327]     if (TRUE) {
[13:21:59.327]         base::sink(type = "output", split = FALSE)
[13:21:59.327]         if (FALSE) {
[13:21:59.327]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:59.327]         }
[13:21:59.327]         else {
[13:21:59.327]             ...future.result["stdout"] <- base::list(NULL)
[13:21:59.327]         }
[13:21:59.327]         base::close(...future.stdout)
[13:21:59.327]         ...future.stdout <- NULL
[13:21:59.327]     }
[13:21:59.327]     ...future.result$conditions <- ...future.conditions
[13:21:59.327]     ...future.result$finished <- base::Sys.time()
[13:21:59.327]     ...future.result
[13:21:59.327] }
[13:21:59.330] assign_globals() ...
[13:21:59.330] List of 5
[13:21:59.330]  $ ...future.FUN            :function (x, y)  
[13:21:59.330]  $ MoreArgs                 : NULL
[13:21:59.330]  $ ...future.elements_ii    :List of 2
[13:21:59.330]   ..$ :List of 1
[13:21:59.330]   .. ..$ : int 1
[13:21:59.330]   ..$ :List of 1
[13:21:59.330]   .. ..$ : int 0
[13:21:59.330]  $ ...future.seeds_ii       : NULL
[13:21:59.330]  $ ...future.globals.maxSize: NULL
[13:21:59.330]  - attr(*, "where")=List of 5
[13:21:59.330]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:59.330]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:21:59.330]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:59.330]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:59.330]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:59.330]  - attr(*, "resolved")= logi FALSE
[13:21:59.330]  - attr(*, "total_size")= num 6368
[13:21:59.330]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:59.330]  - attr(*, "already-done")= logi TRUE
[13:21:59.337] - reassign environment for ‘...future.FUN’
[13:21:59.338] - copied ‘...future.FUN’ to environment
[13:21:59.338] - copied ‘MoreArgs’ to environment
[13:21:59.338] - copied ‘...future.elements_ii’ to environment
[13:21:59.338] - copied ‘...future.seeds_ii’ to environment
[13:21:59.338] - copied ‘...future.globals.maxSize’ to environment
[13:21:59.338] assign_globals() ... done
[13:21:59.338] requestCore(): workers = 2
[13:21:59.341] MulticoreFuture started
[13:21:59.341] - Launch lazy future ... done
[13:21:59.342] run() for ‘MulticoreFuture’ ... done
[13:21:59.342] Created future:
[13:21:59.342] plan(): Setting new future strategy stack:
[13:21:59.342] List of future strategies:
[13:21:59.342] 1. sequential:
[13:21:59.342]    - args: function (..., envir = parent.frame())
[13:21:59.342]    - tweaked: FALSE
[13:21:59.342]    - call: NULL
[13:21:59.343] plan(): nbrOfWorkers() = 1
[13:21:59.342] MulticoreFuture:
[13:21:59.342] Label: ‘future_mapply-1’
[13:21:59.342] Expression:
[13:21:59.342] {
[13:21:59.342]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:59.342]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:59.342]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:59.342]         on.exit(options(oopts), add = TRUE)
[13:21:59.342]     }
[13:21:59.342]     {
[13:21:59.342]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:21:59.342]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:21:59.342]         do.call(mapply, args = args)
[13:21:59.342]     }
[13:21:59.342] }
[13:21:59.342] Lazy evaluation: FALSE
[13:21:59.342] Asynchronous evaluation: TRUE
[13:21:59.342] Local evaluation: TRUE
[13:21:59.342] Environment: R_GlobalEnv
[13:21:59.342] Capture standard output: FALSE
[13:21:59.342] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:59.342] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:59.342] Packages: <none>
[13:21:59.342] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:59.342] Resolved: FALSE
[13:21:59.342] Value: <not collected>
[13:21:59.342] Conditions captured: <none>
[13:21:59.342] Early signaling: FALSE
[13:21:59.342] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:21:59.342] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:59.355] Chunk #1 of 2 ... DONE
[13:21:59.355] Chunk #2 of 2 ...
[13:21:59.356]  - Finding globals in '...' for chunk #2 ...
[13:21:59.356] getGlobalsAndPackages() ...
[13:21:59.356] Searching for globals...
[13:21:59.357] 
[13:21:59.357] Searching for globals ... DONE
[13:21:59.357] - globals: [0] <none>
[13:21:59.357] getGlobalsAndPackages() ... DONE
[13:21:59.358]    + additional globals found: [n=0] 
[13:21:59.358]    + additional namespaces needed: [n=0] 
[13:21:59.358]  - Finding globals in '...' for chunk #2 ... DONE
[13:21:59.358]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:59.358]  - seeds: <none>
[13:21:59.358]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:59.359] getGlobalsAndPackages() ...
[13:21:59.359] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:59.359] Resolving globals: FALSE
[13:21:59.360] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:21:59.361] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:21:59.361] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:59.361] 
[13:21:59.361] getGlobalsAndPackages() ... DONE
[13:21:59.362] run() for ‘Future’ ...
[13:21:59.362] - state: ‘created’
[13:21:59.362] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:59.367] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:59.368] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:59.368]   - Field: ‘label’
[13:21:59.368]   - Field: ‘local’
[13:21:59.368]   - Field: ‘owner’
[13:21:59.368]   - Field: ‘envir’
[13:21:59.368]   - Field: ‘workers’
[13:21:59.369]   - Field: ‘packages’
[13:21:59.369]   - Field: ‘gc’
[13:21:59.369]   - Field: ‘job’
[13:21:59.369]   - Field: ‘conditions’
[13:21:59.369]   - Field: ‘expr’
[13:21:59.369]   - Field: ‘uuid’
[13:21:59.369]   - Field: ‘seed’
[13:21:59.370]   - Field: ‘version’
[13:21:59.370]   - Field: ‘result’
[13:21:59.370]   - Field: ‘asynchronous’
[13:21:59.370]   - Field: ‘calls’
[13:21:59.370]   - Field: ‘globals’
[13:21:59.370]   - Field: ‘stdout’
[13:21:59.371]   - Field: ‘earlySignal’
[13:21:59.371]   - Field: ‘lazy’
[13:21:59.371]   - Field: ‘state’
[13:21:59.371] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:59.371] - Launch lazy future ...
[13:21:59.372] Packages needed by the future expression (n = 0): <none>
[13:21:59.372] Packages needed by future strategies (n = 0): <none>
[13:21:59.372] {
[13:21:59.372]     {
[13:21:59.372]         {
[13:21:59.372]             ...future.startTime <- base::Sys.time()
[13:21:59.372]             {
[13:21:59.372]                 {
[13:21:59.372]                   {
[13:21:59.372]                     {
[13:21:59.372]                       base::local({
[13:21:59.372]                         has_future <- base::requireNamespace("future", 
[13:21:59.372]                           quietly = TRUE)
[13:21:59.372]                         if (has_future) {
[13:21:59.372]                           ns <- base::getNamespace("future")
[13:21:59.372]                           version <- ns[[".package"]][["version"]]
[13:21:59.372]                           if (is.null(version)) 
[13:21:59.372]                             version <- utils::packageVersion("future")
[13:21:59.372]                         }
[13:21:59.372]                         else {
[13:21:59.372]                           version <- NULL
[13:21:59.372]                         }
[13:21:59.372]                         if (!has_future || version < "1.8.0") {
[13:21:59.372]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:59.372]                             "", base::R.version$version.string), 
[13:21:59.372]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:59.372]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:59.372]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:59.372]                               "release", "version")], collapse = " "), 
[13:21:59.372]                             hostname = base::Sys.info()[["nodename"]])
[13:21:59.372]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:59.372]                             info)
[13:21:59.372]                           info <- base::paste(info, collapse = "; ")
[13:21:59.372]                           if (!has_future) {
[13:21:59.372]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:59.372]                               info)
[13:21:59.372]                           }
[13:21:59.372]                           else {
[13:21:59.372]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:59.372]                               info, version)
[13:21:59.372]                           }
[13:21:59.372]                           base::stop(msg)
[13:21:59.372]                         }
[13:21:59.372]                       })
[13:21:59.372]                     }
[13:21:59.372]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:59.372]                     base::options(mc.cores = 1L)
[13:21:59.372]                   }
[13:21:59.372]                   options(future.plan = NULL)
[13:21:59.372]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:59.372]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:59.372]                 }
[13:21:59.372]                 ...future.workdir <- getwd()
[13:21:59.372]             }
[13:21:59.372]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:59.372]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:59.372]         }
[13:21:59.372]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:59.372]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:59.372]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:59.372]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:59.372]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:59.372]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:59.372]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:59.372]             base::names(...future.oldOptions))
[13:21:59.372]     }
[13:21:59.372]     if (FALSE) {
[13:21:59.372]     }
[13:21:59.372]     else {
[13:21:59.372]         if (FALSE) {
[13:21:59.372]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:59.372]                 open = "w")
[13:21:59.372]         }
[13:21:59.372]         else {
[13:21:59.372]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:59.372]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:59.372]         }
[13:21:59.372]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:59.372]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:59.372]             base::sink(type = "output", split = FALSE)
[13:21:59.372]             base::close(...future.stdout)
[13:21:59.372]         }, add = TRUE)
[13:21:59.372]     }
[13:21:59.372]     ...future.frame <- base::sys.nframe()
[13:21:59.372]     ...future.conditions <- base::list()
[13:21:59.372]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:59.372]     if (FALSE) {
[13:21:59.372]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:59.372]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:59.372]     }
[13:21:59.372]     ...future.result <- base::tryCatch({
[13:21:59.372]         base::withCallingHandlers({
[13:21:59.372]             ...future.value <- base::withVisible(base::local({
[13:21:59.372]                 withCallingHandlers({
[13:21:59.372]                   {
[13:21:59.372]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:59.372]                     if (!identical(...future.globals.maxSize.org, 
[13:21:59.372]                       ...future.globals.maxSize)) {
[13:21:59.372]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:59.372]                       on.exit(options(oopts), add = TRUE)
[13:21:59.372]                     }
[13:21:59.372]                     {
[13:21:59.372]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:21:59.372]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:21:59.372]                         USE.NAMES = FALSE)
[13:21:59.372]                       do.call(mapply, args = args)
[13:21:59.372]                     }
[13:21:59.372]                   }
[13:21:59.372]                 }, immediateCondition = function(cond) {
[13:21:59.372]                   save_rds <- function (object, pathname, ...) 
[13:21:59.372]                   {
[13:21:59.372]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:59.372]                     if (file_test("-f", pathname_tmp)) {
[13:21:59.372]                       fi_tmp <- file.info(pathname_tmp)
[13:21:59.372]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:59.372]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:59.372]                         fi_tmp[["mtime"]])
[13:21:59.372]                     }
[13:21:59.372]                     tryCatch({
[13:21:59.372]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:59.372]                     }, error = function(ex) {
[13:21:59.372]                       msg <- conditionMessage(ex)
[13:21:59.372]                       fi_tmp <- file.info(pathname_tmp)
[13:21:59.372]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:59.372]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:59.372]                         fi_tmp[["mtime"]], msg)
[13:21:59.372]                       ex$message <- msg
[13:21:59.372]                       stop(ex)
[13:21:59.372]                     })
[13:21:59.372]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:59.372]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:59.372]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:59.372]                       fi_tmp <- file.info(pathname_tmp)
[13:21:59.372]                       fi <- file.info(pathname)
[13:21:59.372]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:59.372]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:59.372]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:59.372]                         fi[["size"]], fi[["mtime"]])
[13:21:59.372]                       stop(msg)
[13:21:59.372]                     }
[13:21:59.372]                     invisible(pathname)
[13:21:59.372]                   }
[13:21:59.372]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:59.372]                     rootPath = tempdir()) 
[13:21:59.372]                   {
[13:21:59.372]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:59.372]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:59.372]                       tmpdir = path, fileext = ".rds")
[13:21:59.372]                     save_rds(obj, file)
[13:21:59.372]                   }
[13:21:59.372]                   saveImmediateCondition(cond, path = "/tmp/Rtmp78O1Lc/.future/immediateConditions")
[13:21:59.372]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.372]                   {
[13:21:59.372]                     inherits <- base::inherits
[13:21:59.372]                     invokeRestart <- base::invokeRestart
[13:21:59.372]                     is.null <- base::is.null
[13:21:59.372]                     muffled <- FALSE
[13:21:59.372]                     if (inherits(cond, "message")) {
[13:21:59.372]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:59.372]                       if (muffled) 
[13:21:59.372]                         invokeRestart("muffleMessage")
[13:21:59.372]                     }
[13:21:59.372]                     else if (inherits(cond, "warning")) {
[13:21:59.372]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:59.372]                       if (muffled) 
[13:21:59.372]                         invokeRestart("muffleWarning")
[13:21:59.372]                     }
[13:21:59.372]                     else if (inherits(cond, "condition")) {
[13:21:59.372]                       if (!is.null(pattern)) {
[13:21:59.372]                         computeRestarts <- base::computeRestarts
[13:21:59.372]                         grepl <- base::grepl
[13:21:59.372]                         restarts <- computeRestarts(cond)
[13:21:59.372]                         for (restart in restarts) {
[13:21:59.372]                           name <- restart$name
[13:21:59.372]                           if (is.null(name)) 
[13:21:59.372]                             next
[13:21:59.372]                           if (!grepl(pattern, name)) 
[13:21:59.372]                             next
[13:21:59.372]                           invokeRestart(restart)
[13:21:59.372]                           muffled <- TRUE
[13:21:59.372]                           break
[13:21:59.372]                         }
[13:21:59.372]                       }
[13:21:59.372]                     }
[13:21:59.372]                     invisible(muffled)
[13:21:59.372]                   }
[13:21:59.372]                   muffleCondition(cond)
[13:21:59.372]                 })
[13:21:59.372]             }))
[13:21:59.372]             future::FutureResult(value = ...future.value$value, 
[13:21:59.372]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:59.372]                   ...future.rng), globalenv = if (FALSE) 
[13:21:59.372]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:59.372]                     ...future.globalenv.names))
[13:21:59.372]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:59.372]         }, condition = base::local({
[13:21:59.372]             c <- base::c
[13:21:59.372]             inherits <- base::inherits
[13:21:59.372]             invokeRestart <- base::invokeRestart
[13:21:59.372]             length <- base::length
[13:21:59.372]             list <- base::list
[13:21:59.372]             seq.int <- base::seq.int
[13:21:59.372]             signalCondition <- base::signalCondition
[13:21:59.372]             sys.calls <- base::sys.calls
[13:21:59.372]             `[[` <- base::`[[`
[13:21:59.372]             `+` <- base::`+`
[13:21:59.372]             `<<-` <- base::`<<-`
[13:21:59.372]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:59.372]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:59.372]                   3L)]
[13:21:59.372]             }
[13:21:59.372]             function(cond) {
[13:21:59.372]                 is_error <- inherits(cond, "error")
[13:21:59.372]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:59.372]                   NULL)
[13:21:59.372]                 if (is_error) {
[13:21:59.372]                   sessionInformation <- function() {
[13:21:59.372]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:59.372]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:59.372]                       search = base::search(), system = base::Sys.info())
[13:21:59.372]                   }
[13:21:59.372]                   ...future.conditions[[length(...future.conditions) + 
[13:21:59.372]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:59.372]                     cond$call), session = sessionInformation(), 
[13:21:59.372]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:59.372]                   signalCondition(cond)
[13:21:59.372]                 }
[13:21:59.372]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:59.372]                 "immediateCondition"))) {
[13:21:59.372]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:59.372]                   ...future.conditions[[length(...future.conditions) + 
[13:21:59.372]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:59.372]                   if (TRUE && !signal) {
[13:21:59.372]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.372]                     {
[13:21:59.372]                       inherits <- base::inherits
[13:21:59.372]                       invokeRestart <- base::invokeRestart
[13:21:59.372]                       is.null <- base::is.null
[13:21:59.372]                       muffled <- FALSE
[13:21:59.372]                       if (inherits(cond, "message")) {
[13:21:59.372]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:59.372]                         if (muffled) 
[13:21:59.372]                           invokeRestart("muffleMessage")
[13:21:59.372]                       }
[13:21:59.372]                       else if (inherits(cond, "warning")) {
[13:21:59.372]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:59.372]                         if (muffled) 
[13:21:59.372]                           invokeRestart("muffleWarning")
[13:21:59.372]                       }
[13:21:59.372]                       else if (inherits(cond, "condition")) {
[13:21:59.372]                         if (!is.null(pattern)) {
[13:21:59.372]                           computeRestarts <- base::computeRestarts
[13:21:59.372]                           grepl <- base::grepl
[13:21:59.372]                           restarts <- computeRestarts(cond)
[13:21:59.372]                           for (restart in restarts) {
[13:21:59.372]                             name <- restart$name
[13:21:59.372]                             if (is.null(name)) 
[13:21:59.372]                               next
[13:21:59.372]                             if (!grepl(pattern, name)) 
[13:21:59.372]                               next
[13:21:59.372]                             invokeRestart(restart)
[13:21:59.372]                             muffled <- TRUE
[13:21:59.372]                             break
[13:21:59.372]                           }
[13:21:59.372]                         }
[13:21:59.372]                       }
[13:21:59.372]                       invisible(muffled)
[13:21:59.372]                     }
[13:21:59.372]                     muffleCondition(cond, pattern = "^muffle")
[13:21:59.372]                   }
[13:21:59.372]                 }
[13:21:59.372]                 else {
[13:21:59.372]                   if (TRUE) {
[13:21:59.372]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.372]                     {
[13:21:59.372]                       inherits <- base::inherits
[13:21:59.372]                       invokeRestart <- base::invokeRestart
[13:21:59.372]                       is.null <- base::is.null
[13:21:59.372]                       muffled <- FALSE
[13:21:59.372]                       if (inherits(cond, "message")) {
[13:21:59.372]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:59.372]                         if (muffled) 
[13:21:59.372]                           invokeRestart("muffleMessage")
[13:21:59.372]                       }
[13:21:59.372]                       else if (inherits(cond, "warning")) {
[13:21:59.372]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:59.372]                         if (muffled) 
[13:21:59.372]                           invokeRestart("muffleWarning")
[13:21:59.372]                       }
[13:21:59.372]                       else if (inherits(cond, "condition")) {
[13:21:59.372]                         if (!is.null(pattern)) {
[13:21:59.372]                           computeRestarts <- base::computeRestarts
[13:21:59.372]                           grepl <- base::grepl
[13:21:59.372]                           restarts <- computeRestarts(cond)
[13:21:59.372]                           for (restart in restarts) {
[13:21:59.372]                             name <- restart$name
[13:21:59.372]                             if (is.null(name)) 
[13:21:59.372]                               next
[13:21:59.372]                             if (!grepl(pattern, name)) 
[13:21:59.372]                               next
[13:21:59.372]                             invokeRestart(restart)
[13:21:59.372]                             muffled <- TRUE
[13:21:59.372]                             break
[13:21:59.372]                           }
[13:21:59.372]                         }
[13:21:59.372]                       }
[13:21:59.372]                       invisible(muffled)
[13:21:59.372]                     }
[13:21:59.372]                     muffleCondition(cond, pattern = "^muffle")
[13:21:59.372]                   }
[13:21:59.372]                 }
[13:21:59.372]             }
[13:21:59.372]         }))
[13:21:59.372]     }, error = function(ex) {
[13:21:59.372]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:59.372]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:59.372]                 ...future.rng), started = ...future.startTime, 
[13:21:59.372]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:59.372]             version = "1.8"), class = "FutureResult")
[13:21:59.372]     }, finally = {
[13:21:59.372]         if (!identical(...future.workdir, getwd())) 
[13:21:59.372]             setwd(...future.workdir)
[13:21:59.372]         {
[13:21:59.372]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:59.372]                 ...future.oldOptions$nwarnings <- NULL
[13:21:59.372]             }
[13:21:59.372]             base::options(...future.oldOptions)
[13:21:59.372]             if (.Platform$OS.type == "windows") {
[13:21:59.372]                 old_names <- names(...future.oldEnvVars)
[13:21:59.372]                 envs <- base::Sys.getenv()
[13:21:59.372]                 names <- names(envs)
[13:21:59.372]                 common <- intersect(names, old_names)
[13:21:59.372]                 added <- setdiff(names, old_names)
[13:21:59.372]                 removed <- setdiff(old_names, names)
[13:21:59.372]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:59.372]                   envs[common]]
[13:21:59.372]                 NAMES <- toupper(changed)
[13:21:59.372]                 args <- list()
[13:21:59.372]                 for (kk in seq_along(NAMES)) {
[13:21:59.372]                   name <- changed[[kk]]
[13:21:59.372]                   NAME <- NAMES[[kk]]
[13:21:59.372]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.372]                     next
[13:21:59.372]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:59.372]                 }
[13:21:59.372]                 NAMES <- toupper(added)
[13:21:59.372]                 for (kk in seq_along(NAMES)) {
[13:21:59.372]                   name <- added[[kk]]
[13:21:59.372]                   NAME <- NAMES[[kk]]
[13:21:59.372]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.372]                     next
[13:21:59.372]                   args[[name]] <- ""
[13:21:59.372]                 }
[13:21:59.372]                 NAMES <- toupper(removed)
[13:21:59.372]                 for (kk in seq_along(NAMES)) {
[13:21:59.372]                   name <- removed[[kk]]
[13:21:59.372]                   NAME <- NAMES[[kk]]
[13:21:59.372]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.372]                     next
[13:21:59.372]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:59.372]                 }
[13:21:59.372]                 if (length(args) > 0) 
[13:21:59.372]                   base::do.call(base::Sys.setenv, args = args)
[13:21:59.372]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:59.372]             }
[13:21:59.372]             else {
[13:21:59.372]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:59.372]             }
[13:21:59.372]             {
[13:21:59.372]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:59.372]                   0L) {
[13:21:59.372]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:59.372]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:59.372]                   base::options(opts)
[13:21:59.372]                 }
[13:21:59.372]                 {
[13:21:59.372]                   {
[13:21:59.372]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:59.372]                     NULL
[13:21:59.372]                   }
[13:21:59.372]                   options(future.plan = NULL)
[13:21:59.372]                   if (is.na(NA_character_)) 
[13:21:59.372]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:59.372]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:59.372]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:59.372]                     envir = parent.frame()) 
[13:21:59.372]                   {
[13:21:59.372]                     default_workers <- missing(workers)
[13:21:59.372]                     if (is.function(workers)) 
[13:21:59.372]                       workers <- workers()
[13:21:59.372]                     workers <- structure(as.integer(workers), 
[13:21:59.372]                       class = class(workers))
[13:21:59.372]                     stop_if_not(is.finite(workers), workers >= 
[13:21:59.372]                       1L)
[13:21:59.372]                     if ((workers == 1L && !inherits(workers, 
[13:21:59.372]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:59.372]                       if (default_workers) 
[13:21:59.372]                         supportsMulticore(warn = TRUE)
[13:21:59.372]                       return(sequential(..., envir = envir))
[13:21:59.372]                     }
[13:21:59.372]                     oopts <- options(mc.cores = workers)
[13:21:59.372]                     on.exit(options(oopts))
[13:21:59.372]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:59.372]                       envir = envir)
[13:21:59.372]                     if (!future$lazy) 
[13:21:59.372]                       future <- run(future)
[13:21:59.372]                     invisible(future)
[13:21:59.372]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:59.372]                 }
[13:21:59.372]             }
[13:21:59.372]         }
[13:21:59.372]     })
[13:21:59.372]     if (TRUE) {
[13:21:59.372]         base::sink(type = "output", split = FALSE)
[13:21:59.372]         if (FALSE) {
[13:21:59.372]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:59.372]         }
[13:21:59.372]         else {
[13:21:59.372]             ...future.result["stdout"] <- base::list(NULL)
[13:21:59.372]         }
[13:21:59.372]         base::close(...future.stdout)
[13:21:59.372]         ...future.stdout <- NULL
[13:21:59.372]     }
[13:21:59.372]     ...future.result$conditions <- ...future.conditions
[13:21:59.372]     ...future.result$finished <- base::Sys.time()
[13:21:59.372]     ...future.result
[13:21:59.372] }
[13:21:59.376] assign_globals() ...
[13:21:59.376] List of 5
[13:21:59.376]  $ ...future.FUN            :function (x, y)  
[13:21:59.376]  $ MoreArgs                 : NULL
[13:21:59.376]  $ ...future.elements_ii    :List of 2
[13:21:59.376]   ..$ :List of 1
[13:21:59.376]   .. ..$ : int 0
[13:21:59.376]   ..$ :List of 1
[13:21:59.376]   .. ..$ : int 1
[13:21:59.376]  $ ...future.seeds_ii       : NULL
[13:21:59.376]  $ ...future.globals.maxSize: NULL
[13:21:59.376]  - attr(*, "where")=List of 5
[13:21:59.376]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:59.376]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:21:59.376]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:59.376]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:59.376]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:59.376]  - attr(*, "resolved")= logi FALSE
[13:21:59.376]  - attr(*, "total_size")= num 6368
[13:21:59.376]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:59.376]  - attr(*, "already-done")= logi TRUE
[13:21:59.385] - reassign environment for ‘...future.FUN’
[13:21:59.385] - copied ‘...future.FUN’ to environment
[13:21:59.385] - copied ‘MoreArgs’ to environment
[13:21:59.385] - copied ‘...future.elements_ii’ to environment
[13:21:59.385] - copied ‘...future.seeds_ii’ to environment
[13:21:59.385] - copied ‘...future.globals.maxSize’ to environment
[13:21:59.386] assign_globals() ... done
[13:21:59.386] requestCore(): workers = 2
[13:21:59.388] MulticoreFuture started
[13:21:59.389] - Launch lazy future ... done
[13:21:59.389] plan(): Setting new future strategy stack:
[13:21:59.393] run() for ‘MulticoreFuture’ ... done
[13:21:59.394] Created future:
[13:21:59.393] List of future strategies:
[13:21:59.393] 1. sequential:
[13:21:59.393]    - args: function (..., envir = parent.frame())
[13:21:59.393]    - tweaked: FALSE
[13:21:59.393]    - call: NULL
[13:21:59.395] plan(): nbrOfWorkers() = 1
[13:21:59.398] plan(): Setting new future strategy stack:
[13:21:59.398] List of future strategies:
[13:21:59.398] 1. multicore:
[13:21:59.398]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:59.398]    - tweaked: FALSE
[13:21:59.398]    - call: plan(strategy)
[13:21:59.404] plan(): nbrOfWorkers() = 2
[13:21:59.394] MulticoreFuture:
[13:21:59.394] Label: ‘future_mapply-2’
[13:21:59.394] Expression:
[13:21:59.394] {
[13:21:59.394]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:59.394]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:59.394]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:59.394]         on.exit(options(oopts), add = TRUE)
[13:21:59.394]     }
[13:21:59.394]     {
[13:21:59.394]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:21:59.394]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:21:59.394]         do.call(mapply, args = args)
[13:21:59.394]     }
[13:21:59.394] }
[13:21:59.394] Lazy evaluation: FALSE
[13:21:59.394] Asynchronous evaluation: TRUE
[13:21:59.394] Local evaluation: TRUE
[13:21:59.394] Environment: R_GlobalEnv
[13:21:59.394] Capture standard output: FALSE
[13:21:59.394] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:59.394] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:59.394] Packages: <none>
[13:21:59.394] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:59.394] Resolved: TRUE
[13:21:59.394] Value: <not collected>
[13:21:59.394] Conditions captured: <none>
[13:21:59.394] Early signaling: FALSE
[13:21:59.394] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:21:59.394] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:59.406] Chunk #2 of 2 ... DONE
[13:21:59.406] Launching 2 futures (chunks) ... DONE
[13:21:59.406] Resolving 2 futures (chunks) ...
[13:21:59.407] resolve() on list ...
[13:21:59.407]  recursive: 0
[13:21:59.407]  length: 2
[13:21:59.407] 
[13:21:59.418] Future #2
[13:21:59.418] result() for MulticoreFuture ...
[13:21:59.419] result() for MulticoreFuture ...
[13:21:59.420] result() for MulticoreFuture ... done
[13:21:59.420] result() for MulticoreFuture ... done
[13:21:59.420] result() for MulticoreFuture ...
[13:21:59.420] result() for MulticoreFuture ... done
[13:21:59.421] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:21:59.421] - nx: 2
[13:21:59.421] - relay: TRUE
[13:21:59.421] - stdout: TRUE
[13:21:59.421] - signal: TRUE
[13:21:59.421] - resignal: FALSE
[13:21:59.422] - force: TRUE
[13:21:59.422] - relayed: [n=2] FALSE, FALSE
[13:21:59.422] - queued futures: [n=2] FALSE, FALSE
[13:21:59.422]  - until=1
[13:21:59.422]  - relaying element #1
[13:21:59.422] - relayed: [n=2] FALSE, FALSE
[13:21:59.422] - queued futures: [n=2] FALSE, TRUE
[13:21:59.423] signalConditionsASAP(NULL, pos=2) ... done
[13:21:59.423]  length: 1 (resolved future 2)
[13:21:59.846] plan(): Setting new future strategy stack:
[13:21:59.846] List of future strategies:
[13:21:59.846] 1. multicore:
[13:21:59.846]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:59.846]    - tweaked: FALSE
[13:21:59.846]    - call: plan(strategy)
[13:21:59.851] plan(): nbrOfWorkers() = 2
[13:21:59.852] Future #1
[13:21:59.852] result() for MulticoreFuture ...
[13:21:59.853] result() for MulticoreFuture ...
[13:21:59.853] result() for MulticoreFuture ... done
[13:21:59.853] result() for MulticoreFuture ... done
[13:21:59.853] result() for MulticoreFuture ...
[13:21:59.853] result() for MulticoreFuture ... done
[13:21:59.853] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:21:59.853] - nx: 2
[13:21:59.854] - relay: TRUE
[13:21:59.854] - stdout: TRUE
[13:21:59.854] - signal: TRUE
[13:21:59.854] - resignal: FALSE
[13:21:59.854] - force: TRUE
[13:21:59.854] - relayed: [n=2] FALSE, FALSE
[13:21:59.854] - queued futures: [n=2] FALSE, TRUE
[13:21:59.854]  - until=1
[13:21:59.854]  - relaying element #1
[13:21:59.855] result() for MulticoreFuture ...
[13:21:59.855] result() for MulticoreFuture ... done
[13:21:59.855] result() for MulticoreFuture ...
[13:21:59.855] result() for MulticoreFuture ... done
[13:21:59.855] result() for MulticoreFuture ...
[13:21:59.855] result() for MulticoreFuture ... done
[13:21:59.855] result() for MulticoreFuture ...
[13:21:59.855] result() for MulticoreFuture ... done
[13:21:59.855] - relayed: [n=2] TRUE, FALSE
[13:21:59.856] - queued futures: [n=2] TRUE, TRUE
[13:21:59.856] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:21:59.856]  length: 0 (resolved future 1)
[13:21:59.856] Relaying remaining futures
[13:21:59.856] signalConditionsASAP(NULL, pos=0) ...
[13:21:59.856] - nx: 2
[13:21:59.856] - relay: TRUE
[13:21:59.856] - stdout: TRUE
[13:21:59.856] - signal: TRUE
[13:21:59.857] - resignal: FALSE
[13:21:59.857] - force: TRUE
[13:21:59.857] - relayed: [n=2] TRUE, FALSE
[13:21:59.857] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:59.857]  - relaying element #2
[13:21:59.857] result() for MulticoreFuture ...
[13:21:59.857] result() for MulticoreFuture ... done
[13:21:59.857] result() for MulticoreFuture ...
[13:21:59.857] result() for MulticoreFuture ... done
[13:21:59.858] result() for MulticoreFuture ...
[13:21:59.858] result() for MulticoreFuture ... done
[13:21:59.858] result() for MulticoreFuture ...
[13:21:59.858] result() for MulticoreFuture ... done
[13:21:59.858] - relayed: [n=2] TRUE, TRUE
[13:21:59.858] - queued futures: [n=2] TRUE, TRUE
[13:21:59.858] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[13:21:59.858] resolve() on list ... DONE
[13:21:59.858] result() for MulticoreFuture ...
[13:21:59.859] result() for MulticoreFuture ... done
[13:21:59.859] result() for MulticoreFuture ...
[13:21:59.859] result() for MulticoreFuture ... done
[13:21:59.859] result() for MulticoreFuture ...
[13:21:59.859] result() for MulticoreFuture ... done
[13:21:59.859] result() for MulticoreFuture ...
[13:21:59.859] result() for MulticoreFuture ... done
[13:21:59.859]  - Number of value chunks collected: 2
[13:21:59.860] Resolving 2 futures (chunks) ... DONE
[13:21:59.860] Reducing values from 2 chunks ...
[13:21:59.860]  - Number of values collected after concatenation: 2
[13:21:59.860]  - Number of values expected: 2
[13:21:59.860] Reducing values from 2 chunks ... DONE
[13:21:59.860] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[13:21:59.861] future_mapply() ...
[13:21:59.865] Number of chunks: 2
[13:21:59.865] getGlobalsAndPackagesXApply() ...
[13:21:59.865]  - future.globals: TRUE
[13:21:59.865] getGlobalsAndPackages() ...
[13:21:59.865] Searching for globals...
[13:21:59.867] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:21:59.867] Searching for globals ... DONE
[13:21:59.867] Resolving globals: FALSE
[13:21:59.868] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:21:59.868] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:21:59.869] - globals: [1] ‘FUN’
[13:21:59.869] 
[13:21:59.869] getGlobalsAndPackages() ... DONE
[13:21:59.869]  - globals found/used: [n=1] ‘FUN’
[13:21:59.869]  - needed namespaces: [n=0] 
[13:21:59.869] Finding globals ... DONE
[13:21:59.869] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:21:59.869] List of 2
[13:21:59.869]  $ ...future.FUN:function (x, y)  
[13:21:59.869]  $ MoreArgs     : NULL
[13:21:59.869]  - attr(*, "where")=List of 2
[13:21:59.869]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:59.869]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:21:59.869]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:59.869]  - attr(*, "resolved")= logi FALSE
[13:21:59.869]  - attr(*, "total_size")= num NA
[13:21:59.874] Packages to be attached in all futures: [n=0] 
[13:21:59.874] getGlobalsAndPackagesXApply() ... DONE
[13:21:59.875] Number of futures (= number of chunks): 2
[13:21:59.875] Launching 2 futures (chunks) ...
[13:21:59.875] Chunk #1 of 2 ...
[13:21:59.875]  - Finding globals in '...' for chunk #1 ...
[13:21:59.875] getGlobalsAndPackages() ...
[13:21:59.875] Searching for globals...
[13:21:59.876] 
[13:21:59.876] Searching for globals ... DONE
[13:21:59.876] - globals: [0] <none>
[13:21:59.876] getGlobalsAndPackages() ... DONE
[13:21:59.876]    + additional globals found: [n=0] 
[13:21:59.876]    + additional namespaces needed: [n=0] 
[13:21:59.876]  - Finding globals in '...' for chunk #1 ... DONE
[13:21:59.876]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:59.876]  - seeds: <none>
[13:21:59.877]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:59.877] getGlobalsAndPackages() ...
[13:21:59.877] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:59.877] Resolving globals: FALSE
[13:21:59.877] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:21:59.878] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:21:59.878] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:59.878] 
[13:21:59.878] getGlobalsAndPackages() ... DONE
[13:21:59.878] run() for ‘Future’ ...
[13:21:59.879] - state: ‘created’
[13:21:59.879] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:59.882] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:59.883] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:59.883]   - Field: ‘label’
[13:21:59.883]   - Field: ‘local’
[13:21:59.883]   - Field: ‘owner’
[13:21:59.883]   - Field: ‘envir’
[13:21:59.883]   - Field: ‘workers’
[13:21:59.883]   - Field: ‘packages’
[13:21:59.883]   - Field: ‘gc’
[13:21:59.883]   - Field: ‘job’
[13:21:59.884]   - Field: ‘conditions’
[13:21:59.884]   - Field: ‘expr’
[13:21:59.884]   - Field: ‘uuid’
[13:21:59.884]   - Field: ‘seed’
[13:21:59.884]   - Field: ‘version’
[13:21:59.884]   - Field: ‘result’
[13:21:59.884]   - Field: ‘asynchronous’
[13:21:59.884]   - Field: ‘calls’
[13:21:59.884]   - Field: ‘globals’
[13:21:59.884]   - Field: ‘stdout’
[13:21:59.885]   - Field: ‘earlySignal’
[13:21:59.885]   - Field: ‘lazy’
[13:21:59.885]   - Field: ‘state’
[13:21:59.885] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:59.885] - Launch lazy future ...
[13:21:59.885] Packages needed by the future expression (n = 0): <none>
[13:21:59.885] Packages needed by future strategies (n = 0): <none>
[13:21:59.886] {
[13:21:59.886]     {
[13:21:59.886]         {
[13:21:59.886]             ...future.startTime <- base::Sys.time()
[13:21:59.886]             {
[13:21:59.886]                 {
[13:21:59.886]                   {
[13:21:59.886]                     {
[13:21:59.886]                       base::local({
[13:21:59.886]                         has_future <- base::requireNamespace("future", 
[13:21:59.886]                           quietly = TRUE)
[13:21:59.886]                         if (has_future) {
[13:21:59.886]                           ns <- base::getNamespace("future")
[13:21:59.886]                           version <- ns[[".package"]][["version"]]
[13:21:59.886]                           if (is.null(version)) 
[13:21:59.886]                             version <- utils::packageVersion("future")
[13:21:59.886]                         }
[13:21:59.886]                         else {
[13:21:59.886]                           version <- NULL
[13:21:59.886]                         }
[13:21:59.886]                         if (!has_future || version < "1.8.0") {
[13:21:59.886]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:59.886]                             "", base::R.version$version.string), 
[13:21:59.886]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:59.886]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:59.886]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:59.886]                               "release", "version")], collapse = " "), 
[13:21:59.886]                             hostname = base::Sys.info()[["nodename"]])
[13:21:59.886]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:59.886]                             info)
[13:21:59.886]                           info <- base::paste(info, collapse = "; ")
[13:21:59.886]                           if (!has_future) {
[13:21:59.886]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:59.886]                               info)
[13:21:59.886]                           }
[13:21:59.886]                           else {
[13:21:59.886]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:59.886]                               info, version)
[13:21:59.886]                           }
[13:21:59.886]                           base::stop(msg)
[13:21:59.886]                         }
[13:21:59.886]                       })
[13:21:59.886]                     }
[13:21:59.886]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:59.886]                     base::options(mc.cores = 1L)
[13:21:59.886]                   }
[13:21:59.886]                   options(future.plan = NULL)
[13:21:59.886]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:59.886]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:59.886]                 }
[13:21:59.886]                 ...future.workdir <- getwd()
[13:21:59.886]             }
[13:21:59.886]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:59.886]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:59.886]         }
[13:21:59.886]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:59.886]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:59.886]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:59.886]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:59.886]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:59.886]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:59.886]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:59.886]             base::names(...future.oldOptions))
[13:21:59.886]     }
[13:21:59.886]     if (FALSE) {
[13:21:59.886]     }
[13:21:59.886]     else {
[13:21:59.886]         if (TRUE) {
[13:21:59.886]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:59.886]                 open = "w")
[13:21:59.886]         }
[13:21:59.886]         else {
[13:21:59.886]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:59.886]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:59.886]         }
[13:21:59.886]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:59.886]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:59.886]             base::sink(type = "output", split = FALSE)
[13:21:59.886]             base::close(...future.stdout)
[13:21:59.886]         }, add = TRUE)
[13:21:59.886]     }
[13:21:59.886]     ...future.frame <- base::sys.nframe()
[13:21:59.886]     ...future.conditions <- base::list()
[13:21:59.886]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:59.886]     if (FALSE) {
[13:21:59.886]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:59.886]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:59.886]     }
[13:21:59.886]     ...future.result <- base::tryCatch({
[13:21:59.886]         base::withCallingHandlers({
[13:21:59.886]             ...future.value <- base::withVisible(base::local({
[13:21:59.886]                 withCallingHandlers({
[13:21:59.886]                   {
[13:21:59.886]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:59.886]                     if (!identical(...future.globals.maxSize.org, 
[13:21:59.886]                       ...future.globals.maxSize)) {
[13:21:59.886]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:59.886]                       on.exit(options(oopts), add = TRUE)
[13:21:59.886]                     }
[13:21:59.886]                     {
[13:21:59.886]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:21:59.886]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:21:59.886]                         USE.NAMES = FALSE)
[13:21:59.886]                       do.call(mapply, args = args)
[13:21:59.886]                     }
[13:21:59.886]                   }
[13:21:59.886]                 }, immediateCondition = function(cond) {
[13:21:59.886]                   save_rds <- function (object, pathname, ...) 
[13:21:59.886]                   {
[13:21:59.886]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:59.886]                     if (file_test("-f", pathname_tmp)) {
[13:21:59.886]                       fi_tmp <- file.info(pathname_tmp)
[13:21:59.886]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:59.886]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:59.886]                         fi_tmp[["mtime"]])
[13:21:59.886]                     }
[13:21:59.886]                     tryCatch({
[13:21:59.886]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:59.886]                     }, error = function(ex) {
[13:21:59.886]                       msg <- conditionMessage(ex)
[13:21:59.886]                       fi_tmp <- file.info(pathname_tmp)
[13:21:59.886]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:59.886]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:59.886]                         fi_tmp[["mtime"]], msg)
[13:21:59.886]                       ex$message <- msg
[13:21:59.886]                       stop(ex)
[13:21:59.886]                     })
[13:21:59.886]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:59.886]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:59.886]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:59.886]                       fi_tmp <- file.info(pathname_tmp)
[13:21:59.886]                       fi <- file.info(pathname)
[13:21:59.886]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:59.886]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:59.886]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:59.886]                         fi[["size"]], fi[["mtime"]])
[13:21:59.886]                       stop(msg)
[13:21:59.886]                     }
[13:21:59.886]                     invisible(pathname)
[13:21:59.886]                   }
[13:21:59.886]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:59.886]                     rootPath = tempdir()) 
[13:21:59.886]                   {
[13:21:59.886]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:59.886]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:59.886]                       tmpdir = path, fileext = ".rds")
[13:21:59.886]                     save_rds(obj, file)
[13:21:59.886]                   }
[13:21:59.886]                   saveImmediateCondition(cond, path = "/tmp/Rtmp78O1Lc/.future/immediateConditions")
[13:21:59.886]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.886]                   {
[13:21:59.886]                     inherits <- base::inherits
[13:21:59.886]                     invokeRestart <- base::invokeRestart
[13:21:59.886]                     is.null <- base::is.null
[13:21:59.886]                     muffled <- FALSE
[13:21:59.886]                     if (inherits(cond, "message")) {
[13:21:59.886]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:59.886]                       if (muffled) 
[13:21:59.886]                         invokeRestart("muffleMessage")
[13:21:59.886]                     }
[13:21:59.886]                     else if (inherits(cond, "warning")) {
[13:21:59.886]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:59.886]                       if (muffled) 
[13:21:59.886]                         invokeRestart("muffleWarning")
[13:21:59.886]                     }
[13:21:59.886]                     else if (inherits(cond, "condition")) {
[13:21:59.886]                       if (!is.null(pattern)) {
[13:21:59.886]                         computeRestarts <- base::computeRestarts
[13:21:59.886]                         grepl <- base::grepl
[13:21:59.886]                         restarts <- computeRestarts(cond)
[13:21:59.886]                         for (restart in restarts) {
[13:21:59.886]                           name <- restart$name
[13:21:59.886]                           if (is.null(name)) 
[13:21:59.886]                             next
[13:21:59.886]                           if (!grepl(pattern, name)) 
[13:21:59.886]                             next
[13:21:59.886]                           invokeRestart(restart)
[13:21:59.886]                           muffled <- TRUE
[13:21:59.886]                           break
[13:21:59.886]                         }
[13:21:59.886]                       }
[13:21:59.886]                     }
[13:21:59.886]                     invisible(muffled)
[13:21:59.886]                   }
[13:21:59.886]                   muffleCondition(cond)
[13:21:59.886]                 })
[13:21:59.886]             }))
[13:21:59.886]             future::FutureResult(value = ...future.value$value, 
[13:21:59.886]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:59.886]                   ...future.rng), globalenv = if (FALSE) 
[13:21:59.886]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:59.886]                     ...future.globalenv.names))
[13:21:59.886]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:59.886]         }, condition = base::local({
[13:21:59.886]             c <- base::c
[13:21:59.886]             inherits <- base::inherits
[13:21:59.886]             invokeRestart <- base::invokeRestart
[13:21:59.886]             length <- base::length
[13:21:59.886]             list <- base::list
[13:21:59.886]             seq.int <- base::seq.int
[13:21:59.886]             signalCondition <- base::signalCondition
[13:21:59.886]             sys.calls <- base::sys.calls
[13:21:59.886]             `[[` <- base::`[[`
[13:21:59.886]             `+` <- base::`+`
[13:21:59.886]             `<<-` <- base::`<<-`
[13:21:59.886]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:59.886]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:59.886]                   3L)]
[13:21:59.886]             }
[13:21:59.886]             function(cond) {
[13:21:59.886]                 is_error <- inherits(cond, "error")
[13:21:59.886]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:59.886]                   NULL)
[13:21:59.886]                 if (is_error) {
[13:21:59.886]                   sessionInformation <- function() {
[13:21:59.886]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:59.886]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:59.886]                       search = base::search(), system = base::Sys.info())
[13:21:59.886]                   }
[13:21:59.886]                   ...future.conditions[[length(...future.conditions) + 
[13:21:59.886]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:59.886]                     cond$call), session = sessionInformation(), 
[13:21:59.886]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:59.886]                   signalCondition(cond)
[13:21:59.886]                 }
[13:21:59.886]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:59.886]                 "immediateCondition"))) {
[13:21:59.886]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:59.886]                   ...future.conditions[[length(...future.conditions) + 
[13:21:59.886]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:59.886]                   if (TRUE && !signal) {
[13:21:59.886]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.886]                     {
[13:21:59.886]                       inherits <- base::inherits
[13:21:59.886]                       invokeRestart <- base::invokeRestart
[13:21:59.886]                       is.null <- base::is.null
[13:21:59.886]                       muffled <- FALSE
[13:21:59.886]                       if (inherits(cond, "message")) {
[13:21:59.886]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:59.886]                         if (muffled) 
[13:21:59.886]                           invokeRestart("muffleMessage")
[13:21:59.886]                       }
[13:21:59.886]                       else if (inherits(cond, "warning")) {
[13:21:59.886]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:59.886]                         if (muffled) 
[13:21:59.886]                           invokeRestart("muffleWarning")
[13:21:59.886]                       }
[13:21:59.886]                       else if (inherits(cond, "condition")) {
[13:21:59.886]                         if (!is.null(pattern)) {
[13:21:59.886]                           computeRestarts <- base::computeRestarts
[13:21:59.886]                           grepl <- base::grepl
[13:21:59.886]                           restarts <- computeRestarts(cond)
[13:21:59.886]                           for (restart in restarts) {
[13:21:59.886]                             name <- restart$name
[13:21:59.886]                             if (is.null(name)) 
[13:21:59.886]                               next
[13:21:59.886]                             if (!grepl(pattern, name)) 
[13:21:59.886]                               next
[13:21:59.886]                             invokeRestart(restart)
[13:21:59.886]                             muffled <- TRUE
[13:21:59.886]                             break
[13:21:59.886]                           }
[13:21:59.886]                         }
[13:21:59.886]                       }
[13:21:59.886]                       invisible(muffled)
[13:21:59.886]                     }
[13:21:59.886]                     muffleCondition(cond, pattern = "^muffle")
[13:21:59.886]                   }
[13:21:59.886]                 }
[13:21:59.886]                 else {
[13:21:59.886]                   if (TRUE) {
[13:21:59.886]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.886]                     {
[13:21:59.886]                       inherits <- base::inherits
[13:21:59.886]                       invokeRestart <- base::invokeRestart
[13:21:59.886]                       is.null <- base::is.null
[13:21:59.886]                       muffled <- FALSE
[13:21:59.886]                       if (inherits(cond, "message")) {
[13:21:59.886]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:59.886]                         if (muffled) 
[13:21:59.886]                           invokeRestart("muffleMessage")
[13:21:59.886]                       }
[13:21:59.886]                       else if (inherits(cond, "warning")) {
[13:21:59.886]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:59.886]                         if (muffled) 
[13:21:59.886]                           invokeRestart("muffleWarning")
[13:21:59.886]                       }
[13:21:59.886]                       else if (inherits(cond, "condition")) {
[13:21:59.886]                         if (!is.null(pattern)) {
[13:21:59.886]                           computeRestarts <- base::computeRestarts
[13:21:59.886]                           grepl <- base::grepl
[13:21:59.886]                           restarts <- computeRestarts(cond)
[13:21:59.886]                           for (restart in restarts) {
[13:21:59.886]                             name <- restart$name
[13:21:59.886]                             if (is.null(name)) 
[13:21:59.886]                               next
[13:21:59.886]                             if (!grepl(pattern, name)) 
[13:21:59.886]                               next
[13:21:59.886]                             invokeRestart(restart)
[13:21:59.886]                             muffled <- TRUE
[13:21:59.886]                             break
[13:21:59.886]                           }
[13:21:59.886]                         }
[13:21:59.886]                       }
[13:21:59.886]                       invisible(muffled)
[13:21:59.886]                     }
[13:21:59.886]                     muffleCondition(cond, pattern = "^muffle")
[13:21:59.886]                   }
[13:21:59.886]                 }
[13:21:59.886]             }
[13:21:59.886]         }))
[13:21:59.886]     }, error = function(ex) {
[13:21:59.886]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:59.886]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:59.886]                 ...future.rng), started = ...future.startTime, 
[13:21:59.886]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:59.886]             version = "1.8"), class = "FutureResult")
[13:21:59.886]     }, finally = {
[13:21:59.886]         if (!identical(...future.workdir, getwd())) 
[13:21:59.886]             setwd(...future.workdir)
[13:21:59.886]         {
[13:21:59.886]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:59.886]                 ...future.oldOptions$nwarnings <- NULL
[13:21:59.886]             }
[13:21:59.886]             base::options(...future.oldOptions)
[13:21:59.886]             if (.Platform$OS.type == "windows") {
[13:21:59.886]                 old_names <- names(...future.oldEnvVars)
[13:21:59.886]                 envs <- base::Sys.getenv()
[13:21:59.886]                 names <- names(envs)
[13:21:59.886]                 common <- intersect(names, old_names)
[13:21:59.886]                 added <- setdiff(names, old_names)
[13:21:59.886]                 removed <- setdiff(old_names, names)
[13:21:59.886]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:59.886]                   envs[common]]
[13:21:59.886]                 NAMES <- toupper(changed)
[13:21:59.886]                 args <- list()
[13:21:59.886]                 for (kk in seq_along(NAMES)) {
[13:21:59.886]                   name <- changed[[kk]]
[13:21:59.886]                   NAME <- NAMES[[kk]]
[13:21:59.886]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.886]                     next
[13:21:59.886]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:59.886]                 }
[13:21:59.886]                 NAMES <- toupper(added)
[13:21:59.886]                 for (kk in seq_along(NAMES)) {
[13:21:59.886]                   name <- added[[kk]]
[13:21:59.886]                   NAME <- NAMES[[kk]]
[13:21:59.886]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.886]                     next
[13:21:59.886]                   args[[name]] <- ""
[13:21:59.886]                 }
[13:21:59.886]                 NAMES <- toupper(removed)
[13:21:59.886]                 for (kk in seq_along(NAMES)) {
[13:21:59.886]                   name <- removed[[kk]]
[13:21:59.886]                   NAME <- NAMES[[kk]]
[13:21:59.886]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.886]                     next
[13:21:59.886]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:59.886]                 }
[13:21:59.886]                 if (length(args) > 0) 
[13:21:59.886]                   base::do.call(base::Sys.setenv, args = args)
[13:21:59.886]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:59.886]             }
[13:21:59.886]             else {
[13:21:59.886]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:59.886]             }
[13:21:59.886]             {
[13:21:59.886]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:59.886]                   0L) {
[13:21:59.886]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:59.886]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:59.886]                   base::options(opts)
[13:21:59.886]                 }
[13:21:59.886]                 {
[13:21:59.886]                   {
[13:21:59.886]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:59.886]                     NULL
[13:21:59.886]                   }
[13:21:59.886]                   options(future.plan = NULL)
[13:21:59.886]                   if (is.na(NA_character_)) 
[13:21:59.886]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:59.886]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:59.886]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:59.886]                     envir = parent.frame()) 
[13:21:59.886]                   {
[13:21:59.886]                     default_workers <- missing(workers)
[13:21:59.886]                     if (is.function(workers)) 
[13:21:59.886]                       workers <- workers()
[13:21:59.886]                     workers <- structure(as.integer(workers), 
[13:21:59.886]                       class = class(workers))
[13:21:59.886]                     stop_if_not(is.finite(workers), workers >= 
[13:21:59.886]                       1L)
[13:21:59.886]                     if ((workers == 1L && !inherits(workers, 
[13:21:59.886]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:59.886]                       if (default_workers) 
[13:21:59.886]                         supportsMulticore(warn = TRUE)
[13:21:59.886]                       return(sequential(..., envir = envir))
[13:21:59.886]                     }
[13:21:59.886]                     oopts <- options(mc.cores = workers)
[13:21:59.886]                     on.exit(options(oopts))
[13:21:59.886]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:59.886]                       envir = envir)
[13:21:59.886]                     if (!future$lazy) 
[13:21:59.886]                       future <- run(future)
[13:21:59.886]                     invisible(future)
[13:21:59.886]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:59.886]                 }
[13:21:59.886]             }
[13:21:59.886]         }
[13:21:59.886]     })
[13:21:59.886]     if (TRUE) {
[13:21:59.886]         base::sink(type = "output", split = FALSE)
[13:21:59.886]         if (TRUE) {
[13:21:59.886]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:59.886]         }
[13:21:59.886]         else {
[13:21:59.886]             ...future.result["stdout"] <- base::list(NULL)
[13:21:59.886]         }
[13:21:59.886]         base::close(...future.stdout)
[13:21:59.886]         ...future.stdout <- NULL
[13:21:59.886]     }
[13:21:59.886]     ...future.result$conditions <- ...future.conditions
[13:21:59.886]     ...future.result$finished <- base::Sys.time()
[13:21:59.886]     ...future.result
[13:21:59.886] }
[13:21:59.888] assign_globals() ...
[13:21:59.888] List of 5
[13:21:59.888]  $ ...future.FUN            :function (x, y)  
[13:21:59.888]  $ MoreArgs                 : NULL
[13:21:59.888]  $ ...future.elements_ii    :List of 2
[13:21:59.888]   ..$ :List of 1
[13:21:59.888]   .. ..$ : int 1
[13:21:59.888]   ..$ :List of 1
[13:21:59.888]   .. ..$ : int 0
[13:21:59.888]  $ ...future.seeds_ii       : NULL
[13:21:59.888]  $ ...future.globals.maxSize: NULL
[13:21:59.888]  - attr(*, "where")=List of 5
[13:21:59.888]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:59.888]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:21:59.888]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:59.888]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:59.888]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:59.888]  - attr(*, "resolved")= logi FALSE
[13:21:59.888]  - attr(*, "total_size")= num 6368
[13:21:59.888]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:59.888]  - attr(*, "already-done")= logi TRUE
[13:21:59.894] - reassign environment for ‘...future.FUN’
[13:21:59.894] - copied ‘...future.FUN’ to environment
[13:21:59.894] - copied ‘MoreArgs’ to environment
[13:21:59.894] - copied ‘...future.elements_ii’ to environment
[13:21:59.894] - copied ‘...future.seeds_ii’ to environment
[13:21:59.894] - copied ‘...future.globals.maxSize’ to environment
[13:21:59.894] assign_globals() ... done
[13:21:59.894] requestCore(): workers = 2
[13:21:59.897] MulticoreFuture started
[13:21:59.897] - Launch lazy future ... done
[13:21:59.897] run() for ‘MulticoreFuture’ ... done
[13:21:59.898] Created future:
[13:21:59.898] plan(): Setting new future strategy stack:
[13:21:59.898] List of future strategies:
[13:21:59.898] 1. sequential:
[13:21:59.898]    - args: function (..., envir = parent.frame())
[13:21:59.898]    - tweaked: FALSE
[13:21:59.898]    - call: NULL
[13:21:59.899] plan(): nbrOfWorkers() = 1
[13:21:59.898] MulticoreFuture:
[13:21:59.898] Label: ‘future_mapply-1’
[13:21:59.898] Expression:
[13:21:59.898] {
[13:21:59.898]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:59.898]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:59.898]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:59.898]         on.exit(options(oopts), add = TRUE)
[13:21:59.898]     }
[13:21:59.898]     {
[13:21:59.898]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:21:59.898]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:21:59.898]         do.call(mapply, args = args)
[13:21:59.898]     }
[13:21:59.898] }
[13:21:59.898] Lazy evaluation: FALSE
[13:21:59.898] Asynchronous evaluation: TRUE
[13:21:59.898] Local evaluation: TRUE
[13:21:59.898] Environment: R_GlobalEnv
[13:21:59.898] Capture standard output: TRUE
[13:21:59.898] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:59.898] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:59.898] Packages: <none>
[13:21:59.898] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:59.898] Resolved: FALSE
[13:21:59.898] Value: <not collected>
[13:21:59.898] Conditions captured: <none>
[13:21:59.898] Early signaling: FALSE
[13:21:59.898] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:21:59.898] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:59.911] Chunk #1 of 2 ... DONE
[13:21:59.911] Chunk #2 of 2 ...
[13:21:59.911]  - Finding globals in '...' for chunk #2 ...
[13:21:59.911] getGlobalsAndPackages() ...
[13:21:59.911] Searching for globals...
[13:21:59.912] 
[13:21:59.912] Searching for globals ... DONE
[13:21:59.912] - globals: [0] <none>
[13:21:59.913] getGlobalsAndPackages() ... DONE
[13:21:59.913]    + additional globals found: [n=0] 
[13:21:59.913]    + additional namespaces needed: [n=0] 
[13:21:59.913]  - Finding globals in '...' for chunk #2 ... DONE
[13:21:59.913]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:59.913]  - seeds: <none>
[13:21:59.914]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:59.914] getGlobalsAndPackages() ...
[13:21:59.914] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:59.914] Resolving globals: FALSE
[13:21:59.915] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:21:59.928] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:21:59.928] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:59.928] 
[13:21:59.929] getGlobalsAndPackages() ... DONE
[13:21:59.929] run() for ‘Future’ ...
[13:21:59.929] - state: ‘created’
[13:21:59.929] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:59.934] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:59.935] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:59.935]   - Field: ‘label’
[13:21:59.935]   - Field: ‘local’
[13:21:59.935]   - Field: ‘owner’
[13:21:59.936]   - Field: ‘envir’
[13:21:59.936]   - Field: ‘workers’
[13:21:59.936]   - Field: ‘packages’
[13:21:59.936]   - Field: ‘gc’
[13:21:59.936]   - Field: ‘job’
[13:21:59.936]   - Field: ‘conditions’
[13:21:59.937]   - Field: ‘expr’
[13:21:59.937]   - Field: ‘uuid’
[13:21:59.937]   - Field: ‘seed’
[13:21:59.937]   - Field: ‘version’
[13:21:59.937]   - Field: ‘result’
[13:21:59.937]   - Field: ‘asynchronous’
[13:21:59.937]   - Field: ‘calls’
[13:21:59.937]   - Field: ‘globals’
[13:21:59.938]   - Field: ‘stdout’
[13:21:59.938]   - Field: ‘earlySignal’
[13:21:59.938]   - Field: ‘lazy’
[13:21:59.938]   - Field: ‘state’
[13:21:59.938] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:59.939] - Launch lazy future ...
[13:21:59.939] Packages needed by the future expression (n = 0): <none>
[13:21:59.939] Packages needed by future strategies (n = 0): <none>
[13:21:59.940] {
[13:21:59.940]     {
[13:21:59.940]         {
[13:21:59.940]             ...future.startTime <- base::Sys.time()
[13:21:59.940]             {
[13:21:59.940]                 {
[13:21:59.940]                   {
[13:21:59.940]                     {
[13:21:59.940]                       base::local({
[13:21:59.940]                         has_future <- base::requireNamespace("future", 
[13:21:59.940]                           quietly = TRUE)
[13:21:59.940]                         if (has_future) {
[13:21:59.940]                           ns <- base::getNamespace("future")
[13:21:59.940]                           version <- ns[[".package"]][["version"]]
[13:21:59.940]                           if (is.null(version)) 
[13:21:59.940]                             version <- utils::packageVersion("future")
[13:21:59.940]                         }
[13:21:59.940]                         else {
[13:21:59.940]                           version <- NULL
[13:21:59.940]                         }
[13:21:59.940]                         if (!has_future || version < "1.8.0") {
[13:21:59.940]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:59.940]                             "", base::R.version$version.string), 
[13:21:59.940]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:59.940]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:59.940]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:59.940]                               "release", "version")], collapse = " "), 
[13:21:59.940]                             hostname = base::Sys.info()[["nodename"]])
[13:21:59.940]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:59.940]                             info)
[13:21:59.940]                           info <- base::paste(info, collapse = "; ")
[13:21:59.940]                           if (!has_future) {
[13:21:59.940]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:59.940]                               info)
[13:21:59.940]                           }
[13:21:59.940]                           else {
[13:21:59.940]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:59.940]                               info, version)
[13:21:59.940]                           }
[13:21:59.940]                           base::stop(msg)
[13:21:59.940]                         }
[13:21:59.940]                       })
[13:21:59.940]                     }
[13:21:59.940]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:59.940]                     base::options(mc.cores = 1L)
[13:21:59.940]                   }
[13:21:59.940]                   options(future.plan = NULL)
[13:21:59.940]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:59.940]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:59.940]                 }
[13:21:59.940]                 ...future.workdir <- getwd()
[13:21:59.940]             }
[13:21:59.940]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:59.940]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:59.940]         }
[13:21:59.940]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:59.940]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:59.940]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:59.940]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:59.940]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:59.940]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:59.940]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:59.940]             base::names(...future.oldOptions))
[13:21:59.940]     }
[13:21:59.940]     if (FALSE) {
[13:21:59.940]     }
[13:21:59.940]     else {
[13:21:59.940]         if (TRUE) {
[13:21:59.940]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:59.940]                 open = "w")
[13:21:59.940]         }
[13:21:59.940]         else {
[13:21:59.940]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:59.940]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:59.940]         }
[13:21:59.940]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:59.940]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:59.940]             base::sink(type = "output", split = FALSE)
[13:21:59.940]             base::close(...future.stdout)
[13:21:59.940]         }, add = TRUE)
[13:21:59.940]     }
[13:21:59.940]     ...future.frame <- base::sys.nframe()
[13:21:59.940]     ...future.conditions <- base::list()
[13:21:59.940]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:59.940]     if (FALSE) {
[13:21:59.940]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:59.940]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:59.940]     }
[13:21:59.940]     ...future.result <- base::tryCatch({
[13:21:59.940]         base::withCallingHandlers({
[13:21:59.940]             ...future.value <- base::withVisible(base::local({
[13:21:59.940]                 withCallingHandlers({
[13:21:59.940]                   {
[13:21:59.940]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:59.940]                     if (!identical(...future.globals.maxSize.org, 
[13:21:59.940]                       ...future.globals.maxSize)) {
[13:21:59.940]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:59.940]                       on.exit(options(oopts), add = TRUE)
[13:21:59.940]                     }
[13:21:59.940]                     {
[13:21:59.940]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:21:59.940]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:21:59.940]                         USE.NAMES = FALSE)
[13:21:59.940]                       do.call(mapply, args = args)
[13:21:59.940]                     }
[13:21:59.940]                   }
[13:21:59.940]                 }, immediateCondition = function(cond) {
[13:21:59.940]                   save_rds <- function (object, pathname, ...) 
[13:21:59.940]                   {
[13:21:59.940]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:59.940]                     if (file_test("-f", pathname_tmp)) {
[13:21:59.940]                       fi_tmp <- file.info(pathname_tmp)
[13:21:59.940]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:59.940]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:59.940]                         fi_tmp[["mtime"]])
[13:21:59.940]                     }
[13:21:59.940]                     tryCatch({
[13:21:59.940]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:59.940]                     }, error = function(ex) {
[13:21:59.940]                       msg <- conditionMessage(ex)
[13:21:59.940]                       fi_tmp <- file.info(pathname_tmp)
[13:21:59.940]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:59.940]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:59.940]                         fi_tmp[["mtime"]], msg)
[13:21:59.940]                       ex$message <- msg
[13:21:59.940]                       stop(ex)
[13:21:59.940]                     })
[13:21:59.940]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:59.940]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:59.940]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:59.940]                       fi_tmp <- file.info(pathname_tmp)
[13:21:59.940]                       fi <- file.info(pathname)
[13:21:59.940]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:59.940]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:59.940]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:59.940]                         fi[["size"]], fi[["mtime"]])
[13:21:59.940]                       stop(msg)
[13:21:59.940]                     }
[13:21:59.940]                     invisible(pathname)
[13:21:59.940]                   }
[13:21:59.940]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:59.940]                     rootPath = tempdir()) 
[13:21:59.940]                   {
[13:21:59.940]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:59.940]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:59.940]                       tmpdir = path, fileext = ".rds")
[13:21:59.940]                     save_rds(obj, file)
[13:21:59.940]                   }
[13:21:59.940]                   saveImmediateCondition(cond, path = "/tmp/Rtmp78O1Lc/.future/immediateConditions")
[13:21:59.940]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.940]                   {
[13:21:59.940]                     inherits <- base::inherits
[13:21:59.940]                     invokeRestart <- base::invokeRestart
[13:21:59.940]                     is.null <- base::is.null
[13:21:59.940]                     muffled <- FALSE
[13:21:59.940]                     if (inherits(cond, "message")) {
[13:21:59.940]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:59.940]                       if (muffled) 
[13:21:59.940]                         invokeRestart("muffleMessage")
[13:21:59.940]                     }
[13:21:59.940]                     else if (inherits(cond, "warning")) {
[13:21:59.940]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:59.940]                       if (muffled) 
[13:21:59.940]                         invokeRestart("muffleWarning")
[13:21:59.940]                     }
[13:21:59.940]                     else if (inherits(cond, "condition")) {
[13:21:59.940]                       if (!is.null(pattern)) {
[13:21:59.940]                         computeRestarts <- base::computeRestarts
[13:21:59.940]                         grepl <- base::grepl
[13:21:59.940]                         restarts <- computeRestarts(cond)
[13:21:59.940]                         for (restart in restarts) {
[13:21:59.940]                           name <- restart$name
[13:21:59.940]                           if (is.null(name)) 
[13:21:59.940]                             next
[13:21:59.940]                           if (!grepl(pattern, name)) 
[13:21:59.940]                             next
[13:21:59.940]                           invokeRestart(restart)
[13:21:59.940]                           muffled <- TRUE
[13:21:59.940]                           break
[13:21:59.940]                         }
[13:21:59.940]                       }
[13:21:59.940]                     }
[13:21:59.940]                     invisible(muffled)
[13:21:59.940]                   }
[13:21:59.940]                   muffleCondition(cond)
[13:21:59.940]                 })
[13:21:59.940]             }))
[13:21:59.940]             future::FutureResult(value = ...future.value$value, 
[13:21:59.940]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:59.940]                   ...future.rng), globalenv = if (FALSE) 
[13:21:59.940]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:59.940]                     ...future.globalenv.names))
[13:21:59.940]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:59.940]         }, condition = base::local({
[13:21:59.940]             c <- base::c
[13:21:59.940]             inherits <- base::inherits
[13:21:59.940]             invokeRestart <- base::invokeRestart
[13:21:59.940]             length <- base::length
[13:21:59.940]             list <- base::list
[13:21:59.940]             seq.int <- base::seq.int
[13:21:59.940]             signalCondition <- base::signalCondition
[13:21:59.940]             sys.calls <- base::sys.calls
[13:21:59.940]             `[[` <- base::`[[`
[13:21:59.940]             `+` <- base::`+`
[13:21:59.940]             `<<-` <- base::`<<-`
[13:21:59.940]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:59.940]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:59.940]                   3L)]
[13:21:59.940]             }
[13:21:59.940]             function(cond) {
[13:21:59.940]                 is_error <- inherits(cond, "error")
[13:21:59.940]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:59.940]                   NULL)
[13:21:59.940]                 if (is_error) {
[13:21:59.940]                   sessionInformation <- function() {
[13:21:59.940]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:59.940]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:59.940]                       search = base::search(), system = base::Sys.info())
[13:21:59.940]                   }
[13:21:59.940]                   ...future.conditions[[length(...future.conditions) + 
[13:21:59.940]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:59.940]                     cond$call), session = sessionInformation(), 
[13:21:59.940]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:59.940]                   signalCondition(cond)
[13:21:59.940]                 }
[13:21:59.940]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:59.940]                 "immediateCondition"))) {
[13:21:59.940]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:59.940]                   ...future.conditions[[length(...future.conditions) + 
[13:21:59.940]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:59.940]                   if (TRUE && !signal) {
[13:21:59.940]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.940]                     {
[13:21:59.940]                       inherits <- base::inherits
[13:21:59.940]                       invokeRestart <- base::invokeRestart
[13:21:59.940]                       is.null <- base::is.null
[13:21:59.940]                       muffled <- FALSE
[13:21:59.940]                       if (inherits(cond, "message")) {
[13:21:59.940]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:59.940]                         if (muffled) 
[13:21:59.940]                           invokeRestart("muffleMessage")
[13:21:59.940]                       }
[13:21:59.940]                       else if (inherits(cond, "warning")) {
[13:21:59.940]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:59.940]                         if (muffled) 
[13:21:59.940]                           invokeRestart("muffleWarning")
[13:21:59.940]                       }
[13:21:59.940]                       else if (inherits(cond, "condition")) {
[13:21:59.940]                         if (!is.null(pattern)) {
[13:21:59.940]                           computeRestarts <- base::computeRestarts
[13:21:59.940]                           grepl <- base::grepl
[13:21:59.940]                           restarts <- computeRestarts(cond)
[13:21:59.940]                           for (restart in restarts) {
[13:21:59.940]                             name <- restart$name
[13:21:59.940]                             if (is.null(name)) 
[13:21:59.940]                               next
[13:21:59.940]                             if (!grepl(pattern, name)) 
[13:21:59.940]                               next
[13:21:59.940]                             invokeRestart(restart)
[13:21:59.940]                             muffled <- TRUE
[13:21:59.940]                             break
[13:21:59.940]                           }
[13:21:59.940]                         }
[13:21:59.940]                       }
[13:21:59.940]                       invisible(muffled)
[13:21:59.940]                     }
[13:21:59.940]                     muffleCondition(cond, pattern = "^muffle")
[13:21:59.940]                   }
[13:21:59.940]                 }
[13:21:59.940]                 else {
[13:21:59.940]                   if (TRUE) {
[13:21:59.940]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.940]                     {
[13:21:59.940]                       inherits <- base::inherits
[13:21:59.940]                       invokeRestart <- base::invokeRestart
[13:21:59.940]                       is.null <- base::is.null
[13:21:59.940]                       muffled <- FALSE
[13:21:59.940]                       if (inherits(cond, "message")) {
[13:21:59.940]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:59.940]                         if (muffled) 
[13:21:59.940]                           invokeRestart("muffleMessage")
[13:21:59.940]                       }
[13:21:59.940]                       else if (inherits(cond, "warning")) {
[13:21:59.940]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:59.940]                         if (muffled) 
[13:21:59.940]                           invokeRestart("muffleWarning")
[13:21:59.940]                       }
[13:21:59.940]                       else if (inherits(cond, "condition")) {
[13:21:59.940]                         if (!is.null(pattern)) {
[13:21:59.940]                           computeRestarts <- base::computeRestarts
[13:21:59.940]                           grepl <- base::grepl
[13:21:59.940]                           restarts <- computeRestarts(cond)
[13:21:59.940]                           for (restart in restarts) {
[13:21:59.940]                             name <- restart$name
[13:21:59.940]                             if (is.null(name)) 
[13:21:59.940]                               next
[13:21:59.940]                             if (!grepl(pattern, name)) 
[13:21:59.940]                               next
[13:21:59.940]                             invokeRestart(restart)
[13:21:59.940]                             muffled <- TRUE
[13:21:59.940]                             break
[13:21:59.940]                           }
[13:21:59.940]                         }
[13:21:59.940]                       }
[13:21:59.940]                       invisible(muffled)
[13:21:59.940]                     }
[13:21:59.940]                     muffleCondition(cond, pattern = "^muffle")
[13:21:59.940]                   }
[13:21:59.940]                 }
[13:21:59.940]             }
[13:21:59.940]         }))
[13:21:59.940]     }, error = function(ex) {
[13:21:59.940]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:59.940]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:59.940]                 ...future.rng), started = ...future.startTime, 
[13:21:59.940]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:59.940]             version = "1.8"), class = "FutureResult")
[13:21:59.940]     }, finally = {
[13:21:59.940]         if (!identical(...future.workdir, getwd())) 
[13:21:59.940]             setwd(...future.workdir)
[13:21:59.940]         {
[13:21:59.940]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:59.940]                 ...future.oldOptions$nwarnings <- NULL
[13:21:59.940]             }
[13:21:59.940]             base::options(...future.oldOptions)
[13:21:59.940]             if (.Platform$OS.type == "windows") {
[13:21:59.940]                 old_names <- names(...future.oldEnvVars)
[13:21:59.940]                 envs <- base::Sys.getenv()
[13:21:59.940]                 names <- names(envs)
[13:21:59.940]                 common <- intersect(names, old_names)
[13:21:59.940]                 added <- setdiff(names, old_names)
[13:21:59.940]                 removed <- setdiff(old_names, names)
[13:21:59.940]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:59.940]                   envs[common]]
[13:21:59.940]                 NAMES <- toupper(changed)
[13:21:59.940]                 args <- list()
[13:21:59.940]                 for (kk in seq_along(NAMES)) {
[13:21:59.940]                   name <- changed[[kk]]
[13:21:59.940]                   NAME <- NAMES[[kk]]
[13:21:59.940]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.940]                     next
[13:21:59.940]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:59.940]                 }
[13:21:59.940]                 NAMES <- toupper(added)
[13:21:59.940]                 for (kk in seq_along(NAMES)) {
[13:21:59.940]                   name <- added[[kk]]
[13:21:59.940]                   NAME <- NAMES[[kk]]
[13:21:59.940]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.940]                     next
[13:21:59.940]                   args[[name]] <- ""
[13:21:59.940]                 }
[13:21:59.940]                 NAMES <- toupper(removed)
[13:21:59.940]                 for (kk in seq_along(NAMES)) {
[13:21:59.940]                   name <- removed[[kk]]
[13:21:59.940]                   NAME <- NAMES[[kk]]
[13:21:59.940]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.940]                     next
[13:21:59.940]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:59.940]                 }
[13:21:59.940]                 if (length(args) > 0) 
[13:21:59.940]                   base::do.call(base::Sys.setenv, args = args)
[13:21:59.940]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:59.940]             }
[13:21:59.940]             else {
[13:21:59.940]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:59.940]             }
[13:21:59.940]             {
[13:21:59.940]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:59.940]                   0L) {
[13:21:59.940]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:59.940]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:59.940]                   base::options(opts)
[13:21:59.940]                 }
[13:21:59.940]                 {
[13:21:59.940]                   {
[13:21:59.940]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:59.940]                     NULL
[13:21:59.940]                   }
[13:21:59.940]                   options(future.plan = NULL)
[13:21:59.940]                   if (is.na(NA_character_)) 
[13:21:59.940]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:59.940]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:59.940]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:59.940]                     envir = parent.frame()) 
[13:21:59.940]                   {
[13:21:59.940]                     default_workers <- missing(workers)
[13:21:59.940]                     if (is.function(workers)) 
[13:21:59.940]                       workers <- workers()
[13:21:59.940]                     workers <- structure(as.integer(workers), 
[13:21:59.940]                       class = class(workers))
[13:21:59.940]                     stop_if_not(is.finite(workers), workers >= 
[13:21:59.940]                       1L)
[13:21:59.940]                     if ((workers == 1L && !inherits(workers, 
[13:21:59.940]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:59.940]                       if (default_workers) 
[13:21:59.940]                         supportsMulticore(warn = TRUE)
[13:21:59.940]                       return(sequential(..., envir = envir))
[13:21:59.940]                     }
[13:21:59.940]                     oopts <- options(mc.cores = workers)
[13:21:59.940]                     on.exit(options(oopts))
[13:21:59.940]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:59.940]                       envir = envir)
[13:21:59.940]                     if (!future$lazy) 
[13:21:59.940]                       future <- run(future)
[13:21:59.940]                     invisible(future)
[13:21:59.940]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:59.940]                 }
[13:21:59.940]             }
[13:21:59.940]         }
[13:21:59.940]     })
[13:21:59.940]     if (TRUE) {
[13:21:59.940]         base::sink(type = "output", split = FALSE)
[13:21:59.940]         if (TRUE) {
[13:21:59.940]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:59.940]         }
[13:21:59.940]         else {
[13:21:59.940]             ...future.result["stdout"] <- base::list(NULL)
[13:21:59.940]         }
[13:21:59.940]         base::close(...future.stdout)
[13:21:59.940]         ...future.stdout <- NULL
[13:21:59.940]     }
[13:21:59.940]     ...future.result$conditions <- ...future.conditions
[13:21:59.940]     ...future.result$finished <- base::Sys.time()
[13:21:59.940]     ...future.result
[13:21:59.940] }
[13:21:59.943] assign_globals() ...
[13:21:59.943] List of 5
[13:21:59.943]  $ ...future.FUN            :function (x, y)  
[13:21:59.943]  $ MoreArgs                 : NULL
[13:21:59.943]  $ ...future.elements_ii    :List of 2
[13:21:59.943]   ..$ :List of 1
[13:21:59.943]   .. ..$ : int 0
[13:21:59.943]   ..$ :List of 1
[13:21:59.943]   .. ..$ : int 1
[13:21:59.943]  $ ...future.seeds_ii       : NULL
[13:21:59.943]  $ ...future.globals.maxSize: NULL
[13:21:59.943]  - attr(*, "where")=List of 5
[13:21:59.943]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:59.943]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:21:59.943]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:59.943]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:59.943]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:59.943]  - attr(*, "resolved")= logi FALSE
[13:21:59.943]  - attr(*, "total_size")= num 6368
[13:21:59.943]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:59.943]  - attr(*, "already-done")= logi TRUE
[13:21:59.950] - reassign environment for ‘...future.FUN’
[13:21:59.950] - copied ‘...future.FUN’ to environment
[13:21:59.950] - copied ‘MoreArgs’ to environment
[13:21:59.950] - copied ‘...future.elements_ii’ to environment
[13:21:59.950] - copied ‘...future.seeds_ii’ to environment
[13:21:59.950] - copied ‘...future.globals.maxSize’ to environment
[13:21:59.950] assign_globals() ... done
[13:21:59.950] requestCore(): workers = 2
[13:21:59.953] MulticoreFuture started
[13:21:59.953] - Launch lazy future ... done
[13:21:59.953] run() for ‘MulticoreFuture’ ... done
[13:21:59.954] Created future:
[13:21:59.954] plan(): Setting new future strategy stack:
[13:21:59.954] List of future strategies:
[13:21:59.954] 1. sequential:
[13:21:59.954]    - args: function (..., envir = parent.frame())
[13:21:59.954]    - tweaked: FALSE
[13:21:59.954]    - call: NULL
[13:21:59.955] plan(): nbrOfWorkers() = 1
[13:21:59.957] plan(): Setting new future strategy stack:
[13:21:59.957] List of future strategies:
[13:21:59.957] 1. multicore:
[13:21:59.957]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:59.957]    - tweaked: FALSE
[13:21:59.957]    - call: plan(strategy)
[13:21:59.963] plan(): nbrOfWorkers() = 2
[13:21:59.954] MulticoreFuture:
[13:21:59.954] Label: ‘future_mapply-2’
[13:21:59.954] Expression:
[13:21:59.954] {
[13:21:59.954]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:59.954]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:59.954]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:59.954]         on.exit(options(oopts), add = TRUE)
[13:21:59.954]     }
[13:21:59.954]     {
[13:21:59.954]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:21:59.954]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:21:59.954]         do.call(mapply, args = args)
[13:21:59.954]     }
[13:21:59.954] }
[13:21:59.954] Lazy evaluation: FALSE
[13:21:59.954] Asynchronous evaluation: TRUE
[13:21:59.954] Local evaluation: TRUE
[13:21:59.954] Environment: R_GlobalEnv
[13:21:59.954] Capture standard output: TRUE
[13:21:59.954] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:59.954] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:59.954] Packages: <none>
[13:21:59.954] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:59.954] Resolved: TRUE
[13:21:59.954] Value: <not collected>
[13:21:59.954] Conditions captured: <none>
[13:21:59.954] Early signaling: FALSE
[13:21:59.954] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:21:59.954] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:59.964] Chunk #2 of 2 ... DONE
[13:21:59.964] Launching 2 futures (chunks) ... DONE
[13:21:59.964] Resolving 2 futures (chunks) ...
[13:21:59.965] resolve() on list ...
[13:21:59.965]  recursive: 0
[13:21:59.965]  length: 2
[13:21:59.965] 
[13:21:59.976] Future #2
[13:21:59.976] result() for MulticoreFuture ...
[13:21:59.977] result() for MulticoreFuture ...
[13:21:59.977] result() for MulticoreFuture ... done
[13:21:59.977] result() for MulticoreFuture ... done
[13:21:59.978] result() for MulticoreFuture ...
[13:21:59.978] result() for MulticoreFuture ... done
[13:21:59.978] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:21:59.978] - nx: 2
[13:21:59.978] - relay: TRUE
[13:21:59.978] - stdout: TRUE
[13:21:59.978] - signal: TRUE
[13:21:59.978] - resignal: FALSE
[13:21:59.979] - force: TRUE
[13:21:59.979] - relayed: [n=2] FALSE, FALSE
[13:21:59.979] - queued futures: [n=2] FALSE, FALSE
[13:21:59.979]  - until=1
[13:21:59.979]  - relaying element #1
[13:21:59.979] - relayed: [n=2] FALSE, FALSE
[13:21:59.979] - queued futures: [n=2] FALSE, TRUE
[13:21:59.980] signalConditionsASAP(NULL, pos=2) ... done
[13:21:59.980]  length: 1 (resolved future 2)
[13:22:00.402] plan(): Setting new future strategy stack:
[13:22:00.402] List of future strategies:
[13:22:00.402] 1. multicore:
[13:22:00.402]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:00.402]    - tweaked: FALSE
[13:22:00.402]    - call: plan(strategy)
[13:22:00.407] plan(): nbrOfWorkers() = 2
[13:22:00.408] Future #1
[13:22:00.408] result() for MulticoreFuture ...
[13:22:00.409] result() for MulticoreFuture ...
[13:22:00.409] result() for MulticoreFuture ... done
[13:22:00.409] result() for MulticoreFuture ... done
[13:22:00.409] result() for MulticoreFuture ...
[13:22:00.409] result() for MulticoreFuture ... done
[13:22:00.409] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:22:00.410] - nx: 2
[13:22:00.410] - relay: TRUE
[13:22:00.410] - stdout: TRUE
[13:22:00.410] - signal: TRUE
[13:22:00.410] - resignal: FALSE
[13:22:00.410] - force: TRUE
[13:22:00.410] - relayed: [n=2] FALSE, FALSE
[13:22:00.410] - queued futures: [n=2] FALSE, TRUE
[13:22:00.410]  - until=1
[13:22:00.411]  - relaying element #1
[13:22:00.411] result() for MulticoreFuture ...
[13:22:00.411] result() for MulticoreFuture ... done
[13:22:00.411] result() for MulticoreFuture ...
[13:22:00.411] result() for MulticoreFuture ... done
[13:22:00.411] result() for MulticoreFuture ...
[13:22:00.411] result() for MulticoreFuture ... done
[13:22:00.411] result() for MulticoreFuture ...
[13:22:00.412] result() for MulticoreFuture ... done
[13:22:00.412] - relayed: [n=2] TRUE, FALSE
[13:22:00.412] - queued futures: [n=2] TRUE, TRUE
[13:22:00.412] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:22:00.412]  length: 0 (resolved future 1)
[13:22:00.412] Relaying remaining futures
[13:22:00.412] signalConditionsASAP(NULL, pos=0) ...
[13:22:00.415] - nx: 2
[13:22:00.415] - relay: TRUE
[13:22:00.415] - stdout: TRUE
[13:22:00.416] - signal: TRUE
[13:22:00.416] - resignal: FALSE
[13:22:00.416] - force: TRUE
[13:22:00.416] - relayed: [n=2] TRUE, FALSE
[13:22:00.416] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:22:00.417]  - relaying element #2
[13:22:00.417] result() for MulticoreFuture ...
[13:22:00.417] result() for MulticoreFuture ... done
[13:22:00.417] result() for MulticoreFuture ...
[13:22:00.417] result() for MulticoreFuture ... done
[13:22:00.417] result() for MulticoreFuture ...
[13:22:00.418] result() for MulticoreFuture ... done
[13:22:00.418] result() for MulticoreFuture ...
[13:22:00.418] result() for MulticoreFuture ... done
[13:22:00.418] - relayed: [n=2] TRUE, TRUE
[13:22:00.418] - queued futures: [n=2] TRUE, TRUE
[13:22:00.418] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[13:22:00.419] resolve() on list ... DONE
[13:22:00.419] result() for MulticoreFuture ...
[13:22:00.419] result() for MulticoreFuture ... done
[13:22:00.419] result() for MulticoreFuture ...
[13:22:00.419] result() for MulticoreFuture ... done
[13:22:00.419] result() for MulticoreFuture ...
[13:22:00.419] result() for MulticoreFuture ... done
[13:22:00.420] result() for MulticoreFuture ...
[13:22:00.420] result() for MulticoreFuture ... done
[13:22:00.420]  - Number of value chunks collected: 2
[13:22:00.420] Resolving 2 futures (chunks) ... DONE
[13:22:00.420] Reducing values from 2 chunks ...
[13:22:00.420]  - Number of values collected after concatenation: 2
[13:22:00.420]  - Number of values expected: 2
[13:22:00.421] Reducing values from 2 chunks ... DONE
[13:22:00.421] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[13:22:00.421] future_mapply() ...
[13:22:00.426] Number of chunks: 2
[13:22:00.426] getGlobalsAndPackagesXApply() ...
[13:22:00.426]  - future.globals: TRUE
[13:22:00.426] getGlobalsAndPackages() ...
[13:22:00.426] Searching for globals...
[13:22:00.428] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:22:00.429] Searching for globals ... DONE
[13:22:00.429] Resolving globals: FALSE
[13:22:00.429] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:22:00.430] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:22:00.430] - globals: [1] ‘FUN’
[13:22:00.430] 
[13:22:00.430] getGlobalsAndPackages() ... DONE
[13:22:00.430]  - globals found/used: [n=1] ‘FUN’
[13:22:00.430]  - needed namespaces: [n=0] 
[13:22:00.430] Finding globals ... DONE
[13:22:00.430] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:22:00.431] List of 2
[13:22:00.431]  $ ...future.FUN:function (x, y)  
[13:22:00.431]  $ MoreArgs     : NULL
[13:22:00.431]  - attr(*, "where")=List of 2
[13:22:00.431]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:22:00.431]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:22:00.431]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:22:00.431]  - attr(*, "resolved")= logi FALSE
[13:22:00.431]  - attr(*, "total_size")= num NA
[13:22:00.434] Packages to be attached in all futures: [n=0] 
[13:22:00.434] getGlobalsAndPackagesXApply() ... DONE
[13:22:00.434] Number of futures (= number of chunks): 2
[13:22:00.434] Launching 2 futures (chunks) ...
[13:22:00.434] Chunk #1 of 2 ...
[13:22:00.434]  - Finding globals in '...' for chunk #1 ...
[13:22:00.434] getGlobalsAndPackages() ...
[13:22:00.434] Searching for globals...
[13:22:00.435] 
[13:22:00.435] Searching for globals ... DONE
[13:22:00.435] - globals: [0] <none>
[13:22:00.435] getGlobalsAndPackages() ... DONE
[13:22:00.435]    + additional globals found: [n=0] 
[13:22:00.435]    + additional namespaces needed: [n=0] 
[13:22:00.435]  - Finding globals in '...' for chunk #1 ... DONE
[13:22:00.435]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:22:00.435]  - seeds: <none>
[13:22:00.436]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:00.436] getGlobalsAndPackages() ...
[13:22:00.436] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:00.436] Resolving globals: FALSE
[13:22:00.436] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:22:00.437] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:22:00.437] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:00.437] 
[13:22:00.437] getGlobalsAndPackages() ... DONE
[13:22:00.438] run() for ‘Future’ ...
[13:22:00.438] - state: ‘created’
[13:22:00.438] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:22:00.442] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:00.442] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:22:00.442]   - Field: ‘label’
[13:22:00.442]   - Field: ‘local’
[13:22:00.442]   - Field: ‘owner’
[13:22:00.442]   - Field: ‘envir’
[13:22:00.442]   - Field: ‘workers’
[13:22:00.442]   - Field: ‘packages’
[13:22:00.442]   - Field: ‘gc’
[13:22:00.443]   - Field: ‘job’
[13:22:00.443]   - Field: ‘conditions’
[13:22:00.443]   - Field: ‘expr’
[13:22:00.443]   - Field: ‘uuid’
[13:22:00.443]   - Field: ‘seed’
[13:22:00.443]   - Field: ‘version’
[13:22:00.443]   - Field: ‘result’
[13:22:00.443]   - Field: ‘asynchronous’
[13:22:00.443]   - Field: ‘calls’
[13:22:00.443]   - Field: ‘globals’
[13:22:00.443]   - Field: ‘stdout’
[13:22:00.444]   - Field: ‘earlySignal’
[13:22:00.444]   - Field: ‘lazy’
[13:22:00.444]   - Field: ‘state’
[13:22:00.444] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:22:00.444] - Launch lazy future ...
[13:22:00.444] Packages needed by the future expression (n = 0): <none>
[13:22:00.444] Packages needed by future strategies (n = 0): <none>
[13:22:00.445] {
[13:22:00.445]     {
[13:22:00.445]         {
[13:22:00.445]             ...future.startTime <- base::Sys.time()
[13:22:00.445]             {
[13:22:00.445]                 {
[13:22:00.445]                   {
[13:22:00.445]                     {
[13:22:00.445]                       base::local({
[13:22:00.445]                         has_future <- base::requireNamespace("future", 
[13:22:00.445]                           quietly = TRUE)
[13:22:00.445]                         if (has_future) {
[13:22:00.445]                           ns <- base::getNamespace("future")
[13:22:00.445]                           version <- ns[[".package"]][["version"]]
[13:22:00.445]                           if (is.null(version)) 
[13:22:00.445]                             version <- utils::packageVersion("future")
[13:22:00.445]                         }
[13:22:00.445]                         else {
[13:22:00.445]                           version <- NULL
[13:22:00.445]                         }
[13:22:00.445]                         if (!has_future || version < "1.8.0") {
[13:22:00.445]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:00.445]                             "", base::R.version$version.string), 
[13:22:00.445]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:00.445]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:00.445]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:00.445]                               "release", "version")], collapse = " "), 
[13:22:00.445]                             hostname = base::Sys.info()[["nodename"]])
[13:22:00.445]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:00.445]                             info)
[13:22:00.445]                           info <- base::paste(info, collapse = "; ")
[13:22:00.445]                           if (!has_future) {
[13:22:00.445]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:00.445]                               info)
[13:22:00.445]                           }
[13:22:00.445]                           else {
[13:22:00.445]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:00.445]                               info, version)
[13:22:00.445]                           }
[13:22:00.445]                           base::stop(msg)
[13:22:00.445]                         }
[13:22:00.445]                       })
[13:22:00.445]                     }
[13:22:00.445]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:00.445]                     base::options(mc.cores = 1L)
[13:22:00.445]                   }
[13:22:00.445]                   options(future.plan = NULL)
[13:22:00.445]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:00.445]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:00.445]                 }
[13:22:00.445]                 ...future.workdir <- getwd()
[13:22:00.445]             }
[13:22:00.445]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:00.445]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:00.445]         }
[13:22:00.445]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:00.445]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:22:00.445]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:00.445]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:00.445]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:00.445]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:00.445]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:00.445]             base::names(...future.oldOptions))
[13:22:00.445]     }
[13:22:00.445]     if (TRUE) {
[13:22:00.445]     }
[13:22:00.445]     else {
[13:22:00.445]         if (NA) {
[13:22:00.445]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:00.445]                 open = "w")
[13:22:00.445]         }
[13:22:00.445]         else {
[13:22:00.445]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:00.445]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:00.445]         }
[13:22:00.445]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:00.445]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:00.445]             base::sink(type = "output", split = FALSE)
[13:22:00.445]             base::close(...future.stdout)
[13:22:00.445]         }, add = TRUE)
[13:22:00.445]     }
[13:22:00.445]     ...future.frame <- base::sys.nframe()
[13:22:00.445]     ...future.conditions <- base::list()
[13:22:00.445]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:00.445]     if (FALSE) {
[13:22:00.445]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:00.445]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:00.445]     }
[13:22:00.445]     ...future.result <- base::tryCatch({
[13:22:00.445]         base::withCallingHandlers({
[13:22:00.445]             ...future.value <- base::withVisible(base::local({
[13:22:00.445]                 withCallingHandlers({
[13:22:00.445]                   {
[13:22:00.445]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:00.445]                     if (!identical(...future.globals.maxSize.org, 
[13:22:00.445]                       ...future.globals.maxSize)) {
[13:22:00.445]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:00.445]                       on.exit(options(oopts), add = TRUE)
[13:22:00.445]                     }
[13:22:00.445]                     {
[13:22:00.445]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:22:00.445]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:22:00.445]                         USE.NAMES = FALSE)
[13:22:00.445]                       do.call(mapply, args = args)
[13:22:00.445]                     }
[13:22:00.445]                   }
[13:22:00.445]                 }, immediateCondition = function(cond) {
[13:22:00.445]                   save_rds <- function (object, pathname, ...) 
[13:22:00.445]                   {
[13:22:00.445]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:22:00.445]                     if (file_test("-f", pathname_tmp)) {
[13:22:00.445]                       fi_tmp <- file.info(pathname_tmp)
[13:22:00.445]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:22:00.445]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:00.445]                         fi_tmp[["mtime"]])
[13:22:00.445]                     }
[13:22:00.445]                     tryCatch({
[13:22:00.445]                       saveRDS(object, file = pathname_tmp, ...)
[13:22:00.445]                     }, error = function(ex) {
[13:22:00.445]                       msg <- conditionMessage(ex)
[13:22:00.445]                       fi_tmp <- file.info(pathname_tmp)
[13:22:00.445]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:22:00.445]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:00.445]                         fi_tmp[["mtime"]], msg)
[13:22:00.445]                       ex$message <- msg
[13:22:00.445]                       stop(ex)
[13:22:00.445]                     })
[13:22:00.445]                     stopifnot(file_test("-f", pathname_tmp))
[13:22:00.445]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:22:00.445]                     if (!res || file_test("-f", pathname_tmp)) {
[13:22:00.445]                       fi_tmp <- file.info(pathname_tmp)
[13:22:00.445]                       fi <- file.info(pathname)
[13:22:00.445]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:22:00.445]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:00.445]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:22:00.445]                         fi[["size"]], fi[["mtime"]])
[13:22:00.445]                       stop(msg)
[13:22:00.445]                     }
[13:22:00.445]                     invisible(pathname)
[13:22:00.445]                   }
[13:22:00.445]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:22:00.445]                     rootPath = tempdir()) 
[13:22:00.445]                   {
[13:22:00.445]                     obj <- list(time = Sys.time(), condition = cond)
[13:22:00.445]                     file <- tempfile(pattern = class(cond)[1], 
[13:22:00.445]                       tmpdir = path, fileext = ".rds")
[13:22:00.445]                     save_rds(obj, file)
[13:22:00.445]                   }
[13:22:00.445]                   saveImmediateCondition(cond, path = "/tmp/Rtmp78O1Lc/.future/immediateConditions")
[13:22:00.445]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.445]                   {
[13:22:00.445]                     inherits <- base::inherits
[13:22:00.445]                     invokeRestart <- base::invokeRestart
[13:22:00.445]                     is.null <- base::is.null
[13:22:00.445]                     muffled <- FALSE
[13:22:00.445]                     if (inherits(cond, "message")) {
[13:22:00.445]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:00.445]                       if (muffled) 
[13:22:00.445]                         invokeRestart("muffleMessage")
[13:22:00.445]                     }
[13:22:00.445]                     else if (inherits(cond, "warning")) {
[13:22:00.445]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:00.445]                       if (muffled) 
[13:22:00.445]                         invokeRestart("muffleWarning")
[13:22:00.445]                     }
[13:22:00.445]                     else if (inherits(cond, "condition")) {
[13:22:00.445]                       if (!is.null(pattern)) {
[13:22:00.445]                         computeRestarts <- base::computeRestarts
[13:22:00.445]                         grepl <- base::grepl
[13:22:00.445]                         restarts <- computeRestarts(cond)
[13:22:00.445]                         for (restart in restarts) {
[13:22:00.445]                           name <- restart$name
[13:22:00.445]                           if (is.null(name)) 
[13:22:00.445]                             next
[13:22:00.445]                           if (!grepl(pattern, name)) 
[13:22:00.445]                             next
[13:22:00.445]                           invokeRestart(restart)
[13:22:00.445]                           muffled <- TRUE
[13:22:00.445]                           break
[13:22:00.445]                         }
[13:22:00.445]                       }
[13:22:00.445]                     }
[13:22:00.445]                     invisible(muffled)
[13:22:00.445]                   }
[13:22:00.445]                   muffleCondition(cond)
[13:22:00.445]                 })
[13:22:00.445]             }))
[13:22:00.445]             future::FutureResult(value = ...future.value$value, 
[13:22:00.445]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:00.445]                   ...future.rng), globalenv = if (FALSE) 
[13:22:00.445]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:00.445]                     ...future.globalenv.names))
[13:22:00.445]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:00.445]         }, condition = base::local({
[13:22:00.445]             c <- base::c
[13:22:00.445]             inherits <- base::inherits
[13:22:00.445]             invokeRestart <- base::invokeRestart
[13:22:00.445]             length <- base::length
[13:22:00.445]             list <- base::list
[13:22:00.445]             seq.int <- base::seq.int
[13:22:00.445]             signalCondition <- base::signalCondition
[13:22:00.445]             sys.calls <- base::sys.calls
[13:22:00.445]             `[[` <- base::`[[`
[13:22:00.445]             `+` <- base::`+`
[13:22:00.445]             `<<-` <- base::`<<-`
[13:22:00.445]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:00.445]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:00.445]                   3L)]
[13:22:00.445]             }
[13:22:00.445]             function(cond) {
[13:22:00.445]                 is_error <- inherits(cond, "error")
[13:22:00.445]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:00.445]                   NULL)
[13:22:00.445]                 if (is_error) {
[13:22:00.445]                   sessionInformation <- function() {
[13:22:00.445]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:00.445]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:00.445]                       search = base::search(), system = base::Sys.info())
[13:22:00.445]                   }
[13:22:00.445]                   ...future.conditions[[length(...future.conditions) + 
[13:22:00.445]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:00.445]                     cond$call), session = sessionInformation(), 
[13:22:00.445]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:00.445]                   signalCondition(cond)
[13:22:00.445]                 }
[13:22:00.445]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:00.445]                 "immediateCondition"))) {
[13:22:00.445]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:00.445]                   ...future.conditions[[length(...future.conditions) + 
[13:22:00.445]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:00.445]                   if (TRUE && !signal) {
[13:22:00.445]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.445]                     {
[13:22:00.445]                       inherits <- base::inherits
[13:22:00.445]                       invokeRestart <- base::invokeRestart
[13:22:00.445]                       is.null <- base::is.null
[13:22:00.445]                       muffled <- FALSE
[13:22:00.445]                       if (inherits(cond, "message")) {
[13:22:00.445]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:00.445]                         if (muffled) 
[13:22:00.445]                           invokeRestart("muffleMessage")
[13:22:00.445]                       }
[13:22:00.445]                       else if (inherits(cond, "warning")) {
[13:22:00.445]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:00.445]                         if (muffled) 
[13:22:00.445]                           invokeRestart("muffleWarning")
[13:22:00.445]                       }
[13:22:00.445]                       else if (inherits(cond, "condition")) {
[13:22:00.445]                         if (!is.null(pattern)) {
[13:22:00.445]                           computeRestarts <- base::computeRestarts
[13:22:00.445]                           grepl <- base::grepl
[13:22:00.445]                           restarts <- computeRestarts(cond)
[13:22:00.445]                           for (restart in restarts) {
[13:22:00.445]                             name <- restart$name
[13:22:00.445]                             if (is.null(name)) 
[13:22:00.445]                               next
[13:22:00.445]                             if (!grepl(pattern, name)) 
[13:22:00.445]                               next
[13:22:00.445]                             invokeRestart(restart)
[13:22:00.445]                             muffled <- TRUE
[13:22:00.445]                             break
[13:22:00.445]                           }
[13:22:00.445]                         }
[13:22:00.445]                       }
[13:22:00.445]                       invisible(muffled)
[13:22:00.445]                     }
[13:22:00.445]                     muffleCondition(cond, pattern = "^muffle")
[13:22:00.445]                   }
[13:22:00.445]                 }
[13:22:00.445]                 else {
[13:22:00.445]                   if (TRUE) {
[13:22:00.445]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.445]                     {
[13:22:00.445]                       inherits <- base::inherits
[13:22:00.445]                       invokeRestart <- base::invokeRestart
[13:22:00.445]                       is.null <- base::is.null
[13:22:00.445]                       muffled <- FALSE
[13:22:00.445]                       if (inherits(cond, "message")) {
[13:22:00.445]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:00.445]                         if (muffled) 
[13:22:00.445]                           invokeRestart("muffleMessage")
[13:22:00.445]                       }
[13:22:00.445]                       else if (inherits(cond, "warning")) {
[13:22:00.445]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:00.445]                         if (muffled) 
[13:22:00.445]                           invokeRestart("muffleWarning")
[13:22:00.445]                       }
[13:22:00.445]                       else if (inherits(cond, "condition")) {
[13:22:00.445]                         if (!is.null(pattern)) {
[13:22:00.445]                           computeRestarts <- base::computeRestarts
[13:22:00.445]                           grepl <- base::grepl
[13:22:00.445]                           restarts <- computeRestarts(cond)
[13:22:00.445]                           for (restart in restarts) {
[13:22:00.445]                             name <- restart$name
[13:22:00.445]                             if (is.null(name)) 
[13:22:00.445]                               next
[13:22:00.445]                             if (!grepl(pattern, name)) 
[13:22:00.445]                               next
[13:22:00.445]                             invokeRestart(restart)
[13:22:00.445]                             muffled <- TRUE
[13:22:00.445]                             break
[13:22:00.445]                           }
[13:22:00.445]                         }
[13:22:00.445]                       }
[13:22:00.445]                       invisible(muffled)
[13:22:00.445]                     }
[13:22:00.445]                     muffleCondition(cond, pattern = "^muffle")
[13:22:00.445]                   }
[13:22:00.445]                 }
[13:22:00.445]             }
[13:22:00.445]         }))
[13:22:00.445]     }, error = function(ex) {
[13:22:00.445]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:00.445]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:00.445]                 ...future.rng), started = ...future.startTime, 
[13:22:00.445]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:00.445]             version = "1.8"), class = "FutureResult")
[13:22:00.445]     }, finally = {
[13:22:00.445]         if (!identical(...future.workdir, getwd())) 
[13:22:00.445]             setwd(...future.workdir)
[13:22:00.445]         {
[13:22:00.445]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:00.445]                 ...future.oldOptions$nwarnings <- NULL
[13:22:00.445]             }
[13:22:00.445]             base::options(...future.oldOptions)
[13:22:00.445]             if (.Platform$OS.type == "windows") {
[13:22:00.445]                 old_names <- names(...future.oldEnvVars)
[13:22:00.445]                 envs <- base::Sys.getenv()
[13:22:00.445]                 names <- names(envs)
[13:22:00.445]                 common <- intersect(names, old_names)
[13:22:00.445]                 added <- setdiff(names, old_names)
[13:22:00.445]                 removed <- setdiff(old_names, names)
[13:22:00.445]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:00.445]                   envs[common]]
[13:22:00.445]                 NAMES <- toupper(changed)
[13:22:00.445]                 args <- list()
[13:22:00.445]                 for (kk in seq_along(NAMES)) {
[13:22:00.445]                   name <- changed[[kk]]
[13:22:00.445]                   NAME <- NAMES[[kk]]
[13:22:00.445]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.445]                     next
[13:22:00.445]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:00.445]                 }
[13:22:00.445]                 NAMES <- toupper(added)
[13:22:00.445]                 for (kk in seq_along(NAMES)) {
[13:22:00.445]                   name <- added[[kk]]
[13:22:00.445]                   NAME <- NAMES[[kk]]
[13:22:00.445]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.445]                     next
[13:22:00.445]                   args[[name]] <- ""
[13:22:00.445]                 }
[13:22:00.445]                 NAMES <- toupper(removed)
[13:22:00.445]                 for (kk in seq_along(NAMES)) {
[13:22:00.445]                   name <- removed[[kk]]
[13:22:00.445]                   NAME <- NAMES[[kk]]
[13:22:00.445]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.445]                     next
[13:22:00.445]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:00.445]                 }
[13:22:00.445]                 if (length(args) > 0) 
[13:22:00.445]                   base::do.call(base::Sys.setenv, args = args)
[13:22:00.445]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:00.445]             }
[13:22:00.445]             else {
[13:22:00.445]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:00.445]             }
[13:22:00.445]             {
[13:22:00.445]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:00.445]                   0L) {
[13:22:00.445]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:00.445]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:00.445]                   base::options(opts)
[13:22:00.445]                 }
[13:22:00.445]                 {
[13:22:00.445]                   {
[13:22:00.445]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:00.445]                     NULL
[13:22:00.445]                   }
[13:22:00.445]                   options(future.plan = NULL)
[13:22:00.445]                   if (is.na(NA_character_)) 
[13:22:00.445]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:00.445]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:00.445]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:22:00.445]                     envir = parent.frame()) 
[13:22:00.445]                   {
[13:22:00.445]                     default_workers <- missing(workers)
[13:22:00.445]                     if (is.function(workers)) 
[13:22:00.445]                       workers <- workers()
[13:22:00.445]                     workers <- structure(as.integer(workers), 
[13:22:00.445]                       class = class(workers))
[13:22:00.445]                     stop_if_not(is.finite(workers), workers >= 
[13:22:00.445]                       1L)
[13:22:00.445]                     if ((workers == 1L && !inherits(workers, 
[13:22:00.445]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:22:00.445]                       if (default_workers) 
[13:22:00.445]                         supportsMulticore(warn = TRUE)
[13:22:00.445]                       return(sequential(..., envir = envir))
[13:22:00.445]                     }
[13:22:00.445]                     oopts <- options(mc.cores = workers)
[13:22:00.445]                     on.exit(options(oopts))
[13:22:00.445]                     future <- MulticoreFuture(..., workers = workers, 
[13:22:00.445]                       envir = envir)
[13:22:00.445]                     if (!future$lazy) 
[13:22:00.445]                       future <- run(future)
[13:22:00.445]                     invisible(future)
[13:22:00.445]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:00.445]                 }
[13:22:00.445]             }
[13:22:00.445]         }
[13:22:00.445]     })
[13:22:00.445]     if (FALSE) {
[13:22:00.445]         base::sink(type = "output", split = FALSE)
[13:22:00.445]         if (NA) {
[13:22:00.445]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:00.445]         }
[13:22:00.445]         else {
[13:22:00.445]             ...future.result["stdout"] <- base::list(NULL)
[13:22:00.445]         }
[13:22:00.445]         base::close(...future.stdout)
[13:22:00.445]         ...future.stdout <- NULL
[13:22:00.445]     }
[13:22:00.445]     ...future.result$conditions <- ...future.conditions
[13:22:00.445]     ...future.result$finished <- base::Sys.time()
[13:22:00.445]     ...future.result
[13:22:00.445] }
[13:22:00.447] assign_globals() ...
[13:22:00.447] List of 5
[13:22:00.447]  $ ...future.FUN            :function (x, y)  
[13:22:00.447]  $ MoreArgs                 : NULL
[13:22:00.447]  $ ...future.elements_ii    :List of 2
[13:22:00.447]   ..$ :List of 1
[13:22:00.447]   .. ..$ : int 1
[13:22:00.447]   ..$ :List of 1
[13:22:00.447]   .. ..$ : int 0
[13:22:00.447]  $ ...future.seeds_ii       : NULL
[13:22:00.447]  $ ...future.globals.maxSize: NULL
[13:22:00.447]  - attr(*, "where")=List of 5
[13:22:00.447]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:22:00.447]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:22:00.447]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:22:00.447]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:22:00.447]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:22:00.447]  - attr(*, "resolved")= logi FALSE
[13:22:00.447]  - attr(*, "total_size")= num 6368
[13:22:00.447]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:22:00.447]  - attr(*, "already-done")= logi TRUE
[13:22:00.455] - reassign environment for ‘...future.FUN’
[13:22:00.456] - copied ‘...future.FUN’ to environment
[13:22:00.456] - copied ‘MoreArgs’ to environment
[13:22:00.456] - copied ‘...future.elements_ii’ to environment
[13:22:00.456] - copied ‘...future.seeds_ii’ to environment
[13:22:00.456] - copied ‘...future.globals.maxSize’ to environment
[13:22:00.456] assign_globals() ... done
[13:22:00.456] requestCore(): workers = 2
[13:22:00.459] MulticoreFuture started
[13:22:00.459] - Launch lazy future ... done
[13:22:00.460] run() for ‘MulticoreFuture’ ... done
[13:22:00.460] plan(): Setting new future strategy stack:
[13:22:00.460] Created future:
[13:22:00.460] List of future strategies:
[13:22:00.460] 1. sequential:
[13:22:00.460]    - args: function (..., envir = parent.frame())
[13:22:00.460]    - tweaked: FALSE
[13:22:00.460]    - call: NULL
[13:22:00.461] plan(): nbrOfWorkers() = 1
[13:22:00.460] MulticoreFuture:
[13:22:00.460] Label: ‘future_mapply-1’
[13:22:00.460] Expression:
[13:22:00.460] {
[13:22:00.460]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:00.460]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:22:00.460]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:00.460]         on.exit(options(oopts), add = TRUE)
[13:22:00.460]     }
[13:22:00.460]     {
[13:22:00.460]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:22:00.460]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:22:00.460]         do.call(mapply, args = args)
[13:22:00.460]     }
[13:22:00.460] }
[13:22:00.460] Lazy evaluation: FALSE
[13:22:00.460] Asynchronous evaluation: TRUE
[13:22:00.460] Local evaluation: TRUE
[13:22:00.460] Environment: R_GlobalEnv
[13:22:00.460] Capture standard output: NA
[13:22:00.460] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:22:00.460] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:22:00.460] Packages: <none>
[13:22:00.460] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:22:00.460] Resolved: FALSE
[13:22:00.460] Value: <not collected>
[13:22:00.460] Conditions captured: <none>
[13:22:00.460] Early signaling: FALSE
[13:22:00.460] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:22:00.460] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:00.473] Chunk #1 of 2 ... DONE
[13:22:00.474] Chunk #2 of 2 ...
[13:22:00.474]  - Finding globals in '...' for chunk #2 ...
[13:22:00.474] getGlobalsAndPackages() ...
[13:22:00.474] Searching for globals...
[13:22:00.475] 
[13:22:00.475] Searching for globals ... DONE
[13:22:00.475] - globals: [0] <none>
[13:22:00.476] getGlobalsAndPackages() ... DONE
[13:22:00.476]    + additional globals found: [n=0] 
[13:22:00.476]    + additional namespaces needed: [n=0] 
[13:22:00.476]  - Finding globals in '...' for chunk #2 ... DONE
[13:22:00.476]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:22:00.477]  - seeds: <none>
[13:22:00.477]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:00.477] getGlobalsAndPackages() ...
[13:22:00.477] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:00.477] Resolving globals: FALSE
[13:22:00.478] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:22:00.479] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:22:00.479] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:00.480] 
[13:22:00.480] getGlobalsAndPackages() ... DONE
[13:22:00.480] run() for ‘Future’ ...
[13:22:00.480] - state: ‘created’
[13:22:00.481] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:22:00.486] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:00.486] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:22:00.486]   - Field: ‘label’
[13:22:00.487]   - Field: ‘local’
[13:22:00.487]   - Field: ‘owner’
[13:22:00.487]   - Field: ‘envir’
[13:22:00.487]   - Field: ‘workers’
[13:22:00.487]   - Field: ‘packages’
[13:22:00.487]   - Field: ‘gc’
[13:22:00.487]   - Field: ‘job’
[13:22:00.488]   - Field: ‘conditions’
[13:22:00.488]   - Field: ‘expr’
[13:22:00.488]   - Field: ‘uuid’
[13:22:00.488]   - Field: ‘seed’
[13:22:00.488]   - Field: ‘version’
[13:22:00.488]   - Field: ‘result’
[13:22:00.488]   - Field: ‘asynchronous’
[13:22:00.489]   - Field: ‘calls’
[13:22:00.489]   - Field: ‘globals’
[13:22:00.489]   - Field: ‘stdout’
[13:22:00.489]   - Field: ‘earlySignal’
[13:22:00.489]   - Field: ‘lazy’
[13:22:00.489]   - Field: ‘state’
[13:22:00.489] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:22:00.490] - Launch lazy future ...
[13:22:00.490] Packages needed by the future expression (n = 0): <none>
[13:22:00.490] Packages needed by future strategies (n = 0): <none>
[13:22:00.491] {
[13:22:00.491]     {
[13:22:00.491]         {
[13:22:00.491]             ...future.startTime <- base::Sys.time()
[13:22:00.491]             {
[13:22:00.491]                 {
[13:22:00.491]                   {
[13:22:00.491]                     {
[13:22:00.491]                       base::local({
[13:22:00.491]                         has_future <- base::requireNamespace("future", 
[13:22:00.491]                           quietly = TRUE)
[13:22:00.491]                         if (has_future) {
[13:22:00.491]                           ns <- base::getNamespace("future")
[13:22:00.491]                           version <- ns[[".package"]][["version"]]
[13:22:00.491]                           if (is.null(version)) 
[13:22:00.491]                             version <- utils::packageVersion("future")
[13:22:00.491]                         }
[13:22:00.491]                         else {
[13:22:00.491]                           version <- NULL
[13:22:00.491]                         }
[13:22:00.491]                         if (!has_future || version < "1.8.0") {
[13:22:00.491]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:00.491]                             "", base::R.version$version.string), 
[13:22:00.491]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:00.491]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:00.491]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:00.491]                               "release", "version")], collapse = " "), 
[13:22:00.491]                             hostname = base::Sys.info()[["nodename"]])
[13:22:00.491]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:00.491]                             info)
[13:22:00.491]                           info <- base::paste(info, collapse = "; ")
[13:22:00.491]                           if (!has_future) {
[13:22:00.491]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:00.491]                               info)
[13:22:00.491]                           }
[13:22:00.491]                           else {
[13:22:00.491]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:00.491]                               info, version)
[13:22:00.491]                           }
[13:22:00.491]                           base::stop(msg)
[13:22:00.491]                         }
[13:22:00.491]                       })
[13:22:00.491]                     }
[13:22:00.491]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:00.491]                     base::options(mc.cores = 1L)
[13:22:00.491]                   }
[13:22:00.491]                   options(future.plan = NULL)
[13:22:00.491]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:00.491]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:00.491]                 }
[13:22:00.491]                 ...future.workdir <- getwd()
[13:22:00.491]             }
[13:22:00.491]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:00.491]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:00.491]         }
[13:22:00.491]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:00.491]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:22:00.491]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:00.491]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:00.491]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:00.491]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:00.491]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:00.491]             base::names(...future.oldOptions))
[13:22:00.491]     }
[13:22:00.491]     if (TRUE) {
[13:22:00.491]     }
[13:22:00.491]     else {
[13:22:00.491]         if (NA) {
[13:22:00.491]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:00.491]                 open = "w")
[13:22:00.491]         }
[13:22:00.491]         else {
[13:22:00.491]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:00.491]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:00.491]         }
[13:22:00.491]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:00.491]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:00.491]             base::sink(type = "output", split = FALSE)
[13:22:00.491]             base::close(...future.stdout)
[13:22:00.491]         }, add = TRUE)
[13:22:00.491]     }
[13:22:00.491]     ...future.frame <- base::sys.nframe()
[13:22:00.491]     ...future.conditions <- base::list()
[13:22:00.491]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:00.491]     if (FALSE) {
[13:22:00.491]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:00.491]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:00.491]     }
[13:22:00.491]     ...future.result <- base::tryCatch({
[13:22:00.491]         base::withCallingHandlers({
[13:22:00.491]             ...future.value <- base::withVisible(base::local({
[13:22:00.491]                 withCallingHandlers({
[13:22:00.491]                   {
[13:22:00.491]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:00.491]                     if (!identical(...future.globals.maxSize.org, 
[13:22:00.491]                       ...future.globals.maxSize)) {
[13:22:00.491]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:00.491]                       on.exit(options(oopts), add = TRUE)
[13:22:00.491]                     }
[13:22:00.491]                     {
[13:22:00.491]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:22:00.491]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:22:00.491]                         USE.NAMES = FALSE)
[13:22:00.491]                       do.call(mapply, args = args)
[13:22:00.491]                     }
[13:22:00.491]                   }
[13:22:00.491]                 }, immediateCondition = function(cond) {
[13:22:00.491]                   save_rds <- function (object, pathname, ...) 
[13:22:00.491]                   {
[13:22:00.491]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:22:00.491]                     if (file_test("-f", pathname_tmp)) {
[13:22:00.491]                       fi_tmp <- file.info(pathname_tmp)
[13:22:00.491]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:22:00.491]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:00.491]                         fi_tmp[["mtime"]])
[13:22:00.491]                     }
[13:22:00.491]                     tryCatch({
[13:22:00.491]                       saveRDS(object, file = pathname_tmp, ...)
[13:22:00.491]                     }, error = function(ex) {
[13:22:00.491]                       msg <- conditionMessage(ex)
[13:22:00.491]                       fi_tmp <- file.info(pathname_tmp)
[13:22:00.491]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:22:00.491]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:00.491]                         fi_tmp[["mtime"]], msg)
[13:22:00.491]                       ex$message <- msg
[13:22:00.491]                       stop(ex)
[13:22:00.491]                     })
[13:22:00.491]                     stopifnot(file_test("-f", pathname_tmp))
[13:22:00.491]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:22:00.491]                     if (!res || file_test("-f", pathname_tmp)) {
[13:22:00.491]                       fi_tmp <- file.info(pathname_tmp)
[13:22:00.491]                       fi <- file.info(pathname)
[13:22:00.491]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:22:00.491]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:00.491]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:22:00.491]                         fi[["size"]], fi[["mtime"]])
[13:22:00.491]                       stop(msg)
[13:22:00.491]                     }
[13:22:00.491]                     invisible(pathname)
[13:22:00.491]                   }
[13:22:00.491]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:22:00.491]                     rootPath = tempdir()) 
[13:22:00.491]                   {
[13:22:00.491]                     obj <- list(time = Sys.time(), condition = cond)
[13:22:00.491]                     file <- tempfile(pattern = class(cond)[1], 
[13:22:00.491]                       tmpdir = path, fileext = ".rds")
[13:22:00.491]                     save_rds(obj, file)
[13:22:00.491]                   }
[13:22:00.491]                   saveImmediateCondition(cond, path = "/tmp/Rtmp78O1Lc/.future/immediateConditions")
[13:22:00.491]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.491]                   {
[13:22:00.491]                     inherits <- base::inherits
[13:22:00.491]                     invokeRestart <- base::invokeRestart
[13:22:00.491]                     is.null <- base::is.null
[13:22:00.491]                     muffled <- FALSE
[13:22:00.491]                     if (inherits(cond, "message")) {
[13:22:00.491]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:00.491]                       if (muffled) 
[13:22:00.491]                         invokeRestart("muffleMessage")
[13:22:00.491]                     }
[13:22:00.491]                     else if (inherits(cond, "warning")) {
[13:22:00.491]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:00.491]                       if (muffled) 
[13:22:00.491]                         invokeRestart("muffleWarning")
[13:22:00.491]                     }
[13:22:00.491]                     else if (inherits(cond, "condition")) {
[13:22:00.491]                       if (!is.null(pattern)) {
[13:22:00.491]                         computeRestarts <- base::computeRestarts
[13:22:00.491]                         grepl <- base::grepl
[13:22:00.491]                         restarts <- computeRestarts(cond)
[13:22:00.491]                         for (restart in restarts) {
[13:22:00.491]                           name <- restart$name
[13:22:00.491]                           if (is.null(name)) 
[13:22:00.491]                             next
[13:22:00.491]                           if (!grepl(pattern, name)) 
[13:22:00.491]                             next
[13:22:00.491]                           invokeRestart(restart)
[13:22:00.491]                           muffled <- TRUE
[13:22:00.491]                           break
[13:22:00.491]                         }
[13:22:00.491]                       }
[13:22:00.491]                     }
[13:22:00.491]                     invisible(muffled)
[13:22:00.491]                   }
[13:22:00.491]                   muffleCondition(cond)
[13:22:00.491]                 })
[13:22:00.491]             }))
[13:22:00.491]             future::FutureResult(value = ...future.value$value, 
[13:22:00.491]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:00.491]                   ...future.rng), globalenv = if (FALSE) 
[13:22:00.491]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:00.491]                     ...future.globalenv.names))
[13:22:00.491]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:00.491]         }, condition = base::local({
[13:22:00.491]             c <- base::c
[13:22:00.491]             inherits <- base::inherits
[13:22:00.491]             invokeRestart <- base::invokeRestart
[13:22:00.491]             length <- base::length
[13:22:00.491]             list <- base::list
[13:22:00.491]             seq.int <- base::seq.int
[13:22:00.491]             signalCondition <- base::signalCondition
[13:22:00.491]             sys.calls <- base::sys.calls
[13:22:00.491]             `[[` <- base::`[[`
[13:22:00.491]             `+` <- base::`+`
[13:22:00.491]             `<<-` <- base::`<<-`
[13:22:00.491]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:00.491]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:00.491]                   3L)]
[13:22:00.491]             }
[13:22:00.491]             function(cond) {
[13:22:00.491]                 is_error <- inherits(cond, "error")
[13:22:00.491]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:00.491]                   NULL)
[13:22:00.491]                 if (is_error) {
[13:22:00.491]                   sessionInformation <- function() {
[13:22:00.491]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:00.491]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:00.491]                       search = base::search(), system = base::Sys.info())
[13:22:00.491]                   }
[13:22:00.491]                   ...future.conditions[[length(...future.conditions) + 
[13:22:00.491]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:00.491]                     cond$call), session = sessionInformation(), 
[13:22:00.491]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:00.491]                   signalCondition(cond)
[13:22:00.491]                 }
[13:22:00.491]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:00.491]                 "immediateCondition"))) {
[13:22:00.491]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:00.491]                   ...future.conditions[[length(...future.conditions) + 
[13:22:00.491]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:00.491]                   if (TRUE && !signal) {
[13:22:00.491]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.491]                     {
[13:22:00.491]                       inherits <- base::inherits
[13:22:00.491]                       invokeRestart <- base::invokeRestart
[13:22:00.491]                       is.null <- base::is.null
[13:22:00.491]                       muffled <- FALSE
[13:22:00.491]                       if (inherits(cond, "message")) {
[13:22:00.491]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:00.491]                         if (muffled) 
[13:22:00.491]                           invokeRestart("muffleMessage")
[13:22:00.491]                       }
[13:22:00.491]                       else if (inherits(cond, "warning")) {
[13:22:00.491]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:00.491]                         if (muffled) 
[13:22:00.491]                           invokeRestart("muffleWarning")
[13:22:00.491]                       }
[13:22:00.491]                       else if (inherits(cond, "condition")) {
[13:22:00.491]                         if (!is.null(pattern)) {
[13:22:00.491]                           computeRestarts <- base::computeRestarts
[13:22:00.491]                           grepl <- base::grepl
[13:22:00.491]                           restarts <- computeRestarts(cond)
[13:22:00.491]                           for (restart in restarts) {
[13:22:00.491]                             name <- restart$name
[13:22:00.491]                             if (is.null(name)) 
[13:22:00.491]                               next
[13:22:00.491]                             if (!grepl(pattern, name)) 
[13:22:00.491]                               next
[13:22:00.491]                             invokeRestart(restart)
[13:22:00.491]                             muffled <- TRUE
[13:22:00.491]                             break
[13:22:00.491]                           }
[13:22:00.491]                         }
[13:22:00.491]                       }
[13:22:00.491]                       invisible(muffled)
[13:22:00.491]                     }
[13:22:00.491]                     muffleCondition(cond, pattern = "^muffle")
[13:22:00.491]                   }
[13:22:00.491]                 }
[13:22:00.491]                 else {
[13:22:00.491]                   if (TRUE) {
[13:22:00.491]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.491]                     {
[13:22:00.491]                       inherits <- base::inherits
[13:22:00.491]                       invokeRestart <- base::invokeRestart
[13:22:00.491]                       is.null <- base::is.null
[13:22:00.491]                       muffled <- FALSE
[13:22:00.491]                       if (inherits(cond, "message")) {
[13:22:00.491]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:00.491]                         if (muffled) 
[13:22:00.491]                           invokeRestart("muffleMessage")
[13:22:00.491]                       }
[13:22:00.491]                       else if (inherits(cond, "warning")) {
[13:22:00.491]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:00.491]                         if (muffled) 
[13:22:00.491]                           invokeRestart("muffleWarning")
[13:22:00.491]                       }
[13:22:00.491]                       else if (inherits(cond, "condition")) {
[13:22:00.491]                         if (!is.null(pattern)) {
[13:22:00.491]                           computeRestarts <- base::computeRestarts
[13:22:00.491]                           grepl <- base::grepl
[13:22:00.491]                           restarts <- computeRestarts(cond)
[13:22:00.491]                           for (restart in restarts) {
[13:22:00.491]                             name <- restart$name
[13:22:00.491]                             if (is.null(name)) 
[13:22:00.491]                               next
[13:22:00.491]                             if (!grepl(pattern, name)) 
[13:22:00.491]                               next
[13:22:00.491]                             invokeRestart(restart)
[13:22:00.491]                             muffled <- TRUE
[13:22:00.491]                             break
[13:22:00.491]                           }
[13:22:00.491]                         }
[13:22:00.491]                       }
[13:22:00.491]                       invisible(muffled)
[13:22:00.491]                     }
[13:22:00.491]                     muffleCondition(cond, pattern = "^muffle")
[13:22:00.491]                   }
[13:22:00.491]                 }
[13:22:00.491]             }
[13:22:00.491]         }))
[13:22:00.491]     }, error = function(ex) {
[13:22:00.491]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:00.491]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:00.491]                 ...future.rng), started = ...future.startTime, 
[13:22:00.491]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:00.491]             version = "1.8"), class = "FutureResult")
[13:22:00.491]     }, finally = {
[13:22:00.491]         if (!identical(...future.workdir, getwd())) 
[13:22:00.491]             setwd(...future.workdir)
[13:22:00.491]         {
[13:22:00.491]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:00.491]                 ...future.oldOptions$nwarnings <- NULL
[13:22:00.491]             }
[13:22:00.491]             base::options(...future.oldOptions)
[13:22:00.491]             if (.Platform$OS.type == "windows") {
[13:22:00.491]                 old_names <- names(...future.oldEnvVars)
[13:22:00.491]                 envs <- base::Sys.getenv()
[13:22:00.491]                 names <- names(envs)
[13:22:00.491]                 common <- intersect(names, old_names)
[13:22:00.491]                 added <- setdiff(names, old_names)
[13:22:00.491]                 removed <- setdiff(old_names, names)
[13:22:00.491]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:00.491]                   envs[common]]
[13:22:00.491]                 NAMES <- toupper(changed)
[13:22:00.491]                 args <- list()
[13:22:00.491]                 for (kk in seq_along(NAMES)) {
[13:22:00.491]                   name <- changed[[kk]]
[13:22:00.491]                   NAME <- NAMES[[kk]]
[13:22:00.491]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.491]                     next
[13:22:00.491]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:00.491]                 }
[13:22:00.491]                 NAMES <- toupper(added)
[13:22:00.491]                 for (kk in seq_along(NAMES)) {
[13:22:00.491]                   name <- added[[kk]]
[13:22:00.491]                   NAME <- NAMES[[kk]]
[13:22:00.491]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.491]                     next
[13:22:00.491]                   args[[name]] <- ""
[13:22:00.491]                 }
[13:22:00.491]                 NAMES <- toupper(removed)
[13:22:00.491]                 for (kk in seq_along(NAMES)) {
[13:22:00.491]                   name <- removed[[kk]]
[13:22:00.491]                   NAME <- NAMES[[kk]]
[13:22:00.491]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.491]                     next
[13:22:00.491]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:00.491]                 }
[13:22:00.491]                 if (length(args) > 0) 
[13:22:00.491]                   base::do.call(base::Sys.setenv, args = args)
[13:22:00.491]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:00.491]             }
[13:22:00.491]             else {
[13:22:00.491]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:00.491]             }
[13:22:00.491]             {
[13:22:00.491]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:00.491]                   0L) {
[13:22:00.491]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:00.491]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:00.491]                   base::options(opts)
[13:22:00.491]                 }
[13:22:00.491]                 {
[13:22:00.491]                   {
[13:22:00.491]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:00.491]                     NULL
[13:22:00.491]                   }
[13:22:00.491]                   options(future.plan = NULL)
[13:22:00.491]                   if (is.na(NA_character_)) 
[13:22:00.491]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:00.491]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:00.491]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:22:00.491]                     envir = parent.frame()) 
[13:22:00.491]                   {
[13:22:00.491]                     default_workers <- missing(workers)
[13:22:00.491]                     if (is.function(workers)) 
[13:22:00.491]                       workers <- workers()
[13:22:00.491]                     workers <- structure(as.integer(workers), 
[13:22:00.491]                       class = class(workers))
[13:22:00.491]                     stop_if_not(is.finite(workers), workers >= 
[13:22:00.491]                       1L)
[13:22:00.491]                     if ((workers == 1L && !inherits(workers, 
[13:22:00.491]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:22:00.491]                       if (default_workers) 
[13:22:00.491]                         supportsMulticore(warn = TRUE)
[13:22:00.491]                       return(sequential(..., envir = envir))
[13:22:00.491]                     }
[13:22:00.491]                     oopts <- options(mc.cores = workers)
[13:22:00.491]                     on.exit(options(oopts))
[13:22:00.491]                     future <- MulticoreFuture(..., workers = workers, 
[13:22:00.491]                       envir = envir)
[13:22:00.491]                     if (!future$lazy) 
[13:22:00.491]                       future <- run(future)
[13:22:00.491]                     invisible(future)
[13:22:00.491]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:00.491]                 }
[13:22:00.491]             }
[13:22:00.491]         }
[13:22:00.491]     })
[13:22:00.491]     if (FALSE) {
[13:22:00.491]         base::sink(type = "output", split = FALSE)
[13:22:00.491]         if (NA) {
[13:22:00.491]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:00.491]         }
[13:22:00.491]         else {
[13:22:00.491]             ...future.result["stdout"] <- base::list(NULL)
[13:22:00.491]         }
[13:22:00.491]         base::close(...future.stdout)
[13:22:00.491]         ...future.stdout <- NULL
[13:22:00.491]     }
[13:22:00.491]     ...future.result$conditions <- ...future.conditions
[13:22:00.491]     ...future.result$finished <- base::Sys.time()
[13:22:00.491]     ...future.result
[13:22:00.491] }
[13:22:00.495] assign_globals() ...
[13:22:00.495] List of 5
[13:22:00.495]  $ ...future.FUN            :function (x, y)  
[13:22:00.495]  $ MoreArgs                 : NULL
[13:22:00.495]  $ ...future.elements_ii    :List of 2
[13:22:00.495]   ..$ :List of 1
[13:22:00.495]   .. ..$ : int 0
[13:22:00.495]   ..$ :List of 1
[13:22:00.495]   .. ..$ : int 1
[13:22:00.495]  $ ...future.seeds_ii       : NULL
[13:22:00.495]  $ ...future.globals.maxSize: NULL
[13:22:00.495]  - attr(*, "where")=List of 5
[13:22:00.495]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:22:00.495]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:22:00.495]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:22:00.495]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:22:00.495]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:22:00.495]  - attr(*, "resolved")= logi FALSE
[13:22:00.495]  - attr(*, "total_size")= num 6368
[13:22:00.495]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:22:00.495]  - attr(*, "already-done")= logi TRUE
[13:22:00.503] - reassign environment for ‘...future.FUN’
[13:22:00.503] - copied ‘...future.FUN’ to environment
[13:22:00.504] - copied ‘MoreArgs’ to environment
[13:22:00.506] - copied ‘...future.elements_ii’ to environment
[13:22:00.506] - copied ‘...future.seeds_ii’ to environment
[13:22:00.506] - copied ‘...future.globals.maxSize’ to environment
[13:22:00.507] assign_globals() ... done
[13:22:00.507] requestCore(): workers = 2
[13:22:00.510] MulticoreFuture started
[13:22:00.511] - Launch lazy future ... done
[13:22:00.511] run() for ‘MulticoreFuture’ ... done
[13:22:00.511] plan(): Setting new future strategy stack:
[13:22:00.512] Created future:
[13:22:00.512] List of future strategies:
[13:22:00.512] 1. sequential:
[13:22:00.512]    - args: function (..., envir = parent.frame())
[13:22:00.512]    - tweaked: FALSE
[13:22:00.512]    - call: NULL
[13:22:00.513] plan(): nbrOfWorkers() = 1
[13:22:00.516] plan(): Setting new future strategy stack:
[13:22:00.516] List of future strategies:
[13:22:00.516] 1. multicore:
[13:22:00.516]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:00.516]    - tweaked: FALSE
[13:22:00.516]    - call: plan(strategy)
[13:22:00.523] plan(): nbrOfWorkers() = 2
[13:22:00.512] MulticoreFuture:
[13:22:00.512] Label: ‘future_mapply-2’
[13:22:00.512] Expression:
[13:22:00.512] {
[13:22:00.512]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:00.512]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:22:00.512]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:00.512]         on.exit(options(oopts), add = TRUE)
[13:22:00.512]     }
[13:22:00.512]     {
[13:22:00.512]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:22:00.512]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:22:00.512]         do.call(mapply, args = args)
[13:22:00.512]     }
[13:22:00.512] }
[13:22:00.512] Lazy evaluation: FALSE
[13:22:00.512] Asynchronous evaluation: TRUE
[13:22:00.512] Local evaluation: TRUE
[13:22:00.512] Environment: R_GlobalEnv
[13:22:00.512] Capture standard output: NA
[13:22:00.512] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:22:00.512] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:22:00.512] Packages: <none>
[13:22:00.512] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:22:00.512] Resolved: TRUE
[13:22:00.512] Value: <not collected>
[13:22:00.512] Conditions captured: <none>
[13:22:00.512] Early signaling: FALSE
[13:22:00.512] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:22:00.512] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:00.525] Chunk #2 of 2 ... DONE
[13:22:00.525] Launching 2 futures (chunks) ... DONE
[13:22:00.525] Resolving 2 futures (chunks) ...
[13:22:00.525] resolve() on list ...
[13:22:00.526]  recursive: 0
[13:22:00.526]  length: 2
[13:22:00.526] 
[13:22:00.537] Future #2
[13:22:00.537] result() for MulticoreFuture ...
[13:22:00.538] result() for MulticoreFuture ...
[13:22:00.538] result() for MulticoreFuture ... done
[13:22:00.539] result() for MulticoreFuture ... done
[13:22:00.539] result() for MulticoreFuture ...
[13:22:00.539] result() for MulticoreFuture ... done
[13:22:00.539] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:22:00.539] - nx: 2
[13:22:00.539] - relay: TRUE
[13:22:00.539] - stdout: TRUE
[13:22:00.540] - signal: TRUE
[13:22:00.540] - resignal: FALSE
[13:22:00.540] - force: TRUE
[13:22:00.540] - relayed: [n=2] FALSE, FALSE
[13:22:00.540] - queued futures: [n=2] FALSE, FALSE
[13:22:00.541]  - until=1
[13:22:00.541]  - relaying element #1
[13:22:00.541] - relayed: [n=2] FALSE, FALSE
[13:22:00.541] - queued futures: [n=2] FALSE, TRUE
[13:22:00.541] signalConditionsASAP(NULL, pos=2) ... done
[13:22:00.541]  length: 1 (resolved future 2)
[13:22:00.964] plan(): Setting new future strategy stack:
[13:22:00.965] List of future strategies:
[13:22:00.965] 1. multicore:
[13:22:00.965]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:00.965]    - tweaked: FALSE
[13:22:00.965]    - call: plan(strategy)
[13:22:00.969] plan(): nbrOfWorkers() = 2
[13:22:00.970] Future #1
[13:22:00.970] result() for MulticoreFuture ...
[13:22:00.971] result() for MulticoreFuture ...
[13:22:00.971] result() for MulticoreFuture ... done
[13:22:00.971] result() for MulticoreFuture ... done
[13:22:00.971] result() for MulticoreFuture ...
[13:22:00.971] result() for MulticoreFuture ... done
[13:22:00.972] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:22:00.972] - nx: 2
[13:22:00.972] - relay: TRUE
[13:22:00.972] - stdout: TRUE
[13:22:00.972] - signal: TRUE
[13:22:00.972] - resignal: FALSE
[13:22:00.972] - force: TRUE
[13:22:00.973] - relayed: [n=2] FALSE, FALSE
[13:22:00.973] - queued futures: [n=2] FALSE, TRUE
[13:22:00.973]  - until=1
[13:22:00.973]  - relaying element #1
[13:22:00.973] result() for MulticoreFuture ...
[13:22:00.973] result() for MulticoreFuture ... done
[13:22:00.974] result() for MulticoreFuture ...
[13:22:00.974] result() for MulticoreFuture ... done
[13:22:00.974] result() for MulticoreFuture ...
[13:22:00.974] result() for MulticoreFuture ... done
[13:22:00.974] result() for MulticoreFuture ...
[13:22:00.974] result() for MulticoreFuture ... done
[13:22:00.975] - relayed: [n=2] TRUE, FALSE
[13:22:00.975] - queued futures: [n=2] TRUE, TRUE
[13:22:00.975] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:22:00.975]  length: 0 (resolved future 1)
[13:22:00.975] Relaying remaining futures
[13:22:00.975] signalConditionsASAP(NULL, pos=0) ...
[13:22:00.975] - nx: 2
[13:22:00.975] - relay: TRUE
[13:22:00.976] - stdout: TRUE
[13:22:00.976] - signal: TRUE
[13:22:00.976] - resignal: FALSE
[13:22:00.976] - force: TRUE
[13:22:00.976] - relayed: [n=2] TRUE, FALSE
[13:22:00.976] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:22:00.976]  - relaying element #2
[13:22:00.976] result() for MulticoreFuture ...
[13:22:00.976] result() for MulticoreFuture ... done
[13:22:00.977] result() for MulticoreFuture ...
[13:22:00.977] result() for MulticoreFuture ... done
[13:22:00.977] result() for MulticoreFuture ...
[13:22:00.977] result() for MulticoreFuture ... done
[13:22:00.977] result() for MulticoreFuture ...
[13:22:00.977] result() for MulticoreFuture ... done
[13:22:00.977] - relayed: [n=2] TRUE, TRUE
[13:22:00.977] - queued futures: [n=2] TRUE, TRUE
[13:22:00.978] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[13:22:00.978] resolve() on list ... DONE
[13:22:00.978] result() for MulticoreFuture ...
[13:22:00.978] result() for MulticoreFuture ... done
[13:22:00.978] result() for MulticoreFuture ...
[13:22:00.978] result() for MulticoreFuture ... done
[13:22:00.978] result() for MulticoreFuture ...
[13:22:00.978] result() for MulticoreFuture ... done
[13:22:00.978] result() for MulticoreFuture ...
[13:22:00.978] result() for MulticoreFuture ... done
[13:22:00.979]  - Number of value chunks collected: 2
[13:22:00.979] Resolving 2 futures (chunks) ... DONE
[13:22:00.979] Reducing values from 2 chunks ...
[13:22:00.979]  - Number of values collected after concatenation: 2
[13:22:00.979]  - Number of values expected: 2
[13:22:00.979] Reducing values from 2 chunks ... DONE
[13:22:00.979] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[13:22:00.980] plan(): Setting new future strategy stack:
[13:22:00.980] List of future strategies:
[13:22:00.980] 1. multisession:
[13:22:00.980]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:22:00.980]    - tweaked: FALSE
[13:22:00.980]    - call: plan(strategy)
[13:22:00.980] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:22:00.981] multisession:
[13:22:00.981] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:22:00.981] - tweaked: FALSE
[13:22:00.981] - call: plan(strategy)
[13:22:00.987] getGlobalsAndPackages() ...
[13:22:00.987] Not searching for globals
[13:22:00.988] - globals: [0] <none>
[13:22:00.988] getGlobalsAndPackages() ... DONE
[13:22:00.988] [local output] makeClusterPSOCK() ...
[13:22:01.037] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:22:01.038] [local output] Base port: 11374
[13:22:01.038] [local output] Getting setup options for 2 cluster nodes ...
[13:22:01.038] [local output]  - Node 1 of 2 ...
[13:22:01.039] [local output] localMachine=TRUE => revtunnel=FALSE

[13:22:01.039] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp78O1Lc/worker.rank=1.parallelly.parent=79997.1387d59082028.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp78O1Lc/worker.rank=1.parallelly.parent=79997.1387d59082028.pid")'’
[13:22:01.233] - Possible to infer worker's PID: TRUE
[13:22:01.233] [local output] Rscript port: 11374

[13:22:01.234] [local output]  - Node 2 of 2 ...
[13:22:01.234] [local output] localMachine=TRUE => revtunnel=FALSE

[13:22:01.235] [local output] Rscript port: 11374

[13:22:01.235] [local output] Getting setup options for 2 cluster nodes ... done
[13:22:01.235] [local output]  - Parallel setup requested for some PSOCK nodes
[13:22:01.236] [local output] Setting up PSOCK nodes in parallel
[13:22:01.236] List of 36
[13:22:01.236]  $ worker          : chr "localhost"
[13:22:01.236]   ..- attr(*, "localhost")= logi TRUE
[13:22:01.236]  $ master          : chr "localhost"
[13:22:01.236]  $ port            : int 11374
[13:22:01.236]  $ connectTimeout  : num 120
[13:22:01.236]  $ timeout         : num 2592000
[13:22:01.236]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:22:01.236]  $ homogeneous     : logi TRUE
[13:22:01.236]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:22:01.236]  $ rscript_envs    : NULL
[13:22:01.236]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:22:01.236]  $ rscript_startup : NULL
[13:22:01.236]  $ rscript_sh      : chr "sh"
[13:22:01.236]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:22:01.236]  $ methods         : logi TRUE
[13:22:01.236]  $ socketOptions   : chr "no-delay"
[13:22:01.236]  $ useXDR          : logi FALSE
[13:22:01.236]  $ outfile         : chr "/dev/null"
[13:22:01.236]  $ renice          : int NA
[13:22:01.236]  $ rshcmd          : NULL
[13:22:01.236]  $ user            : chr(0) 
[13:22:01.236]  $ revtunnel       : logi FALSE
[13:22:01.236]  $ rshlogfile      : NULL
[13:22:01.236]  $ rshopts         : chr(0) 
[13:22:01.236]  $ rank            : int 1
[13:22:01.236]  $ manual          : logi FALSE
[13:22:01.236]  $ dryrun          : logi FALSE
[13:22:01.236]  $ quiet           : logi FALSE
[13:22:01.236]  $ setup_strategy  : chr "parallel"
[13:22:01.236]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:22:01.236]  $ pidfile         : chr "/tmp/Rtmp78O1Lc/worker.rank=1.parallelly.parent=79997.1387d59082028.pid"
[13:22:01.236]  $ rshcmd_label    : NULL
[13:22:01.236]  $ rsh_call        : NULL
[13:22:01.236]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:22:01.236]  $ localMachine    : logi TRUE
[13:22:01.236]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:22:01.236]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:22:01.236]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:22:01.236]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:22:01.236]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:22:01.236]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:22:01.236]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:22:01.236]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:22:01.236]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:22:01.236]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:22:01.236]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:22:01.236]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:22:01.236]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:22:01.236]  $ arguments       :List of 28
[13:22:01.236]   ..$ worker          : chr "localhost"
[13:22:01.236]   ..$ master          : NULL
[13:22:01.236]   ..$ port            : int 11374
[13:22:01.236]   ..$ connectTimeout  : num 120
[13:22:01.236]   ..$ timeout         : num 2592000
[13:22:01.236]   ..$ rscript         : NULL
[13:22:01.236]   ..$ homogeneous     : NULL
[13:22:01.236]   ..$ rscript_args    : NULL
[13:22:01.236]   ..$ rscript_envs    : NULL
[13:22:01.236]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:22:01.236]   ..$ rscript_startup : NULL
[13:22:01.236]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:22:01.236]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:22:01.236]   ..$ methods         : logi TRUE
[13:22:01.236]   ..$ socketOptions   : chr "no-delay"
[13:22:01.236]   ..$ useXDR          : logi FALSE
[13:22:01.236]   ..$ outfile         : chr "/dev/null"
[13:22:01.236]   ..$ renice          : int NA
[13:22:01.236]   ..$ rshcmd          : NULL
[13:22:01.236]   ..$ user            : NULL
[13:22:01.236]   ..$ revtunnel       : logi NA
[13:22:01.236]   ..$ rshlogfile      : NULL
[13:22:01.236]   ..$ rshopts         : NULL
[13:22:01.236]   ..$ rank            : int 1
[13:22:01.236]   ..$ manual          : logi FALSE
[13:22:01.236]   ..$ dryrun          : logi FALSE
[13:22:01.236]   ..$ quiet           : logi FALSE
[13:22:01.236]   ..$ setup_strategy  : chr "parallel"
[13:22:01.236]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:22:01.253] [local output] System call to launch all workers:
[13:22:01.253] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp78O1Lc/worker.rank=1.parallelly.parent=79997.1387d59082028.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11374 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:22:01.253] [local output] Starting PSOCK main server
[13:22:01.259] [local output] Workers launched
[13:22:01.259] [local output] Waiting for workers to connect back
[13:22:01.260]  - [local output] 0 workers out of 2 ready
[13:22:01.508]  - [local output] 0 workers out of 2 ready
[13:22:01.509]  - [local output] 1 workers out of 2 ready
[13:22:01.519]  - [local output] 1 workers out of 2 ready
[13:22:01.520]  - [local output] 2 workers out of 2 ready
[13:22:01.520] [local output] Launching of workers completed
[13:22:01.520] [local output] Collecting session information from workers
[13:22:01.521] [local output]  - Worker #1 of 2
[13:22:01.522] [local output]  - Worker #2 of 2
[13:22:01.522] [local output] makeClusterPSOCK() ... done
[13:22:01.534] Packages needed by the future expression (n = 0): <none>
[13:22:01.534] Packages needed by future strategies (n = 0): <none>
[13:22:01.534] {
[13:22:01.534]     {
[13:22:01.534]         {
[13:22:01.534]             ...future.startTime <- base::Sys.time()
[13:22:01.534]             {
[13:22:01.534]                 {
[13:22:01.534]                   {
[13:22:01.534]                     {
[13:22:01.534]                       base::local({
[13:22:01.534]                         has_future <- base::requireNamespace("future", 
[13:22:01.534]                           quietly = TRUE)
[13:22:01.534]                         if (has_future) {
[13:22:01.534]                           ns <- base::getNamespace("future")
[13:22:01.534]                           version <- ns[[".package"]][["version"]]
[13:22:01.534]                           if (is.null(version)) 
[13:22:01.534]                             version <- utils::packageVersion("future")
[13:22:01.534]                         }
[13:22:01.534]                         else {
[13:22:01.534]                           version <- NULL
[13:22:01.534]                         }
[13:22:01.534]                         if (!has_future || version < "1.8.0") {
[13:22:01.534]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:01.534]                             "", base::R.version$version.string), 
[13:22:01.534]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:01.534]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:01.534]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:01.534]                               "release", "version")], collapse = " "), 
[13:22:01.534]                             hostname = base::Sys.info()[["nodename"]])
[13:22:01.534]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:01.534]                             info)
[13:22:01.534]                           info <- base::paste(info, collapse = "; ")
[13:22:01.534]                           if (!has_future) {
[13:22:01.534]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:01.534]                               info)
[13:22:01.534]                           }
[13:22:01.534]                           else {
[13:22:01.534]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:01.534]                               info, version)
[13:22:01.534]                           }
[13:22:01.534]                           base::stop(msg)
[13:22:01.534]                         }
[13:22:01.534]                       })
[13:22:01.534]                     }
[13:22:01.534]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:01.534]                     base::options(mc.cores = 1L)
[13:22:01.534]                   }
[13:22:01.534]                   options(future.plan = NULL)
[13:22:01.534]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:01.534]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:01.534]                 }
[13:22:01.534]                 ...future.workdir <- getwd()
[13:22:01.534]             }
[13:22:01.534]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:01.534]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:01.534]         }
[13:22:01.534]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:01.534]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:01.534]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:01.534]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:01.534]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:01.534]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:01.534]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:01.534]             base::names(...future.oldOptions))
[13:22:01.534]     }
[13:22:01.534]     if (FALSE) {
[13:22:01.534]     }
[13:22:01.534]     else {
[13:22:01.534]         if (TRUE) {
[13:22:01.534]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:01.534]                 open = "w")
[13:22:01.534]         }
[13:22:01.534]         else {
[13:22:01.534]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:01.534]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:01.534]         }
[13:22:01.534]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:01.534]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:01.534]             base::sink(type = "output", split = FALSE)
[13:22:01.534]             base::close(...future.stdout)
[13:22:01.534]         }, add = TRUE)
[13:22:01.534]     }
[13:22:01.534]     ...future.frame <- base::sys.nframe()
[13:22:01.534]     ...future.conditions <- base::list()
[13:22:01.534]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:01.534]     if (FALSE) {
[13:22:01.534]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:01.534]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:01.534]     }
[13:22:01.534]     ...future.result <- base::tryCatch({
[13:22:01.534]         base::withCallingHandlers({
[13:22:01.534]             ...future.value <- base::withVisible(base::local({
[13:22:01.534]                 ...future.makeSendCondition <- base::local({
[13:22:01.534]                   sendCondition <- NULL
[13:22:01.534]                   function(frame = 1L) {
[13:22:01.534]                     if (is.function(sendCondition)) 
[13:22:01.534]                       return(sendCondition)
[13:22:01.534]                     ns <- getNamespace("parallel")
[13:22:01.534]                     if (exists("sendData", mode = "function", 
[13:22:01.534]                       envir = ns)) {
[13:22:01.534]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:01.534]                         envir = ns)
[13:22:01.534]                       envir <- sys.frame(frame)
[13:22:01.534]                       master <- NULL
[13:22:01.534]                       while (!identical(envir, .GlobalEnv) && 
[13:22:01.534]                         !identical(envir, emptyenv())) {
[13:22:01.534]                         if (exists("master", mode = "list", envir = envir, 
[13:22:01.534]                           inherits = FALSE)) {
[13:22:01.534]                           master <- get("master", mode = "list", 
[13:22:01.534]                             envir = envir, inherits = FALSE)
[13:22:01.534]                           if (inherits(master, c("SOCKnode", 
[13:22:01.534]                             "SOCK0node"))) {
[13:22:01.534]                             sendCondition <<- function(cond) {
[13:22:01.534]                               data <- list(type = "VALUE", value = cond, 
[13:22:01.534]                                 success = TRUE)
[13:22:01.534]                               parallel_sendData(master, data)
[13:22:01.534]                             }
[13:22:01.534]                             return(sendCondition)
[13:22:01.534]                           }
[13:22:01.534]                         }
[13:22:01.534]                         frame <- frame + 1L
[13:22:01.534]                         envir <- sys.frame(frame)
[13:22:01.534]                       }
[13:22:01.534]                     }
[13:22:01.534]                     sendCondition <<- function(cond) NULL
[13:22:01.534]                   }
[13:22:01.534]                 })
[13:22:01.534]                 withCallingHandlers({
[13:22:01.534]                   NA
[13:22:01.534]                 }, immediateCondition = function(cond) {
[13:22:01.534]                   sendCondition <- ...future.makeSendCondition()
[13:22:01.534]                   sendCondition(cond)
[13:22:01.534]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:01.534]                   {
[13:22:01.534]                     inherits <- base::inherits
[13:22:01.534]                     invokeRestart <- base::invokeRestart
[13:22:01.534]                     is.null <- base::is.null
[13:22:01.534]                     muffled <- FALSE
[13:22:01.534]                     if (inherits(cond, "message")) {
[13:22:01.534]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:01.534]                       if (muffled) 
[13:22:01.534]                         invokeRestart("muffleMessage")
[13:22:01.534]                     }
[13:22:01.534]                     else if (inherits(cond, "warning")) {
[13:22:01.534]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:01.534]                       if (muffled) 
[13:22:01.534]                         invokeRestart("muffleWarning")
[13:22:01.534]                     }
[13:22:01.534]                     else if (inherits(cond, "condition")) {
[13:22:01.534]                       if (!is.null(pattern)) {
[13:22:01.534]                         computeRestarts <- base::computeRestarts
[13:22:01.534]                         grepl <- base::grepl
[13:22:01.534]                         restarts <- computeRestarts(cond)
[13:22:01.534]                         for (restart in restarts) {
[13:22:01.534]                           name <- restart$name
[13:22:01.534]                           if (is.null(name)) 
[13:22:01.534]                             next
[13:22:01.534]                           if (!grepl(pattern, name)) 
[13:22:01.534]                             next
[13:22:01.534]                           invokeRestart(restart)
[13:22:01.534]                           muffled <- TRUE
[13:22:01.534]                           break
[13:22:01.534]                         }
[13:22:01.534]                       }
[13:22:01.534]                     }
[13:22:01.534]                     invisible(muffled)
[13:22:01.534]                   }
[13:22:01.534]                   muffleCondition(cond)
[13:22:01.534]                 })
[13:22:01.534]             }))
[13:22:01.534]             future::FutureResult(value = ...future.value$value, 
[13:22:01.534]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:01.534]                   ...future.rng), globalenv = if (FALSE) 
[13:22:01.534]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:01.534]                     ...future.globalenv.names))
[13:22:01.534]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:01.534]         }, condition = base::local({
[13:22:01.534]             c <- base::c
[13:22:01.534]             inherits <- base::inherits
[13:22:01.534]             invokeRestart <- base::invokeRestart
[13:22:01.534]             length <- base::length
[13:22:01.534]             list <- base::list
[13:22:01.534]             seq.int <- base::seq.int
[13:22:01.534]             signalCondition <- base::signalCondition
[13:22:01.534]             sys.calls <- base::sys.calls
[13:22:01.534]             `[[` <- base::`[[`
[13:22:01.534]             `+` <- base::`+`
[13:22:01.534]             `<<-` <- base::`<<-`
[13:22:01.534]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:01.534]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:01.534]                   3L)]
[13:22:01.534]             }
[13:22:01.534]             function(cond) {
[13:22:01.534]                 is_error <- inherits(cond, "error")
[13:22:01.534]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:01.534]                   NULL)
[13:22:01.534]                 if (is_error) {
[13:22:01.534]                   sessionInformation <- function() {
[13:22:01.534]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:01.534]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:01.534]                       search = base::search(), system = base::Sys.info())
[13:22:01.534]                   }
[13:22:01.534]                   ...future.conditions[[length(...future.conditions) + 
[13:22:01.534]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:01.534]                     cond$call), session = sessionInformation(), 
[13:22:01.534]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:01.534]                   signalCondition(cond)
[13:22:01.534]                 }
[13:22:01.534]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:01.534]                 "immediateCondition"))) {
[13:22:01.534]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:01.534]                   ...future.conditions[[length(...future.conditions) + 
[13:22:01.534]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:01.534]                   if (TRUE && !signal) {
[13:22:01.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:01.534]                     {
[13:22:01.534]                       inherits <- base::inherits
[13:22:01.534]                       invokeRestart <- base::invokeRestart
[13:22:01.534]                       is.null <- base::is.null
[13:22:01.534]                       muffled <- FALSE
[13:22:01.534]                       if (inherits(cond, "message")) {
[13:22:01.534]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:01.534]                         if (muffled) 
[13:22:01.534]                           invokeRestart("muffleMessage")
[13:22:01.534]                       }
[13:22:01.534]                       else if (inherits(cond, "warning")) {
[13:22:01.534]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:01.534]                         if (muffled) 
[13:22:01.534]                           invokeRestart("muffleWarning")
[13:22:01.534]                       }
[13:22:01.534]                       else if (inherits(cond, "condition")) {
[13:22:01.534]                         if (!is.null(pattern)) {
[13:22:01.534]                           computeRestarts <- base::computeRestarts
[13:22:01.534]                           grepl <- base::grepl
[13:22:01.534]                           restarts <- computeRestarts(cond)
[13:22:01.534]                           for (restart in restarts) {
[13:22:01.534]                             name <- restart$name
[13:22:01.534]                             if (is.null(name)) 
[13:22:01.534]                               next
[13:22:01.534]                             if (!grepl(pattern, name)) 
[13:22:01.534]                               next
[13:22:01.534]                             invokeRestart(restart)
[13:22:01.534]                             muffled <- TRUE
[13:22:01.534]                             break
[13:22:01.534]                           }
[13:22:01.534]                         }
[13:22:01.534]                       }
[13:22:01.534]                       invisible(muffled)
[13:22:01.534]                     }
[13:22:01.534]                     muffleCondition(cond, pattern = "^muffle")
[13:22:01.534]                   }
[13:22:01.534]                 }
[13:22:01.534]                 else {
[13:22:01.534]                   if (TRUE) {
[13:22:01.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:01.534]                     {
[13:22:01.534]                       inherits <- base::inherits
[13:22:01.534]                       invokeRestart <- base::invokeRestart
[13:22:01.534]                       is.null <- base::is.null
[13:22:01.534]                       muffled <- FALSE
[13:22:01.534]                       if (inherits(cond, "message")) {
[13:22:01.534]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:01.534]                         if (muffled) 
[13:22:01.534]                           invokeRestart("muffleMessage")
[13:22:01.534]                       }
[13:22:01.534]                       else if (inherits(cond, "warning")) {
[13:22:01.534]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:01.534]                         if (muffled) 
[13:22:01.534]                           invokeRestart("muffleWarning")
[13:22:01.534]                       }
[13:22:01.534]                       else if (inherits(cond, "condition")) {
[13:22:01.534]                         if (!is.null(pattern)) {
[13:22:01.534]                           computeRestarts <- base::computeRestarts
[13:22:01.534]                           grepl <- base::grepl
[13:22:01.534]                           restarts <- computeRestarts(cond)
[13:22:01.534]                           for (restart in restarts) {
[13:22:01.534]                             name <- restart$name
[13:22:01.534]                             if (is.null(name)) 
[13:22:01.534]                               next
[13:22:01.534]                             if (!grepl(pattern, name)) 
[13:22:01.534]                               next
[13:22:01.534]                             invokeRestart(restart)
[13:22:01.534]                             muffled <- TRUE
[13:22:01.534]                             break
[13:22:01.534]                           }
[13:22:01.534]                         }
[13:22:01.534]                       }
[13:22:01.534]                       invisible(muffled)
[13:22:01.534]                     }
[13:22:01.534]                     muffleCondition(cond, pattern = "^muffle")
[13:22:01.534]                   }
[13:22:01.534]                 }
[13:22:01.534]             }
[13:22:01.534]         }))
[13:22:01.534]     }, error = function(ex) {
[13:22:01.534]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:01.534]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:01.534]                 ...future.rng), started = ...future.startTime, 
[13:22:01.534]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:01.534]             version = "1.8"), class = "FutureResult")
[13:22:01.534]     }, finally = {
[13:22:01.534]         if (!identical(...future.workdir, getwd())) 
[13:22:01.534]             setwd(...future.workdir)
[13:22:01.534]         {
[13:22:01.534]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:01.534]                 ...future.oldOptions$nwarnings <- NULL
[13:22:01.534]             }
[13:22:01.534]             base::options(...future.oldOptions)
[13:22:01.534]             if (.Platform$OS.type == "windows") {
[13:22:01.534]                 old_names <- names(...future.oldEnvVars)
[13:22:01.534]                 envs <- base::Sys.getenv()
[13:22:01.534]                 names <- names(envs)
[13:22:01.534]                 common <- intersect(names, old_names)
[13:22:01.534]                 added <- setdiff(names, old_names)
[13:22:01.534]                 removed <- setdiff(old_names, names)
[13:22:01.534]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:01.534]                   envs[common]]
[13:22:01.534]                 NAMES <- toupper(changed)
[13:22:01.534]                 args <- list()
[13:22:01.534]                 for (kk in seq_along(NAMES)) {
[13:22:01.534]                   name <- changed[[kk]]
[13:22:01.534]                   NAME <- NAMES[[kk]]
[13:22:01.534]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:01.534]                     next
[13:22:01.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:01.534]                 }
[13:22:01.534]                 NAMES <- toupper(added)
[13:22:01.534]                 for (kk in seq_along(NAMES)) {
[13:22:01.534]                   name <- added[[kk]]
[13:22:01.534]                   NAME <- NAMES[[kk]]
[13:22:01.534]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:01.534]                     next
[13:22:01.534]                   args[[name]] <- ""
[13:22:01.534]                 }
[13:22:01.534]                 NAMES <- toupper(removed)
[13:22:01.534]                 for (kk in seq_along(NAMES)) {
[13:22:01.534]                   name <- removed[[kk]]
[13:22:01.534]                   NAME <- NAMES[[kk]]
[13:22:01.534]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:01.534]                     next
[13:22:01.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:01.534]                 }
[13:22:01.534]                 if (length(args) > 0) 
[13:22:01.534]                   base::do.call(base::Sys.setenv, args = args)
[13:22:01.534]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:01.534]             }
[13:22:01.534]             else {
[13:22:01.534]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:01.534]             }
[13:22:01.534]             {
[13:22:01.534]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:01.534]                   0L) {
[13:22:01.534]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:01.534]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:01.534]                   base::options(opts)
[13:22:01.534]                 }
[13:22:01.534]                 {
[13:22:01.534]                   {
[13:22:01.534]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:01.534]                     NULL
[13:22:01.534]                   }
[13:22:01.534]                   options(future.plan = NULL)
[13:22:01.534]                   if (is.na(NA_character_)) 
[13:22:01.534]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:01.534]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:01.534]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:01.534]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:01.534]                     envir = parent.frame()) 
[13:22:01.534]                   {
[13:22:01.534]                     if (is.function(workers)) 
[13:22:01.534]                       workers <- workers()
[13:22:01.534]                     workers <- structure(as.integer(workers), 
[13:22:01.534]                       class = class(workers))
[13:22:01.534]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:01.534]                       workers >= 1)
[13:22:01.534]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:01.534]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:01.534]                     }
[13:22:01.534]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:01.534]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:01.534]                       envir = envir)
[13:22:01.534]                     if (!future$lazy) 
[13:22:01.534]                       future <- run(future)
[13:22:01.534]                     invisible(future)
[13:22:01.534]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:01.534]                 }
[13:22:01.534]             }
[13:22:01.534]         }
[13:22:01.534]     })
[13:22:01.534]     if (TRUE) {
[13:22:01.534]         base::sink(type = "output", split = FALSE)
[13:22:01.534]         if (TRUE) {
[13:22:01.534]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:01.534]         }
[13:22:01.534]         else {
[13:22:01.534]             ...future.result["stdout"] <- base::list(NULL)
[13:22:01.534]         }
[13:22:01.534]         base::close(...future.stdout)
[13:22:01.534]         ...future.stdout <- NULL
[13:22:01.534]     }
[13:22:01.534]     ...future.result$conditions <- ...future.conditions
[13:22:01.534]     ...future.result$finished <- base::Sys.time()
[13:22:01.534]     ...future.result
[13:22:01.534] }
[13:22:01.592] MultisessionFuture started
[13:22:01.593] result() for ClusterFuture ...
[13:22:01.593] receiveMessageFromWorker() for ClusterFuture ...
[13:22:01.594] - Validating connection of MultisessionFuture
[13:22:01.640] - received message: FutureResult
[13:22:01.640] - Received FutureResult
[13:22:01.640] - Erased future from FutureRegistry
[13:22:01.640] result() for ClusterFuture ...
[13:22:01.640] - result already collected: FutureResult
[13:22:01.640] result() for ClusterFuture ... done
[13:22:01.641] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:01.641] result() for ClusterFuture ... done
[13:22:01.641] result() for ClusterFuture ...
[13:22:01.641] - result already collected: FutureResult
[13:22:01.641] result() for ClusterFuture ... done
[13:22:01.641] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:22:01.645] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[13:22:01.646] future_lapply() ...
[13:22:01.650] Number of chunks: 2
[13:22:01.650] getGlobalsAndPackagesXApply() ...
[13:22:01.650]  - future.globals: TRUE
[13:22:01.651] getGlobalsAndPackages() ...
[13:22:01.651] Searching for globals...
[13:22:01.652] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:22:01.653] Searching for globals ... DONE
[13:22:01.653] Resolving globals: FALSE
[13:22:01.653] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:22:01.654] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:22:01.654] - globals: [1] ‘FUN’
[13:22:01.654] 
[13:22:01.654] getGlobalsAndPackages() ... DONE
[13:22:01.654]  - globals found/used: [n=1] ‘FUN’
[13:22:01.654]  - needed namespaces: [n=0] 
[13:22:01.654] Finding globals ... DONE
[13:22:01.655]  - use_args: TRUE
[13:22:01.655]  - Getting '...' globals ...
[13:22:01.655] resolve() on list ...
[13:22:01.655]  recursive: 0
[13:22:01.655]  length: 1
[13:22:01.655]  elements: ‘...’
[13:22:01.656]  length: 0 (resolved future 1)
[13:22:01.656] resolve() on list ... DONE
[13:22:01.656]    - '...' content: [n=0] 
[13:22:01.656] List of 1
[13:22:01.656]  $ ...: list()
[13:22:01.656]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:22:01.656]  - attr(*, "where")=List of 1
[13:22:01.656]   ..$ ...:<environment: 0x55dd758c86b0> 
[13:22:01.656]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:22:01.656]  - attr(*, "resolved")= logi TRUE
[13:22:01.656]  - attr(*, "total_size")= num NA
[13:22:01.659]  - Getting '...' globals ... DONE
[13:22:01.659] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:22:01.660] List of 2
[13:22:01.660]  $ ...future.FUN:function (x)  
[13:22:01.660]  $ ...          : list()
[13:22:01.660]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:22:01.660]  - attr(*, "where")=List of 2
[13:22:01.660]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:22:01.660]   ..$ ...          :<environment: 0x55dd758c86b0> 
[13:22:01.660]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:22:01.660]  - attr(*, "resolved")= logi FALSE
[13:22:01.660]  - attr(*, "total_size")= num 4720
[13:22:01.663] Packages to be attached in all futures: [n=0] 
[13:22:01.663] getGlobalsAndPackagesXApply() ... DONE
[13:22:01.663] Number of futures (= number of chunks): 2
[13:22:01.663] Launching 2 futures (chunks) ...
[13:22:01.664] Chunk #1 of 2 ...
[13:22:01.664]  - Finding globals in 'X' for chunk #1 ...
[13:22:01.664] getGlobalsAndPackages() ...
[13:22:01.664] Searching for globals...
[13:22:01.664] 
[13:22:01.664] Searching for globals ... DONE
[13:22:01.665] - globals: [0] <none>
[13:22:01.665] getGlobalsAndPackages() ... DONE
[13:22:01.665]    + additional globals found: [n=0] 
[13:22:01.665]    + additional namespaces needed: [n=0] 
[13:22:01.665]  - Finding globals in 'X' for chunk #1 ... DONE
[13:22:01.665]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:22:01.665]  - seeds: <none>
[13:22:01.665]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:01.665] getGlobalsAndPackages() ...
[13:22:01.666] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:01.666] Resolving globals: FALSE
[13:22:01.666] Tweak future expression to call with '...' arguments ...
[13:22:01.666] {
[13:22:01.666]     do.call(function(...) {
[13:22:01.666]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:01.666]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:22:01.666]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:01.666]             on.exit(options(oopts), add = TRUE)
[13:22:01.666]         }
[13:22:01.666]         {
[13:22:01.666]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:22:01.666]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:22:01.666]                 ...future.FUN(...future.X_jj, ...)
[13:22:01.666]             })
[13:22:01.666]         }
[13:22:01.666]     }, args = future.call.arguments)
[13:22:01.666] }
[13:22:01.666] Tweak future expression to call with '...' arguments ... DONE
[13:22:01.667] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:01.667] 
[13:22:01.667] getGlobalsAndPackages() ... DONE
[13:22:01.667] run() for ‘Future’ ...
[13:22:01.667] - state: ‘created’
[13:22:01.668] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:01.683] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:01.683] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:01.683]   - Field: ‘node’
[13:22:01.683]   - Field: ‘label’
[13:22:01.683]   - Field: ‘local’
[13:22:01.683]   - Field: ‘owner’
[13:22:01.683]   - Field: ‘envir’
[13:22:01.684]   - Field: ‘workers’
[13:22:01.684]   - Field: ‘packages’
[13:22:01.684]   - Field: ‘gc’
[13:22:01.684]   - Field: ‘conditions’
[13:22:01.684]   - Field: ‘persistent’
[13:22:01.684]   - Field: ‘expr’
[13:22:01.684]   - Field: ‘uuid’
[13:22:01.684]   - Field: ‘seed’
[13:22:01.684]   - Field: ‘version’
[13:22:01.685]   - Field: ‘result’
[13:22:01.685]   - Field: ‘asynchronous’
[13:22:01.685]   - Field: ‘calls’
[13:22:01.685]   - Field: ‘globals’
[13:22:01.685]   - Field: ‘stdout’
[13:22:01.685]   - Field: ‘earlySignal’
[13:22:01.685]   - Field: ‘lazy’
[13:22:01.685]   - Field: ‘state’
[13:22:01.686] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:01.686] - Launch lazy future ...
[13:22:01.686] Packages needed by the future expression (n = 0): <none>
[13:22:01.686] Packages needed by future strategies (n = 0): <none>
[13:22:01.687] {
[13:22:01.687]     {
[13:22:01.687]         {
[13:22:01.687]             ...future.startTime <- base::Sys.time()
[13:22:01.687]             {
[13:22:01.687]                 {
[13:22:01.687]                   {
[13:22:01.687]                     {
[13:22:01.687]                       base::local({
[13:22:01.687]                         has_future <- base::requireNamespace("future", 
[13:22:01.687]                           quietly = TRUE)
[13:22:01.687]                         if (has_future) {
[13:22:01.687]                           ns <- base::getNamespace("future")
[13:22:01.687]                           version <- ns[[".package"]][["version"]]
[13:22:01.687]                           if (is.null(version)) 
[13:22:01.687]                             version <- utils::packageVersion("future")
[13:22:01.687]                         }
[13:22:01.687]                         else {
[13:22:01.687]                           version <- NULL
[13:22:01.687]                         }
[13:22:01.687]                         if (!has_future || version < "1.8.0") {
[13:22:01.687]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:01.687]                             "", base::R.version$version.string), 
[13:22:01.687]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:01.687]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:01.687]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:01.687]                               "release", "version")], collapse = " "), 
[13:22:01.687]                             hostname = base::Sys.info()[["nodename"]])
[13:22:01.687]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:01.687]                             info)
[13:22:01.687]                           info <- base::paste(info, collapse = "; ")
[13:22:01.687]                           if (!has_future) {
[13:22:01.687]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:01.687]                               info)
[13:22:01.687]                           }
[13:22:01.687]                           else {
[13:22:01.687]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:01.687]                               info, version)
[13:22:01.687]                           }
[13:22:01.687]                           base::stop(msg)
[13:22:01.687]                         }
[13:22:01.687]                       })
[13:22:01.687]                     }
[13:22:01.687]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:01.687]                     base::options(mc.cores = 1L)
[13:22:01.687]                   }
[13:22:01.687]                   options(future.plan = NULL)
[13:22:01.687]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:01.687]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:01.687]                 }
[13:22:01.687]                 ...future.workdir <- getwd()
[13:22:01.687]             }
[13:22:01.687]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:01.687]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:01.687]         }
[13:22:01.687]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:01.687]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:22:01.687]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:01.687]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:01.687]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:01.687]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:01.687]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:01.687]             base::names(...future.oldOptions))
[13:22:01.687]     }
[13:22:01.687]     if (FALSE) {
[13:22:01.687]     }
[13:22:01.687]     else {
[13:22:01.687]         if (FALSE) {
[13:22:01.687]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:01.687]                 open = "w")
[13:22:01.687]         }
[13:22:01.687]         else {
[13:22:01.687]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:01.687]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:01.687]         }
[13:22:01.687]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:01.687]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:01.687]             base::sink(type = "output", split = FALSE)
[13:22:01.687]             base::close(...future.stdout)
[13:22:01.687]         }, add = TRUE)
[13:22:01.687]     }
[13:22:01.687]     ...future.frame <- base::sys.nframe()
[13:22:01.687]     ...future.conditions <- base::list()
[13:22:01.687]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:01.687]     if (FALSE) {
[13:22:01.687]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:01.687]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:01.687]     }
[13:22:01.687]     ...future.result <- base::tryCatch({
[13:22:01.687]         base::withCallingHandlers({
[13:22:01.687]             ...future.value <- base::withVisible(base::local({
[13:22:01.687]                 ...future.makeSendCondition <- base::local({
[13:22:01.687]                   sendCondition <- NULL
[13:22:01.687]                   function(frame = 1L) {
[13:22:01.687]                     if (is.function(sendCondition)) 
[13:22:01.687]                       return(sendCondition)
[13:22:01.687]                     ns <- getNamespace("parallel")
[13:22:01.687]                     if (exists("sendData", mode = "function", 
[13:22:01.687]                       envir = ns)) {
[13:22:01.687]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:01.687]                         envir = ns)
[13:22:01.687]                       envir <- sys.frame(frame)
[13:22:01.687]                       master <- NULL
[13:22:01.687]                       while (!identical(envir, .GlobalEnv) && 
[13:22:01.687]                         !identical(envir, emptyenv())) {
[13:22:01.687]                         if (exists("master", mode = "list", envir = envir, 
[13:22:01.687]                           inherits = FALSE)) {
[13:22:01.687]                           master <- get("master", mode = "list", 
[13:22:01.687]                             envir = envir, inherits = FALSE)
[13:22:01.687]                           if (inherits(master, c("SOCKnode", 
[13:22:01.687]                             "SOCK0node"))) {
[13:22:01.687]                             sendCondition <<- function(cond) {
[13:22:01.687]                               data <- list(type = "VALUE", value = cond, 
[13:22:01.687]                                 success = TRUE)
[13:22:01.687]                               parallel_sendData(master, data)
[13:22:01.687]                             }
[13:22:01.687]                             return(sendCondition)
[13:22:01.687]                           }
[13:22:01.687]                         }
[13:22:01.687]                         frame <- frame + 1L
[13:22:01.687]                         envir <- sys.frame(frame)
[13:22:01.687]                       }
[13:22:01.687]                     }
[13:22:01.687]                     sendCondition <<- function(cond) NULL
[13:22:01.687]                   }
[13:22:01.687]                 })
[13:22:01.687]                 withCallingHandlers({
[13:22:01.687]                   {
[13:22:01.687]                     do.call(function(...) {
[13:22:01.687]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:01.687]                       if (!identical(...future.globals.maxSize.org, 
[13:22:01.687]                         ...future.globals.maxSize)) {
[13:22:01.687]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:01.687]                         on.exit(options(oopts), add = TRUE)
[13:22:01.687]                       }
[13:22:01.687]                       {
[13:22:01.687]                         lapply(seq_along(...future.elements_ii), 
[13:22:01.687]                           FUN = function(jj) {
[13:22:01.687]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:22:01.687]                             ...future.FUN(...future.X_jj, ...)
[13:22:01.687]                           })
[13:22:01.687]                       }
[13:22:01.687]                     }, args = future.call.arguments)
[13:22:01.687]                   }
[13:22:01.687]                 }, immediateCondition = function(cond) {
[13:22:01.687]                   sendCondition <- ...future.makeSendCondition()
[13:22:01.687]                   sendCondition(cond)
[13:22:01.687]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:01.687]                   {
[13:22:01.687]                     inherits <- base::inherits
[13:22:01.687]                     invokeRestart <- base::invokeRestart
[13:22:01.687]                     is.null <- base::is.null
[13:22:01.687]                     muffled <- FALSE
[13:22:01.687]                     if (inherits(cond, "message")) {
[13:22:01.687]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:01.687]                       if (muffled) 
[13:22:01.687]                         invokeRestart("muffleMessage")
[13:22:01.687]                     }
[13:22:01.687]                     else if (inherits(cond, "warning")) {
[13:22:01.687]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:01.687]                       if (muffled) 
[13:22:01.687]                         invokeRestart("muffleWarning")
[13:22:01.687]                     }
[13:22:01.687]                     else if (inherits(cond, "condition")) {
[13:22:01.687]                       if (!is.null(pattern)) {
[13:22:01.687]                         computeRestarts <- base::computeRestarts
[13:22:01.687]                         grepl <- base::grepl
[13:22:01.687]                         restarts <- computeRestarts(cond)
[13:22:01.687]                         for (restart in restarts) {
[13:22:01.687]                           name <- restart$name
[13:22:01.687]                           if (is.null(name)) 
[13:22:01.687]                             next
[13:22:01.687]                           if (!grepl(pattern, name)) 
[13:22:01.687]                             next
[13:22:01.687]                           invokeRestart(restart)
[13:22:01.687]                           muffled <- TRUE
[13:22:01.687]                           break
[13:22:01.687]                         }
[13:22:01.687]                       }
[13:22:01.687]                     }
[13:22:01.687]                     invisible(muffled)
[13:22:01.687]                   }
[13:22:01.687]                   muffleCondition(cond)
[13:22:01.687]                 })
[13:22:01.687]             }))
[13:22:01.687]             future::FutureResult(value = ...future.value$value, 
[13:22:01.687]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:01.687]                   ...future.rng), globalenv = if (FALSE) 
[13:22:01.687]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:01.687]                     ...future.globalenv.names))
[13:22:01.687]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:01.687]         }, condition = base::local({
[13:22:01.687]             c <- base::c
[13:22:01.687]             inherits <- base::inherits
[13:22:01.687]             invokeRestart <- base::invokeRestart
[13:22:01.687]             length <- base::length
[13:22:01.687]             list <- base::list
[13:22:01.687]             seq.int <- base::seq.int
[13:22:01.687]             signalCondition <- base::signalCondition
[13:22:01.687]             sys.calls <- base::sys.calls
[13:22:01.687]             `[[` <- base::`[[`
[13:22:01.687]             `+` <- base::`+`
[13:22:01.687]             `<<-` <- base::`<<-`
[13:22:01.687]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:01.687]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:01.687]                   3L)]
[13:22:01.687]             }
[13:22:01.687]             function(cond) {
[13:22:01.687]                 is_error <- inherits(cond, "error")
[13:22:01.687]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:01.687]                   NULL)
[13:22:01.687]                 if (is_error) {
[13:22:01.687]                   sessionInformation <- function() {
[13:22:01.687]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:01.687]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:01.687]                       search = base::search(), system = base::Sys.info())
[13:22:01.687]                   }
[13:22:01.687]                   ...future.conditions[[length(...future.conditions) + 
[13:22:01.687]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:01.687]                     cond$call), session = sessionInformation(), 
[13:22:01.687]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:01.687]                   signalCondition(cond)
[13:22:01.687]                 }
[13:22:01.687]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:01.687]                 "immediateCondition"))) {
[13:22:01.687]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:01.687]                   ...future.conditions[[length(...future.conditions) + 
[13:22:01.687]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:01.687]                   if (TRUE && !signal) {
[13:22:01.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:01.687]                     {
[13:22:01.687]                       inherits <- base::inherits
[13:22:01.687]                       invokeRestart <- base::invokeRestart
[13:22:01.687]                       is.null <- base::is.null
[13:22:01.687]                       muffled <- FALSE
[13:22:01.687]                       if (inherits(cond, "message")) {
[13:22:01.687]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:01.687]                         if (muffled) 
[13:22:01.687]                           invokeRestart("muffleMessage")
[13:22:01.687]                       }
[13:22:01.687]                       else if (inherits(cond, "warning")) {
[13:22:01.687]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:01.687]                         if (muffled) 
[13:22:01.687]                           invokeRestart("muffleWarning")
[13:22:01.687]                       }
[13:22:01.687]                       else if (inherits(cond, "condition")) {
[13:22:01.687]                         if (!is.null(pattern)) {
[13:22:01.687]                           computeRestarts <- base::computeRestarts
[13:22:01.687]                           grepl <- base::grepl
[13:22:01.687]                           restarts <- computeRestarts(cond)
[13:22:01.687]                           for (restart in restarts) {
[13:22:01.687]                             name <- restart$name
[13:22:01.687]                             if (is.null(name)) 
[13:22:01.687]                               next
[13:22:01.687]                             if (!grepl(pattern, name)) 
[13:22:01.687]                               next
[13:22:01.687]                             invokeRestart(restart)
[13:22:01.687]                             muffled <- TRUE
[13:22:01.687]                             break
[13:22:01.687]                           }
[13:22:01.687]                         }
[13:22:01.687]                       }
[13:22:01.687]                       invisible(muffled)
[13:22:01.687]                     }
[13:22:01.687]                     muffleCondition(cond, pattern = "^muffle")
[13:22:01.687]                   }
[13:22:01.687]                 }
[13:22:01.687]                 else {
[13:22:01.687]                   if (TRUE) {
[13:22:01.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:01.687]                     {
[13:22:01.687]                       inherits <- base::inherits
[13:22:01.687]                       invokeRestart <- base::invokeRestart
[13:22:01.687]                       is.null <- base::is.null
[13:22:01.687]                       muffled <- FALSE
[13:22:01.687]                       if (inherits(cond, "message")) {
[13:22:01.687]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:01.687]                         if (muffled) 
[13:22:01.687]                           invokeRestart("muffleMessage")
[13:22:01.687]                       }
[13:22:01.687]                       else if (inherits(cond, "warning")) {
[13:22:01.687]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:01.687]                         if (muffled) 
[13:22:01.687]                           invokeRestart("muffleWarning")
[13:22:01.687]                       }
[13:22:01.687]                       else if (inherits(cond, "condition")) {
[13:22:01.687]                         if (!is.null(pattern)) {
[13:22:01.687]                           computeRestarts <- base::computeRestarts
[13:22:01.687]                           grepl <- base::grepl
[13:22:01.687]                           restarts <- computeRestarts(cond)
[13:22:01.687]                           for (restart in restarts) {
[13:22:01.687]                             name <- restart$name
[13:22:01.687]                             if (is.null(name)) 
[13:22:01.687]                               next
[13:22:01.687]                             if (!grepl(pattern, name)) 
[13:22:01.687]                               next
[13:22:01.687]                             invokeRestart(restart)
[13:22:01.687]                             muffled <- TRUE
[13:22:01.687]                             break
[13:22:01.687]                           }
[13:22:01.687]                         }
[13:22:01.687]                       }
[13:22:01.687]                       invisible(muffled)
[13:22:01.687]                     }
[13:22:01.687]                     muffleCondition(cond, pattern = "^muffle")
[13:22:01.687]                   }
[13:22:01.687]                 }
[13:22:01.687]             }
[13:22:01.687]         }))
[13:22:01.687]     }, error = function(ex) {
[13:22:01.687]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:01.687]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:01.687]                 ...future.rng), started = ...future.startTime, 
[13:22:01.687]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:01.687]             version = "1.8"), class = "FutureResult")
[13:22:01.687]     }, finally = {
[13:22:01.687]         if (!identical(...future.workdir, getwd())) 
[13:22:01.687]             setwd(...future.workdir)
[13:22:01.687]         {
[13:22:01.687]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:01.687]                 ...future.oldOptions$nwarnings <- NULL
[13:22:01.687]             }
[13:22:01.687]             base::options(...future.oldOptions)
[13:22:01.687]             if (.Platform$OS.type == "windows") {
[13:22:01.687]                 old_names <- names(...future.oldEnvVars)
[13:22:01.687]                 envs <- base::Sys.getenv()
[13:22:01.687]                 names <- names(envs)
[13:22:01.687]                 common <- intersect(names, old_names)
[13:22:01.687]                 added <- setdiff(names, old_names)
[13:22:01.687]                 removed <- setdiff(old_names, names)
[13:22:01.687]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:01.687]                   envs[common]]
[13:22:01.687]                 NAMES <- toupper(changed)
[13:22:01.687]                 args <- list()
[13:22:01.687]                 for (kk in seq_along(NAMES)) {
[13:22:01.687]                   name <- changed[[kk]]
[13:22:01.687]                   NAME <- NAMES[[kk]]
[13:22:01.687]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:01.687]                     next
[13:22:01.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:01.687]                 }
[13:22:01.687]                 NAMES <- toupper(added)
[13:22:01.687]                 for (kk in seq_along(NAMES)) {
[13:22:01.687]                   name <- added[[kk]]
[13:22:01.687]                   NAME <- NAMES[[kk]]
[13:22:01.687]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:01.687]                     next
[13:22:01.687]                   args[[name]] <- ""
[13:22:01.687]                 }
[13:22:01.687]                 NAMES <- toupper(removed)
[13:22:01.687]                 for (kk in seq_along(NAMES)) {
[13:22:01.687]                   name <- removed[[kk]]
[13:22:01.687]                   NAME <- NAMES[[kk]]
[13:22:01.687]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:01.687]                     next
[13:22:01.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:01.687]                 }
[13:22:01.687]                 if (length(args) > 0) 
[13:22:01.687]                   base::do.call(base::Sys.setenv, args = args)
[13:22:01.687]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:01.687]             }
[13:22:01.687]             else {
[13:22:01.687]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:01.687]             }
[13:22:01.687]             {
[13:22:01.687]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:01.687]                   0L) {
[13:22:01.687]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:01.687]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:01.687]                   base::options(opts)
[13:22:01.687]                 }
[13:22:01.687]                 {
[13:22:01.687]                   {
[13:22:01.687]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:01.687]                     NULL
[13:22:01.687]                   }
[13:22:01.687]                   options(future.plan = NULL)
[13:22:01.687]                   if (is.na(NA_character_)) 
[13:22:01.687]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:01.687]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:01.687]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:01.687]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:01.687]                     envir = parent.frame()) 
[13:22:01.687]                   {
[13:22:01.687]                     if (is.function(workers)) 
[13:22:01.687]                       workers <- workers()
[13:22:01.687]                     workers <- structure(as.integer(workers), 
[13:22:01.687]                       class = class(workers))
[13:22:01.687]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:01.687]                       workers >= 1)
[13:22:01.687]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:01.687]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:01.687]                     }
[13:22:01.687]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:01.687]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:01.687]                       envir = envir)
[13:22:01.687]                     if (!future$lazy) 
[13:22:01.687]                       future <- run(future)
[13:22:01.687]                     invisible(future)
[13:22:01.687]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:01.687]                 }
[13:22:01.687]             }
[13:22:01.687]         }
[13:22:01.687]     })
[13:22:01.687]     if (TRUE) {
[13:22:01.687]         base::sink(type = "output", split = FALSE)
[13:22:01.687]         if (FALSE) {
[13:22:01.687]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:01.687]         }
[13:22:01.687]         else {
[13:22:01.687]             ...future.result["stdout"] <- base::list(NULL)
[13:22:01.687]         }
[13:22:01.687]         base::close(...future.stdout)
[13:22:01.687]         ...future.stdout <- NULL
[13:22:01.687]     }
[13:22:01.687]     ...future.result$conditions <- ...future.conditions
[13:22:01.687]     ...future.result$finished <- base::Sys.time()
[13:22:01.687]     ...future.result
[13:22:01.687] }
[13:22:01.690] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[13:22:01.690] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[13:22:01.691] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[13:22:01.691] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:22:01.691] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:22:01.692] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[13:22:01.692] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[13:22:01.692] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:22:01.692] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:22:01.693] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:22:01.693] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:22:01.693] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[13:22:01.694] MultisessionFuture started
[13:22:01.694] - Launch lazy future ... done
[13:22:01.694] run() for ‘MultisessionFuture’ ... done
[13:22:01.694] Created future:
[13:22:01.694] MultisessionFuture:
[13:22:01.694] Label: ‘future_lapply-1’
[13:22:01.694] Expression:
[13:22:01.694] {
[13:22:01.694]     do.call(function(...) {
[13:22:01.694]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:01.694]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:22:01.694]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:01.694]             on.exit(options(oopts), add = TRUE)
[13:22:01.694]         }
[13:22:01.694]         {
[13:22:01.694]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:22:01.694]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:22:01.694]                 ...future.FUN(...future.X_jj, ...)
[13:22:01.694]             })
[13:22:01.694]         }
[13:22:01.694]     }, args = future.call.arguments)
[13:22:01.694] }
[13:22:01.694] Lazy evaluation: FALSE
[13:22:01.694] Asynchronous evaluation: TRUE
[13:22:01.694] Local evaluation: TRUE
[13:22:01.694] Environment: R_GlobalEnv
[13:22:01.694] Capture standard output: FALSE
[13:22:01.694] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:22:01.694] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:22:01.694] Packages: <none>
[13:22:01.694] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:22:01.694] Resolved: FALSE
[13:22:01.694] Value: <not collected>
[13:22:01.694] Conditions captured: <none>
[13:22:01.694] Early signaling: FALSE
[13:22:01.694] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:22:01.694] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:01.707] Chunk #1 of 2 ... DONE
[13:22:01.707] Chunk #2 of 2 ...
[13:22:01.707]  - Finding globals in 'X' for chunk #2 ...
[13:22:01.707] getGlobalsAndPackages() ...
[13:22:01.707] Searching for globals...
[13:22:01.707] 
[13:22:01.708] Searching for globals ... DONE
[13:22:01.708] - globals: [0] <none>
[13:22:01.708] getGlobalsAndPackages() ... DONE
[13:22:01.708]    + additional globals found: [n=0] 
[13:22:01.708]    + additional namespaces needed: [n=0] 
[13:22:01.708]  - Finding globals in 'X' for chunk #2 ... DONE
[13:22:01.708]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:22:01.708]  - seeds: <none>
[13:22:01.708]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:01.709] getGlobalsAndPackages() ...
[13:22:01.709] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:01.709] Resolving globals: FALSE
[13:22:01.709] Tweak future expression to call with '...' arguments ...
[13:22:01.709] {
[13:22:01.709]     do.call(function(...) {
[13:22:01.709]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:01.709]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:22:01.709]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:01.709]             on.exit(options(oopts), add = TRUE)
[13:22:01.709]         }
[13:22:01.709]         {
[13:22:01.709]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:22:01.709]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:22:01.709]                 ...future.FUN(...future.X_jj, ...)
[13:22:01.709]             })
[13:22:01.709]         }
[13:22:01.709]     }, args = future.call.arguments)
[13:22:01.709] }
[13:22:01.709] Tweak future expression to call with '...' arguments ... DONE
[13:22:01.710] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:01.710] 
[13:22:01.710] getGlobalsAndPackages() ... DONE
[13:22:01.710] run() for ‘Future’ ...
[13:22:01.711] - state: ‘created’
[13:22:01.711] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:01.726] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:01.726] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:01.726]   - Field: ‘node’
[13:22:01.726]   - Field: ‘label’
[13:22:01.726]   - Field: ‘local’
[13:22:01.727]   - Field: ‘owner’
[13:22:01.727]   - Field: ‘envir’
[13:22:01.727]   - Field: ‘workers’
[13:22:01.727]   - Field: ‘packages’
[13:22:01.727]   - Field: ‘gc’
[13:22:01.727]   - Field: ‘conditions’
[13:22:01.727]   - Field: ‘persistent’
[13:22:01.727]   - Field: ‘expr’
[13:22:01.727]   - Field: ‘uuid’
[13:22:01.728]   - Field: ‘seed’
[13:22:01.728]   - Field: ‘version’
[13:22:01.728]   - Field: ‘result’
[13:22:01.728]   - Field: ‘asynchronous’
[13:22:01.728]   - Field: ‘calls’
[13:22:01.728]   - Field: ‘globals’
[13:22:01.728]   - Field: ‘stdout’
[13:22:01.728]   - Field: ‘earlySignal’
[13:22:01.728]   - Field: ‘lazy’
[13:22:01.729]   - Field: ‘state’
[13:22:01.729] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:01.729] - Launch lazy future ...
[13:22:01.729] Packages needed by the future expression (n = 0): <none>
[13:22:01.729] Packages needed by future strategies (n = 0): <none>
[13:22:01.730] {
[13:22:01.730]     {
[13:22:01.730]         {
[13:22:01.730]             ...future.startTime <- base::Sys.time()
[13:22:01.730]             {
[13:22:01.730]                 {
[13:22:01.730]                   {
[13:22:01.730]                     {
[13:22:01.730]                       base::local({
[13:22:01.730]                         has_future <- base::requireNamespace("future", 
[13:22:01.730]                           quietly = TRUE)
[13:22:01.730]                         if (has_future) {
[13:22:01.730]                           ns <- base::getNamespace("future")
[13:22:01.730]                           version <- ns[[".package"]][["version"]]
[13:22:01.730]                           if (is.null(version)) 
[13:22:01.730]                             version <- utils::packageVersion("future")
[13:22:01.730]                         }
[13:22:01.730]                         else {
[13:22:01.730]                           version <- NULL
[13:22:01.730]                         }
[13:22:01.730]                         if (!has_future || version < "1.8.0") {
[13:22:01.730]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:01.730]                             "", base::R.version$version.string), 
[13:22:01.730]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:01.730]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:01.730]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:01.730]                               "release", "version")], collapse = " "), 
[13:22:01.730]                             hostname = base::Sys.info()[["nodename"]])
[13:22:01.730]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:01.730]                             info)
[13:22:01.730]                           info <- base::paste(info, collapse = "; ")
[13:22:01.730]                           if (!has_future) {
[13:22:01.730]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:01.730]                               info)
[13:22:01.730]                           }
[13:22:01.730]                           else {
[13:22:01.730]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:01.730]                               info, version)
[13:22:01.730]                           }
[13:22:01.730]                           base::stop(msg)
[13:22:01.730]                         }
[13:22:01.730]                       })
[13:22:01.730]                     }
[13:22:01.730]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:01.730]                     base::options(mc.cores = 1L)
[13:22:01.730]                   }
[13:22:01.730]                   options(future.plan = NULL)
[13:22:01.730]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:01.730]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:01.730]                 }
[13:22:01.730]                 ...future.workdir <- getwd()
[13:22:01.730]             }
[13:22:01.730]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:01.730]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:01.730]         }
[13:22:01.730]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:01.730]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:22:01.730]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:01.730]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:01.730]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:01.730]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:01.730]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:01.730]             base::names(...future.oldOptions))
[13:22:01.730]     }
[13:22:01.730]     if (FALSE) {
[13:22:01.730]     }
[13:22:01.730]     else {
[13:22:01.730]         if (FALSE) {
[13:22:01.730]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:01.730]                 open = "w")
[13:22:01.730]         }
[13:22:01.730]         else {
[13:22:01.730]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:01.730]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:01.730]         }
[13:22:01.730]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:01.730]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:01.730]             base::sink(type = "output", split = FALSE)
[13:22:01.730]             base::close(...future.stdout)
[13:22:01.730]         }, add = TRUE)
[13:22:01.730]     }
[13:22:01.730]     ...future.frame <- base::sys.nframe()
[13:22:01.730]     ...future.conditions <- base::list()
[13:22:01.730]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:01.730]     if (FALSE) {
[13:22:01.730]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:01.730]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:01.730]     }
[13:22:01.730]     ...future.result <- base::tryCatch({
[13:22:01.730]         base::withCallingHandlers({
[13:22:01.730]             ...future.value <- base::withVisible(base::local({
[13:22:01.730]                 ...future.makeSendCondition <- base::local({
[13:22:01.730]                   sendCondition <- NULL
[13:22:01.730]                   function(frame = 1L) {
[13:22:01.730]                     if (is.function(sendCondition)) 
[13:22:01.730]                       return(sendCondition)
[13:22:01.730]                     ns <- getNamespace("parallel")
[13:22:01.730]                     if (exists("sendData", mode = "function", 
[13:22:01.730]                       envir = ns)) {
[13:22:01.730]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:01.730]                         envir = ns)
[13:22:01.730]                       envir <- sys.frame(frame)
[13:22:01.730]                       master <- NULL
[13:22:01.730]                       while (!identical(envir, .GlobalEnv) && 
[13:22:01.730]                         !identical(envir, emptyenv())) {
[13:22:01.730]                         if (exists("master", mode = "list", envir = envir, 
[13:22:01.730]                           inherits = FALSE)) {
[13:22:01.730]                           master <- get("master", mode = "list", 
[13:22:01.730]                             envir = envir, inherits = FALSE)
[13:22:01.730]                           if (inherits(master, c("SOCKnode", 
[13:22:01.730]                             "SOCK0node"))) {
[13:22:01.730]                             sendCondition <<- function(cond) {
[13:22:01.730]                               data <- list(type = "VALUE", value = cond, 
[13:22:01.730]                                 success = TRUE)
[13:22:01.730]                               parallel_sendData(master, data)
[13:22:01.730]                             }
[13:22:01.730]                             return(sendCondition)
[13:22:01.730]                           }
[13:22:01.730]                         }
[13:22:01.730]                         frame <- frame + 1L
[13:22:01.730]                         envir <- sys.frame(frame)
[13:22:01.730]                       }
[13:22:01.730]                     }
[13:22:01.730]                     sendCondition <<- function(cond) NULL
[13:22:01.730]                   }
[13:22:01.730]                 })
[13:22:01.730]                 withCallingHandlers({
[13:22:01.730]                   {
[13:22:01.730]                     do.call(function(...) {
[13:22:01.730]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:01.730]                       if (!identical(...future.globals.maxSize.org, 
[13:22:01.730]                         ...future.globals.maxSize)) {
[13:22:01.730]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:01.730]                         on.exit(options(oopts), add = TRUE)
[13:22:01.730]                       }
[13:22:01.730]                       {
[13:22:01.730]                         lapply(seq_along(...future.elements_ii), 
[13:22:01.730]                           FUN = function(jj) {
[13:22:01.730]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:22:01.730]                             ...future.FUN(...future.X_jj, ...)
[13:22:01.730]                           })
[13:22:01.730]                       }
[13:22:01.730]                     }, args = future.call.arguments)
[13:22:01.730]                   }
[13:22:01.730]                 }, immediateCondition = function(cond) {
[13:22:01.730]                   sendCondition <- ...future.makeSendCondition()
[13:22:01.730]                   sendCondition(cond)
[13:22:01.730]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:01.730]                   {
[13:22:01.730]                     inherits <- base::inherits
[13:22:01.730]                     invokeRestart <- base::invokeRestart
[13:22:01.730]                     is.null <- base::is.null
[13:22:01.730]                     muffled <- FALSE
[13:22:01.730]                     if (inherits(cond, "message")) {
[13:22:01.730]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:01.730]                       if (muffled) 
[13:22:01.730]                         invokeRestart("muffleMessage")
[13:22:01.730]                     }
[13:22:01.730]                     else if (inherits(cond, "warning")) {
[13:22:01.730]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:01.730]                       if (muffled) 
[13:22:01.730]                         invokeRestart("muffleWarning")
[13:22:01.730]                     }
[13:22:01.730]                     else if (inherits(cond, "condition")) {
[13:22:01.730]                       if (!is.null(pattern)) {
[13:22:01.730]                         computeRestarts <- base::computeRestarts
[13:22:01.730]                         grepl <- base::grepl
[13:22:01.730]                         restarts <- computeRestarts(cond)
[13:22:01.730]                         for (restart in restarts) {
[13:22:01.730]                           name <- restart$name
[13:22:01.730]                           if (is.null(name)) 
[13:22:01.730]                             next
[13:22:01.730]                           if (!grepl(pattern, name)) 
[13:22:01.730]                             next
[13:22:01.730]                           invokeRestart(restart)
[13:22:01.730]                           muffled <- TRUE
[13:22:01.730]                           break
[13:22:01.730]                         }
[13:22:01.730]                       }
[13:22:01.730]                     }
[13:22:01.730]                     invisible(muffled)
[13:22:01.730]                   }
[13:22:01.730]                   muffleCondition(cond)
[13:22:01.730]                 })
[13:22:01.730]             }))
[13:22:01.730]             future::FutureResult(value = ...future.value$value, 
[13:22:01.730]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:01.730]                   ...future.rng), globalenv = if (FALSE) 
[13:22:01.730]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:01.730]                     ...future.globalenv.names))
[13:22:01.730]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:01.730]         }, condition = base::local({
[13:22:01.730]             c <- base::c
[13:22:01.730]             inherits <- base::inherits
[13:22:01.730]             invokeRestart <- base::invokeRestart
[13:22:01.730]             length <- base::length
[13:22:01.730]             list <- base::list
[13:22:01.730]             seq.int <- base::seq.int
[13:22:01.730]             signalCondition <- base::signalCondition
[13:22:01.730]             sys.calls <- base::sys.calls
[13:22:01.730]             `[[` <- base::`[[`
[13:22:01.730]             `+` <- base::`+`
[13:22:01.730]             `<<-` <- base::`<<-`
[13:22:01.730]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:01.730]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:01.730]                   3L)]
[13:22:01.730]             }
[13:22:01.730]             function(cond) {
[13:22:01.730]                 is_error <- inherits(cond, "error")
[13:22:01.730]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:01.730]                   NULL)
[13:22:01.730]                 if (is_error) {
[13:22:01.730]                   sessionInformation <- function() {
[13:22:01.730]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:01.730]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:01.730]                       search = base::search(), system = base::Sys.info())
[13:22:01.730]                   }
[13:22:01.730]                   ...future.conditions[[length(...future.conditions) + 
[13:22:01.730]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:01.730]                     cond$call), session = sessionInformation(), 
[13:22:01.730]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:01.730]                   signalCondition(cond)
[13:22:01.730]                 }
[13:22:01.730]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:01.730]                 "immediateCondition"))) {
[13:22:01.730]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:01.730]                   ...future.conditions[[length(...future.conditions) + 
[13:22:01.730]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:01.730]                   if (TRUE && !signal) {
[13:22:01.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:01.730]                     {
[13:22:01.730]                       inherits <- base::inherits
[13:22:01.730]                       invokeRestart <- base::invokeRestart
[13:22:01.730]                       is.null <- base::is.null
[13:22:01.730]                       muffled <- FALSE
[13:22:01.730]                       if (inherits(cond, "message")) {
[13:22:01.730]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:01.730]                         if (muffled) 
[13:22:01.730]                           invokeRestart("muffleMessage")
[13:22:01.730]                       }
[13:22:01.730]                       else if (inherits(cond, "warning")) {
[13:22:01.730]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:01.730]                         if (muffled) 
[13:22:01.730]                           invokeRestart("muffleWarning")
[13:22:01.730]                       }
[13:22:01.730]                       else if (inherits(cond, "condition")) {
[13:22:01.730]                         if (!is.null(pattern)) {
[13:22:01.730]                           computeRestarts <- base::computeRestarts
[13:22:01.730]                           grepl <- base::grepl
[13:22:01.730]                           restarts <- computeRestarts(cond)
[13:22:01.730]                           for (restart in restarts) {
[13:22:01.730]                             name <- restart$name
[13:22:01.730]                             if (is.null(name)) 
[13:22:01.730]                               next
[13:22:01.730]                             if (!grepl(pattern, name)) 
[13:22:01.730]                               next
[13:22:01.730]                             invokeRestart(restart)
[13:22:01.730]                             muffled <- TRUE
[13:22:01.730]                             break
[13:22:01.730]                           }
[13:22:01.730]                         }
[13:22:01.730]                       }
[13:22:01.730]                       invisible(muffled)
[13:22:01.730]                     }
[13:22:01.730]                     muffleCondition(cond, pattern = "^muffle")
[13:22:01.730]                   }
[13:22:01.730]                 }
[13:22:01.730]                 else {
[13:22:01.730]                   if (TRUE) {
[13:22:01.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:01.730]                     {
[13:22:01.730]                       inherits <- base::inherits
[13:22:01.730]                       invokeRestart <- base::invokeRestart
[13:22:01.730]                       is.null <- base::is.null
[13:22:01.730]                       muffled <- FALSE
[13:22:01.730]                       if (inherits(cond, "message")) {
[13:22:01.730]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:01.730]                         if (muffled) 
[13:22:01.730]                           invokeRestart("muffleMessage")
[13:22:01.730]                       }
[13:22:01.730]                       else if (inherits(cond, "warning")) {
[13:22:01.730]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:01.730]                         if (muffled) 
[13:22:01.730]                           invokeRestart("muffleWarning")
[13:22:01.730]                       }
[13:22:01.730]                       else if (inherits(cond, "condition")) {
[13:22:01.730]                         if (!is.null(pattern)) {
[13:22:01.730]                           computeRestarts <- base::computeRestarts
[13:22:01.730]                           grepl <- base::grepl
[13:22:01.730]                           restarts <- computeRestarts(cond)
[13:22:01.730]                           for (restart in restarts) {
[13:22:01.730]                             name <- restart$name
[13:22:01.730]                             if (is.null(name)) 
[13:22:01.730]                               next
[13:22:01.730]                             if (!grepl(pattern, name)) 
[13:22:01.730]                               next
[13:22:01.730]                             invokeRestart(restart)
[13:22:01.730]                             muffled <- TRUE
[13:22:01.730]                             break
[13:22:01.730]                           }
[13:22:01.730]                         }
[13:22:01.730]                       }
[13:22:01.730]                       invisible(muffled)
[13:22:01.730]                     }
[13:22:01.730]                     muffleCondition(cond, pattern = "^muffle")
[13:22:01.730]                   }
[13:22:01.730]                 }
[13:22:01.730]             }
[13:22:01.730]         }))
[13:22:01.730]     }, error = function(ex) {
[13:22:01.730]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:01.730]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:01.730]                 ...future.rng), started = ...future.startTime, 
[13:22:01.730]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:01.730]             version = "1.8"), class = "FutureResult")
[13:22:01.730]     }, finally = {
[13:22:01.730]         if (!identical(...future.workdir, getwd())) 
[13:22:01.730]             setwd(...future.workdir)
[13:22:01.730]         {
[13:22:01.730]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:01.730]                 ...future.oldOptions$nwarnings <- NULL
[13:22:01.730]             }
[13:22:01.730]             base::options(...future.oldOptions)
[13:22:01.730]             if (.Platform$OS.type == "windows") {
[13:22:01.730]                 old_names <- names(...future.oldEnvVars)
[13:22:01.730]                 envs <- base::Sys.getenv()
[13:22:01.730]                 names <- names(envs)
[13:22:01.730]                 common <- intersect(names, old_names)
[13:22:01.730]                 added <- setdiff(names, old_names)
[13:22:01.730]                 removed <- setdiff(old_names, names)
[13:22:01.730]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:01.730]                   envs[common]]
[13:22:01.730]                 NAMES <- toupper(changed)
[13:22:01.730]                 args <- list()
[13:22:01.730]                 for (kk in seq_along(NAMES)) {
[13:22:01.730]                   name <- changed[[kk]]
[13:22:01.730]                   NAME <- NAMES[[kk]]
[13:22:01.730]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:01.730]                     next
[13:22:01.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:01.730]                 }
[13:22:01.730]                 NAMES <- toupper(added)
[13:22:01.730]                 for (kk in seq_along(NAMES)) {
[13:22:01.730]                   name <- added[[kk]]
[13:22:01.730]                   NAME <- NAMES[[kk]]
[13:22:01.730]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:01.730]                     next
[13:22:01.730]                   args[[name]] <- ""
[13:22:01.730]                 }
[13:22:01.730]                 NAMES <- toupper(removed)
[13:22:01.730]                 for (kk in seq_along(NAMES)) {
[13:22:01.730]                   name <- removed[[kk]]
[13:22:01.730]                   NAME <- NAMES[[kk]]
[13:22:01.730]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:01.730]                     next
[13:22:01.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:01.730]                 }
[13:22:01.730]                 if (length(args) > 0) 
[13:22:01.730]                   base::do.call(base::Sys.setenv, args = args)
[13:22:01.730]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:01.730]             }
[13:22:01.730]             else {
[13:22:01.730]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:01.730]             }
[13:22:01.730]             {
[13:22:01.730]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:01.730]                   0L) {
[13:22:01.730]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:01.730]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:01.730]                   base::options(opts)
[13:22:01.730]                 }
[13:22:01.730]                 {
[13:22:01.730]                   {
[13:22:01.730]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:01.730]                     NULL
[13:22:01.730]                   }
[13:22:01.730]                   options(future.plan = NULL)
[13:22:01.730]                   if (is.na(NA_character_)) 
[13:22:01.730]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:01.730]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:01.730]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:01.730]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:01.730]                     envir = parent.frame()) 
[13:22:01.730]                   {
[13:22:01.730]                     if (is.function(workers)) 
[13:22:01.730]                       workers <- workers()
[13:22:01.730]                     workers <- structure(as.integer(workers), 
[13:22:01.730]                       class = class(workers))
[13:22:01.730]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:01.730]                       workers >= 1)
[13:22:01.730]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:01.730]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:01.730]                     }
[13:22:01.730]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:01.730]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:01.730]                       envir = envir)
[13:22:01.730]                     if (!future$lazy) 
[13:22:01.730]                       future <- run(future)
[13:22:01.730]                     invisible(future)
[13:22:01.730]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:01.730]                 }
[13:22:01.730]             }
[13:22:01.730]         }
[13:22:01.730]     })
[13:22:01.730]     if (TRUE) {
[13:22:01.730]         base::sink(type = "output", split = FALSE)
[13:22:01.730]         if (FALSE) {
[13:22:01.730]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:01.730]         }
[13:22:01.730]         else {
[13:22:01.730]             ...future.result["stdout"] <- base::list(NULL)
[13:22:01.730]         }
[13:22:01.730]         base::close(...future.stdout)
[13:22:01.730]         ...future.stdout <- NULL
[13:22:01.730]     }
[13:22:01.730]     ...future.result$conditions <- ...future.conditions
[13:22:01.730]     ...future.result$finished <- base::Sys.time()
[13:22:01.730]     ...future.result
[13:22:01.730] }
[13:22:01.786] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[13:22:01.786] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[13:22:01.787] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[13:22:01.787] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:22:01.787] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:22:01.788] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[13:22:01.788] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[13:22:01.788] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:22:01.788] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:22:01.789] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:22:01.789] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:22:01.789] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[13:22:01.790] MultisessionFuture started
[13:22:01.790] - Launch lazy future ... done
[13:22:01.790] run() for ‘MultisessionFuture’ ... done
[13:22:01.790] Created future:
[13:22:01.790] MultisessionFuture:
[13:22:01.790] Label: ‘future_lapply-2’
[13:22:01.790] Expression:
[13:22:01.790] {
[13:22:01.790]     do.call(function(...) {
[13:22:01.790]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:01.790]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:22:01.790]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:01.790]             on.exit(options(oopts), add = TRUE)
[13:22:01.790]         }
[13:22:01.790]         {
[13:22:01.790]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:22:01.790]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:22:01.790]                 ...future.FUN(...future.X_jj, ...)
[13:22:01.790]             })
[13:22:01.790]         }
[13:22:01.790]     }, args = future.call.arguments)
[13:22:01.790] }
[13:22:01.790] Lazy evaluation: FALSE
[13:22:01.790] Asynchronous evaluation: TRUE
[13:22:01.790] Local evaluation: TRUE
[13:22:01.790] Environment: R_GlobalEnv
[13:22:01.790] Capture standard output: FALSE
[13:22:01.790] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:22:01.790] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:22:01.790] Packages: <none>
[13:22:01.790] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:22:01.790] Resolved: FALSE
[13:22:01.790] Value: <not collected>
[13:22:01.790] Conditions captured: <none>
[13:22:01.790] Early signaling: FALSE
[13:22:01.790] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:22:01.790] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:01.802] Chunk #2 of 2 ... DONE
[13:22:01.802] Launching 2 futures (chunks) ... DONE
[13:22:01.803] Resolving 2 futures (chunks) ...
[13:22:01.803] resolve() on list ...
[13:22:01.805]  recursive: 0
[13:22:01.805]  length: 2
[13:22:01.805] 
[13:22:01.880] receiveMessageFromWorker() for ClusterFuture ...
[13:22:01.880] - Validating connection of MultisessionFuture
[13:22:01.880] - received message: FutureResult
[13:22:01.880] - Received FutureResult
[13:22:01.880] - Erased future from FutureRegistry
[13:22:01.880] result() for ClusterFuture ...
[13:22:01.881] - result already collected: FutureResult
[13:22:01.881] result() for ClusterFuture ... done
[13:22:01.881] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:01.881] Future #2
[13:22:01.881] result() for ClusterFuture ...
[13:22:01.881] - result already collected: FutureResult
[13:22:01.881] result() for ClusterFuture ... done
[13:22:01.881] result() for ClusterFuture ...
[13:22:01.881] - result already collected: FutureResult
[13:22:01.881] result() for ClusterFuture ... done
[13:22:01.881] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:22:01.882] - nx: 2
[13:22:01.882] - relay: TRUE
[13:22:01.882] - stdout: TRUE
[13:22:01.882] - signal: TRUE
[13:22:01.882] - resignal: FALSE
[13:22:01.882] - force: TRUE
[13:22:01.882] - relayed: [n=2] FALSE, FALSE
[13:22:01.882] - queued futures: [n=2] FALSE, FALSE
[13:22:01.882]  - until=1
[13:22:01.882]  - relaying element #1
[13:22:01.882] - relayed: [n=2] FALSE, FALSE
[13:22:01.882] - queued futures: [n=2] FALSE, TRUE
[13:22:01.883] signalConditionsASAP(NULL, pos=2) ... done
[13:22:01.883]  length: 1 (resolved future 2)
[13:22:02.248] receiveMessageFromWorker() for ClusterFuture ...
[13:22:02.248] - Validating connection of MultisessionFuture
[13:22:02.248] - received message: FutureResult
[13:22:02.248] - Received FutureResult
[13:22:02.248] - Erased future from FutureRegistry
[13:22:02.249] result() for ClusterFuture ...
[13:22:02.249] - result already collected: FutureResult
[13:22:02.249] result() for ClusterFuture ... done
[13:22:02.249] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:02.249] Future #1
[13:22:02.249] result() for ClusterFuture ...
[13:22:02.249] - result already collected: FutureResult
[13:22:02.249] result() for ClusterFuture ... done
[13:22:02.249] result() for ClusterFuture ...
[13:22:02.249] - result already collected: FutureResult
[13:22:02.249] result() for ClusterFuture ... done
[13:22:02.250] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:22:02.250] - nx: 2
[13:22:02.250] - relay: TRUE
[13:22:02.250] - stdout: TRUE
[13:22:02.250] - signal: TRUE
[13:22:02.250] - resignal: FALSE
[13:22:02.250] - force: TRUE
[13:22:02.250] - relayed: [n=2] FALSE, FALSE
[13:22:02.250] - queued futures: [n=2] FALSE, TRUE
[13:22:02.250]  - until=1
[13:22:02.250]  - relaying element #1
[13:22:02.251] result() for ClusterFuture ...
[13:22:02.251] - result already collected: FutureResult
[13:22:02.251] result() for ClusterFuture ... done
[13:22:02.251] result() for ClusterFuture ...
[13:22:02.251] - result already collected: FutureResult
[13:22:02.251] result() for ClusterFuture ... done
[13:22:02.251] result() for ClusterFuture ...
[13:22:02.251] - result already collected: FutureResult
[13:22:02.251] result() for ClusterFuture ... done
[13:22:02.251] result() for ClusterFuture ...
[13:22:02.251] - result already collected: FutureResult
[13:22:02.251] result() for ClusterFuture ... done
[13:22:02.252] - relayed: [n=2] TRUE, FALSE
[13:22:02.252] - queued futures: [n=2] TRUE, TRUE
[13:22:02.252] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:22:02.252]  length: 0 (resolved future 1)
[13:22:02.252] Relaying remaining futures
[13:22:02.252] signalConditionsASAP(NULL, pos=0) ...
[13:22:02.252] - nx: 2
[13:22:02.252] - relay: TRUE
[13:22:02.252] - stdout: TRUE
[13:22:02.252] - signal: TRUE
[13:22:02.252] - resignal: FALSE
[13:22:02.253] - force: TRUE
[13:22:02.253] - relayed: [n=2] TRUE, FALSE
[13:22:02.253] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:22:02.253]  - relaying element #2
[13:22:02.253] result() for ClusterFuture ...
[13:22:02.253] - result already collected: FutureResult
[13:22:02.253] result() for ClusterFuture ... done
[13:22:02.253] result() for ClusterFuture ...
[13:22:02.253] - result already collected: FutureResult
[13:22:02.253] result() for ClusterFuture ... done
[13:22:02.253] result() for ClusterFuture ...
[13:22:02.254] - result already collected: FutureResult
[13:22:02.254] result() for ClusterFuture ... done
[13:22:02.254] result() for ClusterFuture ...
[13:22:02.254] - result already collected: FutureResult
[13:22:02.254] result() for ClusterFuture ... done
[13:22:02.254] - relayed: [n=2] TRUE, TRUE
[13:22:02.254] - queued futures: [n=2] TRUE, TRUE
[13:22:02.254] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[13:22:02.254] resolve() on list ... DONE
[13:22:02.254] result() for ClusterFuture ...
[13:22:02.254] - result already collected: FutureResult
[13:22:02.254] result() for ClusterFuture ... done
[13:22:02.255] result() for ClusterFuture ...
[13:22:02.255] - result already collected: FutureResult
[13:22:02.255] result() for ClusterFuture ... done
[13:22:02.255] result() for ClusterFuture ...
[13:22:02.255] - result already collected: FutureResult
[13:22:02.255] result() for ClusterFuture ... done
[13:22:02.255] result() for ClusterFuture ...
[13:22:02.255] - result already collected: FutureResult
[13:22:02.255] result() for ClusterFuture ... done
[13:22:02.255]  - Number of value chunks collected: 2
[13:22:02.255] Resolving 2 futures (chunks) ... DONE
[13:22:02.256] Reducing values from 2 chunks ...
[13:22:02.256]  - Number of values collected after concatenation: 2
[13:22:02.256]  - Number of values expected: 2
[13:22:02.256] Reducing values from 2 chunks ... DONE
[13:22:02.256] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[13:22:02.256] future_lapply() ...
[13:22:02.261] Number of chunks: 2
[13:22:02.261] getGlobalsAndPackagesXApply() ...
[13:22:02.262]  - future.globals: TRUE
[13:22:02.262] getGlobalsAndPackages() ...
[13:22:02.262] Searching for globals...
[13:22:02.263] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:22:02.264] Searching for globals ... DONE
[13:22:02.264] Resolving globals: FALSE
[13:22:02.264] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:22:02.264] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:22:02.265] - globals: [1] ‘FUN’
[13:22:02.265] 
[13:22:02.265] getGlobalsAndPackages() ... DONE
[13:22:02.265]  - globals found/used: [n=1] ‘FUN’
[13:22:02.265]  - needed namespaces: [n=0] 
[13:22:02.265] Finding globals ... DONE
[13:22:02.265]  - use_args: TRUE
[13:22:02.265]  - Getting '...' globals ...
[13:22:02.266] resolve() on list ...
[13:22:02.266]  recursive: 0
[13:22:02.266]  length: 1
[13:22:02.266]  elements: ‘...’
[13:22:02.266]  length: 0 (resolved future 1)
[13:22:02.266] resolve() on list ... DONE
[13:22:02.266]    - '...' content: [n=0] 
[13:22:02.266] List of 1
[13:22:02.266]  $ ...: list()
[13:22:02.266]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:22:02.266]  - attr(*, "where")=List of 1
[13:22:02.266]   ..$ ...:<environment: 0x55dd73c98f68> 
[13:22:02.266]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:22:02.266]  - attr(*, "resolved")= logi TRUE
[13:22:02.266]  - attr(*, "total_size")= num NA
[13:22:02.269]  - Getting '...' globals ... DONE
[13:22:02.269] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:22:02.269] List of 2
[13:22:02.269]  $ ...future.FUN:function (x)  
[13:22:02.269]  $ ...          : list()
[13:22:02.269]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:22:02.269]  - attr(*, "where")=List of 2
[13:22:02.269]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:22:02.269]   ..$ ...          :<environment: 0x55dd73c98f68> 
[13:22:02.269]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:22:02.269]  - attr(*, "resolved")= logi FALSE
[13:22:02.269]  - attr(*, "total_size")= num 4720
[13:22:02.272] Packages to be attached in all futures: [n=0] 
[13:22:02.272] getGlobalsAndPackagesXApply() ... DONE
[13:22:02.272] Number of futures (= number of chunks): 2
[13:22:02.272] Launching 2 futures (chunks) ...
[13:22:02.272] Chunk #1 of 2 ...
[13:22:02.272]  - Finding globals in 'X' for chunk #1 ...
[13:22:02.273] getGlobalsAndPackages() ...
[13:22:02.273] Searching for globals...
[13:22:02.273] 
[13:22:02.273] Searching for globals ... DONE
[13:22:02.273] - globals: [0] <none>
[13:22:02.273] getGlobalsAndPackages() ... DONE
[13:22:02.273]    + additional globals found: [n=0] 
[13:22:02.273]    + additional namespaces needed: [n=0] 
[13:22:02.273]  - Finding globals in 'X' for chunk #1 ... DONE
[13:22:02.274]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:22:02.274]  - seeds: <none>
[13:22:02.274]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:02.274] getGlobalsAndPackages() ...
[13:22:02.274] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:02.274] Resolving globals: FALSE
[13:22:02.274] Tweak future expression to call with '...' arguments ...
[13:22:02.274] {
[13:22:02.274]     do.call(function(...) {
[13:22:02.274]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:02.274]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:22:02.274]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:02.274]             on.exit(options(oopts), add = TRUE)
[13:22:02.274]         }
[13:22:02.274]         {
[13:22:02.274]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:22:02.274]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:22:02.274]                 ...future.FUN(...future.X_jj, ...)
[13:22:02.274]             })
[13:22:02.274]         }
[13:22:02.274]     }, args = future.call.arguments)
[13:22:02.274] }
[13:22:02.275] Tweak future expression to call with '...' arguments ... DONE
[13:22:02.275] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:02.275] 
[13:22:02.275] getGlobalsAndPackages() ... DONE
[13:22:02.275] run() for ‘Future’ ...
[13:22:02.276] - state: ‘created’
[13:22:02.276] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:02.290] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:02.290] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:02.290]   - Field: ‘node’
[13:22:02.291]   - Field: ‘label’
[13:22:02.291]   - Field: ‘local’
[13:22:02.291]   - Field: ‘owner’
[13:22:02.291]   - Field: ‘envir’
[13:22:02.291]   - Field: ‘workers’
[13:22:02.291]   - Field: ‘packages’
[13:22:02.291]   - Field: ‘gc’
[13:22:02.291]   - Field: ‘conditions’
[13:22:02.291]   - Field: ‘persistent’
[13:22:02.291]   - Field: ‘expr’
[13:22:02.292]   - Field: ‘uuid’
[13:22:02.292]   - Field: ‘seed’
[13:22:02.292]   - Field: ‘version’
[13:22:02.292]   - Field: ‘result’
[13:22:02.292]   - Field: ‘asynchronous’
[13:22:02.292]   - Field: ‘calls’
[13:22:02.292]   - Field: ‘globals’
[13:22:02.292]   - Field: ‘stdout’
[13:22:02.292]   - Field: ‘earlySignal’
[13:22:02.292]   - Field: ‘lazy’
[13:22:02.293]   - Field: ‘state’
[13:22:02.293] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:02.293] - Launch lazy future ...
[13:22:02.293] Packages needed by the future expression (n = 0): <none>
[13:22:02.293] Packages needed by future strategies (n = 0): <none>
[13:22:02.294] {
[13:22:02.294]     {
[13:22:02.294]         {
[13:22:02.294]             ...future.startTime <- base::Sys.time()
[13:22:02.294]             {
[13:22:02.294]                 {
[13:22:02.294]                   {
[13:22:02.294]                     {
[13:22:02.294]                       base::local({
[13:22:02.294]                         has_future <- base::requireNamespace("future", 
[13:22:02.294]                           quietly = TRUE)
[13:22:02.294]                         if (has_future) {
[13:22:02.294]                           ns <- base::getNamespace("future")
[13:22:02.294]                           version <- ns[[".package"]][["version"]]
[13:22:02.294]                           if (is.null(version)) 
[13:22:02.294]                             version <- utils::packageVersion("future")
[13:22:02.294]                         }
[13:22:02.294]                         else {
[13:22:02.294]                           version <- NULL
[13:22:02.294]                         }
[13:22:02.294]                         if (!has_future || version < "1.8.0") {
[13:22:02.294]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:02.294]                             "", base::R.version$version.string), 
[13:22:02.294]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:02.294]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:02.294]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:02.294]                               "release", "version")], collapse = " "), 
[13:22:02.294]                             hostname = base::Sys.info()[["nodename"]])
[13:22:02.294]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:02.294]                             info)
[13:22:02.294]                           info <- base::paste(info, collapse = "; ")
[13:22:02.294]                           if (!has_future) {
[13:22:02.294]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:02.294]                               info)
[13:22:02.294]                           }
[13:22:02.294]                           else {
[13:22:02.294]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:02.294]                               info, version)
[13:22:02.294]                           }
[13:22:02.294]                           base::stop(msg)
[13:22:02.294]                         }
[13:22:02.294]                       })
[13:22:02.294]                     }
[13:22:02.294]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:02.294]                     base::options(mc.cores = 1L)
[13:22:02.294]                   }
[13:22:02.294]                   options(future.plan = NULL)
[13:22:02.294]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:02.294]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:02.294]                 }
[13:22:02.294]                 ...future.workdir <- getwd()
[13:22:02.294]             }
[13:22:02.294]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:02.294]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:02.294]         }
[13:22:02.294]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:02.294]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:22:02.294]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:02.294]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:02.294]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:02.294]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:02.294]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:02.294]             base::names(...future.oldOptions))
[13:22:02.294]     }
[13:22:02.294]     if (FALSE) {
[13:22:02.294]     }
[13:22:02.294]     else {
[13:22:02.294]         if (TRUE) {
[13:22:02.294]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:02.294]                 open = "w")
[13:22:02.294]         }
[13:22:02.294]         else {
[13:22:02.294]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:02.294]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:02.294]         }
[13:22:02.294]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:02.294]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:02.294]             base::sink(type = "output", split = FALSE)
[13:22:02.294]             base::close(...future.stdout)
[13:22:02.294]         }, add = TRUE)
[13:22:02.294]     }
[13:22:02.294]     ...future.frame <- base::sys.nframe()
[13:22:02.294]     ...future.conditions <- base::list()
[13:22:02.294]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:02.294]     if (FALSE) {
[13:22:02.294]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:02.294]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:02.294]     }
[13:22:02.294]     ...future.result <- base::tryCatch({
[13:22:02.294]         base::withCallingHandlers({
[13:22:02.294]             ...future.value <- base::withVisible(base::local({
[13:22:02.294]                 ...future.makeSendCondition <- base::local({
[13:22:02.294]                   sendCondition <- NULL
[13:22:02.294]                   function(frame = 1L) {
[13:22:02.294]                     if (is.function(sendCondition)) 
[13:22:02.294]                       return(sendCondition)
[13:22:02.294]                     ns <- getNamespace("parallel")
[13:22:02.294]                     if (exists("sendData", mode = "function", 
[13:22:02.294]                       envir = ns)) {
[13:22:02.294]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:02.294]                         envir = ns)
[13:22:02.294]                       envir <- sys.frame(frame)
[13:22:02.294]                       master <- NULL
[13:22:02.294]                       while (!identical(envir, .GlobalEnv) && 
[13:22:02.294]                         !identical(envir, emptyenv())) {
[13:22:02.294]                         if (exists("master", mode = "list", envir = envir, 
[13:22:02.294]                           inherits = FALSE)) {
[13:22:02.294]                           master <- get("master", mode = "list", 
[13:22:02.294]                             envir = envir, inherits = FALSE)
[13:22:02.294]                           if (inherits(master, c("SOCKnode", 
[13:22:02.294]                             "SOCK0node"))) {
[13:22:02.294]                             sendCondition <<- function(cond) {
[13:22:02.294]                               data <- list(type = "VALUE", value = cond, 
[13:22:02.294]                                 success = TRUE)
[13:22:02.294]                               parallel_sendData(master, data)
[13:22:02.294]                             }
[13:22:02.294]                             return(sendCondition)
[13:22:02.294]                           }
[13:22:02.294]                         }
[13:22:02.294]                         frame <- frame + 1L
[13:22:02.294]                         envir <- sys.frame(frame)
[13:22:02.294]                       }
[13:22:02.294]                     }
[13:22:02.294]                     sendCondition <<- function(cond) NULL
[13:22:02.294]                   }
[13:22:02.294]                 })
[13:22:02.294]                 withCallingHandlers({
[13:22:02.294]                   {
[13:22:02.294]                     do.call(function(...) {
[13:22:02.294]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:02.294]                       if (!identical(...future.globals.maxSize.org, 
[13:22:02.294]                         ...future.globals.maxSize)) {
[13:22:02.294]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:02.294]                         on.exit(options(oopts), add = TRUE)
[13:22:02.294]                       }
[13:22:02.294]                       {
[13:22:02.294]                         lapply(seq_along(...future.elements_ii), 
[13:22:02.294]                           FUN = function(jj) {
[13:22:02.294]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:22:02.294]                             ...future.FUN(...future.X_jj, ...)
[13:22:02.294]                           })
[13:22:02.294]                       }
[13:22:02.294]                     }, args = future.call.arguments)
[13:22:02.294]                   }
[13:22:02.294]                 }, immediateCondition = function(cond) {
[13:22:02.294]                   sendCondition <- ...future.makeSendCondition()
[13:22:02.294]                   sendCondition(cond)
[13:22:02.294]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:02.294]                   {
[13:22:02.294]                     inherits <- base::inherits
[13:22:02.294]                     invokeRestart <- base::invokeRestart
[13:22:02.294]                     is.null <- base::is.null
[13:22:02.294]                     muffled <- FALSE
[13:22:02.294]                     if (inherits(cond, "message")) {
[13:22:02.294]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:02.294]                       if (muffled) 
[13:22:02.294]                         invokeRestart("muffleMessage")
[13:22:02.294]                     }
[13:22:02.294]                     else if (inherits(cond, "warning")) {
[13:22:02.294]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:02.294]                       if (muffled) 
[13:22:02.294]                         invokeRestart("muffleWarning")
[13:22:02.294]                     }
[13:22:02.294]                     else if (inherits(cond, "condition")) {
[13:22:02.294]                       if (!is.null(pattern)) {
[13:22:02.294]                         computeRestarts <- base::computeRestarts
[13:22:02.294]                         grepl <- base::grepl
[13:22:02.294]                         restarts <- computeRestarts(cond)
[13:22:02.294]                         for (restart in restarts) {
[13:22:02.294]                           name <- restart$name
[13:22:02.294]                           if (is.null(name)) 
[13:22:02.294]                             next
[13:22:02.294]                           if (!grepl(pattern, name)) 
[13:22:02.294]                             next
[13:22:02.294]                           invokeRestart(restart)
[13:22:02.294]                           muffled <- TRUE
[13:22:02.294]                           break
[13:22:02.294]                         }
[13:22:02.294]                       }
[13:22:02.294]                     }
[13:22:02.294]                     invisible(muffled)
[13:22:02.294]                   }
[13:22:02.294]                   muffleCondition(cond)
[13:22:02.294]                 })
[13:22:02.294]             }))
[13:22:02.294]             future::FutureResult(value = ...future.value$value, 
[13:22:02.294]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:02.294]                   ...future.rng), globalenv = if (FALSE) 
[13:22:02.294]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:02.294]                     ...future.globalenv.names))
[13:22:02.294]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:02.294]         }, condition = base::local({
[13:22:02.294]             c <- base::c
[13:22:02.294]             inherits <- base::inherits
[13:22:02.294]             invokeRestart <- base::invokeRestart
[13:22:02.294]             length <- base::length
[13:22:02.294]             list <- base::list
[13:22:02.294]             seq.int <- base::seq.int
[13:22:02.294]             signalCondition <- base::signalCondition
[13:22:02.294]             sys.calls <- base::sys.calls
[13:22:02.294]             `[[` <- base::`[[`
[13:22:02.294]             `+` <- base::`+`
[13:22:02.294]             `<<-` <- base::`<<-`
[13:22:02.294]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:02.294]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:02.294]                   3L)]
[13:22:02.294]             }
[13:22:02.294]             function(cond) {
[13:22:02.294]                 is_error <- inherits(cond, "error")
[13:22:02.294]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:02.294]                   NULL)
[13:22:02.294]                 if (is_error) {
[13:22:02.294]                   sessionInformation <- function() {
[13:22:02.294]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:02.294]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:02.294]                       search = base::search(), system = base::Sys.info())
[13:22:02.294]                   }
[13:22:02.294]                   ...future.conditions[[length(...future.conditions) + 
[13:22:02.294]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:02.294]                     cond$call), session = sessionInformation(), 
[13:22:02.294]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:02.294]                   signalCondition(cond)
[13:22:02.294]                 }
[13:22:02.294]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:02.294]                 "immediateCondition"))) {
[13:22:02.294]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:02.294]                   ...future.conditions[[length(...future.conditions) + 
[13:22:02.294]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:02.294]                   if (TRUE && !signal) {
[13:22:02.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:02.294]                     {
[13:22:02.294]                       inherits <- base::inherits
[13:22:02.294]                       invokeRestart <- base::invokeRestart
[13:22:02.294]                       is.null <- base::is.null
[13:22:02.294]                       muffled <- FALSE
[13:22:02.294]                       if (inherits(cond, "message")) {
[13:22:02.294]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:02.294]                         if (muffled) 
[13:22:02.294]                           invokeRestart("muffleMessage")
[13:22:02.294]                       }
[13:22:02.294]                       else if (inherits(cond, "warning")) {
[13:22:02.294]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:02.294]                         if (muffled) 
[13:22:02.294]                           invokeRestart("muffleWarning")
[13:22:02.294]                       }
[13:22:02.294]                       else if (inherits(cond, "condition")) {
[13:22:02.294]                         if (!is.null(pattern)) {
[13:22:02.294]                           computeRestarts <- base::computeRestarts
[13:22:02.294]                           grepl <- base::grepl
[13:22:02.294]                           restarts <- computeRestarts(cond)
[13:22:02.294]                           for (restart in restarts) {
[13:22:02.294]                             name <- restart$name
[13:22:02.294]                             if (is.null(name)) 
[13:22:02.294]                               next
[13:22:02.294]                             if (!grepl(pattern, name)) 
[13:22:02.294]                               next
[13:22:02.294]                             invokeRestart(restart)
[13:22:02.294]                             muffled <- TRUE
[13:22:02.294]                             break
[13:22:02.294]                           }
[13:22:02.294]                         }
[13:22:02.294]                       }
[13:22:02.294]                       invisible(muffled)
[13:22:02.294]                     }
[13:22:02.294]                     muffleCondition(cond, pattern = "^muffle")
[13:22:02.294]                   }
[13:22:02.294]                 }
[13:22:02.294]                 else {
[13:22:02.294]                   if (TRUE) {
[13:22:02.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:02.294]                     {
[13:22:02.294]                       inherits <- base::inherits
[13:22:02.294]                       invokeRestart <- base::invokeRestart
[13:22:02.294]                       is.null <- base::is.null
[13:22:02.294]                       muffled <- FALSE
[13:22:02.294]                       if (inherits(cond, "message")) {
[13:22:02.294]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:02.294]                         if (muffled) 
[13:22:02.294]                           invokeRestart("muffleMessage")
[13:22:02.294]                       }
[13:22:02.294]                       else if (inherits(cond, "warning")) {
[13:22:02.294]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:02.294]                         if (muffled) 
[13:22:02.294]                           invokeRestart("muffleWarning")
[13:22:02.294]                       }
[13:22:02.294]                       else if (inherits(cond, "condition")) {
[13:22:02.294]                         if (!is.null(pattern)) {
[13:22:02.294]                           computeRestarts <- base::computeRestarts
[13:22:02.294]                           grepl <- base::grepl
[13:22:02.294]                           restarts <- computeRestarts(cond)
[13:22:02.294]                           for (restart in restarts) {
[13:22:02.294]                             name <- restart$name
[13:22:02.294]                             if (is.null(name)) 
[13:22:02.294]                               next
[13:22:02.294]                             if (!grepl(pattern, name)) 
[13:22:02.294]                               next
[13:22:02.294]                             invokeRestart(restart)
[13:22:02.294]                             muffled <- TRUE
[13:22:02.294]                             break
[13:22:02.294]                           }
[13:22:02.294]                         }
[13:22:02.294]                       }
[13:22:02.294]                       invisible(muffled)
[13:22:02.294]                     }
[13:22:02.294]                     muffleCondition(cond, pattern = "^muffle")
[13:22:02.294]                   }
[13:22:02.294]                 }
[13:22:02.294]             }
[13:22:02.294]         }))
[13:22:02.294]     }, error = function(ex) {
[13:22:02.294]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:02.294]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:02.294]                 ...future.rng), started = ...future.startTime, 
[13:22:02.294]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:02.294]             version = "1.8"), class = "FutureResult")
[13:22:02.294]     }, finally = {
[13:22:02.294]         if (!identical(...future.workdir, getwd())) 
[13:22:02.294]             setwd(...future.workdir)
[13:22:02.294]         {
[13:22:02.294]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:02.294]                 ...future.oldOptions$nwarnings <- NULL
[13:22:02.294]             }
[13:22:02.294]             base::options(...future.oldOptions)
[13:22:02.294]             if (.Platform$OS.type == "windows") {
[13:22:02.294]                 old_names <- names(...future.oldEnvVars)
[13:22:02.294]                 envs <- base::Sys.getenv()
[13:22:02.294]                 names <- names(envs)
[13:22:02.294]                 common <- intersect(names, old_names)
[13:22:02.294]                 added <- setdiff(names, old_names)
[13:22:02.294]                 removed <- setdiff(old_names, names)
[13:22:02.294]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:02.294]                   envs[common]]
[13:22:02.294]                 NAMES <- toupper(changed)
[13:22:02.294]                 args <- list()
[13:22:02.294]                 for (kk in seq_along(NAMES)) {
[13:22:02.294]                   name <- changed[[kk]]
[13:22:02.294]                   NAME <- NAMES[[kk]]
[13:22:02.294]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:02.294]                     next
[13:22:02.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:02.294]                 }
[13:22:02.294]                 NAMES <- toupper(added)
[13:22:02.294]                 for (kk in seq_along(NAMES)) {
[13:22:02.294]                   name <- added[[kk]]
[13:22:02.294]                   NAME <- NAMES[[kk]]
[13:22:02.294]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:02.294]                     next
[13:22:02.294]                   args[[name]] <- ""
[13:22:02.294]                 }
[13:22:02.294]                 NAMES <- toupper(removed)
[13:22:02.294]                 for (kk in seq_along(NAMES)) {
[13:22:02.294]                   name <- removed[[kk]]
[13:22:02.294]                   NAME <- NAMES[[kk]]
[13:22:02.294]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:02.294]                     next
[13:22:02.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:02.294]                 }
[13:22:02.294]                 if (length(args) > 0) 
[13:22:02.294]                   base::do.call(base::Sys.setenv, args = args)
[13:22:02.294]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:02.294]             }
[13:22:02.294]             else {
[13:22:02.294]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:02.294]             }
[13:22:02.294]             {
[13:22:02.294]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:02.294]                   0L) {
[13:22:02.294]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:02.294]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:02.294]                   base::options(opts)
[13:22:02.294]                 }
[13:22:02.294]                 {
[13:22:02.294]                   {
[13:22:02.294]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:02.294]                     NULL
[13:22:02.294]                   }
[13:22:02.294]                   options(future.plan = NULL)
[13:22:02.294]                   if (is.na(NA_character_)) 
[13:22:02.294]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:02.294]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:02.294]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:02.294]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:02.294]                     envir = parent.frame()) 
[13:22:02.294]                   {
[13:22:02.294]                     if (is.function(workers)) 
[13:22:02.294]                       workers <- workers()
[13:22:02.294]                     workers <- structure(as.integer(workers), 
[13:22:02.294]                       class = class(workers))
[13:22:02.294]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:02.294]                       workers >= 1)
[13:22:02.294]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:02.294]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:02.294]                     }
[13:22:02.294]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:02.294]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:02.294]                       envir = envir)
[13:22:02.294]                     if (!future$lazy) 
[13:22:02.294]                       future <- run(future)
[13:22:02.294]                     invisible(future)
[13:22:02.294]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:02.294]                 }
[13:22:02.294]             }
[13:22:02.294]         }
[13:22:02.294]     })
[13:22:02.294]     if (TRUE) {
[13:22:02.294]         base::sink(type = "output", split = FALSE)
[13:22:02.294]         if (TRUE) {
[13:22:02.294]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:02.294]         }
[13:22:02.294]         else {
[13:22:02.294]             ...future.result["stdout"] <- base::list(NULL)
[13:22:02.294]         }
[13:22:02.294]         base::close(...future.stdout)
[13:22:02.294]         ...future.stdout <- NULL
[13:22:02.294]     }
[13:22:02.294]     ...future.result$conditions <- ...future.conditions
[13:22:02.294]     ...future.result$finished <- base::Sys.time()
[13:22:02.294]     ...future.result
[13:22:02.294] }
[13:22:02.297] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[13:22:02.297] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[13:22:02.297] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[13:22:02.297] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:22:02.298] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:22:02.298] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[13:22:02.298] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[13:22:02.298] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:22:02.298] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:22:02.299] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:22:02.299] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:22:02.299] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[13:22:02.300] MultisessionFuture started
[13:22:02.300] - Launch lazy future ... done
[13:22:02.300] run() for ‘MultisessionFuture’ ... done
[13:22:02.300] Created future:
[13:22:02.300] MultisessionFuture:
[13:22:02.300] Label: ‘future_lapply-1’
[13:22:02.300] Expression:
[13:22:02.300] {
[13:22:02.300]     do.call(function(...) {
[13:22:02.300]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:02.300]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:22:02.300]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:02.300]             on.exit(options(oopts), add = TRUE)
[13:22:02.300]         }
[13:22:02.300]         {
[13:22:02.300]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:22:02.300]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:22:02.300]                 ...future.FUN(...future.X_jj, ...)
[13:22:02.300]             })
[13:22:02.300]         }
[13:22:02.300]     }, args = future.call.arguments)
[13:22:02.300] }
[13:22:02.300] Lazy evaluation: FALSE
[13:22:02.300] Asynchronous evaluation: TRUE
[13:22:02.300] Local evaluation: TRUE
[13:22:02.300] Environment: R_GlobalEnv
[13:22:02.300] Capture standard output: TRUE
[13:22:02.300] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:22:02.300] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:22:02.300] Packages: <none>
[13:22:02.300] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:22:02.300] Resolved: FALSE
[13:22:02.300] Value: <not collected>
[13:22:02.300] Conditions captured: <none>
[13:22:02.300] Early signaling: FALSE
[13:22:02.300] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:22:02.300] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:02.312] Chunk #1 of 2 ... DONE
[13:22:02.312] Chunk #2 of 2 ...
[13:22:02.312]  - Finding globals in 'X' for chunk #2 ...
[13:22:02.312] getGlobalsAndPackages() ...
[13:22:02.312] Searching for globals...
[13:22:02.312] 
[13:22:02.313] Searching for globals ... DONE
[13:22:02.313] - globals: [0] <none>
[13:22:02.313] getGlobalsAndPackages() ... DONE
[13:22:02.313]    + additional globals found: [n=0] 
[13:22:02.313]    + additional namespaces needed: [n=0] 
[13:22:02.313]  - Finding globals in 'X' for chunk #2 ... DONE
[13:22:02.313]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:22:02.313]  - seeds: <none>
[13:22:02.313]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:02.313] getGlobalsAndPackages() ...
[13:22:02.314] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:02.314] Resolving globals: FALSE
[13:22:02.314] Tweak future expression to call with '...' arguments ...
[13:22:02.314] {
[13:22:02.314]     do.call(function(...) {
[13:22:02.314]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:02.314]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:22:02.314]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:02.314]             on.exit(options(oopts), add = TRUE)
[13:22:02.314]         }
[13:22:02.314]         {
[13:22:02.314]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:22:02.314]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:22:02.314]                 ...future.FUN(...future.X_jj, ...)
[13:22:02.314]             })
[13:22:02.314]         }
[13:22:02.314]     }, args = future.call.arguments)
[13:22:02.314] }
[13:22:02.314] Tweak future expression to call with '...' arguments ... DONE
[13:22:02.315] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:02.315] 
[13:22:02.315] getGlobalsAndPackages() ... DONE
[13:22:02.315] run() for ‘Future’ ...
[13:22:02.315] - state: ‘created’
[13:22:02.315] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:02.330] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:02.330] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:02.330]   - Field: ‘node’
[13:22:02.330]   - Field: ‘label’
[13:22:02.330]   - Field: ‘local’
[13:22:02.330]   - Field: ‘owner’
[13:22:02.330]   - Field: ‘envir’
[13:22:02.330]   - Field: ‘workers’
[13:22:02.331]   - Field: ‘packages’
[13:22:02.331]   - Field: ‘gc’
[13:22:02.331]   - Field: ‘conditions’
[13:22:02.331]   - Field: ‘persistent’
[13:22:02.331]   - Field: ‘expr’
[13:22:02.331]   - Field: ‘uuid’
[13:22:02.331]   - Field: ‘seed’
[13:22:02.331]   - Field: ‘version’
[13:22:02.331]   - Field: ‘result’
[13:22:02.331]   - Field: ‘asynchronous’
[13:22:02.332]   - Field: ‘calls’
[13:22:02.332]   - Field: ‘globals’
[13:22:02.332]   - Field: ‘stdout’
[13:22:02.332]   - Field: ‘earlySignal’
[13:22:02.332]   - Field: ‘lazy’
[13:22:02.332]   - Field: ‘state’
[13:22:02.332] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:02.332] - Launch lazy future ...
[13:22:02.333] Packages needed by the future expression (n = 0): <none>
[13:22:02.333] Packages needed by future strategies (n = 0): <none>
[13:22:02.333] {
[13:22:02.333]     {
[13:22:02.333]         {
[13:22:02.333]             ...future.startTime <- base::Sys.time()
[13:22:02.333]             {
[13:22:02.333]                 {
[13:22:02.333]                   {
[13:22:02.333]                     {
[13:22:02.333]                       base::local({
[13:22:02.333]                         has_future <- base::requireNamespace("future", 
[13:22:02.333]                           quietly = TRUE)
[13:22:02.333]                         if (has_future) {
[13:22:02.333]                           ns <- base::getNamespace("future")
[13:22:02.333]                           version <- ns[[".package"]][["version"]]
[13:22:02.333]                           if (is.null(version)) 
[13:22:02.333]                             version <- utils::packageVersion("future")
[13:22:02.333]                         }
[13:22:02.333]                         else {
[13:22:02.333]                           version <- NULL
[13:22:02.333]                         }
[13:22:02.333]                         if (!has_future || version < "1.8.0") {
[13:22:02.333]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:02.333]                             "", base::R.version$version.string), 
[13:22:02.333]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:02.333]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:02.333]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:02.333]                               "release", "version")], collapse = " "), 
[13:22:02.333]                             hostname = base::Sys.info()[["nodename"]])
[13:22:02.333]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:02.333]                             info)
[13:22:02.333]                           info <- base::paste(info, collapse = "; ")
[13:22:02.333]                           if (!has_future) {
[13:22:02.333]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:02.333]                               info)
[13:22:02.333]                           }
[13:22:02.333]                           else {
[13:22:02.333]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:02.333]                               info, version)
[13:22:02.333]                           }
[13:22:02.333]                           base::stop(msg)
[13:22:02.333]                         }
[13:22:02.333]                       })
[13:22:02.333]                     }
[13:22:02.333]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:02.333]                     base::options(mc.cores = 1L)
[13:22:02.333]                   }
[13:22:02.333]                   options(future.plan = NULL)
[13:22:02.333]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:02.333]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:02.333]                 }
[13:22:02.333]                 ...future.workdir <- getwd()
[13:22:02.333]             }
[13:22:02.333]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:02.333]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:02.333]         }
[13:22:02.333]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:02.333]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:22:02.333]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:02.333]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:02.333]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:02.333]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:02.333]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:02.333]             base::names(...future.oldOptions))
[13:22:02.333]     }
[13:22:02.333]     if (FALSE) {
[13:22:02.333]     }
[13:22:02.333]     else {
[13:22:02.333]         if (TRUE) {
[13:22:02.333]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:02.333]                 open = "w")
[13:22:02.333]         }
[13:22:02.333]         else {
[13:22:02.333]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:02.333]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:02.333]         }
[13:22:02.333]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:02.333]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:02.333]             base::sink(type = "output", split = FALSE)
[13:22:02.333]             base::close(...future.stdout)
[13:22:02.333]         }, add = TRUE)
[13:22:02.333]     }
[13:22:02.333]     ...future.frame <- base::sys.nframe()
[13:22:02.333]     ...future.conditions <- base::list()
[13:22:02.333]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:02.333]     if (FALSE) {
[13:22:02.333]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:02.333]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:02.333]     }
[13:22:02.333]     ...future.result <- base::tryCatch({
[13:22:02.333]         base::withCallingHandlers({
[13:22:02.333]             ...future.value <- base::withVisible(base::local({
[13:22:02.333]                 ...future.makeSendCondition <- base::local({
[13:22:02.333]                   sendCondition <- NULL
[13:22:02.333]                   function(frame = 1L) {
[13:22:02.333]                     if (is.function(sendCondition)) 
[13:22:02.333]                       return(sendCondition)
[13:22:02.333]                     ns <- getNamespace("parallel")
[13:22:02.333]                     if (exists("sendData", mode = "function", 
[13:22:02.333]                       envir = ns)) {
[13:22:02.333]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:02.333]                         envir = ns)
[13:22:02.333]                       envir <- sys.frame(frame)
[13:22:02.333]                       master <- NULL
[13:22:02.333]                       while (!identical(envir, .GlobalEnv) && 
[13:22:02.333]                         !identical(envir, emptyenv())) {
[13:22:02.333]                         if (exists("master", mode = "list", envir = envir, 
[13:22:02.333]                           inherits = FALSE)) {
[13:22:02.333]                           master <- get("master", mode = "list", 
[13:22:02.333]                             envir = envir, inherits = FALSE)
[13:22:02.333]                           if (inherits(master, c("SOCKnode", 
[13:22:02.333]                             "SOCK0node"))) {
[13:22:02.333]                             sendCondition <<- function(cond) {
[13:22:02.333]                               data <- list(type = "VALUE", value = cond, 
[13:22:02.333]                                 success = TRUE)
[13:22:02.333]                               parallel_sendData(master, data)
[13:22:02.333]                             }
[13:22:02.333]                             return(sendCondition)
[13:22:02.333]                           }
[13:22:02.333]                         }
[13:22:02.333]                         frame <- frame + 1L
[13:22:02.333]                         envir <- sys.frame(frame)
[13:22:02.333]                       }
[13:22:02.333]                     }
[13:22:02.333]                     sendCondition <<- function(cond) NULL
[13:22:02.333]                   }
[13:22:02.333]                 })
[13:22:02.333]                 withCallingHandlers({
[13:22:02.333]                   {
[13:22:02.333]                     do.call(function(...) {
[13:22:02.333]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:02.333]                       if (!identical(...future.globals.maxSize.org, 
[13:22:02.333]                         ...future.globals.maxSize)) {
[13:22:02.333]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:02.333]                         on.exit(options(oopts), add = TRUE)
[13:22:02.333]                       }
[13:22:02.333]                       {
[13:22:02.333]                         lapply(seq_along(...future.elements_ii), 
[13:22:02.333]                           FUN = function(jj) {
[13:22:02.333]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:22:02.333]                             ...future.FUN(...future.X_jj, ...)
[13:22:02.333]                           })
[13:22:02.333]                       }
[13:22:02.333]                     }, args = future.call.arguments)
[13:22:02.333]                   }
[13:22:02.333]                 }, immediateCondition = function(cond) {
[13:22:02.333]                   sendCondition <- ...future.makeSendCondition()
[13:22:02.333]                   sendCondition(cond)
[13:22:02.333]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:02.333]                   {
[13:22:02.333]                     inherits <- base::inherits
[13:22:02.333]                     invokeRestart <- base::invokeRestart
[13:22:02.333]                     is.null <- base::is.null
[13:22:02.333]                     muffled <- FALSE
[13:22:02.333]                     if (inherits(cond, "message")) {
[13:22:02.333]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:02.333]                       if (muffled) 
[13:22:02.333]                         invokeRestart("muffleMessage")
[13:22:02.333]                     }
[13:22:02.333]                     else if (inherits(cond, "warning")) {
[13:22:02.333]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:02.333]                       if (muffled) 
[13:22:02.333]                         invokeRestart("muffleWarning")
[13:22:02.333]                     }
[13:22:02.333]                     else if (inherits(cond, "condition")) {
[13:22:02.333]                       if (!is.null(pattern)) {
[13:22:02.333]                         computeRestarts <- base::computeRestarts
[13:22:02.333]                         grepl <- base::grepl
[13:22:02.333]                         restarts <- computeRestarts(cond)
[13:22:02.333]                         for (restart in restarts) {
[13:22:02.333]                           name <- restart$name
[13:22:02.333]                           if (is.null(name)) 
[13:22:02.333]                             next
[13:22:02.333]                           if (!grepl(pattern, name)) 
[13:22:02.333]                             next
[13:22:02.333]                           invokeRestart(restart)
[13:22:02.333]                           muffled <- TRUE
[13:22:02.333]                           break
[13:22:02.333]                         }
[13:22:02.333]                       }
[13:22:02.333]                     }
[13:22:02.333]                     invisible(muffled)
[13:22:02.333]                   }
[13:22:02.333]                   muffleCondition(cond)
[13:22:02.333]                 })
[13:22:02.333]             }))
[13:22:02.333]             future::FutureResult(value = ...future.value$value, 
[13:22:02.333]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:02.333]                   ...future.rng), globalenv = if (FALSE) 
[13:22:02.333]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:02.333]                     ...future.globalenv.names))
[13:22:02.333]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:02.333]         }, condition = base::local({
[13:22:02.333]             c <- base::c
[13:22:02.333]             inherits <- base::inherits
[13:22:02.333]             invokeRestart <- base::invokeRestart
[13:22:02.333]             length <- base::length
[13:22:02.333]             list <- base::list
[13:22:02.333]             seq.int <- base::seq.int
[13:22:02.333]             signalCondition <- base::signalCondition
[13:22:02.333]             sys.calls <- base::sys.calls
[13:22:02.333]             `[[` <- base::`[[`
[13:22:02.333]             `+` <- base::`+`
[13:22:02.333]             `<<-` <- base::`<<-`
[13:22:02.333]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:02.333]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:02.333]                   3L)]
[13:22:02.333]             }
[13:22:02.333]             function(cond) {
[13:22:02.333]                 is_error <- inherits(cond, "error")
[13:22:02.333]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:02.333]                   NULL)
[13:22:02.333]                 if (is_error) {
[13:22:02.333]                   sessionInformation <- function() {
[13:22:02.333]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:02.333]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:02.333]                       search = base::search(), system = base::Sys.info())
[13:22:02.333]                   }
[13:22:02.333]                   ...future.conditions[[length(...future.conditions) + 
[13:22:02.333]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:02.333]                     cond$call), session = sessionInformation(), 
[13:22:02.333]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:02.333]                   signalCondition(cond)
[13:22:02.333]                 }
[13:22:02.333]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:02.333]                 "immediateCondition"))) {
[13:22:02.333]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:02.333]                   ...future.conditions[[length(...future.conditions) + 
[13:22:02.333]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:02.333]                   if (TRUE && !signal) {
[13:22:02.333]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:02.333]                     {
[13:22:02.333]                       inherits <- base::inherits
[13:22:02.333]                       invokeRestart <- base::invokeRestart
[13:22:02.333]                       is.null <- base::is.null
[13:22:02.333]                       muffled <- FALSE
[13:22:02.333]                       if (inherits(cond, "message")) {
[13:22:02.333]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:02.333]                         if (muffled) 
[13:22:02.333]                           invokeRestart("muffleMessage")
[13:22:02.333]                       }
[13:22:02.333]                       else if (inherits(cond, "warning")) {
[13:22:02.333]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:02.333]                         if (muffled) 
[13:22:02.333]                           invokeRestart("muffleWarning")
[13:22:02.333]                       }
[13:22:02.333]                       else if (inherits(cond, "condition")) {
[13:22:02.333]                         if (!is.null(pattern)) {
[13:22:02.333]                           computeRestarts <- base::computeRestarts
[13:22:02.333]                           grepl <- base::grepl
[13:22:02.333]                           restarts <- computeRestarts(cond)
[13:22:02.333]                           for (restart in restarts) {
[13:22:02.333]                             name <- restart$name
[13:22:02.333]                             if (is.null(name)) 
[13:22:02.333]                               next
[13:22:02.333]                             if (!grepl(pattern, name)) 
[13:22:02.333]                               next
[13:22:02.333]                             invokeRestart(restart)
[13:22:02.333]                             muffled <- TRUE
[13:22:02.333]                             break
[13:22:02.333]                           }
[13:22:02.333]                         }
[13:22:02.333]                       }
[13:22:02.333]                       invisible(muffled)
[13:22:02.333]                     }
[13:22:02.333]                     muffleCondition(cond, pattern = "^muffle")
[13:22:02.333]                   }
[13:22:02.333]                 }
[13:22:02.333]                 else {
[13:22:02.333]                   if (TRUE) {
[13:22:02.333]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:02.333]                     {
[13:22:02.333]                       inherits <- base::inherits
[13:22:02.333]                       invokeRestart <- base::invokeRestart
[13:22:02.333]                       is.null <- base::is.null
[13:22:02.333]                       muffled <- FALSE
[13:22:02.333]                       if (inherits(cond, "message")) {
[13:22:02.333]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:02.333]                         if (muffled) 
[13:22:02.333]                           invokeRestart("muffleMessage")
[13:22:02.333]                       }
[13:22:02.333]                       else if (inherits(cond, "warning")) {
[13:22:02.333]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:02.333]                         if (muffled) 
[13:22:02.333]                           invokeRestart("muffleWarning")
[13:22:02.333]                       }
[13:22:02.333]                       else if (inherits(cond, "condition")) {
[13:22:02.333]                         if (!is.null(pattern)) {
[13:22:02.333]                           computeRestarts <- base::computeRestarts
[13:22:02.333]                           grepl <- base::grepl
[13:22:02.333]                           restarts <- computeRestarts(cond)
[13:22:02.333]                           for (restart in restarts) {
[13:22:02.333]                             name <- restart$name
[13:22:02.333]                             if (is.null(name)) 
[13:22:02.333]                               next
[13:22:02.333]                             if (!grepl(pattern, name)) 
[13:22:02.333]                               next
[13:22:02.333]                             invokeRestart(restart)
[13:22:02.333]                             muffled <- TRUE
[13:22:02.333]                             break
[13:22:02.333]                           }
[13:22:02.333]                         }
[13:22:02.333]                       }
[13:22:02.333]                       invisible(muffled)
[13:22:02.333]                     }
[13:22:02.333]                     muffleCondition(cond, pattern = "^muffle")
[13:22:02.333]                   }
[13:22:02.333]                 }
[13:22:02.333]             }
[13:22:02.333]         }))
[13:22:02.333]     }, error = function(ex) {
[13:22:02.333]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:02.333]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:02.333]                 ...future.rng), started = ...future.startTime, 
[13:22:02.333]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:02.333]             version = "1.8"), class = "FutureResult")
[13:22:02.333]     }, finally = {
[13:22:02.333]         if (!identical(...future.workdir, getwd())) 
[13:22:02.333]             setwd(...future.workdir)
[13:22:02.333]         {
[13:22:02.333]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:02.333]                 ...future.oldOptions$nwarnings <- NULL
[13:22:02.333]             }
[13:22:02.333]             base::options(...future.oldOptions)
[13:22:02.333]             if (.Platform$OS.type == "windows") {
[13:22:02.333]                 old_names <- names(...future.oldEnvVars)
[13:22:02.333]                 envs <- base::Sys.getenv()
[13:22:02.333]                 names <- names(envs)
[13:22:02.333]                 common <- intersect(names, old_names)
[13:22:02.333]                 added <- setdiff(names, old_names)
[13:22:02.333]                 removed <- setdiff(old_names, names)
[13:22:02.333]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:02.333]                   envs[common]]
[13:22:02.333]                 NAMES <- toupper(changed)
[13:22:02.333]                 args <- list()
[13:22:02.333]                 for (kk in seq_along(NAMES)) {
[13:22:02.333]                   name <- changed[[kk]]
[13:22:02.333]                   NAME <- NAMES[[kk]]
[13:22:02.333]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:02.333]                     next
[13:22:02.333]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:02.333]                 }
[13:22:02.333]                 NAMES <- toupper(added)
[13:22:02.333]                 for (kk in seq_along(NAMES)) {
[13:22:02.333]                   name <- added[[kk]]
[13:22:02.333]                   NAME <- NAMES[[kk]]
[13:22:02.333]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:02.333]                     next
[13:22:02.333]                   args[[name]] <- ""
[13:22:02.333]                 }
[13:22:02.333]                 NAMES <- toupper(removed)
[13:22:02.333]                 for (kk in seq_along(NAMES)) {
[13:22:02.333]                   name <- removed[[kk]]
[13:22:02.333]                   NAME <- NAMES[[kk]]
[13:22:02.333]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:02.333]                     next
[13:22:02.333]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:02.333]                 }
[13:22:02.333]                 if (length(args) > 0) 
[13:22:02.333]                   base::do.call(base::Sys.setenv, args = args)
[13:22:02.333]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:02.333]             }
[13:22:02.333]             else {
[13:22:02.333]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:02.333]             }
[13:22:02.333]             {
[13:22:02.333]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:02.333]                   0L) {
[13:22:02.333]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:02.333]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:02.333]                   base::options(opts)
[13:22:02.333]                 }
[13:22:02.333]                 {
[13:22:02.333]                   {
[13:22:02.333]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:02.333]                     NULL
[13:22:02.333]                   }
[13:22:02.333]                   options(future.plan = NULL)
[13:22:02.333]                   if (is.na(NA_character_)) 
[13:22:02.333]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:02.333]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:02.333]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:02.333]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:02.333]                     envir = parent.frame()) 
[13:22:02.333]                   {
[13:22:02.333]                     if (is.function(workers)) 
[13:22:02.333]                       workers <- workers()
[13:22:02.333]                     workers <- structure(as.integer(workers), 
[13:22:02.333]                       class = class(workers))
[13:22:02.333]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:02.333]                       workers >= 1)
[13:22:02.333]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:02.333]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:02.333]                     }
[13:22:02.333]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:02.333]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:02.333]                       envir = envir)
[13:22:02.333]                     if (!future$lazy) 
[13:22:02.333]                       future <- run(future)
[13:22:02.333]                     invisible(future)
[13:22:02.333]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:02.333]                 }
[13:22:02.333]             }
[13:22:02.333]         }
[13:22:02.333]     })
[13:22:02.333]     if (TRUE) {
[13:22:02.333]         base::sink(type = "output", split = FALSE)
[13:22:02.333]         if (TRUE) {
[13:22:02.333]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:02.333]         }
[13:22:02.333]         else {
[13:22:02.333]             ...future.result["stdout"] <- base::list(NULL)
[13:22:02.333]         }
[13:22:02.333]         base::close(...future.stdout)
[13:22:02.333]         ...future.stdout <- NULL
[13:22:02.333]     }
[13:22:02.333]     ...future.result$conditions <- ...future.conditions
[13:22:02.333]     ...future.result$finished <- base::Sys.time()
[13:22:02.333]     ...future.result
[13:22:02.333] }
[13:22:02.336] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[13:22:02.336] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[13:22:02.337] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[13:22:02.337] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:22:02.337] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:22:02.338] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[13:22:02.338] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[13:22:02.338] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:22:02.338] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:22:02.339] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:22:02.339] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:22:02.339] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[13:22:02.340] MultisessionFuture started
[13:22:02.340] - Launch lazy future ... done
[13:22:02.340] run() for ‘MultisessionFuture’ ... done
[13:22:02.340] Created future:
[13:22:02.340] MultisessionFuture:
[13:22:02.340] Label: ‘future_lapply-2’
[13:22:02.340] Expression:
[13:22:02.340] {
[13:22:02.340]     do.call(function(...) {
[13:22:02.340]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:02.340]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:22:02.340]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:02.340]             on.exit(options(oopts), add = TRUE)
[13:22:02.340]         }
[13:22:02.340]         {
[13:22:02.340]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:22:02.340]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:22:02.340]                 ...future.FUN(...future.X_jj, ...)
[13:22:02.340]             })
[13:22:02.340]         }
[13:22:02.340]     }, args = future.call.arguments)
[13:22:02.340] }
[13:22:02.340] Lazy evaluation: FALSE
[13:22:02.340] Asynchronous evaluation: TRUE
[13:22:02.340] Local evaluation: TRUE
[13:22:02.340] Environment: R_GlobalEnv
[13:22:02.340] Capture standard output: TRUE
[13:22:02.340] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:22:02.340] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:22:02.340] Packages: <none>
[13:22:02.340] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:22:02.340] Resolved: FALSE
[13:22:02.340] Value: <not collected>
[13:22:02.340] Conditions captured: <none>
[13:22:02.340] Early signaling: FALSE
[13:22:02.340] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:22:02.340] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:02.352] Chunk #2 of 2 ... DONE
[13:22:02.352] Launching 2 futures (chunks) ... DONE
[13:22:02.352] Resolving 2 futures (chunks) ...
[13:22:02.353] resolve() on list ...
[13:22:02.353]  recursive: 0
[13:22:02.353]  length: 2
[13:22:02.353] 
[13:22:02.395] receiveMessageFromWorker() for ClusterFuture ...
[13:22:02.396] - Validating connection of MultisessionFuture
[13:22:02.396] - received message: FutureResult
[13:22:02.396] - Received FutureResult
[13:22:02.396] - Erased future from FutureRegistry
[13:22:02.396] result() for ClusterFuture ...
[13:22:02.396] - result already collected: FutureResult
[13:22:02.396] result() for ClusterFuture ... done
[13:22:02.396] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:02.397] Future #2
[13:22:02.397] result() for ClusterFuture ...
[13:22:02.397] - result already collected: FutureResult
[13:22:02.397] result() for ClusterFuture ... done
[13:22:02.397] result() for ClusterFuture ...
[13:22:02.397] - result already collected: FutureResult
[13:22:02.397] result() for ClusterFuture ... done
[13:22:02.397] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:22:02.397] - nx: 2
[13:22:02.397] - relay: TRUE
[13:22:02.397] - stdout: TRUE
[13:22:02.398] - signal: TRUE
[13:22:02.398] - resignal: FALSE
[13:22:02.398] - force: TRUE
[13:22:02.398] - relayed: [n=2] FALSE, FALSE
[13:22:02.398] - queued futures: [n=2] FALSE, FALSE
[13:22:02.398]  - until=1
[13:22:02.398]  - relaying element #1
[13:22:02.398] - relayed: [n=2] FALSE, FALSE
[13:22:02.398] - queued futures: [n=2] FALSE, TRUE
[13:22:02.398] signalConditionsASAP(NULL, pos=2) ... done
[13:22:02.398]  length: 1 (resolved future 2)
[13:22:02.848] receiveMessageFromWorker() for ClusterFuture ...
[13:22:02.848] - Validating connection of MultisessionFuture
[13:22:02.849] - received message: FutureResult
[13:22:02.849] - Received FutureResult
[13:22:02.849] - Erased future from FutureRegistry
[13:22:02.849] result() for ClusterFuture ...
[13:22:02.849] - result already collected: FutureResult
[13:22:02.849] result() for ClusterFuture ... done
[13:22:02.849] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:02.849] Future #1
[13:22:02.849] result() for ClusterFuture ...
[13:22:02.849] - result already collected: FutureResult
[13:22:02.849] result() for ClusterFuture ... done
[13:22:02.850] result() for ClusterFuture ...
[13:22:02.850] - result already collected: FutureResult
[13:22:02.850] result() for ClusterFuture ... done
[13:22:02.850] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:22:02.850] - nx: 2
[13:22:02.850] - relay: TRUE
[13:22:02.850] - stdout: TRUE
[13:22:02.850] - signal: TRUE
[13:22:02.850] - resignal: FALSE
[13:22:02.850] - force: TRUE
[13:22:02.850] - relayed: [n=2] FALSE, FALSE
[13:22:02.850] - queued futures: [n=2] FALSE, TRUE
[13:22:02.851]  - until=1
[13:22:02.851]  - relaying element #1
[13:22:02.851] result() for ClusterFuture ...
[13:22:02.851] - result already collected: FutureResult
[13:22:02.851] result() for ClusterFuture ... done
[13:22:02.851] result() for ClusterFuture ...
[13:22:02.851] - result already collected: FutureResult
[13:22:02.851] result() for ClusterFuture ... done
[13:22:02.851] result() for ClusterFuture ...
[13:22:02.851] - result already collected: FutureResult
[13:22:02.851] result() for ClusterFuture ... done
[13:22:02.852] result() for ClusterFuture ...
[13:22:02.852] - result already collected: FutureResult
[13:22:02.852] result() for ClusterFuture ... done
[13:22:02.852] - relayed: [n=2] TRUE, FALSE
[13:22:02.852] - queued futures: [n=2] TRUE, TRUE
[13:22:02.852] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:22:02.852]  length: 0 (resolved future 1)
[13:22:02.852] Relaying remaining futures
[13:22:02.852] signalConditionsASAP(NULL, pos=0) ...
[13:22:02.852] - nx: 2
[13:22:02.854] - relay: TRUE
[13:22:02.854] - stdout: TRUE
[13:22:02.855] - signal: TRUE
[13:22:02.855] - resignal: FALSE
[13:22:02.855] - force: TRUE
[13:22:02.855] - relayed: [n=2] TRUE, FALSE
[13:22:02.855] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:22:02.855]  - relaying element #2
[13:22:02.855] result() for ClusterFuture ...
[13:22:02.855] - result already collected: FutureResult
[13:22:02.855] result() for ClusterFuture ... done
[13:22:02.855] result() for ClusterFuture ...
[13:22:02.855] - result already collected: FutureResult
[13:22:02.856] result() for ClusterFuture ... done
[13:22:02.856] result() for ClusterFuture ...
[13:22:02.856] - result already collected: FutureResult
[13:22:02.856] result() for ClusterFuture ... done
[13:22:02.856] result() for ClusterFuture ...
[13:22:02.856] - result already collected: FutureResult
[13:22:02.856] result() for ClusterFuture ... done
[13:22:02.856] - relayed: [n=2] TRUE, TRUE
[13:22:02.856] - queued futures: [n=2] TRUE, TRUE
[13:22:02.856] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[13:22:02.856] resolve() on list ... DONE
[13:22:02.857] result() for ClusterFuture ...
[13:22:02.857] - result already collected: FutureResult
[13:22:02.857] result() for ClusterFuture ... done
[13:22:02.857] result() for ClusterFuture ...
[13:22:02.857] - result already collected: FutureResult
[13:22:02.857] result() for ClusterFuture ... done
[13:22:02.857] result() for ClusterFuture ...
[13:22:02.857] - result already collected: FutureResult
[13:22:02.857] result() for ClusterFuture ... done
[13:22:02.857] result() for ClusterFuture ...
[13:22:02.857] - result already collected: FutureResult
[13:22:02.857] result() for ClusterFuture ... done
[13:22:02.858]  - Number of value chunks collected: 2
[13:22:02.858] Resolving 2 futures (chunks) ... DONE
[13:22:02.858] Reducing values from 2 chunks ...
[13:22:02.858]  - Number of values collected after concatenation: 2
[13:22:02.858]  - Number of values expected: 2
[13:22:02.858] Reducing values from 2 chunks ... DONE
[13:22:02.858] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[13:22:02.858] future_lapply() ...
[13:22:02.863] Number of chunks: 2
[13:22:02.863] getGlobalsAndPackagesXApply() ...
[13:22:02.863]  - future.globals: TRUE
[13:22:02.863] getGlobalsAndPackages() ...
[13:22:02.863] Searching for globals...
[13:22:02.865] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:22:02.865] Searching for globals ... DONE
[13:22:02.865] Resolving globals: FALSE
[13:22:02.865] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:22:02.866] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:22:02.866] - globals: [1] ‘FUN’
[13:22:02.866] 
[13:22:02.866] getGlobalsAndPackages() ... DONE
[13:22:02.866]  - globals found/used: [n=1] ‘FUN’
[13:22:02.866]  - needed namespaces: [n=0] 
[13:22:02.866] Finding globals ... DONE
[13:22:02.866]  - use_args: TRUE
[13:22:02.866]  - Getting '...' globals ...
[13:22:02.867] resolve() on list ...
[13:22:02.867]  recursive: 0
[13:22:02.867]  length: 1
[13:22:02.867]  elements: ‘...’
[13:22:02.867]  length: 0 (resolved future 1)
[13:22:02.867] resolve() on list ... DONE
[13:22:02.867]    - '...' content: [n=0] 
[13:22:02.867] List of 1
[13:22:02.867]  $ ...: list()
[13:22:02.867]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:22:02.867]  - attr(*, "where")=List of 1
[13:22:02.867]   ..$ ...:<environment: 0x55dd74b42d10> 
[13:22:02.867]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:22:02.867]  - attr(*, "resolved")= logi TRUE
[13:22:02.867]  - attr(*, "total_size")= num NA
[13:22:02.870]  - Getting '...' globals ... DONE
[13:22:02.870] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:22:02.870] List of 2
[13:22:02.870]  $ ...future.FUN:function (x)  
[13:22:02.870]  $ ...          : list()
[13:22:02.870]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:22:02.870]  - attr(*, "where")=List of 2
[13:22:02.870]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:22:02.870]   ..$ ...          :<environment: 0x55dd74b42d10> 
[13:22:02.870]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:22:02.870]  - attr(*, "resolved")= logi FALSE
[13:22:02.870]  - attr(*, "total_size")= num 4720
[13:22:02.873] Packages to be attached in all futures: [n=0] 
[13:22:02.873] getGlobalsAndPackagesXApply() ... DONE
[13:22:02.873] Number of futures (= number of chunks): 2
[13:22:02.873] Launching 2 futures (chunks) ...
[13:22:02.873] Chunk #1 of 2 ...
[13:22:02.873]  - Finding globals in 'X' for chunk #1 ...
[13:22:02.874] getGlobalsAndPackages() ...
[13:22:02.874] Searching for globals...
[13:22:02.874] 
[13:22:02.874] Searching for globals ... DONE
[13:22:02.874] - globals: [0] <none>
[13:22:02.874] getGlobalsAndPackages() ... DONE
[13:22:02.874]    + additional globals found: [n=0] 
[13:22:02.874]    + additional namespaces needed: [n=0] 
[13:22:02.874]  - Finding globals in 'X' for chunk #1 ... DONE
[13:22:02.875]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:22:02.875]  - seeds: <none>
[13:22:02.875]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:02.875] getGlobalsAndPackages() ...
[13:22:02.875] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:02.875] Resolving globals: FALSE
[13:22:02.875] Tweak future expression to call with '...' arguments ...
[13:22:02.875] {
[13:22:02.875]     do.call(function(...) {
[13:22:02.875]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:02.875]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:22:02.875]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:02.875]             on.exit(options(oopts), add = TRUE)
[13:22:02.875]         }
[13:22:02.875]         {
[13:22:02.875]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:22:02.875]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:22:02.875]                 ...future.FUN(...future.X_jj, ...)
[13:22:02.875]             })
[13:22:02.875]         }
[13:22:02.875]     }, args = future.call.arguments)
[13:22:02.875] }
[13:22:02.876] Tweak future expression to call with '...' arguments ... DONE
[13:22:02.876] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:02.876] 
[13:22:02.876] getGlobalsAndPackages() ... DONE
[13:22:02.876] run() for ‘Future’ ...
[13:22:02.877] - state: ‘created’
[13:22:02.877] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:02.892] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:02.892] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:02.893]   - Field: ‘node’
[13:22:02.893]   - Field: ‘label’
[13:22:02.893]   - Field: ‘local’
[13:22:02.893]   - Field: ‘owner’
[13:22:02.893]   - Field: ‘envir’
[13:22:02.893]   - Field: ‘workers’
[13:22:02.893]   - Field: ‘packages’
[13:22:02.893]   - Field: ‘gc’
[13:22:02.893]   - Field: ‘conditions’
[13:22:02.893]   - Field: ‘persistent’
[13:22:02.893]   - Field: ‘expr’
[13:22:02.894]   - Field: ‘uuid’
[13:22:02.894]   - Field: ‘seed’
[13:22:02.894]   - Field: ‘version’
[13:22:02.894]   - Field: ‘result’
[13:22:02.894]   - Field: ‘asynchronous’
[13:22:02.894]   - Field: ‘calls’
[13:22:02.894]   - Field: ‘globals’
[13:22:02.894]   - Field: ‘stdout’
[13:22:02.894]   - Field: ‘earlySignal’
[13:22:02.894]   - Field: ‘lazy’
[13:22:02.894]   - Field: ‘state’
[13:22:02.895] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:02.895] - Launch lazy future ...
[13:22:02.895] Packages needed by the future expression (n = 0): <none>
[13:22:02.895] Packages needed by future strategies (n = 0): <none>
[13:22:02.896] {
[13:22:02.896]     {
[13:22:02.896]         {
[13:22:02.896]             ...future.startTime <- base::Sys.time()
[13:22:02.896]             {
[13:22:02.896]                 {
[13:22:02.896]                   {
[13:22:02.896]                     {
[13:22:02.896]                       base::local({
[13:22:02.896]                         has_future <- base::requireNamespace("future", 
[13:22:02.896]                           quietly = TRUE)
[13:22:02.896]                         if (has_future) {
[13:22:02.896]                           ns <- base::getNamespace("future")
[13:22:02.896]                           version <- ns[[".package"]][["version"]]
[13:22:02.896]                           if (is.null(version)) 
[13:22:02.896]                             version <- utils::packageVersion("future")
[13:22:02.896]                         }
[13:22:02.896]                         else {
[13:22:02.896]                           version <- NULL
[13:22:02.896]                         }
[13:22:02.896]                         if (!has_future || version < "1.8.0") {
[13:22:02.896]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:02.896]                             "", base::R.version$version.string), 
[13:22:02.896]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:02.896]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:02.896]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:02.896]                               "release", "version")], collapse = " "), 
[13:22:02.896]                             hostname = base::Sys.info()[["nodename"]])
[13:22:02.896]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:02.896]                             info)
[13:22:02.896]                           info <- base::paste(info, collapse = "; ")
[13:22:02.896]                           if (!has_future) {
[13:22:02.896]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:02.896]                               info)
[13:22:02.896]                           }
[13:22:02.896]                           else {
[13:22:02.896]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:02.896]                               info, version)
[13:22:02.896]                           }
[13:22:02.896]                           base::stop(msg)
[13:22:02.896]                         }
[13:22:02.896]                       })
[13:22:02.896]                     }
[13:22:02.896]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:02.896]                     base::options(mc.cores = 1L)
[13:22:02.896]                   }
[13:22:02.896]                   options(future.plan = NULL)
[13:22:02.896]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:02.896]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:02.896]                 }
[13:22:02.896]                 ...future.workdir <- getwd()
[13:22:02.896]             }
[13:22:02.896]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:02.896]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:02.896]         }
[13:22:02.896]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:02.896]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:22:02.896]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:02.896]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:02.896]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:02.896]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:02.896]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:02.896]             base::names(...future.oldOptions))
[13:22:02.896]     }
[13:22:02.896]     if (TRUE) {
[13:22:02.896]     }
[13:22:02.896]     else {
[13:22:02.896]         if (NA) {
[13:22:02.896]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:02.896]                 open = "w")
[13:22:02.896]         }
[13:22:02.896]         else {
[13:22:02.896]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:02.896]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:02.896]         }
[13:22:02.896]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:02.896]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:02.896]             base::sink(type = "output", split = FALSE)
[13:22:02.896]             base::close(...future.stdout)
[13:22:02.896]         }, add = TRUE)
[13:22:02.896]     }
[13:22:02.896]     ...future.frame <- base::sys.nframe()
[13:22:02.896]     ...future.conditions <- base::list()
[13:22:02.896]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:02.896]     if (FALSE) {
[13:22:02.896]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:02.896]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:02.896]     }
[13:22:02.896]     ...future.result <- base::tryCatch({
[13:22:02.896]         base::withCallingHandlers({
[13:22:02.896]             ...future.value <- base::withVisible(base::local({
[13:22:02.896]                 ...future.makeSendCondition <- base::local({
[13:22:02.896]                   sendCondition <- NULL
[13:22:02.896]                   function(frame = 1L) {
[13:22:02.896]                     if (is.function(sendCondition)) 
[13:22:02.896]                       return(sendCondition)
[13:22:02.896]                     ns <- getNamespace("parallel")
[13:22:02.896]                     if (exists("sendData", mode = "function", 
[13:22:02.896]                       envir = ns)) {
[13:22:02.896]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:02.896]                         envir = ns)
[13:22:02.896]                       envir <- sys.frame(frame)
[13:22:02.896]                       master <- NULL
[13:22:02.896]                       while (!identical(envir, .GlobalEnv) && 
[13:22:02.896]                         !identical(envir, emptyenv())) {
[13:22:02.896]                         if (exists("master", mode = "list", envir = envir, 
[13:22:02.896]                           inherits = FALSE)) {
[13:22:02.896]                           master <- get("master", mode = "list", 
[13:22:02.896]                             envir = envir, inherits = FALSE)
[13:22:02.896]                           if (inherits(master, c("SOCKnode", 
[13:22:02.896]                             "SOCK0node"))) {
[13:22:02.896]                             sendCondition <<- function(cond) {
[13:22:02.896]                               data <- list(type = "VALUE", value = cond, 
[13:22:02.896]                                 success = TRUE)
[13:22:02.896]                               parallel_sendData(master, data)
[13:22:02.896]                             }
[13:22:02.896]                             return(sendCondition)
[13:22:02.896]                           }
[13:22:02.896]                         }
[13:22:02.896]                         frame <- frame + 1L
[13:22:02.896]                         envir <- sys.frame(frame)
[13:22:02.896]                       }
[13:22:02.896]                     }
[13:22:02.896]                     sendCondition <<- function(cond) NULL
[13:22:02.896]                   }
[13:22:02.896]                 })
[13:22:02.896]                 withCallingHandlers({
[13:22:02.896]                   {
[13:22:02.896]                     do.call(function(...) {
[13:22:02.896]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:02.896]                       if (!identical(...future.globals.maxSize.org, 
[13:22:02.896]                         ...future.globals.maxSize)) {
[13:22:02.896]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:02.896]                         on.exit(options(oopts), add = TRUE)
[13:22:02.896]                       }
[13:22:02.896]                       {
[13:22:02.896]                         lapply(seq_along(...future.elements_ii), 
[13:22:02.896]                           FUN = function(jj) {
[13:22:02.896]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:22:02.896]                             ...future.FUN(...future.X_jj, ...)
[13:22:02.896]                           })
[13:22:02.896]                       }
[13:22:02.896]                     }, args = future.call.arguments)
[13:22:02.896]                   }
[13:22:02.896]                 }, immediateCondition = function(cond) {
[13:22:02.896]                   sendCondition <- ...future.makeSendCondition()
[13:22:02.896]                   sendCondition(cond)
[13:22:02.896]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:02.896]                   {
[13:22:02.896]                     inherits <- base::inherits
[13:22:02.896]                     invokeRestart <- base::invokeRestart
[13:22:02.896]                     is.null <- base::is.null
[13:22:02.896]                     muffled <- FALSE
[13:22:02.896]                     if (inherits(cond, "message")) {
[13:22:02.896]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:02.896]                       if (muffled) 
[13:22:02.896]                         invokeRestart("muffleMessage")
[13:22:02.896]                     }
[13:22:02.896]                     else if (inherits(cond, "warning")) {
[13:22:02.896]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:02.896]                       if (muffled) 
[13:22:02.896]                         invokeRestart("muffleWarning")
[13:22:02.896]                     }
[13:22:02.896]                     else if (inherits(cond, "condition")) {
[13:22:02.896]                       if (!is.null(pattern)) {
[13:22:02.896]                         computeRestarts <- base::computeRestarts
[13:22:02.896]                         grepl <- base::grepl
[13:22:02.896]                         restarts <- computeRestarts(cond)
[13:22:02.896]                         for (restart in restarts) {
[13:22:02.896]                           name <- restart$name
[13:22:02.896]                           if (is.null(name)) 
[13:22:02.896]                             next
[13:22:02.896]                           if (!grepl(pattern, name)) 
[13:22:02.896]                             next
[13:22:02.896]                           invokeRestart(restart)
[13:22:02.896]                           muffled <- TRUE
[13:22:02.896]                           break
[13:22:02.896]                         }
[13:22:02.896]                       }
[13:22:02.896]                     }
[13:22:02.896]                     invisible(muffled)
[13:22:02.896]                   }
[13:22:02.896]                   muffleCondition(cond)
[13:22:02.896]                 })
[13:22:02.896]             }))
[13:22:02.896]             future::FutureResult(value = ...future.value$value, 
[13:22:02.896]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:02.896]                   ...future.rng), globalenv = if (FALSE) 
[13:22:02.896]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:02.896]                     ...future.globalenv.names))
[13:22:02.896]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:02.896]         }, condition = base::local({
[13:22:02.896]             c <- base::c
[13:22:02.896]             inherits <- base::inherits
[13:22:02.896]             invokeRestart <- base::invokeRestart
[13:22:02.896]             length <- base::length
[13:22:02.896]             list <- base::list
[13:22:02.896]             seq.int <- base::seq.int
[13:22:02.896]             signalCondition <- base::signalCondition
[13:22:02.896]             sys.calls <- base::sys.calls
[13:22:02.896]             `[[` <- base::`[[`
[13:22:02.896]             `+` <- base::`+`
[13:22:02.896]             `<<-` <- base::`<<-`
[13:22:02.896]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:02.896]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:02.896]                   3L)]
[13:22:02.896]             }
[13:22:02.896]             function(cond) {
[13:22:02.896]                 is_error <- inherits(cond, "error")
[13:22:02.896]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:02.896]                   NULL)
[13:22:02.896]                 if (is_error) {
[13:22:02.896]                   sessionInformation <- function() {
[13:22:02.896]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:02.896]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:02.896]                       search = base::search(), system = base::Sys.info())
[13:22:02.896]                   }
[13:22:02.896]                   ...future.conditions[[length(...future.conditions) + 
[13:22:02.896]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:02.896]                     cond$call), session = sessionInformation(), 
[13:22:02.896]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:02.896]                   signalCondition(cond)
[13:22:02.896]                 }
[13:22:02.896]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:02.896]                 "immediateCondition"))) {
[13:22:02.896]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:02.896]                   ...future.conditions[[length(...future.conditions) + 
[13:22:02.896]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:02.896]                   if (TRUE && !signal) {
[13:22:02.896]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:02.896]                     {
[13:22:02.896]                       inherits <- base::inherits
[13:22:02.896]                       invokeRestart <- base::invokeRestart
[13:22:02.896]                       is.null <- base::is.null
[13:22:02.896]                       muffled <- FALSE
[13:22:02.896]                       if (inherits(cond, "message")) {
[13:22:02.896]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:02.896]                         if (muffled) 
[13:22:02.896]                           invokeRestart("muffleMessage")
[13:22:02.896]                       }
[13:22:02.896]                       else if (inherits(cond, "warning")) {
[13:22:02.896]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:02.896]                         if (muffled) 
[13:22:02.896]                           invokeRestart("muffleWarning")
[13:22:02.896]                       }
[13:22:02.896]                       else if (inherits(cond, "condition")) {
[13:22:02.896]                         if (!is.null(pattern)) {
[13:22:02.896]                           computeRestarts <- base::computeRestarts
[13:22:02.896]                           grepl <- base::grepl
[13:22:02.896]                           restarts <- computeRestarts(cond)
[13:22:02.896]                           for (restart in restarts) {
[13:22:02.896]                             name <- restart$name
[13:22:02.896]                             if (is.null(name)) 
[13:22:02.896]                               next
[13:22:02.896]                             if (!grepl(pattern, name)) 
[13:22:02.896]                               next
[13:22:02.896]                             invokeRestart(restart)
[13:22:02.896]                             muffled <- TRUE
[13:22:02.896]                             break
[13:22:02.896]                           }
[13:22:02.896]                         }
[13:22:02.896]                       }
[13:22:02.896]                       invisible(muffled)
[13:22:02.896]                     }
[13:22:02.896]                     muffleCondition(cond, pattern = "^muffle")
[13:22:02.896]                   }
[13:22:02.896]                 }
[13:22:02.896]                 else {
[13:22:02.896]                   if (TRUE) {
[13:22:02.896]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:02.896]                     {
[13:22:02.896]                       inherits <- base::inherits
[13:22:02.896]                       invokeRestart <- base::invokeRestart
[13:22:02.896]                       is.null <- base::is.null
[13:22:02.896]                       muffled <- FALSE
[13:22:02.896]                       if (inherits(cond, "message")) {
[13:22:02.896]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:02.896]                         if (muffled) 
[13:22:02.896]                           invokeRestart("muffleMessage")
[13:22:02.896]                       }
[13:22:02.896]                       else if (inherits(cond, "warning")) {
[13:22:02.896]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:02.896]                         if (muffled) 
[13:22:02.896]                           invokeRestart("muffleWarning")
[13:22:02.896]                       }
[13:22:02.896]                       else if (inherits(cond, "condition")) {
[13:22:02.896]                         if (!is.null(pattern)) {
[13:22:02.896]                           computeRestarts <- base::computeRestarts
[13:22:02.896]                           grepl <- base::grepl
[13:22:02.896]                           restarts <- computeRestarts(cond)
[13:22:02.896]                           for (restart in restarts) {
[13:22:02.896]                             name <- restart$name
[13:22:02.896]                             if (is.null(name)) 
[13:22:02.896]                               next
[13:22:02.896]                             if (!grepl(pattern, name)) 
[13:22:02.896]                               next
[13:22:02.896]                             invokeRestart(restart)
[13:22:02.896]                             muffled <- TRUE
[13:22:02.896]                             break
[13:22:02.896]                           }
[13:22:02.896]                         }
[13:22:02.896]                       }
[13:22:02.896]                       invisible(muffled)
[13:22:02.896]                     }
[13:22:02.896]                     muffleCondition(cond, pattern = "^muffle")
[13:22:02.896]                   }
[13:22:02.896]                 }
[13:22:02.896]             }
[13:22:02.896]         }))
[13:22:02.896]     }, error = function(ex) {
[13:22:02.896]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:02.896]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:02.896]                 ...future.rng), started = ...future.startTime, 
[13:22:02.896]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:02.896]             version = "1.8"), class = "FutureResult")
[13:22:02.896]     }, finally = {
[13:22:02.896]         if (!identical(...future.workdir, getwd())) 
[13:22:02.896]             setwd(...future.workdir)
[13:22:02.896]         {
[13:22:02.896]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:02.896]                 ...future.oldOptions$nwarnings <- NULL
[13:22:02.896]             }
[13:22:02.896]             base::options(...future.oldOptions)
[13:22:02.896]             if (.Platform$OS.type == "windows") {
[13:22:02.896]                 old_names <- names(...future.oldEnvVars)
[13:22:02.896]                 envs <- base::Sys.getenv()
[13:22:02.896]                 names <- names(envs)
[13:22:02.896]                 common <- intersect(names, old_names)
[13:22:02.896]                 added <- setdiff(names, old_names)
[13:22:02.896]                 removed <- setdiff(old_names, names)
[13:22:02.896]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:02.896]                   envs[common]]
[13:22:02.896]                 NAMES <- toupper(changed)
[13:22:02.896]                 args <- list()
[13:22:02.896]                 for (kk in seq_along(NAMES)) {
[13:22:02.896]                   name <- changed[[kk]]
[13:22:02.896]                   NAME <- NAMES[[kk]]
[13:22:02.896]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:02.896]                     next
[13:22:02.896]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:02.896]                 }
[13:22:02.896]                 NAMES <- toupper(added)
[13:22:02.896]                 for (kk in seq_along(NAMES)) {
[13:22:02.896]                   name <- added[[kk]]
[13:22:02.896]                   NAME <- NAMES[[kk]]
[13:22:02.896]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:02.896]                     next
[13:22:02.896]                   args[[name]] <- ""
[13:22:02.896]                 }
[13:22:02.896]                 NAMES <- toupper(removed)
[13:22:02.896]                 for (kk in seq_along(NAMES)) {
[13:22:02.896]                   name <- removed[[kk]]
[13:22:02.896]                   NAME <- NAMES[[kk]]
[13:22:02.896]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:02.896]                     next
[13:22:02.896]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:02.896]                 }
[13:22:02.896]                 if (length(args) > 0) 
[13:22:02.896]                   base::do.call(base::Sys.setenv, args = args)
[13:22:02.896]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:02.896]             }
[13:22:02.896]             else {
[13:22:02.896]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:02.896]             }
[13:22:02.896]             {
[13:22:02.896]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:02.896]                   0L) {
[13:22:02.896]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:02.896]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:02.896]                   base::options(opts)
[13:22:02.896]                 }
[13:22:02.896]                 {
[13:22:02.896]                   {
[13:22:02.896]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:02.896]                     NULL
[13:22:02.896]                   }
[13:22:02.896]                   options(future.plan = NULL)
[13:22:02.896]                   if (is.na(NA_character_)) 
[13:22:02.896]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:02.896]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:02.896]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:02.896]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:02.896]                     envir = parent.frame()) 
[13:22:02.896]                   {
[13:22:02.896]                     if (is.function(workers)) 
[13:22:02.896]                       workers <- workers()
[13:22:02.896]                     workers <- structure(as.integer(workers), 
[13:22:02.896]                       class = class(workers))
[13:22:02.896]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:02.896]                       workers >= 1)
[13:22:02.896]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:02.896]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:02.896]                     }
[13:22:02.896]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:02.896]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:02.896]                       envir = envir)
[13:22:02.896]                     if (!future$lazy) 
[13:22:02.896]                       future <- run(future)
[13:22:02.896]                     invisible(future)
[13:22:02.896]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:02.896]                 }
[13:22:02.896]             }
[13:22:02.896]         }
[13:22:02.896]     })
[13:22:02.896]     if (FALSE) {
[13:22:02.896]         base::sink(type = "output", split = FALSE)
[13:22:02.896]         if (NA) {
[13:22:02.896]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:02.896]         }
[13:22:02.896]         else {
[13:22:02.896]             ...future.result["stdout"] <- base::list(NULL)
[13:22:02.896]         }
[13:22:02.896]         base::close(...future.stdout)
[13:22:02.896]         ...future.stdout <- NULL
[13:22:02.896]     }
[13:22:02.896]     ...future.result$conditions <- ...future.conditions
[13:22:02.896]     ...future.result$finished <- base::Sys.time()
[13:22:02.896]     ...future.result
[13:22:02.896] }
[13:22:02.899] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[13:22:02.899] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[13:22:02.899] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[13:22:02.899] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:22:02.900] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:22:02.900] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[13:22:02.900] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[13:22:02.900] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:22:02.901] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:22:02.901] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:22:02.901] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:22:02.901] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[13:22:02.902] MultisessionFuture started
[13:22:02.902] - Launch lazy future ... done
[13:22:02.902] run() for ‘MultisessionFuture’ ... done
[13:22:02.902] Created future:
[13:22:02.902] MultisessionFuture:
[13:22:02.902] Label: ‘future_lapply-1’
[13:22:02.902] Expression:
[13:22:02.902] {
[13:22:02.902]     do.call(function(...) {
[13:22:02.902]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:02.902]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:22:02.902]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:02.902]             on.exit(options(oopts), add = TRUE)
[13:22:02.902]         }
[13:22:02.902]         {
[13:22:02.902]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:22:02.902]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:22:02.902]                 ...future.FUN(...future.X_jj, ...)
[13:22:02.902]             })
[13:22:02.902]         }
[13:22:02.902]     }, args = future.call.arguments)
[13:22:02.902] }
[13:22:02.902] Lazy evaluation: FALSE
[13:22:02.902] Asynchronous evaluation: TRUE
[13:22:02.902] Local evaluation: TRUE
[13:22:02.902] Environment: R_GlobalEnv
[13:22:02.902] Capture standard output: NA
[13:22:02.902] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:22:02.902] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:22:02.902] Packages: <none>
[13:22:02.902] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:22:02.902] Resolved: FALSE
[13:22:02.902] Value: <not collected>
[13:22:02.902] Conditions captured: <none>
[13:22:02.902] Early signaling: FALSE
[13:22:02.902] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:22:02.902] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:02.914] Chunk #1 of 2 ... DONE
[13:22:02.914] Chunk #2 of 2 ...
[13:22:02.914]  - Finding globals in 'X' for chunk #2 ...
[13:22:02.914] getGlobalsAndPackages() ...
[13:22:02.914] Searching for globals...
[13:22:02.914] 
[13:22:02.914] Searching for globals ... DONE
[13:22:02.914] - globals: [0] <none>
[13:22:02.915] getGlobalsAndPackages() ... DONE
[13:22:02.915]    + additional globals found: [n=0] 
[13:22:02.915]    + additional namespaces needed: [n=0] 
[13:22:02.915]  - Finding globals in 'X' for chunk #2 ... DONE
[13:22:02.915]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:22:02.915]  - seeds: <none>
[13:22:02.915]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:02.915] getGlobalsAndPackages() ...
[13:22:02.915] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:02.915] Resolving globals: FALSE
[13:22:02.915] Tweak future expression to call with '...' arguments ...
[13:22:02.916] {
[13:22:02.916]     do.call(function(...) {
[13:22:02.916]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:02.916]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:22:02.916]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:02.916]             on.exit(options(oopts), add = TRUE)
[13:22:02.916]         }
[13:22:02.916]         {
[13:22:02.916]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:22:02.916]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:22:02.916]                 ...future.FUN(...future.X_jj, ...)
[13:22:02.916]             })
[13:22:02.916]         }
[13:22:02.916]     }, args = future.call.arguments)
[13:22:02.916] }
[13:22:02.916] Tweak future expression to call with '...' arguments ... DONE
[13:22:02.916] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:02.916] 
[13:22:02.916] getGlobalsAndPackages() ... DONE
[13:22:02.917] run() for ‘Future’ ...
[13:22:02.917] - state: ‘created’
[13:22:02.917] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:02.931] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:02.932] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:02.932]   - Field: ‘node’
[13:22:02.932]   - Field: ‘label’
[13:22:02.932]   - Field: ‘local’
[13:22:02.932]   - Field: ‘owner’
[13:22:02.932]   - Field: ‘envir’
[13:22:02.932]   - Field: ‘workers’
[13:22:02.932]   - Field: ‘packages’
[13:22:02.933]   - Field: ‘gc’
[13:22:02.933]   - Field: ‘conditions’
[13:22:02.933]   - Field: ‘persistent’
[13:22:02.933]   - Field: ‘expr’
[13:22:02.933]   - Field: ‘uuid’
[13:22:02.933]   - Field: ‘seed’
[13:22:02.933]   - Field: ‘version’
[13:22:02.933]   - Field: ‘result’
[13:22:02.933]   - Field: ‘asynchronous’
[13:22:02.933]   - Field: ‘calls’
[13:22:02.934]   - Field: ‘globals’
[13:22:02.934]   - Field: ‘stdout’
[13:22:02.934]   - Field: ‘earlySignal’
[13:22:02.934]   - Field: ‘lazy’
[13:22:02.934]   - Field: ‘state’
[13:22:02.934] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:02.934] - Launch lazy future ...
[13:22:02.934] Packages needed by the future expression (n = 0): <none>
[13:22:02.934] Packages needed by future strategies (n = 0): <none>
[13:22:02.935] {
[13:22:02.935]     {
[13:22:02.935]         {
[13:22:02.935]             ...future.startTime <- base::Sys.time()
[13:22:02.935]             {
[13:22:02.935]                 {
[13:22:02.935]                   {
[13:22:02.935]                     {
[13:22:02.935]                       base::local({
[13:22:02.935]                         has_future <- base::requireNamespace("future", 
[13:22:02.935]                           quietly = TRUE)
[13:22:02.935]                         if (has_future) {
[13:22:02.935]                           ns <- base::getNamespace("future")
[13:22:02.935]                           version <- ns[[".package"]][["version"]]
[13:22:02.935]                           if (is.null(version)) 
[13:22:02.935]                             version <- utils::packageVersion("future")
[13:22:02.935]                         }
[13:22:02.935]                         else {
[13:22:02.935]                           version <- NULL
[13:22:02.935]                         }
[13:22:02.935]                         if (!has_future || version < "1.8.0") {
[13:22:02.935]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:02.935]                             "", base::R.version$version.string), 
[13:22:02.935]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:02.935]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:02.935]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:02.935]                               "release", "version")], collapse = " "), 
[13:22:02.935]                             hostname = base::Sys.info()[["nodename"]])
[13:22:02.935]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:02.935]                             info)
[13:22:02.935]                           info <- base::paste(info, collapse = "; ")
[13:22:02.935]                           if (!has_future) {
[13:22:02.935]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:02.935]                               info)
[13:22:02.935]                           }
[13:22:02.935]                           else {
[13:22:02.935]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:02.935]                               info, version)
[13:22:02.935]                           }
[13:22:02.935]                           base::stop(msg)
[13:22:02.935]                         }
[13:22:02.935]                       })
[13:22:02.935]                     }
[13:22:02.935]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:02.935]                     base::options(mc.cores = 1L)
[13:22:02.935]                   }
[13:22:02.935]                   options(future.plan = NULL)
[13:22:02.935]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:02.935]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:02.935]                 }
[13:22:02.935]                 ...future.workdir <- getwd()
[13:22:02.935]             }
[13:22:02.935]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:02.935]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:02.935]         }
[13:22:02.935]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:02.935]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:22:02.935]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:02.935]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:02.935]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:02.935]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:02.935]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:02.935]             base::names(...future.oldOptions))
[13:22:02.935]     }
[13:22:02.935]     if (TRUE) {
[13:22:02.935]     }
[13:22:02.935]     else {
[13:22:02.935]         if (NA) {
[13:22:02.935]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:02.935]                 open = "w")
[13:22:02.935]         }
[13:22:02.935]         else {
[13:22:02.935]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:02.935]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:02.935]         }
[13:22:02.935]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:02.935]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:02.935]             base::sink(type = "output", split = FALSE)
[13:22:02.935]             base::close(...future.stdout)
[13:22:02.935]         }, add = TRUE)
[13:22:02.935]     }
[13:22:02.935]     ...future.frame <- base::sys.nframe()
[13:22:02.935]     ...future.conditions <- base::list()
[13:22:02.935]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:02.935]     if (FALSE) {
[13:22:02.935]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:02.935]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:02.935]     }
[13:22:02.935]     ...future.result <- base::tryCatch({
[13:22:02.935]         base::withCallingHandlers({
[13:22:02.935]             ...future.value <- base::withVisible(base::local({
[13:22:02.935]                 ...future.makeSendCondition <- base::local({
[13:22:02.935]                   sendCondition <- NULL
[13:22:02.935]                   function(frame = 1L) {
[13:22:02.935]                     if (is.function(sendCondition)) 
[13:22:02.935]                       return(sendCondition)
[13:22:02.935]                     ns <- getNamespace("parallel")
[13:22:02.935]                     if (exists("sendData", mode = "function", 
[13:22:02.935]                       envir = ns)) {
[13:22:02.935]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:02.935]                         envir = ns)
[13:22:02.935]                       envir <- sys.frame(frame)
[13:22:02.935]                       master <- NULL
[13:22:02.935]                       while (!identical(envir, .GlobalEnv) && 
[13:22:02.935]                         !identical(envir, emptyenv())) {
[13:22:02.935]                         if (exists("master", mode = "list", envir = envir, 
[13:22:02.935]                           inherits = FALSE)) {
[13:22:02.935]                           master <- get("master", mode = "list", 
[13:22:02.935]                             envir = envir, inherits = FALSE)
[13:22:02.935]                           if (inherits(master, c("SOCKnode", 
[13:22:02.935]                             "SOCK0node"))) {
[13:22:02.935]                             sendCondition <<- function(cond) {
[13:22:02.935]                               data <- list(type = "VALUE", value = cond, 
[13:22:02.935]                                 success = TRUE)
[13:22:02.935]                               parallel_sendData(master, data)
[13:22:02.935]                             }
[13:22:02.935]                             return(sendCondition)
[13:22:02.935]                           }
[13:22:02.935]                         }
[13:22:02.935]                         frame <- frame + 1L
[13:22:02.935]                         envir <- sys.frame(frame)
[13:22:02.935]                       }
[13:22:02.935]                     }
[13:22:02.935]                     sendCondition <<- function(cond) NULL
[13:22:02.935]                   }
[13:22:02.935]                 })
[13:22:02.935]                 withCallingHandlers({
[13:22:02.935]                   {
[13:22:02.935]                     do.call(function(...) {
[13:22:02.935]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:02.935]                       if (!identical(...future.globals.maxSize.org, 
[13:22:02.935]                         ...future.globals.maxSize)) {
[13:22:02.935]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:02.935]                         on.exit(options(oopts), add = TRUE)
[13:22:02.935]                       }
[13:22:02.935]                       {
[13:22:02.935]                         lapply(seq_along(...future.elements_ii), 
[13:22:02.935]                           FUN = function(jj) {
[13:22:02.935]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:22:02.935]                             ...future.FUN(...future.X_jj, ...)
[13:22:02.935]                           })
[13:22:02.935]                       }
[13:22:02.935]                     }, args = future.call.arguments)
[13:22:02.935]                   }
[13:22:02.935]                 }, immediateCondition = function(cond) {
[13:22:02.935]                   sendCondition <- ...future.makeSendCondition()
[13:22:02.935]                   sendCondition(cond)
[13:22:02.935]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:02.935]                   {
[13:22:02.935]                     inherits <- base::inherits
[13:22:02.935]                     invokeRestart <- base::invokeRestart
[13:22:02.935]                     is.null <- base::is.null
[13:22:02.935]                     muffled <- FALSE
[13:22:02.935]                     if (inherits(cond, "message")) {
[13:22:02.935]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:02.935]                       if (muffled) 
[13:22:02.935]                         invokeRestart("muffleMessage")
[13:22:02.935]                     }
[13:22:02.935]                     else if (inherits(cond, "warning")) {
[13:22:02.935]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:02.935]                       if (muffled) 
[13:22:02.935]                         invokeRestart("muffleWarning")
[13:22:02.935]                     }
[13:22:02.935]                     else if (inherits(cond, "condition")) {
[13:22:02.935]                       if (!is.null(pattern)) {
[13:22:02.935]                         computeRestarts <- base::computeRestarts
[13:22:02.935]                         grepl <- base::grepl
[13:22:02.935]                         restarts <- computeRestarts(cond)
[13:22:02.935]                         for (restart in restarts) {
[13:22:02.935]                           name <- restart$name
[13:22:02.935]                           if (is.null(name)) 
[13:22:02.935]                             next
[13:22:02.935]                           if (!grepl(pattern, name)) 
[13:22:02.935]                             next
[13:22:02.935]                           invokeRestart(restart)
[13:22:02.935]                           muffled <- TRUE
[13:22:02.935]                           break
[13:22:02.935]                         }
[13:22:02.935]                       }
[13:22:02.935]                     }
[13:22:02.935]                     invisible(muffled)
[13:22:02.935]                   }
[13:22:02.935]                   muffleCondition(cond)
[13:22:02.935]                 })
[13:22:02.935]             }))
[13:22:02.935]             future::FutureResult(value = ...future.value$value, 
[13:22:02.935]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:02.935]                   ...future.rng), globalenv = if (FALSE) 
[13:22:02.935]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:02.935]                     ...future.globalenv.names))
[13:22:02.935]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:02.935]         }, condition = base::local({
[13:22:02.935]             c <- base::c
[13:22:02.935]             inherits <- base::inherits
[13:22:02.935]             invokeRestart <- base::invokeRestart
[13:22:02.935]             length <- base::length
[13:22:02.935]             list <- base::list
[13:22:02.935]             seq.int <- base::seq.int
[13:22:02.935]             signalCondition <- base::signalCondition
[13:22:02.935]             sys.calls <- base::sys.calls
[13:22:02.935]             `[[` <- base::`[[`
[13:22:02.935]             `+` <- base::`+`
[13:22:02.935]             `<<-` <- base::`<<-`
[13:22:02.935]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:02.935]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:02.935]                   3L)]
[13:22:02.935]             }
[13:22:02.935]             function(cond) {
[13:22:02.935]                 is_error <- inherits(cond, "error")
[13:22:02.935]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:02.935]                   NULL)
[13:22:02.935]                 if (is_error) {
[13:22:02.935]                   sessionInformation <- function() {
[13:22:02.935]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:02.935]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:02.935]                       search = base::search(), system = base::Sys.info())
[13:22:02.935]                   }
[13:22:02.935]                   ...future.conditions[[length(...future.conditions) + 
[13:22:02.935]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:02.935]                     cond$call), session = sessionInformation(), 
[13:22:02.935]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:02.935]                   signalCondition(cond)
[13:22:02.935]                 }
[13:22:02.935]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:02.935]                 "immediateCondition"))) {
[13:22:02.935]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:02.935]                   ...future.conditions[[length(...future.conditions) + 
[13:22:02.935]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:02.935]                   if (TRUE && !signal) {
[13:22:02.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:02.935]                     {
[13:22:02.935]                       inherits <- base::inherits
[13:22:02.935]                       invokeRestart <- base::invokeRestart
[13:22:02.935]                       is.null <- base::is.null
[13:22:02.935]                       muffled <- FALSE
[13:22:02.935]                       if (inherits(cond, "message")) {
[13:22:02.935]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:02.935]                         if (muffled) 
[13:22:02.935]                           invokeRestart("muffleMessage")
[13:22:02.935]                       }
[13:22:02.935]                       else if (inherits(cond, "warning")) {
[13:22:02.935]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:02.935]                         if (muffled) 
[13:22:02.935]                           invokeRestart("muffleWarning")
[13:22:02.935]                       }
[13:22:02.935]                       else if (inherits(cond, "condition")) {
[13:22:02.935]                         if (!is.null(pattern)) {
[13:22:02.935]                           computeRestarts <- base::computeRestarts
[13:22:02.935]                           grepl <- base::grepl
[13:22:02.935]                           restarts <- computeRestarts(cond)
[13:22:02.935]                           for (restart in restarts) {
[13:22:02.935]                             name <- restart$name
[13:22:02.935]                             if (is.null(name)) 
[13:22:02.935]                               next
[13:22:02.935]                             if (!grepl(pattern, name)) 
[13:22:02.935]                               next
[13:22:02.935]                             invokeRestart(restart)
[13:22:02.935]                             muffled <- TRUE
[13:22:02.935]                             break
[13:22:02.935]                           }
[13:22:02.935]                         }
[13:22:02.935]                       }
[13:22:02.935]                       invisible(muffled)
[13:22:02.935]                     }
[13:22:02.935]                     muffleCondition(cond, pattern = "^muffle")
[13:22:02.935]                   }
[13:22:02.935]                 }
[13:22:02.935]                 else {
[13:22:02.935]                   if (TRUE) {
[13:22:02.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:02.935]                     {
[13:22:02.935]                       inherits <- base::inherits
[13:22:02.935]                       invokeRestart <- base::invokeRestart
[13:22:02.935]                       is.null <- base::is.null
[13:22:02.935]                       muffled <- FALSE
[13:22:02.935]                       if (inherits(cond, "message")) {
[13:22:02.935]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:02.935]                         if (muffled) 
[13:22:02.935]                           invokeRestart("muffleMessage")
[13:22:02.935]                       }
[13:22:02.935]                       else if (inherits(cond, "warning")) {
[13:22:02.935]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:02.935]                         if (muffled) 
[13:22:02.935]                           invokeRestart("muffleWarning")
[13:22:02.935]                       }
[13:22:02.935]                       else if (inherits(cond, "condition")) {
[13:22:02.935]                         if (!is.null(pattern)) {
[13:22:02.935]                           computeRestarts <- base::computeRestarts
[13:22:02.935]                           grepl <- base::grepl
[13:22:02.935]                           restarts <- computeRestarts(cond)
[13:22:02.935]                           for (restart in restarts) {
[13:22:02.935]                             name <- restart$name
[13:22:02.935]                             if (is.null(name)) 
[13:22:02.935]                               next
[13:22:02.935]                             if (!grepl(pattern, name)) 
[13:22:02.935]                               next
[13:22:02.935]                             invokeRestart(restart)
[13:22:02.935]                             muffled <- TRUE
[13:22:02.935]                             break
[13:22:02.935]                           }
[13:22:02.935]                         }
[13:22:02.935]                       }
[13:22:02.935]                       invisible(muffled)
[13:22:02.935]                     }
[13:22:02.935]                     muffleCondition(cond, pattern = "^muffle")
[13:22:02.935]                   }
[13:22:02.935]                 }
[13:22:02.935]             }
[13:22:02.935]         }))
[13:22:02.935]     }, error = function(ex) {
[13:22:02.935]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:02.935]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:02.935]                 ...future.rng), started = ...future.startTime, 
[13:22:02.935]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:02.935]             version = "1.8"), class = "FutureResult")
[13:22:02.935]     }, finally = {
[13:22:02.935]         if (!identical(...future.workdir, getwd())) 
[13:22:02.935]             setwd(...future.workdir)
[13:22:02.935]         {
[13:22:02.935]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:02.935]                 ...future.oldOptions$nwarnings <- NULL
[13:22:02.935]             }
[13:22:02.935]             base::options(...future.oldOptions)
[13:22:02.935]             if (.Platform$OS.type == "windows") {
[13:22:02.935]                 old_names <- names(...future.oldEnvVars)
[13:22:02.935]                 envs <- base::Sys.getenv()
[13:22:02.935]                 names <- names(envs)
[13:22:02.935]                 common <- intersect(names, old_names)
[13:22:02.935]                 added <- setdiff(names, old_names)
[13:22:02.935]                 removed <- setdiff(old_names, names)
[13:22:02.935]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:02.935]                   envs[common]]
[13:22:02.935]                 NAMES <- toupper(changed)
[13:22:02.935]                 args <- list()
[13:22:02.935]                 for (kk in seq_along(NAMES)) {
[13:22:02.935]                   name <- changed[[kk]]
[13:22:02.935]                   NAME <- NAMES[[kk]]
[13:22:02.935]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:02.935]                     next
[13:22:02.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:02.935]                 }
[13:22:02.935]                 NAMES <- toupper(added)
[13:22:02.935]                 for (kk in seq_along(NAMES)) {
[13:22:02.935]                   name <- added[[kk]]
[13:22:02.935]                   NAME <- NAMES[[kk]]
[13:22:02.935]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:02.935]                     next
[13:22:02.935]                   args[[name]] <- ""
[13:22:02.935]                 }
[13:22:02.935]                 NAMES <- toupper(removed)
[13:22:02.935]                 for (kk in seq_along(NAMES)) {
[13:22:02.935]                   name <- removed[[kk]]
[13:22:02.935]                   NAME <- NAMES[[kk]]
[13:22:02.935]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:02.935]                     next
[13:22:02.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:02.935]                 }
[13:22:02.935]                 if (length(args) > 0) 
[13:22:02.935]                   base::do.call(base::Sys.setenv, args = args)
[13:22:02.935]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:02.935]             }
[13:22:02.935]             else {
[13:22:02.935]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:02.935]             }
[13:22:02.935]             {
[13:22:02.935]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:02.935]                   0L) {
[13:22:02.935]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:02.935]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:02.935]                   base::options(opts)
[13:22:02.935]                 }
[13:22:02.935]                 {
[13:22:02.935]                   {
[13:22:02.935]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:02.935]                     NULL
[13:22:02.935]                   }
[13:22:02.935]                   options(future.plan = NULL)
[13:22:02.935]                   if (is.na(NA_character_)) 
[13:22:02.935]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:02.935]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:02.935]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:02.935]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:02.935]                     envir = parent.frame()) 
[13:22:02.935]                   {
[13:22:02.935]                     if (is.function(workers)) 
[13:22:02.935]                       workers <- workers()
[13:22:02.935]                     workers <- structure(as.integer(workers), 
[13:22:02.935]                       class = class(workers))
[13:22:02.935]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:02.935]                       workers >= 1)
[13:22:02.935]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:02.935]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:02.935]                     }
[13:22:02.935]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:02.935]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:02.935]                       envir = envir)
[13:22:02.935]                     if (!future$lazy) 
[13:22:02.935]                       future <- run(future)
[13:22:02.935]                     invisible(future)
[13:22:02.935]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:02.935]                 }
[13:22:02.935]             }
[13:22:02.935]         }
[13:22:02.935]     })
[13:22:02.935]     if (FALSE) {
[13:22:02.935]         base::sink(type = "output", split = FALSE)
[13:22:02.935]         if (NA) {
[13:22:02.935]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:02.935]         }
[13:22:02.935]         else {
[13:22:02.935]             ...future.result["stdout"] <- base::list(NULL)
[13:22:02.935]         }
[13:22:02.935]         base::close(...future.stdout)
[13:22:02.935]         ...future.stdout <- NULL
[13:22:02.935]     }
[13:22:02.935]     ...future.result$conditions <- ...future.conditions
[13:22:02.935]     ...future.result$finished <- base::Sys.time()
[13:22:02.935]     ...future.result
[13:22:02.935] }
[13:22:02.938] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[13:22:02.938] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[13:22:02.938] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[13:22:02.939] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:22:02.939] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:22:02.939] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[13:22:02.940] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[13:22:02.940] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:22:02.940] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:22:02.940] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:22:02.941] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:22:02.941] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[13:22:02.941] MultisessionFuture started
[13:22:02.941] - Launch lazy future ... done
[13:22:02.942] run() for ‘MultisessionFuture’ ... done
[13:22:02.942] Created future:
[13:22:02.942] MultisessionFuture:
[13:22:02.942] Label: ‘future_lapply-2’
[13:22:02.942] Expression:
[13:22:02.942] {
[13:22:02.942]     do.call(function(...) {
[13:22:02.942]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:02.942]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:22:02.942]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:02.942]             on.exit(options(oopts), add = TRUE)
[13:22:02.942]         }
[13:22:02.942]         {
[13:22:02.942]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:22:02.942]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:22:02.942]                 ...future.FUN(...future.X_jj, ...)
[13:22:02.942]             })
[13:22:02.942]         }
[13:22:02.942]     }, args = future.call.arguments)
[13:22:02.942] }
[13:22:02.942] Lazy evaluation: FALSE
[13:22:02.942] Asynchronous evaluation: TRUE
[13:22:02.942] Local evaluation: TRUE
[13:22:02.942] Environment: R_GlobalEnv
[13:22:02.942] Capture standard output: NA
[13:22:02.942] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:22:02.942] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:22:02.942] Packages: <none>
[13:22:02.942] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:22:02.942] Resolved: FALSE
[13:22:02.942] Value: <not collected>
[13:22:02.942] Conditions captured: <none>
[13:22:02.942] Early signaling: FALSE
[13:22:02.942] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:22:02.942] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:02.953] Chunk #2 of 2 ... DONE
[13:22:02.954] Launching 2 futures (chunks) ... DONE
[13:22:02.954] Resolving 2 futures (chunks) ...
[13:22:02.954] resolve() on list ...
[13:22:02.954]  recursive: 0
[13:22:02.954]  length: 2
[13:22:02.954] 
[13:22:02.997] receiveMessageFromWorker() for ClusterFuture ...
[13:22:02.997] - Validating connection of MultisessionFuture
[13:22:02.997] - received message: FutureResult
[13:22:02.997] - Received FutureResult
[13:22:02.997] - Erased future from FutureRegistry
[13:22:02.998] result() for ClusterFuture ...
[13:22:02.998] - result already collected: FutureResult
[13:22:02.998] result() for ClusterFuture ... done
[13:22:02.998] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:02.998] Future #2
[13:22:02.998] result() for ClusterFuture ...
[13:22:02.998] - result already collected: FutureResult
[13:22:02.998] result() for ClusterFuture ... done
[13:22:02.998] result() for ClusterFuture ...
[13:22:02.998] - result already collected: FutureResult
[13:22:02.998] result() for ClusterFuture ... done
[13:22:02.999] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:22:02.999] - nx: 2
[13:22:02.999] - relay: TRUE
[13:22:02.999] - stdout: TRUE
[13:22:02.999] - signal: TRUE
[13:22:02.999] - resignal: FALSE
[13:22:02.999] - force: TRUE
[13:22:02.999] - relayed: [n=2] FALSE, FALSE
[13:22:02.999] - queued futures: [n=2] FALSE, FALSE
[13:22:02.999]  - until=1
[13:22:02.999]  - relaying element #1
[13:22:03.000] - relayed: [n=2] FALSE, FALSE
[13:22:03.000] - queued futures: [n=2] FALSE, TRUE
[13:22:03.000] signalConditionsASAP(NULL, pos=2) ... done
[13:22:03.000]  length: 1 (resolved future 2)
[13:22:03.450] receiveMessageFromWorker() for ClusterFuture ...
[13:22:03.450] - Validating connection of MultisessionFuture
[13:22:03.450] - received message: FutureResult
[13:22:03.451] - Received FutureResult
[13:22:03.451] - Erased future from FutureRegistry
[13:22:03.451] result() for ClusterFuture ...
[13:22:03.451] - result already collected: FutureResult
[13:22:03.451] result() for ClusterFuture ... done
[13:22:03.451] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:03.451] Future #1
[13:22:03.451] result() for ClusterFuture ...
[13:22:03.451] - result already collected: FutureResult
[13:22:03.451] result() for ClusterFuture ... done
[13:22:03.452] result() for ClusterFuture ...
[13:22:03.452] - result already collected: FutureResult
[13:22:03.452] result() for ClusterFuture ... done
[13:22:03.452] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:22:03.452] - nx: 2
[13:22:03.452] - relay: TRUE
[13:22:03.452] - stdout: TRUE
[13:22:03.452] - signal: TRUE
[13:22:03.452] - resignal: FALSE
[13:22:03.452] - force: TRUE
[13:22:03.452] - relayed: [n=2] FALSE, FALSE
[13:22:03.453] - queued futures: [n=2] FALSE, TRUE
[13:22:03.453]  - until=1
[13:22:03.453]  - relaying element #1
[13:22:03.453] result() for ClusterFuture ...
[13:22:03.453] - result already collected: FutureResult
[13:22:03.453] result() for ClusterFuture ... done
[13:22:03.453] result() for ClusterFuture ...
[13:22:03.453] - result already collected: FutureResult
[13:22:03.453] result() for ClusterFuture ... done
[13:22:03.453] result() for ClusterFuture ...
[13:22:03.453] - result already collected: FutureResult
[13:22:03.454] result() for ClusterFuture ... done
[13:22:03.454] result() for ClusterFuture ...
[13:22:03.454] - result already collected: FutureResult
[13:22:03.454] result() for ClusterFuture ... done
[13:22:03.454] - relayed: [n=2] TRUE, FALSE
[13:22:03.454] - queued futures: [n=2] TRUE, TRUE
[13:22:03.454] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:22:03.454]  length: 0 (resolved future 1)
[13:22:03.454] Relaying remaining futures
[13:22:03.454] signalConditionsASAP(NULL, pos=0) ...
[13:22:03.454] - nx: 2
[13:22:03.455] - relay: TRUE
[13:22:03.455] - stdout: TRUE
[13:22:03.455] - signal: TRUE
[13:22:03.455] - resignal: FALSE
[13:22:03.455] - force: TRUE
[13:22:03.455] - relayed: [n=2] TRUE, FALSE
[13:22:03.455] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:22:03.455]  - relaying element #2
[13:22:03.455] result() for ClusterFuture ...
[13:22:03.455] - result already collected: FutureResult
[13:22:03.455] result() for ClusterFuture ... done
[13:22:03.455] result() for ClusterFuture ...
[13:22:03.456] - result already collected: FutureResult
[13:22:03.456] result() for ClusterFuture ... done
[13:22:03.456] result() for ClusterFuture ...
[13:22:03.456] - result already collected: FutureResult
[13:22:03.456] result() for ClusterFuture ... done
[13:22:03.456] result() for ClusterFuture ...
[13:22:03.456] - result already collected: FutureResult
[13:22:03.456] result() for ClusterFuture ... done
[13:22:03.456] - relayed: [n=2] TRUE, TRUE
[13:22:03.456] - queued futures: [n=2] TRUE, TRUE
[13:22:03.457] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[13:22:03.457] resolve() on list ... DONE
[13:22:03.457] result() for ClusterFuture ...
[13:22:03.457] - result already collected: FutureResult
[13:22:03.457] result() for ClusterFuture ... done
[13:22:03.457] result() for ClusterFuture ...
[13:22:03.457] - result already collected: FutureResult
[13:22:03.457] result() for ClusterFuture ... done
[13:22:03.457] result() for ClusterFuture ...
[13:22:03.457] - result already collected: FutureResult
[13:22:03.457] result() for ClusterFuture ... done
[13:22:03.458] result() for ClusterFuture ...
[13:22:03.458] - result already collected: FutureResult
[13:22:03.458] result() for ClusterFuture ... done
[13:22:03.458]  - Number of value chunks collected: 2
[13:22:03.458] Resolving 2 futures (chunks) ... DONE
[13:22:03.458] Reducing values from 2 chunks ...
[13:22:03.458]  - Number of values collected after concatenation: 2
[13:22:03.458]  - Number of values expected: 2
[13:22:03.458] Reducing values from 2 chunks ... DONE
[13:22:03.458] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[13:22:03.459] future_mapply() ...
[13:22:03.463] Number of chunks: 2
[13:22:03.464] getGlobalsAndPackagesXApply() ...
[13:22:03.464]  - future.globals: TRUE
[13:22:03.464] getGlobalsAndPackages() ...
[13:22:03.464] Searching for globals...
[13:22:03.466] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:22:03.466] Searching for globals ... DONE
[13:22:03.466] Resolving globals: FALSE
[13:22:03.466] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:22:03.467] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:22:03.467] - globals: [1] ‘FUN’
[13:22:03.467] 
[13:22:03.467] getGlobalsAndPackages() ... DONE
[13:22:03.467]  - globals found/used: [n=1] ‘FUN’
[13:22:03.467]  - needed namespaces: [n=0] 
[13:22:03.467] Finding globals ... DONE
[13:22:03.468] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:22:03.468] List of 2
[13:22:03.468]  $ ...future.FUN:function (x, y)  
[13:22:03.468]  $ MoreArgs     : NULL
[13:22:03.468]  - attr(*, "where")=List of 2
[13:22:03.468]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:22:03.468]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:22:03.468]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:22:03.468]  - attr(*, "resolved")= logi FALSE
[13:22:03.468]  - attr(*, "total_size")= num NA
[13:22:03.470] Packages to be attached in all futures: [n=0] 
[13:22:03.470] getGlobalsAndPackagesXApply() ... DONE
[13:22:03.471] Number of futures (= number of chunks): 2
[13:22:03.471] Launching 2 futures (chunks) ...
[13:22:03.471] Chunk #1 of 2 ...
[13:22:03.471]  - Finding globals in '...' for chunk #1 ...
[13:22:03.471] getGlobalsAndPackages() ...
[13:22:03.471] Searching for globals...
[13:22:03.472] 
[13:22:03.472] Searching for globals ... DONE
[13:22:03.474] - globals: [0] <none>
[13:22:03.474] getGlobalsAndPackages() ... DONE
[13:22:03.474]    + additional globals found: [n=0] 
[13:22:03.474]    + additional namespaces needed: [n=0] 
[13:22:03.474]  - Finding globals in '...' for chunk #1 ... DONE
[13:22:03.474]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:22:03.474]  - seeds: <none>
[13:22:03.474]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:03.474] getGlobalsAndPackages() ...
[13:22:03.475] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:03.475] Resolving globals: FALSE
[13:22:03.475] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:22:03.476] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:22:03.476] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:03.476] 
[13:22:03.476] getGlobalsAndPackages() ... DONE
[13:22:03.476] run() for ‘Future’ ...
[13:22:03.477] - state: ‘created’
[13:22:03.477] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:03.492] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:03.492] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:03.492]   - Field: ‘node’
[13:22:03.492]   - Field: ‘label’
[13:22:03.492]   - Field: ‘local’
[13:22:03.492]   - Field: ‘owner’
[13:22:03.492]   - Field: ‘envir’
[13:22:03.493]   - Field: ‘workers’
[13:22:03.493]   - Field: ‘packages’
[13:22:03.493]   - Field: ‘gc’
[13:22:03.493]   - Field: ‘conditions’
[13:22:03.493]   - Field: ‘persistent’
[13:22:03.493]   - Field: ‘expr’
[13:22:03.493]   - Field: ‘uuid’
[13:22:03.493]   - Field: ‘seed’
[13:22:03.493]   - Field: ‘version’
[13:22:03.493]   - Field: ‘result’
[13:22:03.494]   - Field: ‘asynchronous’
[13:22:03.494]   - Field: ‘calls’
[13:22:03.494]   - Field: ‘globals’
[13:22:03.494]   - Field: ‘stdout’
[13:22:03.494]   - Field: ‘earlySignal’
[13:22:03.494]   - Field: ‘lazy’
[13:22:03.494]   - Field: ‘state’
[13:22:03.494] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:03.494] - Launch lazy future ...
[13:22:03.495] Packages needed by the future expression (n = 0): <none>
[13:22:03.495] Packages needed by future strategies (n = 0): <none>
[13:22:03.495] {
[13:22:03.495]     {
[13:22:03.495]         {
[13:22:03.495]             ...future.startTime <- base::Sys.time()
[13:22:03.495]             {
[13:22:03.495]                 {
[13:22:03.495]                   {
[13:22:03.495]                     {
[13:22:03.495]                       base::local({
[13:22:03.495]                         has_future <- base::requireNamespace("future", 
[13:22:03.495]                           quietly = TRUE)
[13:22:03.495]                         if (has_future) {
[13:22:03.495]                           ns <- base::getNamespace("future")
[13:22:03.495]                           version <- ns[[".package"]][["version"]]
[13:22:03.495]                           if (is.null(version)) 
[13:22:03.495]                             version <- utils::packageVersion("future")
[13:22:03.495]                         }
[13:22:03.495]                         else {
[13:22:03.495]                           version <- NULL
[13:22:03.495]                         }
[13:22:03.495]                         if (!has_future || version < "1.8.0") {
[13:22:03.495]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:03.495]                             "", base::R.version$version.string), 
[13:22:03.495]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:03.495]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:03.495]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:03.495]                               "release", "version")], collapse = " "), 
[13:22:03.495]                             hostname = base::Sys.info()[["nodename"]])
[13:22:03.495]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:03.495]                             info)
[13:22:03.495]                           info <- base::paste(info, collapse = "; ")
[13:22:03.495]                           if (!has_future) {
[13:22:03.495]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:03.495]                               info)
[13:22:03.495]                           }
[13:22:03.495]                           else {
[13:22:03.495]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:03.495]                               info, version)
[13:22:03.495]                           }
[13:22:03.495]                           base::stop(msg)
[13:22:03.495]                         }
[13:22:03.495]                       })
[13:22:03.495]                     }
[13:22:03.495]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:03.495]                     base::options(mc.cores = 1L)
[13:22:03.495]                   }
[13:22:03.495]                   options(future.plan = NULL)
[13:22:03.495]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:03.495]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:03.495]                 }
[13:22:03.495]                 ...future.workdir <- getwd()
[13:22:03.495]             }
[13:22:03.495]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:03.495]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:03.495]         }
[13:22:03.495]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:03.495]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:22:03.495]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:03.495]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:03.495]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:03.495]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:03.495]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:03.495]             base::names(...future.oldOptions))
[13:22:03.495]     }
[13:22:03.495]     if (FALSE) {
[13:22:03.495]     }
[13:22:03.495]     else {
[13:22:03.495]         if (FALSE) {
[13:22:03.495]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:03.495]                 open = "w")
[13:22:03.495]         }
[13:22:03.495]         else {
[13:22:03.495]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:03.495]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:03.495]         }
[13:22:03.495]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:03.495]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:03.495]             base::sink(type = "output", split = FALSE)
[13:22:03.495]             base::close(...future.stdout)
[13:22:03.495]         }, add = TRUE)
[13:22:03.495]     }
[13:22:03.495]     ...future.frame <- base::sys.nframe()
[13:22:03.495]     ...future.conditions <- base::list()
[13:22:03.495]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:03.495]     if (FALSE) {
[13:22:03.495]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:03.495]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:03.495]     }
[13:22:03.495]     ...future.result <- base::tryCatch({
[13:22:03.495]         base::withCallingHandlers({
[13:22:03.495]             ...future.value <- base::withVisible(base::local({
[13:22:03.495]                 ...future.makeSendCondition <- base::local({
[13:22:03.495]                   sendCondition <- NULL
[13:22:03.495]                   function(frame = 1L) {
[13:22:03.495]                     if (is.function(sendCondition)) 
[13:22:03.495]                       return(sendCondition)
[13:22:03.495]                     ns <- getNamespace("parallel")
[13:22:03.495]                     if (exists("sendData", mode = "function", 
[13:22:03.495]                       envir = ns)) {
[13:22:03.495]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:03.495]                         envir = ns)
[13:22:03.495]                       envir <- sys.frame(frame)
[13:22:03.495]                       master <- NULL
[13:22:03.495]                       while (!identical(envir, .GlobalEnv) && 
[13:22:03.495]                         !identical(envir, emptyenv())) {
[13:22:03.495]                         if (exists("master", mode = "list", envir = envir, 
[13:22:03.495]                           inherits = FALSE)) {
[13:22:03.495]                           master <- get("master", mode = "list", 
[13:22:03.495]                             envir = envir, inherits = FALSE)
[13:22:03.495]                           if (inherits(master, c("SOCKnode", 
[13:22:03.495]                             "SOCK0node"))) {
[13:22:03.495]                             sendCondition <<- function(cond) {
[13:22:03.495]                               data <- list(type = "VALUE", value = cond, 
[13:22:03.495]                                 success = TRUE)
[13:22:03.495]                               parallel_sendData(master, data)
[13:22:03.495]                             }
[13:22:03.495]                             return(sendCondition)
[13:22:03.495]                           }
[13:22:03.495]                         }
[13:22:03.495]                         frame <- frame + 1L
[13:22:03.495]                         envir <- sys.frame(frame)
[13:22:03.495]                       }
[13:22:03.495]                     }
[13:22:03.495]                     sendCondition <<- function(cond) NULL
[13:22:03.495]                   }
[13:22:03.495]                 })
[13:22:03.495]                 withCallingHandlers({
[13:22:03.495]                   {
[13:22:03.495]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:03.495]                     if (!identical(...future.globals.maxSize.org, 
[13:22:03.495]                       ...future.globals.maxSize)) {
[13:22:03.495]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:03.495]                       on.exit(options(oopts), add = TRUE)
[13:22:03.495]                     }
[13:22:03.495]                     {
[13:22:03.495]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:22:03.495]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:22:03.495]                         USE.NAMES = FALSE)
[13:22:03.495]                       do.call(mapply, args = args)
[13:22:03.495]                     }
[13:22:03.495]                   }
[13:22:03.495]                 }, immediateCondition = function(cond) {
[13:22:03.495]                   sendCondition <- ...future.makeSendCondition()
[13:22:03.495]                   sendCondition(cond)
[13:22:03.495]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:03.495]                   {
[13:22:03.495]                     inherits <- base::inherits
[13:22:03.495]                     invokeRestart <- base::invokeRestart
[13:22:03.495]                     is.null <- base::is.null
[13:22:03.495]                     muffled <- FALSE
[13:22:03.495]                     if (inherits(cond, "message")) {
[13:22:03.495]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:03.495]                       if (muffled) 
[13:22:03.495]                         invokeRestart("muffleMessage")
[13:22:03.495]                     }
[13:22:03.495]                     else if (inherits(cond, "warning")) {
[13:22:03.495]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:03.495]                       if (muffled) 
[13:22:03.495]                         invokeRestart("muffleWarning")
[13:22:03.495]                     }
[13:22:03.495]                     else if (inherits(cond, "condition")) {
[13:22:03.495]                       if (!is.null(pattern)) {
[13:22:03.495]                         computeRestarts <- base::computeRestarts
[13:22:03.495]                         grepl <- base::grepl
[13:22:03.495]                         restarts <- computeRestarts(cond)
[13:22:03.495]                         for (restart in restarts) {
[13:22:03.495]                           name <- restart$name
[13:22:03.495]                           if (is.null(name)) 
[13:22:03.495]                             next
[13:22:03.495]                           if (!grepl(pattern, name)) 
[13:22:03.495]                             next
[13:22:03.495]                           invokeRestart(restart)
[13:22:03.495]                           muffled <- TRUE
[13:22:03.495]                           break
[13:22:03.495]                         }
[13:22:03.495]                       }
[13:22:03.495]                     }
[13:22:03.495]                     invisible(muffled)
[13:22:03.495]                   }
[13:22:03.495]                   muffleCondition(cond)
[13:22:03.495]                 })
[13:22:03.495]             }))
[13:22:03.495]             future::FutureResult(value = ...future.value$value, 
[13:22:03.495]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:03.495]                   ...future.rng), globalenv = if (FALSE) 
[13:22:03.495]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:03.495]                     ...future.globalenv.names))
[13:22:03.495]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:03.495]         }, condition = base::local({
[13:22:03.495]             c <- base::c
[13:22:03.495]             inherits <- base::inherits
[13:22:03.495]             invokeRestart <- base::invokeRestart
[13:22:03.495]             length <- base::length
[13:22:03.495]             list <- base::list
[13:22:03.495]             seq.int <- base::seq.int
[13:22:03.495]             signalCondition <- base::signalCondition
[13:22:03.495]             sys.calls <- base::sys.calls
[13:22:03.495]             `[[` <- base::`[[`
[13:22:03.495]             `+` <- base::`+`
[13:22:03.495]             `<<-` <- base::`<<-`
[13:22:03.495]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:03.495]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:03.495]                   3L)]
[13:22:03.495]             }
[13:22:03.495]             function(cond) {
[13:22:03.495]                 is_error <- inherits(cond, "error")
[13:22:03.495]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:03.495]                   NULL)
[13:22:03.495]                 if (is_error) {
[13:22:03.495]                   sessionInformation <- function() {
[13:22:03.495]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:03.495]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:03.495]                       search = base::search(), system = base::Sys.info())
[13:22:03.495]                   }
[13:22:03.495]                   ...future.conditions[[length(...future.conditions) + 
[13:22:03.495]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:03.495]                     cond$call), session = sessionInformation(), 
[13:22:03.495]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:03.495]                   signalCondition(cond)
[13:22:03.495]                 }
[13:22:03.495]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:03.495]                 "immediateCondition"))) {
[13:22:03.495]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:03.495]                   ...future.conditions[[length(...future.conditions) + 
[13:22:03.495]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:03.495]                   if (TRUE && !signal) {
[13:22:03.495]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:03.495]                     {
[13:22:03.495]                       inherits <- base::inherits
[13:22:03.495]                       invokeRestart <- base::invokeRestart
[13:22:03.495]                       is.null <- base::is.null
[13:22:03.495]                       muffled <- FALSE
[13:22:03.495]                       if (inherits(cond, "message")) {
[13:22:03.495]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:03.495]                         if (muffled) 
[13:22:03.495]                           invokeRestart("muffleMessage")
[13:22:03.495]                       }
[13:22:03.495]                       else if (inherits(cond, "warning")) {
[13:22:03.495]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:03.495]                         if (muffled) 
[13:22:03.495]                           invokeRestart("muffleWarning")
[13:22:03.495]                       }
[13:22:03.495]                       else if (inherits(cond, "condition")) {
[13:22:03.495]                         if (!is.null(pattern)) {
[13:22:03.495]                           computeRestarts <- base::computeRestarts
[13:22:03.495]                           grepl <- base::grepl
[13:22:03.495]                           restarts <- computeRestarts(cond)
[13:22:03.495]                           for (restart in restarts) {
[13:22:03.495]                             name <- restart$name
[13:22:03.495]                             if (is.null(name)) 
[13:22:03.495]                               next
[13:22:03.495]                             if (!grepl(pattern, name)) 
[13:22:03.495]                               next
[13:22:03.495]                             invokeRestart(restart)
[13:22:03.495]                             muffled <- TRUE
[13:22:03.495]                             break
[13:22:03.495]                           }
[13:22:03.495]                         }
[13:22:03.495]                       }
[13:22:03.495]                       invisible(muffled)
[13:22:03.495]                     }
[13:22:03.495]                     muffleCondition(cond, pattern = "^muffle")
[13:22:03.495]                   }
[13:22:03.495]                 }
[13:22:03.495]                 else {
[13:22:03.495]                   if (TRUE) {
[13:22:03.495]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:03.495]                     {
[13:22:03.495]                       inherits <- base::inherits
[13:22:03.495]                       invokeRestart <- base::invokeRestart
[13:22:03.495]                       is.null <- base::is.null
[13:22:03.495]                       muffled <- FALSE
[13:22:03.495]                       if (inherits(cond, "message")) {
[13:22:03.495]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:03.495]                         if (muffled) 
[13:22:03.495]                           invokeRestart("muffleMessage")
[13:22:03.495]                       }
[13:22:03.495]                       else if (inherits(cond, "warning")) {
[13:22:03.495]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:03.495]                         if (muffled) 
[13:22:03.495]                           invokeRestart("muffleWarning")
[13:22:03.495]                       }
[13:22:03.495]                       else if (inherits(cond, "condition")) {
[13:22:03.495]                         if (!is.null(pattern)) {
[13:22:03.495]                           computeRestarts <- base::computeRestarts
[13:22:03.495]                           grepl <- base::grepl
[13:22:03.495]                           restarts <- computeRestarts(cond)
[13:22:03.495]                           for (restart in restarts) {
[13:22:03.495]                             name <- restart$name
[13:22:03.495]                             if (is.null(name)) 
[13:22:03.495]                               next
[13:22:03.495]                             if (!grepl(pattern, name)) 
[13:22:03.495]                               next
[13:22:03.495]                             invokeRestart(restart)
[13:22:03.495]                             muffled <- TRUE
[13:22:03.495]                             break
[13:22:03.495]                           }
[13:22:03.495]                         }
[13:22:03.495]                       }
[13:22:03.495]                       invisible(muffled)
[13:22:03.495]                     }
[13:22:03.495]                     muffleCondition(cond, pattern = "^muffle")
[13:22:03.495]                   }
[13:22:03.495]                 }
[13:22:03.495]             }
[13:22:03.495]         }))
[13:22:03.495]     }, error = function(ex) {
[13:22:03.495]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:03.495]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:03.495]                 ...future.rng), started = ...future.startTime, 
[13:22:03.495]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:03.495]             version = "1.8"), class = "FutureResult")
[13:22:03.495]     }, finally = {
[13:22:03.495]         if (!identical(...future.workdir, getwd())) 
[13:22:03.495]             setwd(...future.workdir)
[13:22:03.495]         {
[13:22:03.495]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:03.495]                 ...future.oldOptions$nwarnings <- NULL
[13:22:03.495]             }
[13:22:03.495]             base::options(...future.oldOptions)
[13:22:03.495]             if (.Platform$OS.type == "windows") {
[13:22:03.495]                 old_names <- names(...future.oldEnvVars)
[13:22:03.495]                 envs <- base::Sys.getenv()
[13:22:03.495]                 names <- names(envs)
[13:22:03.495]                 common <- intersect(names, old_names)
[13:22:03.495]                 added <- setdiff(names, old_names)
[13:22:03.495]                 removed <- setdiff(old_names, names)
[13:22:03.495]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:03.495]                   envs[common]]
[13:22:03.495]                 NAMES <- toupper(changed)
[13:22:03.495]                 args <- list()
[13:22:03.495]                 for (kk in seq_along(NAMES)) {
[13:22:03.495]                   name <- changed[[kk]]
[13:22:03.495]                   NAME <- NAMES[[kk]]
[13:22:03.495]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:03.495]                     next
[13:22:03.495]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:03.495]                 }
[13:22:03.495]                 NAMES <- toupper(added)
[13:22:03.495]                 for (kk in seq_along(NAMES)) {
[13:22:03.495]                   name <- added[[kk]]
[13:22:03.495]                   NAME <- NAMES[[kk]]
[13:22:03.495]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:03.495]                     next
[13:22:03.495]                   args[[name]] <- ""
[13:22:03.495]                 }
[13:22:03.495]                 NAMES <- toupper(removed)
[13:22:03.495]                 for (kk in seq_along(NAMES)) {
[13:22:03.495]                   name <- removed[[kk]]
[13:22:03.495]                   NAME <- NAMES[[kk]]
[13:22:03.495]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:03.495]                     next
[13:22:03.495]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:03.495]                 }
[13:22:03.495]                 if (length(args) > 0) 
[13:22:03.495]                   base::do.call(base::Sys.setenv, args = args)
[13:22:03.495]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:03.495]             }
[13:22:03.495]             else {
[13:22:03.495]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:03.495]             }
[13:22:03.495]             {
[13:22:03.495]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:03.495]                   0L) {
[13:22:03.495]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:03.495]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:03.495]                   base::options(opts)
[13:22:03.495]                 }
[13:22:03.495]                 {
[13:22:03.495]                   {
[13:22:03.495]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:03.495]                     NULL
[13:22:03.495]                   }
[13:22:03.495]                   options(future.plan = NULL)
[13:22:03.495]                   if (is.na(NA_character_)) 
[13:22:03.495]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:03.495]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:03.495]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:03.495]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:03.495]                     envir = parent.frame()) 
[13:22:03.495]                   {
[13:22:03.495]                     if (is.function(workers)) 
[13:22:03.495]                       workers <- workers()
[13:22:03.495]                     workers <- structure(as.integer(workers), 
[13:22:03.495]                       class = class(workers))
[13:22:03.495]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:03.495]                       workers >= 1)
[13:22:03.495]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:03.495]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:03.495]                     }
[13:22:03.495]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:03.495]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:03.495]                       envir = envir)
[13:22:03.495]                     if (!future$lazy) 
[13:22:03.495]                       future <- run(future)
[13:22:03.495]                     invisible(future)
[13:22:03.495]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:03.495]                 }
[13:22:03.495]             }
[13:22:03.495]         }
[13:22:03.495]     })
[13:22:03.495]     if (TRUE) {
[13:22:03.495]         base::sink(type = "output", split = FALSE)
[13:22:03.495]         if (FALSE) {
[13:22:03.495]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:03.495]         }
[13:22:03.495]         else {
[13:22:03.495]             ...future.result["stdout"] <- base::list(NULL)
[13:22:03.495]         }
[13:22:03.495]         base::close(...future.stdout)
[13:22:03.495]         ...future.stdout <- NULL
[13:22:03.495]     }
[13:22:03.495]     ...future.result$conditions <- ...future.conditions
[13:22:03.495]     ...future.result$finished <- base::Sys.time()
[13:22:03.495]     ...future.result
[13:22:03.495] }
[13:22:03.498] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[13:22:03.498] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[13:22:03.499] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[13:22:03.499] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[13:22:03.499] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[13:22:03.500] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[13:22:03.500] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[13:22:03.500] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:22:03.500] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:22:03.501] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:22:03.501] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:22:03.501] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[13:22:03.502] MultisessionFuture started
[13:22:03.502] - Launch lazy future ... done
[13:22:03.502] run() for ‘MultisessionFuture’ ... done
[13:22:03.502] Created future:
[13:22:03.502] MultisessionFuture:
[13:22:03.502] Label: ‘future_mapply-1’
[13:22:03.502] Expression:
[13:22:03.502] {
[13:22:03.502]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:03.502]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:22:03.502]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:03.502]         on.exit(options(oopts), add = TRUE)
[13:22:03.502]     }
[13:22:03.502]     {
[13:22:03.502]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:22:03.502]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:22:03.502]         do.call(mapply, args = args)
[13:22:03.502]     }
[13:22:03.502] }
[13:22:03.502] Lazy evaluation: FALSE
[13:22:03.502] Asynchronous evaluation: TRUE
[13:22:03.502] Local evaluation: TRUE
[13:22:03.502] Environment: R_GlobalEnv
[13:22:03.502] Capture standard output: FALSE
[13:22:03.502] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:22:03.502] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:22:03.502] Packages: <none>
[13:22:03.502] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:22:03.502] Resolved: FALSE
[13:22:03.502] Value: <not collected>
[13:22:03.502] Conditions captured: <none>
[13:22:03.502] Early signaling: FALSE
[13:22:03.502] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:22:03.502] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:03.514] Chunk #1 of 2 ... DONE
[13:22:03.514] Chunk #2 of 2 ...
[13:22:03.514]  - Finding globals in '...' for chunk #2 ...
[13:22:03.514] getGlobalsAndPackages() ...
[13:22:03.514] Searching for globals...
[13:22:03.515] 
[13:22:03.515] Searching for globals ... DONE
[13:22:03.515] - globals: [0] <none>
[13:22:03.515] getGlobalsAndPackages() ... DONE
[13:22:03.515]    + additional globals found: [n=0] 
[13:22:03.515]    + additional namespaces needed: [n=0] 
[13:22:03.515]  - Finding globals in '...' for chunk #2 ... DONE
[13:22:03.515]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:22:03.515]  - seeds: <none>
[13:22:03.516]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:03.516] getGlobalsAndPackages() ...
[13:22:03.516] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:03.516] Resolving globals: FALSE
[13:22:03.516] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:22:03.517] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:22:03.517] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:03.517] 
[13:22:03.517] getGlobalsAndPackages() ... DONE
[13:22:03.518] run() for ‘Future’ ...
[13:22:03.518] - state: ‘created’
[13:22:03.518] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:03.532] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:03.533] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:03.533]   - Field: ‘node’
[13:22:03.533]   - Field: ‘label’
[13:22:03.533]   - Field: ‘local’
[13:22:03.533]   - Field: ‘owner’
[13:22:03.533]   - Field: ‘envir’
[13:22:03.533]   - Field: ‘workers’
[13:22:03.533]   - Field: ‘packages’
[13:22:03.533]   - Field: ‘gc’
[13:22:03.534]   - Field: ‘conditions’
[13:22:03.534]   - Field: ‘persistent’
[13:22:03.534]   - Field: ‘expr’
[13:22:03.534]   - Field: ‘uuid’
[13:22:03.534]   - Field: ‘seed’
[13:22:03.534]   - Field: ‘version’
[13:22:03.534]   - Field: ‘result’
[13:22:03.534]   - Field: ‘asynchronous’
[13:22:03.534]   - Field: ‘calls’
[13:22:03.534]   - Field: ‘globals’
[13:22:03.534]   - Field: ‘stdout’
[13:22:03.535]   - Field: ‘earlySignal’
[13:22:03.535]   - Field: ‘lazy’
[13:22:03.535]   - Field: ‘state’
[13:22:03.535] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:03.535] - Launch lazy future ...
[13:22:03.535] Packages needed by the future expression (n = 0): <none>
[13:22:03.535] Packages needed by future strategies (n = 0): <none>
[13:22:03.536] {
[13:22:03.536]     {
[13:22:03.536]         {
[13:22:03.536]             ...future.startTime <- base::Sys.time()
[13:22:03.536]             {
[13:22:03.536]                 {
[13:22:03.536]                   {
[13:22:03.536]                     {
[13:22:03.536]                       base::local({
[13:22:03.536]                         has_future <- base::requireNamespace("future", 
[13:22:03.536]                           quietly = TRUE)
[13:22:03.536]                         if (has_future) {
[13:22:03.536]                           ns <- base::getNamespace("future")
[13:22:03.536]                           version <- ns[[".package"]][["version"]]
[13:22:03.536]                           if (is.null(version)) 
[13:22:03.536]                             version <- utils::packageVersion("future")
[13:22:03.536]                         }
[13:22:03.536]                         else {
[13:22:03.536]                           version <- NULL
[13:22:03.536]                         }
[13:22:03.536]                         if (!has_future || version < "1.8.0") {
[13:22:03.536]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:03.536]                             "", base::R.version$version.string), 
[13:22:03.536]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:03.536]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:03.536]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:03.536]                               "release", "version")], collapse = " "), 
[13:22:03.536]                             hostname = base::Sys.info()[["nodename"]])
[13:22:03.536]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:03.536]                             info)
[13:22:03.536]                           info <- base::paste(info, collapse = "; ")
[13:22:03.536]                           if (!has_future) {
[13:22:03.536]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:03.536]                               info)
[13:22:03.536]                           }
[13:22:03.536]                           else {
[13:22:03.536]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:03.536]                               info, version)
[13:22:03.536]                           }
[13:22:03.536]                           base::stop(msg)
[13:22:03.536]                         }
[13:22:03.536]                       })
[13:22:03.536]                     }
[13:22:03.536]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:03.536]                     base::options(mc.cores = 1L)
[13:22:03.536]                   }
[13:22:03.536]                   options(future.plan = NULL)
[13:22:03.536]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:03.536]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:03.536]                 }
[13:22:03.536]                 ...future.workdir <- getwd()
[13:22:03.536]             }
[13:22:03.536]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:03.536]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:03.536]         }
[13:22:03.536]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:03.536]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:22:03.536]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:03.536]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:03.536]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:03.536]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:03.536]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:03.536]             base::names(...future.oldOptions))
[13:22:03.536]     }
[13:22:03.536]     if (FALSE) {
[13:22:03.536]     }
[13:22:03.536]     else {
[13:22:03.536]         if (FALSE) {
[13:22:03.536]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:03.536]                 open = "w")
[13:22:03.536]         }
[13:22:03.536]         else {
[13:22:03.536]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:03.536]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:03.536]         }
[13:22:03.536]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:03.536]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:03.536]             base::sink(type = "output", split = FALSE)
[13:22:03.536]             base::close(...future.stdout)
[13:22:03.536]         }, add = TRUE)
[13:22:03.536]     }
[13:22:03.536]     ...future.frame <- base::sys.nframe()
[13:22:03.536]     ...future.conditions <- base::list()
[13:22:03.536]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:03.536]     if (FALSE) {
[13:22:03.536]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:03.536]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:03.536]     }
[13:22:03.536]     ...future.result <- base::tryCatch({
[13:22:03.536]         base::withCallingHandlers({
[13:22:03.536]             ...future.value <- base::withVisible(base::local({
[13:22:03.536]                 ...future.makeSendCondition <- base::local({
[13:22:03.536]                   sendCondition <- NULL
[13:22:03.536]                   function(frame = 1L) {
[13:22:03.536]                     if (is.function(sendCondition)) 
[13:22:03.536]                       return(sendCondition)
[13:22:03.536]                     ns <- getNamespace("parallel")
[13:22:03.536]                     if (exists("sendData", mode = "function", 
[13:22:03.536]                       envir = ns)) {
[13:22:03.536]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:03.536]                         envir = ns)
[13:22:03.536]                       envir <- sys.frame(frame)
[13:22:03.536]                       master <- NULL
[13:22:03.536]                       while (!identical(envir, .GlobalEnv) && 
[13:22:03.536]                         !identical(envir, emptyenv())) {
[13:22:03.536]                         if (exists("master", mode = "list", envir = envir, 
[13:22:03.536]                           inherits = FALSE)) {
[13:22:03.536]                           master <- get("master", mode = "list", 
[13:22:03.536]                             envir = envir, inherits = FALSE)
[13:22:03.536]                           if (inherits(master, c("SOCKnode", 
[13:22:03.536]                             "SOCK0node"))) {
[13:22:03.536]                             sendCondition <<- function(cond) {
[13:22:03.536]                               data <- list(type = "VALUE", value = cond, 
[13:22:03.536]                                 success = TRUE)
[13:22:03.536]                               parallel_sendData(master, data)
[13:22:03.536]                             }
[13:22:03.536]                             return(sendCondition)
[13:22:03.536]                           }
[13:22:03.536]                         }
[13:22:03.536]                         frame <- frame + 1L
[13:22:03.536]                         envir <- sys.frame(frame)
[13:22:03.536]                       }
[13:22:03.536]                     }
[13:22:03.536]                     sendCondition <<- function(cond) NULL
[13:22:03.536]                   }
[13:22:03.536]                 })
[13:22:03.536]                 withCallingHandlers({
[13:22:03.536]                   {
[13:22:03.536]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:03.536]                     if (!identical(...future.globals.maxSize.org, 
[13:22:03.536]                       ...future.globals.maxSize)) {
[13:22:03.536]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:03.536]                       on.exit(options(oopts), add = TRUE)
[13:22:03.536]                     }
[13:22:03.536]                     {
[13:22:03.536]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:22:03.536]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:22:03.536]                         USE.NAMES = FALSE)
[13:22:03.536]                       do.call(mapply, args = args)
[13:22:03.536]                     }
[13:22:03.536]                   }
[13:22:03.536]                 }, immediateCondition = function(cond) {
[13:22:03.536]                   sendCondition <- ...future.makeSendCondition()
[13:22:03.536]                   sendCondition(cond)
[13:22:03.536]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:03.536]                   {
[13:22:03.536]                     inherits <- base::inherits
[13:22:03.536]                     invokeRestart <- base::invokeRestart
[13:22:03.536]                     is.null <- base::is.null
[13:22:03.536]                     muffled <- FALSE
[13:22:03.536]                     if (inherits(cond, "message")) {
[13:22:03.536]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:03.536]                       if (muffled) 
[13:22:03.536]                         invokeRestart("muffleMessage")
[13:22:03.536]                     }
[13:22:03.536]                     else if (inherits(cond, "warning")) {
[13:22:03.536]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:03.536]                       if (muffled) 
[13:22:03.536]                         invokeRestart("muffleWarning")
[13:22:03.536]                     }
[13:22:03.536]                     else if (inherits(cond, "condition")) {
[13:22:03.536]                       if (!is.null(pattern)) {
[13:22:03.536]                         computeRestarts <- base::computeRestarts
[13:22:03.536]                         grepl <- base::grepl
[13:22:03.536]                         restarts <- computeRestarts(cond)
[13:22:03.536]                         for (restart in restarts) {
[13:22:03.536]                           name <- restart$name
[13:22:03.536]                           if (is.null(name)) 
[13:22:03.536]                             next
[13:22:03.536]                           if (!grepl(pattern, name)) 
[13:22:03.536]                             next
[13:22:03.536]                           invokeRestart(restart)
[13:22:03.536]                           muffled <- TRUE
[13:22:03.536]                           break
[13:22:03.536]                         }
[13:22:03.536]                       }
[13:22:03.536]                     }
[13:22:03.536]                     invisible(muffled)
[13:22:03.536]                   }
[13:22:03.536]                   muffleCondition(cond)
[13:22:03.536]                 })
[13:22:03.536]             }))
[13:22:03.536]             future::FutureResult(value = ...future.value$value, 
[13:22:03.536]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:03.536]                   ...future.rng), globalenv = if (FALSE) 
[13:22:03.536]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:03.536]                     ...future.globalenv.names))
[13:22:03.536]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:03.536]         }, condition = base::local({
[13:22:03.536]             c <- base::c
[13:22:03.536]             inherits <- base::inherits
[13:22:03.536]             invokeRestart <- base::invokeRestart
[13:22:03.536]             length <- base::length
[13:22:03.536]             list <- base::list
[13:22:03.536]             seq.int <- base::seq.int
[13:22:03.536]             signalCondition <- base::signalCondition
[13:22:03.536]             sys.calls <- base::sys.calls
[13:22:03.536]             `[[` <- base::`[[`
[13:22:03.536]             `+` <- base::`+`
[13:22:03.536]             `<<-` <- base::`<<-`
[13:22:03.536]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:03.536]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:03.536]                   3L)]
[13:22:03.536]             }
[13:22:03.536]             function(cond) {
[13:22:03.536]                 is_error <- inherits(cond, "error")
[13:22:03.536]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:03.536]                   NULL)
[13:22:03.536]                 if (is_error) {
[13:22:03.536]                   sessionInformation <- function() {
[13:22:03.536]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:03.536]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:03.536]                       search = base::search(), system = base::Sys.info())
[13:22:03.536]                   }
[13:22:03.536]                   ...future.conditions[[length(...future.conditions) + 
[13:22:03.536]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:03.536]                     cond$call), session = sessionInformation(), 
[13:22:03.536]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:03.536]                   signalCondition(cond)
[13:22:03.536]                 }
[13:22:03.536]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:03.536]                 "immediateCondition"))) {
[13:22:03.536]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:03.536]                   ...future.conditions[[length(...future.conditions) + 
[13:22:03.536]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:03.536]                   if (TRUE && !signal) {
[13:22:03.536]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:03.536]                     {
[13:22:03.536]                       inherits <- base::inherits
[13:22:03.536]                       invokeRestart <- base::invokeRestart
[13:22:03.536]                       is.null <- base::is.null
[13:22:03.536]                       muffled <- FALSE
[13:22:03.536]                       if (inherits(cond, "message")) {
[13:22:03.536]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:03.536]                         if (muffled) 
[13:22:03.536]                           invokeRestart("muffleMessage")
[13:22:03.536]                       }
[13:22:03.536]                       else if (inherits(cond, "warning")) {
[13:22:03.536]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:03.536]                         if (muffled) 
[13:22:03.536]                           invokeRestart("muffleWarning")
[13:22:03.536]                       }
[13:22:03.536]                       else if (inherits(cond, "condition")) {
[13:22:03.536]                         if (!is.null(pattern)) {
[13:22:03.536]                           computeRestarts <- base::computeRestarts
[13:22:03.536]                           grepl <- base::grepl
[13:22:03.536]                           restarts <- computeRestarts(cond)
[13:22:03.536]                           for (restart in restarts) {
[13:22:03.536]                             name <- restart$name
[13:22:03.536]                             if (is.null(name)) 
[13:22:03.536]                               next
[13:22:03.536]                             if (!grepl(pattern, name)) 
[13:22:03.536]                               next
[13:22:03.536]                             invokeRestart(restart)
[13:22:03.536]                             muffled <- TRUE
[13:22:03.536]                             break
[13:22:03.536]                           }
[13:22:03.536]                         }
[13:22:03.536]                       }
[13:22:03.536]                       invisible(muffled)
[13:22:03.536]                     }
[13:22:03.536]                     muffleCondition(cond, pattern = "^muffle")
[13:22:03.536]                   }
[13:22:03.536]                 }
[13:22:03.536]                 else {
[13:22:03.536]                   if (TRUE) {
[13:22:03.536]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:03.536]                     {
[13:22:03.536]                       inherits <- base::inherits
[13:22:03.536]                       invokeRestart <- base::invokeRestart
[13:22:03.536]                       is.null <- base::is.null
[13:22:03.536]                       muffled <- FALSE
[13:22:03.536]                       if (inherits(cond, "message")) {
[13:22:03.536]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:03.536]                         if (muffled) 
[13:22:03.536]                           invokeRestart("muffleMessage")
[13:22:03.536]                       }
[13:22:03.536]                       else if (inherits(cond, "warning")) {
[13:22:03.536]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:03.536]                         if (muffled) 
[13:22:03.536]                           invokeRestart("muffleWarning")
[13:22:03.536]                       }
[13:22:03.536]                       else if (inherits(cond, "condition")) {
[13:22:03.536]                         if (!is.null(pattern)) {
[13:22:03.536]                           computeRestarts <- base::computeRestarts
[13:22:03.536]                           grepl <- base::grepl
[13:22:03.536]                           restarts <- computeRestarts(cond)
[13:22:03.536]                           for (restart in restarts) {
[13:22:03.536]                             name <- restart$name
[13:22:03.536]                             if (is.null(name)) 
[13:22:03.536]                               next
[13:22:03.536]                             if (!grepl(pattern, name)) 
[13:22:03.536]                               next
[13:22:03.536]                             invokeRestart(restart)
[13:22:03.536]                             muffled <- TRUE
[13:22:03.536]                             break
[13:22:03.536]                           }
[13:22:03.536]                         }
[13:22:03.536]                       }
[13:22:03.536]                       invisible(muffled)
[13:22:03.536]                     }
[13:22:03.536]                     muffleCondition(cond, pattern = "^muffle")
[13:22:03.536]                   }
[13:22:03.536]                 }
[13:22:03.536]             }
[13:22:03.536]         }))
[13:22:03.536]     }, error = function(ex) {
[13:22:03.536]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:03.536]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:03.536]                 ...future.rng), started = ...future.startTime, 
[13:22:03.536]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:03.536]             version = "1.8"), class = "FutureResult")
[13:22:03.536]     }, finally = {
[13:22:03.536]         if (!identical(...future.workdir, getwd())) 
[13:22:03.536]             setwd(...future.workdir)
[13:22:03.536]         {
[13:22:03.536]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:03.536]                 ...future.oldOptions$nwarnings <- NULL
[13:22:03.536]             }
[13:22:03.536]             base::options(...future.oldOptions)
[13:22:03.536]             if (.Platform$OS.type == "windows") {
[13:22:03.536]                 old_names <- names(...future.oldEnvVars)
[13:22:03.536]                 envs <- base::Sys.getenv()
[13:22:03.536]                 names <- names(envs)
[13:22:03.536]                 common <- intersect(names, old_names)
[13:22:03.536]                 added <- setdiff(names, old_names)
[13:22:03.536]                 removed <- setdiff(old_names, names)
[13:22:03.536]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:03.536]                   envs[common]]
[13:22:03.536]                 NAMES <- toupper(changed)
[13:22:03.536]                 args <- list()
[13:22:03.536]                 for (kk in seq_along(NAMES)) {
[13:22:03.536]                   name <- changed[[kk]]
[13:22:03.536]                   NAME <- NAMES[[kk]]
[13:22:03.536]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:03.536]                     next
[13:22:03.536]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:03.536]                 }
[13:22:03.536]                 NAMES <- toupper(added)
[13:22:03.536]                 for (kk in seq_along(NAMES)) {
[13:22:03.536]                   name <- added[[kk]]
[13:22:03.536]                   NAME <- NAMES[[kk]]
[13:22:03.536]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:03.536]                     next
[13:22:03.536]                   args[[name]] <- ""
[13:22:03.536]                 }
[13:22:03.536]                 NAMES <- toupper(removed)
[13:22:03.536]                 for (kk in seq_along(NAMES)) {
[13:22:03.536]                   name <- removed[[kk]]
[13:22:03.536]                   NAME <- NAMES[[kk]]
[13:22:03.536]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:03.536]                     next
[13:22:03.536]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:03.536]                 }
[13:22:03.536]                 if (length(args) > 0) 
[13:22:03.536]                   base::do.call(base::Sys.setenv, args = args)
[13:22:03.536]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:03.536]             }
[13:22:03.536]             else {
[13:22:03.536]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:03.536]             }
[13:22:03.536]             {
[13:22:03.536]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:03.536]                   0L) {
[13:22:03.536]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:03.536]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:03.536]                   base::options(opts)
[13:22:03.536]                 }
[13:22:03.536]                 {
[13:22:03.536]                   {
[13:22:03.536]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:03.536]                     NULL
[13:22:03.536]                   }
[13:22:03.536]                   options(future.plan = NULL)
[13:22:03.536]                   if (is.na(NA_character_)) 
[13:22:03.536]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:03.536]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:03.536]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:03.536]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:03.536]                     envir = parent.frame()) 
[13:22:03.536]                   {
[13:22:03.536]                     if (is.function(workers)) 
[13:22:03.536]                       workers <- workers()
[13:22:03.536]                     workers <- structure(as.integer(workers), 
[13:22:03.536]                       class = class(workers))
[13:22:03.536]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:03.536]                       workers >= 1)
[13:22:03.536]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:03.536]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:03.536]                     }
[13:22:03.536]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:03.536]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:03.536]                       envir = envir)
[13:22:03.536]                     if (!future$lazy) 
[13:22:03.536]                       future <- run(future)
[13:22:03.536]                     invisible(future)
[13:22:03.536]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:03.536]                 }
[13:22:03.536]             }
[13:22:03.536]         }
[13:22:03.536]     })
[13:22:03.536]     if (TRUE) {
[13:22:03.536]         base::sink(type = "output", split = FALSE)
[13:22:03.536]         if (FALSE) {
[13:22:03.536]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:03.536]         }
[13:22:03.536]         else {
[13:22:03.536]             ...future.result["stdout"] <- base::list(NULL)
[13:22:03.536]         }
[13:22:03.536]         base::close(...future.stdout)
[13:22:03.536]         ...future.stdout <- NULL
[13:22:03.536]     }
[13:22:03.536]     ...future.result$conditions <- ...future.conditions
[13:22:03.536]     ...future.result$finished <- base::Sys.time()
[13:22:03.536]     ...future.result
[13:22:03.536] }
[13:22:03.539] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[13:22:03.539] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[13:22:03.539] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[13:22:03.539] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[13:22:03.540] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[13:22:03.540] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[13:22:03.540] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[13:22:03.540] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:22:03.541] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:22:03.541] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:22:03.541] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:22:03.541] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[13:22:03.542] MultisessionFuture started
[13:22:03.542] - Launch lazy future ... done
[13:22:03.542] run() for ‘MultisessionFuture’ ... done
[13:22:03.542] Created future:
[13:22:03.542] MultisessionFuture:
[13:22:03.542] Label: ‘future_mapply-2’
[13:22:03.542] Expression:
[13:22:03.542] {
[13:22:03.542]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:03.542]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:22:03.542]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:03.542]         on.exit(options(oopts), add = TRUE)
[13:22:03.542]     }
[13:22:03.542]     {
[13:22:03.542]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:22:03.542]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:22:03.542]         do.call(mapply, args = args)
[13:22:03.542]     }
[13:22:03.542] }
[13:22:03.542] Lazy evaluation: FALSE
[13:22:03.542] Asynchronous evaluation: TRUE
[13:22:03.542] Local evaluation: TRUE
[13:22:03.542] Environment: R_GlobalEnv
[13:22:03.542] Capture standard output: FALSE
[13:22:03.542] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:22:03.542] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:22:03.542] Packages: <none>
[13:22:03.542] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:22:03.542] Resolved: FALSE
[13:22:03.542] Value: <not collected>
[13:22:03.542] Conditions captured: <none>
[13:22:03.542] Early signaling: FALSE
[13:22:03.542] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:22:03.542] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:03.554] Chunk #2 of 2 ... DONE
[13:22:03.554] Launching 2 futures (chunks) ... DONE
[13:22:03.554] Resolving 2 futures (chunks) ...
[13:22:03.554] resolve() on list ...
[13:22:03.554]  recursive: 0
[13:22:03.554]  length: 2
[13:22:03.554] 
[13:22:03.597] receiveMessageFromWorker() for ClusterFuture ...
[13:22:03.597] - Validating connection of MultisessionFuture
[13:22:03.597] - received message: FutureResult
[13:22:03.597] - Received FutureResult
[13:22:03.597] - Erased future from FutureRegistry
[13:22:03.597] result() for ClusterFuture ...
[13:22:03.598] - result already collected: FutureResult
[13:22:03.598] result() for ClusterFuture ... done
[13:22:03.598] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:03.598] Future #2
[13:22:03.598] result() for ClusterFuture ...
[13:22:03.598] - result already collected: FutureResult
[13:22:03.598] result() for ClusterFuture ... done
[13:22:03.598] result() for ClusterFuture ...
[13:22:03.598] - result already collected: FutureResult
[13:22:03.598] result() for ClusterFuture ... done
[13:22:03.599] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:22:03.599] - nx: 2
[13:22:03.599] - relay: TRUE
[13:22:03.599] - stdout: TRUE
[13:22:03.599] - signal: TRUE
[13:22:03.599] - resignal: FALSE
[13:22:03.599] - force: TRUE
[13:22:03.599] - relayed: [n=2] FALSE, FALSE
[13:22:03.599] - queued futures: [n=2] FALSE, FALSE
[13:22:03.599]  - until=1
[13:22:03.599]  - relaying element #1
[13:22:03.599] - relayed: [n=2] FALSE, FALSE
[13:22:03.600] - queued futures: [n=2] FALSE, TRUE
[13:22:03.600] signalConditionsASAP(NULL, pos=2) ... done
[13:22:03.600]  length: 1 (resolved future 2)
[13:22:04.050] receiveMessageFromWorker() for ClusterFuture ...
[13:22:04.051] - Validating connection of MultisessionFuture
[13:22:04.051] - received message: FutureResult
[13:22:04.051] - Received FutureResult
[13:22:04.051] - Erased future from FutureRegistry
[13:22:04.051] result() for ClusterFuture ...
[13:22:04.051] - result already collected: FutureResult
[13:22:04.051] result() for ClusterFuture ... done
[13:22:04.051] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:04.051] Future #1
[13:22:04.052] result() for ClusterFuture ...
[13:22:04.052] - result already collected: FutureResult
[13:22:04.052] result() for ClusterFuture ... done
[13:22:04.052] result() for ClusterFuture ...
[13:22:04.052] - result already collected: FutureResult
[13:22:04.052] result() for ClusterFuture ... done
[13:22:04.052] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:22:04.052] - nx: 2
[13:22:04.052] - relay: TRUE
[13:22:04.052] - stdout: TRUE
[13:22:04.053] - signal: TRUE
[13:22:04.053] - resignal: FALSE
[13:22:04.053] - force: TRUE
[13:22:04.053] - relayed: [n=2] FALSE, FALSE
[13:22:04.053] - queued futures: [n=2] FALSE, TRUE
[13:22:04.053]  - until=1
[13:22:04.053]  - relaying element #1
[13:22:04.053] result() for ClusterFuture ...
[13:22:04.053] - result already collected: FutureResult
[13:22:04.053] result() for ClusterFuture ... done
[13:22:04.053] result() for ClusterFuture ...
[13:22:04.053] - result already collected: FutureResult
[13:22:04.054] result() for ClusterFuture ... done
[13:22:04.054] result() for ClusterFuture ...
[13:22:04.054] - result already collected: FutureResult
[13:22:04.054] result() for ClusterFuture ... done
[13:22:04.054] result() for ClusterFuture ...
[13:22:04.054] - result already collected: FutureResult
[13:22:04.054] result() for ClusterFuture ... done
[13:22:04.054] - relayed: [n=2] TRUE, FALSE
[13:22:04.054] - queued futures: [n=2] TRUE, TRUE
[13:22:04.054] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:22:04.054]  length: 0 (resolved future 1)
[13:22:04.055] Relaying remaining futures
[13:22:04.055] signalConditionsASAP(NULL, pos=0) ...
[13:22:04.055] - nx: 2
[13:22:04.055] - relay: TRUE
[13:22:04.055] - stdout: TRUE
[13:22:04.055] - signal: TRUE
[13:22:04.055] - resignal: FALSE
[13:22:04.055] - force: TRUE
[13:22:04.055] - relayed: [n=2] TRUE, FALSE
[13:22:04.055] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:22:04.055]  - relaying element #2
[13:22:04.056] result() for ClusterFuture ...
[13:22:04.056] - result already collected: FutureResult
[13:22:04.056] result() for ClusterFuture ... done
[13:22:04.056] result() for ClusterFuture ...
[13:22:04.056] - result already collected: FutureResult
[13:22:04.056] result() for ClusterFuture ... done
[13:22:04.056] result() for ClusterFuture ...
[13:22:04.056] - result already collected: FutureResult
[13:22:04.056] result() for ClusterFuture ... done
[13:22:04.056] result() for ClusterFuture ...
[13:22:04.056] - result already collected: FutureResult
[13:22:04.057] result() for ClusterFuture ... done
[13:22:04.057] - relayed: [n=2] TRUE, TRUE
[13:22:04.057] - queued futures: [n=2] TRUE, TRUE
[13:22:04.057] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[13:22:04.057] resolve() on list ... DONE
[13:22:04.057] result() for ClusterFuture ...
[13:22:04.057] - result already collected: FutureResult
[13:22:04.057] result() for ClusterFuture ... done
[13:22:04.057] result() for ClusterFuture ...
[13:22:04.057] - result already collected: FutureResult
[13:22:04.057] result() for ClusterFuture ... done
[13:22:04.057] result() for ClusterFuture ...
[13:22:04.058] - result already collected: FutureResult
[13:22:04.058] result() for ClusterFuture ... done
[13:22:04.058] result() for ClusterFuture ...
[13:22:04.058] - result already collected: FutureResult
[13:22:04.058] result() for ClusterFuture ... done
[13:22:04.058]  - Number of value chunks collected: 2
[13:22:04.058] Resolving 2 futures (chunks) ... DONE
[13:22:04.058] Reducing values from 2 chunks ...
[13:22:04.058]  - Number of values collected after concatenation: 2
[13:22:04.058]  - Number of values expected: 2
[13:22:04.058] Reducing values from 2 chunks ... DONE
[13:22:04.059] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[13:22:04.059] future_mapply() ...
[13:22:04.063] Number of chunks: 2
[13:22:04.063] getGlobalsAndPackagesXApply() ...
[13:22:04.063]  - future.globals: TRUE
[13:22:04.063] getGlobalsAndPackages() ...
[13:22:04.063] Searching for globals...
[13:22:04.065] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:22:04.065] Searching for globals ... DONE
[13:22:04.065] Resolving globals: FALSE
[13:22:04.065] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:22:04.066] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:22:04.066] - globals: [1] ‘FUN’
[13:22:04.066] 
[13:22:04.066] getGlobalsAndPackages() ... DONE
[13:22:04.066]  - globals found/used: [n=1] ‘FUN’
[13:22:04.066]  - needed namespaces: [n=0] 
[13:22:04.066] Finding globals ... DONE
[13:22:04.067] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:22:04.067] List of 2
[13:22:04.067]  $ ...future.FUN:function (x, y)  
[13:22:04.067]  $ MoreArgs     : NULL
[13:22:04.067]  - attr(*, "where")=List of 2
[13:22:04.067]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:22:04.067]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:22:04.067]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:22:04.067]  - attr(*, "resolved")= logi FALSE
[13:22:04.067]  - attr(*, "total_size")= num NA
[13:22:04.069] Packages to be attached in all futures: [n=0] 
[13:22:04.069] getGlobalsAndPackagesXApply() ... DONE
[13:22:04.069] Number of futures (= number of chunks): 2
[13:22:04.070] Launching 2 futures (chunks) ...
[13:22:04.070] Chunk #1 of 2 ...
[13:22:04.070]  - Finding globals in '...' for chunk #1 ...
[13:22:04.070] getGlobalsAndPackages() ...
[13:22:04.070] Searching for globals...
[13:22:04.070] 
[13:22:04.070] Searching for globals ... DONE
[13:22:04.070] - globals: [0] <none>
[13:22:04.070] getGlobalsAndPackages() ... DONE
[13:22:04.071]    + additional globals found: [n=0] 
[13:22:04.071]    + additional namespaces needed: [n=0] 
[13:22:04.071]  - Finding globals in '...' for chunk #1 ... DONE
[13:22:04.071]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:22:04.071]  - seeds: <none>
[13:22:04.071]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:04.071] getGlobalsAndPackages() ...
[13:22:04.071] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:04.071] Resolving globals: FALSE
[13:22:04.072] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:22:04.072] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:22:04.072] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:04.072] 
[13:22:04.073] getGlobalsAndPackages() ... DONE
[13:22:04.073] run() for ‘Future’ ...
[13:22:04.073] - state: ‘created’
[13:22:04.073] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:04.087] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:04.087] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:04.087]   - Field: ‘node’
[13:22:04.087]   - Field: ‘label’
[13:22:04.087]   - Field: ‘local’
[13:22:04.088]   - Field: ‘owner’
[13:22:04.088]   - Field: ‘envir’
[13:22:04.088]   - Field: ‘workers’
[13:22:04.088]   - Field: ‘packages’
[13:22:04.088]   - Field: ‘gc’
[13:22:04.088]   - Field: ‘conditions’
[13:22:04.088]   - Field: ‘persistent’
[13:22:04.088]   - Field: ‘expr’
[13:22:04.088]   - Field: ‘uuid’
[13:22:04.088]   - Field: ‘seed’
[13:22:04.089]   - Field: ‘version’
[13:22:04.089]   - Field: ‘result’
[13:22:04.089]   - Field: ‘asynchronous’
[13:22:04.089]   - Field: ‘calls’
[13:22:04.089]   - Field: ‘globals’
[13:22:04.089]   - Field: ‘stdout’
[13:22:04.089]   - Field: ‘earlySignal’
[13:22:04.089]   - Field: ‘lazy’
[13:22:04.089]   - Field: ‘state’
[13:22:04.089] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:04.089] - Launch lazy future ...
[13:22:04.090] Packages needed by the future expression (n = 0): <none>
[13:22:04.090] Packages needed by future strategies (n = 0): <none>
[13:22:04.090] {
[13:22:04.090]     {
[13:22:04.090]         {
[13:22:04.090]             ...future.startTime <- base::Sys.time()
[13:22:04.090]             {
[13:22:04.090]                 {
[13:22:04.090]                   {
[13:22:04.090]                     {
[13:22:04.090]                       base::local({
[13:22:04.090]                         has_future <- base::requireNamespace("future", 
[13:22:04.090]                           quietly = TRUE)
[13:22:04.090]                         if (has_future) {
[13:22:04.090]                           ns <- base::getNamespace("future")
[13:22:04.090]                           version <- ns[[".package"]][["version"]]
[13:22:04.090]                           if (is.null(version)) 
[13:22:04.090]                             version <- utils::packageVersion("future")
[13:22:04.090]                         }
[13:22:04.090]                         else {
[13:22:04.090]                           version <- NULL
[13:22:04.090]                         }
[13:22:04.090]                         if (!has_future || version < "1.8.0") {
[13:22:04.090]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:04.090]                             "", base::R.version$version.string), 
[13:22:04.090]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:04.090]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:04.090]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:04.090]                               "release", "version")], collapse = " "), 
[13:22:04.090]                             hostname = base::Sys.info()[["nodename"]])
[13:22:04.090]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:04.090]                             info)
[13:22:04.090]                           info <- base::paste(info, collapse = "; ")
[13:22:04.090]                           if (!has_future) {
[13:22:04.090]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:04.090]                               info)
[13:22:04.090]                           }
[13:22:04.090]                           else {
[13:22:04.090]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:04.090]                               info, version)
[13:22:04.090]                           }
[13:22:04.090]                           base::stop(msg)
[13:22:04.090]                         }
[13:22:04.090]                       })
[13:22:04.090]                     }
[13:22:04.090]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:04.090]                     base::options(mc.cores = 1L)
[13:22:04.090]                   }
[13:22:04.090]                   options(future.plan = NULL)
[13:22:04.090]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:04.090]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:04.090]                 }
[13:22:04.090]                 ...future.workdir <- getwd()
[13:22:04.090]             }
[13:22:04.090]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:04.090]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:04.090]         }
[13:22:04.090]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:04.090]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:22:04.090]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:04.090]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:04.090]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:04.090]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:04.090]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:04.090]             base::names(...future.oldOptions))
[13:22:04.090]     }
[13:22:04.090]     if (FALSE) {
[13:22:04.090]     }
[13:22:04.090]     else {
[13:22:04.090]         if (TRUE) {
[13:22:04.090]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:04.090]                 open = "w")
[13:22:04.090]         }
[13:22:04.090]         else {
[13:22:04.090]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:04.090]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:04.090]         }
[13:22:04.090]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:04.090]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:04.090]             base::sink(type = "output", split = FALSE)
[13:22:04.090]             base::close(...future.stdout)
[13:22:04.090]         }, add = TRUE)
[13:22:04.090]     }
[13:22:04.090]     ...future.frame <- base::sys.nframe()
[13:22:04.090]     ...future.conditions <- base::list()
[13:22:04.090]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:04.090]     if (FALSE) {
[13:22:04.090]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:04.090]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:04.090]     }
[13:22:04.090]     ...future.result <- base::tryCatch({
[13:22:04.090]         base::withCallingHandlers({
[13:22:04.090]             ...future.value <- base::withVisible(base::local({
[13:22:04.090]                 ...future.makeSendCondition <- base::local({
[13:22:04.090]                   sendCondition <- NULL
[13:22:04.090]                   function(frame = 1L) {
[13:22:04.090]                     if (is.function(sendCondition)) 
[13:22:04.090]                       return(sendCondition)
[13:22:04.090]                     ns <- getNamespace("parallel")
[13:22:04.090]                     if (exists("sendData", mode = "function", 
[13:22:04.090]                       envir = ns)) {
[13:22:04.090]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:04.090]                         envir = ns)
[13:22:04.090]                       envir <- sys.frame(frame)
[13:22:04.090]                       master <- NULL
[13:22:04.090]                       while (!identical(envir, .GlobalEnv) && 
[13:22:04.090]                         !identical(envir, emptyenv())) {
[13:22:04.090]                         if (exists("master", mode = "list", envir = envir, 
[13:22:04.090]                           inherits = FALSE)) {
[13:22:04.090]                           master <- get("master", mode = "list", 
[13:22:04.090]                             envir = envir, inherits = FALSE)
[13:22:04.090]                           if (inherits(master, c("SOCKnode", 
[13:22:04.090]                             "SOCK0node"))) {
[13:22:04.090]                             sendCondition <<- function(cond) {
[13:22:04.090]                               data <- list(type = "VALUE", value = cond, 
[13:22:04.090]                                 success = TRUE)
[13:22:04.090]                               parallel_sendData(master, data)
[13:22:04.090]                             }
[13:22:04.090]                             return(sendCondition)
[13:22:04.090]                           }
[13:22:04.090]                         }
[13:22:04.090]                         frame <- frame + 1L
[13:22:04.090]                         envir <- sys.frame(frame)
[13:22:04.090]                       }
[13:22:04.090]                     }
[13:22:04.090]                     sendCondition <<- function(cond) NULL
[13:22:04.090]                   }
[13:22:04.090]                 })
[13:22:04.090]                 withCallingHandlers({
[13:22:04.090]                   {
[13:22:04.090]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:04.090]                     if (!identical(...future.globals.maxSize.org, 
[13:22:04.090]                       ...future.globals.maxSize)) {
[13:22:04.090]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:04.090]                       on.exit(options(oopts), add = TRUE)
[13:22:04.090]                     }
[13:22:04.090]                     {
[13:22:04.090]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:22:04.090]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:22:04.090]                         USE.NAMES = FALSE)
[13:22:04.090]                       do.call(mapply, args = args)
[13:22:04.090]                     }
[13:22:04.090]                   }
[13:22:04.090]                 }, immediateCondition = function(cond) {
[13:22:04.090]                   sendCondition <- ...future.makeSendCondition()
[13:22:04.090]                   sendCondition(cond)
[13:22:04.090]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:04.090]                   {
[13:22:04.090]                     inherits <- base::inherits
[13:22:04.090]                     invokeRestart <- base::invokeRestart
[13:22:04.090]                     is.null <- base::is.null
[13:22:04.090]                     muffled <- FALSE
[13:22:04.090]                     if (inherits(cond, "message")) {
[13:22:04.090]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:04.090]                       if (muffled) 
[13:22:04.090]                         invokeRestart("muffleMessage")
[13:22:04.090]                     }
[13:22:04.090]                     else if (inherits(cond, "warning")) {
[13:22:04.090]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:04.090]                       if (muffled) 
[13:22:04.090]                         invokeRestart("muffleWarning")
[13:22:04.090]                     }
[13:22:04.090]                     else if (inherits(cond, "condition")) {
[13:22:04.090]                       if (!is.null(pattern)) {
[13:22:04.090]                         computeRestarts <- base::computeRestarts
[13:22:04.090]                         grepl <- base::grepl
[13:22:04.090]                         restarts <- computeRestarts(cond)
[13:22:04.090]                         for (restart in restarts) {
[13:22:04.090]                           name <- restart$name
[13:22:04.090]                           if (is.null(name)) 
[13:22:04.090]                             next
[13:22:04.090]                           if (!grepl(pattern, name)) 
[13:22:04.090]                             next
[13:22:04.090]                           invokeRestart(restart)
[13:22:04.090]                           muffled <- TRUE
[13:22:04.090]                           break
[13:22:04.090]                         }
[13:22:04.090]                       }
[13:22:04.090]                     }
[13:22:04.090]                     invisible(muffled)
[13:22:04.090]                   }
[13:22:04.090]                   muffleCondition(cond)
[13:22:04.090]                 })
[13:22:04.090]             }))
[13:22:04.090]             future::FutureResult(value = ...future.value$value, 
[13:22:04.090]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:04.090]                   ...future.rng), globalenv = if (FALSE) 
[13:22:04.090]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:04.090]                     ...future.globalenv.names))
[13:22:04.090]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:04.090]         }, condition = base::local({
[13:22:04.090]             c <- base::c
[13:22:04.090]             inherits <- base::inherits
[13:22:04.090]             invokeRestart <- base::invokeRestart
[13:22:04.090]             length <- base::length
[13:22:04.090]             list <- base::list
[13:22:04.090]             seq.int <- base::seq.int
[13:22:04.090]             signalCondition <- base::signalCondition
[13:22:04.090]             sys.calls <- base::sys.calls
[13:22:04.090]             `[[` <- base::`[[`
[13:22:04.090]             `+` <- base::`+`
[13:22:04.090]             `<<-` <- base::`<<-`
[13:22:04.090]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:04.090]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:04.090]                   3L)]
[13:22:04.090]             }
[13:22:04.090]             function(cond) {
[13:22:04.090]                 is_error <- inherits(cond, "error")
[13:22:04.090]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:04.090]                   NULL)
[13:22:04.090]                 if (is_error) {
[13:22:04.090]                   sessionInformation <- function() {
[13:22:04.090]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:04.090]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:04.090]                       search = base::search(), system = base::Sys.info())
[13:22:04.090]                   }
[13:22:04.090]                   ...future.conditions[[length(...future.conditions) + 
[13:22:04.090]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:04.090]                     cond$call), session = sessionInformation(), 
[13:22:04.090]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:04.090]                   signalCondition(cond)
[13:22:04.090]                 }
[13:22:04.090]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:04.090]                 "immediateCondition"))) {
[13:22:04.090]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:04.090]                   ...future.conditions[[length(...future.conditions) + 
[13:22:04.090]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:04.090]                   if (TRUE && !signal) {
[13:22:04.090]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:04.090]                     {
[13:22:04.090]                       inherits <- base::inherits
[13:22:04.090]                       invokeRestart <- base::invokeRestart
[13:22:04.090]                       is.null <- base::is.null
[13:22:04.090]                       muffled <- FALSE
[13:22:04.090]                       if (inherits(cond, "message")) {
[13:22:04.090]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:04.090]                         if (muffled) 
[13:22:04.090]                           invokeRestart("muffleMessage")
[13:22:04.090]                       }
[13:22:04.090]                       else if (inherits(cond, "warning")) {
[13:22:04.090]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:04.090]                         if (muffled) 
[13:22:04.090]                           invokeRestart("muffleWarning")
[13:22:04.090]                       }
[13:22:04.090]                       else if (inherits(cond, "condition")) {
[13:22:04.090]                         if (!is.null(pattern)) {
[13:22:04.090]                           computeRestarts <- base::computeRestarts
[13:22:04.090]                           grepl <- base::grepl
[13:22:04.090]                           restarts <- computeRestarts(cond)
[13:22:04.090]                           for (restart in restarts) {
[13:22:04.090]                             name <- restart$name
[13:22:04.090]                             if (is.null(name)) 
[13:22:04.090]                               next
[13:22:04.090]                             if (!grepl(pattern, name)) 
[13:22:04.090]                               next
[13:22:04.090]                             invokeRestart(restart)
[13:22:04.090]                             muffled <- TRUE
[13:22:04.090]                             break
[13:22:04.090]                           }
[13:22:04.090]                         }
[13:22:04.090]                       }
[13:22:04.090]                       invisible(muffled)
[13:22:04.090]                     }
[13:22:04.090]                     muffleCondition(cond, pattern = "^muffle")
[13:22:04.090]                   }
[13:22:04.090]                 }
[13:22:04.090]                 else {
[13:22:04.090]                   if (TRUE) {
[13:22:04.090]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:04.090]                     {
[13:22:04.090]                       inherits <- base::inherits
[13:22:04.090]                       invokeRestart <- base::invokeRestart
[13:22:04.090]                       is.null <- base::is.null
[13:22:04.090]                       muffled <- FALSE
[13:22:04.090]                       if (inherits(cond, "message")) {
[13:22:04.090]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:04.090]                         if (muffled) 
[13:22:04.090]                           invokeRestart("muffleMessage")
[13:22:04.090]                       }
[13:22:04.090]                       else if (inherits(cond, "warning")) {
[13:22:04.090]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:04.090]                         if (muffled) 
[13:22:04.090]                           invokeRestart("muffleWarning")
[13:22:04.090]                       }
[13:22:04.090]                       else if (inherits(cond, "condition")) {
[13:22:04.090]                         if (!is.null(pattern)) {
[13:22:04.090]                           computeRestarts <- base::computeRestarts
[13:22:04.090]                           grepl <- base::grepl
[13:22:04.090]                           restarts <- computeRestarts(cond)
[13:22:04.090]                           for (restart in restarts) {
[13:22:04.090]                             name <- restart$name
[13:22:04.090]                             if (is.null(name)) 
[13:22:04.090]                               next
[13:22:04.090]                             if (!grepl(pattern, name)) 
[13:22:04.090]                               next
[13:22:04.090]                             invokeRestart(restart)
[13:22:04.090]                             muffled <- TRUE
[13:22:04.090]                             break
[13:22:04.090]                           }
[13:22:04.090]                         }
[13:22:04.090]                       }
[13:22:04.090]                       invisible(muffled)
[13:22:04.090]                     }
[13:22:04.090]                     muffleCondition(cond, pattern = "^muffle")
[13:22:04.090]                   }
[13:22:04.090]                 }
[13:22:04.090]             }
[13:22:04.090]         }))
[13:22:04.090]     }, error = function(ex) {
[13:22:04.090]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:04.090]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:04.090]                 ...future.rng), started = ...future.startTime, 
[13:22:04.090]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:04.090]             version = "1.8"), class = "FutureResult")
[13:22:04.090]     }, finally = {
[13:22:04.090]         if (!identical(...future.workdir, getwd())) 
[13:22:04.090]             setwd(...future.workdir)
[13:22:04.090]         {
[13:22:04.090]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:04.090]                 ...future.oldOptions$nwarnings <- NULL
[13:22:04.090]             }
[13:22:04.090]             base::options(...future.oldOptions)
[13:22:04.090]             if (.Platform$OS.type == "windows") {
[13:22:04.090]                 old_names <- names(...future.oldEnvVars)
[13:22:04.090]                 envs <- base::Sys.getenv()
[13:22:04.090]                 names <- names(envs)
[13:22:04.090]                 common <- intersect(names, old_names)
[13:22:04.090]                 added <- setdiff(names, old_names)
[13:22:04.090]                 removed <- setdiff(old_names, names)
[13:22:04.090]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:04.090]                   envs[common]]
[13:22:04.090]                 NAMES <- toupper(changed)
[13:22:04.090]                 args <- list()
[13:22:04.090]                 for (kk in seq_along(NAMES)) {
[13:22:04.090]                   name <- changed[[kk]]
[13:22:04.090]                   NAME <- NAMES[[kk]]
[13:22:04.090]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:04.090]                     next
[13:22:04.090]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:04.090]                 }
[13:22:04.090]                 NAMES <- toupper(added)
[13:22:04.090]                 for (kk in seq_along(NAMES)) {
[13:22:04.090]                   name <- added[[kk]]
[13:22:04.090]                   NAME <- NAMES[[kk]]
[13:22:04.090]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:04.090]                     next
[13:22:04.090]                   args[[name]] <- ""
[13:22:04.090]                 }
[13:22:04.090]                 NAMES <- toupper(removed)
[13:22:04.090]                 for (kk in seq_along(NAMES)) {
[13:22:04.090]                   name <- removed[[kk]]
[13:22:04.090]                   NAME <- NAMES[[kk]]
[13:22:04.090]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:04.090]                     next
[13:22:04.090]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:04.090]                 }
[13:22:04.090]                 if (length(args) > 0) 
[13:22:04.090]                   base::do.call(base::Sys.setenv, args = args)
[13:22:04.090]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:04.090]             }
[13:22:04.090]             else {
[13:22:04.090]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:04.090]             }
[13:22:04.090]             {
[13:22:04.090]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:04.090]                   0L) {
[13:22:04.090]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:04.090]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:04.090]                   base::options(opts)
[13:22:04.090]                 }
[13:22:04.090]                 {
[13:22:04.090]                   {
[13:22:04.090]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:04.090]                     NULL
[13:22:04.090]                   }
[13:22:04.090]                   options(future.plan = NULL)
[13:22:04.090]                   if (is.na(NA_character_)) 
[13:22:04.090]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:04.090]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:04.090]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:04.090]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:04.090]                     envir = parent.frame()) 
[13:22:04.090]                   {
[13:22:04.090]                     if (is.function(workers)) 
[13:22:04.090]                       workers <- workers()
[13:22:04.090]                     workers <- structure(as.integer(workers), 
[13:22:04.090]                       class = class(workers))
[13:22:04.090]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:04.090]                       workers >= 1)
[13:22:04.090]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:04.090]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:04.090]                     }
[13:22:04.090]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:04.090]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:04.090]                       envir = envir)
[13:22:04.090]                     if (!future$lazy) 
[13:22:04.090]                       future <- run(future)
[13:22:04.090]                     invisible(future)
[13:22:04.090]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:04.090]                 }
[13:22:04.090]             }
[13:22:04.090]         }
[13:22:04.090]     })
[13:22:04.090]     if (TRUE) {
[13:22:04.090]         base::sink(type = "output", split = FALSE)
[13:22:04.090]         if (TRUE) {
[13:22:04.090]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:04.090]         }
[13:22:04.090]         else {
[13:22:04.090]             ...future.result["stdout"] <- base::list(NULL)
[13:22:04.090]         }
[13:22:04.090]         base::close(...future.stdout)
[13:22:04.090]         ...future.stdout <- NULL
[13:22:04.090]     }
[13:22:04.090]     ...future.result$conditions <- ...future.conditions
[13:22:04.090]     ...future.result$finished <- base::Sys.time()
[13:22:04.090]     ...future.result
[13:22:04.090] }
[13:22:04.093] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[13:22:04.093] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[13:22:04.094] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[13:22:04.094] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[13:22:04.094] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[13:22:04.094] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[13:22:04.095] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[13:22:04.095] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:22:04.095] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:22:04.095] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:22:04.096] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:22:04.096] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[13:22:04.096] MultisessionFuture started
[13:22:04.097] - Launch lazy future ... done
[13:22:04.097] run() for ‘MultisessionFuture’ ... done
[13:22:04.097] Created future:
[13:22:04.097] MultisessionFuture:
[13:22:04.097] Label: ‘future_mapply-1’
[13:22:04.097] Expression:
[13:22:04.097] {
[13:22:04.097]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:04.097]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:22:04.097]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:04.097]         on.exit(options(oopts), add = TRUE)
[13:22:04.097]     }
[13:22:04.097]     {
[13:22:04.097]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:22:04.097]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:22:04.097]         do.call(mapply, args = args)
[13:22:04.097]     }
[13:22:04.097] }
[13:22:04.097] Lazy evaluation: FALSE
[13:22:04.097] Asynchronous evaluation: TRUE
[13:22:04.097] Local evaluation: TRUE
[13:22:04.097] Environment: R_GlobalEnv
[13:22:04.097] Capture standard output: TRUE
[13:22:04.097] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:22:04.097] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:22:04.097] Packages: <none>
[13:22:04.097] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:22:04.097] Resolved: FALSE
[13:22:04.097] Value: <not collected>
[13:22:04.097] Conditions captured: <none>
[13:22:04.097] Early signaling: FALSE
[13:22:04.097] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:22:04.097] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:04.108] Chunk #1 of 2 ... DONE
[13:22:04.109] Chunk #2 of 2 ...
[13:22:04.109]  - Finding globals in '...' for chunk #2 ...
[13:22:04.109] getGlobalsAndPackages() ...
[13:22:04.109] Searching for globals...
[13:22:04.109] 
[13:22:04.109] Searching for globals ... DONE
[13:22:04.109] - globals: [0] <none>
[13:22:04.110] getGlobalsAndPackages() ... DONE
[13:22:04.110]    + additional globals found: [n=0] 
[13:22:04.110]    + additional namespaces needed: [n=0] 
[13:22:04.110]  - Finding globals in '...' for chunk #2 ... DONE
[13:22:04.110]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:22:04.110]  - seeds: <none>
[13:22:04.110]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:04.110] getGlobalsAndPackages() ...
[13:22:04.110] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:04.110] Resolving globals: FALSE
[13:22:04.111] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:22:04.111] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:22:04.111] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:04.112] 
[13:22:04.112] getGlobalsAndPackages() ... DONE
[13:22:04.112] run() for ‘Future’ ...
[13:22:04.112] - state: ‘created’
[13:22:04.112] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:04.129] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:04.130] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:04.130]   - Field: ‘node’
[13:22:04.130]   - Field: ‘label’
[13:22:04.130]   - Field: ‘local’
[13:22:04.130]   - Field: ‘owner’
[13:22:04.130]   - Field: ‘envir’
[13:22:04.130]   - Field: ‘workers’
[13:22:04.130]   - Field: ‘packages’
[13:22:04.130]   - Field: ‘gc’
[13:22:04.131]   - Field: ‘conditions’
[13:22:04.131]   - Field: ‘persistent’
[13:22:04.131]   - Field: ‘expr’
[13:22:04.131]   - Field: ‘uuid’
[13:22:04.131]   - Field: ‘seed’
[13:22:04.131]   - Field: ‘version’
[13:22:04.131]   - Field: ‘result’
[13:22:04.131]   - Field: ‘asynchronous’
[13:22:04.131]   - Field: ‘calls’
[13:22:04.131]   - Field: ‘globals’
[13:22:04.131]   - Field: ‘stdout’
[13:22:04.131]   - Field: ‘earlySignal’
[13:22:04.132]   - Field: ‘lazy’
[13:22:04.132]   - Field: ‘state’
[13:22:04.132] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:04.132] - Launch lazy future ...
[13:22:04.132] Packages needed by the future expression (n = 0): <none>
[13:22:04.132] Packages needed by future strategies (n = 0): <none>
[13:22:04.133] {
[13:22:04.133]     {
[13:22:04.133]         {
[13:22:04.133]             ...future.startTime <- base::Sys.time()
[13:22:04.133]             {
[13:22:04.133]                 {
[13:22:04.133]                   {
[13:22:04.133]                     {
[13:22:04.133]                       base::local({
[13:22:04.133]                         has_future <- base::requireNamespace("future", 
[13:22:04.133]                           quietly = TRUE)
[13:22:04.133]                         if (has_future) {
[13:22:04.133]                           ns <- base::getNamespace("future")
[13:22:04.133]                           version <- ns[[".package"]][["version"]]
[13:22:04.133]                           if (is.null(version)) 
[13:22:04.133]                             version <- utils::packageVersion("future")
[13:22:04.133]                         }
[13:22:04.133]                         else {
[13:22:04.133]                           version <- NULL
[13:22:04.133]                         }
[13:22:04.133]                         if (!has_future || version < "1.8.0") {
[13:22:04.133]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:04.133]                             "", base::R.version$version.string), 
[13:22:04.133]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:04.133]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:04.133]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:04.133]                               "release", "version")], collapse = " "), 
[13:22:04.133]                             hostname = base::Sys.info()[["nodename"]])
[13:22:04.133]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:04.133]                             info)
[13:22:04.133]                           info <- base::paste(info, collapse = "; ")
[13:22:04.133]                           if (!has_future) {
[13:22:04.133]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:04.133]                               info)
[13:22:04.133]                           }
[13:22:04.133]                           else {
[13:22:04.133]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:04.133]                               info, version)
[13:22:04.133]                           }
[13:22:04.133]                           base::stop(msg)
[13:22:04.133]                         }
[13:22:04.133]                       })
[13:22:04.133]                     }
[13:22:04.133]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:04.133]                     base::options(mc.cores = 1L)
[13:22:04.133]                   }
[13:22:04.133]                   options(future.plan = NULL)
[13:22:04.133]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:04.133]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:04.133]                 }
[13:22:04.133]                 ...future.workdir <- getwd()
[13:22:04.133]             }
[13:22:04.133]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:04.133]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:04.133]         }
[13:22:04.133]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:04.133]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:22:04.133]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:04.133]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:04.133]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:04.133]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:04.133]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:04.133]             base::names(...future.oldOptions))
[13:22:04.133]     }
[13:22:04.133]     if (FALSE) {
[13:22:04.133]     }
[13:22:04.133]     else {
[13:22:04.133]         if (TRUE) {
[13:22:04.133]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:04.133]                 open = "w")
[13:22:04.133]         }
[13:22:04.133]         else {
[13:22:04.133]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:04.133]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:04.133]         }
[13:22:04.133]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:04.133]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:04.133]             base::sink(type = "output", split = FALSE)
[13:22:04.133]             base::close(...future.stdout)
[13:22:04.133]         }, add = TRUE)
[13:22:04.133]     }
[13:22:04.133]     ...future.frame <- base::sys.nframe()
[13:22:04.133]     ...future.conditions <- base::list()
[13:22:04.133]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:04.133]     if (FALSE) {
[13:22:04.133]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:04.133]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:04.133]     }
[13:22:04.133]     ...future.result <- base::tryCatch({
[13:22:04.133]         base::withCallingHandlers({
[13:22:04.133]             ...future.value <- base::withVisible(base::local({
[13:22:04.133]                 ...future.makeSendCondition <- base::local({
[13:22:04.133]                   sendCondition <- NULL
[13:22:04.133]                   function(frame = 1L) {
[13:22:04.133]                     if (is.function(sendCondition)) 
[13:22:04.133]                       return(sendCondition)
[13:22:04.133]                     ns <- getNamespace("parallel")
[13:22:04.133]                     if (exists("sendData", mode = "function", 
[13:22:04.133]                       envir = ns)) {
[13:22:04.133]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:04.133]                         envir = ns)
[13:22:04.133]                       envir <- sys.frame(frame)
[13:22:04.133]                       master <- NULL
[13:22:04.133]                       while (!identical(envir, .GlobalEnv) && 
[13:22:04.133]                         !identical(envir, emptyenv())) {
[13:22:04.133]                         if (exists("master", mode = "list", envir = envir, 
[13:22:04.133]                           inherits = FALSE)) {
[13:22:04.133]                           master <- get("master", mode = "list", 
[13:22:04.133]                             envir = envir, inherits = FALSE)
[13:22:04.133]                           if (inherits(master, c("SOCKnode", 
[13:22:04.133]                             "SOCK0node"))) {
[13:22:04.133]                             sendCondition <<- function(cond) {
[13:22:04.133]                               data <- list(type = "VALUE", value = cond, 
[13:22:04.133]                                 success = TRUE)
[13:22:04.133]                               parallel_sendData(master, data)
[13:22:04.133]                             }
[13:22:04.133]                             return(sendCondition)
[13:22:04.133]                           }
[13:22:04.133]                         }
[13:22:04.133]                         frame <- frame + 1L
[13:22:04.133]                         envir <- sys.frame(frame)
[13:22:04.133]                       }
[13:22:04.133]                     }
[13:22:04.133]                     sendCondition <<- function(cond) NULL
[13:22:04.133]                   }
[13:22:04.133]                 })
[13:22:04.133]                 withCallingHandlers({
[13:22:04.133]                   {
[13:22:04.133]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:04.133]                     if (!identical(...future.globals.maxSize.org, 
[13:22:04.133]                       ...future.globals.maxSize)) {
[13:22:04.133]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:04.133]                       on.exit(options(oopts), add = TRUE)
[13:22:04.133]                     }
[13:22:04.133]                     {
[13:22:04.133]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:22:04.133]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:22:04.133]                         USE.NAMES = FALSE)
[13:22:04.133]                       do.call(mapply, args = args)
[13:22:04.133]                     }
[13:22:04.133]                   }
[13:22:04.133]                 }, immediateCondition = function(cond) {
[13:22:04.133]                   sendCondition <- ...future.makeSendCondition()
[13:22:04.133]                   sendCondition(cond)
[13:22:04.133]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:04.133]                   {
[13:22:04.133]                     inherits <- base::inherits
[13:22:04.133]                     invokeRestart <- base::invokeRestart
[13:22:04.133]                     is.null <- base::is.null
[13:22:04.133]                     muffled <- FALSE
[13:22:04.133]                     if (inherits(cond, "message")) {
[13:22:04.133]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:04.133]                       if (muffled) 
[13:22:04.133]                         invokeRestart("muffleMessage")
[13:22:04.133]                     }
[13:22:04.133]                     else if (inherits(cond, "warning")) {
[13:22:04.133]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:04.133]                       if (muffled) 
[13:22:04.133]                         invokeRestart("muffleWarning")
[13:22:04.133]                     }
[13:22:04.133]                     else if (inherits(cond, "condition")) {
[13:22:04.133]                       if (!is.null(pattern)) {
[13:22:04.133]                         computeRestarts <- base::computeRestarts
[13:22:04.133]                         grepl <- base::grepl
[13:22:04.133]                         restarts <- computeRestarts(cond)
[13:22:04.133]                         for (restart in restarts) {
[13:22:04.133]                           name <- restart$name
[13:22:04.133]                           if (is.null(name)) 
[13:22:04.133]                             next
[13:22:04.133]                           if (!grepl(pattern, name)) 
[13:22:04.133]                             next
[13:22:04.133]                           invokeRestart(restart)
[13:22:04.133]                           muffled <- TRUE
[13:22:04.133]                           break
[13:22:04.133]                         }
[13:22:04.133]                       }
[13:22:04.133]                     }
[13:22:04.133]                     invisible(muffled)
[13:22:04.133]                   }
[13:22:04.133]                   muffleCondition(cond)
[13:22:04.133]                 })
[13:22:04.133]             }))
[13:22:04.133]             future::FutureResult(value = ...future.value$value, 
[13:22:04.133]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:04.133]                   ...future.rng), globalenv = if (FALSE) 
[13:22:04.133]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:04.133]                     ...future.globalenv.names))
[13:22:04.133]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:04.133]         }, condition = base::local({
[13:22:04.133]             c <- base::c
[13:22:04.133]             inherits <- base::inherits
[13:22:04.133]             invokeRestart <- base::invokeRestart
[13:22:04.133]             length <- base::length
[13:22:04.133]             list <- base::list
[13:22:04.133]             seq.int <- base::seq.int
[13:22:04.133]             signalCondition <- base::signalCondition
[13:22:04.133]             sys.calls <- base::sys.calls
[13:22:04.133]             `[[` <- base::`[[`
[13:22:04.133]             `+` <- base::`+`
[13:22:04.133]             `<<-` <- base::`<<-`
[13:22:04.133]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:04.133]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:04.133]                   3L)]
[13:22:04.133]             }
[13:22:04.133]             function(cond) {
[13:22:04.133]                 is_error <- inherits(cond, "error")
[13:22:04.133]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:04.133]                   NULL)
[13:22:04.133]                 if (is_error) {
[13:22:04.133]                   sessionInformation <- function() {
[13:22:04.133]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:04.133]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:04.133]                       search = base::search(), system = base::Sys.info())
[13:22:04.133]                   }
[13:22:04.133]                   ...future.conditions[[length(...future.conditions) + 
[13:22:04.133]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:04.133]                     cond$call), session = sessionInformation(), 
[13:22:04.133]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:04.133]                   signalCondition(cond)
[13:22:04.133]                 }
[13:22:04.133]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:04.133]                 "immediateCondition"))) {
[13:22:04.133]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:04.133]                   ...future.conditions[[length(...future.conditions) + 
[13:22:04.133]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:04.133]                   if (TRUE && !signal) {
[13:22:04.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:04.133]                     {
[13:22:04.133]                       inherits <- base::inherits
[13:22:04.133]                       invokeRestart <- base::invokeRestart
[13:22:04.133]                       is.null <- base::is.null
[13:22:04.133]                       muffled <- FALSE
[13:22:04.133]                       if (inherits(cond, "message")) {
[13:22:04.133]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:04.133]                         if (muffled) 
[13:22:04.133]                           invokeRestart("muffleMessage")
[13:22:04.133]                       }
[13:22:04.133]                       else if (inherits(cond, "warning")) {
[13:22:04.133]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:04.133]                         if (muffled) 
[13:22:04.133]                           invokeRestart("muffleWarning")
[13:22:04.133]                       }
[13:22:04.133]                       else if (inherits(cond, "condition")) {
[13:22:04.133]                         if (!is.null(pattern)) {
[13:22:04.133]                           computeRestarts <- base::computeRestarts
[13:22:04.133]                           grepl <- base::grepl
[13:22:04.133]                           restarts <- computeRestarts(cond)
[13:22:04.133]                           for (restart in restarts) {
[13:22:04.133]                             name <- restart$name
[13:22:04.133]                             if (is.null(name)) 
[13:22:04.133]                               next
[13:22:04.133]                             if (!grepl(pattern, name)) 
[13:22:04.133]                               next
[13:22:04.133]                             invokeRestart(restart)
[13:22:04.133]                             muffled <- TRUE
[13:22:04.133]                             break
[13:22:04.133]                           }
[13:22:04.133]                         }
[13:22:04.133]                       }
[13:22:04.133]                       invisible(muffled)
[13:22:04.133]                     }
[13:22:04.133]                     muffleCondition(cond, pattern = "^muffle")
[13:22:04.133]                   }
[13:22:04.133]                 }
[13:22:04.133]                 else {
[13:22:04.133]                   if (TRUE) {
[13:22:04.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:04.133]                     {
[13:22:04.133]                       inherits <- base::inherits
[13:22:04.133]                       invokeRestart <- base::invokeRestart
[13:22:04.133]                       is.null <- base::is.null
[13:22:04.133]                       muffled <- FALSE
[13:22:04.133]                       if (inherits(cond, "message")) {
[13:22:04.133]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:04.133]                         if (muffled) 
[13:22:04.133]                           invokeRestart("muffleMessage")
[13:22:04.133]                       }
[13:22:04.133]                       else if (inherits(cond, "warning")) {
[13:22:04.133]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:04.133]                         if (muffled) 
[13:22:04.133]                           invokeRestart("muffleWarning")
[13:22:04.133]                       }
[13:22:04.133]                       else if (inherits(cond, "condition")) {
[13:22:04.133]                         if (!is.null(pattern)) {
[13:22:04.133]                           computeRestarts <- base::computeRestarts
[13:22:04.133]                           grepl <- base::grepl
[13:22:04.133]                           restarts <- computeRestarts(cond)
[13:22:04.133]                           for (restart in restarts) {
[13:22:04.133]                             name <- restart$name
[13:22:04.133]                             if (is.null(name)) 
[13:22:04.133]                               next
[13:22:04.133]                             if (!grepl(pattern, name)) 
[13:22:04.133]                               next
[13:22:04.133]                             invokeRestart(restart)
[13:22:04.133]                             muffled <- TRUE
[13:22:04.133]                             break
[13:22:04.133]                           }
[13:22:04.133]                         }
[13:22:04.133]                       }
[13:22:04.133]                       invisible(muffled)
[13:22:04.133]                     }
[13:22:04.133]                     muffleCondition(cond, pattern = "^muffle")
[13:22:04.133]                   }
[13:22:04.133]                 }
[13:22:04.133]             }
[13:22:04.133]         }))
[13:22:04.133]     }, error = function(ex) {
[13:22:04.133]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:04.133]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:04.133]                 ...future.rng), started = ...future.startTime, 
[13:22:04.133]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:04.133]             version = "1.8"), class = "FutureResult")
[13:22:04.133]     }, finally = {
[13:22:04.133]         if (!identical(...future.workdir, getwd())) 
[13:22:04.133]             setwd(...future.workdir)
[13:22:04.133]         {
[13:22:04.133]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:04.133]                 ...future.oldOptions$nwarnings <- NULL
[13:22:04.133]             }
[13:22:04.133]             base::options(...future.oldOptions)
[13:22:04.133]             if (.Platform$OS.type == "windows") {
[13:22:04.133]                 old_names <- names(...future.oldEnvVars)
[13:22:04.133]                 envs <- base::Sys.getenv()
[13:22:04.133]                 names <- names(envs)
[13:22:04.133]                 common <- intersect(names, old_names)
[13:22:04.133]                 added <- setdiff(names, old_names)
[13:22:04.133]                 removed <- setdiff(old_names, names)
[13:22:04.133]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:04.133]                   envs[common]]
[13:22:04.133]                 NAMES <- toupper(changed)
[13:22:04.133]                 args <- list()
[13:22:04.133]                 for (kk in seq_along(NAMES)) {
[13:22:04.133]                   name <- changed[[kk]]
[13:22:04.133]                   NAME <- NAMES[[kk]]
[13:22:04.133]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:04.133]                     next
[13:22:04.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:04.133]                 }
[13:22:04.133]                 NAMES <- toupper(added)
[13:22:04.133]                 for (kk in seq_along(NAMES)) {
[13:22:04.133]                   name <- added[[kk]]
[13:22:04.133]                   NAME <- NAMES[[kk]]
[13:22:04.133]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:04.133]                     next
[13:22:04.133]                   args[[name]] <- ""
[13:22:04.133]                 }
[13:22:04.133]                 NAMES <- toupper(removed)
[13:22:04.133]                 for (kk in seq_along(NAMES)) {
[13:22:04.133]                   name <- removed[[kk]]
[13:22:04.133]                   NAME <- NAMES[[kk]]
[13:22:04.133]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:04.133]                     next
[13:22:04.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:04.133]                 }
[13:22:04.133]                 if (length(args) > 0) 
[13:22:04.133]                   base::do.call(base::Sys.setenv, args = args)
[13:22:04.133]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:04.133]             }
[13:22:04.133]             else {
[13:22:04.133]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:04.133]             }
[13:22:04.133]             {
[13:22:04.133]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:04.133]                   0L) {
[13:22:04.133]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:04.133]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:04.133]                   base::options(opts)
[13:22:04.133]                 }
[13:22:04.133]                 {
[13:22:04.133]                   {
[13:22:04.133]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:04.133]                     NULL
[13:22:04.133]                   }
[13:22:04.133]                   options(future.plan = NULL)
[13:22:04.133]                   if (is.na(NA_character_)) 
[13:22:04.133]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:04.133]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:04.133]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:04.133]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:04.133]                     envir = parent.frame()) 
[13:22:04.133]                   {
[13:22:04.133]                     if (is.function(workers)) 
[13:22:04.133]                       workers <- workers()
[13:22:04.133]                     workers <- structure(as.integer(workers), 
[13:22:04.133]                       class = class(workers))
[13:22:04.133]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:04.133]                       workers >= 1)
[13:22:04.133]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:04.133]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:04.133]                     }
[13:22:04.133]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:04.133]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:04.133]                       envir = envir)
[13:22:04.133]                     if (!future$lazy) 
[13:22:04.133]                       future <- run(future)
[13:22:04.133]                     invisible(future)
[13:22:04.133]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:04.133]                 }
[13:22:04.133]             }
[13:22:04.133]         }
[13:22:04.133]     })
[13:22:04.133]     if (TRUE) {
[13:22:04.133]         base::sink(type = "output", split = FALSE)
[13:22:04.133]         if (TRUE) {
[13:22:04.133]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:04.133]         }
[13:22:04.133]         else {
[13:22:04.133]             ...future.result["stdout"] <- base::list(NULL)
[13:22:04.133]         }
[13:22:04.133]         base::close(...future.stdout)
[13:22:04.133]         ...future.stdout <- NULL
[13:22:04.133]     }
[13:22:04.133]     ...future.result$conditions <- ...future.conditions
[13:22:04.133]     ...future.result$finished <- base::Sys.time()
[13:22:04.133]     ...future.result
[13:22:04.133] }
[13:22:04.136] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[13:22:04.136] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[13:22:04.136] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[13:22:04.136] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[13:22:04.137] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[13:22:04.137] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[13:22:04.137] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[13:22:04.137] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:22:04.137] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:22:04.138] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:22:04.138] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:22:04.138] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[13:22:04.138] MultisessionFuture started
[13:22:04.139] - Launch lazy future ... done
[13:22:04.139] run() for ‘MultisessionFuture’ ... done
[13:22:04.139] Created future:
[13:22:04.139] MultisessionFuture:
[13:22:04.139] Label: ‘future_mapply-2’
[13:22:04.139] Expression:
[13:22:04.139] {
[13:22:04.139]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:04.139]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:22:04.139]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:04.139]         on.exit(options(oopts), add = TRUE)
[13:22:04.139]     }
[13:22:04.139]     {
[13:22:04.139]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:22:04.139]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:22:04.139]         do.call(mapply, args = args)
[13:22:04.139]     }
[13:22:04.139] }
[13:22:04.139] Lazy evaluation: FALSE
[13:22:04.139] Asynchronous evaluation: TRUE
[13:22:04.139] Local evaluation: TRUE
[13:22:04.139] Environment: R_GlobalEnv
[13:22:04.139] Capture standard output: TRUE
[13:22:04.139] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:22:04.139] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:22:04.139] Packages: <none>
[13:22:04.139] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:22:04.139] Resolved: FALSE
[13:22:04.139] Value: <not collected>
[13:22:04.139] Conditions captured: <none>
[13:22:04.139] Early signaling: FALSE
[13:22:04.139] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:22:04.139] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:04.150] Chunk #2 of 2 ... DONE
[13:22:04.150] Launching 2 futures (chunks) ... DONE
[13:22:04.150] Resolving 2 futures (chunks) ...
[13:22:04.151] resolve() on list ...
[13:22:04.151]  recursive: 0
[13:22:04.151]  length: 2
[13:22:04.151] 
[13:22:04.193] receiveMessageFromWorker() for ClusterFuture ...
[13:22:04.194] - Validating connection of MultisessionFuture
[13:22:04.194] - received message: FutureResult
[13:22:04.194] - Received FutureResult
[13:22:04.194] - Erased future from FutureRegistry
[13:22:04.194] result() for ClusterFuture ...
[13:22:04.194] - result already collected: FutureResult
[13:22:04.194] result() for ClusterFuture ... done
[13:22:04.194] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:04.195] Future #2
[13:22:04.195] result() for ClusterFuture ...
[13:22:04.195] - result already collected: FutureResult
[13:22:04.195] result() for ClusterFuture ... done
[13:22:04.195] result() for ClusterFuture ...
[13:22:04.195] - result already collected: FutureResult
[13:22:04.195] result() for ClusterFuture ... done
[13:22:04.195] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:22:04.195] - nx: 2
[13:22:04.195] - relay: TRUE
[13:22:04.195] - stdout: TRUE
[13:22:04.196] - signal: TRUE
[13:22:04.196] - resignal: FALSE
[13:22:04.196] - force: TRUE
[13:22:04.196] - relayed: [n=2] FALSE, FALSE
[13:22:04.196] - queued futures: [n=2] FALSE, FALSE
[13:22:04.196]  - until=1
[13:22:04.196]  - relaying element #1
[13:22:04.196] - relayed: [n=2] FALSE, FALSE
[13:22:04.196] - queued futures: [n=2] FALSE, TRUE
[13:22:04.196] signalConditionsASAP(NULL, pos=2) ... done
[13:22:04.196]  length: 1 (resolved future 2)
[13:22:04.646] receiveMessageFromWorker() for ClusterFuture ...
[13:22:04.646] - Validating connection of MultisessionFuture
[13:22:04.646] - received message: FutureResult
[13:22:04.646] - Received FutureResult
[13:22:04.647] - Erased future from FutureRegistry
[13:22:04.647] result() for ClusterFuture ...
[13:22:04.647] - result already collected: FutureResult
[13:22:04.647] result() for ClusterFuture ... done
[13:22:04.647] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:04.647] Future #1
[13:22:04.647] result() for ClusterFuture ...
[13:22:04.647] - result already collected: FutureResult
[13:22:04.647] result() for ClusterFuture ... done
[13:22:04.647] result() for ClusterFuture ...
[13:22:04.647] - result already collected: FutureResult
[13:22:04.648] result() for ClusterFuture ... done
[13:22:04.648] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:22:04.648] - nx: 2
[13:22:04.648] - relay: TRUE
[13:22:04.648] - stdout: TRUE
[13:22:04.648] - signal: TRUE
[13:22:04.648] - resignal: FALSE
[13:22:04.648] - force: TRUE
[13:22:04.648] - relayed: [n=2] FALSE, FALSE
[13:22:04.648] - queued futures: [n=2] FALSE, TRUE
[13:22:04.649]  - until=1
[13:22:04.649]  - relaying element #1
[13:22:04.649] result() for ClusterFuture ...
[13:22:04.649] - result already collected: FutureResult
[13:22:04.649] result() for ClusterFuture ... done
[13:22:04.649] result() for ClusterFuture ...
[13:22:04.649] - result already collected: FutureResult
[13:22:04.649] result() for ClusterFuture ... done
[13:22:04.649] result() for ClusterFuture ...
[13:22:04.649] - result already collected: FutureResult
[13:22:04.649] result() for ClusterFuture ... done
[13:22:04.650] result() for ClusterFuture ...
[13:22:04.650] - result already collected: FutureResult
[13:22:04.650] result() for ClusterFuture ... done
[13:22:04.650] - relayed: [n=2] TRUE, FALSE
[13:22:04.650] - queued futures: [n=2] TRUE, TRUE
[13:22:04.650] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:22:04.650]  length: 0 (resolved future 1)
[13:22:04.650] Relaying remaining futures
[13:22:04.650] signalConditionsASAP(NULL, pos=0) ...
[13:22:04.650] - nx: 2
[13:22:04.650] - relay: TRUE
[13:22:04.650] - stdout: TRUE
[13:22:04.651] - signal: TRUE
[13:22:04.651] - resignal: FALSE
[13:22:04.651] - force: TRUE
[13:22:04.651] - relayed: [n=2] TRUE, FALSE
[13:22:04.651] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:22:04.651]  - relaying element #2
[13:22:04.651] result() for ClusterFuture ...
[13:22:04.651] - result already collected: FutureResult
[13:22:04.651] result() for ClusterFuture ... done
[13:22:04.651] result() for ClusterFuture ...
[13:22:04.651] - result already collected: FutureResult
[13:22:04.652] result() for ClusterFuture ... done
[13:22:04.652] result() for ClusterFuture ...
[13:22:04.652] - result already collected: FutureResult
[13:22:04.652] result() for ClusterFuture ... done
[13:22:04.652] result() for ClusterFuture ...
[13:22:04.652] - result already collected: FutureResult
[13:22:04.652] result() for ClusterFuture ... done
[13:22:04.652] - relayed: [n=2] TRUE, TRUE
[13:22:04.652] - queued futures: [n=2] TRUE, TRUE
[13:22:04.652] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[13:22:04.653] resolve() on list ... DONE
[13:22:04.653] result() for ClusterFuture ...
[13:22:04.653] - result already collected: FutureResult
[13:22:04.653] result() for ClusterFuture ... done
[13:22:04.653] result() for ClusterFuture ...
[13:22:04.653] - result already collected: FutureResult
[13:22:04.653] result() for ClusterFuture ... done
[13:22:04.653] result() for ClusterFuture ...
[13:22:04.653] - result already collected: FutureResult
[13:22:04.653] result() for ClusterFuture ... done
[13:22:04.653] result() for ClusterFuture ...
[13:22:04.653] - result already collected: FutureResult
[13:22:04.654] result() for ClusterFuture ... done
[13:22:04.654]  - Number of value chunks collected: 2
[13:22:04.654] Resolving 2 futures (chunks) ... DONE
[13:22:04.654] Reducing values from 2 chunks ...
[13:22:04.654]  - Number of values collected after concatenation: 2
[13:22:04.654]  - Number of values expected: 2
[13:22:04.654] Reducing values from 2 chunks ... DONE
[13:22:04.654] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[13:22:04.655] future_mapply() ...
[13:22:04.658] Number of chunks: 2
[13:22:04.658] getGlobalsAndPackagesXApply() ...
[13:22:04.659]  - future.globals: TRUE
[13:22:04.659] getGlobalsAndPackages() ...
[13:22:04.659] Searching for globals...
[13:22:04.660] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:22:04.660] Searching for globals ... DONE
[13:22:04.661] Resolving globals: FALSE
[13:22:04.661] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:22:04.661] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:22:04.661] - globals: [1] ‘FUN’
[13:22:04.662] 
[13:22:04.662] getGlobalsAndPackages() ... DONE
[13:22:04.662]  - globals found/used: [n=1] ‘FUN’
[13:22:04.662]  - needed namespaces: [n=0] 
[13:22:04.662] Finding globals ... DONE
[13:22:04.662] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:22:04.662] List of 2
[13:22:04.662]  $ ...future.FUN:function (x, y)  
[13:22:04.662]  $ MoreArgs     : NULL
[13:22:04.662]  - attr(*, "where")=List of 2
[13:22:04.662]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:22:04.662]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:22:04.662]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:22:04.662]  - attr(*, "resolved")= logi FALSE
[13:22:04.662]  - attr(*, "total_size")= num NA
[13:22:04.665] Packages to be attached in all futures: [n=0] 
[13:22:04.665] getGlobalsAndPackagesXApply() ... DONE
[13:22:04.665] Number of futures (= number of chunks): 2
[13:22:04.665] Launching 2 futures (chunks) ...
[13:22:04.665] Chunk #1 of 2 ...
[13:22:04.665]  - Finding globals in '...' for chunk #1 ...
[13:22:04.665] getGlobalsAndPackages() ...
[13:22:04.665] Searching for globals...
[13:22:04.666] 
[13:22:04.666] Searching for globals ... DONE
[13:22:04.666] - globals: [0] <none>
[13:22:04.666] getGlobalsAndPackages() ... DONE
[13:22:04.666]    + additional globals found: [n=0] 
[13:22:04.666]    + additional namespaces needed: [n=0] 
[13:22:04.666]  - Finding globals in '...' for chunk #1 ... DONE
[13:22:04.666]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:22:04.666]  - seeds: <none>
[13:22:04.667]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:04.667] getGlobalsAndPackages() ...
[13:22:04.667] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:04.667] Resolving globals: FALSE
[13:22:04.667] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:22:04.668] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:22:04.668] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:04.668] 
[13:22:04.668] getGlobalsAndPackages() ... DONE
[13:22:04.668] run() for ‘Future’ ...
[13:22:04.669] - state: ‘created’
[13:22:04.669] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:04.682] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:04.682] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:04.682]   - Field: ‘node’
[13:22:04.683]   - Field: ‘label’
[13:22:04.683]   - Field: ‘local’
[13:22:04.683]   - Field: ‘owner’
[13:22:04.683]   - Field: ‘envir’
[13:22:04.683]   - Field: ‘workers’
[13:22:04.683]   - Field: ‘packages’
[13:22:04.683]   - Field: ‘gc’
[13:22:04.683]   - Field: ‘conditions’
[13:22:04.683]   - Field: ‘persistent’
[13:22:04.683]   - Field: ‘expr’
[13:22:04.684]   - Field: ‘uuid’
[13:22:04.684]   - Field: ‘seed’
[13:22:04.684]   - Field: ‘version’
[13:22:04.684]   - Field: ‘result’
[13:22:04.684]   - Field: ‘asynchronous’
[13:22:04.684]   - Field: ‘calls’
[13:22:04.684]   - Field: ‘globals’
[13:22:04.684]   - Field: ‘stdout’
[13:22:04.684]   - Field: ‘earlySignal’
[13:22:04.684]   - Field: ‘lazy’
[13:22:04.684]   - Field: ‘state’
[13:22:04.685] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:04.685] - Launch lazy future ...
[13:22:04.685] Packages needed by the future expression (n = 0): <none>
[13:22:04.685] Packages needed by future strategies (n = 0): <none>
[13:22:04.686] {
[13:22:04.686]     {
[13:22:04.686]         {
[13:22:04.686]             ...future.startTime <- base::Sys.time()
[13:22:04.686]             {
[13:22:04.686]                 {
[13:22:04.686]                   {
[13:22:04.686]                     {
[13:22:04.686]                       base::local({
[13:22:04.686]                         has_future <- base::requireNamespace("future", 
[13:22:04.686]                           quietly = TRUE)
[13:22:04.686]                         if (has_future) {
[13:22:04.686]                           ns <- base::getNamespace("future")
[13:22:04.686]                           version <- ns[[".package"]][["version"]]
[13:22:04.686]                           if (is.null(version)) 
[13:22:04.686]                             version <- utils::packageVersion("future")
[13:22:04.686]                         }
[13:22:04.686]                         else {
[13:22:04.686]                           version <- NULL
[13:22:04.686]                         }
[13:22:04.686]                         if (!has_future || version < "1.8.0") {
[13:22:04.686]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:04.686]                             "", base::R.version$version.string), 
[13:22:04.686]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:04.686]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:04.686]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:04.686]                               "release", "version")], collapse = " "), 
[13:22:04.686]                             hostname = base::Sys.info()[["nodename"]])
[13:22:04.686]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:04.686]                             info)
[13:22:04.686]                           info <- base::paste(info, collapse = "; ")
[13:22:04.686]                           if (!has_future) {
[13:22:04.686]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:04.686]                               info)
[13:22:04.686]                           }
[13:22:04.686]                           else {
[13:22:04.686]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:04.686]                               info, version)
[13:22:04.686]                           }
[13:22:04.686]                           base::stop(msg)
[13:22:04.686]                         }
[13:22:04.686]                       })
[13:22:04.686]                     }
[13:22:04.686]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:04.686]                     base::options(mc.cores = 1L)
[13:22:04.686]                   }
[13:22:04.686]                   options(future.plan = NULL)
[13:22:04.686]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:04.686]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:04.686]                 }
[13:22:04.686]                 ...future.workdir <- getwd()
[13:22:04.686]             }
[13:22:04.686]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:04.686]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:04.686]         }
[13:22:04.686]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:04.686]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:22:04.686]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:04.686]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:04.686]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:04.686]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:04.686]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:04.686]             base::names(...future.oldOptions))
[13:22:04.686]     }
[13:22:04.686]     if (TRUE) {
[13:22:04.686]     }
[13:22:04.686]     else {
[13:22:04.686]         if (NA) {
[13:22:04.686]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:04.686]                 open = "w")
[13:22:04.686]         }
[13:22:04.686]         else {
[13:22:04.686]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:04.686]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:04.686]         }
[13:22:04.686]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:04.686]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:04.686]             base::sink(type = "output", split = FALSE)
[13:22:04.686]             base::close(...future.stdout)
[13:22:04.686]         }, add = TRUE)
[13:22:04.686]     }
[13:22:04.686]     ...future.frame <- base::sys.nframe()
[13:22:04.686]     ...future.conditions <- base::list()
[13:22:04.686]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:04.686]     if (FALSE) {
[13:22:04.686]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:04.686]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:04.686]     }
[13:22:04.686]     ...future.result <- base::tryCatch({
[13:22:04.686]         base::withCallingHandlers({
[13:22:04.686]             ...future.value <- base::withVisible(base::local({
[13:22:04.686]                 ...future.makeSendCondition <- base::local({
[13:22:04.686]                   sendCondition <- NULL
[13:22:04.686]                   function(frame = 1L) {
[13:22:04.686]                     if (is.function(sendCondition)) 
[13:22:04.686]                       return(sendCondition)
[13:22:04.686]                     ns <- getNamespace("parallel")
[13:22:04.686]                     if (exists("sendData", mode = "function", 
[13:22:04.686]                       envir = ns)) {
[13:22:04.686]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:04.686]                         envir = ns)
[13:22:04.686]                       envir <- sys.frame(frame)
[13:22:04.686]                       master <- NULL
[13:22:04.686]                       while (!identical(envir, .GlobalEnv) && 
[13:22:04.686]                         !identical(envir, emptyenv())) {
[13:22:04.686]                         if (exists("master", mode = "list", envir = envir, 
[13:22:04.686]                           inherits = FALSE)) {
[13:22:04.686]                           master <- get("master", mode = "list", 
[13:22:04.686]                             envir = envir, inherits = FALSE)
[13:22:04.686]                           if (inherits(master, c("SOCKnode", 
[13:22:04.686]                             "SOCK0node"))) {
[13:22:04.686]                             sendCondition <<- function(cond) {
[13:22:04.686]                               data <- list(type = "VALUE", value = cond, 
[13:22:04.686]                                 success = TRUE)
[13:22:04.686]                               parallel_sendData(master, data)
[13:22:04.686]                             }
[13:22:04.686]                             return(sendCondition)
[13:22:04.686]                           }
[13:22:04.686]                         }
[13:22:04.686]                         frame <- frame + 1L
[13:22:04.686]                         envir <- sys.frame(frame)
[13:22:04.686]                       }
[13:22:04.686]                     }
[13:22:04.686]                     sendCondition <<- function(cond) NULL
[13:22:04.686]                   }
[13:22:04.686]                 })
[13:22:04.686]                 withCallingHandlers({
[13:22:04.686]                   {
[13:22:04.686]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:04.686]                     if (!identical(...future.globals.maxSize.org, 
[13:22:04.686]                       ...future.globals.maxSize)) {
[13:22:04.686]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:04.686]                       on.exit(options(oopts), add = TRUE)
[13:22:04.686]                     }
[13:22:04.686]                     {
[13:22:04.686]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:22:04.686]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:22:04.686]                         USE.NAMES = FALSE)
[13:22:04.686]                       do.call(mapply, args = args)
[13:22:04.686]                     }
[13:22:04.686]                   }
[13:22:04.686]                 }, immediateCondition = function(cond) {
[13:22:04.686]                   sendCondition <- ...future.makeSendCondition()
[13:22:04.686]                   sendCondition(cond)
[13:22:04.686]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:04.686]                   {
[13:22:04.686]                     inherits <- base::inherits
[13:22:04.686]                     invokeRestart <- base::invokeRestart
[13:22:04.686]                     is.null <- base::is.null
[13:22:04.686]                     muffled <- FALSE
[13:22:04.686]                     if (inherits(cond, "message")) {
[13:22:04.686]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:04.686]                       if (muffled) 
[13:22:04.686]                         invokeRestart("muffleMessage")
[13:22:04.686]                     }
[13:22:04.686]                     else if (inherits(cond, "warning")) {
[13:22:04.686]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:04.686]                       if (muffled) 
[13:22:04.686]                         invokeRestart("muffleWarning")
[13:22:04.686]                     }
[13:22:04.686]                     else if (inherits(cond, "condition")) {
[13:22:04.686]                       if (!is.null(pattern)) {
[13:22:04.686]                         computeRestarts <- base::computeRestarts
[13:22:04.686]                         grepl <- base::grepl
[13:22:04.686]                         restarts <- computeRestarts(cond)
[13:22:04.686]                         for (restart in restarts) {
[13:22:04.686]                           name <- restart$name
[13:22:04.686]                           if (is.null(name)) 
[13:22:04.686]                             next
[13:22:04.686]                           if (!grepl(pattern, name)) 
[13:22:04.686]                             next
[13:22:04.686]                           invokeRestart(restart)
[13:22:04.686]                           muffled <- TRUE
[13:22:04.686]                           break
[13:22:04.686]                         }
[13:22:04.686]                       }
[13:22:04.686]                     }
[13:22:04.686]                     invisible(muffled)
[13:22:04.686]                   }
[13:22:04.686]                   muffleCondition(cond)
[13:22:04.686]                 })
[13:22:04.686]             }))
[13:22:04.686]             future::FutureResult(value = ...future.value$value, 
[13:22:04.686]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:04.686]                   ...future.rng), globalenv = if (FALSE) 
[13:22:04.686]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:04.686]                     ...future.globalenv.names))
[13:22:04.686]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:04.686]         }, condition = base::local({
[13:22:04.686]             c <- base::c
[13:22:04.686]             inherits <- base::inherits
[13:22:04.686]             invokeRestart <- base::invokeRestart
[13:22:04.686]             length <- base::length
[13:22:04.686]             list <- base::list
[13:22:04.686]             seq.int <- base::seq.int
[13:22:04.686]             signalCondition <- base::signalCondition
[13:22:04.686]             sys.calls <- base::sys.calls
[13:22:04.686]             `[[` <- base::`[[`
[13:22:04.686]             `+` <- base::`+`
[13:22:04.686]             `<<-` <- base::`<<-`
[13:22:04.686]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:04.686]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:04.686]                   3L)]
[13:22:04.686]             }
[13:22:04.686]             function(cond) {
[13:22:04.686]                 is_error <- inherits(cond, "error")
[13:22:04.686]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:04.686]                   NULL)
[13:22:04.686]                 if (is_error) {
[13:22:04.686]                   sessionInformation <- function() {
[13:22:04.686]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:04.686]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:04.686]                       search = base::search(), system = base::Sys.info())
[13:22:04.686]                   }
[13:22:04.686]                   ...future.conditions[[length(...future.conditions) + 
[13:22:04.686]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:04.686]                     cond$call), session = sessionInformation(), 
[13:22:04.686]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:04.686]                   signalCondition(cond)
[13:22:04.686]                 }
[13:22:04.686]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:04.686]                 "immediateCondition"))) {
[13:22:04.686]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:04.686]                   ...future.conditions[[length(...future.conditions) + 
[13:22:04.686]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:04.686]                   if (TRUE && !signal) {
[13:22:04.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:04.686]                     {
[13:22:04.686]                       inherits <- base::inherits
[13:22:04.686]                       invokeRestart <- base::invokeRestart
[13:22:04.686]                       is.null <- base::is.null
[13:22:04.686]                       muffled <- FALSE
[13:22:04.686]                       if (inherits(cond, "message")) {
[13:22:04.686]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:04.686]                         if (muffled) 
[13:22:04.686]                           invokeRestart("muffleMessage")
[13:22:04.686]                       }
[13:22:04.686]                       else if (inherits(cond, "warning")) {
[13:22:04.686]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:04.686]                         if (muffled) 
[13:22:04.686]                           invokeRestart("muffleWarning")
[13:22:04.686]                       }
[13:22:04.686]                       else if (inherits(cond, "condition")) {
[13:22:04.686]                         if (!is.null(pattern)) {
[13:22:04.686]                           computeRestarts <- base::computeRestarts
[13:22:04.686]                           grepl <- base::grepl
[13:22:04.686]                           restarts <- computeRestarts(cond)
[13:22:04.686]                           for (restart in restarts) {
[13:22:04.686]                             name <- restart$name
[13:22:04.686]                             if (is.null(name)) 
[13:22:04.686]                               next
[13:22:04.686]                             if (!grepl(pattern, name)) 
[13:22:04.686]                               next
[13:22:04.686]                             invokeRestart(restart)
[13:22:04.686]                             muffled <- TRUE
[13:22:04.686]                             break
[13:22:04.686]                           }
[13:22:04.686]                         }
[13:22:04.686]                       }
[13:22:04.686]                       invisible(muffled)
[13:22:04.686]                     }
[13:22:04.686]                     muffleCondition(cond, pattern = "^muffle")
[13:22:04.686]                   }
[13:22:04.686]                 }
[13:22:04.686]                 else {
[13:22:04.686]                   if (TRUE) {
[13:22:04.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:04.686]                     {
[13:22:04.686]                       inherits <- base::inherits
[13:22:04.686]                       invokeRestart <- base::invokeRestart
[13:22:04.686]                       is.null <- base::is.null
[13:22:04.686]                       muffled <- FALSE
[13:22:04.686]                       if (inherits(cond, "message")) {
[13:22:04.686]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:04.686]                         if (muffled) 
[13:22:04.686]                           invokeRestart("muffleMessage")
[13:22:04.686]                       }
[13:22:04.686]                       else if (inherits(cond, "warning")) {
[13:22:04.686]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:04.686]                         if (muffled) 
[13:22:04.686]                           invokeRestart("muffleWarning")
[13:22:04.686]                       }
[13:22:04.686]                       else if (inherits(cond, "condition")) {
[13:22:04.686]                         if (!is.null(pattern)) {
[13:22:04.686]                           computeRestarts <- base::computeRestarts
[13:22:04.686]                           grepl <- base::grepl
[13:22:04.686]                           restarts <- computeRestarts(cond)
[13:22:04.686]                           for (restart in restarts) {
[13:22:04.686]                             name <- restart$name
[13:22:04.686]                             if (is.null(name)) 
[13:22:04.686]                               next
[13:22:04.686]                             if (!grepl(pattern, name)) 
[13:22:04.686]                               next
[13:22:04.686]                             invokeRestart(restart)
[13:22:04.686]                             muffled <- TRUE
[13:22:04.686]                             break
[13:22:04.686]                           }
[13:22:04.686]                         }
[13:22:04.686]                       }
[13:22:04.686]                       invisible(muffled)
[13:22:04.686]                     }
[13:22:04.686]                     muffleCondition(cond, pattern = "^muffle")
[13:22:04.686]                   }
[13:22:04.686]                 }
[13:22:04.686]             }
[13:22:04.686]         }))
[13:22:04.686]     }, error = function(ex) {
[13:22:04.686]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:04.686]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:04.686]                 ...future.rng), started = ...future.startTime, 
[13:22:04.686]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:04.686]             version = "1.8"), class = "FutureResult")
[13:22:04.686]     }, finally = {
[13:22:04.686]         if (!identical(...future.workdir, getwd())) 
[13:22:04.686]             setwd(...future.workdir)
[13:22:04.686]         {
[13:22:04.686]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:04.686]                 ...future.oldOptions$nwarnings <- NULL
[13:22:04.686]             }
[13:22:04.686]             base::options(...future.oldOptions)
[13:22:04.686]             if (.Platform$OS.type == "windows") {
[13:22:04.686]                 old_names <- names(...future.oldEnvVars)
[13:22:04.686]                 envs <- base::Sys.getenv()
[13:22:04.686]                 names <- names(envs)
[13:22:04.686]                 common <- intersect(names, old_names)
[13:22:04.686]                 added <- setdiff(names, old_names)
[13:22:04.686]                 removed <- setdiff(old_names, names)
[13:22:04.686]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:04.686]                   envs[common]]
[13:22:04.686]                 NAMES <- toupper(changed)
[13:22:04.686]                 args <- list()
[13:22:04.686]                 for (kk in seq_along(NAMES)) {
[13:22:04.686]                   name <- changed[[kk]]
[13:22:04.686]                   NAME <- NAMES[[kk]]
[13:22:04.686]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:04.686]                     next
[13:22:04.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:04.686]                 }
[13:22:04.686]                 NAMES <- toupper(added)
[13:22:04.686]                 for (kk in seq_along(NAMES)) {
[13:22:04.686]                   name <- added[[kk]]
[13:22:04.686]                   NAME <- NAMES[[kk]]
[13:22:04.686]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:04.686]                     next
[13:22:04.686]                   args[[name]] <- ""
[13:22:04.686]                 }
[13:22:04.686]                 NAMES <- toupper(removed)
[13:22:04.686]                 for (kk in seq_along(NAMES)) {
[13:22:04.686]                   name <- removed[[kk]]
[13:22:04.686]                   NAME <- NAMES[[kk]]
[13:22:04.686]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:04.686]                     next
[13:22:04.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:04.686]                 }
[13:22:04.686]                 if (length(args) > 0) 
[13:22:04.686]                   base::do.call(base::Sys.setenv, args = args)
[13:22:04.686]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:04.686]             }
[13:22:04.686]             else {
[13:22:04.686]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:04.686]             }
[13:22:04.686]             {
[13:22:04.686]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:04.686]                   0L) {
[13:22:04.686]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:04.686]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:04.686]                   base::options(opts)
[13:22:04.686]                 }
[13:22:04.686]                 {
[13:22:04.686]                   {
[13:22:04.686]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:04.686]                     NULL
[13:22:04.686]                   }
[13:22:04.686]                   options(future.plan = NULL)
[13:22:04.686]                   if (is.na(NA_character_)) 
[13:22:04.686]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:04.686]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:04.686]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:04.686]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:04.686]                     envir = parent.frame()) 
[13:22:04.686]                   {
[13:22:04.686]                     if (is.function(workers)) 
[13:22:04.686]                       workers <- workers()
[13:22:04.686]                     workers <- structure(as.integer(workers), 
[13:22:04.686]                       class = class(workers))
[13:22:04.686]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:04.686]                       workers >= 1)
[13:22:04.686]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:04.686]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:04.686]                     }
[13:22:04.686]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:04.686]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:04.686]                       envir = envir)
[13:22:04.686]                     if (!future$lazy) 
[13:22:04.686]                       future <- run(future)
[13:22:04.686]                     invisible(future)
[13:22:04.686]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:04.686]                 }
[13:22:04.686]             }
[13:22:04.686]         }
[13:22:04.686]     })
[13:22:04.686]     if (FALSE) {
[13:22:04.686]         base::sink(type = "output", split = FALSE)
[13:22:04.686]         if (NA) {
[13:22:04.686]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:04.686]         }
[13:22:04.686]         else {
[13:22:04.686]             ...future.result["stdout"] <- base::list(NULL)
[13:22:04.686]         }
[13:22:04.686]         base::close(...future.stdout)
[13:22:04.686]         ...future.stdout <- NULL
[13:22:04.686]     }
[13:22:04.686]     ...future.result$conditions <- ...future.conditions
[13:22:04.686]     ...future.result$finished <- base::Sys.time()
[13:22:04.686]     ...future.result
[13:22:04.686] }
[13:22:04.688] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[13:22:04.689] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[13:22:04.689] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[13:22:04.689] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[13:22:04.690] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[13:22:04.690] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[13:22:04.690] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[13:22:04.690] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:22:04.691] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:22:04.691] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:22:04.691] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:22:04.691] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[13:22:04.692] MultisessionFuture started
[13:22:04.692] - Launch lazy future ... done
[13:22:04.692] run() for ‘MultisessionFuture’ ... done
[13:22:04.692] Created future:
[13:22:04.692] MultisessionFuture:
[13:22:04.692] Label: ‘future_mapply-1’
[13:22:04.692] Expression:
[13:22:04.692] {
[13:22:04.692]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:04.692]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:22:04.692]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:04.692]         on.exit(options(oopts), add = TRUE)
[13:22:04.692]     }
[13:22:04.692]     {
[13:22:04.692]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:22:04.692]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:22:04.692]         do.call(mapply, args = args)
[13:22:04.692]     }
[13:22:04.692] }
[13:22:04.692] Lazy evaluation: FALSE
[13:22:04.692] Asynchronous evaluation: TRUE
[13:22:04.692] Local evaluation: TRUE
[13:22:04.692] Environment: R_GlobalEnv
[13:22:04.692] Capture standard output: NA
[13:22:04.692] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:22:04.692] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:22:04.692] Packages: <none>
[13:22:04.692] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:22:04.692] Resolved: FALSE
[13:22:04.692] Value: <not collected>
[13:22:04.692] Conditions captured: <none>
[13:22:04.692] Early signaling: FALSE
[13:22:04.692] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:22:04.692] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:04.704] Chunk #1 of 2 ... DONE
[13:22:04.704] Chunk #2 of 2 ...
[13:22:04.704]  - Finding globals in '...' for chunk #2 ...
[13:22:04.704] getGlobalsAndPackages() ...
[13:22:04.704] Searching for globals...
[13:22:04.705] 
[13:22:04.705] Searching for globals ... DONE
[13:22:04.705] - globals: [0] <none>
[13:22:04.705] getGlobalsAndPackages() ... DONE
[13:22:04.705]    + additional globals found: [n=0] 
[13:22:04.705]    + additional namespaces needed: [n=0] 
[13:22:04.705]  - Finding globals in '...' for chunk #2 ... DONE
[13:22:04.705]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:22:04.705]  - seeds: <none>
[13:22:04.706]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:04.706] getGlobalsAndPackages() ...
[13:22:04.706] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:04.706] Resolving globals: FALSE
[13:22:04.706] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:22:04.707] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:22:04.707] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:22:04.707] 
[13:22:04.707] getGlobalsAndPackages() ... DONE
[13:22:04.707] run() for ‘Future’ ...
[13:22:04.708] - state: ‘created’
[13:22:04.708] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:04.722] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:04.722] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:04.722]   - Field: ‘node’
[13:22:04.722]   - Field: ‘label’
[13:22:04.722]   - Field: ‘local’
[13:22:04.722]   - Field: ‘owner’
[13:22:04.723]   - Field: ‘envir’
[13:22:04.723]   - Field: ‘workers’
[13:22:04.723]   - Field: ‘packages’
[13:22:04.723]   - Field: ‘gc’
[13:22:04.723]   - Field: ‘conditions’
[13:22:04.723]   - Field: ‘persistent’
[13:22:04.723]   - Field: ‘expr’
[13:22:04.723]   - Field: ‘uuid’
[13:22:04.723]   - Field: ‘seed’
[13:22:04.723]   - Field: ‘version’
[13:22:04.723]   - Field: ‘result’
[13:22:04.724]   - Field: ‘asynchronous’
[13:22:04.724]   - Field: ‘calls’
[13:22:04.724]   - Field: ‘globals’
[13:22:04.724]   - Field: ‘stdout’
[13:22:04.724]   - Field: ‘earlySignal’
[13:22:04.724]   - Field: ‘lazy’
[13:22:04.724]   - Field: ‘state’
[13:22:04.724] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:04.724] - Launch lazy future ...
[13:22:04.725] Packages needed by the future expression (n = 0): <none>
[13:22:04.725] Packages needed by future strategies (n = 0): <none>
[13:22:04.725] {
[13:22:04.725]     {
[13:22:04.725]         {
[13:22:04.725]             ...future.startTime <- base::Sys.time()
[13:22:04.725]             {
[13:22:04.725]                 {
[13:22:04.725]                   {
[13:22:04.725]                     {
[13:22:04.725]                       base::local({
[13:22:04.725]                         has_future <- base::requireNamespace("future", 
[13:22:04.725]                           quietly = TRUE)
[13:22:04.725]                         if (has_future) {
[13:22:04.725]                           ns <- base::getNamespace("future")
[13:22:04.725]                           version <- ns[[".package"]][["version"]]
[13:22:04.725]                           if (is.null(version)) 
[13:22:04.725]                             version <- utils::packageVersion("future")
[13:22:04.725]                         }
[13:22:04.725]                         else {
[13:22:04.725]                           version <- NULL
[13:22:04.725]                         }
[13:22:04.725]                         if (!has_future || version < "1.8.0") {
[13:22:04.725]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:04.725]                             "", base::R.version$version.string), 
[13:22:04.725]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:04.725]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:04.725]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:04.725]                               "release", "version")], collapse = " "), 
[13:22:04.725]                             hostname = base::Sys.info()[["nodename"]])
[13:22:04.725]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:04.725]                             info)
[13:22:04.725]                           info <- base::paste(info, collapse = "; ")
[13:22:04.725]                           if (!has_future) {
[13:22:04.725]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:04.725]                               info)
[13:22:04.725]                           }
[13:22:04.725]                           else {
[13:22:04.725]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:04.725]                               info, version)
[13:22:04.725]                           }
[13:22:04.725]                           base::stop(msg)
[13:22:04.725]                         }
[13:22:04.725]                       })
[13:22:04.725]                     }
[13:22:04.725]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:04.725]                     base::options(mc.cores = 1L)
[13:22:04.725]                   }
[13:22:04.725]                   options(future.plan = NULL)
[13:22:04.725]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:04.725]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:04.725]                 }
[13:22:04.725]                 ...future.workdir <- getwd()
[13:22:04.725]             }
[13:22:04.725]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:04.725]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:04.725]         }
[13:22:04.725]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:04.725]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:22:04.725]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:04.725]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:04.725]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:04.725]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:04.725]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:04.725]             base::names(...future.oldOptions))
[13:22:04.725]     }
[13:22:04.725]     if (TRUE) {
[13:22:04.725]     }
[13:22:04.725]     else {
[13:22:04.725]         if (NA) {
[13:22:04.725]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:04.725]                 open = "w")
[13:22:04.725]         }
[13:22:04.725]         else {
[13:22:04.725]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:04.725]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:04.725]         }
[13:22:04.725]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:04.725]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:04.725]             base::sink(type = "output", split = FALSE)
[13:22:04.725]             base::close(...future.stdout)
[13:22:04.725]         }, add = TRUE)
[13:22:04.725]     }
[13:22:04.725]     ...future.frame <- base::sys.nframe()
[13:22:04.725]     ...future.conditions <- base::list()
[13:22:04.725]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:04.725]     if (FALSE) {
[13:22:04.725]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:04.725]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:04.725]     }
[13:22:04.725]     ...future.result <- base::tryCatch({
[13:22:04.725]         base::withCallingHandlers({
[13:22:04.725]             ...future.value <- base::withVisible(base::local({
[13:22:04.725]                 ...future.makeSendCondition <- base::local({
[13:22:04.725]                   sendCondition <- NULL
[13:22:04.725]                   function(frame = 1L) {
[13:22:04.725]                     if (is.function(sendCondition)) 
[13:22:04.725]                       return(sendCondition)
[13:22:04.725]                     ns <- getNamespace("parallel")
[13:22:04.725]                     if (exists("sendData", mode = "function", 
[13:22:04.725]                       envir = ns)) {
[13:22:04.725]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:04.725]                         envir = ns)
[13:22:04.725]                       envir <- sys.frame(frame)
[13:22:04.725]                       master <- NULL
[13:22:04.725]                       while (!identical(envir, .GlobalEnv) && 
[13:22:04.725]                         !identical(envir, emptyenv())) {
[13:22:04.725]                         if (exists("master", mode = "list", envir = envir, 
[13:22:04.725]                           inherits = FALSE)) {
[13:22:04.725]                           master <- get("master", mode = "list", 
[13:22:04.725]                             envir = envir, inherits = FALSE)
[13:22:04.725]                           if (inherits(master, c("SOCKnode", 
[13:22:04.725]                             "SOCK0node"))) {
[13:22:04.725]                             sendCondition <<- function(cond) {
[13:22:04.725]                               data <- list(type = "VALUE", value = cond, 
[13:22:04.725]                                 success = TRUE)
[13:22:04.725]                               parallel_sendData(master, data)
[13:22:04.725]                             }
[13:22:04.725]                             return(sendCondition)
[13:22:04.725]                           }
[13:22:04.725]                         }
[13:22:04.725]                         frame <- frame + 1L
[13:22:04.725]                         envir <- sys.frame(frame)
[13:22:04.725]                       }
[13:22:04.725]                     }
[13:22:04.725]                     sendCondition <<- function(cond) NULL
[13:22:04.725]                   }
[13:22:04.725]                 })
[13:22:04.725]                 withCallingHandlers({
[13:22:04.725]                   {
[13:22:04.725]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:04.725]                     if (!identical(...future.globals.maxSize.org, 
[13:22:04.725]                       ...future.globals.maxSize)) {
[13:22:04.725]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:04.725]                       on.exit(options(oopts), add = TRUE)
[13:22:04.725]                     }
[13:22:04.725]                     {
[13:22:04.725]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:22:04.725]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:22:04.725]                         USE.NAMES = FALSE)
[13:22:04.725]                       do.call(mapply, args = args)
[13:22:04.725]                     }
[13:22:04.725]                   }
[13:22:04.725]                 }, immediateCondition = function(cond) {
[13:22:04.725]                   sendCondition <- ...future.makeSendCondition()
[13:22:04.725]                   sendCondition(cond)
[13:22:04.725]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:04.725]                   {
[13:22:04.725]                     inherits <- base::inherits
[13:22:04.725]                     invokeRestart <- base::invokeRestart
[13:22:04.725]                     is.null <- base::is.null
[13:22:04.725]                     muffled <- FALSE
[13:22:04.725]                     if (inherits(cond, "message")) {
[13:22:04.725]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:04.725]                       if (muffled) 
[13:22:04.725]                         invokeRestart("muffleMessage")
[13:22:04.725]                     }
[13:22:04.725]                     else if (inherits(cond, "warning")) {
[13:22:04.725]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:04.725]                       if (muffled) 
[13:22:04.725]                         invokeRestart("muffleWarning")
[13:22:04.725]                     }
[13:22:04.725]                     else if (inherits(cond, "condition")) {
[13:22:04.725]                       if (!is.null(pattern)) {
[13:22:04.725]                         computeRestarts <- base::computeRestarts
[13:22:04.725]                         grepl <- base::grepl
[13:22:04.725]                         restarts <- computeRestarts(cond)
[13:22:04.725]                         for (restart in restarts) {
[13:22:04.725]                           name <- restart$name
[13:22:04.725]                           if (is.null(name)) 
[13:22:04.725]                             next
[13:22:04.725]                           if (!grepl(pattern, name)) 
[13:22:04.725]                             next
[13:22:04.725]                           invokeRestart(restart)
[13:22:04.725]                           muffled <- TRUE
[13:22:04.725]                           break
[13:22:04.725]                         }
[13:22:04.725]                       }
[13:22:04.725]                     }
[13:22:04.725]                     invisible(muffled)
[13:22:04.725]                   }
[13:22:04.725]                   muffleCondition(cond)
[13:22:04.725]                 })
[13:22:04.725]             }))
[13:22:04.725]             future::FutureResult(value = ...future.value$value, 
[13:22:04.725]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:04.725]                   ...future.rng), globalenv = if (FALSE) 
[13:22:04.725]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:04.725]                     ...future.globalenv.names))
[13:22:04.725]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:04.725]         }, condition = base::local({
[13:22:04.725]             c <- base::c
[13:22:04.725]             inherits <- base::inherits
[13:22:04.725]             invokeRestart <- base::invokeRestart
[13:22:04.725]             length <- base::length
[13:22:04.725]             list <- base::list
[13:22:04.725]             seq.int <- base::seq.int
[13:22:04.725]             signalCondition <- base::signalCondition
[13:22:04.725]             sys.calls <- base::sys.calls
[13:22:04.725]             `[[` <- base::`[[`
[13:22:04.725]             `+` <- base::`+`
[13:22:04.725]             `<<-` <- base::`<<-`
[13:22:04.725]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:04.725]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:04.725]                   3L)]
[13:22:04.725]             }
[13:22:04.725]             function(cond) {
[13:22:04.725]                 is_error <- inherits(cond, "error")
[13:22:04.725]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:04.725]                   NULL)
[13:22:04.725]                 if (is_error) {
[13:22:04.725]                   sessionInformation <- function() {
[13:22:04.725]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:04.725]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:04.725]                       search = base::search(), system = base::Sys.info())
[13:22:04.725]                   }
[13:22:04.725]                   ...future.conditions[[length(...future.conditions) + 
[13:22:04.725]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:04.725]                     cond$call), session = sessionInformation(), 
[13:22:04.725]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:04.725]                   signalCondition(cond)
[13:22:04.725]                 }
[13:22:04.725]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:04.725]                 "immediateCondition"))) {
[13:22:04.725]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:04.725]                   ...future.conditions[[length(...future.conditions) + 
[13:22:04.725]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:04.725]                   if (TRUE && !signal) {
[13:22:04.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:04.725]                     {
[13:22:04.725]                       inherits <- base::inherits
[13:22:04.725]                       invokeRestart <- base::invokeRestart
[13:22:04.725]                       is.null <- base::is.null
[13:22:04.725]                       muffled <- FALSE
[13:22:04.725]                       if (inherits(cond, "message")) {
[13:22:04.725]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:04.725]                         if (muffled) 
[13:22:04.725]                           invokeRestart("muffleMessage")
[13:22:04.725]                       }
[13:22:04.725]                       else if (inherits(cond, "warning")) {
[13:22:04.725]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:04.725]                         if (muffled) 
[13:22:04.725]                           invokeRestart("muffleWarning")
[13:22:04.725]                       }
[13:22:04.725]                       else if (inherits(cond, "condition")) {
[13:22:04.725]                         if (!is.null(pattern)) {
[13:22:04.725]                           computeRestarts <- base::computeRestarts
[13:22:04.725]                           grepl <- base::grepl
[13:22:04.725]                           restarts <- computeRestarts(cond)
[13:22:04.725]                           for (restart in restarts) {
[13:22:04.725]                             name <- restart$name
[13:22:04.725]                             if (is.null(name)) 
[13:22:04.725]                               next
[13:22:04.725]                             if (!grepl(pattern, name)) 
[13:22:04.725]                               next
[13:22:04.725]                             invokeRestart(restart)
[13:22:04.725]                             muffled <- TRUE
[13:22:04.725]                             break
[13:22:04.725]                           }
[13:22:04.725]                         }
[13:22:04.725]                       }
[13:22:04.725]                       invisible(muffled)
[13:22:04.725]                     }
[13:22:04.725]                     muffleCondition(cond, pattern = "^muffle")
[13:22:04.725]                   }
[13:22:04.725]                 }
[13:22:04.725]                 else {
[13:22:04.725]                   if (TRUE) {
[13:22:04.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:04.725]                     {
[13:22:04.725]                       inherits <- base::inherits
[13:22:04.725]                       invokeRestart <- base::invokeRestart
[13:22:04.725]                       is.null <- base::is.null
[13:22:04.725]                       muffled <- FALSE
[13:22:04.725]                       if (inherits(cond, "message")) {
[13:22:04.725]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:04.725]                         if (muffled) 
[13:22:04.725]                           invokeRestart("muffleMessage")
[13:22:04.725]                       }
[13:22:04.725]                       else if (inherits(cond, "warning")) {
[13:22:04.725]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:04.725]                         if (muffled) 
[13:22:04.725]                           invokeRestart("muffleWarning")
[13:22:04.725]                       }
[13:22:04.725]                       else if (inherits(cond, "condition")) {
[13:22:04.725]                         if (!is.null(pattern)) {
[13:22:04.725]                           computeRestarts <- base::computeRestarts
[13:22:04.725]                           grepl <- base::grepl
[13:22:04.725]                           restarts <- computeRestarts(cond)
[13:22:04.725]                           for (restart in restarts) {
[13:22:04.725]                             name <- restart$name
[13:22:04.725]                             if (is.null(name)) 
[13:22:04.725]                               next
[13:22:04.725]                             if (!grepl(pattern, name)) 
[13:22:04.725]                               next
[13:22:04.725]                             invokeRestart(restart)
[13:22:04.725]                             muffled <- TRUE
[13:22:04.725]                             break
[13:22:04.725]                           }
[13:22:04.725]                         }
[13:22:04.725]                       }
[13:22:04.725]                       invisible(muffled)
[13:22:04.725]                     }
[13:22:04.725]                     muffleCondition(cond, pattern = "^muffle")
[13:22:04.725]                   }
[13:22:04.725]                 }
[13:22:04.725]             }
[13:22:04.725]         }))
[13:22:04.725]     }, error = function(ex) {
[13:22:04.725]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:04.725]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:04.725]                 ...future.rng), started = ...future.startTime, 
[13:22:04.725]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:04.725]             version = "1.8"), class = "FutureResult")
[13:22:04.725]     }, finally = {
[13:22:04.725]         if (!identical(...future.workdir, getwd())) 
[13:22:04.725]             setwd(...future.workdir)
[13:22:04.725]         {
[13:22:04.725]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:04.725]                 ...future.oldOptions$nwarnings <- NULL
[13:22:04.725]             }
[13:22:04.725]             base::options(...future.oldOptions)
[13:22:04.725]             if (.Platform$OS.type == "windows") {
[13:22:04.725]                 old_names <- names(...future.oldEnvVars)
[13:22:04.725]                 envs <- base::Sys.getenv()
[13:22:04.725]                 names <- names(envs)
[13:22:04.725]                 common <- intersect(names, old_names)
[13:22:04.725]                 added <- setdiff(names, old_names)
[13:22:04.725]                 removed <- setdiff(old_names, names)
[13:22:04.725]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:04.725]                   envs[common]]
[13:22:04.725]                 NAMES <- toupper(changed)
[13:22:04.725]                 args <- list()
[13:22:04.725]                 for (kk in seq_along(NAMES)) {
[13:22:04.725]                   name <- changed[[kk]]
[13:22:04.725]                   NAME <- NAMES[[kk]]
[13:22:04.725]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:04.725]                     next
[13:22:04.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:04.725]                 }
[13:22:04.725]                 NAMES <- toupper(added)
[13:22:04.725]                 for (kk in seq_along(NAMES)) {
[13:22:04.725]                   name <- added[[kk]]
[13:22:04.725]                   NAME <- NAMES[[kk]]
[13:22:04.725]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:04.725]                     next
[13:22:04.725]                   args[[name]] <- ""
[13:22:04.725]                 }
[13:22:04.725]                 NAMES <- toupper(removed)
[13:22:04.725]                 for (kk in seq_along(NAMES)) {
[13:22:04.725]                   name <- removed[[kk]]
[13:22:04.725]                   NAME <- NAMES[[kk]]
[13:22:04.725]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:04.725]                     next
[13:22:04.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:04.725]                 }
[13:22:04.725]                 if (length(args) > 0) 
[13:22:04.725]                   base::do.call(base::Sys.setenv, args = args)
[13:22:04.725]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:04.725]             }
[13:22:04.725]             else {
[13:22:04.725]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:04.725]             }
[13:22:04.725]             {
[13:22:04.725]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:04.725]                   0L) {
[13:22:04.725]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:04.725]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:04.725]                   base::options(opts)
[13:22:04.725]                 }
[13:22:04.725]                 {
[13:22:04.725]                   {
[13:22:04.725]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:04.725]                     NULL
[13:22:04.725]                   }
[13:22:04.725]                   options(future.plan = NULL)
[13:22:04.725]                   if (is.na(NA_character_)) 
[13:22:04.725]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:04.725]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:04.725]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:04.725]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:04.725]                     envir = parent.frame()) 
[13:22:04.725]                   {
[13:22:04.725]                     if (is.function(workers)) 
[13:22:04.725]                       workers <- workers()
[13:22:04.725]                     workers <- structure(as.integer(workers), 
[13:22:04.725]                       class = class(workers))
[13:22:04.725]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:04.725]                       workers >= 1)
[13:22:04.725]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:04.725]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:04.725]                     }
[13:22:04.725]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:04.725]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:04.725]                       envir = envir)
[13:22:04.725]                     if (!future$lazy) 
[13:22:04.725]                       future <- run(future)
[13:22:04.725]                     invisible(future)
[13:22:04.725]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:04.725]                 }
[13:22:04.725]             }
[13:22:04.725]         }
[13:22:04.725]     })
[13:22:04.725]     if (FALSE) {
[13:22:04.725]         base::sink(type = "output", split = FALSE)
[13:22:04.725]         if (NA) {
[13:22:04.725]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:04.725]         }
[13:22:04.725]         else {
[13:22:04.725]             ...future.result["stdout"] <- base::list(NULL)
[13:22:04.725]         }
[13:22:04.725]         base::close(...future.stdout)
[13:22:04.725]         ...future.stdout <- NULL
[13:22:04.725]     }
[13:22:04.725]     ...future.result$conditions <- ...future.conditions
[13:22:04.725]     ...future.result$finished <- base::Sys.time()
[13:22:04.725]     ...future.result
[13:22:04.725] }
[13:22:04.728] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[13:22:04.728] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[13:22:04.729] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[13:22:04.729] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[13:22:04.729] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[13:22:04.729] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[13:22:04.730] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[13:22:04.730] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:22:04.730] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:22:04.730] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:22:04.730] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:22:04.730] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[13:22:04.731] MultisessionFuture started
[13:22:04.731] - Launch lazy future ... done
[13:22:04.731] run() for ‘MultisessionFuture’ ... done
[13:22:04.731] Created future:
[13:22:04.731] MultisessionFuture:
[13:22:04.731] Label: ‘future_mapply-2’
[13:22:04.731] Expression:
[13:22:04.731] {
[13:22:04.731]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:22:04.731]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:22:04.731]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:22:04.731]         on.exit(options(oopts), add = TRUE)
[13:22:04.731]     }
[13:22:04.731]     {
[13:22:04.731]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:22:04.731]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:22:04.731]         do.call(mapply, args = args)
[13:22:04.731]     }
[13:22:04.731] }
[13:22:04.731] Lazy evaluation: FALSE
[13:22:04.731] Asynchronous evaluation: TRUE
[13:22:04.731] Local evaluation: TRUE
[13:22:04.731] Environment: R_GlobalEnv
[13:22:04.731] Capture standard output: NA
[13:22:04.731] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:22:04.731] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:22:04.731] Packages: <none>
[13:22:04.731] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:22:04.731] Resolved: FALSE
[13:22:04.731] Value: <not collected>
[13:22:04.731] Conditions captured: <none>
[13:22:04.731] Early signaling: FALSE
[13:22:04.731] Owner process: 64164a80-05ec-fdd8-0070-1a2681101b79
[13:22:04.731] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:04.743] Chunk #2 of 2 ... DONE
[13:22:04.743] Launching 2 futures (chunks) ... DONE
[13:22:04.743] Resolving 2 futures (chunks) ...
[13:22:04.743] resolve() on list ...
[13:22:04.744]  recursive: 0
[13:22:04.744]  length: 2
[13:22:04.744] 
[13:22:04.786] receiveMessageFromWorker() for ClusterFuture ...
[13:22:04.786] - Validating connection of MultisessionFuture
[13:22:04.787] - received message: FutureResult
[13:22:04.787] - Received FutureResult
[13:22:04.787] - Erased future from FutureRegistry
[13:22:04.787] result() for ClusterFuture ...
[13:22:04.787] - result already collected: FutureResult
[13:22:04.787] result() for ClusterFuture ... done
[13:22:04.787] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:04.787] Future #2
[13:22:04.787] result() for ClusterFuture ...
[13:22:04.787] - result already collected: FutureResult
[13:22:04.788] result() for ClusterFuture ... done
[13:22:04.788] result() for ClusterFuture ...
[13:22:04.788] - result already collected: FutureResult
[13:22:04.788] result() for ClusterFuture ... done
[13:22:04.788] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:22:04.788] - nx: 2
[13:22:04.788] - relay: TRUE
[13:22:04.788] - stdout: TRUE
[13:22:04.788] - signal: TRUE
[13:22:04.788] - resignal: FALSE
[13:22:04.788] - force: TRUE
[13:22:04.789] - relayed: [n=2] FALSE, FALSE
[13:22:04.789] - queued futures: [n=2] FALSE, FALSE
[13:22:04.789]  - until=1
[13:22:04.789]  - relaying element #1
[13:22:04.789] - relayed: [n=2] FALSE, FALSE
[13:22:04.789] - queued futures: [n=2] FALSE, TRUE
[13:22:04.789] signalConditionsASAP(NULL, pos=2) ... done
[13:22:04.789]  length: 1 (resolved future 2)
[13:22:05.240] receiveMessageFromWorker() for ClusterFuture ...
[13:22:05.240] - Validating connection of MultisessionFuture
[13:22:05.241] - received message: FutureResult
[13:22:05.241] - Received FutureResult
[13:22:05.241] - Erased future from FutureRegistry
[13:22:05.241] result() for ClusterFuture ...
[13:22:05.241] - result already collected: FutureResult
[13:22:05.241] result() for ClusterFuture ... done
[13:22:05.241] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:05.241] Future #1
[13:22:05.241] result() for ClusterFuture ...
[13:22:05.241] - result already collected: FutureResult
[13:22:05.242] result() for ClusterFuture ... done
[13:22:05.242] result() for ClusterFuture ...
[13:22:05.242] - result already collected: FutureResult
[13:22:05.242] result() for ClusterFuture ... done
[13:22:05.242] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:22:05.242] - nx: 2
[13:22:05.242] - relay: TRUE
[13:22:05.242] - stdout: TRUE
[13:22:05.242] - signal: TRUE
[13:22:05.242] - resignal: FALSE
[13:22:05.242] - force: TRUE
[13:22:05.242] - relayed: [n=2] FALSE, FALSE
[13:22:05.243] - queued futures: [n=2] FALSE, TRUE
[13:22:05.243]  - until=1
[13:22:05.243]  - relaying element #1
[13:22:05.243] result() for ClusterFuture ...
[13:22:05.243] - result already collected: FutureResult
[13:22:05.243] result() for ClusterFuture ... done
[13:22:05.243] result() for ClusterFuture ...
[13:22:05.243] - result already collected: FutureResult
[13:22:05.243] result() for ClusterFuture ... done
[13:22:05.243] result() for ClusterFuture ...
[13:22:05.243] - result already collected: FutureResult
[13:22:05.244] result() for ClusterFuture ... done
[13:22:05.244] result() for ClusterFuture ...
[13:22:05.244] - result already collected: FutureResult
[13:22:05.244] result() for ClusterFuture ... done
[13:22:05.244] - relayed: [n=2] TRUE, FALSE
[13:22:05.244] - queued futures: [n=2] TRUE, TRUE
[13:22:05.244] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:22:05.244]  length: 0 (resolved future 1)
[13:22:05.244] Relaying remaining futures
[13:22:05.244] signalConditionsASAP(NULL, pos=0) ...
[13:22:05.244] - nx: 2
[13:22:05.245] - relay: TRUE
[13:22:05.245] - stdout: TRUE
[13:22:05.245] - signal: TRUE
[13:22:05.245] - resignal: FALSE
[13:22:05.245] - force: TRUE
[13:22:05.245] - relayed: [n=2] TRUE, FALSE
[13:22:05.245] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:22:05.245]  - relaying element #2
[13:22:05.245] result() for ClusterFuture ...
[13:22:05.245] - result already collected: FutureResult
[13:22:05.245] result() for ClusterFuture ... done
[13:22:05.245] result() for ClusterFuture ...
[13:22:05.246] - result already collected: FutureResult
[13:22:05.246] result() for ClusterFuture ... done
[13:22:05.246] result() for ClusterFuture ...
[13:22:05.246] - result already collected: FutureResult
[13:22:05.246] result() for ClusterFuture ... done
[13:22:05.246] result() for ClusterFuture ...
[13:22:05.246] - result already collected: FutureResult
[13:22:05.246] result() for ClusterFuture ... done
[13:22:05.246] - relayed: [n=2] TRUE, TRUE
[13:22:05.246] - queued futures: [n=2] TRUE, TRUE
[13:22:05.247] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[13:22:05.247] resolve() on list ... DONE
[13:22:05.247] result() for ClusterFuture ...
[13:22:05.247] - result already collected: FutureResult
[13:22:05.247] result() for ClusterFuture ... done
[13:22:05.247] result() for ClusterFuture ...
[13:22:05.247] - result already collected: FutureResult
[13:22:05.247] result() for ClusterFuture ... done
[13:22:05.247] result() for ClusterFuture ...
[13:22:05.247] - result already collected: FutureResult
[13:22:05.247] result() for ClusterFuture ... done
[13:22:05.247] result() for ClusterFuture ...
[13:22:05.248] - result already collected: FutureResult
[13:22:05.248] result() for ClusterFuture ... done
[13:22:05.248]  - Number of value chunks collected: 2
[13:22:05.248] Resolving 2 futures (chunks) ... DONE
[13:22:05.248] Reducing values from 2 chunks ...
[13:22:05.248]  - Number of values collected after concatenation: 2
[13:22:05.248]  - Number of values expected: 2
[13:22:05.248] Reducing values from 2 chunks ... DONE
[13:22:05.248] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 2 cores ... DONE
> 
> message("*** future_*apply() and 'future.stdout' ... DONE")
*** future_*apply() and 'future.stdout' ... DONE
> 
> source("incl/end.R")
[13:22:05.249] plan(): Setting new future strategy stack:
[13:22:05.249] List of future strategies:
[13:22:05.249] 1. FutureStrategy:
[13:22:05.249]    - args: function (..., envir = parent.frame())
[13:22:05.249]    - tweaked: FALSE
[13:22:05.249]    - call: future::plan(oplan)
[13:22:05.250] plan(): nbrOfWorkers() = 1
> 
