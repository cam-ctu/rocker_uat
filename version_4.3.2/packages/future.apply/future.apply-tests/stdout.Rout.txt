
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[10:24:31.013] plan(): Setting new future strategy stack:
[10:24:31.013] List of future strategies:
[10:24:31.013] 1. sequential:
[10:24:31.013]    - args: function (..., envir = parent.frame())
[10:24:31.013]    - tweaked: FALSE
[10:24:31.013]    - call: future::plan("sequential")
[10:24:31.028] plan(): nbrOfWorkers() = 1
> 
> message("*** future_*apply() and 'future.stdout' ...")
*** future_*apply() and 'future.stdout' ...
> 
> options(future.debug = TRUE)
> 
> truth <- list()
> 
> out <- utils::capture.output({
+   y <- lapply(1:0, FUN = function(x) {
+     print(x)
+   })
+ })
> truth[["lapply"]] <- list(value = y, stdout = out)
> 
> out <- utils::capture.output({
+   y <- mapply(1:0, 0:1, FUN = function(x, y) {
+     print(list(x = x, y = y))
+   })
+ })
> truth[["mapply"]] <- list(value = y, stdout = out)
> 
> for (cores in 1:availCores) {
+   message(sprintf("  - Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+   
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("* plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     for (fun in names(truth)) {
+       for (stdout in c(FALSE, TRUE, NA)) {
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ...", fun, stdout))
+   
+         out <- utils::capture.output({
+           if (fun == "lapply") {
+             y <- future_lapply(1:0, FUN = function(x) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+ 	      print(x)
+             }, future.stdout = stdout)
+ 	  } else if (fun == "mapply") {
+             y <- future_mapply(1:0, 0:1, FUN = function(x, y) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+               print(list(x = x, y = y))
+             }, future.stdout = stdout)
+ 	  }
+         })
+         stopifnot(identical(y, truth[[fun]]$value))
+   
+         if (isTRUE(stdout)) {
+           stopifnot(identical(out, truth[[fun]]$stdout))
+         } else if (is.na(stdout)) {
+         } else {
+           stopifnot(nchar(out) == 0)
+         }
+       
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ... DONE", fun, stdout))
+       } ## for (stdout ...)
+     } ## for (fun ...)
+     
+     message(sprintf("* plan('%s') ... DONE", strategy))
+   }
+   
+   message(sprintf("  - Testing with %d cores ... DONE", cores))
+ }
  - Testing with 1 cores ...
* plan('sequential') ...
[10:24:31.061] plan(): Setting new future strategy stack:
[10:24:31.061] List of future strategies:
[10:24:31.061] 1. sequential:
[10:24:31.061]    - args: function (..., envir = parent.frame())
[10:24:31.061]    - tweaked: FALSE
[10:24:31.061]    - call: plan(strategy)
[10:24:31.072] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[10:24:31.072] future_lapply() ...
[10:24:31.077] Number of chunks: 1
[10:24:31.077] getGlobalsAndPackagesXApply() ...
[10:24:31.077]  - future.globals: TRUE
[10:24:31.078] getGlobalsAndPackages() ...
[10:24:31.078] Searching for globals...
[10:24:31.081] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:24:31.081] Searching for globals ... DONE
[10:24:31.081] Resolving globals: FALSE
[10:24:31.082] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[10:24:31.083] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[10:24:31.083] - globals: [1] ‘FUN’
[10:24:31.083] 
[10:24:31.083] getGlobalsAndPackages() ... DONE
[10:24:31.083]  - globals found/used: [n=1] ‘FUN’
[10:24:31.083]  - needed namespaces: [n=0] 
[10:24:31.083] Finding globals ... DONE
[10:24:31.083]  - use_args: TRUE
[10:24:31.083]  - Getting '...' globals ...
[10:24:31.084] resolve() on list ...
[10:24:31.084]  recursive: 0
[10:24:31.085]  length: 1
[10:24:31.085]  elements: ‘...’
[10:24:31.085]  length: 0 (resolved future 1)
[10:24:31.085] resolve() on list ... DONE
[10:24:31.085]    - '...' content: [n=0] 
[10:24:31.085] List of 1
[10:24:31.085]  $ ...: list()
[10:24:31.085]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:31.085]  - attr(*, "where")=List of 1
[10:24:31.085]   ..$ ...:<environment: 0x55d211444cb0> 
[10:24:31.085]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:31.085]  - attr(*, "resolved")= logi TRUE
[10:24:31.085]  - attr(*, "total_size")= num NA
[10:24:31.092]  - Getting '...' globals ... DONE
[10:24:31.092] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:24:31.093] List of 2
[10:24:31.093]  $ ...future.FUN:function (x)  
[10:24:31.093]  $ ...          : list()
[10:24:31.093]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:31.093]  - attr(*, "where")=List of 2
[10:24:31.093]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:31.093]   ..$ ...          :<environment: 0x55d211444cb0> 
[10:24:31.093]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:31.093]  - attr(*, "resolved")= logi FALSE
[10:24:31.093]  - attr(*, "total_size")= num 4720
[10:24:31.095] Packages to be attached in all futures: [n=0] 
[10:24:31.095] getGlobalsAndPackagesXApply() ... DONE
[10:24:31.096] Number of futures (= number of chunks): 1
[10:24:31.096] Launching 1 futures (chunks) ...
[10:24:31.096] Chunk #1 of 1 ...
[10:24:31.096]  - Finding globals in 'X' for chunk #1 ...
[10:24:31.096] getGlobalsAndPackages() ...
[10:24:31.096] Searching for globals...
[10:24:31.097] 
[10:24:31.097] Searching for globals ... DONE
[10:24:31.097] - globals: [0] <none>
[10:24:31.097] getGlobalsAndPackages() ... DONE
[10:24:31.097]    + additional globals found: [n=0] 
[10:24:31.097]    + additional namespaces needed: [n=0] 
[10:24:31.097]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:31.097]  - seeds: <none>
[10:24:31.097]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:31.098] getGlobalsAndPackages() ...
[10:24:31.098] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:31.098] Resolving globals: FALSE
[10:24:31.098] Tweak future expression to call with '...' arguments ...
[10:24:31.098] {
[10:24:31.098]     do.call(function(...) {
[10:24:31.098]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:31.098]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:31.098]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:31.098]             on.exit(options(oopts), add = TRUE)
[10:24:31.098]         }
[10:24:31.098]         {
[10:24:31.098]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:31.098]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:31.098]                 ...future.FUN(...future.X_jj, ...)
[10:24:31.098]             })
[10:24:31.098]         }
[10:24:31.098]     }, args = future.call.arguments)
[10:24:31.098] }
[10:24:31.098] Tweak future expression to call with '...' arguments ... DONE
[10:24:31.099] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:31.099] 
[10:24:31.099] getGlobalsAndPackages() ... DONE
[10:24:31.100] run() for ‘Future’ ...
[10:24:31.100] - state: ‘created’
[10:24:31.100] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:24:31.100] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:31.100] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:31.101]   - Field: ‘label’
[10:24:31.101]   - Field: ‘local’
[10:24:31.101]   - Field: ‘owner’
[10:24:31.101]   - Field: ‘envir’
[10:24:31.101]   - Field: ‘packages’
[10:24:31.101]   - Field: ‘gc’
[10:24:31.101]   - Field: ‘conditions’
[10:24:31.101]   - Field: ‘expr’
[10:24:31.101]   - Field: ‘uuid’
[10:24:31.101]   - Field: ‘seed’
[10:24:31.101]   - Field: ‘version’
[10:24:31.102]   - Field: ‘result’
[10:24:31.102]   - Field: ‘asynchronous’
[10:24:31.102]   - Field: ‘calls’
[10:24:31.102]   - Field: ‘globals’
[10:24:31.102]   - Field: ‘stdout’
[10:24:31.102]   - Field: ‘earlySignal’
[10:24:31.102]   - Field: ‘lazy’
[10:24:31.102]   - Field: ‘state’
[10:24:31.102] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:31.102] - Launch lazy future ...
[10:24:31.103] Packages needed by the future expression (n = 0): <none>
[10:24:31.103] Packages needed by future strategies (n = 0): <none>
[10:24:31.104] {
[10:24:31.104]     {
[10:24:31.104]         {
[10:24:31.104]             ...future.startTime <- base::Sys.time()
[10:24:31.104]             {
[10:24:31.104]                 {
[10:24:31.104]                   {
[10:24:31.104]                     base::local({
[10:24:31.104]                       has_future <- base::requireNamespace("future", 
[10:24:31.104]                         quietly = TRUE)
[10:24:31.104]                       if (has_future) {
[10:24:31.104]                         ns <- base::getNamespace("future")
[10:24:31.104]                         version <- ns[[".package"]][["version"]]
[10:24:31.104]                         if (is.null(version)) 
[10:24:31.104]                           version <- utils::packageVersion("future")
[10:24:31.104]                       }
[10:24:31.104]                       else {
[10:24:31.104]                         version <- NULL
[10:24:31.104]                       }
[10:24:31.104]                       if (!has_future || version < "1.8.0") {
[10:24:31.104]                         info <- base::c(r_version = base::gsub("R version ", 
[10:24:31.104]                           "", base::R.version$version.string), 
[10:24:31.104]                           platform = base::sprintf("%s (%s-bit)", 
[10:24:31.104]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:31.104]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:31.104]                             "release", "version")], collapse = " "), 
[10:24:31.104]                           hostname = base::Sys.info()[["nodename"]])
[10:24:31.104]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:24:31.104]                           info)
[10:24:31.104]                         info <- base::paste(info, collapse = "; ")
[10:24:31.104]                         if (!has_future) {
[10:24:31.104]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:31.104]                             info)
[10:24:31.104]                         }
[10:24:31.104]                         else {
[10:24:31.104]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:31.104]                             info, version)
[10:24:31.104]                         }
[10:24:31.104]                         base::stop(msg)
[10:24:31.104]                       }
[10:24:31.104]                     })
[10:24:31.104]                   }
[10:24:31.104]                   options(future.plan = NULL)
[10:24:31.104]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:31.104]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:31.104]                 }
[10:24:31.104]                 ...future.workdir <- getwd()
[10:24:31.104]             }
[10:24:31.104]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:31.104]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:31.104]         }
[10:24:31.104]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:31.104]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:31.104]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:31.104]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:31.104]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:31.104]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:31.104]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:31.104]             base::names(...future.oldOptions))
[10:24:31.104]     }
[10:24:31.104]     if (FALSE) {
[10:24:31.104]     }
[10:24:31.104]     else {
[10:24:31.104]         if (FALSE) {
[10:24:31.104]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:31.104]                 open = "w")
[10:24:31.104]         }
[10:24:31.104]         else {
[10:24:31.104]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:31.104]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:31.104]         }
[10:24:31.104]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:31.104]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:31.104]             base::sink(type = "output", split = FALSE)
[10:24:31.104]             base::close(...future.stdout)
[10:24:31.104]         }, add = TRUE)
[10:24:31.104]     }
[10:24:31.104]     ...future.frame <- base::sys.nframe()
[10:24:31.104]     ...future.conditions <- base::list()
[10:24:31.104]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:31.104]     if (FALSE) {
[10:24:31.104]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:31.104]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:31.104]     }
[10:24:31.104]     ...future.result <- base::tryCatch({
[10:24:31.104]         base::withCallingHandlers({
[10:24:31.104]             ...future.value <- base::withVisible(base::local({
[10:24:31.104]                 do.call(function(...) {
[10:24:31.104]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:31.104]                   if (!identical(...future.globals.maxSize.org, 
[10:24:31.104]                     ...future.globals.maxSize)) {
[10:24:31.104]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:31.104]                     on.exit(options(oopts), add = TRUE)
[10:24:31.104]                   }
[10:24:31.104]                   {
[10:24:31.104]                     lapply(seq_along(...future.elements_ii), 
[10:24:31.104]                       FUN = function(jj) {
[10:24:31.104]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:31.104]                         ...future.FUN(...future.X_jj, ...)
[10:24:31.104]                       })
[10:24:31.104]                   }
[10:24:31.104]                 }, args = future.call.arguments)
[10:24:31.104]             }))
[10:24:31.104]             future::FutureResult(value = ...future.value$value, 
[10:24:31.104]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:31.104]                   ...future.rng), globalenv = if (FALSE) 
[10:24:31.104]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:31.104]                     ...future.globalenv.names))
[10:24:31.104]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:31.104]         }, condition = base::local({
[10:24:31.104]             c <- base::c
[10:24:31.104]             inherits <- base::inherits
[10:24:31.104]             invokeRestart <- base::invokeRestart
[10:24:31.104]             length <- base::length
[10:24:31.104]             list <- base::list
[10:24:31.104]             seq.int <- base::seq.int
[10:24:31.104]             signalCondition <- base::signalCondition
[10:24:31.104]             sys.calls <- base::sys.calls
[10:24:31.104]             `[[` <- base::`[[`
[10:24:31.104]             `+` <- base::`+`
[10:24:31.104]             `<<-` <- base::`<<-`
[10:24:31.104]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:31.104]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:31.104]                   3L)]
[10:24:31.104]             }
[10:24:31.104]             function(cond) {
[10:24:31.104]                 is_error <- inherits(cond, "error")
[10:24:31.104]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:31.104]                   NULL)
[10:24:31.104]                 if (is_error) {
[10:24:31.104]                   sessionInformation <- function() {
[10:24:31.104]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:31.104]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:31.104]                       search = base::search(), system = base::Sys.info())
[10:24:31.104]                   }
[10:24:31.104]                   ...future.conditions[[length(...future.conditions) + 
[10:24:31.104]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:31.104]                     cond$call), session = sessionInformation(), 
[10:24:31.104]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:31.104]                   signalCondition(cond)
[10:24:31.104]                 }
[10:24:31.104]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:31.104]                 "immediateCondition"))) {
[10:24:31.104]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:31.104]                   ...future.conditions[[length(...future.conditions) + 
[10:24:31.104]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:31.104]                   if (TRUE && !signal) {
[10:24:31.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:31.104]                     {
[10:24:31.104]                       inherits <- base::inherits
[10:24:31.104]                       invokeRestart <- base::invokeRestart
[10:24:31.104]                       is.null <- base::is.null
[10:24:31.104]                       muffled <- FALSE
[10:24:31.104]                       if (inherits(cond, "message")) {
[10:24:31.104]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:31.104]                         if (muffled) 
[10:24:31.104]                           invokeRestart("muffleMessage")
[10:24:31.104]                       }
[10:24:31.104]                       else if (inherits(cond, "warning")) {
[10:24:31.104]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:31.104]                         if (muffled) 
[10:24:31.104]                           invokeRestart("muffleWarning")
[10:24:31.104]                       }
[10:24:31.104]                       else if (inherits(cond, "condition")) {
[10:24:31.104]                         if (!is.null(pattern)) {
[10:24:31.104]                           computeRestarts <- base::computeRestarts
[10:24:31.104]                           grepl <- base::grepl
[10:24:31.104]                           restarts <- computeRestarts(cond)
[10:24:31.104]                           for (restart in restarts) {
[10:24:31.104]                             name <- restart$name
[10:24:31.104]                             if (is.null(name)) 
[10:24:31.104]                               next
[10:24:31.104]                             if (!grepl(pattern, name)) 
[10:24:31.104]                               next
[10:24:31.104]                             invokeRestart(restart)
[10:24:31.104]                             muffled <- TRUE
[10:24:31.104]                             break
[10:24:31.104]                           }
[10:24:31.104]                         }
[10:24:31.104]                       }
[10:24:31.104]                       invisible(muffled)
[10:24:31.104]                     }
[10:24:31.104]                     muffleCondition(cond, pattern = "^muffle")
[10:24:31.104]                   }
[10:24:31.104]                 }
[10:24:31.104]                 else {
[10:24:31.104]                   if (TRUE) {
[10:24:31.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:31.104]                     {
[10:24:31.104]                       inherits <- base::inherits
[10:24:31.104]                       invokeRestart <- base::invokeRestart
[10:24:31.104]                       is.null <- base::is.null
[10:24:31.104]                       muffled <- FALSE
[10:24:31.104]                       if (inherits(cond, "message")) {
[10:24:31.104]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:31.104]                         if (muffled) 
[10:24:31.104]                           invokeRestart("muffleMessage")
[10:24:31.104]                       }
[10:24:31.104]                       else if (inherits(cond, "warning")) {
[10:24:31.104]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:31.104]                         if (muffled) 
[10:24:31.104]                           invokeRestart("muffleWarning")
[10:24:31.104]                       }
[10:24:31.104]                       else if (inherits(cond, "condition")) {
[10:24:31.104]                         if (!is.null(pattern)) {
[10:24:31.104]                           computeRestarts <- base::computeRestarts
[10:24:31.104]                           grepl <- base::grepl
[10:24:31.104]                           restarts <- computeRestarts(cond)
[10:24:31.104]                           for (restart in restarts) {
[10:24:31.104]                             name <- restart$name
[10:24:31.104]                             if (is.null(name)) 
[10:24:31.104]                               next
[10:24:31.104]                             if (!grepl(pattern, name)) 
[10:24:31.104]                               next
[10:24:31.104]                             invokeRestart(restart)
[10:24:31.104]                             muffled <- TRUE
[10:24:31.104]                             break
[10:24:31.104]                           }
[10:24:31.104]                         }
[10:24:31.104]                       }
[10:24:31.104]                       invisible(muffled)
[10:24:31.104]                     }
[10:24:31.104]                     muffleCondition(cond, pattern = "^muffle")
[10:24:31.104]                   }
[10:24:31.104]                 }
[10:24:31.104]             }
[10:24:31.104]         }))
[10:24:31.104]     }, error = function(ex) {
[10:24:31.104]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:31.104]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:31.104]                 ...future.rng), started = ...future.startTime, 
[10:24:31.104]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:31.104]             version = "1.8"), class = "FutureResult")
[10:24:31.104]     }, finally = {
[10:24:31.104]         if (!identical(...future.workdir, getwd())) 
[10:24:31.104]             setwd(...future.workdir)
[10:24:31.104]         {
[10:24:31.104]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:31.104]                 ...future.oldOptions$nwarnings <- NULL
[10:24:31.104]             }
[10:24:31.104]             base::options(...future.oldOptions)
[10:24:31.104]             if (.Platform$OS.type == "windows") {
[10:24:31.104]                 old_names <- names(...future.oldEnvVars)
[10:24:31.104]                 envs <- base::Sys.getenv()
[10:24:31.104]                 names <- names(envs)
[10:24:31.104]                 common <- intersect(names, old_names)
[10:24:31.104]                 added <- setdiff(names, old_names)
[10:24:31.104]                 removed <- setdiff(old_names, names)
[10:24:31.104]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:31.104]                   envs[common]]
[10:24:31.104]                 NAMES <- toupper(changed)
[10:24:31.104]                 args <- list()
[10:24:31.104]                 for (kk in seq_along(NAMES)) {
[10:24:31.104]                   name <- changed[[kk]]
[10:24:31.104]                   NAME <- NAMES[[kk]]
[10:24:31.104]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:31.104]                     next
[10:24:31.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:31.104]                 }
[10:24:31.104]                 NAMES <- toupper(added)
[10:24:31.104]                 for (kk in seq_along(NAMES)) {
[10:24:31.104]                   name <- added[[kk]]
[10:24:31.104]                   NAME <- NAMES[[kk]]
[10:24:31.104]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:31.104]                     next
[10:24:31.104]                   args[[name]] <- ""
[10:24:31.104]                 }
[10:24:31.104]                 NAMES <- toupper(removed)
[10:24:31.104]                 for (kk in seq_along(NAMES)) {
[10:24:31.104]                   name <- removed[[kk]]
[10:24:31.104]                   NAME <- NAMES[[kk]]
[10:24:31.104]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:31.104]                     next
[10:24:31.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:31.104]                 }
[10:24:31.104]                 if (length(args) > 0) 
[10:24:31.104]                   base::do.call(base::Sys.setenv, args = args)
[10:24:31.104]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:31.104]             }
[10:24:31.104]             else {
[10:24:31.104]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:31.104]             }
[10:24:31.104]             {
[10:24:31.104]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:31.104]                   0L) {
[10:24:31.104]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:31.104]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:31.104]                   base::options(opts)
[10:24:31.104]                 }
[10:24:31.104]                 {
[10:24:31.104]                   {
[10:24:31.104]                     NULL
[10:24:31.104]                     RNGkind("Mersenne-Twister")
[10:24:31.104]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:31.104]                       inherits = FALSE)
[10:24:31.104]                   }
[10:24:31.104]                   options(future.plan = NULL)
[10:24:31.104]                   if (is.na(NA_character_)) 
[10:24:31.104]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:31.104]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:31.104]                   future::plan(list(function (..., envir = parent.frame()) 
[10:24:31.104]                   {
[10:24:31.104]                     future <- SequentialFuture(..., envir = envir)
[10:24:31.104]                     if (!future$lazy) 
[10:24:31.104]                       future <- run(future)
[10:24:31.104]                     invisible(future)
[10:24:31.104]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:31.104]                 }
[10:24:31.104]             }
[10:24:31.104]         }
[10:24:31.104]     })
[10:24:31.104]     if (TRUE) {
[10:24:31.104]         base::sink(type = "output", split = FALSE)
[10:24:31.104]         if (FALSE) {
[10:24:31.104]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:31.104]         }
[10:24:31.104]         else {
[10:24:31.104]             ...future.result["stdout"] <- base::list(NULL)
[10:24:31.104]         }
[10:24:31.104]         base::close(...future.stdout)
[10:24:31.104]         ...future.stdout <- NULL
[10:24:31.104]     }
[10:24:31.104]     ...future.result$conditions <- ...future.conditions
[10:24:31.104]     ...future.result$finished <- base::Sys.time()
[10:24:31.104]     ...future.result
[10:24:31.104] }
[10:24:31.106] assign_globals() ...
[10:24:31.106] List of 5
[10:24:31.106]  $ ...future.FUN            :function (x)  
[10:24:31.106]  $ future.call.arguments    : list()
[10:24:31.106]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:31.106]  $ ...future.elements_ii    :List of 2
[10:24:31.106]   ..$ : int 1
[10:24:31.106]   ..$ : int 0
[10:24:31.106]  $ ...future.seeds_ii       : NULL
[10:24:31.106]  $ ...future.globals.maxSize: NULL
[10:24:31.106]  - attr(*, "where")=List of 5
[10:24:31.106]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:31.106]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:31.106]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:31.106]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:31.106]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:31.106]  - attr(*, "resolved")= logi FALSE
[10:24:31.106]  - attr(*, "total_size")= num 4720
[10:24:31.106]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:31.106]  - attr(*, "already-done")= logi TRUE
[10:24:31.111] - reassign environment for ‘...future.FUN’
[10:24:31.111] - copied ‘...future.FUN’ to environment
[10:24:31.111] - copied ‘future.call.arguments’ to environment
[10:24:31.111] - copied ‘...future.elements_ii’ to environment
[10:24:31.111] - copied ‘...future.seeds_ii’ to environment
[10:24:31.111] - copied ‘...future.globals.maxSize’ to environment
[10:24:31.111] assign_globals() ... done
[10:24:31.112] plan(): Setting new future strategy stack:
[10:24:31.112] List of future strategies:
[10:24:31.112] 1. sequential:
[10:24:31.112]    - args: function (..., envir = parent.frame())
[10:24:31.112]    - tweaked: FALSE
[10:24:31.112]    - call: NULL
[10:24:31.112] plan(): nbrOfWorkers() = 1
[10:24:31.614] plan(): Setting new future strategy stack:
[10:24:31.615] List of future strategies:
[10:24:31.615] 1. sequential:
[10:24:31.615]    - args: function (..., envir = parent.frame())
[10:24:31.615]    - tweaked: FALSE
[10:24:31.615]    - call: plan(strategy)
[10:24:31.615] plan(): nbrOfWorkers() = 1
[10:24:31.615] SequentialFuture started (and completed)
[10:24:31.616] - Launch lazy future ... done
[10:24:31.616] run() for ‘SequentialFuture’ ... done
[10:24:31.616] Created future:
[10:24:31.616] SequentialFuture:
[10:24:31.616] Label: ‘future_lapply-1’
[10:24:31.616] Expression:
[10:24:31.616] {
[10:24:31.616]     do.call(function(...) {
[10:24:31.616]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:31.616]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:31.616]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:31.616]             on.exit(options(oopts), add = TRUE)
[10:24:31.616]         }
[10:24:31.616]         {
[10:24:31.616]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:31.616]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:31.616]                 ...future.FUN(...future.X_jj, ...)
[10:24:31.616]             })
[10:24:31.616]         }
[10:24:31.616]     }, args = future.call.arguments)
[10:24:31.616] }
[10:24:31.616] Lazy evaluation: FALSE
[10:24:31.616] Asynchronous evaluation: FALSE
[10:24:31.616] Local evaluation: TRUE
[10:24:31.616] Environment: R_GlobalEnv
[10:24:31.616] Capture standard output: FALSE
[10:24:31.616] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:31.616] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:31.616] Packages: <none>
[10:24:31.616] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:31.616] Resolved: TRUE
[10:24:31.616] Value: 112 bytes of class ‘list’
[10:24:31.616] Early signaling: FALSE
[10:24:31.616] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:31.616] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:31.618] Chunk #1 of 1 ... DONE
[10:24:31.618] Launching 1 futures (chunks) ... DONE
[10:24:31.618] Resolving 1 futures (chunks) ...
[10:24:31.618] resolve() on list ...
[10:24:31.618]  recursive: 0
[10:24:31.618]  length: 1
[10:24:31.618] 
[10:24:31.619] resolved() for ‘SequentialFuture’ ...
[10:24:31.619] - state: ‘finished’
[10:24:31.619] - run: TRUE
[10:24:31.619] - result: ‘FutureResult’
[10:24:31.619] resolved() for ‘SequentialFuture’ ... done
[10:24:31.619] Future #1
[10:24:31.620] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:31.620] - nx: 1
[10:24:31.620] - relay: TRUE
[10:24:31.620] - stdout: TRUE
[10:24:31.620] - signal: TRUE
[10:24:31.620] - resignal: FALSE
[10:24:31.620] - force: TRUE
[10:24:31.620] - relayed: [n=1] FALSE
[10:24:31.620] - queued futures: [n=1] FALSE
[10:24:31.620]  - until=1
[10:24:31.620]  - relaying element #1
[10:24:31.621] - relayed: [n=1] TRUE
[10:24:31.621] - queued futures: [n=1] TRUE
[10:24:31.621] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:31.621]  length: 0 (resolved future 1)
[10:24:31.621] Relaying remaining futures
[10:24:31.621] signalConditionsASAP(NULL, pos=0) ...
[10:24:31.623] - nx: 1
[10:24:31.623] - relay: TRUE
[10:24:31.624] - stdout: TRUE
[10:24:31.624] - signal: TRUE
[10:24:31.624] - resignal: FALSE
[10:24:31.624] - force: TRUE
[10:24:31.624] - relayed: [n=1] TRUE
[10:24:31.624] - queued futures: [n=1] TRUE
 - flush all
[10:24:31.624] - relayed: [n=1] TRUE
[10:24:31.624] - queued futures: [n=1] TRUE
[10:24:31.624] signalConditionsASAP(NULL, pos=0) ... done
[10:24:31.624] resolve() on list ... DONE
[10:24:31.625]  - Number of value chunks collected: 1
[10:24:31.625] Resolving 1 futures (chunks) ... DONE
[10:24:31.625] Reducing values from 1 chunks ...
[10:24:31.625]  - Number of values collected after concatenation: 2
[10:24:31.625]  - Number of values expected: 2
[10:24:31.625] Reducing values from 1 chunks ... DONE
[10:24:31.625] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[10:24:31.626] future_lapply() ...
[10:24:31.626] Number of chunks: 1
[10:24:31.627] getGlobalsAndPackagesXApply() ...
[10:24:31.627]  - future.globals: TRUE
[10:24:31.627] getGlobalsAndPackages() ...
[10:24:31.627] Searching for globals...
[10:24:31.628] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:24:31.628] Searching for globals ... DONE
[10:24:31.628] Resolving globals: FALSE
[10:24:31.629] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[10:24:31.629] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[10:24:31.629] - globals: [1] ‘FUN’
[10:24:31.629] 
[10:24:31.629] getGlobalsAndPackages() ... DONE
[10:24:31.630]  - globals found/used: [n=1] ‘FUN’
[10:24:31.630]  - needed namespaces: [n=0] 
[10:24:31.630] Finding globals ... DONE
[10:24:31.630]  - use_args: TRUE
[10:24:31.630]  - Getting '...' globals ...
[10:24:31.630] resolve() on list ...
[10:24:31.630]  recursive: 0
[10:24:31.630]  length: 1
[10:24:31.631]  elements: ‘...’
[10:24:31.631]  length: 0 (resolved future 1)
[10:24:31.631] resolve() on list ... DONE
[10:24:31.631]    - '...' content: [n=0] 
[10:24:31.631] List of 1
[10:24:31.631]  $ ...: list()
[10:24:31.631]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:31.631]  - attr(*, "where")=List of 1
[10:24:31.631]   ..$ ...:<environment: 0x55d20ffb1318> 
[10:24:31.631]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:31.631]  - attr(*, "resolved")= logi TRUE
[10:24:31.631]  - attr(*, "total_size")= num NA
[10:24:31.634]  - Getting '...' globals ... DONE
[10:24:31.634] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:24:31.634] List of 2
[10:24:31.634]  $ ...future.FUN:function (x)  
[10:24:31.634]  $ ...          : list()
[10:24:31.634]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:31.634]  - attr(*, "where")=List of 2
[10:24:31.634]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:31.634]   ..$ ...          :<environment: 0x55d20ffb1318> 
[10:24:31.634]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:31.634]  - attr(*, "resolved")= logi FALSE
[10:24:31.634]  - attr(*, "total_size")= num 4720
[10:24:31.636] Packages to be attached in all futures: [n=0] 
[10:24:31.637] getGlobalsAndPackagesXApply() ... DONE
[10:24:31.637] Number of futures (= number of chunks): 1
[10:24:31.637] Launching 1 futures (chunks) ...
[10:24:31.637] Chunk #1 of 1 ...
[10:24:31.637]  - Finding globals in 'X' for chunk #1 ...
[10:24:31.637] getGlobalsAndPackages() ...
[10:24:31.637] Searching for globals...
[10:24:31.638] 
[10:24:31.638] Searching for globals ... DONE
[10:24:31.638] - globals: [0] <none>
[10:24:31.638] getGlobalsAndPackages() ... DONE
[10:24:31.638]    + additional globals found: [n=0] 
[10:24:31.638]    + additional namespaces needed: [n=0] 
[10:24:31.638]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:31.638]  - seeds: <none>
[10:24:31.638]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:31.638] getGlobalsAndPackages() ...
[10:24:31.638] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:31.639] Resolving globals: FALSE
[10:24:31.639] Tweak future expression to call with '...' arguments ...
[10:24:31.639] {
[10:24:31.639]     do.call(function(...) {
[10:24:31.639]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:31.639]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:31.639]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:31.639]             on.exit(options(oopts), add = TRUE)
[10:24:31.639]         }
[10:24:31.639]         {
[10:24:31.639]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:31.639]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:31.639]                 ...future.FUN(...future.X_jj, ...)
[10:24:31.639]             })
[10:24:31.639]         }
[10:24:31.639]     }, args = future.call.arguments)
[10:24:31.639] }
[10:24:31.639] Tweak future expression to call with '...' arguments ... DONE
[10:24:31.639] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:31.639] 
[10:24:31.640] getGlobalsAndPackages() ... DONE
[10:24:31.640] run() for ‘Future’ ...
[10:24:31.640] - state: ‘created’
[10:24:31.640] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:24:31.640] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:31.640] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:31.641]   - Field: ‘label’
[10:24:31.641]   - Field: ‘local’
[10:24:31.641]   - Field: ‘owner’
[10:24:31.641]   - Field: ‘envir’
[10:24:31.641]   - Field: ‘packages’
[10:24:31.641]   - Field: ‘gc’
[10:24:31.641]   - Field: ‘conditions’
[10:24:31.641]   - Field: ‘expr’
[10:24:31.641]   - Field: ‘uuid’
[10:24:31.642]   - Field: ‘seed’
[10:24:31.642]   - Field: ‘version’
[10:24:31.642]   - Field: ‘result’
[10:24:31.642]   - Field: ‘asynchronous’
[10:24:31.642]   - Field: ‘calls’
[10:24:31.642]   - Field: ‘globals’
[10:24:31.642]   - Field: ‘stdout’
[10:24:31.642]   - Field: ‘earlySignal’
[10:24:31.642]   - Field: ‘lazy’
[10:24:31.642]   - Field: ‘state’
[10:24:31.642] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:31.643] - Launch lazy future ...
[10:24:31.643] Packages needed by the future expression (n = 0): <none>
[10:24:31.643] Packages needed by future strategies (n = 0): <none>
[10:24:31.643] {
[10:24:31.643]     {
[10:24:31.643]         {
[10:24:31.643]             ...future.startTime <- base::Sys.time()
[10:24:31.643]             {
[10:24:31.643]                 {
[10:24:31.643]                   {
[10:24:31.643]                     base::local({
[10:24:31.643]                       has_future <- base::requireNamespace("future", 
[10:24:31.643]                         quietly = TRUE)
[10:24:31.643]                       if (has_future) {
[10:24:31.643]                         ns <- base::getNamespace("future")
[10:24:31.643]                         version <- ns[[".package"]][["version"]]
[10:24:31.643]                         if (is.null(version)) 
[10:24:31.643]                           version <- utils::packageVersion("future")
[10:24:31.643]                       }
[10:24:31.643]                       else {
[10:24:31.643]                         version <- NULL
[10:24:31.643]                       }
[10:24:31.643]                       if (!has_future || version < "1.8.0") {
[10:24:31.643]                         info <- base::c(r_version = base::gsub("R version ", 
[10:24:31.643]                           "", base::R.version$version.string), 
[10:24:31.643]                           platform = base::sprintf("%s (%s-bit)", 
[10:24:31.643]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:31.643]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:31.643]                             "release", "version")], collapse = " "), 
[10:24:31.643]                           hostname = base::Sys.info()[["nodename"]])
[10:24:31.643]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:24:31.643]                           info)
[10:24:31.643]                         info <- base::paste(info, collapse = "; ")
[10:24:31.643]                         if (!has_future) {
[10:24:31.643]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:31.643]                             info)
[10:24:31.643]                         }
[10:24:31.643]                         else {
[10:24:31.643]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:31.643]                             info, version)
[10:24:31.643]                         }
[10:24:31.643]                         base::stop(msg)
[10:24:31.643]                       }
[10:24:31.643]                     })
[10:24:31.643]                   }
[10:24:31.643]                   options(future.plan = NULL)
[10:24:31.643]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:31.643]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:31.643]                 }
[10:24:31.643]                 ...future.workdir <- getwd()
[10:24:31.643]             }
[10:24:31.643]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:31.643]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:31.643]         }
[10:24:31.643]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:31.643]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:31.643]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:31.643]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:31.643]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:31.643]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:31.643]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:31.643]             base::names(...future.oldOptions))
[10:24:31.643]     }
[10:24:31.643]     if (FALSE) {
[10:24:31.643]     }
[10:24:31.643]     else {
[10:24:31.643]         if (TRUE) {
[10:24:31.643]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:31.643]                 open = "w")
[10:24:31.643]         }
[10:24:31.643]         else {
[10:24:31.643]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:31.643]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:31.643]         }
[10:24:31.643]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:31.643]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:31.643]             base::sink(type = "output", split = FALSE)
[10:24:31.643]             base::close(...future.stdout)
[10:24:31.643]         }, add = TRUE)
[10:24:31.643]     }
[10:24:31.643]     ...future.frame <- base::sys.nframe()
[10:24:31.643]     ...future.conditions <- base::list()
[10:24:31.643]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:31.643]     if (FALSE) {
[10:24:31.643]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:31.643]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:31.643]     }
[10:24:31.643]     ...future.result <- base::tryCatch({
[10:24:31.643]         base::withCallingHandlers({
[10:24:31.643]             ...future.value <- base::withVisible(base::local({
[10:24:31.643]                 do.call(function(...) {
[10:24:31.643]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:31.643]                   if (!identical(...future.globals.maxSize.org, 
[10:24:31.643]                     ...future.globals.maxSize)) {
[10:24:31.643]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:31.643]                     on.exit(options(oopts), add = TRUE)
[10:24:31.643]                   }
[10:24:31.643]                   {
[10:24:31.643]                     lapply(seq_along(...future.elements_ii), 
[10:24:31.643]                       FUN = function(jj) {
[10:24:31.643]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:31.643]                         ...future.FUN(...future.X_jj, ...)
[10:24:31.643]                       })
[10:24:31.643]                   }
[10:24:31.643]                 }, args = future.call.arguments)
[10:24:31.643]             }))
[10:24:31.643]             future::FutureResult(value = ...future.value$value, 
[10:24:31.643]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:31.643]                   ...future.rng), globalenv = if (FALSE) 
[10:24:31.643]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:31.643]                     ...future.globalenv.names))
[10:24:31.643]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:31.643]         }, condition = base::local({
[10:24:31.643]             c <- base::c
[10:24:31.643]             inherits <- base::inherits
[10:24:31.643]             invokeRestart <- base::invokeRestart
[10:24:31.643]             length <- base::length
[10:24:31.643]             list <- base::list
[10:24:31.643]             seq.int <- base::seq.int
[10:24:31.643]             signalCondition <- base::signalCondition
[10:24:31.643]             sys.calls <- base::sys.calls
[10:24:31.643]             `[[` <- base::`[[`
[10:24:31.643]             `+` <- base::`+`
[10:24:31.643]             `<<-` <- base::`<<-`
[10:24:31.643]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:31.643]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:31.643]                   3L)]
[10:24:31.643]             }
[10:24:31.643]             function(cond) {
[10:24:31.643]                 is_error <- inherits(cond, "error")
[10:24:31.643]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:31.643]                   NULL)
[10:24:31.643]                 if (is_error) {
[10:24:31.643]                   sessionInformation <- function() {
[10:24:31.643]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:31.643]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:31.643]                       search = base::search(), system = base::Sys.info())
[10:24:31.643]                   }
[10:24:31.643]                   ...future.conditions[[length(...future.conditions) + 
[10:24:31.643]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:31.643]                     cond$call), session = sessionInformation(), 
[10:24:31.643]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:31.643]                   signalCondition(cond)
[10:24:31.643]                 }
[10:24:31.643]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:31.643]                 "immediateCondition"))) {
[10:24:31.643]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:31.643]                   ...future.conditions[[length(...future.conditions) + 
[10:24:31.643]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:31.643]                   if (TRUE && !signal) {
[10:24:31.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:31.643]                     {
[10:24:31.643]                       inherits <- base::inherits
[10:24:31.643]                       invokeRestart <- base::invokeRestart
[10:24:31.643]                       is.null <- base::is.null
[10:24:31.643]                       muffled <- FALSE
[10:24:31.643]                       if (inherits(cond, "message")) {
[10:24:31.643]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:31.643]                         if (muffled) 
[10:24:31.643]                           invokeRestart("muffleMessage")
[10:24:31.643]                       }
[10:24:31.643]                       else if (inherits(cond, "warning")) {
[10:24:31.643]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:31.643]                         if (muffled) 
[10:24:31.643]                           invokeRestart("muffleWarning")
[10:24:31.643]                       }
[10:24:31.643]                       else if (inherits(cond, "condition")) {
[10:24:31.643]                         if (!is.null(pattern)) {
[10:24:31.643]                           computeRestarts <- base::computeRestarts
[10:24:31.643]                           grepl <- base::grepl
[10:24:31.643]                           restarts <- computeRestarts(cond)
[10:24:31.643]                           for (restart in restarts) {
[10:24:31.643]                             name <- restart$name
[10:24:31.643]                             if (is.null(name)) 
[10:24:31.643]                               next
[10:24:31.643]                             if (!grepl(pattern, name)) 
[10:24:31.643]                               next
[10:24:31.643]                             invokeRestart(restart)
[10:24:31.643]                             muffled <- TRUE
[10:24:31.643]                             break
[10:24:31.643]                           }
[10:24:31.643]                         }
[10:24:31.643]                       }
[10:24:31.643]                       invisible(muffled)
[10:24:31.643]                     }
[10:24:31.643]                     muffleCondition(cond, pattern = "^muffle")
[10:24:31.643]                   }
[10:24:31.643]                 }
[10:24:31.643]                 else {
[10:24:31.643]                   if (TRUE) {
[10:24:31.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:31.643]                     {
[10:24:31.643]                       inherits <- base::inherits
[10:24:31.643]                       invokeRestart <- base::invokeRestart
[10:24:31.643]                       is.null <- base::is.null
[10:24:31.643]                       muffled <- FALSE
[10:24:31.643]                       if (inherits(cond, "message")) {
[10:24:31.643]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:31.643]                         if (muffled) 
[10:24:31.643]                           invokeRestart("muffleMessage")
[10:24:31.643]                       }
[10:24:31.643]                       else if (inherits(cond, "warning")) {
[10:24:31.643]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:31.643]                         if (muffled) 
[10:24:31.643]                           invokeRestart("muffleWarning")
[10:24:31.643]                       }
[10:24:31.643]                       else if (inherits(cond, "condition")) {
[10:24:31.643]                         if (!is.null(pattern)) {
[10:24:31.643]                           computeRestarts <- base::computeRestarts
[10:24:31.643]                           grepl <- base::grepl
[10:24:31.643]                           restarts <- computeRestarts(cond)
[10:24:31.643]                           for (restart in restarts) {
[10:24:31.643]                             name <- restart$name
[10:24:31.643]                             if (is.null(name)) 
[10:24:31.643]                               next
[10:24:31.643]                             if (!grepl(pattern, name)) 
[10:24:31.643]                               next
[10:24:31.643]                             invokeRestart(restart)
[10:24:31.643]                             muffled <- TRUE
[10:24:31.643]                             break
[10:24:31.643]                           }
[10:24:31.643]                         }
[10:24:31.643]                       }
[10:24:31.643]                       invisible(muffled)
[10:24:31.643]                     }
[10:24:31.643]                     muffleCondition(cond, pattern = "^muffle")
[10:24:31.643]                   }
[10:24:31.643]                 }
[10:24:31.643]             }
[10:24:31.643]         }))
[10:24:31.643]     }, error = function(ex) {
[10:24:31.643]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:31.643]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:31.643]                 ...future.rng), started = ...future.startTime, 
[10:24:31.643]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:31.643]             version = "1.8"), class = "FutureResult")
[10:24:31.643]     }, finally = {
[10:24:31.643]         if (!identical(...future.workdir, getwd())) 
[10:24:31.643]             setwd(...future.workdir)
[10:24:31.643]         {
[10:24:31.643]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:31.643]                 ...future.oldOptions$nwarnings <- NULL
[10:24:31.643]             }
[10:24:31.643]             base::options(...future.oldOptions)
[10:24:31.643]             if (.Platform$OS.type == "windows") {
[10:24:31.643]                 old_names <- names(...future.oldEnvVars)
[10:24:31.643]                 envs <- base::Sys.getenv()
[10:24:31.643]                 names <- names(envs)
[10:24:31.643]                 common <- intersect(names, old_names)
[10:24:31.643]                 added <- setdiff(names, old_names)
[10:24:31.643]                 removed <- setdiff(old_names, names)
[10:24:31.643]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:31.643]                   envs[common]]
[10:24:31.643]                 NAMES <- toupper(changed)
[10:24:31.643]                 args <- list()
[10:24:31.643]                 for (kk in seq_along(NAMES)) {
[10:24:31.643]                   name <- changed[[kk]]
[10:24:31.643]                   NAME <- NAMES[[kk]]
[10:24:31.643]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:31.643]                     next
[10:24:31.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:31.643]                 }
[10:24:31.643]                 NAMES <- toupper(added)
[10:24:31.643]                 for (kk in seq_along(NAMES)) {
[10:24:31.643]                   name <- added[[kk]]
[10:24:31.643]                   NAME <- NAMES[[kk]]
[10:24:31.643]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:31.643]                     next
[10:24:31.643]                   args[[name]] <- ""
[10:24:31.643]                 }
[10:24:31.643]                 NAMES <- toupper(removed)
[10:24:31.643]                 for (kk in seq_along(NAMES)) {
[10:24:31.643]                   name <- removed[[kk]]
[10:24:31.643]                   NAME <- NAMES[[kk]]
[10:24:31.643]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:31.643]                     next
[10:24:31.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:31.643]                 }
[10:24:31.643]                 if (length(args) > 0) 
[10:24:31.643]                   base::do.call(base::Sys.setenv, args = args)
[10:24:31.643]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:31.643]             }
[10:24:31.643]             else {
[10:24:31.643]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:31.643]             }
[10:24:31.643]             {
[10:24:31.643]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:31.643]                   0L) {
[10:24:31.643]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:31.643]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:31.643]                   base::options(opts)
[10:24:31.643]                 }
[10:24:31.643]                 {
[10:24:31.643]                   {
[10:24:31.643]                     NULL
[10:24:31.643]                     RNGkind("Mersenne-Twister")
[10:24:31.643]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:31.643]                       inherits = FALSE)
[10:24:31.643]                   }
[10:24:31.643]                   options(future.plan = NULL)
[10:24:31.643]                   if (is.na(NA_character_)) 
[10:24:31.643]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:31.643]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:31.643]                   future::plan(list(function (..., envir = parent.frame()) 
[10:24:31.643]                   {
[10:24:31.643]                     future <- SequentialFuture(..., envir = envir)
[10:24:31.643]                     if (!future$lazy) 
[10:24:31.643]                       future <- run(future)
[10:24:31.643]                     invisible(future)
[10:24:31.643]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:31.643]                 }
[10:24:31.643]             }
[10:24:31.643]         }
[10:24:31.643]     })
[10:24:31.643]     if (TRUE) {
[10:24:31.643]         base::sink(type = "output", split = FALSE)
[10:24:31.643]         if (TRUE) {
[10:24:31.643]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:31.643]         }
[10:24:31.643]         else {
[10:24:31.643]             ...future.result["stdout"] <- base::list(NULL)
[10:24:31.643]         }
[10:24:31.643]         base::close(...future.stdout)
[10:24:31.643]         ...future.stdout <- NULL
[10:24:31.643]     }
[10:24:31.643]     ...future.result$conditions <- ...future.conditions
[10:24:31.643]     ...future.result$finished <- base::Sys.time()
[10:24:31.643]     ...future.result
[10:24:31.643] }
[10:24:31.645] assign_globals() ...
[10:24:31.645] List of 5
[10:24:31.645]  $ ...future.FUN            :function (x)  
[10:24:31.645]  $ future.call.arguments    : list()
[10:24:31.645]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:31.645]  $ ...future.elements_ii    :List of 2
[10:24:31.645]   ..$ : int 1
[10:24:31.645]   ..$ : int 0
[10:24:31.645]  $ ...future.seeds_ii       : NULL
[10:24:31.645]  $ ...future.globals.maxSize: NULL
[10:24:31.645]  - attr(*, "where")=List of 5
[10:24:31.645]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:31.645]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:31.645]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:31.645]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:31.645]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:31.645]  - attr(*, "resolved")= logi FALSE
[10:24:31.645]  - attr(*, "total_size")= num 4720
[10:24:31.645]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:31.645]  - attr(*, "already-done")= logi TRUE
[10:24:31.651] - reassign environment for ‘...future.FUN’
[10:24:31.652] - copied ‘...future.FUN’ to environment
[10:24:31.652] - copied ‘future.call.arguments’ to environment
[10:24:31.652] - copied ‘...future.elements_ii’ to environment
[10:24:31.652] - copied ‘...future.seeds_ii’ to environment
[10:24:31.652] - copied ‘...future.globals.maxSize’ to environment
[10:24:31.652] assign_globals() ... done
[10:24:31.652] plan(): Setting new future strategy stack:
[10:24:31.652] List of future strategies:
[10:24:31.652] 1. sequential:
[10:24:31.652]    - args: function (..., envir = parent.frame())
[10:24:31.652]    - tweaked: FALSE
[10:24:31.652]    - call: NULL
[10:24:31.653] plan(): nbrOfWorkers() = 1
[10:24:32.154] plan(): Setting new future strategy stack:
[10:24:32.155] List of future strategies:
[10:24:32.155] 1. sequential:
[10:24:32.155]    - args: function (..., envir = parent.frame())
[10:24:32.155]    - tweaked: FALSE
[10:24:32.155]    - call: plan(strategy)
[10:24:32.155] plan(): nbrOfWorkers() = 1
[10:24:32.155] SequentialFuture started (and completed)
[10:24:32.155] - Launch lazy future ... done
[10:24:32.156] run() for ‘SequentialFuture’ ... done
[10:24:32.156] Created future:
[10:24:32.156] SequentialFuture:
[10:24:32.156] Label: ‘future_lapply-1’
[10:24:32.156] Expression:
[10:24:32.156] {
[10:24:32.156]     do.call(function(...) {
[10:24:32.156]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:32.156]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:32.156]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:32.156]             on.exit(options(oopts), add = TRUE)
[10:24:32.156]         }
[10:24:32.156]         {
[10:24:32.156]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:32.156]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:32.156]                 ...future.FUN(...future.X_jj, ...)
[10:24:32.156]             })
[10:24:32.156]         }
[10:24:32.156]     }, args = future.call.arguments)
[10:24:32.156] }
[10:24:32.156] Lazy evaluation: FALSE
[10:24:32.156] Asynchronous evaluation: FALSE
[10:24:32.156] Local evaluation: TRUE
[10:24:32.156] Environment: R_GlobalEnv
[10:24:32.156] Capture standard output: TRUE
[10:24:32.156] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:32.156] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:32.156] Packages: <none>
[10:24:32.156] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:32.156] Resolved: TRUE
[10:24:32.156] Value: 112 bytes of class ‘list’
[10:24:32.156] Early signaling: FALSE
[10:24:32.156] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:32.156] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:32.157] Chunk #1 of 1 ... DONE
[10:24:32.157] Launching 1 futures (chunks) ... DONE
[10:24:32.157] Resolving 1 futures (chunks) ...
[10:24:32.157] resolve() on list ...
[10:24:32.158]  recursive: 0
[10:24:32.158]  length: 1
[10:24:32.158] 
[10:24:32.158] resolved() for ‘SequentialFuture’ ...
[10:24:32.158] - state: ‘finished’
[10:24:32.158] - run: TRUE
[10:24:32.158] - result: ‘FutureResult’
[10:24:32.158] resolved() for ‘SequentialFuture’ ... done
[10:24:32.158] Future #1
[10:24:32.158] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:32.159] - nx: 1
[10:24:32.159] - relay: TRUE
[10:24:32.159] - stdout: TRUE
[10:24:32.159] - signal: TRUE
[10:24:32.159] - resignal: FALSE
[10:24:32.159] - force: TRUE
[10:24:32.159] - relayed: [n=1] FALSE
[10:24:32.159] - queued futures: [n=1] FALSE
[10:24:32.159]  - until=1
[10:24:32.159]  - relaying element #1
[10:24:32.160] - relayed: [n=1] TRUE
[10:24:32.160] - queued futures: [n=1] TRUE
[10:24:32.160] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:32.160]  length: 0 (resolved future 1)
[10:24:32.160] Relaying remaining futures
[10:24:32.160] signalConditionsASAP(NULL, pos=0) ...
[10:24:32.160] - nx: 1
[10:24:32.160] - relay: TRUE
[10:24:32.160] - stdout: TRUE
[10:24:32.160] - signal: TRUE
[10:24:32.160] - resignal: FALSE
[10:24:32.161] - force: TRUE
[10:24:32.161] - relayed: [n=1] TRUE
[10:24:32.161] - queued futures: [n=1] TRUE
 - flush all
[10:24:32.161] - relayed: [n=1] TRUE
[10:24:32.161] - queued futures: [n=1] TRUE
[10:24:32.161] signalConditionsASAP(NULL, pos=0) ... done
[10:24:32.161] resolve() on list ... DONE
[10:24:32.161]  - Number of value chunks collected: 1
[10:24:32.161] Resolving 1 futures (chunks) ... DONE
[10:24:32.161] Reducing values from 1 chunks ...
[10:24:32.162]  - Number of values collected after concatenation: 2
[10:24:32.162]  - Number of values expected: 2
[10:24:32.162] Reducing values from 1 chunks ... DONE
[10:24:32.162] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[10:24:32.162] future_lapply() ...
[10:24:32.163] Number of chunks: 1
[10:24:32.163] getGlobalsAndPackagesXApply() ...
[10:24:32.163]  - future.globals: TRUE
[10:24:32.163] getGlobalsAndPackages() ...
[10:24:32.163] Searching for globals...
[10:24:32.165] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:24:32.165] Searching for globals ... DONE
[10:24:32.165] Resolving globals: FALSE
[10:24:32.165] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[10:24:32.166] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[10:24:32.166] - globals: [1] ‘FUN’
[10:24:32.166] 
[10:24:32.166] getGlobalsAndPackages() ... DONE
[10:24:32.166]  - globals found/used: [n=1] ‘FUN’
[10:24:32.166]  - needed namespaces: [n=0] 
[10:24:32.166] Finding globals ... DONE
[10:24:32.166]  - use_args: TRUE
[10:24:32.166]  - Getting '...' globals ...
[10:24:32.167] resolve() on list ...
[10:24:32.167]  recursive: 0
[10:24:32.167]  length: 1
[10:24:32.167]  elements: ‘...’
[10:24:32.167]  length: 0 (resolved future 1)
[10:24:32.167] resolve() on list ... DONE
[10:24:32.167]    - '...' content: [n=0] 
[10:24:32.167] List of 1
[10:24:32.167]  $ ...: list()
[10:24:32.167]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:32.167]  - attr(*, "where")=List of 1
[10:24:32.167]   ..$ ...:<environment: 0x55d210c99cb0> 
[10:24:32.167]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:32.167]  - attr(*, "resolved")= logi TRUE
[10:24:32.167]  - attr(*, "total_size")= num NA
[10:24:32.170]  - Getting '...' globals ... DONE
[10:24:32.170] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:24:32.170] List of 2
[10:24:32.170]  $ ...future.FUN:function (x)  
[10:24:32.170]  $ ...          : list()
[10:24:32.170]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:32.170]  - attr(*, "where")=List of 2
[10:24:32.170]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:32.170]   ..$ ...          :<environment: 0x55d210c99cb0> 
[10:24:32.170]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:32.170]  - attr(*, "resolved")= logi FALSE
[10:24:32.170]  - attr(*, "total_size")= num 4720
[10:24:32.173] Packages to be attached in all futures: [n=0] 
[10:24:32.173] getGlobalsAndPackagesXApply() ... DONE
[10:24:32.173] Number of futures (= number of chunks): 1
[10:24:32.173] Launching 1 futures (chunks) ...
[10:24:32.173] Chunk #1 of 1 ...
[10:24:32.173]  - Finding globals in 'X' for chunk #1 ...
[10:24:32.174] getGlobalsAndPackages() ...
[10:24:32.174] Searching for globals...
[10:24:32.174] 
[10:24:32.175] Searching for globals ... DONE
[10:24:32.176] - globals: [0] <none>
[10:24:32.176] getGlobalsAndPackages() ... DONE
[10:24:32.176]    + additional globals found: [n=0] 
[10:24:32.176]    + additional namespaces needed: [n=0] 
[10:24:32.176]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:32.176]  - seeds: <none>
[10:24:32.176]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:32.176] getGlobalsAndPackages() ...
[10:24:32.176] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:32.176] Resolving globals: FALSE
[10:24:32.177] Tweak future expression to call with '...' arguments ...
[10:24:32.177] {
[10:24:32.177]     do.call(function(...) {
[10:24:32.177]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:32.177]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:32.177]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:32.177]             on.exit(options(oopts), add = TRUE)
[10:24:32.177]         }
[10:24:32.177]         {
[10:24:32.177]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:32.177]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:32.177]                 ...future.FUN(...future.X_jj, ...)
[10:24:32.177]             })
[10:24:32.177]         }
[10:24:32.177]     }, args = future.call.arguments)
[10:24:32.177] }
[10:24:32.177] Tweak future expression to call with '...' arguments ... DONE
[10:24:32.177] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:32.177] 
[10:24:32.178] getGlobalsAndPackages() ... DONE
[10:24:32.178] run() for ‘Future’ ...
[10:24:32.178] - state: ‘created’
[10:24:32.178] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:24:32.178] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:32.178] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:32.179]   - Field: ‘label’
[10:24:32.179]   - Field: ‘local’
[10:24:32.179]   - Field: ‘owner’
[10:24:32.179]   - Field: ‘envir’
[10:24:32.179]   - Field: ‘packages’
[10:24:32.179]   - Field: ‘gc’
[10:24:32.179]   - Field: ‘conditions’
[10:24:32.179]   - Field: ‘expr’
[10:24:32.179]   - Field: ‘uuid’
[10:24:32.179]   - Field: ‘seed’
[10:24:32.179]   - Field: ‘version’
[10:24:32.180]   - Field: ‘result’
[10:24:32.180]   - Field: ‘asynchronous’
[10:24:32.180]   - Field: ‘calls’
[10:24:32.180]   - Field: ‘globals’
[10:24:32.180]   - Field: ‘stdout’
[10:24:32.180]   - Field: ‘earlySignal’
[10:24:32.180]   - Field: ‘lazy’
[10:24:32.180]   - Field: ‘state’
[10:24:32.180] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:32.180] - Launch lazy future ...
[10:24:32.181] Packages needed by the future expression (n = 0): <none>
[10:24:32.181] Packages needed by future strategies (n = 0): <none>
[10:24:32.181] {
[10:24:32.181]     {
[10:24:32.181]         {
[10:24:32.181]             ...future.startTime <- base::Sys.time()
[10:24:32.181]             {
[10:24:32.181]                 {
[10:24:32.181]                   {
[10:24:32.181]                     base::local({
[10:24:32.181]                       has_future <- base::requireNamespace("future", 
[10:24:32.181]                         quietly = TRUE)
[10:24:32.181]                       if (has_future) {
[10:24:32.181]                         ns <- base::getNamespace("future")
[10:24:32.181]                         version <- ns[[".package"]][["version"]]
[10:24:32.181]                         if (is.null(version)) 
[10:24:32.181]                           version <- utils::packageVersion("future")
[10:24:32.181]                       }
[10:24:32.181]                       else {
[10:24:32.181]                         version <- NULL
[10:24:32.181]                       }
[10:24:32.181]                       if (!has_future || version < "1.8.0") {
[10:24:32.181]                         info <- base::c(r_version = base::gsub("R version ", 
[10:24:32.181]                           "", base::R.version$version.string), 
[10:24:32.181]                           platform = base::sprintf("%s (%s-bit)", 
[10:24:32.181]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:32.181]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:32.181]                             "release", "version")], collapse = " "), 
[10:24:32.181]                           hostname = base::Sys.info()[["nodename"]])
[10:24:32.181]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:24:32.181]                           info)
[10:24:32.181]                         info <- base::paste(info, collapse = "; ")
[10:24:32.181]                         if (!has_future) {
[10:24:32.181]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:32.181]                             info)
[10:24:32.181]                         }
[10:24:32.181]                         else {
[10:24:32.181]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:32.181]                             info, version)
[10:24:32.181]                         }
[10:24:32.181]                         base::stop(msg)
[10:24:32.181]                       }
[10:24:32.181]                     })
[10:24:32.181]                   }
[10:24:32.181]                   options(future.plan = NULL)
[10:24:32.181]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:32.181]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:32.181]                 }
[10:24:32.181]                 ...future.workdir <- getwd()
[10:24:32.181]             }
[10:24:32.181]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:32.181]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:32.181]         }
[10:24:32.181]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:32.181]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:32.181]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:32.181]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:32.181]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:32.181]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:32.181]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:32.181]             base::names(...future.oldOptions))
[10:24:32.181]     }
[10:24:32.181]     if (TRUE) {
[10:24:32.181]     }
[10:24:32.181]     else {
[10:24:32.181]         if (NA) {
[10:24:32.181]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:32.181]                 open = "w")
[10:24:32.181]         }
[10:24:32.181]         else {
[10:24:32.181]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:32.181]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:32.181]         }
[10:24:32.181]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:32.181]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:32.181]             base::sink(type = "output", split = FALSE)
[10:24:32.181]             base::close(...future.stdout)
[10:24:32.181]         }, add = TRUE)
[10:24:32.181]     }
[10:24:32.181]     ...future.frame <- base::sys.nframe()
[10:24:32.181]     ...future.conditions <- base::list()
[10:24:32.181]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:32.181]     if (FALSE) {
[10:24:32.181]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:32.181]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:32.181]     }
[10:24:32.181]     ...future.result <- base::tryCatch({
[10:24:32.181]         base::withCallingHandlers({
[10:24:32.181]             ...future.value <- base::withVisible(base::local({
[10:24:32.181]                 do.call(function(...) {
[10:24:32.181]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:32.181]                   if (!identical(...future.globals.maxSize.org, 
[10:24:32.181]                     ...future.globals.maxSize)) {
[10:24:32.181]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:32.181]                     on.exit(options(oopts), add = TRUE)
[10:24:32.181]                   }
[10:24:32.181]                   {
[10:24:32.181]                     lapply(seq_along(...future.elements_ii), 
[10:24:32.181]                       FUN = function(jj) {
[10:24:32.181]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:32.181]                         ...future.FUN(...future.X_jj, ...)
[10:24:32.181]                       })
[10:24:32.181]                   }
[10:24:32.181]                 }, args = future.call.arguments)
[10:24:32.181]             }))
[10:24:32.181]             future::FutureResult(value = ...future.value$value, 
[10:24:32.181]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:32.181]                   ...future.rng), globalenv = if (FALSE) 
[10:24:32.181]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:32.181]                     ...future.globalenv.names))
[10:24:32.181]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:32.181]         }, condition = base::local({
[10:24:32.181]             c <- base::c
[10:24:32.181]             inherits <- base::inherits
[10:24:32.181]             invokeRestart <- base::invokeRestart
[10:24:32.181]             length <- base::length
[10:24:32.181]             list <- base::list
[10:24:32.181]             seq.int <- base::seq.int
[10:24:32.181]             signalCondition <- base::signalCondition
[10:24:32.181]             sys.calls <- base::sys.calls
[10:24:32.181]             `[[` <- base::`[[`
[10:24:32.181]             `+` <- base::`+`
[10:24:32.181]             `<<-` <- base::`<<-`
[10:24:32.181]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:32.181]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:32.181]                   3L)]
[10:24:32.181]             }
[10:24:32.181]             function(cond) {
[10:24:32.181]                 is_error <- inherits(cond, "error")
[10:24:32.181]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:32.181]                   NULL)
[10:24:32.181]                 if (is_error) {
[10:24:32.181]                   sessionInformation <- function() {
[10:24:32.181]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:32.181]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:32.181]                       search = base::search(), system = base::Sys.info())
[10:24:32.181]                   }
[10:24:32.181]                   ...future.conditions[[length(...future.conditions) + 
[10:24:32.181]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:32.181]                     cond$call), session = sessionInformation(), 
[10:24:32.181]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:32.181]                   signalCondition(cond)
[10:24:32.181]                 }
[10:24:32.181]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:32.181]                 "immediateCondition"))) {
[10:24:32.181]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:32.181]                   ...future.conditions[[length(...future.conditions) + 
[10:24:32.181]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:32.181]                   if (TRUE && !signal) {
[10:24:32.181]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:32.181]                     {
[10:24:32.181]                       inherits <- base::inherits
[10:24:32.181]                       invokeRestart <- base::invokeRestart
[10:24:32.181]                       is.null <- base::is.null
[10:24:32.181]                       muffled <- FALSE
[10:24:32.181]                       if (inherits(cond, "message")) {
[10:24:32.181]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:32.181]                         if (muffled) 
[10:24:32.181]                           invokeRestart("muffleMessage")
[10:24:32.181]                       }
[10:24:32.181]                       else if (inherits(cond, "warning")) {
[10:24:32.181]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:32.181]                         if (muffled) 
[10:24:32.181]                           invokeRestart("muffleWarning")
[10:24:32.181]                       }
[10:24:32.181]                       else if (inherits(cond, "condition")) {
[10:24:32.181]                         if (!is.null(pattern)) {
[10:24:32.181]                           computeRestarts <- base::computeRestarts
[10:24:32.181]                           grepl <- base::grepl
[10:24:32.181]                           restarts <- computeRestarts(cond)
[10:24:32.181]                           for (restart in restarts) {
[10:24:32.181]                             name <- restart$name
[10:24:32.181]                             if (is.null(name)) 
[10:24:32.181]                               next
[10:24:32.181]                             if (!grepl(pattern, name)) 
[10:24:32.181]                               next
[10:24:32.181]                             invokeRestart(restart)
[10:24:32.181]                             muffled <- TRUE
[10:24:32.181]                             break
[10:24:32.181]                           }
[10:24:32.181]                         }
[10:24:32.181]                       }
[10:24:32.181]                       invisible(muffled)
[10:24:32.181]                     }
[10:24:32.181]                     muffleCondition(cond, pattern = "^muffle")
[10:24:32.181]                   }
[10:24:32.181]                 }
[10:24:32.181]                 else {
[10:24:32.181]                   if (TRUE) {
[10:24:32.181]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:32.181]                     {
[10:24:32.181]                       inherits <- base::inherits
[10:24:32.181]                       invokeRestart <- base::invokeRestart
[10:24:32.181]                       is.null <- base::is.null
[10:24:32.181]                       muffled <- FALSE
[10:24:32.181]                       if (inherits(cond, "message")) {
[10:24:32.181]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:32.181]                         if (muffled) 
[10:24:32.181]                           invokeRestart("muffleMessage")
[10:24:32.181]                       }
[10:24:32.181]                       else if (inherits(cond, "warning")) {
[10:24:32.181]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:32.181]                         if (muffled) 
[10:24:32.181]                           invokeRestart("muffleWarning")
[10:24:32.181]                       }
[10:24:32.181]                       else if (inherits(cond, "condition")) {
[10:24:32.181]                         if (!is.null(pattern)) {
[10:24:32.181]                           computeRestarts <- base::computeRestarts
[10:24:32.181]                           grepl <- base::grepl
[10:24:32.181]                           restarts <- computeRestarts(cond)
[10:24:32.181]                           for (restart in restarts) {
[10:24:32.181]                             name <- restart$name
[10:24:32.181]                             if (is.null(name)) 
[10:24:32.181]                               next
[10:24:32.181]                             if (!grepl(pattern, name)) 
[10:24:32.181]                               next
[10:24:32.181]                             invokeRestart(restart)
[10:24:32.181]                             muffled <- TRUE
[10:24:32.181]                             break
[10:24:32.181]                           }
[10:24:32.181]                         }
[10:24:32.181]                       }
[10:24:32.181]                       invisible(muffled)
[10:24:32.181]                     }
[10:24:32.181]                     muffleCondition(cond, pattern = "^muffle")
[10:24:32.181]                   }
[10:24:32.181]                 }
[10:24:32.181]             }
[10:24:32.181]         }))
[10:24:32.181]     }, error = function(ex) {
[10:24:32.181]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:32.181]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:32.181]                 ...future.rng), started = ...future.startTime, 
[10:24:32.181]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:32.181]             version = "1.8"), class = "FutureResult")
[10:24:32.181]     }, finally = {
[10:24:32.181]         if (!identical(...future.workdir, getwd())) 
[10:24:32.181]             setwd(...future.workdir)
[10:24:32.181]         {
[10:24:32.181]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:32.181]                 ...future.oldOptions$nwarnings <- NULL
[10:24:32.181]             }
[10:24:32.181]             base::options(...future.oldOptions)
[10:24:32.181]             if (.Platform$OS.type == "windows") {
[10:24:32.181]                 old_names <- names(...future.oldEnvVars)
[10:24:32.181]                 envs <- base::Sys.getenv()
[10:24:32.181]                 names <- names(envs)
[10:24:32.181]                 common <- intersect(names, old_names)
[10:24:32.181]                 added <- setdiff(names, old_names)
[10:24:32.181]                 removed <- setdiff(old_names, names)
[10:24:32.181]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:32.181]                   envs[common]]
[10:24:32.181]                 NAMES <- toupper(changed)
[10:24:32.181]                 args <- list()
[10:24:32.181]                 for (kk in seq_along(NAMES)) {
[10:24:32.181]                   name <- changed[[kk]]
[10:24:32.181]                   NAME <- NAMES[[kk]]
[10:24:32.181]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:32.181]                     next
[10:24:32.181]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:32.181]                 }
[10:24:32.181]                 NAMES <- toupper(added)
[10:24:32.181]                 for (kk in seq_along(NAMES)) {
[10:24:32.181]                   name <- added[[kk]]
[10:24:32.181]                   NAME <- NAMES[[kk]]
[10:24:32.181]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:32.181]                     next
[10:24:32.181]                   args[[name]] <- ""
[10:24:32.181]                 }
[10:24:32.181]                 NAMES <- toupper(removed)
[10:24:32.181]                 for (kk in seq_along(NAMES)) {
[10:24:32.181]                   name <- removed[[kk]]
[10:24:32.181]                   NAME <- NAMES[[kk]]
[10:24:32.181]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:32.181]                     next
[10:24:32.181]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:32.181]                 }
[10:24:32.181]                 if (length(args) > 0) 
[10:24:32.181]                   base::do.call(base::Sys.setenv, args = args)
[10:24:32.181]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:32.181]             }
[10:24:32.181]             else {
[10:24:32.181]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:32.181]             }
[10:24:32.181]             {
[10:24:32.181]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:32.181]                   0L) {
[10:24:32.181]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:32.181]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:32.181]                   base::options(opts)
[10:24:32.181]                 }
[10:24:32.181]                 {
[10:24:32.181]                   {
[10:24:32.181]                     NULL
[10:24:32.181]                     RNGkind("Mersenne-Twister")
[10:24:32.181]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:32.181]                       inherits = FALSE)
[10:24:32.181]                   }
[10:24:32.181]                   options(future.plan = NULL)
[10:24:32.181]                   if (is.na(NA_character_)) 
[10:24:32.181]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:32.181]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:32.181]                   future::plan(list(function (..., envir = parent.frame()) 
[10:24:32.181]                   {
[10:24:32.181]                     future <- SequentialFuture(..., envir = envir)
[10:24:32.181]                     if (!future$lazy) 
[10:24:32.181]                       future <- run(future)
[10:24:32.181]                     invisible(future)
[10:24:32.181]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:32.181]                 }
[10:24:32.181]             }
[10:24:32.181]         }
[10:24:32.181]     })
[10:24:32.181]     if (FALSE) {
[10:24:32.181]         base::sink(type = "output", split = FALSE)
[10:24:32.181]         if (NA) {
[10:24:32.181]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:32.181]         }
[10:24:32.181]         else {
[10:24:32.181]             ...future.result["stdout"] <- base::list(NULL)
[10:24:32.181]         }
[10:24:32.181]         base::close(...future.stdout)
[10:24:32.181]         ...future.stdout <- NULL
[10:24:32.181]     }
[10:24:32.181]     ...future.result$conditions <- ...future.conditions
[10:24:32.181]     ...future.result$finished <- base::Sys.time()
[10:24:32.181]     ...future.result
[10:24:32.181] }
[10:24:32.183] assign_globals() ...
[10:24:32.183] List of 5
[10:24:32.183]  $ ...future.FUN            :function (x)  
[10:24:32.183]  $ future.call.arguments    : list()
[10:24:32.183]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:32.183]  $ ...future.elements_ii    :List of 2
[10:24:32.183]   ..$ : int 1
[10:24:32.183]   ..$ : int 0
[10:24:32.183]  $ ...future.seeds_ii       : NULL
[10:24:32.183]  $ ...future.globals.maxSize: NULL
[10:24:32.183]  - attr(*, "where")=List of 5
[10:24:32.183]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:32.183]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:32.183]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:32.183]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:32.183]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:32.183]  - attr(*, "resolved")= logi FALSE
[10:24:32.183]  - attr(*, "total_size")= num 4720
[10:24:32.183]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:32.183]  - attr(*, "already-done")= logi TRUE
[10:24:32.188] - reassign environment for ‘...future.FUN’
[10:24:32.188] - copied ‘...future.FUN’ to environment
[10:24:32.188] - copied ‘future.call.arguments’ to environment
[10:24:32.188] - copied ‘...future.elements_ii’ to environment
[10:24:32.188] - copied ‘...future.seeds_ii’ to environment
[10:24:32.188] - copied ‘...future.globals.maxSize’ to environment
[10:24:32.188] assign_globals() ... done
[10:24:32.188] plan(): Setting new future strategy stack:
[10:24:32.189] List of future strategies:
[10:24:32.189] 1. sequential:
[10:24:32.189]    - args: function (..., envir = parent.frame())
[10:24:32.189]    - tweaked: FALSE
[10:24:32.189]    - call: NULL
[10:24:32.189] plan(): nbrOfWorkers() = 1
[10:24:32.690] plan(): Setting new future strategy stack:
[10:24:32.691] List of future strategies:
[10:24:32.691] 1. sequential:
[10:24:32.691]    - args: function (..., envir = parent.frame())
[10:24:32.691]    - tweaked: FALSE
[10:24:32.691]    - call: plan(strategy)
[10:24:32.691] plan(): nbrOfWorkers() = 1
[10:24:32.691] SequentialFuture started (and completed)
[10:24:32.691] - Launch lazy future ... done
[10:24:32.692] run() for ‘SequentialFuture’ ... done
[10:24:32.692] Created future:
[10:24:32.692] SequentialFuture:
[10:24:32.692] Label: ‘future_lapply-1’
[10:24:32.692] Expression:
[10:24:32.692] {
[10:24:32.692]     do.call(function(...) {
[10:24:32.692]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:32.692]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:32.692]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:32.692]             on.exit(options(oopts), add = TRUE)
[10:24:32.692]         }
[10:24:32.692]         {
[10:24:32.692]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:32.692]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:32.692]                 ...future.FUN(...future.X_jj, ...)
[10:24:32.692]             })
[10:24:32.692]         }
[10:24:32.692]     }, args = future.call.arguments)
[10:24:32.692] }
[10:24:32.692] Lazy evaluation: FALSE
[10:24:32.692] Asynchronous evaluation: FALSE
[10:24:32.692] Local evaluation: TRUE
[10:24:32.692] Environment: R_GlobalEnv
[10:24:32.692] Capture standard output: NA
[10:24:32.692] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:32.692] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:32.692] Packages: <none>
[10:24:32.692] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:32.692] Resolved: TRUE
[10:24:32.692] Value: 112 bytes of class ‘list’
[10:24:32.692] Early signaling: FALSE
[10:24:32.692] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:32.692] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:32.693] Chunk #1 of 1 ... DONE
[10:24:32.693] Launching 1 futures (chunks) ... DONE
[10:24:32.693] Resolving 1 futures (chunks) ...
[10:24:32.693] resolve() on list ...
[10:24:32.693]  recursive: 0
[10:24:32.693]  length: 1
[10:24:32.694] 
[10:24:32.694] resolved() for ‘SequentialFuture’ ...
[10:24:32.694] - state: ‘finished’
[10:24:32.694] - run: TRUE
[10:24:32.694] - result: ‘FutureResult’
[10:24:32.694] resolved() for ‘SequentialFuture’ ... done
[10:24:32.694] Future #1
[10:24:32.694] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:32.694] - nx: 1
[10:24:32.694] - relay: TRUE
[10:24:32.695] - stdout: TRUE
[10:24:32.695] - signal: TRUE
[10:24:32.695] - resignal: FALSE
[10:24:32.695] - force: TRUE
[10:24:32.695] - relayed: [n=1] FALSE
[10:24:32.695] - queued futures: [n=1] FALSE
[10:24:32.695]  - until=1
[10:24:32.695]  - relaying element #1
[10:24:32.695] - relayed: [n=1] TRUE
[10:24:32.695] - queued futures: [n=1] TRUE
[10:24:32.696] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:32.696]  length: 0 (resolved future 1)
[10:24:32.696] Relaying remaining futures
[10:24:32.696] signalConditionsASAP(NULL, pos=0) ...
[10:24:32.696] - nx: 1
[10:24:32.696] - relay: TRUE
[10:24:32.696] - stdout: TRUE
[10:24:32.696] - signal: TRUE
[10:24:32.696] - resignal: FALSE
[10:24:32.696] - force: TRUE
[10:24:32.696] - relayed: [n=1] TRUE
[10:24:32.696] - queued futures: [n=1] TRUE
 - flush all
[10:24:32.697] - relayed: [n=1] TRUE
[10:24:32.697] - queued futures: [n=1] TRUE
[10:24:32.697] signalConditionsASAP(NULL, pos=0) ... done
[10:24:32.697] resolve() on list ... DONE
[10:24:32.697]  - Number of value chunks collected: 1
[10:24:32.697] Resolving 1 futures (chunks) ... DONE
[10:24:32.697] Reducing values from 1 chunks ...
[10:24:32.697]  - Number of values collected after concatenation: 2
[10:24:32.697]  - Number of values expected: 2
[10:24:32.697] Reducing values from 1 chunks ... DONE
[10:24:32.698] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[10:24:32.698] future_mapply() ...
[10:24:32.698] Number of chunks: 1
[10:24:32.698] getGlobalsAndPackagesXApply() ...
[10:24:32.698]  - future.globals: TRUE
[10:24:32.698] getGlobalsAndPackages() ...
[10:24:32.698] Searching for globals...
[10:24:32.700] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:24:32.700] Searching for globals ... DONE
[10:24:32.700] Resolving globals: FALSE
[10:24:32.701] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[10:24:32.701] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[10:24:32.703] - globals: [1] ‘FUN’
[10:24:32.703] 
[10:24:32.703] getGlobalsAndPackages() ... DONE
[10:24:32.703]  - globals found/used: [n=1] ‘FUN’
[10:24:32.703]  - needed namespaces: [n=0] 
[10:24:32.703] Finding globals ... DONE
[10:24:32.703] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:24:32.704] List of 2
[10:24:32.704]  $ ...future.FUN:function (x, y)  
[10:24:32.704]  $ MoreArgs     : NULL
[10:24:32.704]  - attr(*, "where")=List of 2
[10:24:32.704]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:32.704]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:24:32.704]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:32.704]  - attr(*, "resolved")= logi FALSE
[10:24:32.704]  - attr(*, "total_size")= num NA
[10:24:32.706] Packages to be attached in all futures: [n=0] 
[10:24:32.706] getGlobalsAndPackagesXApply() ... DONE
[10:24:32.706] Number of futures (= number of chunks): 1
[10:24:32.707] Launching 1 futures (chunks) ...
[10:24:32.707] Chunk #1 of 1 ...
[10:24:32.707]  - Finding globals in '...' for chunk #1 ...
[10:24:32.707] getGlobalsAndPackages() ...
[10:24:32.707] Searching for globals...
[10:24:32.707] 
[10:24:32.707] Searching for globals ... DONE
[10:24:32.707] - globals: [0] <none>
[10:24:32.708] getGlobalsAndPackages() ... DONE
[10:24:32.708]    + additional globals found: [n=0] 
[10:24:32.708]    + additional namespaces needed: [n=0] 
[10:24:32.708]  - Finding globals in '...' for chunk #1 ... DONE
[10:24:32.708]  - seeds: <none>
[10:24:32.708]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:32.708] getGlobalsAndPackages() ...
[10:24:32.708] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:32.708] Resolving globals: FALSE
[10:24:32.709] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[10:24:32.709] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:24:32.709] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:32.710] 
[10:24:32.710] getGlobalsAndPackages() ... DONE
[10:24:32.710] run() for ‘Future’ ...
[10:24:32.710] - state: ‘created’
[10:24:32.710] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:24:32.710] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:32.710] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:32.711]   - Field: ‘label’
[10:24:32.711]   - Field: ‘local’
[10:24:32.711]   - Field: ‘owner’
[10:24:32.711]   - Field: ‘envir’
[10:24:32.711]   - Field: ‘packages’
[10:24:32.711]   - Field: ‘gc’
[10:24:32.711]   - Field: ‘conditions’
[10:24:32.711]   - Field: ‘expr’
[10:24:32.711]   - Field: ‘uuid’
[10:24:32.711]   - Field: ‘seed’
[10:24:32.712]   - Field: ‘version’
[10:24:32.712]   - Field: ‘result’
[10:24:32.712]   - Field: ‘asynchronous’
[10:24:32.712]   - Field: ‘calls’
[10:24:32.712]   - Field: ‘globals’
[10:24:32.712]   - Field: ‘stdout’
[10:24:32.712]   - Field: ‘earlySignal’
[10:24:32.712]   - Field: ‘lazy’
[10:24:32.712]   - Field: ‘state’
[10:24:32.712] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:32.712] - Launch lazy future ...
[10:24:32.713] Packages needed by the future expression (n = 0): <none>
[10:24:32.713] Packages needed by future strategies (n = 0): <none>
[10:24:32.713] {
[10:24:32.713]     {
[10:24:32.713]         {
[10:24:32.713]             ...future.startTime <- base::Sys.time()
[10:24:32.713]             {
[10:24:32.713]                 {
[10:24:32.713]                   {
[10:24:32.713]                     base::local({
[10:24:32.713]                       has_future <- base::requireNamespace("future", 
[10:24:32.713]                         quietly = TRUE)
[10:24:32.713]                       if (has_future) {
[10:24:32.713]                         ns <- base::getNamespace("future")
[10:24:32.713]                         version <- ns[[".package"]][["version"]]
[10:24:32.713]                         if (is.null(version)) 
[10:24:32.713]                           version <- utils::packageVersion("future")
[10:24:32.713]                       }
[10:24:32.713]                       else {
[10:24:32.713]                         version <- NULL
[10:24:32.713]                       }
[10:24:32.713]                       if (!has_future || version < "1.8.0") {
[10:24:32.713]                         info <- base::c(r_version = base::gsub("R version ", 
[10:24:32.713]                           "", base::R.version$version.string), 
[10:24:32.713]                           platform = base::sprintf("%s (%s-bit)", 
[10:24:32.713]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:32.713]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:32.713]                             "release", "version")], collapse = " "), 
[10:24:32.713]                           hostname = base::Sys.info()[["nodename"]])
[10:24:32.713]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:24:32.713]                           info)
[10:24:32.713]                         info <- base::paste(info, collapse = "; ")
[10:24:32.713]                         if (!has_future) {
[10:24:32.713]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:32.713]                             info)
[10:24:32.713]                         }
[10:24:32.713]                         else {
[10:24:32.713]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:32.713]                             info, version)
[10:24:32.713]                         }
[10:24:32.713]                         base::stop(msg)
[10:24:32.713]                       }
[10:24:32.713]                     })
[10:24:32.713]                   }
[10:24:32.713]                   options(future.plan = NULL)
[10:24:32.713]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:32.713]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:32.713]                 }
[10:24:32.713]                 ...future.workdir <- getwd()
[10:24:32.713]             }
[10:24:32.713]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:32.713]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:32.713]         }
[10:24:32.713]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:32.713]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:32.713]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:32.713]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:32.713]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:32.713]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:32.713]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:32.713]             base::names(...future.oldOptions))
[10:24:32.713]     }
[10:24:32.713]     if (FALSE) {
[10:24:32.713]     }
[10:24:32.713]     else {
[10:24:32.713]         if (FALSE) {
[10:24:32.713]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:32.713]                 open = "w")
[10:24:32.713]         }
[10:24:32.713]         else {
[10:24:32.713]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:32.713]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:32.713]         }
[10:24:32.713]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:32.713]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:32.713]             base::sink(type = "output", split = FALSE)
[10:24:32.713]             base::close(...future.stdout)
[10:24:32.713]         }, add = TRUE)
[10:24:32.713]     }
[10:24:32.713]     ...future.frame <- base::sys.nframe()
[10:24:32.713]     ...future.conditions <- base::list()
[10:24:32.713]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:32.713]     if (FALSE) {
[10:24:32.713]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:32.713]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:32.713]     }
[10:24:32.713]     ...future.result <- base::tryCatch({
[10:24:32.713]         base::withCallingHandlers({
[10:24:32.713]             ...future.value <- base::withVisible(base::local({
[10:24:32.713]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:32.713]                 if (!identical(...future.globals.maxSize.org, 
[10:24:32.713]                   ...future.globals.maxSize)) {
[10:24:32.713]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:32.713]                   on.exit(options(oopts), add = TRUE)
[10:24:32.713]                 }
[10:24:32.713]                 {
[10:24:32.713]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:32.713]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:24:32.713]                     USE.NAMES = FALSE)
[10:24:32.713]                   do.call(mapply, args = args)
[10:24:32.713]                 }
[10:24:32.713]             }))
[10:24:32.713]             future::FutureResult(value = ...future.value$value, 
[10:24:32.713]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:32.713]                   ...future.rng), globalenv = if (FALSE) 
[10:24:32.713]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:32.713]                     ...future.globalenv.names))
[10:24:32.713]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:32.713]         }, condition = base::local({
[10:24:32.713]             c <- base::c
[10:24:32.713]             inherits <- base::inherits
[10:24:32.713]             invokeRestart <- base::invokeRestart
[10:24:32.713]             length <- base::length
[10:24:32.713]             list <- base::list
[10:24:32.713]             seq.int <- base::seq.int
[10:24:32.713]             signalCondition <- base::signalCondition
[10:24:32.713]             sys.calls <- base::sys.calls
[10:24:32.713]             `[[` <- base::`[[`
[10:24:32.713]             `+` <- base::`+`
[10:24:32.713]             `<<-` <- base::`<<-`
[10:24:32.713]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:32.713]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:32.713]                   3L)]
[10:24:32.713]             }
[10:24:32.713]             function(cond) {
[10:24:32.713]                 is_error <- inherits(cond, "error")
[10:24:32.713]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:32.713]                   NULL)
[10:24:32.713]                 if (is_error) {
[10:24:32.713]                   sessionInformation <- function() {
[10:24:32.713]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:32.713]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:32.713]                       search = base::search(), system = base::Sys.info())
[10:24:32.713]                   }
[10:24:32.713]                   ...future.conditions[[length(...future.conditions) + 
[10:24:32.713]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:32.713]                     cond$call), session = sessionInformation(), 
[10:24:32.713]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:32.713]                   signalCondition(cond)
[10:24:32.713]                 }
[10:24:32.713]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:32.713]                 "immediateCondition"))) {
[10:24:32.713]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:32.713]                   ...future.conditions[[length(...future.conditions) + 
[10:24:32.713]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:32.713]                   if (TRUE && !signal) {
[10:24:32.713]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:32.713]                     {
[10:24:32.713]                       inherits <- base::inherits
[10:24:32.713]                       invokeRestart <- base::invokeRestart
[10:24:32.713]                       is.null <- base::is.null
[10:24:32.713]                       muffled <- FALSE
[10:24:32.713]                       if (inherits(cond, "message")) {
[10:24:32.713]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:32.713]                         if (muffled) 
[10:24:32.713]                           invokeRestart("muffleMessage")
[10:24:32.713]                       }
[10:24:32.713]                       else if (inherits(cond, "warning")) {
[10:24:32.713]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:32.713]                         if (muffled) 
[10:24:32.713]                           invokeRestart("muffleWarning")
[10:24:32.713]                       }
[10:24:32.713]                       else if (inherits(cond, "condition")) {
[10:24:32.713]                         if (!is.null(pattern)) {
[10:24:32.713]                           computeRestarts <- base::computeRestarts
[10:24:32.713]                           grepl <- base::grepl
[10:24:32.713]                           restarts <- computeRestarts(cond)
[10:24:32.713]                           for (restart in restarts) {
[10:24:32.713]                             name <- restart$name
[10:24:32.713]                             if (is.null(name)) 
[10:24:32.713]                               next
[10:24:32.713]                             if (!grepl(pattern, name)) 
[10:24:32.713]                               next
[10:24:32.713]                             invokeRestart(restart)
[10:24:32.713]                             muffled <- TRUE
[10:24:32.713]                             break
[10:24:32.713]                           }
[10:24:32.713]                         }
[10:24:32.713]                       }
[10:24:32.713]                       invisible(muffled)
[10:24:32.713]                     }
[10:24:32.713]                     muffleCondition(cond, pattern = "^muffle")
[10:24:32.713]                   }
[10:24:32.713]                 }
[10:24:32.713]                 else {
[10:24:32.713]                   if (TRUE) {
[10:24:32.713]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:32.713]                     {
[10:24:32.713]                       inherits <- base::inherits
[10:24:32.713]                       invokeRestart <- base::invokeRestart
[10:24:32.713]                       is.null <- base::is.null
[10:24:32.713]                       muffled <- FALSE
[10:24:32.713]                       if (inherits(cond, "message")) {
[10:24:32.713]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:32.713]                         if (muffled) 
[10:24:32.713]                           invokeRestart("muffleMessage")
[10:24:32.713]                       }
[10:24:32.713]                       else if (inherits(cond, "warning")) {
[10:24:32.713]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:32.713]                         if (muffled) 
[10:24:32.713]                           invokeRestart("muffleWarning")
[10:24:32.713]                       }
[10:24:32.713]                       else if (inherits(cond, "condition")) {
[10:24:32.713]                         if (!is.null(pattern)) {
[10:24:32.713]                           computeRestarts <- base::computeRestarts
[10:24:32.713]                           grepl <- base::grepl
[10:24:32.713]                           restarts <- computeRestarts(cond)
[10:24:32.713]                           for (restart in restarts) {
[10:24:32.713]                             name <- restart$name
[10:24:32.713]                             if (is.null(name)) 
[10:24:32.713]                               next
[10:24:32.713]                             if (!grepl(pattern, name)) 
[10:24:32.713]                               next
[10:24:32.713]                             invokeRestart(restart)
[10:24:32.713]                             muffled <- TRUE
[10:24:32.713]                             break
[10:24:32.713]                           }
[10:24:32.713]                         }
[10:24:32.713]                       }
[10:24:32.713]                       invisible(muffled)
[10:24:32.713]                     }
[10:24:32.713]                     muffleCondition(cond, pattern = "^muffle")
[10:24:32.713]                   }
[10:24:32.713]                 }
[10:24:32.713]             }
[10:24:32.713]         }))
[10:24:32.713]     }, error = function(ex) {
[10:24:32.713]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:32.713]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:32.713]                 ...future.rng), started = ...future.startTime, 
[10:24:32.713]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:32.713]             version = "1.8"), class = "FutureResult")
[10:24:32.713]     }, finally = {
[10:24:32.713]         if (!identical(...future.workdir, getwd())) 
[10:24:32.713]             setwd(...future.workdir)
[10:24:32.713]         {
[10:24:32.713]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:32.713]                 ...future.oldOptions$nwarnings <- NULL
[10:24:32.713]             }
[10:24:32.713]             base::options(...future.oldOptions)
[10:24:32.713]             if (.Platform$OS.type == "windows") {
[10:24:32.713]                 old_names <- names(...future.oldEnvVars)
[10:24:32.713]                 envs <- base::Sys.getenv()
[10:24:32.713]                 names <- names(envs)
[10:24:32.713]                 common <- intersect(names, old_names)
[10:24:32.713]                 added <- setdiff(names, old_names)
[10:24:32.713]                 removed <- setdiff(old_names, names)
[10:24:32.713]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:32.713]                   envs[common]]
[10:24:32.713]                 NAMES <- toupper(changed)
[10:24:32.713]                 args <- list()
[10:24:32.713]                 for (kk in seq_along(NAMES)) {
[10:24:32.713]                   name <- changed[[kk]]
[10:24:32.713]                   NAME <- NAMES[[kk]]
[10:24:32.713]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:32.713]                     next
[10:24:32.713]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:32.713]                 }
[10:24:32.713]                 NAMES <- toupper(added)
[10:24:32.713]                 for (kk in seq_along(NAMES)) {
[10:24:32.713]                   name <- added[[kk]]
[10:24:32.713]                   NAME <- NAMES[[kk]]
[10:24:32.713]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:32.713]                     next
[10:24:32.713]                   args[[name]] <- ""
[10:24:32.713]                 }
[10:24:32.713]                 NAMES <- toupper(removed)
[10:24:32.713]                 for (kk in seq_along(NAMES)) {
[10:24:32.713]                   name <- removed[[kk]]
[10:24:32.713]                   NAME <- NAMES[[kk]]
[10:24:32.713]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:32.713]                     next
[10:24:32.713]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:32.713]                 }
[10:24:32.713]                 if (length(args) > 0) 
[10:24:32.713]                   base::do.call(base::Sys.setenv, args = args)
[10:24:32.713]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:32.713]             }
[10:24:32.713]             else {
[10:24:32.713]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:32.713]             }
[10:24:32.713]             {
[10:24:32.713]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:32.713]                   0L) {
[10:24:32.713]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:32.713]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:32.713]                   base::options(opts)
[10:24:32.713]                 }
[10:24:32.713]                 {
[10:24:32.713]                   {
[10:24:32.713]                     NULL
[10:24:32.713]                     RNGkind("Mersenne-Twister")
[10:24:32.713]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:32.713]                       inherits = FALSE)
[10:24:32.713]                   }
[10:24:32.713]                   options(future.plan = NULL)
[10:24:32.713]                   if (is.na(NA_character_)) 
[10:24:32.713]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:32.713]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:32.713]                   future::plan(list(function (..., envir = parent.frame()) 
[10:24:32.713]                   {
[10:24:32.713]                     future <- SequentialFuture(..., envir = envir)
[10:24:32.713]                     if (!future$lazy) 
[10:24:32.713]                       future <- run(future)
[10:24:32.713]                     invisible(future)
[10:24:32.713]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:32.713]                 }
[10:24:32.713]             }
[10:24:32.713]         }
[10:24:32.713]     })
[10:24:32.713]     if (TRUE) {
[10:24:32.713]         base::sink(type = "output", split = FALSE)
[10:24:32.713]         if (FALSE) {
[10:24:32.713]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:32.713]         }
[10:24:32.713]         else {
[10:24:32.713]             ...future.result["stdout"] <- base::list(NULL)
[10:24:32.713]         }
[10:24:32.713]         base::close(...future.stdout)
[10:24:32.713]         ...future.stdout <- NULL
[10:24:32.713]     }
[10:24:32.713]     ...future.result$conditions <- ...future.conditions
[10:24:32.713]     ...future.result$finished <- base::Sys.time()
[10:24:32.713]     ...future.result
[10:24:32.713] }
[10:24:32.715] assign_globals() ...
[10:24:32.715] List of 5
[10:24:32.715]  $ ...future.FUN            :function (x, y)  
[10:24:32.715]  $ MoreArgs                 : NULL
[10:24:32.715]  $ ...future.elements_ii    :List of 2
[10:24:32.715]   ..$ :List of 2
[10:24:32.715]   .. ..$ : int 1
[10:24:32.715]   .. ..$ : int 0
[10:24:32.715]   ..$ :List of 2
[10:24:32.715]   .. ..$ : int 0
[10:24:32.715]   .. ..$ : int 1
[10:24:32.715]  $ ...future.seeds_ii       : NULL
[10:24:32.715]  $ ...future.globals.maxSize: NULL
[10:24:32.715]  - attr(*, "where")=List of 5
[10:24:32.715]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:32.715]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:24:32.715]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:32.715]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:32.715]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:32.715]  - attr(*, "resolved")= logi FALSE
[10:24:32.715]  - attr(*, "total_size")= num 6480
[10:24:32.715]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:32.715]  - attr(*, "already-done")= logi TRUE
[10:24:32.721] - reassign environment for ‘...future.FUN’
[10:24:32.721] - copied ‘...future.FUN’ to environment
[10:24:32.721] - copied ‘MoreArgs’ to environment
[10:24:32.721] - copied ‘...future.elements_ii’ to environment
[10:24:32.721] - copied ‘...future.seeds_ii’ to environment
[10:24:32.721] - copied ‘...future.globals.maxSize’ to environment
[10:24:32.721] assign_globals() ... done
[10:24:32.721] plan(): Setting new future strategy stack:
[10:24:32.721] List of future strategies:
[10:24:32.721] 1. sequential:
[10:24:32.721]    - args: function (..., envir = parent.frame())
[10:24:32.721]    - tweaked: FALSE
[10:24:32.721]    - call: NULL
[10:24:32.722] plan(): nbrOfWorkers() = 1
[10:24:33.224] plan(): Setting new future strategy stack:
[10:24:33.224] List of future strategies:
[10:24:33.224] 1. sequential:
[10:24:33.224]    - args: function (..., envir = parent.frame())
[10:24:33.224]    - tweaked: FALSE
[10:24:33.224]    - call: plan(strategy)
[10:24:33.224] plan(): nbrOfWorkers() = 1
[10:24:33.224] SequentialFuture started (and completed)
[10:24:33.225] - Launch lazy future ... done
[10:24:33.225] run() for ‘SequentialFuture’ ... done
[10:24:33.225] Created future:
[10:24:33.225] SequentialFuture:
[10:24:33.225] Label: ‘future_mapply-1’
[10:24:33.225] Expression:
[10:24:33.225] {
[10:24:33.225]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:33.225]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:33.225]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:33.225]         on.exit(options(oopts), add = TRUE)
[10:24:33.225]     }
[10:24:33.225]     {
[10:24:33.225]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:33.225]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:24:33.225]         do.call(mapply, args = args)
[10:24:33.225]     }
[10:24:33.225] }
[10:24:33.225] Lazy evaluation: FALSE
[10:24:33.225] Asynchronous evaluation: FALSE
[10:24:33.225] Local evaluation: TRUE
[10:24:33.225] Environment: R_GlobalEnv
[10:24:33.225] Capture standard output: FALSE
[10:24:33.225] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:33.225] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:33.225] Packages: <none>
[10:24:33.225] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:33.225] Resolved: TRUE
[10:24:33.225] Value: 224 bytes of class ‘list’
[10:24:33.225] Early signaling: FALSE
[10:24:33.225] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:33.225] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:33.226] Chunk #1 of 1 ... DONE
[10:24:33.226] Launching 1 futures (chunks) ... DONE
[10:24:33.226] Resolving 1 futures (chunks) ...
[10:24:33.226] resolve() on list ...
[10:24:33.227]  recursive: 0
[10:24:33.227]  length: 1
[10:24:33.227] 
[10:24:33.227] resolved() for ‘SequentialFuture’ ...
[10:24:33.227] - state: ‘finished’
[10:24:33.227] - run: TRUE
[10:24:33.227] - result: ‘FutureResult’
[10:24:33.227] resolved() for ‘SequentialFuture’ ... done
[10:24:33.227] Future #1
[10:24:33.227] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:33.228] - nx: 1
[10:24:33.228] - relay: TRUE
[10:24:33.228] - stdout: TRUE
[10:24:33.228] - signal: TRUE
[10:24:33.228] - resignal: FALSE
[10:24:33.228] - force: TRUE
[10:24:33.228] - relayed: [n=1] FALSE
[10:24:33.228] - queued futures: [n=1] FALSE
[10:24:33.228]  - until=1
[10:24:33.228]  - relaying element #1
[10:24:33.230] - relayed: [n=1] TRUE
[10:24:33.230] - queued futures: [n=1] TRUE
[10:24:33.231] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:33.231]  length: 0 (resolved future 1)
[10:24:33.231] Relaying remaining futures
[10:24:33.231] signalConditionsASAP(NULL, pos=0) ...
[10:24:33.231] - nx: 1
[10:24:33.231] - relay: TRUE
[10:24:33.231] - stdout: TRUE
[10:24:33.231] - signal: TRUE
[10:24:33.231] - resignal: FALSE
[10:24:33.231] - force: TRUE
[10:24:33.231] - relayed: [n=1] TRUE
[10:24:33.231] - queued futures: [n=1] TRUE
 - flush all
[10:24:33.232] - relayed: [n=1] TRUE
[10:24:33.232] - queued futures: [n=1] TRUE
[10:24:33.232] signalConditionsASAP(NULL, pos=0) ... done
[10:24:33.232] resolve() on list ... DONE
[10:24:33.232]  - Number of value chunks collected: 1
[10:24:33.232] Resolving 1 futures (chunks) ... DONE
[10:24:33.232] Reducing values from 1 chunks ...
[10:24:33.232]  - Number of values collected after concatenation: 2
[10:24:33.232]  - Number of values expected: 2
[10:24:33.233] Reducing values from 1 chunks ... DONE
[10:24:33.233] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[10:24:33.233] future_mapply() ...
[10:24:33.233] Number of chunks: 1
[10:24:33.233] getGlobalsAndPackagesXApply() ...
[10:24:33.234]  - future.globals: TRUE
[10:24:33.234] getGlobalsAndPackages() ...
[10:24:33.234] Searching for globals...
[10:24:33.235] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:24:33.235] Searching for globals ... DONE
[10:24:33.236] Resolving globals: FALSE
[10:24:33.236] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[10:24:33.236] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[10:24:33.237] - globals: [1] ‘FUN’
[10:24:33.237] 
[10:24:33.237] getGlobalsAndPackages() ... DONE
[10:24:33.237]  - globals found/used: [n=1] ‘FUN’
[10:24:33.237]  - needed namespaces: [n=0] 
[10:24:33.237] Finding globals ... DONE
[10:24:33.237] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:24:33.237] List of 2
[10:24:33.237]  $ ...future.FUN:function (x, y)  
[10:24:33.237]  $ MoreArgs     : NULL
[10:24:33.237]  - attr(*, "where")=List of 2
[10:24:33.237]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:33.237]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:24:33.237]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:33.237]  - attr(*, "resolved")= logi FALSE
[10:24:33.237]  - attr(*, "total_size")= num NA
[10:24:33.240] Packages to be attached in all futures: [n=0] 
[10:24:33.240] getGlobalsAndPackagesXApply() ... DONE
[10:24:33.240] Number of futures (= number of chunks): 1
[10:24:33.240] Launching 1 futures (chunks) ...
[10:24:33.240] Chunk #1 of 1 ...
[10:24:33.241]  - Finding globals in '...' for chunk #1 ...
[10:24:33.241] getGlobalsAndPackages() ...
[10:24:33.241] Searching for globals...
[10:24:33.241] 
[10:24:33.241] Searching for globals ... DONE
[10:24:33.241] - globals: [0] <none>
[10:24:33.241] getGlobalsAndPackages() ... DONE
[10:24:33.241]    + additional globals found: [n=0] 
[10:24:33.242]    + additional namespaces needed: [n=0] 
[10:24:33.242]  - Finding globals in '...' for chunk #1 ... DONE
[10:24:33.242]  - seeds: <none>
[10:24:33.242]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:33.242] getGlobalsAndPackages() ...
[10:24:33.242] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:33.242] Resolving globals: FALSE
[10:24:33.243] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[10:24:33.243] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:24:33.243] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:33.243] 
[10:24:33.243] getGlobalsAndPackages() ... DONE
[10:24:33.244] run() for ‘Future’ ...
[10:24:33.244] - state: ‘created’
[10:24:33.244] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:24:33.244] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:33.244] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:33.244]   - Field: ‘label’
[10:24:33.245]   - Field: ‘local’
[10:24:33.245]   - Field: ‘owner’
[10:24:33.245]   - Field: ‘envir’
[10:24:33.245]   - Field: ‘packages’
[10:24:33.245]   - Field: ‘gc’
[10:24:33.245]   - Field: ‘conditions’
[10:24:33.245]   - Field: ‘expr’
[10:24:33.245]   - Field: ‘uuid’
[10:24:33.245]   - Field: ‘seed’
[10:24:33.245]   - Field: ‘version’
[10:24:33.246]   - Field: ‘result’
[10:24:33.246]   - Field: ‘asynchronous’
[10:24:33.246]   - Field: ‘calls’
[10:24:33.246]   - Field: ‘globals’
[10:24:33.246]   - Field: ‘stdout’
[10:24:33.246]   - Field: ‘earlySignal’
[10:24:33.246]   - Field: ‘lazy’
[10:24:33.246]   - Field: ‘state’
[10:24:33.246] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:33.246] - Launch lazy future ...
[10:24:33.247] Packages needed by the future expression (n = 0): <none>
[10:24:33.247] Packages needed by future strategies (n = 0): <none>
[10:24:33.247] {
[10:24:33.247]     {
[10:24:33.247]         {
[10:24:33.247]             ...future.startTime <- base::Sys.time()
[10:24:33.247]             {
[10:24:33.247]                 {
[10:24:33.247]                   {
[10:24:33.247]                     base::local({
[10:24:33.247]                       has_future <- base::requireNamespace("future", 
[10:24:33.247]                         quietly = TRUE)
[10:24:33.247]                       if (has_future) {
[10:24:33.247]                         ns <- base::getNamespace("future")
[10:24:33.247]                         version <- ns[[".package"]][["version"]]
[10:24:33.247]                         if (is.null(version)) 
[10:24:33.247]                           version <- utils::packageVersion("future")
[10:24:33.247]                       }
[10:24:33.247]                       else {
[10:24:33.247]                         version <- NULL
[10:24:33.247]                       }
[10:24:33.247]                       if (!has_future || version < "1.8.0") {
[10:24:33.247]                         info <- base::c(r_version = base::gsub("R version ", 
[10:24:33.247]                           "", base::R.version$version.string), 
[10:24:33.247]                           platform = base::sprintf("%s (%s-bit)", 
[10:24:33.247]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:33.247]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:33.247]                             "release", "version")], collapse = " "), 
[10:24:33.247]                           hostname = base::Sys.info()[["nodename"]])
[10:24:33.247]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:24:33.247]                           info)
[10:24:33.247]                         info <- base::paste(info, collapse = "; ")
[10:24:33.247]                         if (!has_future) {
[10:24:33.247]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:33.247]                             info)
[10:24:33.247]                         }
[10:24:33.247]                         else {
[10:24:33.247]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:33.247]                             info, version)
[10:24:33.247]                         }
[10:24:33.247]                         base::stop(msg)
[10:24:33.247]                       }
[10:24:33.247]                     })
[10:24:33.247]                   }
[10:24:33.247]                   options(future.plan = NULL)
[10:24:33.247]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:33.247]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:33.247]                 }
[10:24:33.247]                 ...future.workdir <- getwd()
[10:24:33.247]             }
[10:24:33.247]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:33.247]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:33.247]         }
[10:24:33.247]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:33.247]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:33.247]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:33.247]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:33.247]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:33.247]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:33.247]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:33.247]             base::names(...future.oldOptions))
[10:24:33.247]     }
[10:24:33.247]     if (FALSE) {
[10:24:33.247]     }
[10:24:33.247]     else {
[10:24:33.247]         if (TRUE) {
[10:24:33.247]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:33.247]                 open = "w")
[10:24:33.247]         }
[10:24:33.247]         else {
[10:24:33.247]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:33.247]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:33.247]         }
[10:24:33.247]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:33.247]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:33.247]             base::sink(type = "output", split = FALSE)
[10:24:33.247]             base::close(...future.stdout)
[10:24:33.247]         }, add = TRUE)
[10:24:33.247]     }
[10:24:33.247]     ...future.frame <- base::sys.nframe()
[10:24:33.247]     ...future.conditions <- base::list()
[10:24:33.247]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:33.247]     if (FALSE) {
[10:24:33.247]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:33.247]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:33.247]     }
[10:24:33.247]     ...future.result <- base::tryCatch({
[10:24:33.247]         base::withCallingHandlers({
[10:24:33.247]             ...future.value <- base::withVisible(base::local({
[10:24:33.247]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:33.247]                 if (!identical(...future.globals.maxSize.org, 
[10:24:33.247]                   ...future.globals.maxSize)) {
[10:24:33.247]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:33.247]                   on.exit(options(oopts), add = TRUE)
[10:24:33.247]                 }
[10:24:33.247]                 {
[10:24:33.247]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:33.247]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:24:33.247]                     USE.NAMES = FALSE)
[10:24:33.247]                   do.call(mapply, args = args)
[10:24:33.247]                 }
[10:24:33.247]             }))
[10:24:33.247]             future::FutureResult(value = ...future.value$value, 
[10:24:33.247]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:33.247]                   ...future.rng), globalenv = if (FALSE) 
[10:24:33.247]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:33.247]                     ...future.globalenv.names))
[10:24:33.247]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:33.247]         }, condition = base::local({
[10:24:33.247]             c <- base::c
[10:24:33.247]             inherits <- base::inherits
[10:24:33.247]             invokeRestart <- base::invokeRestart
[10:24:33.247]             length <- base::length
[10:24:33.247]             list <- base::list
[10:24:33.247]             seq.int <- base::seq.int
[10:24:33.247]             signalCondition <- base::signalCondition
[10:24:33.247]             sys.calls <- base::sys.calls
[10:24:33.247]             `[[` <- base::`[[`
[10:24:33.247]             `+` <- base::`+`
[10:24:33.247]             `<<-` <- base::`<<-`
[10:24:33.247]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:33.247]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:33.247]                   3L)]
[10:24:33.247]             }
[10:24:33.247]             function(cond) {
[10:24:33.247]                 is_error <- inherits(cond, "error")
[10:24:33.247]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:33.247]                   NULL)
[10:24:33.247]                 if (is_error) {
[10:24:33.247]                   sessionInformation <- function() {
[10:24:33.247]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:33.247]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:33.247]                       search = base::search(), system = base::Sys.info())
[10:24:33.247]                   }
[10:24:33.247]                   ...future.conditions[[length(...future.conditions) + 
[10:24:33.247]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:33.247]                     cond$call), session = sessionInformation(), 
[10:24:33.247]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:33.247]                   signalCondition(cond)
[10:24:33.247]                 }
[10:24:33.247]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:33.247]                 "immediateCondition"))) {
[10:24:33.247]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:33.247]                   ...future.conditions[[length(...future.conditions) + 
[10:24:33.247]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:33.247]                   if (TRUE && !signal) {
[10:24:33.247]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:33.247]                     {
[10:24:33.247]                       inherits <- base::inherits
[10:24:33.247]                       invokeRestart <- base::invokeRestart
[10:24:33.247]                       is.null <- base::is.null
[10:24:33.247]                       muffled <- FALSE
[10:24:33.247]                       if (inherits(cond, "message")) {
[10:24:33.247]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:33.247]                         if (muffled) 
[10:24:33.247]                           invokeRestart("muffleMessage")
[10:24:33.247]                       }
[10:24:33.247]                       else if (inherits(cond, "warning")) {
[10:24:33.247]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:33.247]                         if (muffled) 
[10:24:33.247]                           invokeRestart("muffleWarning")
[10:24:33.247]                       }
[10:24:33.247]                       else if (inherits(cond, "condition")) {
[10:24:33.247]                         if (!is.null(pattern)) {
[10:24:33.247]                           computeRestarts <- base::computeRestarts
[10:24:33.247]                           grepl <- base::grepl
[10:24:33.247]                           restarts <- computeRestarts(cond)
[10:24:33.247]                           for (restart in restarts) {
[10:24:33.247]                             name <- restart$name
[10:24:33.247]                             if (is.null(name)) 
[10:24:33.247]                               next
[10:24:33.247]                             if (!grepl(pattern, name)) 
[10:24:33.247]                               next
[10:24:33.247]                             invokeRestart(restart)
[10:24:33.247]                             muffled <- TRUE
[10:24:33.247]                             break
[10:24:33.247]                           }
[10:24:33.247]                         }
[10:24:33.247]                       }
[10:24:33.247]                       invisible(muffled)
[10:24:33.247]                     }
[10:24:33.247]                     muffleCondition(cond, pattern = "^muffle")
[10:24:33.247]                   }
[10:24:33.247]                 }
[10:24:33.247]                 else {
[10:24:33.247]                   if (TRUE) {
[10:24:33.247]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:33.247]                     {
[10:24:33.247]                       inherits <- base::inherits
[10:24:33.247]                       invokeRestart <- base::invokeRestart
[10:24:33.247]                       is.null <- base::is.null
[10:24:33.247]                       muffled <- FALSE
[10:24:33.247]                       if (inherits(cond, "message")) {
[10:24:33.247]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:33.247]                         if (muffled) 
[10:24:33.247]                           invokeRestart("muffleMessage")
[10:24:33.247]                       }
[10:24:33.247]                       else if (inherits(cond, "warning")) {
[10:24:33.247]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:33.247]                         if (muffled) 
[10:24:33.247]                           invokeRestart("muffleWarning")
[10:24:33.247]                       }
[10:24:33.247]                       else if (inherits(cond, "condition")) {
[10:24:33.247]                         if (!is.null(pattern)) {
[10:24:33.247]                           computeRestarts <- base::computeRestarts
[10:24:33.247]                           grepl <- base::grepl
[10:24:33.247]                           restarts <- computeRestarts(cond)
[10:24:33.247]                           for (restart in restarts) {
[10:24:33.247]                             name <- restart$name
[10:24:33.247]                             if (is.null(name)) 
[10:24:33.247]                               next
[10:24:33.247]                             if (!grepl(pattern, name)) 
[10:24:33.247]                               next
[10:24:33.247]                             invokeRestart(restart)
[10:24:33.247]                             muffled <- TRUE
[10:24:33.247]                             break
[10:24:33.247]                           }
[10:24:33.247]                         }
[10:24:33.247]                       }
[10:24:33.247]                       invisible(muffled)
[10:24:33.247]                     }
[10:24:33.247]                     muffleCondition(cond, pattern = "^muffle")
[10:24:33.247]                   }
[10:24:33.247]                 }
[10:24:33.247]             }
[10:24:33.247]         }))
[10:24:33.247]     }, error = function(ex) {
[10:24:33.247]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:33.247]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:33.247]                 ...future.rng), started = ...future.startTime, 
[10:24:33.247]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:33.247]             version = "1.8"), class = "FutureResult")
[10:24:33.247]     }, finally = {
[10:24:33.247]         if (!identical(...future.workdir, getwd())) 
[10:24:33.247]             setwd(...future.workdir)
[10:24:33.247]         {
[10:24:33.247]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:33.247]                 ...future.oldOptions$nwarnings <- NULL
[10:24:33.247]             }
[10:24:33.247]             base::options(...future.oldOptions)
[10:24:33.247]             if (.Platform$OS.type == "windows") {
[10:24:33.247]                 old_names <- names(...future.oldEnvVars)
[10:24:33.247]                 envs <- base::Sys.getenv()
[10:24:33.247]                 names <- names(envs)
[10:24:33.247]                 common <- intersect(names, old_names)
[10:24:33.247]                 added <- setdiff(names, old_names)
[10:24:33.247]                 removed <- setdiff(old_names, names)
[10:24:33.247]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:33.247]                   envs[common]]
[10:24:33.247]                 NAMES <- toupper(changed)
[10:24:33.247]                 args <- list()
[10:24:33.247]                 for (kk in seq_along(NAMES)) {
[10:24:33.247]                   name <- changed[[kk]]
[10:24:33.247]                   NAME <- NAMES[[kk]]
[10:24:33.247]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:33.247]                     next
[10:24:33.247]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:33.247]                 }
[10:24:33.247]                 NAMES <- toupper(added)
[10:24:33.247]                 for (kk in seq_along(NAMES)) {
[10:24:33.247]                   name <- added[[kk]]
[10:24:33.247]                   NAME <- NAMES[[kk]]
[10:24:33.247]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:33.247]                     next
[10:24:33.247]                   args[[name]] <- ""
[10:24:33.247]                 }
[10:24:33.247]                 NAMES <- toupper(removed)
[10:24:33.247]                 for (kk in seq_along(NAMES)) {
[10:24:33.247]                   name <- removed[[kk]]
[10:24:33.247]                   NAME <- NAMES[[kk]]
[10:24:33.247]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:33.247]                     next
[10:24:33.247]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:33.247]                 }
[10:24:33.247]                 if (length(args) > 0) 
[10:24:33.247]                   base::do.call(base::Sys.setenv, args = args)
[10:24:33.247]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:33.247]             }
[10:24:33.247]             else {
[10:24:33.247]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:33.247]             }
[10:24:33.247]             {
[10:24:33.247]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:33.247]                   0L) {
[10:24:33.247]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:33.247]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:33.247]                   base::options(opts)
[10:24:33.247]                 }
[10:24:33.247]                 {
[10:24:33.247]                   {
[10:24:33.247]                     NULL
[10:24:33.247]                     RNGkind("Mersenne-Twister")
[10:24:33.247]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:33.247]                       inherits = FALSE)
[10:24:33.247]                   }
[10:24:33.247]                   options(future.plan = NULL)
[10:24:33.247]                   if (is.na(NA_character_)) 
[10:24:33.247]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:33.247]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:33.247]                   future::plan(list(function (..., envir = parent.frame()) 
[10:24:33.247]                   {
[10:24:33.247]                     future <- SequentialFuture(..., envir = envir)
[10:24:33.247]                     if (!future$lazy) 
[10:24:33.247]                       future <- run(future)
[10:24:33.247]                     invisible(future)
[10:24:33.247]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:33.247]                 }
[10:24:33.247]             }
[10:24:33.247]         }
[10:24:33.247]     })
[10:24:33.247]     if (TRUE) {
[10:24:33.247]         base::sink(type = "output", split = FALSE)
[10:24:33.247]         if (TRUE) {
[10:24:33.247]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:33.247]         }
[10:24:33.247]         else {
[10:24:33.247]             ...future.result["stdout"] <- base::list(NULL)
[10:24:33.247]         }
[10:24:33.247]         base::close(...future.stdout)
[10:24:33.247]         ...future.stdout <- NULL
[10:24:33.247]     }
[10:24:33.247]     ...future.result$conditions <- ...future.conditions
[10:24:33.247]     ...future.result$finished <- base::Sys.time()
[10:24:33.247]     ...future.result
[10:24:33.247] }
[10:24:33.249] assign_globals() ...
[10:24:33.249] List of 5
[10:24:33.249]  $ ...future.FUN            :function (x, y)  
[10:24:33.249]  $ MoreArgs                 : NULL
[10:24:33.249]  $ ...future.elements_ii    :List of 2
[10:24:33.249]   ..$ :List of 2
[10:24:33.249]   .. ..$ : int 1
[10:24:33.249]   .. ..$ : int 0
[10:24:33.249]   ..$ :List of 2
[10:24:33.249]   .. ..$ : int 0
[10:24:33.249]   .. ..$ : int 1
[10:24:33.249]  $ ...future.seeds_ii       : NULL
[10:24:33.249]  $ ...future.globals.maxSize: NULL
[10:24:33.249]  - attr(*, "where")=List of 5
[10:24:33.249]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:33.249]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:24:33.249]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:33.249]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:33.249]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:33.249]  - attr(*, "resolved")= logi FALSE
[10:24:33.249]  - attr(*, "total_size")= num 6480
[10:24:33.249]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:33.249]  - attr(*, "already-done")= logi TRUE
[10:24:33.257] - reassign environment for ‘...future.FUN’
[10:24:33.257] - copied ‘...future.FUN’ to environment
[10:24:33.257] - copied ‘MoreArgs’ to environment
[10:24:33.257] - copied ‘...future.elements_ii’ to environment
[10:24:33.257] - copied ‘...future.seeds_ii’ to environment
[10:24:33.257] - copied ‘...future.globals.maxSize’ to environment
[10:24:33.257] assign_globals() ... done
[10:24:33.257] plan(): Setting new future strategy stack:
[10:24:33.258] List of future strategies:
[10:24:33.258] 1. sequential:
[10:24:33.258]    - args: function (..., envir = parent.frame())
[10:24:33.258]    - tweaked: FALSE
[10:24:33.258]    - call: NULL
[10:24:33.258] plan(): nbrOfWorkers() = 1
[10:24:33.760] plan(): Setting new future strategy stack:
[10:24:33.760] List of future strategies:
[10:24:33.760] 1. sequential:
[10:24:33.760]    - args: function (..., envir = parent.frame())
[10:24:33.760]    - tweaked: FALSE
[10:24:33.760]    - call: plan(strategy)
[10:24:33.760] plan(): nbrOfWorkers() = 1
[10:24:33.761] SequentialFuture started (and completed)
[10:24:33.761] - Launch lazy future ... done
[10:24:33.761] run() for ‘SequentialFuture’ ... done
[10:24:33.761] Created future:
[10:24:33.761] SequentialFuture:
[10:24:33.761] Label: ‘future_mapply-1’
[10:24:33.761] Expression:
[10:24:33.761] {
[10:24:33.761]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:33.761]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:33.761]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:33.761]         on.exit(options(oopts), add = TRUE)
[10:24:33.761]     }
[10:24:33.761]     {
[10:24:33.761]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:33.761]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:24:33.761]         do.call(mapply, args = args)
[10:24:33.761]     }
[10:24:33.761] }
[10:24:33.761] Lazy evaluation: FALSE
[10:24:33.761] Asynchronous evaluation: FALSE
[10:24:33.761] Local evaluation: TRUE
[10:24:33.761] Environment: R_GlobalEnv
[10:24:33.761] Capture standard output: TRUE
[10:24:33.761] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:33.761] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:33.761] Packages: <none>
[10:24:33.761] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:33.761] Resolved: TRUE
[10:24:33.761] Value: 224 bytes of class ‘list’
[10:24:33.761] Early signaling: FALSE
[10:24:33.761] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:33.761] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:33.762] Chunk #1 of 1 ... DONE
[10:24:33.762] Launching 1 futures (chunks) ... DONE
[10:24:33.762] Resolving 1 futures (chunks) ...
[10:24:33.762] resolve() on list ...
[10:24:33.763]  recursive: 0
[10:24:33.763]  length: 1
[10:24:33.763] 
[10:24:33.763] resolved() for ‘SequentialFuture’ ...
[10:24:33.763] - state: ‘finished’
[10:24:33.763] - run: TRUE
[10:24:33.763] - result: ‘FutureResult’
[10:24:33.763] resolved() for ‘SequentialFuture’ ... done
[10:24:33.763] Future #1
[10:24:33.763] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:33.764] - nx: 1
[10:24:33.764] - relay: TRUE
[10:24:33.764] - stdout: TRUE
[10:24:33.764] - signal: TRUE
[10:24:33.764] - resignal: FALSE
[10:24:33.764] - force: TRUE
[10:24:33.764] - relayed: [n=1] FALSE
[10:24:33.764] - queued futures: [n=1] FALSE
[10:24:33.764]  - until=1
[10:24:33.764]  - relaying element #1
[10:24:33.765] - relayed: [n=1] TRUE
[10:24:33.765] - queued futures: [n=1] TRUE
[10:24:33.765] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:33.765]  length: 0 (resolved future 1)
[10:24:33.765] Relaying remaining futures
[10:24:33.765] signalConditionsASAP(NULL, pos=0) ...
[10:24:33.765] - nx: 1
[10:24:33.765] - relay: TRUE
[10:24:33.765] - stdout: TRUE
[10:24:33.765] - signal: TRUE
[10:24:33.766] - resignal: FALSE
[10:24:33.766] - force: TRUE
[10:24:33.766] - relayed: [n=1] TRUE
[10:24:33.766] - queued futures: [n=1] TRUE
 - flush all
[10:24:33.766] - relayed: [n=1] TRUE
[10:24:33.766] - queued futures: [n=1] TRUE
[10:24:33.766] signalConditionsASAP(NULL, pos=0) ... done
[10:24:33.766] resolve() on list ... DONE
[10:24:33.766]  - Number of value chunks collected: 1
[10:24:33.766] Resolving 1 futures (chunks) ... DONE
[10:24:33.767] Reducing values from 1 chunks ...
[10:24:33.767]  - Number of values collected after concatenation: 2
[10:24:33.767]  - Number of values expected: 2
[10:24:33.767] Reducing values from 1 chunks ... DONE
[10:24:33.767] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[10:24:33.767] future_mapply() ...
[10:24:33.767] Number of chunks: 1
[10:24:33.768] getGlobalsAndPackagesXApply() ...
[10:24:33.768]  - future.globals: TRUE
[10:24:33.768] getGlobalsAndPackages() ...
[10:24:33.768] Searching for globals...
[10:24:33.769] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:24:33.770] Searching for globals ... DONE
[10:24:33.770] Resolving globals: FALSE
[10:24:33.770] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[10:24:33.770] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[10:24:33.771] - globals: [1] ‘FUN’
[10:24:33.771] 
[10:24:33.771] getGlobalsAndPackages() ... DONE
[10:24:33.771]  - globals found/used: [n=1] ‘FUN’
[10:24:33.771]  - needed namespaces: [n=0] 
[10:24:33.771] Finding globals ... DONE
[10:24:33.771] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:24:33.771] List of 2
[10:24:33.771]  $ ...future.FUN:function (x, y)  
[10:24:33.771]  $ MoreArgs     : NULL
[10:24:33.771]  - attr(*, "where")=List of 2
[10:24:33.771]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:33.771]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:24:33.771]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:33.771]  - attr(*, "resolved")= logi FALSE
[10:24:33.771]  - attr(*, "total_size")= num NA
[10:24:33.774] Packages to be attached in all futures: [n=0] 
[10:24:33.774] getGlobalsAndPackagesXApply() ... DONE
[10:24:33.774] Number of futures (= number of chunks): 1
[10:24:33.774] Launching 1 futures (chunks) ...
[10:24:33.774] Chunk #1 of 1 ...
[10:24:33.775]  - Finding globals in '...' for chunk #1 ...
[10:24:33.775] getGlobalsAndPackages() ...
[10:24:33.775] Searching for globals...
[10:24:33.775] 
[10:24:33.775] Searching for globals ... DONE
[10:24:33.775] - globals: [0] <none>
[10:24:33.775] getGlobalsAndPackages() ... DONE
[10:24:33.775]    + additional globals found: [n=0] 
[10:24:33.776]    + additional namespaces needed: [n=0] 
[10:24:33.776]  - Finding globals in '...' for chunk #1 ... DONE
[10:24:33.776]  - seeds: <none>
[10:24:33.776]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:33.776] getGlobalsAndPackages() ...
[10:24:33.776] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:33.776] Resolving globals: FALSE
[10:24:33.777] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[10:24:33.777] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:24:33.777] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:33.777] 
[10:24:33.777] getGlobalsAndPackages() ... DONE
[10:24:33.778] run() for ‘Future’ ...
[10:24:33.778] - state: ‘created’
[10:24:33.778] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:24:33.778] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:33.778] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:33.778]   - Field: ‘label’
[10:24:33.779]   - Field: ‘local’
[10:24:33.779]   - Field: ‘owner’
[10:24:33.779]   - Field: ‘envir’
[10:24:33.779]   - Field: ‘packages’
[10:24:33.779]   - Field: ‘gc’
[10:24:33.779]   - Field: ‘conditions’
[10:24:33.779]   - Field: ‘expr’
[10:24:33.779]   - Field: ‘uuid’
[10:24:33.779]   - Field: ‘seed’
[10:24:33.779]   - Field: ‘version’
[10:24:33.779]   - Field: ‘result’
[10:24:33.780]   - Field: ‘asynchronous’
[10:24:33.780]   - Field: ‘calls’
[10:24:33.780]   - Field: ‘globals’
[10:24:33.780]   - Field: ‘stdout’
[10:24:33.780]   - Field: ‘earlySignal’
[10:24:33.780]   - Field: ‘lazy’
[10:24:33.780]   - Field: ‘state’
[10:24:33.780] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:33.780] - Launch lazy future ...
[10:24:33.781] Packages needed by the future expression (n = 0): <none>
[10:24:33.781] Packages needed by future strategies (n = 0): <none>
[10:24:33.781] {
[10:24:33.781]     {
[10:24:33.781]         {
[10:24:33.781]             ...future.startTime <- base::Sys.time()
[10:24:33.781]             {
[10:24:33.781]                 {
[10:24:33.781]                   {
[10:24:33.781]                     base::local({
[10:24:33.781]                       has_future <- base::requireNamespace("future", 
[10:24:33.781]                         quietly = TRUE)
[10:24:33.781]                       if (has_future) {
[10:24:33.781]                         ns <- base::getNamespace("future")
[10:24:33.781]                         version <- ns[[".package"]][["version"]]
[10:24:33.781]                         if (is.null(version)) 
[10:24:33.781]                           version <- utils::packageVersion("future")
[10:24:33.781]                       }
[10:24:33.781]                       else {
[10:24:33.781]                         version <- NULL
[10:24:33.781]                       }
[10:24:33.781]                       if (!has_future || version < "1.8.0") {
[10:24:33.781]                         info <- base::c(r_version = base::gsub("R version ", 
[10:24:33.781]                           "", base::R.version$version.string), 
[10:24:33.781]                           platform = base::sprintf("%s (%s-bit)", 
[10:24:33.781]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:33.781]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:33.781]                             "release", "version")], collapse = " "), 
[10:24:33.781]                           hostname = base::Sys.info()[["nodename"]])
[10:24:33.781]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:24:33.781]                           info)
[10:24:33.781]                         info <- base::paste(info, collapse = "; ")
[10:24:33.781]                         if (!has_future) {
[10:24:33.781]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:33.781]                             info)
[10:24:33.781]                         }
[10:24:33.781]                         else {
[10:24:33.781]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:33.781]                             info, version)
[10:24:33.781]                         }
[10:24:33.781]                         base::stop(msg)
[10:24:33.781]                       }
[10:24:33.781]                     })
[10:24:33.781]                   }
[10:24:33.781]                   options(future.plan = NULL)
[10:24:33.781]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:33.781]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:33.781]                 }
[10:24:33.781]                 ...future.workdir <- getwd()
[10:24:33.781]             }
[10:24:33.781]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:33.781]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:33.781]         }
[10:24:33.781]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:33.781]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:33.781]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:33.781]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:33.781]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:33.781]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:33.781]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:33.781]             base::names(...future.oldOptions))
[10:24:33.781]     }
[10:24:33.781]     if (TRUE) {
[10:24:33.781]     }
[10:24:33.781]     else {
[10:24:33.781]         if (NA) {
[10:24:33.781]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:33.781]                 open = "w")
[10:24:33.781]         }
[10:24:33.781]         else {
[10:24:33.781]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:33.781]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:33.781]         }
[10:24:33.781]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:33.781]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:33.781]             base::sink(type = "output", split = FALSE)
[10:24:33.781]             base::close(...future.stdout)
[10:24:33.781]         }, add = TRUE)
[10:24:33.781]     }
[10:24:33.781]     ...future.frame <- base::sys.nframe()
[10:24:33.781]     ...future.conditions <- base::list()
[10:24:33.781]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:33.781]     if (FALSE) {
[10:24:33.781]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:33.781]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:33.781]     }
[10:24:33.781]     ...future.result <- base::tryCatch({
[10:24:33.781]         base::withCallingHandlers({
[10:24:33.781]             ...future.value <- base::withVisible(base::local({
[10:24:33.781]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:33.781]                 if (!identical(...future.globals.maxSize.org, 
[10:24:33.781]                   ...future.globals.maxSize)) {
[10:24:33.781]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:33.781]                   on.exit(options(oopts), add = TRUE)
[10:24:33.781]                 }
[10:24:33.781]                 {
[10:24:33.781]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:33.781]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:24:33.781]                     USE.NAMES = FALSE)
[10:24:33.781]                   do.call(mapply, args = args)
[10:24:33.781]                 }
[10:24:33.781]             }))
[10:24:33.781]             future::FutureResult(value = ...future.value$value, 
[10:24:33.781]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:33.781]                   ...future.rng), globalenv = if (FALSE) 
[10:24:33.781]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:33.781]                     ...future.globalenv.names))
[10:24:33.781]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:33.781]         }, condition = base::local({
[10:24:33.781]             c <- base::c
[10:24:33.781]             inherits <- base::inherits
[10:24:33.781]             invokeRestart <- base::invokeRestart
[10:24:33.781]             length <- base::length
[10:24:33.781]             list <- base::list
[10:24:33.781]             seq.int <- base::seq.int
[10:24:33.781]             signalCondition <- base::signalCondition
[10:24:33.781]             sys.calls <- base::sys.calls
[10:24:33.781]             `[[` <- base::`[[`
[10:24:33.781]             `+` <- base::`+`
[10:24:33.781]             `<<-` <- base::`<<-`
[10:24:33.781]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:33.781]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:33.781]                   3L)]
[10:24:33.781]             }
[10:24:33.781]             function(cond) {
[10:24:33.781]                 is_error <- inherits(cond, "error")
[10:24:33.781]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:33.781]                   NULL)
[10:24:33.781]                 if (is_error) {
[10:24:33.781]                   sessionInformation <- function() {
[10:24:33.781]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:33.781]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:33.781]                       search = base::search(), system = base::Sys.info())
[10:24:33.781]                   }
[10:24:33.781]                   ...future.conditions[[length(...future.conditions) + 
[10:24:33.781]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:33.781]                     cond$call), session = sessionInformation(), 
[10:24:33.781]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:33.781]                   signalCondition(cond)
[10:24:33.781]                 }
[10:24:33.781]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:33.781]                 "immediateCondition"))) {
[10:24:33.781]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:33.781]                   ...future.conditions[[length(...future.conditions) + 
[10:24:33.781]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:33.781]                   if (TRUE && !signal) {
[10:24:33.781]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:33.781]                     {
[10:24:33.781]                       inherits <- base::inherits
[10:24:33.781]                       invokeRestart <- base::invokeRestart
[10:24:33.781]                       is.null <- base::is.null
[10:24:33.781]                       muffled <- FALSE
[10:24:33.781]                       if (inherits(cond, "message")) {
[10:24:33.781]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:33.781]                         if (muffled) 
[10:24:33.781]                           invokeRestart("muffleMessage")
[10:24:33.781]                       }
[10:24:33.781]                       else if (inherits(cond, "warning")) {
[10:24:33.781]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:33.781]                         if (muffled) 
[10:24:33.781]                           invokeRestart("muffleWarning")
[10:24:33.781]                       }
[10:24:33.781]                       else if (inherits(cond, "condition")) {
[10:24:33.781]                         if (!is.null(pattern)) {
[10:24:33.781]                           computeRestarts <- base::computeRestarts
[10:24:33.781]                           grepl <- base::grepl
[10:24:33.781]                           restarts <- computeRestarts(cond)
[10:24:33.781]                           for (restart in restarts) {
[10:24:33.781]                             name <- restart$name
[10:24:33.781]                             if (is.null(name)) 
[10:24:33.781]                               next
[10:24:33.781]                             if (!grepl(pattern, name)) 
[10:24:33.781]                               next
[10:24:33.781]                             invokeRestart(restart)
[10:24:33.781]                             muffled <- TRUE
[10:24:33.781]                             break
[10:24:33.781]                           }
[10:24:33.781]                         }
[10:24:33.781]                       }
[10:24:33.781]                       invisible(muffled)
[10:24:33.781]                     }
[10:24:33.781]                     muffleCondition(cond, pattern = "^muffle")
[10:24:33.781]                   }
[10:24:33.781]                 }
[10:24:33.781]                 else {
[10:24:33.781]                   if (TRUE) {
[10:24:33.781]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:33.781]                     {
[10:24:33.781]                       inherits <- base::inherits
[10:24:33.781]                       invokeRestart <- base::invokeRestart
[10:24:33.781]                       is.null <- base::is.null
[10:24:33.781]                       muffled <- FALSE
[10:24:33.781]                       if (inherits(cond, "message")) {
[10:24:33.781]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:33.781]                         if (muffled) 
[10:24:33.781]                           invokeRestart("muffleMessage")
[10:24:33.781]                       }
[10:24:33.781]                       else if (inherits(cond, "warning")) {
[10:24:33.781]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:33.781]                         if (muffled) 
[10:24:33.781]                           invokeRestart("muffleWarning")
[10:24:33.781]                       }
[10:24:33.781]                       else if (inherits(cond, "condition")) {
[10:24:33.781]                         if (!is.null(pattern)) {
[10:24:33.781]                           computeRestarts <- base::computeRestarts
[10:24:33.781]                           grepl <- base::grepl
[10:24:33.781]                           restarts <- computeRestarts(cond)
[10:24:33.781]                           for (restart in restarts) {
[10:24:33.781]                             name <- restart$name
[10:24:33.781]                             if (is.null(name)) 
[10:24:33.781]                               next
[10:24:33.781]                             if (!grepl(pattern, name)) 
[10:24:33.781]                               next
[10:24:33.781]                             invokeRestart(restart)
[10:24:33.781]                             muffled <- TRUE
[10:24:33.781]                             break
[10:24:33.781]                           }
[10:24:33.781]                         }
[10:24:33.781]                       }
[10:24:33.781]                       invisible(muffled)
[10:24:33.781]                     }
[10:24:33.781]                     muffleCondition(cond, pattern = "^muffle")
[10:24:33.781]                   }
[10:24:33.781]                 }
[10:24:33.781]             }
[10:24:33.781]         }))
[10:24:33.781]     }, error = function(ex) {
[10:24:33.781]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:33.781]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:33.781]                 ...future.rng), started = ...future.startTime, 
[10:24:33.781]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:33.781]             version = "1.8"), class = "FutureResult")
[10:24:33.781]     }, finally = {
[10:24:33.781]         if (!identical(...future.workdir, getwd())) 
[10:24:33.781]             setwd(...future.workdir)
[10:24:33.781]         {
[10:24:33.781]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:33.781]                 ...future.oldOptions$nwarnings <- NULL
[10:24:33.781]             }
[10:24:33.781]             base::options(...future.oldOptions)
[10:24:33.781]             if (.Platform$OS.type == "windows") {
[10:24:33.781]                 old_names <- names(...future.oldEnvVars)
[10:24:33.781]                 envs <- base::Sys.getenv()
[10:24:33.781]                 names <- names(envs)
[10:24:33.781]                 common <- intersect(names, old_names)
[10:24:33.781]                 added <- setdiff(names, old_names)
[10:24:33.781]                 removed <- setdiff(old_names, names)
[10:24:33.781]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:33.781]                   envs[common]]
[10:24:33.781]                 NAMES <- toupper(changed)
[10:24:33.781]                 args <- list()
[10:24:33.781]                 for (kk in seq_along(NAMES)) {
[10:24:33.781]                   name <- changed[[kk]]
[10:24:33.781]                   NAME <- NAMES[[kk]]
[10:24:33.781]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:33.781]                     next
[10:24:33.781]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:33.781]                 }
[10:24:33.781]                 NAMES <- toupper(added)
[10:24:33.781]                 for (kk in seq_along(NAMES)) {
[10:24:33.781]                   name <- added[[kk]]
[10:24:33.781]                   NAME <- NAMES[[kk]]
[10:24:33.781]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:33.781]                     next
[10:24:33.781]                   args[[name]] <- ""
[10:24:33.781]                 }
[10:24:33.781]                 NAMES <- toupper(removed)
[10:24:33.781]                 for (kk in seq_along(NAMES)) {
[10:24:33.781]                   name <- removed[[kk]]
[10:24:33.781]                   NAME <- NAMES[[kk]]
[10:24:33.781]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:33.781]                     next
[10:24:33.781]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:33.781]                 }
[10:24:33.781]                 if (length(args) > 0) 
[10:24:33.781]                   base::do.call(base::Sys.setenv, args = args)
[10:24:33.781]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:33.781]             }
[10:24:33.781]             else {
[10:24:33.781]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:33.781]             }
[10:24:33.781]             {
[10:24:33.781]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:33.781]                   0L) {
[10:24:33.781]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:33.781]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:33.781]                   base::options(opts)
[10:24:33.781]                 }
[10:24:33.781]                 {
[10:24:33.781]                   {
[10:24:33.781]                     NULL
[10:24:33.781]                     RNGkind("Mersenne-Twister")
[10:24:33.781]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:33.781]                       inherits = FALSE)
[10:24:33.781]                   }
[10:24:33.781]                   options(future.plan = NULL)
[10:24:33.781]                   if (is.na(NA_character_)) 
[10:24:33.781]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:33.781]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:33.781]                   future::plan(list(function (..., envir = parent.frame()) 
[10:24:33.781]                   {
[10:24:33.781]                     future <- SequentialFuture(..., envir = envir)
[10:24:33.781]                     if (!future$lazy) 
[10:24:33.781]                       future <- run(future)
[10:24:33.781]                     invisible(future)
[10:24:33.781]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:33.781]                 }
[10:24:33.781]             }
[10:24:33.781]         }
[10:24:33.781]     })
[10:24:33.781]     if (FALSE) {
[10:24:33.781]         base::sink(type = "output", split = FALSE)
[10:24:33.781]         if (NA) {
[10:24:33.781]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:33.781]         }
[10:24:33.781]         else {
[10:24:33.781]             ...future.result["stdout"] <- base::list(NULL)
[10:24:33.781]         }
[10:24:33.781]         base::close(...future.stdout)
[10:24:33.781]         ...future.stdout <- NULL
[10:24:33.781]     }
[10:24:33.781]     ...future.result$conditions <- ...future.conditions
[10:24:33.781]     ...future.result$finished <- base::Sys.time()
[10:24:33.781]     ...future.result
[10:24:33.781] }
[10:24:33.784] assign_globals() ...
[10:24:33.785] List of 5
[10:24:33.785]  $ ...future.FUN            :function (x, y)  
[10:24:33.785]  $ MoreArgs                 : NULL
[10:24:33.785]  $ ...future.elements_ii    :List of 2
[10:24:33.785]   ..$ :List of 2
[10:24:33.785]   .. ..$ : int 1
[10:24:33.785]   .. ..$ : int 0
[10:24:33.785]   ..$ :List of 2
[10:24:33.785]   .. ..$ : int 0
[10:24:33.785]   .. ..$ : int 1
[10:24:33.785]  $ ...future.seeds_ii       : NULL
[10:24:33.785]  $ ...future.globals.maxSize: NULL
[10:24:33.785]  - attr(*, "where")=List of 5
[10:24:33.785]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:33.785]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:24:33.785]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:33.785]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:33.785]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:33.785]  - attr(*, "resolved")= logi FALSE
[10:24:33.785]  - attr(*, "total_size")= num 6480
[10:24:33.785]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:33.785]  - attr(*, "already-done")= logi TRUE
[10:24:33.790] - reassign environment for ‘...future.FUN’
[10:24:33.790] - copied ‘...future.FUN’ to environment
[10:24:33.790] - copied ‘MoreArgs’ to environment
[10:24:33.790] - copied ‘...future.elements_ii’ to environment
[10:24:33.791] - copied ‘...future.seeds_ii’ to environment
[10:24:33.791] - copied ‘...future.globals.maxSize’ to environment
[10:24:33.791] assign_globals() ... done
[10:24:33.791] plan(): Setting new future strategy stack:
[10:24:33.791] List of future strategies:
[10:24:33.791] 1. sequential:
[10:24:33.791]    - args: function (..., envir = parent.frame())
[10:24:33.791]    - tweaked: FALSE
[10:24:33.791]    - call: NULL
[10:24:33.791] plan(): nbrOfWorkers() = 1
[10:24:34.293] plan(): Setting new future strategy stack:
[10:24:34.293] List of future strategies:
[10:24:34.293] 1. sequential:
[10:24:34.293]    - args: function (..., envir = parent.frame())
[10:24:34.293]    - tweaked: FALSE
[10:24:34.293]    - call: plan(strategy)
[10:24:34.294] plan(): nbrOfWorkers() = 1
[10:24:34.294] SequentialFuture started (and completed)
[10:24:34.294] - Launch lazy future ... done
[10:24:34.294] run() for ‘SequentialFuture’ ... done
[10:24:34.294] Created future:
[10:24:34.294] SequentialFuture:
[10:24:34.294] Label: ‘future_mapply-1’
[10:24:34.294] Expression:
[10:24:34.294] {
[10:24:34.294]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:34.294]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:34.294]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:34.294]         on.exit(options(oopts), add = TRUE)
[10:24:34.294]     }
[10:24:34.294]     {
[10:24:34.294]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:34.294]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:24:34.294]         do.call(mapply, args = args)
[10:24:34.294]     }
[10:24:34.294] }
[10:24:34.294] Lazy evaluation: FALSE
[10:24:34.294] Asynchronous evaluation: FALSE
[10:24:34.294] Local evaluation: TRUE
[10:24:34.294] Environment: R_GlobalEnv
[10:24:34.294] Capture standard output: NA
[10:24:34.294] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:34.294] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:34.294] Packages: <none>
[10:24:34.294] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:34.294] Resolved: TRUE
[10:24:34.294] Value: 224 bytes of class ‘list’
[10:24:34.294] Early signaling: FALSE
[10:24:34.294] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:34.294] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:34.295] Chunk #1 of 1 ... DONE
[10:24:34.296] Launching 1 futures (chunks) ... DONE
[10:24:34.296] Resolving 1 futures (chunks) ...
[10:24:34.296] resolve() on list ...
[10:24:34.296]  recursive: 0
[10:24:34.296]  length: 1
[10:24:34.296] 
[10:24:34.296] resolved() for ‘SequentialFuture’ ...
[10:24:34.296] - state: ‘finished’
[10:24:34.296] - run: TRUE
[10:24:34.296] - result: ‘FutureResult’
[10:24:34.297] resolved() for ‘SequentialFuture’ ... done
[10:24:34.297] Future #1
[10:24:34.297] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:34.297] - nx: 1
[10:24:34.297] - relay: TRUE
[10:24:34.297] - stdout: TRUE
[10:24:34.297] - signal: TRUE
[10:24:34.297] - resignal: FALSE
[10:24:34.297] - force: TRUE
[10:24:34.297] - relayed: [n=1] FALSE
[10:24:34.298] - queued futures: [n=1] FALSE
[10:24:34.298]  - until=1
[10:24:34.298]  - relaying element #1
[10:24:34.298] - relayed: [n=1] TRUE
[10:24:34.298] - queued futures: [n=1] TRUE
[10:24:34.298] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:34.298]  length: 0 (resolved future 1)
[10:24:34.298] Relaying remaining futures
[10:24:34.298] signalConditionsASAP(NULL, pos=0) ...
[10:24:34.299] - nx: 1
[10:24:34.299] - relay: TRUE
[10:24:34.299] - stdout: TRUE
[10:24:34.299] - signal: TRUE
[10:24:34.299] - resignal: FALSE
[10:24:34.299] - force: TRUE
[10:24:34.299] - relayed: [n=1] TRUE
[10:24:34.299] - queued futures: [n=1] TRUE
 - flush all
[10:24:34.299] - relayed: [n=1] TRUE
[10:24:34.299] - queued futures: [n=1] TRUE
[10:24:34.299] signalConditionsASAP(NULL, pos=0) ... done
[10:24:34.300] resolve() on list ... DONE
[10:24:34.300]  - Number of value chunks collected: 1
[10:24:34.300] Resolving 1 futures (chunks) ... DONE
[10:24:34.300] Reducing values from 1 chunks ...
[10:24:34.300]  - Number of values collected after concatenation: 2
[10:24:34.300]  - Number of values expected: 2
[10:24:34.300] Reducing values from 1 chunks ... DONE
[10:24:34.300] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('sequential') ... DONE
* plan('multicore') ...
[10:24:34.301] plan(): Setting new future strategy stack:
[10:24:34.301] List of future strategies:
[10:24:34.301] 1. multicore:
[10:24:34.301]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:34.301]    - tweaked: FALSE
[10:24:34.301]    - call: plan(strategy)
[10:24:34.305] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[10:24:34.305] future_lapply() ...
[10:24:34.309] Number of chunks: 1
[10:24:34.309] getGlobalsAndPackagesXApply() ...
[10:24:34.309]  - future.globals: TRUE
[10:24:34.309] getGlobalsAndPackages() ...
[10:24:34.309] Searching for globals...
[10:24:34.311] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:24:34.311] Searching for globals ... DONE
[10:24:34.311] Resolving globals: FALSE
[10:24:34.311] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[10:24:34.312] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[10:24:34.312] - globals: [1] ‘FUN’
[10:24:34.312] 
[10:24:34.312] getGlobalsAndPackages() ... DONE
[10:24:34.312]  - globals found/used: [n=1] ‘FUN’
[10:24:34.312]  - needed namespaces: [n=0] 
[10:24:34.312] Finding globals ... DONE
[10:24:34.312]  - use_args: TRUE
[10:24:34.312]  - Getting '...' globals ...
[10:24:34.313] resolve() on list ...
[10:24:34.315]  recursive: 0
[10:24:34.315]  length: 1
[10:24:34.315]  elements: ‘...’
[10:24:34.315]  length: 0 (resolved future 1)
[10:24:34.315] resolve() on list ... DONE
[10:24:34.315]    - '...' content: [n=0] 
[10:24:34.315] List of 1
[10:24:34.315]  $ ...: list()
[10:24:34.315]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:34.315]  - attr(*, "where")=List of 1
[10:24:34.315]   ..$ ...:<environment: 0x55d2114384b8> 
[10:24:34.315]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:34.315]  - attr(*, "resolved")= logi TRUE
[10:24:34.315]  - attr(*, "total_size")= num NA
[10:24:34.318]  - Getting '...' globals ... DONE
[10:24:34.318] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:24:34.318] List of 2
[10:24:34.318]  $ ...future.FUN:function (x)  
[10:24:34.318]  $ ...          : list()
[10:24:34.318]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:34.318]  - attr(*, "where")=List of 2
[10:24:34.318]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:34.318]   ..$ ...          :<environment: 0x55d2114384b8> 
[10:24:34.318]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:34.318]  - attr(*, "resolved")= logi FALSE
[10:24:34.318]  - attr(*, "total_size")= num 4720
[10:24:34.321] Packages to be attached in all futures: [n=0] 
[10:24:34.321] getGlobalsAndPackagesXApply() ... DONE
[10:24:34.321] Number of futures (= number of chunks): 1
[10:24:34.321] Launching 1 futures (chunks) ...
[10:24:34.321] Chunk #1 of 1 ...
[10:24:34.322]  - Finding globals in 'X' for chunk #1 ...
[10:24:34.322] getGlobalsAndPackages() ...
[10:24:34.322] Searching for globals...
[10:24:34.322] 
[10:24:34.322] Searching for globals ... DONE
[10:24:34.322] - globals: [0] <none>
[10:24:34.322] getGlobalsAndPackages() ... DONE
[10:24:34.322]    + additional globals found: [n=0] 
[10:24:34.323]    + additional namespaces needed: [n=0] 
[10:24:34.323]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:34.323]  - seeds: <none>
[10:24:34.323]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:34.323] getGlobalsAndPackages() ...
[10:24:34.323] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:34.323] Resolving globals: FALSE
[10:24:34.323] Tweak future expression to call with '...' arguments ...
[10:24:34.323] {
[10:24:34.323]     do.call(function(...) {
[10:24:34.323]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:34.323]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:34.323]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:34.323]             on.exit(options(oopts), add = TRUE)
[10:24:34.323]         }
[10:24:34.323]         {
[10:24:34.323]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:34.323]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:34.323]                 ...future.FUN(...future.X_jj, ...)
[10:24:34.323]             })
[10:24:34.323]         }
[10:24:34.323]     }, args = future.call.arguments)
[10:24:34.323] }
[10:24:34.324] Tweak future expression to call with '...' arguments ... DONE
[10:24:34.324] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:34.324] 
[10:24:34.324] getGlobalsAndPackages() ... DONE
[10:24:34.325] run() for ‘Future’ ...
[10:24:34.325] - state: ‘created’
[10:24:34.325] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:34.329] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:34.329] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:34.329]   - Field: ‘label’
[10:24:34.329]   - Field: ‘local’
[10:24:34.329]   - Field: ‘owner’
[10:24:34.329]   - Field: ‘envir’
[10:24:34.329]   - Field: ‘packages’
[10:24:34.329]   - Field: ‘gc’
[10:24:34.329]   - Field: ‘conditions’
[10:24:34.330]   - Field: ‘expr’
[10:24:34.330]   - Field: ‘uuid’
[10:24:34.330]   - Field: ‘seed’
[10:24:34.330]   - Field: ‘version’
[10:24:34.330]   - Field: ‘result’
[10:24:34.330]   - Field: ‘asynchronous’
[10:24:34.330]   - Field: ‘calls’
[10:24:34.330]   - Field: ‘globals’
[10:24:34.330]   - Field: ‘stdout’
[10:24:34.330]   - Field: ‘earlySignal’
[10:24:34.330]   - Field: ‘lazy’
[10:24:34.331]   - Field: ‘state’
[10:24:34.331] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:34.331] - Launch lazy future ...
[10:24:34.331] Packages needed by the future expression (n = 0): <none>
[10:24:34.331] Packages needed by future strategies (n = 0): <none>
[10:24:34.331] {
[10:24:34.331]     {
[10:24:34.331]         {
[10:24:34.331]             ...future.startTime <- base::Sys.time()
[10:24:34.331]             {
[10:24:34.331]                 {
[10:24:34.331]                   {
[10:24:34.331]                     base::local({
[10:24:34.331]                       has_future <- base::requireNamespace("future", 
[10:24:34.331]                         quietly = TRUE)
[10:24:34.331]                       if (has_future) {
[10:24:34.331]                         ns <- base::getNamespace("future")
[10:24:34.331]                         version <- ns[[".package"]][["version"]]
[10:24:34.331]                         if (is.null(version)) 
[10:24:34.331]                           version <- utils::packageVersion("future")
[10:24:34.331]                       }
[10:24:34.331]                       else {
[10:24:34.331]                         version <- NULL
[10:24:34.331]                       }
[10:24:34.331]                       if (!has_future || version < "1.8.0") {
[10:24:34.331]                         info <- base::c(r_version = base::gsub("R version ", 
[10:24:34.331]                           "", base::R.version$version.string), 
[10:24:34.331]                           platform = base::sprintf("%s (%s-bit)", 
[10:24:34.331]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:34.331]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:34.331]                             "release", "version")], collapse = " "), 
[10:24:34.331]                           hostname = base::Sys.info()[["nodename"]])
[10:24:34.331]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:24:34.331]                           info)
[10:24:34.331]                         info <- base::paste(info, collapse = "; ")
[10:24:34.331]                         if (!has_future) {
[10:24:34.331]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:34.331]                             info)
[10:24:34.331]                         }
[10:24:34.331]                         else {
[10:24:34.331]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:34.331]                             info, version)
[10:24:34.331]                         }
[10:24:34.331]                         base::stop(msg)
[10:24:34.331]                       }
[10:24:34.331]                     })
[10:24:34.331]                   }
[10:24:34.331]                   options(future.plan = NULL)
[10:24:34.331]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:34.331]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:34.331]                 }
[10:24:34.331]                 ...future.workdir <- getwd()
[10:24:34.331]             }
[10:24:34.331]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:34.331]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:34.331]         }
[10:24:34.331]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:34.331]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:34.331]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:34.331]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:34.331]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:34.331]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:34.331]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:34.331]             base::names(...future.oldOptions))
[10:24:34.331]     }
[10:24:34.331]     if (FALSE) {
[10:24:34.331]     }
[10:24:34.331]     else {
[10:24:34.331]         if (FALSE) {
[10:24:34.331]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:34.331]                 open = "w")
[10:24:34.331]         }
[10:24:34.331]         else {
[10:24:34.331]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:34.331]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:34.331]         }
[10:24:34.331]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:34.331]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:34.331]             base::sink(type = "output", split = FALSE)
[10:24:34.331]             base::close(...future.stdout)
[10:24:34.331]         }, add = TRUE)
[10:24:34.331]     }
[10:24:34.331]     ...future.frame <- base::sys.nframe()
[10:24:34.331]     ...future.conditions <- base::list()
[10:24:34.331]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:34.331]     if (FALSE) {
[10:24:34.331]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:34.331]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:34.331]     }
[10:24:34.331]     ...future.result <- base::tryCatch({
[10:24:34.331]         base::withCallingHandlers({
[10:24:34.331]             ...future.value <- base::withVisible(base::local({
[10:24:34.331]                 do.call(function(...) {
[10:24:34.331]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:34.331]                   if (!identical(...future.globals.maxSize.org, 
[10:24:34.331]                     ...future.globals.maxSize)) {
[10:24:34.331]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:34.331]                     on.exit(options(oopts), add = TRUE)
[10:24:34.331]                   }
[10:24:34.331]                   {
[10:24:34.331]                     lapply(seq_along(...future.elements_ii), 
[10:24:34.331]                       FUN = function(jj) {
[10:24:34.331]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:34.331]                         ...future.FUN(...future.X_jj, ...)
[10:24:34.331]                       })
[10:24:34.331]                   }
[10:24:34.331]                 }, args = future.call.arguments)
[10:24:34.331]             }))
[10:24:34.331]             future::FutureResult(value = ...future.value$value, 
[10:24:34.331]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:34.331]                   ...future.rng), globalenv = if (FALSE) 
[10:24:34.331]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:34.331]                     ...future.globalenv.names))
[10:24:34.331]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:34.331]         }, condition = base::local({
[10:24:34.331]             c <- base::c
[10:24:34.331]             inherits <- base::inherits
[10:24:34.331]             invokeRestart <- base::invokeRestart
[10:24:34.331]             length <- base::length
[10:24:34.331]             list <- base::list
[10:24:34.331]             seq.int <- base::seq.int
[10:24:34.331]             signalCondition <- base::signalCondition
[10:24:34.331]             sys.calls <- base::sys.calls
[10:24:34.331]             `[[` <- base::`[[`
[10:24:34.331]             `+` <- base::`+`
[10:24:34.331]             `<<-` <- base::`<<-`
[10:24:34.331]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:34.331]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:34.331]                   3L)]
[10:24:34.331]             }
[10:24:34.331]             function(cond) {
[10:24:34.331]                 is_error <- inherits(cond, "error")
[10:24:34.331]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:34.331]                   NULL)
[10:24:34.331]                 if (is_error) {
[10:24:34.331]                   sessionInformation <- function() {
[10:24:34.331]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:34.331]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:34.331]                       search = base::search(), system = base::Sys.info())
[10:24:34.331]                   }
[10:24:34.331]                   ...future.conditions[[length(...future.conditions) + 
[10:24:34.331]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:34.331]                     cond$call), session = sessionInformation(), 
[10:24:34.331]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:34.331]                   signalCondition(cond)
[10:24:34.331]                 }
[10:24:34.331]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:34.331]                 "immediateCondition"))) {
[10:24:34.331]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:34.331]                   ...future.conditions[[length(...future.conditions) + 
[10:24:34.331]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:34.331]                   if (TRUE && !signal) {
[10:24:34.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:34.331]                     {
[10:24:34.331]                       inherits <- base::inherits
[10:24:34.331]                       invokeRestart <- base::invokeRestart
[10:24:34.331]                       is.null <- base::is.null
[10:24:34.331]                       muffled <- FALSE
[10:24:34.331]                       if (inherits(cond, "message")) {
[10:24:34.331]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:34.331]                         if (muffled) 
[10:24:34.331]                           invokeRestart("muffleMessage")
[10:24:34.331]                       }
[10:24:34.331]                       else if (inherits(cond, "warning")) {
[10:24:34.331]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:34.331]                         if (muffled) 
[10:24:34.331]                           invokeRestart("muffleWarning")
[10:24:34.331]                       }
[10:24:34.331]                       else if (inherits(cond, "condition")) {
[10:24:34.331]                         if (!is.null(pattern)) {
[10:24:34.331]                           computeRestarts <- base::computeRestarts
[10:24:34.331]                           grepl <- base::grepl
[10:24:34.331]                           restarts <- computeRestarts(cond)
[10:24:34.331]                           for (restart in restarts) {
[10:24:34.331]                             name <- restart$name
[10:24:34.331]                             if (is.null(name)) 
[10:24:34.331]                               next
[10:24:34.331]                             if (!grepl(pattern, name)) 
[10:24:34.331]                               next
[10:24:34.331]                             invokeRestart(restart)
[10:24:34.331]                             muffled <- TRUE
[10:24:34.331]                             break
[10:24:34.331]                           }
[10:24:34.331]                         }
[10:24:34.331]                       }
[10:24:34.331]                       invisible(muffled)
[10:24:34.331]                     }
[10:24:34.331]                     muffleCondition(cond, pattern = "^muffle")
[10:24:34.331]                   }
[10:24:34.331]                 }
[10:24:34.331]                 else {
[10:24:34.331]                   if (TRUE) {
[10:24:34.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:34.331]                     {
[10:24:34.331]                       inherits <- base::inherits
[10:24:34.331]                       invokeRestart <- base::invokeRestart
[10:24:34.331]                       is.null <- base::is.null
[10:24:34.331]                       muffled <- FALSE
[10:24:34.331]                       if (inherits(cond, "message")) {
[10:24:34.331]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:34.331]                         if (muffled) 
[10:24:34.331]                           invokeRestart("muffleMessage")
[10:24:34.331]                       }
[10:24:34.331]                       else if (inherits(cond, "warning")) {
[10:24:34.331]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:34.331]                         if (muffled) 
[10:24:34.331]                           invokeRestart("muffleWarning")
[10:24:34.331]                       }
[10:24:34.331]                       else if (inherits(cond, "condition")) {
[10:24:34.331]                         if (!is.null(pattern)) {
[10:24:34.331]                           computeRestarts <- base::computeRestarts
[10:24:34.331]                           grepl <- base::grepl
[10:24:34.331]                           restarts <- computeRestarts(cond)
[10:24:34.331]                           for (restart in restarts) {
[10:24:34.331]                             name <- restart$name
[10:24:34.331]                             if (is.null(name)) 
[10:24:34.331]                               next
[10:24:34.331]                             if (!grepl(pattern, name)) 
[10:24:34.331]                               next
[10:24:34.331]                             invokeRestart(restart)
[10:24:34.331]                             muffled <- TRUE
[10:24:34.331]                             break
[10:24:34.331]                           }
[10:24:34.331]                         }
[10:24:34.331]                       }
[10:24:34.331]                       invisible(muffled)
[10:24:34.331]                     }
[10:24:34.331]                     muffleCondition(cond, pattern = "^muffle")
[10:24:34.331]                   }
[10:24:34.331]                 }
[10:24:34.331]             }
[10:24:34.331]         }))
[10:24:34.331]     }, error = function(ex) {
[10:24:34.331]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:34.331]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:34.331]                 ...future.rng), started = ...future.startTime, 
[10:24:34.331]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:34.331]             version = "1.8"), class = "FutureResult")
[10:24:34.331]     }, finally = {
[10:24:34.331]         if (!identical(...future.workdir, getwd())) 
[10:24:34.331]             setwd(...future.workdir)
[10:24:34.331]         {
[10:24:34.331]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:34.331]                 ...future.oldOptions$nwarnings <- NULL
[10:24:34.331]             }
[10:24:34.331]             base::options(...future.oldOptions)
[10:24:34.331]             if (.Platform$OS.type == "windows") {
[10:24:34.331]                 old_names <- names(...future.oldEnvVars)
[10:24:34.331]                 envs <- base::Sys.getenv()
[10:24:34.331]                 names <- names(envs)
[10:24:34.331]                 common <- intersect(names, old_names)
[10:24:34.331]                 added <- setdiff(names, old_names)
[10:24:34.331]                 removed <- setdiff(old_names, names)
[10:24:34.331]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:34.331]                   envs[common]]
[10:24:34.331]                 NAMES <- toupper(changed)
[10:24:34.331]                 args <- list()
[10:24:34.331]                 for (kk in seq_along(NAMES)) {
[10:24:34.331]                   name <- changed[[kk]]
[10:24:34.331]                   NAME <- NAMES[[kk]]
[10:24:34.331]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:34.331]                     next
[10:24:34.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:34.331]                 }
[10:24:34.331]                 NAMES <- toupper(added)
[10:24:34.331]                 for (kk in seq_along(NAMES)) {
[10:24:34.331]                   name <- added[[kk]]
[10:24:34.331]                   NAME <- NAMES[[kk]]
[10:24:34.331]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:34.331]                     next
[10:24:34.331]                   args[[name]] <- ""
[10:24:34.331]                 }
[10:24:34.331]                 NAMES <- toupper(removed)
[10:24:34.331]                 for (kk in seq_along(NAMES)) {
[10:24:34.331]                   name <- removed[[kk]]
[10:24:34.331]                   NAME <- NAMES[[kk]]
[10:24:34.331]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:34.331]                     next
[10:24:34.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:34.331]                 }
[10:24:34.331]                 if (length(args) > 0) 
[10:24:34.331]                   base::do.call(base::Sys.setenv, args = args)
[10:24:34.331]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:34.331]             }
[10:24:34.331]             else {
[10:24:34.331]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:34.331]             }
[10:24:34.331]             {
[10:24:34.331]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:34.331]                   0L) {
[10:24:34.331]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:34.331]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:34.331]                   base::options(opts)
[10:24:34.331]                 }
[10:24:34.331]                 {
[10:24:34.331]                   {
[10:24:34.331]                     NULL
[10:24:34.331]                     RNGkind("Mersenne-Twister")
[10:24:34.331]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:34.331]                       inherits = FALSE)
[10:24:34.331]                   }
[10:24:34.331]                   options(future.plan = NULL)
[10:24:34.331]                   if (is.na(NA_character_)) 
[10:24:34.331]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:34.331]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:34.331]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:34.331]                     envir = parent.frame()) 
[10:24:34.331]                   {
[10:24:34.331]                     default_workers <- missing(workers)
[10:24:34.331]                     if (is.function(workers)) 
[10:24:34.331]                       workers <- workers()
[10:24:34.331]                     workers <- structure(as.integer(workers), 
[10:24:34.331]                       class = class(workers))
[10:24:34.331]                     stop_if_not(is.finite(workers), workers >= 
[10:24:34.331]                       1L)
[10:24:34.331]                     if ((workers == 1L && !inherits(workers, 
[10:24:34.331]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:34.331]                       if (default_workers) 
[10:24:34.331]                         supportsMulticore(warn = TRUE)
[10:24:34.331]                       return(sequential(..., envir = envir))
[10:24:34.331]                     }
[10:24:34.331]                     oopts <- options(mc.cores = workers)
[10:24:34.331]                     on.exit(options(oopts))
[10:24:34.331]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:34.331]                       envir = envir)
[10:24:34.331]                     if (!future$lazy) 
[10:24:34.331]                       future <- run(future)
[10:24:34.331]                     invisible(future)
[10:24:34.331]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:34.331]                 }
[10:24:34.331]             }
[10:24:34.331]         }
[10:24:34.331]     })
[10:24:34.331]     if (TRUE) {
[10:24:34.331]         base::sink(type = "output", split = FALSE)
[10:24:34.331]         if (FALSE) {
[10:24:34.331]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:34.331]         }
[10:24:34.331]         else {
[10:24:34.331]             ...future.result["stdout"] <- base::list(NULL)
[10:24:34.331]         }
[10:24:34.331]         base::close(...future.stdout)
[10:24:34.331]         ...future.stdout <- NULL
[10:24:34.331]     }
[10:24:34.331]     ...future.result$conditions <- ...future.conditions
[10:24:34.331]     ...future.result$finished <- base::Sys.time()
[10:24:34.331]     ...future.result
[10:24:34.331] }
[10:24:34.333] assign_globals() ...
[10:24:34.333] List of 5
[10:24:34.333]  $ ...future.FUN            :function (x)  
[10:24:34.333]  $ future.call.arguments    : list()
[10:24:34.333]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:34.333]  $ ...future.elements_ii    :List of 2
[10:24:34.333]   ..$ : int 1
[10:24:34.333]   ..$ : int 0
[10:24:34.333]  $ ...future.seeds_ii       : NULL
[10:24:34.333]  $ ...future.globals.maxSize: NULL
[10:24:34.333]  - attr(*, "where")=List of 5
[10:24:34.333]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:34.333]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:34.333]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:34.333]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:34.333]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:34.333]  - attr(*, "resolved")= logi FALSE
[10:24:34.333]  - attr(*, "total_size")= num 4720
[10:24:34.333]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:34.333]  - attr(*, "already-done")= logi TRUE
[10:24:34.338] - reassign environment for ‘...future.FUN’
[10:24:34.339] - copied ‘...future.FUN’ to environment
[10:24:34.339] - copied ‘future.call.arguments’ to environment
[10:24:34.339] - copied ‘...future.elements_ii’ to environment
[10:24:34.339] - copied ‘...future.seeds_ii’ to environment
[10:24:34.339] - copied ‘...future.globals.maxSize’ to environment
[10:24:34.339] assign_globals() ... done
[10:24:34.339] plan(): Setting new future strategy stack:
[10:24:34.339] List of future strategies:
[10:24:34.339] 1. sequential:
[10:24:34.339]    - args: function (..., envir = parent.frame())
[10:24:34.339]    - tweaked: FALSE
[10:24:34.339]    - call: NULL
[10:24:34.340] plan(): nbrOfWorkers() = 1
[10:24:34.841] plan(): Setting new future strategy stack:
[10:24:34.842] List of future strategies:
[10:24:34.842] 1. multicore:
[10:24:34.842]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:34.842]    - tweaked: FALSE
[10:24:34.842]    - call: plan(strategy)
[10:24:34.847] plan(): nbrOfWorkers() = 1
[10:24:34.848] SequentialFuture started (and completed)
[10:24:34.848] - Launch lazy future ... done
[10:24:34.848] run() for ‘SequentialFuture’ ... done
[10:24:34.848] Created future:
[10:24:34.848] SequentialFuture:
[10:24:34.848] Label: ‘future_lapply-1’
[10:24:34.848] Expression:
[10:24:34.848] {
[10:24:34.848]     do.call(function(...) {
[10:24:34.848]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:34.848]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:34.848]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:34.848]             on.exit(options(oopts), add = TRUE)
[10:24:34.848]         }
[10:24:34.848]         {
[10:24:34.848]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:34.848]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:34.848]                 ...future.FUN(...future.X_jj, ...)
[10:24:34.848]             })
[10:24:34.848]         }
[10:24:34.848]     }, args = future.call.arguments)
[10:24:34.848] }
[10:24:34.848] Lazy evaluation: FALSE
[10:24:34.848] Asynchronous evaluation: FALSE
[10:24:34.848] Local evaluation: TRUE
[10:24:34.848] Environment: R_GlobalEnv
[10:24:34.848] Capture standard output: FALSE
[10:24:34.848] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:34.848] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:34.848] Packages: <none>
[10:24:34.848] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:34.848] Resolved: TRUE
[10:24:34.848] Value: 112 bytes of class ‘list’
[10:24:34.848] Early signaling: FALSE
[10:24:34.848] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:34.848] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:34.849] Chunk #1 of 1 ... DONE
[10:24:34.849] Launching 1 futures (chunks) ... DONE
[10:24:34.849] Resolving 1 futures (chunks) ...
[10:24:34.849] resolve() on list ...
[10:24:34.850]  recursive: 0
[10:24:34.850]  length: 1
[10:24:34.850] 
[10:24:34.850] resolved() for ‘SequentialFuture’ ...
[10:24:34.850] - state: ‘finished’
[10:24:34.850] - run: TRUE
[10:24:34.850] - result: ‘FutureResult’
[10:24:34.850] resolved() for ‘SequentialFuture’ ... done
[10:24:34.850] Future #1
[10:24:34.850] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:34.851] - nx: 1
[10:24:34.851] - relay: TRUE
[10:24:34.851] - stdout: TRUE
[10:24:34.851] - signal: TRUE
[10:24:34.851] - resignal: FALSE
[10:24:34.851] - force: TRUE
[10:24:34.851] - relayed: [n=1] FALSE
[10:24:34.851] - queued futures: [n=1] FALSE
[10:24:34.851]  - until=1
[10:24:34.851]  - relaying element #1
[10:24:34.851] - relayed: [n=1] TRUE
[10:24:34.852] - queued futures: [n=1] TRUE
[10:24:34.852] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:34.852]  length: 0 (resolved future 1)
[10:24:34.852] Relaying remaining futures
[10:24:34.852] signalConditionsASAP(NULL, pos=0) ...
[10:24:34.852] - nx: 1
[10:24:34.852] - relay: TRUE
[10:24:34.852] - stdout: TRUE
[10:24:34.852] - signal: TRUE
[10:24:34.852] - resignal: FALSE
[10:24:34.852] - force: TRUE
[10:24:34.853] - relayed: [n=1] TRUE
[10:24:34.853] - queued futures: [n=1] TRUE
 - flush all
[10:24:34.853] - relayed: [n=1] TRUE
[10:24:34.853] - queued futures: [n=1] TRUE
[10:24:34.853] signalConditionsASAP(NULL, pos=0) ... done
[10:24:34.853] resolve() on list ... DONE
[10:24:34.853]  - Number of value chunks collected: 1
[10:24:34.853] Resolving 1 futures (chunks) ... DONE
[10:24:34.853] Reducing values from 1 chunks ...
[10:24:34.853]  - Number of values collected after concatenation: 2
[10:24:34.854]  - Number of values expected: 2
[10:24:34.854] Reducing values from 1 chunks ... DONE
[10:24:34.854] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[10:24:34.854] future_lapply() ...
[10:24:34.858] Number of chunks: 1
[10:24:34.858] getGlobalsAndPackagesXApply() ...
[10:24:34.858]  - future.globals: TRUE
[10:24:34.858] getGlobalsAndPackages() ...
[10:24:34.858] Searching for globals...
[10:24:34.860] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:24:34.860] Searching for globals ... DONE
[10:24:34.860] Resolving globals: FALSE
[10:24:34.860] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[10:24:34.861] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[10:24:34.861] - globals: [1] ‘FUN’
[10:24:34.861] 
[10:24:34.861] getGlobalsAndPackages() ... DONE
[10:24:34.861]  - globals found/used: [n=1] ‘FUN’
[10:24:34.861]  - needed namespaces: [n=0] 
[10:24:34.861] Finding globals ... DONE
[10:24:34.861]  - use_args: TRUE
[10:24:34.861]  - Getting '...' globals ...
[10:24:34.862] resolve() on list ...
[10:24:34.862]  recursive: 0
[10:24:34.862]  length: 1
[10:24:34.862]  elements: ‘...’
[10:24:34.862]  length: 0 (resolved future 1)
[10:24:34.862] resolve() on list ... DONE
[10:24:34.862]    - '...' content: [n=0] 
[10:24:34.862] List of 1
[10:24:34.862]  $ ...: list()
[10:24:34.862]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:34.862]  - attr(*, "where")=List of 1
[10:24:34.862]   ..$ ...:<environment: 0x55d20ffc2bd0> 
[10:24:34.862]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:34.862]  - attr(*, "resolved")= logi TRUE
[10:24:34.862]  - attr(*, "total_size")= num NA
[10:24:34.865]  - Getting '...' globals ... DONE
[10:24:34.865] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:24:34.865] List of 2
[10:24:34.865]  $ ...future.FUN:function (x)  
[10:24:34.865]  $ ...          : list()
[10:24:34.865]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:34.865]  - attr(*, "where")=List of 2
[10:24:34.865]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:34.865]   ..$ ...          :<environment: 0x55d20ffc2bd0> 
[10:24:34.865]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:34.865]  - attr(*, "resolved")= logi FALSE
[10:24:34.865]  - attr(*, "total_size")= num 4720
[10:24:34.868] Packages to be attached in all futures: [n=0] 
[10:24:34.868] getGlobalsAndPackagesXApply() ... DONE
[10:24:34.868] Number of futures (= number of chunks): 1
[10:24:34.868] Launching 1 futures (chunks) ...
[10:24:34.868] Chunk #1 of 1 ...
[10:24:34.868]  - Finding globals in 'X' for chunk #1 ...
[10:24:34.869] getGlobalsAndPackages() ...
[10:24:34.869] Searching for globals...
[10:24:34.869] 
[10:24:34.869] Searching for globals ... DONE
[10:24:34.869] - globals: [0] <none>
[10:24:34.869] getGlobalsAndPackages() ... DONE
[10:24:34.869]    + additional globals found: [n=0] 
[10:24:34.869]    + additional namespaces needed: [n=0] 
[10:24:34.869]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:34.870]  - seeds: <none>
[10:24:34.870]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:34.870] getGlobalsAndPackages() ...
[10:24:34.870] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:34.870] Resolving globals: FALSE
[10:24:34.870] Tweak future expression to call with '...' arguments ...
[10:24:34.870] {
[10:24:34.870]     do.call(function(...) {
[10:24:34.870]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:34.870]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:34.870]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:34.870]             on.exit(options(oopts), add = TRUE)
[10:24:34.870]         }
[10:24:34.870]         {
[10:24:34.870]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:34.870]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:34.870]                 ...future.FUN(...future.X_jj, ...)
[10:24:34.870]             })
[10:24:34.870]         }
[10:24:34.870]     }, args = future.call.arguments)
[10:24:34.870] }
[10:24:34.870] Tweak future expression to call with '...' arguments ... DONE
[10:24:34.872] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:34.872] 
[10:24:34.872] getGlobalsAndPackages() ... DONE
[10:24:34.873] run() for ‘Future’ ...
[10:24:34.873] - state: ‘created’
[10:24:34.873] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:34.876] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:34.876] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:34.877]   - Field: ‘label’
[10:24:34.877]   - Field: ‘local’
[10:24:34.877]   - Field: ‘owner’
[10:24:34.877]   - Field: ‘envir’
[10:24:34.877]   - Field: ‘packages’
[10:24:34.877]   - Field: ‘gc’
[10:24:34.877]   - Field: ‘conditions’
[10:24:34.877]   - Field: ‘expr’
[10:24:34.877]   - Field: ‘uuid’
[10:24:34.877]   - Field: ‘seed’
[10:24:34.878]   - Field: ‘version’
[10:24:34.878]   - Field: ‘result’
[10:24:34.878]   - Field: ‘asynchronous’
[10:24:34.878]   - Field: ‘calls’
[10:24:34.878]   - Field: ‘globals’
[10:24:34.878]   - Field: ‘stdout’
[10:24:34.878]   - Field: ‘earlySignal’
[10:24:34.878]   - Field: ‘lazy’
[10:24:34.878]   - Field: ‘state’
[10:24:34.878] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:34.879] - Launch lazy future ...
[10:24:34.879] Packages needed by the future expression (n = 0): <none>
[10:24:34.879] Packages needed by future strategies (n = 0): <none>
[10:24:34.879] {
[10:24:34.879]     {
[10:24:34.879]         {
[10:24:34.879]             ...future.startTime <- base::Sys.time()
[10:24:34.879]             {
[10:24:34.879]                 {
[10:24:34.879]                   {
[10:24:34.879]                     base::local({
[10:24:34.879]                       has_future <- base::requireNamespace("future", 
[10:24:34.879]                         quietly = TRUE)
[10:24:34.879]                       if (has_future) {
[10:24:34.879]                         ns <- base::getNamespace("future")
[10:24:34.879]                         version <- ns[[".package"]][["version"]]
[10:24:34.879]                         if (is.null(version)) 
[10:24:34.879]                           version <- utils::packageVersion("future")
[10:24:34.879]                       }
[10:24:34.879]                       else {
[10:24:34.879]                         version <- NULL
[10:24:34.879]                       }
[10:24:34.879]                       if (!has_future || version < "1.8.0") {
[10:24:34.879]                         info <- base::c(r_version = base::gsub("R version ", 
[10:24:34.879]                           "", base::R.version$version.string), 
[10:24:34.879]                           platform = base::sprintf("%s (%s-bit)", 
[10:24:34.879]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:34.879]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:34.879]                             "release", "version")], collapse = " "), 
[10:24:34.879]                           hostname = base::Sys.info()[["nodename"]])
[10:24:34.879]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:24:34.879]                           info)
[10:24:34.879]                         info <- base::paste(info, collapse = "; ")
[10:24:34.879]                         if (!has_future) {
[10:24:34.879]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:34.879]                             info)
[10:24:34.879]                         }
[10:24:34.879]                         else {
[10:24:34.879]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:34.879]                             info, version)
[10:24:34.879]                         }
[10:24:34.879]                         base::stop(msg)
[10:24:34.879]                       }
[10:24:34.879]                     })
[10:24:34.879]                   }
[10:24:34.879]                   options(future.plan = NULL)
[10:24:34.879]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:34.879]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:34.879]                 }
[10:24:34.879]                 ...future.workdir <- getwd()
[10:24:34.879]             }
[10:24:34.879]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:34.879]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:34.879]         }
[10:24:34.879]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:34.879]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:34.879]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:34.879]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:34.879]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:34.879]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:34.879]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:34.879]             base::names(...future.oldOptions))
[10:24:34.879]     }
[10:24:34.879]     if (FALSE) {
[10:24:34.879]     }
[10:24:34.879]     else {
[10:24:34.879]         if (TRUE) {
[10:24:34.879]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:34.879]                 open = "w")
[10:24:34.879]         }
[10:24:34.879]         else {
[10:24:34.879]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:34.879]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:34.879]         }
[10:24:34.879]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:34.879]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:34.879]             base::sink(type = "output", split = FALSE)
[10:24:34.879]             base::close(...future.stdout)
[10:24:34.879]         }, add = TRUE)
[10:24:34.879]     }
[10:24:34.879]     ...future.frame <- base::sys.nframe()
[10:24:34.879]     ...future.conditions <- base::list()
[10:24:34.879]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:34.879]     if (FALSE) {
[10:24:34.879]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:34.879]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:34.879]     }
[10:24:34.879]     ...future.result <- base::tryCatch({
[10:24:34.879]         base::withCallingHandlers({
[10:24:34.879]             ...future.value <- base::withVisible(base::local({
[10:24:34.879]                 do.call(function(...) {
[10:24:34.879]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:34.879]                   if (!identical(...future.globals.maxSize.org, 
[10:24:34.879]                     ...future.globals.maxSize)) {
[10:24:34.879]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:34.879]                     on.exit(options(oopts), add = TRUE)
[10:24:34.879]                   }
[10:24:34.879]                   {
[10:24:34.879]                     lapply(seq_along(...future.elements_ii), 
[10:24:34.879]                       FUN = function(jj) {
[10:24:34.879]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:34.879]                         ...future.FUN(...future.X_jj, ...)
[10:24:34.879]                       })
[10:24:34.879]                   }
[10:24:34.879]                 }, args = future.call.arguments)
[10:24:34.879]             }))
[10:24:34.879]             future::FutureResult(value = ...future.value$value, 
[10:24:34.879]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:34.879]                   ...future.rng), globalenv = if (FALSE) 
[10:24:34.879]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:34.879]                     ...future.globalenv.names))
[10:24:34.879]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:34.879]         }, condition = base::local({
[10:24:34.879]             c <- base::c
[10:24:34.879]             inherits <- base::inherits
[10:24:34.879]             invokeRestart <- base::invokeRestart
[10:24:34.879]             length <- base::length
[10:24:34.879]             list <- base::list
[10:24:34.879]             seq.int <- base::seq.int
[10:24:34.879]             signalCondition <- base::signalCondition
[10:24:34.879]             sys.calls <- base::sys.calls
[10:24:34.879]             `[[` <- base::`[[`
[10:24:34.879]             `+` <- base::`+`
[10:24:34.879]             `<<-` <- base::`<<-`
[10:24:34.879]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:34.879]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:34.879]                   3L)]
[10:24:34.879]             }
[10:24:34.879]             function(cond) {
[10:24:34.879]                 is_error <- inherits(cond, "error")
[10:24:34.879]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:34.879]                   NULL)
[10:24:34.879]                 if (is_error) {
[10:24:34.879]                   sessionInformation <- function() {
[10:24:34.879]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:34.879]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:34.879]                       search = base::search(), system = base::Sys.info())
[10:24:34.879]                   }
[10:24:34.879]                   ...future.conditions[[length(...future.conditions) + 
[10:24:34.879]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:34.879]                     cond$call), session = sessionInformation(), 
[10:24:34.879]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:34.879]                   signalCondition(cond)
[10:24:34.879]                 }
[10:24:34.879]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:34.879]                 "immediateCondition"))) {
[10:24:34.879]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:34.879]                   ...future.conditions[[length(...future.conditions) + 
[10:24:34.879]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:34.879]                   if (TRUE && !signal) {
[10:24:34.879]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:34.879]                     {
[10:24:34.879]                       inherits <- base::inherits
[10:24:34.879]                       invokeRestart <- base::invokeRestart
[10:24:34.879]                       is.null <- base::is.null
[10:24:34.879]                       muffled <- FALSE
[10:24:34.879]                       if (inherits(cond, "message")) {
[10:24:34.879]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:34.879]                         if (muffled) 
[10:24:34.879]                           invokeRestart("muffleMessage")
[10:24:34.879]                       }
[10:24:34.879]                       else if (inherits(cond, "warning")) {
[10:24:34.879]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:34.879]                         if (muffled) 
[10:24:34.879]                           invokeRestart("muffleWarning")
[10:24:34.879]                       }
[10:24:34.879]                       else if (inherits(cond, "condition")) {
[10:24:34.879]                         if (!is.null(pattern)) {
[10:24:34.879]                           computeRestarts <- base::computeRestarts
[10:24:34.879]                           grepl <- base::grepl
[10:24:34.879]                           restarts <- computeRestarts(cond)
[10:24:34.879]                           for (restart in restarts) {
[10:24:34.879]                             name <- restart$name
[10:24:34.879]                             if (is.null(name)) 
[10:24:34.879]                               next
[10:24:34.879]                             if (!grepl(pattern, name)) 
[10:24:34.879]                               next
[10:24:34.879]                             invokeRestart(restart)
[10:24:34.879]                             muffled <- TRUE
[10:24:34.879]                             break
[10:24:34.879]                           }
[10:24:34.879]                         }
[10:24:34.879]                       }
[10:24:34.879]                       invisible(muffled)
[10:24:34.879]                     }
[10:24:34.879]                     muffleCondition(cond, pattern = "^muffle")
[10:24:34.879]                   }
[10:24:34.879]                 }
[10:24:34.879]                 else {
[10:24:34.879]                   if (TRUE) {
[10:24:34.879]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:34.879]                     {
[10:24:34.879]                       inherits <- base::inherits
[10:24:34.879]                       invokeRestart <- base::invokeRestart
[10:24:34.879]                       is.null <- base::is.null
[10:24:34.879]                       muffled <- FALSE
[10:24:34.879]                       if (inherits(cond, "message")) {
[10:24:34.879]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:34.879]                         if (muffled) 
[10:24:34.879]                           invokeRestart("muffleMessage")
[10:24:34.879]                       }
[10:24:34.879]                       else if (inherits(cond, "warning")) {
[10:24:34.879]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:34.879]                         if (muffled) 
[10:24:34.879]                           invokeRestart("muffleWarning")
[10:24:34.879]                       }
[10:24:34.879]                       else if (inherits(cond, "condition")) {
[10:24:34.879]                         if (!is.null(pattern)) {
[10:24:34.879]                           computeRestarts <- base::computeRestarts
[10:24:34.879]                           grepl <- base::grepl
[10:24:34.879]                           restarts <- computeRestarts(cond)
[10:24:34.879]                           for (restart in restarts) {
[10:24:34.879]                             name <- restart$name
[10:24:34.879]                             if (is.null(name)) 
[10:24:34.879]                               next
[10:24:34.879]                             if (!grepl(pattern, name)) 
[10:24:34.879]                               next
[10:24:34.879]                             invokeRestart(restart)
[10:24:34.879]                             muffled <- TRUE
[10:24:34.879]                             break
[10:24:34.879]                           }
[10:24:34.879]                         }
[10:24:34.879]                       }
[10:24:34.879]                       invisible(muffled)
[10:24:34.879]                     }
[10:24:34.879]                     muffleCondition(cond, pattern = "^muffle")
[10:24:34.879]                   }
[10:24:34.879]                 }
[10:24:34.879]             }
[10:24:34.879]         }))
[10:24:34.879]     }, error = function(ex) {
[10:24:34.879]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:34.879]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:34.879]                 ...future.rng), started = ...future.startTime, 
[10:24:34.879]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:34.879]             version = "1.8"), class = "FutureResult")
[10:24:34.879]     }, finally = {
[10:24:34.879]         if (!identical(...future.workdir, getwd())) 
[10:24:34.879]             setwd(...future.workdir)
[10:24:34.879]         {
[10:24:34.879]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:34.879]                 ...future.oldOptions$nwarnings <- NULL
[10:24:34.879]             }
[10:24:34.879]             base::options(...future.oldOptions)
[10:24:34.879]             if (.Platform$OS.type == "windows") {
[10:24:34.879]                 old_names <- names(...future.oldEnvVars)
[10:24:34.879]                 envs <- base::Sys.getenv()
[10:24:34.879]                 names <- names(envs)
[10:24:34.879]                 common <- intersect(names, old_names)
[10:24:34.879]                 added <- setdiff(names, old_names)
[10:24:34.879]                 removed <- setdiff(old_names, names)
[10:24:34.879]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:34.879]                   envs[common]]
[10:24:34.879]                 NAMES <- toupper(changed)
[10:24:34.879]                 args <- list()
[10:24:34.879]                 for (kk in seq_along(NAMES)) {
[10:24:34.879]                   name <- changed[[kk]]
[10:24:34.879]                   NAME <- NAMES[[kk]]
[10:24:34.879]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:34.879]                     next
[10:24:34.879]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:34.879]                 }
[10:24:34.879]                 NAMES <- toupper(added)
[10:24:34.879]                 for (kk in seq_along(NAMES)) {
[10:24:34.879]                   name <- added[[kk]]
[10:24:34.879]                   NAME <- NAMES[[kk]]
[10:24:34.879]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:34.879]                     next
[10:24:34.879]                   args[[name]] <- ""
[10:24:34.879]                 }
[10:24:34.879]                 NAMES <- toupper(removed)
[10:24:34.879]                 for (kk in seq_along(NAMES)) {
[10:24:34.879]                   name <- removed[[kk]]
[10:24:34.879]                   NAME <- NAMES[[kk]]
[10:24:34.879]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:34.879]                     next
[10:24:34.879]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:34.879]                 }
[10:24:34.879]                 if (length(args) > 0) 
[10:24:34.879]                   base::do.call(base::Sys.setenv, args = args)
[10:24:34.879]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:34.879]             }
[10:24:34.879]             else {
[10:24:34.879]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:34.879]             }
[10:24:34.879]             {
[10:24:34.879]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:34.879]                   0L) {
[10:24:34.879]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:34.879]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:34.879]                   base::options(opts)
[10:24:34.879]                 }
[10:24:34.879]                 {
[10:24:34.879]                   {
[10:24:34.879]                     NULL
[10:24:34.879]                     RNGkind("Mersenne-Twister")
[10:24:34.879]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:34.879]                       inherits = FALSE)
[10:24:34.879]                   }
[10:24:34.879]                   options(future.plan = NULL)
[10:24:34.879]                   if (is.na(NA_character_)) 
[10:24:34.879]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:34.879]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:34.879]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:34.879]                     envir = parent.frame()) 
[10:24:34.879]                   {
[10:24:34.879]                     default_workers <- missing(workers)
[10:24:34.879]                     if (is.function(workers)) 
[10:24:34.879]                       workers <- workers()
[10:24:34.879]                     workers <- structure(as.integer(workers), 
[10:24:34.879]                       class = class(workers))
[10:24:34.879]                     stop_if_not(is.finite(workers), workers >= 
[10:24:34.879]                       1L)
[10:24:34.879]                     if ((workers == 1L && !inherits(workers, 
[10:24:34.879]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:34.879]                       if (default_workers) 
[10:24:34.879]                         supportsMulticore(warn = TRUE)
[10:24:34.879]                       return(sequential(..., envir = envir))
[10:24:34.879]                     }
[10:24:34.879]                     oopts <- options(mc.cores = workers)
[10:24:34.879]                     on.exit(options(oopts))
[10:24:34.879]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:34.879]                       envir = envir)
[10:24:34.879]                     if (!future$lazy) 
[10:24:34.879]                       future <- run(future)
[10:24:34.879]                     invisible(future)
[10:24:34.879]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:34.879]                 }
[10:24:34.879]             }
[10:24:34.879]         }
[10:24:34.879]     })
[10:24:34.879]     if (TRUE) {
[10:24:34.879]         base::sink(type = "output", split = FALSE)
[10:24:34.879]         if (TRUE) {
[10:24:34.879]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:34.879]         }
[10:24:34.879]         else {
[10:24:34.879]             ...future.result["stdout"] <- base::list(NULL)
[10:24:34.879]         }
[10:24:34.879]         base::close(...future.stdout)
[10:24:34.879]         ...future.stdout <- NULL
[10:24:34.879]     }
[10:24:34.879]     ...future.result$conditions <- ...future.conditions
[10:24:34.879]     ...future.result$finished <- base::Sys.time()
[10:24:34.879]     ...future.result
[10:24:34.879] }
[10:24:34.881] assign_globals() ...
[10:24:34.881] List of 5
[10:24:34.881]  $ ...future.FUN            :function (x)  
[10:24:34.881]  $ future.call.arguments    : list()
[10:24:34.881]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:34.881]  $ ...future.elements_ii    :List of 2
[10:24:34.881]   ..$ : int 1
[10:24:34.881]   ..$ : int 0
[10:24:34.881]  $ ...future.seeds_ii       : NULL
[10:24:34.881]  $ ...future.globals.maxSize: NULL
[10:24:34.881]  - attr(*, "where")=List of 5
[10:24:34.881]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:34.881]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:34.881]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:34.881]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:34.881]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:34.881]  - attr(*, "resolved")= logi FALSE
[10:24:34.881]  - attr(*, "total_size")= num 4720
[10:24:34.881]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:34.881]  - attr(*, "already-done")= logi TRUE
[10:24:34.886] - reassign environment for ‘...future.FUN’
[10:24:34.886] - copied ‘...future.FUN’ to environment
[10:24:34.886] - copied ‘future.call.arguments’ to environment
[10:24:34.886] - copied ‘...future.elements_ii’ to environment
[10:24:34.886] - copied ‘...future.seeds_ii’ to environment
[10:24:34.887] - copied ‘...future.globals.maxSize’ to environment
[10:24:34.887] assign_globals() ... done
[10:24:34.887] plan(): Setting new future strategy stack:
[10:24:34.887] List of future strategies:
[10:24:34.887] 1. sequential:
[10:24:34.887]    - args: function (..., envir = parent.frame())
[10:24:34.887]    - tweaked: FALSE
[10:24:34.887]    - call: NULL
[10:24:34.887] plan(): nbrOfWorkers() = 1
[10:24:35.389] plan(): Setting new future strategy stack:
[10:24:35.389] List of future strategies:
[10:24:35.389] 1. multicore:
[10:24:35.389]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:35.389]    - tweaked: FALSE
[10:24:35.389]    - call: plan(strategy)
[10:24:35.393] plan(): nbrOfWorkers() = 1
[10:24:35.393] SequentialFuture started (and completed)
[10:24:35.394] - Launch lazy future ... done
[10:24:35.394] run() for ‘SequentialFuture’ ... done
[10:24:35.394] Created future:
[10:24:35.394] SequentialFuture:
[10:24:35.394] Label: ‘future_lapply-1’
[10:24:35.394] Expression:
[10:24:35.394] {
[10:24:35.394]     do.call(function(...) {
[10:24:35.394]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:35.394]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:35.394]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:35.394]             on.exit(options(oopts), add = TRUE)
[10:24:35.394]         }
[10:24:35.394]         {
[10:24:35.394]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:35.394]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:35.394]                 ...future.FUN(...future.X_jj, ...)
[10:24:35.394]             })
[10:24:35.394]         }
[10:24:35.394]     }, args = future.call.arguments)
[10:24:35.394] }
[10:24:35.394] Lazy evaluation: FALSE
[10:24:35.394] Asynchronous evaluation: FALSE
[10:24:35.394] Local evaluation: TRUE
[10:24:35.394] Environment: R_GlobalEnv
[10:24:35.394] Capture standard output: TRUE
[10:24:35.394] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:35.394] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:35.394] Packages: <none>
[10:24:35.394] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:35.394] Resolved: TRUE
[10:24:35.394] Value: 112 bytes of class ‘list’
[10:24:35.394] Early signaling: FALSE
[10:24:35.394] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:35.394] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:35.395] Chunk #1 of 1 ... DONE
[10:24:35.395] Launching 1 futures (chunks) ... DONE
[10:24:35.396] Resolving 1 futures (chunks) ...
[10:24:35.396] resolve() on list ...
[10:24:35.396]  recursive: 0
[10:24:35.396]  length: 1
[10:24:35.396] 
[10:24:35.396] resolved() for ‘SequentialFuture’ ...
[10:24:35.396] - state: ‘finished’
[10:24:35.396] - run: TRUE
[10:24:35.396] - result: ‘FutureResult’
[10:24:35.396] resolved() for ‘SequentialFuture’ ... done
[10:24:35.397] Future #1
[10:24:35.397] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:35.397] - nx: 1
[10:24:35.397] - relay: TRUE
[10:24:35.397] - stdout: TRUE
[10:24:35.397] - signal: TRUE
[10:24:35.397] - resignal: FALSE
[10:24:35.397] - force: TRUE
[10:24:35.397] - relayed: [n=1] FALSE
[10:24:35.397] - queued futures: [n=1] FALSE
[10:24:35.398]  - until=1
[10:24:35.398]  - relaying element #1
[10:24:35.398] - relayed: [n=1] TRUE
[10:24:35.398] - queued futures: [n=1] TRUE
[10:24:35.398] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:35.398]  length: 0 (resolved future 1)
[10:24:35.398] Relaying remaining futures
[10:24:35.398] signalConditionsASAP(NULL, pos=0) ...
[10:24:35.398] - nx: 1
[10:24:35.399] - relay: TRUE
[10:24:35.399] - stdout: TRUE
[10:24:35.399] - signal: TRUE
[10:24:35.399] - resignal: FALSE
[10:24:35.399] - force: TRUE
[10:24:35.399] - relayed: [n=1] TRUE
[10:24:35.399] - queued futures: [n=1] TRUE
 - flush all
[10:24:35.399] - relayed: [n=1] TRUE
[10:24:35.399] - queued futures: [n=1] TRUE
[10:24:35.399] signalConditionsASAP(NULL, pos=0) ... done
[10:24:35.399] resolve() on list ... DONE
[10:24:35.400]  - Number of value chunks collected: 1
[10:24:35.400] Resolving 1 futures (chunks) ... DONE
[10:24:35.400] Reducing values from 1 chunks ...
[10:24:35.400]  - Number of values collected after concatenation: 2
[10:24:35.400]  - Number of values expected: 2
[10:24:35.400] Reducing values from 1 chunks ... DONE
[10:24:35.400] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[10:24:35.401] future_lapply() ...
[10:24:35.404] Number of chunks: 1
[10:24:35.407] getGlobalsAndPackagesXApply() ...
[10:24:35.407]  - future.globals: TRUE
[10:24:35.407] getGlobalsAndPackages() ...
[10:24:35.407] Searching for globals...
[10:24:35.408] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:24:35.408] Searching for globals ... DONE
[10:24:35.409] Resolving globals: FALSE
[10:24:35.409] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[10:24:35.409] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[10:24:35.409] - globals: [1] ‘FUN’
[10:24:35.410] 
[10:24:35.410] getGlobalsAndPackages() ... DONE
[10:24:35.410]  - globals found/used: [n=1] ‘FUN’
[10:24:35.410]  - needed namespaces: [n=0] 
[10:24:35.410] Finding globals ... DONE
[10:24:35.410]  - use_args: TRUE
[10:24:35.410]  - Getting '...' globals ...
[10:24:35.410] resolve() on list ...
[10:24:35.411]  recursive: 0
[10:24:35.411]  length: 1
[10:24:35.411]  elements: ‘...’
[10:24:35.411]  length: 0 (resolved future 1)
[10:24:35.411] resolve() on list ... DONE
[10:24:35.411]    - '...' content: [n=0] 
[10:24:35.411] List of 1
[10:24:35.411]  $ ...: list()
[10:24:35.411]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:35.411]  - attr(*, "where")=List of 1
[10:24:35.411]   ..$ ...:<environment: 0x55d2118171c0> 
[10:24:35.411]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:35.411]  - attr(*, "resolved")= logi TRUE
[10:24:35.411]  - attr(*, "total_size")= num NA
[10:24:35.414]  - Getting '...' globals ... DONE
[10:24:35.414] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:24:35.414] List of 2
[10:24:35.414]  $ ...future.FUN:function (x)  
[10:24:35.414]  $ ...          : list()
[10:24:35.414]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:35.414]  - attr(*, "where")=List of 2
[10:24:35.414]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:35.414]   ..$ ...          :<environment: 0x55d2118171c0> 
[10:24:35.414]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:35.414]  - attr(*, "resolved")= logi FALSE
[10:24:35.414]  - attr(*, "total_size")= num 4720
[10:24:35.417] Packages to be attached in all futures: [n=0] 
[10:24:35.417] getGlobalsAndPackagesXApply() ... DONE
[10:24:35.417] Number of futures (= number of chunks): 1
[10:24:35.417] Launching 1 futures (chunks) ...
[10:24:35.417] Chunk #1 of 1 ...
[10:24:35.417]  - Finding globals in 'X' for chunk #1 ...
[10:24:35.418] getGlobalsAndPackages() ...
[10:24:35.418] Searching for globals...
[10:24:35.418] 
[10:24:35.418] Searching for globals ... DONE
[10:24:35.418] - globals: [0] <none>
[10:24:35.418] getGlobalsAndPackages() ... DONE
[10:24:35.418]    + additional globals found: [n=0] 
[10:24:35.418]    + additional namespaces needed: [n=0] 
[10:24:35.418]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:35.419]  - seeds: <none>
[10:24:35.419]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:35.419] getGlobalsAndPackages() ...
[10:24:35.419] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:35.419] Resolving globals: FALSE
[10:24:35.419] Tweak future expression to call with '...' arguments ...
[10:24:35.419] {
[10:24:35.419]     do.call(function(...) {
[10:24:35.419]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:35.419]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:35.419]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:35.419]             on.exit(options(oopts), add = TRUE)
[10:24:35.419]         }
[10:24:35.419]         {
[10:24:35.419]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:35.419]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:35.419]                 ...future.FUN(...future.X_jj, ...)
[10:24:35.419]             })
[10:24:35.419]         }
[10:24:35.419]     }, args = future.call.arguments)
[10:24:35.419] }
[10:24:35.419] Tweak future expression to call with '...' arguments ... DONE
[10:24:35.420] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:35.420] 
[10:24:35.420] getGlobalsAndPackages() ... DONE
[10:24:35.420] run() for ‘Future’ ...
[10:24:35.420] - state: ‘created’
[10:24:35.420] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:35.424] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:35.424] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:35.424]   - Field: ‘label’
[10:24:35.424]   - Field: ‘local’
[10:24:35.424]   - Field: ‘owner’
[10:24:35.424]   - Field: ‘envir’
[10:24:35.425]   - Field: ‘packages’
[10:24:35.425]   - Field: ‘gc’
[10:24:35.425]   - Field: ‘conditions’
[10:24:35.425]   - Field: ‘expr’
[10:24:35.425]   - Field: ‘uuid’
[10:24:35.425]   - Field: ‘seed’
[10:24:35.425]   - Field: ‘version’
[10:24:35.425]   - Field: ‘result’
[10:24:35.425]   - Field: ‘asynchronous’
[10:24:35.425]   - Field: ‘calls’
[10:24:35.426]   - Field: ‘globals’
[10:24:35.426]   - Field: ‘stdout’
[10:24:35.426]   - Field: ‘earlySignal’
[10:24:35.426]   - Field: ‘lazy’
[10:24:35.426]   - Field: ‘state’
[10:24:35.426] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:35.426] - Launch lazy future ...
[10:24:35.426] Packages needed by the future expression (n = 0): <none>
[10:24:35.426] Packages needed by future strategies (n = 0): <none>
[10:24:35.427] {
[10:24:35.427]     {
[10:24:35.427]         {
[10:24:35.427]             ...future.startTime <- base::Sys.time()
[10:24:35.427]             {
[10:24:35.427]                 {
[10:24:35.427]                   {
[10:24:35.427]                     base::local({
[10:24:35.427]                       has_future <- base::requireNamespace("future", 
[10:24:35.427]                         quietly = TRUE)
[10:24:35.427]                       if (has_future) {
[10:24:35.427]                         ns <- base::getNamespace("future")
[10:24:35.427]                         version <- ns[[".package"]][["version"]]
[10:24:35.427]                         if (is.null(version)) 
[10:24:35.427]                           version <- utils::packageVersion("future")
[10:24:35.427]                       }
[10:24:35.427]                       else {
[10:24:35.427]                         version <- NULL
[10:24:35.427]                       }
[10:24:35.427]                       if (!has_future || version < "1.8.0") {
[10:24:35.427]                         info <- base::c(r_version = base::gsub("R version ", 
[10:24:35.427]                           "", base::R.version$version.string), 
[10:24:35.427]                           platform = base::sprintf("%s (%s-bit)", 
[10:24:35.427]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:35.427]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:35.427]                             "release", "version")], collapse = " "), 
[10:24:35.427]                           hostname = base::Sys.info()[["nodename"]])
[10:24:35.427]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:24:35.427]                           info)
[10:24:35.427]                         info <- base::paste(info, collapse = "; ")
[10:24:35.427]                         if (!has_future) {
[10:24:35.427]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:35.427]                             info)
[10:24:35.427]                         }
[10:24:35.427]                         else {
[10:24:35.427]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:35.427]                             info, version)
[10:24:35.427]                         }
[10:24:35.427]                         base::stop(msg)
[10:24:35.427]                       }
[10:24:35.427]                     })
[10:24:35.427]                   }
[10:24:35.427]                   options(future.plan = NULL)
[10:24:35.427]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:35.427]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:35.427]                 }
[10:24:35.427]                 ...future.workdir <- getwd()
[10:24:35.427]             }
[10:24:35.427]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:35.427]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:35.427]         }
[10:24:35.427]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:35.427]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:35.427]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:35.427]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:35.427]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:35.427]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:35.427]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:35.427]             base::names(...future.oldOptions))
[10:24:35.427]     }
[10:24:35.427]     if (TRUE) {
[10:24:35.427]     }
[10:24:35.427]     else {
[10:24:35.427]         if (NA) {
[10:24:35.427]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:35.427]                 open = "w")
[10:24:35.427]         }
[10:24:35.427]         else {
[10:24:35.427]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:35.427]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:35.427]         }
[10:24:35.427]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:35.427]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:35.427]             base::sink(type = "output", split = FALSE)
[10:24:35.427]             base::close(...future.stdout)
[10:24:35.427]         }, add = TRUE)
[10:24:35.427]     }
[10:24:35.427]     ...future.frame <- base::sys.nframe()
[10:24:35.427]     ...future.conditions <- base::list()
[10:24:35.427]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:35.427]     if (FALSE) {
[10:24:35.427]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:35.427]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:35.427]     }
[10:24:35.427]     ...future.result <- base::tryCatch({
[10:24:35.427]         base::withCallingHandlers({
[10:24:35.427]             ...future.value <- base::withVisible(base::local({
[10:24:35.427]                 do.call(function(...) {
[10:24:35.427]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:35.427]                   if (!identical(...future.globals.maxSize.org, 
[10:24:35.427]                     ...future.globals.maxSize)) {
[10:24:35.427]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:35.427]                     on.exit(options(oopts), add = TRUE)
[10:24:35.427]                   }
[10:24:35.427]                   {
[10:24:35.427]                     lapply(seq_along(...future.elements_ii), 
[10:24:35.427]                       FUN = function(jj) {
[10:24:35.427]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:35.427]                         ...future.FUN(...future.X_jj, ...)
[10:24:35.427]                       })
[10:24:35.427]                   }
[10:24:35.427]                 }, args = future.call.arguments)
[10:24:35.427]             }))
[10:24:35.427]             future::FutureResult(value = ...future.value$value, 
[10:24:35.427]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:35.427]                   ...future.rng), globalenv = if (FALSE) 
[10:24:35.427]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:35.427]                     ...future.globalenv.names))
[10:24:35.427]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:35.427]         }, condition = base::local({
[10:24:35.427]             c <- base::c
[10:24:35.427]             inherits <- base::inherits
[10:24:35.427]             invokeRestart <- base::invokeRestart
[10:24:35.427]             length <- base::length
[10:24:35.427]             list <- base::list
[10:24:35.427]             seq.int <- base::seq.int
[10:24:35.427]             signalCondition <- base::signalCondition
[10:24:35.427]             sys.calls <- base::sys.calls
[10:24:35.427]             `[[` <- base::`[[`
[10:24:35.427]             `+` <- base::`+`
[10:24:35.427]             `<<-` <- base::`<<-`
[10:24:35.427]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:35.427]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:35.427]                   3L)]
[10:24:35.427]             }
[10:24:35.427]             function(cond) {
[10:24:35.427]                 is_error <- inherits(cond, "error")
[10:24:35.427]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:35.427]                   NULL)
[10:24:35.427]                 if (is_error) {
[10:24:35.427]                   sessionInformation <- function() {
[10:24:35.427]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:35.427]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:35.427]                       search = base::search(), system = base::Sys.info())
[10:24:35.427]                   }
[10:24:35.427]                   ...future.conditions[[length(...future.conditions) + 
[10:24:35.427]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:35.427]                     cond$call), session = sessionInformation(), 
[10:24:35.427]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:35.427]                   signalCondition(cond)
[10:24:35.427]                 }
[10:24:35.427]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:35.427]                 "immediateCondition"))) {
[10:24:35.427]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:35.427]                   ...future.conditions[[length(...future.conditions) + 
[10:24:35.427]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:35.427]                   if (TRUE && !signal) {
[10:24:35.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:35.427]                     {
[10:24:35.427]                       inherits <- base::inherits
[10:24:35.427]                       invokeRestart <- base::invokeRestart
[10:24:35.427]                       is.null <- base::is.null
[10:24:35.427]                       muffled <- FALSE
[10:24:35.427]                       if (inherits(cond, "message")) {
[10:24:35.427]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:35.427]                         if (muffled) 
[10:24:35.427]                           invokeRestart("muffleMessage")
[10:24:35.427]                       }
[10:24:35.427]                       else if (inherits(cond, "warning")) {
[10:24:35.427]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:35.427]                         if (muffled) 
[10:24:35.427]                           invokeRestart("muffleWarning")
[10:24:35.427]                       }
[10:24:35.427]                       else if (inherits(cond, "condition")) {
[10:24:35.427]                         if (!is.null(pattern)) {
[10:24:35.427]                           computeRestarts <- base::computeRestarts
[10:24:35.427]                           grepl <- base::grepl
[10:24:35.427]                           restarts <- computeRestarts(cond)
[10:24:35.427]                           for (restart in restarts) {
[10:24:35.427]                             name <- restart$name
[10:24:35.427]                             if (is.null(name)) 
[10:24:35.427]                               next
[10:24:35.427]                             if (!grepl(pattern, name)) 
[10:24:35.427]                               next
[10:24:35.427]                             invokeRestart(restart)
[10:24:35.427]                             muffled <- TRUE
[10:24:35.427]                             break
[10:24:35.427]                           }
[10:24:35.427]                         }
[10:24:35.427]                       }
[10:24:35.427]                       invisible(muffled)
[10:24:35.427]                     }
[10:24:35.427]                     muffleCondition(cond, pattern = "^muffle")
[10:24:35.427]                   }
[10:24:35.427]                 }
[10:24:35.427]                 else {
[10:24:35.427]                   if (TRUE) {
[10:24:35.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:35.427]                     {
[10:24:35.427]                       inherits <- base::inherits
[10:24:35.427]                       invokeRestart <- base::invokeRestart
[10:24:35.427]                       is.null <- base::is.null
[10:24:35.427]                       muffled <- FALSE
[10:24:35.427]                       if (inherits(cond, "message")) {
[10:24:35.427]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:35.427]                         if (muffled) 
[10:24:35.427]                           invokeRestart("muffleMessage")
[10:24:35.427]                       }
[10:24:35.427]                       else if (inherits(cond, "warning")) {
[10:24:35.427]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:35.427]                         if (muffled) 
[10:24:35.427]                           invokeRestart("muffleWarning")
[10:24:35.427]                       }
[10:24:35.427]                       else if (inherits(cond, "condition")) {
[10:24:35.427]                         if (!is.null(pattern)) {
[10:24:35.427]                           computeRestarts <- base::computeRestarts
[10:24:35.427]                           grepl <- base::grepl
[10:24:35.427]                           restarts <- computeRestarts(cond)
[10:24:35.427]                           for (restart in restarts) {
[10:24:35.427]                             name <- restart$name
[10:24:35.427]                             if (is.null(name)) 
[10:24:35.427]                               next
[10:24:35.427]                             if (!grepl(pattern, name)) 
[10:24:35.427]                               next
[10:24:35.427]                             invokeRestart(restart)
[10:24:35.427]                             muffled <- TRUE
[10:24:35.427]                             break
[10:24:35.427]                           }
[10:24:35.427]                         }
[10:24:35.427]                       }
[10:24:35.427]                       invisible(muffled)
[10:24:35.427]                     }
[10:24:35.427]                     muffleCondition(cond, pattern = "^muffle")
[10:24:35.427]                   }
[10:24:35.427]                 }
[10:24:35.427]             }
[10:24:35.427]         }))
[10:24:35.427]     }, error = function(ex) {
[10:24:35.427]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:35.427]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:35.427]                 ...future.rng), started = ...future.startTime, 
[10:24:35.427]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:35.427]             version = "1.8"), class = "FutureResult")
[10:24:35.427]     }, finally = {
[10:24:35.427]         if (!identical(...future.workdir, getwd())) 
[10:24:35.427]             setwd(...future.workdir)
[10:24:35.427]         {
[10:24:35.427]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:35.427]                 ...future.oldOptions$nwarnings <- NULL
[10:24:35.427]             }
[10:24:35.427]             base::options(...future.oldOptions)
[10:24:35.427]             if (.Platform$OS.type == "windows") {
[10:24:35.427]                 old_names <- names(...future.oldEnvVars)
[10:24:35.427]                 envs <- base::Sys.getenv()
[10:24:35.427]                 names <- names(envs)
[10:24:35.427]                 common <- intersect(names, old_names)
[10:24:35.427]                 added <- setdiff(names, old_names)
[10:24:35.427]                 removed <- setdiff(old_names, names)
[10:24:35.427]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:35.427]                   envs[common]]
[10:24:35.427]                 NAMES <- toupper(changed)
[10:24:35.427]                 args <- list()
[10:24:35.427]                 for (kk in seq_along(NAMES)) {
[10:24:35.427]                   name <- changed[[kk]]
[10:24:35.427]                   NAME <- NAMES[[kk]]
[10:24:35.427]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:35.427]                     next
[10:24:35.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:35.427]                 }
[10:24:35.427]                 NAMES <- toupper(added)
[10:24:35.427]                 for (kk in seq_along(NAMES)) {
[10:24:35.427]                   name <- added[[kk]]
[10:24:35.427]                   NAME <- NAMES[[kk]]
[10:24:35.427]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:35.427]                     next
[10:24:35.427]                   args[[name]] <- ""
[10:24:35.427]                 }
[10:24:35.427]                 NAMES <- toupper(removed)
[10:24:35.427]                 for (kk in seq_along(NAMES)) {
[10:24:35.427]                   name <- removed[[kk]]
[10:24:35.427]                   NAME <- NAMES[[kk]]
[10:24:35.427]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:35.427]                     next
[10:24:35.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:35.427]                 }
[10:24:35.427]                 if (length(args) > 0) 
[10:24:35.427]                   base::do.call(base::Sys.setenv, args = args)
[10:24:35.427]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:35.427]             }
[10:24:35.427]             else {
[10:24:35.427]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:35.427]             }
[10:24:35.427]             {
[10:24:35.427]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:35.427]                   0L) {
[10:24:35.427]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:35.427]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:35.427]                   base::options(opts)
[10:24:35.427]                 }
[10:24:35.427]                 {
[10:24:35.427]                   {
[10:24:35.427]                     NULL
[10:24:35.427]                     RNGkind("Mersenne-Twister")
[10:24:35.427]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:35.427]                       inherits = FALSE)
[10:24:35.427]                   }
[10:24:35.427]                   options(future.plan = NULL)
[10:24:35.427]                   if (is.na(NA_character_)) 
[10:24:35.427]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:35.427]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:35.427]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:35.427]                     envir = parent.frame()) 
[10:24:35.427]                   {
[10:24:35.427]                     default_workers <- missing(workers)
[10:24:35.427]                     if (is.function(workers)) 
[10:24:35.427]                       workers <- workers()
[10:24:35.427]                     workers <- structure(as.integer(workers), 
[10:24:35.427]                       class = class(workers))
[10:24:35.427]                     stop_if_not(is.finite(workers), workers >= 
[10:24:35.427]                       1L)
[10:24:35.427]                     if ((workers == 1L && !inherits(workers, 
[10:24:35.427]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:35.427]                       if (default_workers) 
[10:24:35.427]                         supportsMulticore(warn = TRUE)
[10:24:35.427]                       return(sequential(..., envir = envir))
[10:24:35.427]                     }
[10:24:35.427]                     oopts <- options(mc.cores = workers)
[10:24:35.427]                     on.exit(options(oopts))
[10:24:35.427]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:35.427]                       envir = envir)
[10:24:35.427]                     if (!future$lazy) 
[10:24:35.427]                       future <- run(future)
[10:24:35.427]                     invisible(future)
[10:24:35.427]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:35.427]                 }
[10:24:35.427]             }
[10:24:35.427]         }
[10:24:35.427]     })
[10:24:35.427]     if (FALSE) {
[10:24:35.427]         base::sink(type = "output", split = FALSE)
[10:24:35.427]         if (NA) {
[10:24:35.427]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:35.427]         }
[10:24:35.427]         else {
[10:24:35.427]             ...future.result["stdout"] <- base::list(NULL)
[10:24:35.427]         }
[10:24:35.427]         base::close(...future.stdout)
[10:24:35.427]         ...future.stdout <- NULL
[10:24:35.427]     }
[10:24:35.427]     ...future.result$conditions <- ...future.conditions
[10:24:35.427]     ...future.result$finished <- base::Sys.time()
[10:24:35.427]     ...future.result
[10:24:35.427] }
[10:24:35.429] assign_globals() ...
[10:24:35.429] List of 5
[10:24:35.429]  $ ...future.FUN            :function (x)  
[10:24:35.429]  $ future.call.arguments    : list()
[10:24:35.429]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:35.429]  $ ...future.elements_ii    :List of 2
[10:24:35.429]   ..$ : int 1
[10:24:35.429]   ..$ : int 0
[10:24:35.429]  $ ...future.seeds_ii       : NULL
[10:24:35.429]  $ ...future.globals.maxSize: NULL
[10:24:35.429]  - attr(*, "where")=List of 5
[10:24:35.429]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:35.429]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:35.429]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:35.429]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:35.429]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:35.429]  - attr(*, "resolved")= logi FALSE
[10:24:35.429]  - attr(*, "total_size")= num 4720
[10:24:35.429]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:35.429]  - attr(*, "already-done")= logi TRUE
[10:24:35.435] - reassign environment for ‘...future.FUN’
[10:24:35.435] - copied ‘...future.FUN’ to environment
[10:24:35.435] - copied ‘future.call.arguments’ to environment
[10:24:35.436] - copied ‘...future.elements_ii’ to environment
[10:24:35.436] - copied ‘...future.seeds_ii’ to environment
[10:24:35.436] - copied ‘...future.globals.maxSize’ to environment
[10:24:35.436] assign_globals() ... done
[10:24:35.436] plan(): Setting new future strategy stack:
[10:24:35.436] List of future strategies:
[10:24:35.436] 1. sequential:
[10:24:35.436]    - args: function (..., envir = parent.frame())
[10:24:35.436]    - tweaked: FALSE
[10:24:35.436]    - call: NULL
[10:24:35.437] plan(): nbrOfWorkers() = 1
[10:24:35.938] plan(): Setting new future strategy stack:
[10:24:35.938] List of future strategies:
[10:24:35.938] 1. multicore:
[10:24:35.938]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:35.938]    - tweaked: FALSE
[10:24:35.938]    - call: plan(strategy)
[10:24:35.942] plan(): nbrOfWorkers() = 1
[10:24:35.943] SequentialFuture started (and completed)
[10:24:35.943] - Launch lazy future ... done
[10:24:35.943] run() for ‘SequentialFuture’ ... done
[10:24:35.943] Created future:
[10:24:35.943] SequentialFuture:
[10:24:35.943] Label: ‘future_lapply-1’
[10:24:35.943] Expression:
[10:24:35.943] {
[10:24:35.943]     do.call(function(...) {
[10:24:35.943]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:35.943]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:35.943]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:35.943]             on.exit(options(oopts), add = TRUE)
[10:24:35.943]         }
[10:24:35.943]         {
[10:24:35.943]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:35.943]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:35.943]                 ...future.FUN(...future.X_jj, ...)
[10:24:35.943]             })
[10:24:35.943]         }
[10:24:35.943]     }, args = future.call.arguments)
[10:24:35.943] }
[10:24:35.943] Lazy evaluation: FALSE
[10:24:35.943] Asynchronous evaluation: FALSE
[10:24:35.943] Local evaluation: TRUE
[10:24:35.943] Environment: R_GlobalEnv
[10:24:35.943] Capture standard output: NA
[10:24:35.943] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:35.943] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:35.943] Packages: <none>
[10:24:35.943] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:35.943] Resolved: TRUE
[10:24:35.943] Value: 112 bytes of class ‘list’
[10:24:35.943] Early signaling: FALSE
[10:24:35.943] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:35.943] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:35.945] Chunk #1 of 1 ... DONE
[10:24:35.945] Launching 1 futures (chunks) ... DONE
[10:24:35.945] Resolving 1 futures (chunks) ...
[10:24:35.945] resolve() on list ...
[10:24:35.945]  recursive: 0
[10:24:35.945]  length: 1
[10:24:35.945] 
[10:24:35.945] resolved() for ‘SequentialFuture’ ...
[10:24:35.945] - state: ‘finished’
[10:24:35.946] - run: TRUE
[10:24:35.946] - result: ‘FutureResult’
[10:24:35.946] resolved() for ‘SequentialFuture’ ... done
[10:24:35.946] Future #1
[10:24:35.946] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:35.946] - nx: 1
[10:24:35.946] - relay: TRUE
[10:24:35.946] - stdout: TRUE
[10:24:35.946] - signal: TRUE
[10:24:35.946] - resignal: FALSE
[10:24:35.946] - force: TRUE
[10:24:35.947] - relayed: [n=1] FALSE
[10:24:35.947] - queued futures: [n=1] FALSE
[10:24:35.947]  - until=1
[10:24:35.947]  - relaying element #1
[10:24:35.947] - relayed: [n=1] TRUE
[10:24:35.947] - queued futures: [n=1] TRUE
[10:24:35.947] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:35.947]  length: 0 (resolved future 1)
[10:24:35.947] Relaying remaining futures
[10:24:35.948] signalConditionsASAP(NULL, pos=0) ...
[10:24:35.948] - nx: 1
[10:24:35.948] - relay: TRUE
[10:24:35.948] - stdout: TRUE
[10:24:35.948] - signal: TRUE
[10:24:35.948] - resignal: FALSE
[10:24:35.948] - force: TRUE
[10:24:35.948] - relayed: [n=1] TRUE
[10:24:35.948] - queued futures: [n=1] TRUE
 - flush all
[10:24:35.948] - relayed: [n=1] TRUE
[10:24:35.948] - queued futures: [n=1] TRUE
[10:24:35.948] signalConditionsASAP(NULL, pos=0) ... done
[10:24:35.949] resolve() on list ... DONE
[10:24:35.949]  - Number of value chunks collected: 1
[10:24:35.949] Resolving 1 futures (chunks) ... DONE
[10:24:35.949] Reducing values from 1 chunks ...
[10:24:35.949]  - Number of values collected after concatenation: 2
[10:24:35.949]  - Number of values expected: 2
[10:24:35.949] Reducing values from 1 chunks ... DONE
[10:24:35.949] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[10:24:35.950] future_mapply() ...
[10:24:35.953] Number of chunks: 1
[10:24:35.953] getGlobalsAndPackagesXApply() ...
[10:24:35.953]  - future.globals: TRUE
[10:24:35.953] getGlobalsAndPackages() ...
[10:24:35.953] Searching for globals...
[10:24:35.955] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:24:35.955] Searching for globals ... DONE
[10:24:35.955] Resolving globals: FALSE
[10:24:35.955] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[10:24:35.956] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[10:24:35.956] - globals: [1] ‘FUN’
[10:24:35.956] 
[10:24:35.956] getGlobalsAndPackages() ... DONE
[10:24:35.956]  - globals found/used: [n=1] ‘FUN’
[10:24:35.956]  - needed namespaces: [n=0] 
[10:24:35.956] Finding globals ... DONE
[10:24:35.957] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:24:35.957] List of 2
[10:24:35.957]  $ ...future.FUN:function (x, y)  
[10:24:35.957]  $ MoreArgs     : NULL
[10:24:35.957]  - attr(*, "where")=List of 2
[10:24:35.957]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:35.957]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:24:35.957]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:35.957]  - attr(*, "resolved")= logi FALSE
[10:24:35.957]  - attr(*, "total_size")= num NA
[10:24:35.959] Packages to be attached in all futures: [n=0] 
[10:24:35.959] getGlobalsAndPackagesXApply() ... DONE
[10:24:35.960] Number of futures (= number of chunks): 1
[10:24:35.960] Launching 1 futures (chunks) ...
[10:24:35.960] Chunk #1 of 1 ...
[10:24:35.960]  - Finding globals in '...' for chunk #1 ...
[10:24:35.960] getGlobalsAndPackages() ...
[10:24:35.960] Searching for globals...
[10:24:35.960] 
[10:24:35.961] Searching for globals ... DONE
[10:24:35.961] - globals: [0] <none>
[10:24:35.961] getGlobalsAndPackages() ... DONE
[10:24:35.961]    + additional globals found: [n=0] 
[10:24:35.961]    + additional namespaces needed: [n=0] 
[10:24:35.961]  - Finding globals in '...' for chunk #1 ... DONE
[10:24:35.961]  - seeds: <none>
[10:24:35.961]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:35.961] getGlobalsAndPackages() ...
[10:24:35.961] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:35.962] Resolving globals: FALSE
[10:24:35.964] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[10:24:35.964] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:24:35.964] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:35.964] 
[10:24:35.964] getGlobalsAndPackages() ... DONE
[10:24:35.965] run() for ‘Future’ ...
[10:24:35.965] - state: ‘created’
[10:24:35.965] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:35.968] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:35.969] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:35.969]   - Field: ‘label’
[10:24:35.969]   - Field: ‘local’
[10:24:35.969]   - Field: ‘owner’
[10:24:35.969]   - Field: ‘envir’
[10:24:35.969]   - Field: ‘packages’
[10:24:35.969]   - Field: ‘gc’
[10:24:35.969]   - Field: ‘conditions’
[10:24:35.969]   - Field: ‘expr’
[10:24:35.970]   - Field: ‘uuid’
[10:24:35.970]   - Field: ‘seed’
[10:24:35.970]   - Field: ‘version’
[10:24:35.970]   - Field: ‘result’
[10:24:35.970]   - Field: ‘asynchronous’
[10:24:35.970]   - Field: ‘calls’
[10:24:35.970]   - Field: ‘globals’
[10:24:35.970]   - Field: ‘stdout’
[10:24:35.970]   - Field: ‘earlySignal’
[10:24:35.970]   - Field: ‘lazy’
[10:24:35.970]   - Field: ‘state’
[10:24:35.971] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:35.971] - Launch lazy future ...
[10:24:35.971] Packages needed by the future expression (n = 0): <none>
[10:24:35.971] Packages needed by future strategies (n = 0): <none>
[10:24:35.971] {
[10:24:35.971]     {
[10:24:35.971]         {
[10:24:35.971]             ...future.startTime <- base::Sys.time()
[10:24:35.971]             {
[10:24:35.971]                 {
[10:24:35.971]                   {
[10:24:35.971]                     base::local({
[10:24:35.971]                       has_future <- base::requireNamespace("future", 
[10:24:35.971]                         quietly = TRUE)
[10:24:35.971]                       if (has_future) {
[10:24:35.971]                         ns <- base::getNamespace("future")
[10:24:35.971]                         version <- ns[[".package"]][["version"]]
[10:24:35.971]                         if (is.null(version)) 
[10:24:35.971]                           version <- utils::packageVersion("future")
[10:24:35.971]                       }
[10:24:35.971]                       else {
[10:24:35.971]                         version <- NULL
[10:24:35.971]                       }
[10:24:35.971]                       if (!has_future || version < "1.8.0") {
[10:24:35.971]                         info <- base::c(r_version = base::gsub("R version ", 
[10:24:35.971]                           "", base::R.version$version.string), 
[10:24:35.971]                           platform = base::sprintf("%s (%s-bit)", 
[10:24:35.971]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:35.971]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:35.971]                             "release", "version")], collapse = " "), 
[10:24:35.971]                           hostname = base::Sys.info()[["nodename"]])
[10:24:35.971]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:24:35.971]                           info)
[10:24:35.971]                         info <- base::paste(info, collapse = "; ")
[10:24:35.971]                         if (!has_future) {
[10:24:35.971]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:35.971]                             info)
[10:24:35.971]                         }
[10:24:35.971]                         else {
[10:24:35.971]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:35.971]                             info, version)
[10:24:35.971]                         }
[10:24:35.971]                         base::stop(msg)
[10:24:35.971]                       }
[10:24:35.971]                     })
[10:24:35.971]                   }
[10:24:35.971]                   options(future.plan = NULL)
[10:24:35.971]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:35.971]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:35.971]                 }
[10:24:35.971]                 ...future.workdir <- getwd()
[10:24:35.971]             }
[10:24:35.971]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:35.971]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:35.971]         }
[10:24:35.971]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:35.971]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:35.971]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:35.971]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:35.971]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:35.971]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:35.971]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:35.971]             base::names(...future.oldOptions))
[10:24:35.971]     }
[10:24:35.971]     if (FALSE) {
[10:24:35.971]     }
[10:24:35.971]     else {
[10:24:35.971]         if (FALSE) {
[10:24:35.971]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:35.971]                 open = "w")
[10:24:35.971]         }
[10:24:35.971]         else {
[10:24:35.971]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:35.971]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:35.971]         }
[10:24:35.971]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:35.971]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:35.971]             base::sink(type = "output", split = FALSE)
[10:24:35.971]             base::close(...future.stdout)
[10:24:35.971]         }, add = TRUE)
[10:24:35.971]     }
[10:24:35.971]     ...future.frame <- base::sys.nframe()
[10:24:35.971]     ...future.conditions <- base::list()
[10:24:35.971]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:35.971]     if (FALSE) {
[10:24:35.971]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:35.971]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:35.971]     }
[10:24:35.971]     ...future.result <- base::tryCatch({
[10:24:35.971]         base::withCallingHandlers({
[10:24:35.971]             ...future.value <- base::withVisible(base::local({
[10:24:35.971]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:35.971]                 if (!identical(...future.globals.maxSize.org, 
[10:24:35.971]                   ...future.globals.maxSize)) {
[10:24:35.971]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:35.971]                   on.exit(options(oopts), add = TRUE)
[10:24:35.971]                 }
[10:24:35.971]                 {
[10:24:35.971]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:35.971]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:24:35.971]                     USE.NAMES = FALSE)
[10:24:35.971]                   do.call(mapply, args = args)
[10:24:35.971]                 }
[10:24:35.971]             }))
[10:24:35.971]             future::FutureResult(value = ...future.value$value, 
[10:24:35.971]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:35.971]                   ...future.rng), globalenv = if (FALSE) 
[10:24:35.971]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:35.971]                     ...future.globalenv.names))
[10:24:35.971]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:35.971]         }, condition = base::local({
[10:24:35.971]             c <- base::c
[10:24:35.971]             inherits <- base::inherits
[10:24:35.971]             invokeRestart <- base::invokeRestart
[10:24:35.971]             length <- base::length
[10:24:35.971]             list <- base::list
[10:24:35.971]             seq.int <- base::seq.int
[10:24:35.971]             signalCondition <- base::signalCondition
[10:24:35.971]             sys.calls <- base::sys.calls
[10:24:35.971]             `[[` <- base::`[[`
[10:24:35.971]             `+` <- base::`+`
[10:24:35.971]             `<<-` <- base::`<<-`
[10:24:35.971]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:35.971]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:35.971]                   3L)]
[10:24:35.971]             }
[10:24:35.971]             function(cond) {
[10:24:35.971]                 is_error <- inherits(cond, "error")
[10:24:35.971]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:35.971]                   NULL)
[10:24:35.971]                 if (is_error) {
[10:24:35.971]                   sessionInformation <- function() {
[10:24:35.971]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:35.971]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:35.971]                       search = base::search(), system = base::Sys.info())
[10:24:35.971]                   }
[10:24:35.971]                   ...future.conditions[[length(...future.conditions) + 
[10:24:35.971]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:35.971]                     cond$call), session = sessionInformation(), 
[10:24:35.971]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:35.971]                   signalCondition(cond)
[10:24:35.971]                 }
[10:24:35.971]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:35.971]                 "immediateCondition"))) {
[10:24:35.971]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:35.971]                   ...future.conditions[[length(...future.conditions) + 
[10:24:35.971]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:35.971]                   if (TRUE && !signal) {
[10:24:35.971]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:35.971]                     {
[10:24:35.971]                       inherits <- base::inherits
[10:24:35.971]                       invokeRestart <- base::invokeRestart
[10:24:35.971]                       is.null <- base::is.null
[10:24:35.971]                       muffled <- FALSE
[10:24:35.971]                       if (inherits(cond, "message")) {
[10:24:35.971]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:35.971]                         if (muffled) 
[10:24:35.971]                           invokeRestart("muffleMessage")
[10:24:35.971]                       }
[10:24:35.971]                       else if (inherits(cond, "warning")) {
[10:24:35.971]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:35.971]                         if (muffled) 
[10:24:35.971]                           invokeRestart("muffleWarning")
[10:24:35.971]                       }
[10:24:35.971]                       else if (inherits(cond, "condition")) {
[10:24:35.971]                         if (!is.null(pattern)) {
[10:24:35.971]                           computeRestarts <- base::computeRestarts
[10:24:35.971]                           grepl <- base::grepl
[10:24:35.971]                           restarts <- computeRestarts(cond)
[10:24:35.971]                           for (restart in restarts) {
[10:24:35.971]                             name <- restart$name
[10:24:35.971]                             if (is.null(name)) 
[10:24:35.971]                               next
[10:24:35.971]                             if (!grepl(pattern, name)) 
[10:24:35.971]                               next
[10:24:35.971]                             invokeRestart(restart)
[10:24:35.971]                             muffled <- TRUE
[10:24:35.971]                             break
[10:24:35.971]                           }
[10:24:35.971]                         }
[10:24:35.971]                       }
[10:24:35.971]                       invisible(muffled)
[10:24:35.971]                     }
[10:24:35.971]                     muffleCondition(cond, pattern = "^muffle")
[10:24:35.971]                   }
[10:24:35.971]                 }
[10:24:35.971]                 else {
[10:24:35.971]                   if (TRUE) {
[10:24:35.971]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:35.971]                     {
[10:24:35.971]                       inherits <- base::inherits
[10:24:35.971]                       invokeRestart <- base::invokeRestart
[10:24:35.971]                       is.null <- base::is.null
[10:24:35.971]                       muffled <- FALSE
[10:24:35.971]                       if (inherits(cond, "message")) {
[10:24:35.971]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:35.971]                         if (muffled) 
[10:24:35.971]                           invokeRestart("muffleMessage")
[10:24:35.971]                       }
[10:24:35.971]                       else if (inherits(cond, "warning")) {
[10:24:35.971]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:35.971]                         if (muffled) 
[10:24:35.971]                           invokeRestart("muffleWarning")
[10:24:35.971]                       }
[10:24:35.971]                       else if (inherits(cond, "condition")) {
[10:24:35.971]                         if (!is.null(pattern)) {
[10:24:35.971]                           computeRestarts <- base::computeRestarts
[10:24:35.971]                           grepl <- base::grepl
[10:24:35.971]                           restarts <- computeRestarts(cond)
[10:24:35.971]                           for (restart in restarts) {
[10:24:35.971]                             name <- restart$name
[10:24:35.971]                             if (is.null(name)) 
[10:24:35.971]                               next
[10:24:35.971]                             if (!grepl(pattern, name)) 
[10:24:35.971]                               next
[10:24:35.971]                             invokeRestart(restart)
[10:24:35.971]                             muffled <- TRUE
[10:24:35.971]                             break
[10:24:35.971]                           }
[10:24:35.971]                         }
[10:24:35.971]                       }
[10:24:35.971]                       invisible(muffled)
[10:24:35.971]                     }
[10:24:35.971]                     muffleCondition(cond, pattern = "^muffle")
[10:24:35.971]                   }
[10:24:35.971]                 }
[10:24:35.971]             }
[10:24:35.971]         }))
[10:24:35.971]     }, error = function(ex) {
[10:24:35.971]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:35.971]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:35.971]                 ...future.rng), started = ...future.startTime, 
[10:24:35.971]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:35.971]             version = "1.8"), class = "FutureResult")
[10:24:35.971]     }, finally = {
[10:24:35.971]         if (!identical(...future.workdir, getwd())) 
[10:24:35.971]             setwd(...future.workdir)
[10:24:35.971]         {
[10:24:35.971]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:35.971]                 ...future.oldOptions$nwarnings <- NULL
[10:24:35.971]             }
[10:24:35.971]             base::options(...future.oldOptions)
[10:24:35.971]             if (.Platform$OS.type == "windows") {
[10:24:35.971]                 old_names <- names(...future.oldEnvVars)
[10:24:35.971]                 envs <- base::Sys.getenv()
[10:24:35.971]                 names <- names(envs)
[10:24:35.971]                 common <- intersect(names, old_names)
[10:24:35.971]                 added <- setdiff(names, old_names)
[10:24:35.971]                 removed <- setdiff(old_names, names)
[10:24:35.971]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:35.971]                   envs[common]]
[10:24:35.971]                 NAMES <- toupper(changed)
[10:24:35.971]                 args <- list()
[10:24:35.971]                 for (kk in seq_along(NAMES)) {
[10:24:35.971]                   name <- changed[[kk]]
[10:24:35.971]                   NAME <- NAMES[[kk]]
[10:24:35.971]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:35.971]                     next
[10:24:35.971]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:35.971]                 }
[10:24:35.971]                 NAMES <- toupper(added)
[10:24:35.971]                 for (kk in seq_along(NAMES)) {
[10:24:35.971]                   name <- added[[kk]]
[10:24:35.971]                   NAME <- NAMES[[kk]]
[10:24:35.971]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:35.971]                     next
[10:24:35.971]                   args[[name]] <- ""
[10:24:35.971]                 }
[10:24:35.971]                 NAMES <- toupper(removed)
[10:24:35.971]                 for (kk in seq_along(NAMES)) {
[10:24:35.971]                   name <- removed[[kk]]
[10:24:35.971]                   NAME <- NAMES[[kk]]
[10:24:35.971]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:35.971]                     next
[10:24:35.971]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:35.971]                 }
[10:24:35.971]                 if (length(args) > 0) 
[10:24:35.971]                   base::do.call(base::Sys.setenv, args = args)
[10:24:35.971]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:35.971]             }
[10:24:35.971]             else {
[10:24:35.971]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:35.971]             }
[10:24:35.971]             {
[10:24:35.971]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:35.971]                   0L) {
[10:24:35.971]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:35.971]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:35.971]                   base::options(opts)
[10:24:35.971]                 }
[10:24:35.971]                 {
[10:24:35.971]                   {
[10:24:35.971]                     NULL
[10:24:35.971]                     RNGkind("Mersenne-Twister")
[10:24:35.971]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:35.971]                       inherits = FALSE)
[10:24:35.971]                   }
[10:24:35.971]                   options(future.plan = NULL)
[10:24:35.971]                   if (is.na(NA_character_)) 
[10:24:35.971]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:35.971]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:35.971]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:35.971]                     envir = parent.frame()) 
[10:24:35.971]                   {
[10:24:35.971]                     default_workers <- missing(workers)
[10:24:35.971]                     if (is.function(workers)) 
[10:24:35.971]                       workers <- workers()
[10:24:35.971]                     workers <- structure(as.integer(workers), 
[10:24:35.971]                       class = class(workers))
[10:24:35.971]                     stop_if_not(is.finite(workers), workers >= 
[10:24:35.971]                       1L)
[10:24:35.971]                     if ((workers == 1L && !inherits(workers, 
[10:24:35.971]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:35.971]                       if (default_workers) 
[10:24:35.971]                         supportsMulticore(warn = TRUE)
[10:24:35.971]                       return(sequential(..., envir = envir))
[10:24:35.971]                     }
[10:24:35.971]                     oopts <- options(mc.cores = workers)
[10:24:35.971]                     on.exit(options(oopts))
[10:24:35.971]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:35.971]                       envir = envir)
[10:24:35.971]                     if (!future$lazy) 
[10:24:35.971]                       future <- run(future)
[10:24:35.971]                     invisible(future)
[10:24:35.971]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:35.971]                 }
[10:24:35.971]             }
[10:24:35.971]         }
[10:24:35.971]     })
[10:24:35.971]     if (TRUE) {
[10:24:35.971]         base::sink(type = "output", split = FALSE)
[10:24:35.971]         if (FALSE) {
[10:24:35.971]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:35.971]         }
[10:24:35.971]         else {
[10:24:35.971]             ...future.result["stdout"] <- base::list(NULL)
[10:24:35.971]         }
[10:24:35.971]         base::close(...future.stdout)
[10:24:35.971]         ...future.stdout <- NULL
[10:24:35.971]     }
[10:24:35.971]     ...future.result$conditions <- ...future.conditions
[10:24:35.971]     ...future.result$finished <- base::Sys.time()
[10:24:35.971]     ...future.result
[10:24:35.971] }
[10:24:35.973] assign_globals() ...
[10:24:35.973] List of 5
[10:24:35.973]  $ ...future.FUN            :function (x, y)  
[10:24:35.973]  $ MoreArgs                 : NULL
[10:24:35.973]  $ ...future.elements_ii    :List of 2
[10:24:35.973]   ..$ :List of 2
[10:24:35.973]   .. ..$ : int 1
[10:24:35.973]   .. ..$ : int 0
[10:24:35.973]   ..$ :List of 2
[10:24:35.973]   .. ..$ : int 0
[10:24:35.973]   .. ..$ : int 1
[10:24:35.973]  $ ...future.seeds_ii       : NULL
[10:24:35.973]  $ ...future.globals.maxSize: NULL
[10:24:35.973]  - attr(*, "where")=List of 5
[10:24:35.973]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:35.973]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:24:35.973]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:35.973]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:35.973]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:35.973]  - attr(*, "resolved")= logi FALSE
[10:24:35.973]  - attr(*, "total_size")= num 6480
[10:24:35.973]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:35.973]  - attr(*, "already-done")= logi TRUE
[10:24:35.979] - reassign environment for ‘...future.FUN’
[10:24:35.979] - copied ‘...future.FUN’ to environment
[10:24:35.979] - copied ‘MoreArgs’ to environment
[10:24:35.979] - copied ‘...future.elements_ii’ to environment
[10:24:35.979] - copied ‘...future.seeds_ii’ to environment
[10:24:35.979] - copied ‘...future.globals.maxSize’ to environment
[10:24:35.979] assign_globals() ... done
[10:24:35.980] plan(): Setting new future strategy stack:
[10:24:35.980] List of future strategies:
[10:24:35.980] 1. sequential:
[10:24:35.980]    - args: function (..., envir = parent.frame())
[10:24:35.980]    - tweaked: FALSE
[10:24:35.980]    - call: NULL
[10:24:35.980] plan(): nbrOfWorkers() = 1
[10:24:36.482] plan(): Setting new future strategy stack:
[10:24:36.482] List of future strategies:
[10:24:36.482] 1. multicore:
[10:24:36.482]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:36.482]    - tweaked: FALSE
[10:24:36.482]    - call: plan(strategy)
[10:24:36.486] plan(): nbrOfWorkers() = 1
[10:24:36.486] SequentialFuture started (and completed)
[10:24:36.486] - Launch lazy future ... done
[10:24:36.486] run() for ‘SequentialFuture’ ... done
[10:24:36.486] Created future:
[10:24:36.487] SequentialFuture:
[10:24:36.487] Label: ‘future_mapply-1’
[10:24:36.487] Expression:
[10:24:36.487] {
[10:24:36.487]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:36.487]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:36.487]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:36.487]         on.exit(options(oopts), add = TRUE)
[10:24:36.487]     }
[10:24:36.487]     {
[10:24:36.487]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:36.487]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:24:36.487]         do.call(mapply, args = args)
[10:24:36.487]     }
[10:24:36.487] }
[10:24:36.487] Lazy evaluation: FALSE
[10:24:36.487] Asynchronous evaluation: FALSE
[10:24:36.487] Local evaluation: TRUE
[10:24:36.487] Environment: R_GlobalEnv
[10:24:36.487] Capture standard output: FALSE
[10:24:36.487] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:36.487] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:36.487] Packages: <none>
[10:24:36.487] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:36.487] Resolved: TRUE
[10:24:36.487] Value: 224 bytes of class ‘list’
[10:24:36.487] Early signaling: FALSE
[10:24:36.487] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:36.487] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:36.488] Chunk #1 of 1 ... DONE
[10:24:36.488] Launching 1 futures (chunks) ... DONE
[10:24:36.488] Resolving 1 futures (chunks) ...
[10:24:36.488] resolve() on list ...
[10:24:36.488]  recursive: 0
[10:24:36.488]  length: 1
[10:24:36.488] 
[10:24:36.488] resolved() for ‘SequentialFuture’ ...
[10:24:36.488] - state: ‘finished’
[10:24:36.489] - run: TRUE
[10:24:36.489] - result: ‘FutureResult’
[10:24:36.489] resolved() for ‘SequentialFuture’ ... done
[10:24:36.489] Future #1
[10:24:36.489] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:36.489] - nx: 1
[10:24:36.489] - relay: TRUE
[10:24:36.489] - stdout: TRUE
[10:24:36.489] - signal: TRUE
[10:24:36.489] - resignal: FALSE
[10:24:36.490] - force: TRUE
[10:24:36.490] - relayed: [n=1] FALSE
[10:24:36.490] - queued futures: [n=1] FALSE
[10:24:36.490]  - until=1
[10:24:36.490]  - relaying element #1
[10:24:36.490] - relayed: [n=1] TRUE
[10:24:36.490] - queued futures: [n=1] TRUE
[10:24:36.490] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:36.490]  length: 0 (resolved future 1)
[10:24:36.490] Relaying remaining futures
[10:24:36.491] signalConditionsASAP(NULL, pos=0) ...
[10:24:36.491] - nx: 1
[10:24:36.491] - relay: TRUE
[10:24:36.491] - stdout: TRUE
[10:24:36.491] - signal: TRUE
[10:24:36.491] - resignal: FALSE
[10:24:36.491] - force: TRUE
[10:24:36.491] - relayed: [n=1] TRUE
[10:24:36.491] - queued futures: [n=1] TRUE
 - flush all
[10:24:36.491] - relayed: [n=1] TRUE
[10:24:36.491] - queued futures: [n=1] TRUE
[10:24:36.492] signalConditionsASAP(NULL, pos=0) ... done
[10:24:36.492] resolve() on list ... DONE
[10:24:36.492]  - Number of value chunks collected: 1
[10:24:36.492] Resolving 1 futures (chunks) ... DONE
[10:24:36.492] Reducing values from 1 chunks ...
[10:24:36.492]  - Number of values collected after concatenation: 2
[10:24:36.492]  - Number of values expected: 2
[10:24:36.492] Reducing values from 1 chunks ... DONE
[10:24:36.492] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[10:24:36.495] future_mapply() ...
[10:24:36.498] Number of chunks: 1
[10:24:36.498] getGlobalsAndPackagesXApply() ...
[10:24:36.498]  - future.globals: TRUE
[10:24:36.498] getGlobalsAndPackages() ...
[10:24:36.498] Searching for globals...
[10:24:36.500] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:24:36.500] Searching for globals ... DONE
[10:24:36.500] Resolving globals: FALSE
[10:24:36.501] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[10:24:36.501] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[10:24:36.501] - globals: [1] ‘FUN’
[10:24:36.501] 
[10:24:36.501] getGlobalsAndPackages() ... DONE
[10:24:36.501]  - globals found/used: [n=1] ‘FUN’
[10:24:36.501]  - needed namespaces: [n=0] 
[10:24:36.502] Finding globals ... DONE
[10:24:36.502] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:24:36.502] List of 2
[10:24:36.502]  $ ...future.FUN:function (x, y)  
[10:24:36.502]  $ MoreArgs     : NULL
[10:24:36.502]  - attr(*, "where")=List of 2
[10:24:36.502]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:36.502]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:24:36.502]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:36.502]  - attr(*, "resolved")= logi FALSE
[10:24:36.502]  - attr(*, "total_size")= num NA
[10:24:36.504] Packages to be attached in all futures: [n=0] 
[10:24:36.504] getGlobalsAndPackagesXApply() ... DONE
[10:24:36.505] Number of futures (= number of chunks): 1
[10:24:36.505] Launching 1 futures (chunks) ...
[10:24:36.505] Chunk #1 of 1 ...
[10:24:36.505]  - Finding globals in '...' for chunk #1 ...
[10:24:36.505] getGlobalsAndPackages() ...
[10:24:36.505] Searching for globals...
[10:24:36.505] 
[10:24:36.506] Searching for globals ... DONE
[10:24:36.506] - globals: [0] <none>
[10:24:36.506] getGlobalsAndPackages() ... DONE
[10:24:36.506]    + additional globals found: [n=0] 
[10:24:36.506]    + additional namespaces needed: [n=0] 
[10:24:36.506]  - Finding globals in '...' for chunk #1 ... DONE
[10:24:36.506]  - seeds: <none>
[10:24:36.506]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:36.506] getGlobalsAndPackages() ...
[10:24:36.506] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:36.507] Resolving globals: FALSE
[10:24:36.507] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[10:24:36.507] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:24:36.508] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:36.508] 
[10:24:36.508] getGlobalsAndPackages() ... DONE
[10:24:36.508] run() for ‘Future’ ...
[10:24:36.508] - state: ‘created’
[10:24:36.508] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:36.512] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:36.512] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:36.512]   - Field: ‘label’
[10:24:36.512]   - Field: ‘local’
[10:24:36.512]   - Field: ‘owner’
[10:24:36.512]   - Field: ‘envir’
[10:24:36.512]   - Field: ‘packages’
[10:24:36.512]   - Field: ‘gc’
[10:24:36.512]   - Field: ‘conditions’
[10:24:36.513]   - Field: ‘expr’
[10:24:36.513]   - Field: ‘uuid’
[10:24:36.513]   - Field: ‘seed’
[10:24:36.513]   - Field: ‘version’
[10:24:36.513]   - Field: ‘result’
[10:24:36.513]   - Field: ‘asynchronous’
[10:24:36.513]   - Field: ‘calls’
[10:24:36.513]   - Field: ‘globals’
[10:24:36.513]   - Field: ‘stdout’
[10:24:36.513]   - Field: ‘earlySignal’
[10:24:36.513]   - Field: ‘lazy’
[10:24:36.514]   - Field: ‘state’
[10:24:36.514] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:36.514] - Launch lazy future ...
[10:24:36.514] Packages needed by the future expression (n = 0): <none>
[10:24:36.514] Packages needed by future strategies (n = 0): <none>
[10:24:36.514] {
[10:24:36.514]     {
[10:24:36.514]         {
[10:24:36.514]             ...future.startTime <- base::Sys.time()
[10:24:36.514]             {
[10:24:36.514]                 {
[10:24:36.514]                   {
[10:24:36.514]                     base::local({
[10:24:36.514]                       has_future <- base::requireNamespace("future", 
[10:24:36.514]                         quietly = TRUE)
[10:24:36.514]                       if (has_future) {
[10:24:36.514]                         ns <- base::getNamespace("future")
[10:24:36.514]                         version <- ns[[".package"]][["version"]]
[10:24:36.514]                         if (is.null(version)) 
[10:24:36.514]                           version <- utils::packageVersion("future")
[10:24:36.514]                       }
[10:24:36.514]                       else {
[10:24:36.514]                         version <- NULL
[10:24:36.514]                       }
[10:24:36.514]                       if (!has_future || version < "1.8.0") {
[10:24:36.514]                         info <- base::c(r_version = base::gsub("R version ", 
[10:24:36.514]                           "", base::R.version$version.string), 
[10:24:36.514]                           platform = base::sprintf("%s (%s-bit)", 
[10:24:36.514]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:36.514]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:36.514]                             "release", "version")], collapse = " "), 
[10:24:36.514]                           hostname = base::Sys.info()[["nodename"]])
[10:24:36.514]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:24:36.514]                           info)
[10:24:36.514]                         info <- base::paste(info, collapse = "; ")
[10:24:36.514]                         if (!has_future) {
[10:24:36.514]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:36.514]                             info)
[10:24:36.514]                         }
[10:24:36.514]                         else {
[10:24:36.514]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:36.514]                             info, version)
[10:24:36.514]                         }
[10:24:36.514]                         base::stop(msg)
[10:24:36.514]                       }
[10:24:36.514]                     })
[10:24:36.514]                   }
[10:24:36.514]                   options(future.plan = NULL)
[10:24:36.514]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:36.514]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:36.514]                 }
[10:24:36.514]                 ...future.workdir <- getwd()
[10:24:36.514]             }
[10:24:36.514]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:36.514]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:36.514]         }
[10:24:36.514]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:36.514]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:36.514]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:36.514]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:36.514]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:36.514]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:36.514]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:36.514]             base::names(...future.oldOptions))
[10:24:36.514]     }
[10:24:36.514]     if (FALSE) {
[10:24:36.514]     }
[10:24:36.514]     else {
[10:24:36.514]         if (TRUE) {
[10:24:36.514]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:36.514]                 open = "w")
[10:24:36.514]         }
[10:24:36.514]         else {
[10:24:36.514]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:36.514]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:36.514]         }
[10:24:36.514]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:36.514]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:36.514]             base::sink(type = "output", split = FALSE)
[10:24:36.514]             base::close(...future.stdout)
[10:24:36.514]         }, add = TRUE)
[10:24:36.514]     }
[10:24:36.514]     ...future.frame <- base::sys.nframe()
[10:24:36.514]     ...future.conditions <- base::list()
[10:24:36.514]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:36.514]     if (FALSE) {
[10:24:36.514]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:36.514]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:36.514]     }
[10:24:36.514]     ...future.result <- base::tryCatch({
[10:24:36.514]         base::withCallingHandlers({
[10:24:36.514]             ...future.value <- base::withVisible(base::local({
[10:24:36.514]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:36.514]                 if (!identical(...future.globals.maxSize.org, 
[10:24:36.514]                   ...future.globals.maxSize)) {
[10:24:36.514]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:36.514]                   on.exit(options(oopts), add = TRUE)
[10:24:36.514]                 }
[10:24:36.514]                 {
[10:24:36.514]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:36.514]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:24:36.514]                     USE.NAMES = FALSE)
[10:24:36.514]                   do.call(mapply, args = args)
[10:24:36.514]                 }
[10:24:36.514]             }))
[10:24:36.514]             future::FutureResult(value = ...future.value$value, 
[10:24:36.514]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:36.514]                   ...future.rng), globalenv = if (FALSE) 
[10:24:36.514]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:36.514]                     ...future.globalenv.names))
[10:24:36.514]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:36.514]         }, condition = base::local({
[10:24:36.514]             c <- base::c
[10:24:36.514]             inherits <- base::inherits
[10:24:36.514]             invokeRestart <- base::invokeRestart
[10:24:36.514]             length <- base::length
[10:24:36.514]             list <- base::list
[10:24:36.514]             seq.int <- base::seq.int
[10:24:36.514]             signalCondition <- base::signalCondition
[10:24:36.514]             sys.calls <- base::sys.calls
[10:24:36.514]             `[[` <- base::`[[`
[10:24:36.514]             `+` <- base::`+`
[10:24:36.514]             `<<-` <- base::`<<-`
[10:24:36.514]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:36.514]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:36.514]                   3L)]
[10:24:36.514]             }
[10:24:36.514]             function(cond) {
[10:24:36.514]                 is_error <- inherits(cond, "error")
[10:24:36.514]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:36.514]                   NULL)
[10:24:36.514]                 if (is_error) {
[10:24:36.514]                   sessionInformation <- function() {
[10:24:36.514]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:36.514]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:36.514]                       search = base::search(), system = base::Sys.info())
[10:24:36.514]                   }
[10:24:36.514]                   ...future.conditions[[length(...future.conditions) + 
[10:24:36.514]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:36.514]                     cond$call), session = sessionInformation(), 
[10:24:36.514]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:36.514]                   signalCondition(cond)
[10:24:36.514]                 }
[10:24:36.514]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:36.514]                 "immediateCondition"))) {
[10:24:36.514]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:36.514]                   ...future.conditions[[length(...future.conditions) + 
[10:24:36.514]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:36.514]                   if (TRUE && !signal) {
[10:24:36.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:36.514]                     {
[10:24:36.514]                       inherits <- base::inherits
[10:24:36.514]                       invokeRestart <- base::invokeRestart
[10:24:36.514]                       is.null <- base::is.null
[10:24:36.514]                       muffled <- FALSE
[10:24:36.514]                       if (inherits(cond, "message")) {
[10:24:36.514]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:36.514]                         if (muffled) 
[10:24:36.514]                           invokeRestart("muffleMessage")
[10:24:36.514]                       }
[10:24:36.514]                       else if (inherits(cond, "warning")) {
[10:24:36.514]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:36.514]                         if (muffled) 
[10:24:36.514]                           invokeRestart("muffleWarning")
[10:24:36.514]                       }
[10:24:36.514]                       else if (inherits(cond, "condition")) {
[10:24:36.514]                         if (!is.null(pattern)) {
[10:24:36.514]                           computeRestarts <- base::computeRestarts
[10:24:36.514]                           grepl <- base::grepl
[10:24:36.514]                           restarts <- computeRestarts(cond)
[10:24:36.514]                           for (restart in restarts) {
[10:24:36.514]                             name <- restart$name
[10:24:36.514]                             if (is.null(name)) 
[10:24:36.514]                               next
[10:24:36.514]                             if (!grepl(pattern, name)) 
[10:24:36.514]                               next
[10:24:36.514]                             invokeRestart(restart)
[10:24:36.514]                             muffled <- TRUE
[10:24:36.514]                             break
[10:24:36.514]                           }
[10:24:36.514]                         }
[10:24:36.514]                       }
[10:24:36.514]                       invisible(muffled)
[10:24:36.514]                     }
[10:24:36.514]                     muffleCondition(cond, pattern = "^muffle")
[10:24:36.514]                   }
[10:24:36.514]                 }
[10:24:36.514]                 else {
[10:24:36.514]                   if (TRUE) {
[10:24:36.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:36.514]                     {
[10:24:36.514]                       inherits <- base::inherits
[10:24:36.514]                       invokeRestart <- base::invokeRestart
[10:24:36.514]                       is.null <- base::is.null
[10:24:36.514]                       muffled <- FALSE
[10:24:36.514]                       if (inherits(cond, "message")) {
[10:24:36.514]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:36.514]                         if (muffled) 
[10:24:36.514]                           invokeRestart("muffleMessage")
[10:24:36.514]                       }
[10:24:36.514]                       else if (inherits(cond, "warning")) {
[10:24:36.514]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:36.514]                         if (muffled) 
[10:24:36.514]                           invokeRestart("muffleWarning")
[10:24:36.514]                       }
[10:24:36.514]                       else if (inherits(cond, "condition")) {
[10:24:36.514]                         if (!is.null(pattern)) {
[10:24:36.514]                           computeRestarts <- base::computeRestarts
[10:24:36.514]                           grepl <- base::grepl
[10:24:36.514]                           restarts <- computeRestarts(cond)
[10:24:36.514]                           for (restart in restarts) {
[10:24:36.514]                             name <- restart$name
[10:24:36.514]                             if (is.null(name)) 
[10:24:36.514]                               next
[10:24:36.514]                             if (!grepl(pattern, name)) 
[10:24:36.514]                               next
[10:24:36.514]                             invokeRestart(restart)
[10:24:36.514]                             muffled <- TRUE
[10:24:36.514]                             break
[10:24:36.514]                           }
[10:24:36.514]                         }
[10:24:36.514]                       }
[10:24:36.514]                       invisible(muffled)
[10:24:36.514]                     }
[10:24:36.514]                     muffleCondition(cond, pattern = "^muffle")
[10:24:36.514]                   }
[10:24:36.514]                 }
[10:24:36.514]             }
[10:24:36.514]         }))
[10:24:36.514]     }, error = function(ex) {
[10:24:36.514]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:36.514]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:36.514]                 ...future.rng), started = ...future.startTime, 
[10:24:36.514]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:36.514]             version = "1.8"), class = "FutureResult")
[10:24:36.514]     }, finally = {
[10:24:36.514]         if (!identical(...future.workdir, getwd())) 
[10:24:36.514]             setwd(...future.workdir)
[10:24:36.514]         {
[10:24:36.514]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:36.514]                 ...future.oldOptions$nwarnings <- NULL
[10:24:36.514]             }
[10:24:36.514]             base::options(...future.oldOptions)
[10:24:36.514]             if (.Platform$OS.type == "windows") {
[10:24:36.514]                 old_names <- names(...future.oldEnvVars)
[10:24:36.514]                 envs <- base::Sys.getenv()
[10:24:36.514]                 names <- names(envs)
[10:24:36.514]                 common <- intersect(names, old_names)
[10:24:36.514]                 added <- setdiff(names, old_names)
[10:24:36.514]                 removed <- setdiff(old_names, names)
[10:24:36.514]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:36.514]                   envs[common]]
[10:24:36.514]                 NAMES <- toupper(changed)
[10:24:36.514]                 args <- list()
[10:24:36.514]                 for (kk in seq_along(NAMES)) {
[10:24:36.514]                   name <- changed[[kk]]
[10:24:36.514]                   NAME <- NAMES[[kk]]
[10:24:36.514]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:36.514]                     next
[10:24:36.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:36.514]                 }
[10:24:36.514]                 NAMES <- toupper(added)
[10:24:36.514]                 for (kk in seq_along(NAMES)) {
[10:24:36.514]                   name <- added[[kk]]
[10:24:36.514]                   NAME <- NAMES[[kk]]
[10:24:36.514]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:36.514]                     next
[10:24:36.514]                   args[[name]] <- ""
[10:24:36.514]                 }
[10:24:36.514]                 NAMES <- toupper(removed)
[10:24:36.514]                 for (kk in seq_along(NAMES)) {
[10:24:36.514]                   name <- removed[[kk]]
[10:24:36.514]                   NAME <- NAMES[[kk]]
[10:24:36.514]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:36.514]                     next
[10:24:36.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:36.514]                 }
[10:24:36.514]                 if (length(args) > 0) 
[10:24:36.514]                   base::do.call(base::Sys.setenv, args = args)
[10:24:36.514]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:36.514]             }
[10:24:36.514]             else {
[10:24:36.514]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:36.514]             }
[10:24:36.514]             {
[10:24:36.514]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:36.514]                   0L) {
[10:24:36.514]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:36.514]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:36.514]                   base::options(opts)
[10:24:36.514]                 }
[10:24:36.514]                 {
[10:24:36.514]                   {
[10:24:36.514]                     NULL
[10:24:36.514]                     RNGkind("Mersenne-Twister")
[10:24:36.514]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:36.514]                       inherits = FALSE)
[10:24:36.514]                   }
[10:24:36.514]                   options(future.plan = NULL)
[10:24:36.514]                   if (is.na(NA_character_)) 
[10:24:36.514]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:36.514]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:36.514]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:36.514]                     envir = parent.frame()) 
[10:24:36.514]                   {
[10:24:36.514]                     default_workers <- missing(workers)
[10:24:36.514]                     if (is.function(workers)) 
[10:24:36.514]                       workers <- workers()
[10:24:36.514]                     workers <- structure(as.integer(workers), 
[10:24:36.514]                       class = class(workers))
[10:24:36.514]                     stop_if_not(is.finite(workers), workers >= 
[10:24:36.514]                       1L)
[10:24:36.514]                     if ((workers == 1L && !inherits(workers, 
[10:24:36.514]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:36.514]                       if (default_workers) 
[10:24:36.514]                         supportsMulticore(warn = TRUE)
[10:24:36.514]                       return(sequential(..., envir = envir))
[10:24:36.514]                     }
[10:24:36.514]                     oopts <- options(mc.cores = workers)
[10:24:36.514]                     on.exit(options(oopts))
[10:24:36.514]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:36.514]                       envir = envir)
[10:24:36.514]                     if (!future$lazy) 
[10:24:36.514]                       future <- run(future)
[10:24:36.514]                     invisible(future)
[10:24:36.514]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:36.514]                 }
[10:24:36.514]             }
[10:24:36.514]         }
[10:24:36.514]     })
[10:24:36.514]     if (TRUE) {
[10:24:36.514]         base::sink(type = "output", split = FALSE)
[10:24:36.514]         if (TRUE) {
[10:24:36.514]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:36.514]         }
[10:24:36.514]         else {
[10:24:36.514]             ...future.result["stdout"] <- base::list(NULL)
[10:24:36.514]         }
[10:24:36.514]         base::close(...future.stdout)
[10:24:36.514]         ...future.stdout <- NULL
[10:24:36.514]     }
[10:24:36.514]     ...future.result$conditions <- ...future.conditions
[10:24:36.514]     ...future.result$finished <- base::Sys.time()
[10:24:36.514]     ...future.result
[10:24:36.514] }
[10:24:36.516] assign_globals() ...
[10:24:36.516] List of 5
[10:24:36.516]  $ ...future.FUN            :function (x, y)  
[10:24:36.516]  $ MoreArgs                 : NULL
[10:24:36.516]  $ ...future.elements_ii    :List of 2
[10:24:36.516]   ..$ :List of 2
[10:24:36.516]   .. ..$ : int 1
[10:24:36.516]   .. ..$ : int 0
[10:24:36.516]   ..$ :List of 2
[10:24:36.516]   .. ..$ : int 0
[10:24:36.516]   .. ..$ : int 1
[10:24:36.516]  $ ...future.seeds_ii       : NULL
[10:24:36.516]  $ ...future.globals.maxSize: NULL
[10:24:36.516]  - attr(*, "where")=List of 5
[10:24:36.516]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:36.516]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:24:36.516]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:36.516]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:36.516]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:36.516]  - attr(*, "resolved")= logi FALSE
[10:24:36.516]  - attr(*, "total_size")= num 6480
[10:24:36.516]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:36.516]  - attr(*, "already-done")= logi TRUE
[10:24:36.523] - reassign environment for ‘...future.FUN’
[10:24:36.523] - copied ‘...future.FUN’ to environment
[10:24:36.523] - copied ‘MoreArgs’ to environment
[10:24:36.523] - copied ‘...future.elements_ii’ to environment
[10:24:36.524] - copied ‘...future.seeds_ii’ to environment
[10:24:36.524] - copied ‘...future.globals.maxSize’ to environment
[10:24:36.524] assign_globals() ... done
[10:24:36.524] plan(): Setting new future strategy stack:
[10:24:36.524] List of future strategies:
[10:24:36.524] 1. sequential:
[10:24:36.524]    - args: function (..., envir = parent.frame())
[10:24:36.524]    - tweaked: FALSE
[10:24:36.524]    - call: NULL
[10:24:36.524] plan(): nbrOfWorkers() = 1
[10:24:37.026] plan(): Setting new future strategy stack:
[10:24:37.026] List of future strategies:
[10:24:37.026] 1. multicore:
[10:24:37.026]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:37.026]    - tweaked: FALSE
[10:24:37.026]    - call: plan(strategy)
[10:24:37.031] plan(): nbrOfWorkers() = 1
[10:24:37.031] SequentialFuture started (and completed)
[10:24:37.031] - Launch lazy future ... done
[10:24:37.031] run() for ‘SequentialFuture’ ... done
[10:24:37.032] Created future:
[10:24:37.032] SequentialFuture:
[10:24:37.032] Label: ‘future_mapply-1’
[10:24:37.032] Expression:
[10:24:37.032] {
[10:24:37.032]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:37.032]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:37.032]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:37.032]         on.exit(options(oopts), add = TRUE)
[10:24:37.032]     }
[10:24:37.032]     {
[10:24:37.032]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:37.032]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:24:37.032]         do.call(mapply, args = args)
[10:24:37.032]     }
[10:24:37.032] }
[10:24:37.032] Lazy evaluation: FALSE
[10:24:37.032] Asynchronous evaluation: FALSE
[10:24:37.032] Local evaluation: TRUE
[10:24:37.032] Environment: R_GlobalEnv
[10:24:37.032] Capture standard output: TRUE
[10:24:37.032] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:37.032] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:37.032] Packages: <none>
[10:24:37.032] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:37.032] Resolved: TRUE
[10:24:37.032] Value: 224 bytes of class ‘list’
[10:24:37.032] Early signaling: FALSE
[10:24:37.032] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:37.032] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:37.033] Chunk #1 of 1 ... DONE
[10:24:37.033] Launching 1 futures (chunks) ... DONE
[10:24:37.033] Resolving 1 futures (chunks) ...
[10:24:37.033] resolve() on list ...
[10:24:37.033]  recursive: 0
[10:24:37.033]  length: 1
[10:24:37.033] 
[10:24:37.034] resolved() for ‘SequentialFuture’ ...
[10:24:37.034] - state: ‘finished’
[10:24:37.034] - run: TRUE
[10:24:37.034] - result: ‘FutureResult’
[10:24:37.034] resolved() for ‘SequentialFuture’ ... done
[10:24:37.034] Future #1
[10:24:37.034] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:37.034] - nx: 1
[10:24:37.034] - relay: TRUE
[10:24:37.034] - stdout: TRUE
[10:24:37.035] - signal: TRUE
[10:24:37.035] - resignal: FALSE
[10:24:37.035] - force: TRUE
[10:24:37.035] - relayed: [n=1] FALSE
[10:24:37.035] - queued futures: [n=1] FALSE
[10:24:37.035]  - until=1
[10:24:37.035]  - relaying element #1
[10:24:37.035] - relayed: [n=1] TRUE
[10:24:37.035] - queued futures: [n=1] TRUE
[10:24:37.035] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:37.036]  length: 0 (resolved future 1)
[10:24:37.036] Relaying remaining futures
[10:24:37.036] signalConditionsASAP(NULL, pos=0) ...
[10:24:37.036] - nx: 1
[10:24:37.036] - relay: TRUE
[10:24:37.036] - stdout: TRUE
[10:24:37.036] - signal: TRUE
[10:24:37.036] - resignal: FALSE
[10:24:37.036] - force: TRUE
[10:24:37.036] - relayed: [n=1] TRUE
[10:24:37.036] - queued futures: [n=1] TRUE
 - flush all
[10:24:37.037] - relayed: [n=1] TRUE
[10:24:37.037] - queued futures: [n=1] TRUE
[10:24:37.037] signalConditionsASAP(NULL, pos=0) ... done
[10:24:37.037] resolve() on list ... DONE
[10:24:37.037]  - Number of value chunks collected: 1
[10:24:37.037] Resolving 1 futures (chunks) ... DONE
[10:24:37.037] Reducing values from 1 chunks ...
[10:24:37.037]  - Number of values collected after concatenation: 2
[10:24:37.037]  - Number of values expected: 2
[10:24:37.037] Reducing values from 1 chunks ... DONE
[10:24:37.038] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[10:24:37.038] future_mapply() ...
[10:24:37.041] Number of chunks: 1
[10:24:37.042] getGlobalsAndPackagesXApply() ...
[10:24:37.042]  - future.globals: TRUE
[10:24:37.042] getGlobalsAndPackages() ...
[10:24:37.042] Searching for globals...
[10:24:37.043] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:24:37.043] Searching for globals ... DONE
[10:24:37.044] Resolving globals: FALSE
[10:24:37.044] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[10:24:37.044] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[10:24:37.045] - globals: [1] ‘FUN’
[10:24:37.045] 
[10:24:37.045] getGlobalsAndPackages() ... DONE
[10:24:37.045]  - globals found/used: [n=1] ‘FUN’
[10:24:37.045]  - needed namespaces: [n=0] 
[10:24:37.045] Finding globals ... DONE
[10:24:37.045] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:24:37.045] List of 2
[10:24:37.045]  $ ...future.FUN:function (x, y)  
[10:24:37.045]  $ MoreArgs     : NULL
[10:24:37.045]  - attr(*, "where")=List of 2
[10:24:37.045]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:37.045]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:24:37.045]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:37.045]  - attr(*, "resolved")= logi FALSE
[10:24:37.045]  - attr(*, "total_size")= num NA
[10:24:37.048] Packages to be attached in all futures: [n=0] 
[10:24:37.048] getGlobalsAndPackagesXApply() ... DONE
[10:24:37.048] Number of futures (= number of chunks): 1
[10:24:37.048] Launching 1 futures (chunks) ...
[10:24:37.048] Chunk #1 of 1 ...
[10:24:37.048]  - Finding globals in '...' for chunk #1 ...
[10:24:37.049] getGlobalsAndPackages() ...
[10:24:37.049] Searching for globals...
[10:24:37.049] 
[10:24:37.049] Searching for globals ... DONE
[10:24:37.049] - globals: [0] <none>
[10:24:37.049] getGlobalsAndPackages() ... DONE
[10:24:37.049]    + additional globals found: [n=0] 
[10:24:37.049]    + additional namespaces needed: [n=0] 
[10:24:37.050]  - Finding globals in '...' for chunk #1 ... DONE
[10:24:37.050]  - seeds: <none>
[10:24:37.050]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:37.050] getGlobalsAndPackages() ...
[10:24:37.050] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:37.050] Resolving globals: FALSE
[10:24:37.050] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[10:24:37.051] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:24:37.051] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:37.051] 
[10:24:37.053] getGlobalsAndPackages() ... DONE
[10:24:37.053] run() for ‘Future’ ...
[10:24:37.053] - state: ‘created’
[10:24:37.054] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:37.057] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:37.057] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:37.057]   - Field: ‘label’
[10:24:37.057]   - Field: ‘local’
[10:24:37.057]   - Field: ‘owner’
[10:24:37.058]   - Field: ‘envir’
[10:24:37.058]   - Field: ‘packages’
[10:24:37.058]   - Field: ‘gc’
[10:24:37.058]   - Field: ‘conditions’
[10:24:37.058]   - Field: ‘expr’
[10:24:37.058]   - Field: ‘uuid’
[10:24:37.058]   - Field: ‘seed’
[10:24:37.058]   - Field: ‘version’
[10:24:37.058]   - Field: ‘result’
[10:24:37.058]   - Field: ‘asynchronous’
[10:24:37.058]   - Field: ‘calls’
[10:24:37.059]   - Field: ‘globals’
[10:24:37.059]   - Field: ‘stdout’
[10:24:37.059]   - Field: ‘earlySignal’
[10:24:37.059]   - Field: ‘lazy’
[10:24:37.059]   - Field: ‘state’
[10:24:37.059] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:37.059] - Launch lazy future ...
[10:24:37.059] Packages needed by the future expression (n = 0): <none>
[10:24:37.059] Packages needed by future strategies (n = 0): <none>
[10:24:37.060] {
[10:24:37.060]     {
[10:24:37.060]         {
[10:24:37.060]             ...future.startTime <- base::Sys.time()
[10:24:37.060]             {
[10:24:37.060]                 {
[10:24:37.060]                   {
[10:24:37.060]                     base::local({
[10:24:37.060]                       has_future <- base::requireNamespace("future", 
[10:24:37.060]                         quietly = TRUE)
[10:24:37.060]                       if (has_future) {
[10:24:37.060]                         ns <- base::getNamespace("future")
[10:24:37.060]                         version <- ns[[".package"]][["version"]]
[10:24:37.060]                         if (is.null(version)) 
[10:24:37.060]                           version <- utils::packageVersion("future")
[10:24:37.060]                       }
[10:24:37.060]                       else {
[10:24:37.060]                         version <- NULL
[10:24:37.060]                       }
[10:24:37.060]                       if (!has_future || version < "1.8.0") {
[10:24:37.060]                         info <- base::c(r_version = base::gsub("R version ", 
[10:24:37.060]                           "", base::R.version$version.string), 
[10:24:37.060]                           platform = base::sprintf("%s (%s-bit)", 
[10:24:37.060]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:37.060]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:37.060]                             "release", "version")], collapse = " "), 
[10:24:37.060]                           hostname = base::Sys.info()[["nodename"]])
[10:24:37.060]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:24:37.060]                           info)
[10:24:37.060]                         info <- base::paste(info, collapse = "; ")
[10:24:37.060]                         if (!has_future) {
[10:24:37.060]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:37.060]                             info)
[10:24:37.060]                         }
[10:24:37.060]                         else {
[10:24:37.060]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:37.060]                             info, version)
[10:24:37.060]                         }
[10:24:37.060]                         base::stop(msg)
[10:24:37.060]                       }
[10:24:37.060]                     })
[10:24:37.060]                   }
[10:24:37.060]                   options(future.plan = NULL)
[10:24:37.060]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:37.060]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:37.060]                 }
[10:24:37.060]                 ...future.workdir <- getwd()
[10:24:37.060]             }
[10:24:37.060]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:37.060]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:37.060]         }
[10:24:37.060]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:37.060]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:37.060]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:37.060]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:37.060]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:37.060]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:37.060]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:37.060]             base::names(...future.oldOptions))
[10:24:37.060]     }
[10:24:37.060]     if (TRUE) {
[10:24:37.060]     }
[10:24:37.060]     else {
[10:24:37.060]         if (NA) {
[10:24:37.060]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:37.060]                 open = "w")
[10:24:37.060]         }
[10:24:37.060]         else {
[10:24:37.060]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:37.060]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:37.060]         }
[10:24:37.060]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:37.060]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:37.060]             base::sink(type = "output", split = FALSE)
[10:24:37.060]             base::close(...future.stdout)
[10:24:37.060]         }, add = TRUE)
[10:24:37.060]     }
[10:24:37.060]     ...future.frame <- base::sys.nframe()
[10:24:37.060]     ...future.conditions <- base::list()
[10:24:37.060]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:37.060]     if (FALSE) {
[10:24:37.060]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:37.060]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:37.060]     }
[10:24:37.060]     ...future.result <- base::tryCatch({
[10:24:37.060]         base::withCallingHandlers({
[10:24:37.060]             ...future.value <- base::withVisible(base::local({
[10:24:37.060]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:37.060]                 if (!identical(...future.globals.maxSize.org, 
[10:24:37.060]                   ...future.globals.maxSize)) {
[10:24:37.060]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:37.060]                   on.exit(options(oopts), add = TRUE)
[10:24:37.060]                 }
[10:24:37.060]                 {
[10:24:37.060]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:37.060]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:24:37.060]                     USE.NAMES = FALSE)
[10:24:37.060]                   do.call(mapply, args = args)
[10:24:37.060]                 }
[10:24:37.060]             }))
[10:24:37.060]             future::FutureResult(value = ...future.value$value, 
[10:24:37.060]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:37.060]                   ...future.rng), globalenv = if (FALSE) 
[10:24:37.060]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:37.060]                     ...future.globalenv.names))
[10:24:37.060]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:37.060]         }, condition = base::local({
[10:24:37.060]             c <- base::c
[10:24:37.060]             inherits <- base::inherits
[10:24:37.060]             invokeRestart <- base::invokeRestart
[10:24:37.060]             length <- base::length
[10:24:37.060]             list <- base::list
[10:24:37.060]             seq.int <- base::seq.int
[10:24:37.060]             signalCondition <- base::signalCondition
[10:24:37.060]             sys.calls <- base::sys.calls
[10:24:37.060]             `[[` <- base::`[[`
[10:24:37.060]             `+` <- base::`+`
[10:24:37.060]             `<<-` <- base::`<<-`
[10:24:37.060]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:37.060]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:37.060]                   3L)]
[10:24:37.060]             }
[10:24:37.060]             function(cond) {
[10:24:37.060]                 is_error <- inherits(cond, "error")
[10:24:37.060]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:37.060]                   NULL)
[10:24:37.060]                 if (is_error) {
[10:24:37.060]                   sessionInformation <- function() {
[10:24:37.060]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:37.060]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:37.060]                       search = base::search(), system = base::Sys.info())
[10:24:37.060]                   }
[10:24:37.060]                   ...future.conditions[[length(...future.conditions) + 
[10:24:37.060]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:37.060]                     cond$call), session = sessionInformation(), 
[10:24:37.060]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:37.060]                   signalCondition(cond)
[10:24:37.060]                 }
[10:24:37.060]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:37.060]                 "immediateCondition"))) {
[10:24:37.060]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:37.060]                   ...future.conditions[[length(...future.conditions) + 
[10:24:37.060]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:37.060]                   if (TRUE && !signal) {
[10:24:37.060]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:37.060]                     {
[10:24:37.060]                       inherits <- base::inherits
[10:24:37.060]                       invokeRestart <- base::invokeRestart
[10:24:37.060]                       is.null <- base::is.null
[10:24:37.060]                       muffled <- FALSE
[10:24:37.060]                       if (inherits(cond, "message")) {
[10:24:37.060]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:37.060]                         if (muffled) 
[10:24:37.060]                           invokeRestart("muffleMessage")
[10:24:37.060]                       }
[10:24:37.060]                       else if (inherits(cond, "warning")) {
[10:24:37.060]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:37.060]                         if (muffled) 
[10:24:37.060]                           invokeRestart("muffleWarning")
[10:24:37.060]                       }
[10:24:37.060]                       else if (inherits(cond, "condition")) {
[10:24:37.060]                         if (!is.null(pattern)) {
[10:24:37.060]                           computeRestarts <- base::computeRestarts
[10:24:37.060]                           grepl <- base::grepl
[10:24:37.060]                           restarts <- computeRestarts(cond)
[10:24:37.060]                           for (restart in restarts) {
[10:24:37.060]                             name <- restart$name
[10:24:37.060]                             if (is.null(name)) 
[10:24:37.060]                               next
[10:24:37.060]                             if (!grepl(pattern, name)) 
[10:24:37.060]                               next
[10:24:37.060]                             invokeRestart(restart)
[10:24:37.060]                             muffled <- TRUE
[10:24:37.060]                             break
[10:24:37.060]                           }
[10:24:37.060]                         }
[10:24:37.060]                       }
[10:24:37.060]                       invisible(muffled)
[10:24:37.060]                     }
[10:24:37.060]                     muffleCondition(cond, pattern = "^muffle")
[10:24:37.060]                   }
[10:24:37.060]                 }
[10:24:37.060]                 else {
[10:24:37.060]                   if (TRUE) {
[10:24:37.060]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:37.060]                     {
[10:24:37.060]                       inherits <- base::inherits
[10:24:37.060]                       invokeRestart <- base::invokeRestart
[10:24:37.060]                       is.null <- base::is.null
[10:24:37.060]                       muffled <- FALSE
[10:24:37.060]                       if (inherits(cond, "message")) {
[10:24:37.060]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:37.060]                         if (muffled) 
[10:24:37.060]                           invokeRestart("muffleMessage")
[10:24:37.060]                       }
[10:24:37.060]                       else if (inherits(cond, "warning")) {
[10:24:37.060]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:37.060]                         if (muffled) 
[10:24:37.060]                           invokeRestart("muffleWarning")
[10:24:37.060]                       }
[10:24:37.060]                       else if (inherits(cond, "condition")) {
[10:24:37.060]                         if (!is.null(pattern)) {
[10:24:37.060]                           computeRestarts <- base::computeRestarts
[10:24:37.060]                           grepl <- base::grepl
[10:24:37.060]                           restarts <- computeRestarts(cond)
[10:24:37.060]                           for (restart in restarts) {
[10:24:37.060]                             name <- restart$name
[10:24:37.060]                             if (is.null(name)) 
[10:24:37.060]                               next
[10:24:37.060]                             if (!grepl(pattern, name)) 
[10:24:37.060]                               next
[10:24:37.060]                             invokeRestart(restart)
[10:24:37.060]                             muffled <- TRUE
[10:24:37.060]                             break
[10:24:37.060]                           }
[10:24:37.060]                         }
[10:24:37.060]                       }
[10:24:37.060]                       invisible(muffled)
[10:24:37.060]                     }
[10:24:37.060]                     muffleCondition(cond, pattern = "^muffle")
[10:24:37.060]                   }
[10:24:37.060]                 }
[10:24:37.060]             }
[10:24:37.060]         }))
[10:24:37.060]     }, error = function(ex) {
[10:24:37.060]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:37.060]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:37.060]                 ...future.rng), started = ...future.startTime, 
[10:24:37.060]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:37.060]             version = "1.8"), class = "FutureResult")
[10:24:37.060]     }, finally = {
[10:24:37.060]         if (!identical(...future.workdir, getwd())) 
[10:24:37.060]             setwd(...future.workdir)
[10:24:37.060]         {
[10:24:37.060]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:37.060]                 ...future.oldOptions$nwarnings <- NULL
[10:24:37.060]             }
[10:24:37.060]             base::options(...future.oldOptions)
[10:24:37.060]             if (.Platform$OS.type == "windows") {
[10:24:37.060]                 old_names <- names(...future.oldEnvVars)
[10:24:37.060]                 envs <- base::Sys.getenv()
[10:24:37.060]                 names <- names(envs)
[10:24:37.060]                 common <- intersect(names, old_names)
[10:24:37.060]                 added <- setdiff(names, old_names)
[10:24:37.060]                 removed <- setdiff(old_names, names)
[10:24:37.060]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:37.060]                   envs[common]]
[10:24:37.060]                 NAMES <- toupper(changed)
[10:24:37.060]                 args <- list()
[10:24:37.060]                 for (kk in seq_along(NAMES)) {
[10:24:37.060]                   name <- changed[[kk]]
[10:24:37.060]                   NAME <- NAMES[[kk]]
[10:24:37.060]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:37.060]                     next
[10:24:37.060]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:37.060]                 }
[10:24:37.060]                 NAMES <- toupper(added)
[10:24:37.060]                 for (kk in seq_along(NAMES)) {
[10:24:37.060]                   name <- added[[kk]]
[10:24:37.060]                   NAME <- NAMES[[kk]]
[10:24:37.060]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:37.060]                     next
[10:24:37.060]                   args[[name]] <- ""
[10:24:37.060]                 }
[10:24:37.060]                 NAMES <- toupper(removed)
[10:24:37.060]                 for (kk in seq_along(NAMES)) {
[10:24:37.060]                   name <- removed[[kk]]
[10:24:37.060]                   NAME <- NAMES[[kk]]
[10:24:37.060]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:37.060]                     next
[10:24:37.060]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:37.060]                 }
[10:24:37.060]                 if (length(args) > 0) 
[10:24:37.060]                   base::do.call(base::Sys.setenv, args = args)
[10:24:37.060]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:37.060]             }
[10:24:37.060]             else {
[10:24:37.060]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:37.060]             }
[10:24:37.060]             {
[10:24:37.060]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:37.060]                   0L) {
[10:24:37.060]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:37.060]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:37.060]                   base::options(opts)
[10:24:37.060]                 }
[10:24:37.060]                 {
[10:24:37.060]                   {
[10:24:37.060]                     NULL
[10:24:37.060]                     RNGkind("Mersenne-Twister")
[10:24:37.060]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:37.060]                       inherits = FALSE)
[10:24:37.060]                   }
[10:24:37.060]                   options(future.plan = NULL)
[10:24:37.060]                   if (is.na(NA_character_)) 
[10:24:37.060]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:37.060]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:37.060]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:37.060]                     envir = parent.frame()) 
[10:24:37.060]                   {
[10:24:37.060]                     default_workers <- missing(workers)
[10:24:37.060]                     if (is.function(workers)) 
[10:24:37.060]                       workers <- workers()
[10:24:37.060]                     workers <- structure(as.integer(workers), 
[10:24:37.060]                       class = class(workers))
[10:24:37.060]                     stop_if_not(is.finite(workers), workers >= 
[10:24:37.060]                       1L)
[10:24:37.060]                     if ((workers == 1L && !inherits(workers, 
[10:24:37.060]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:37.060]                       if (default_workers) 
[10:24:37.060]                         supportsMulticore(warn = TRUE)
[10:24:37.060]                       return(sequential(..., envir = envir))
[10:24:37.060]                     }
[10:24:37.060]                     oopts <- options(mc.cores = workers)
[10:24:37.060]                     on.exit(options(oopts))
[10:24:37.060]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:37.060]                       envir = envir)
[10:24:37.060]                     if (!future$lazy) 
[10:24:37.060]                       future <- run(future)
[10:24:37.060]                     invisible(future)
[10:24:37.060]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:37.060]                 }
[10:24:37.060]             }
[10:24:37.060]         }
[10:24:37.060]     })
[10:24:37.060]     if (FALSE) {
[10:24:37.060]         base::sink(type = "output", split = FALSE)
[10:24:37.060]         if (NA) {
[10:24:37.060]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:37.060]         }
[10:24:37.060]         else {
[10:24:37.060]             ...future.result["stdout"] <- base::list(NULL)
[10:24:37.060]         }
[10:24:37.060]         base::close(...future.stdout)
[10:24:37.060]         ...future.stdout <- NULL
[10:24:37.060]     }
[10:24:37.060]     ...future.result$conditions <- ...future.conditions
[10:24:37.060]     ...future.result$finished <- base::Sys.time()
[10:24:37.060]     ...future.result
[10:24:37.060] }
[10:24:37.062] assign_globals() ...
[10:24:37.062] List of 5
[10:24:37.062]  $ ...future.FUN            :function (x, y)  
[10:24:37.062]  $ MoreArgs                 : NULL
[10:24:37.062]  $ ...future.elements_ii    :List of 2
[10:24:37.062]   ..$ :List of 2
[10:24:37.062]   .. ..$ : int 1
[10:24:37.062]   .. ..$ : int 0
[10:24:37.062]   ..$ :List of 2
[10:24:37.062]   .. ..$ : int 0
[10:24:37.062]   .. ..$ : int 1
[10:24:37.062]  $ ...future.seeds_ii       : NULL
[10:24:37.062]  $ ...future.globals.maxSize: NULL
[10:24:37.062]  - attr(*, "where")=List of 5
[10:24:37.062]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:37.062]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:24:37.062]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:37.062]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:37.062]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:37.062]  - attr(*, "resolved")= logi FALSE
[10:24:37.062]  - attr(*, "total_size")= num 6480
[10:24:37.062]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:37.062]  - attr(*, "already-done")= logi TRUE
[10:24:37.067] - reassign environment for ‘...future.FUN’
[10:24:37.067] - copied ‘...future.FUN’ to environment
[10:24:37.067] - copied ‘MoreArgs’ to environment
[10:24:37.068] - copied ‘...future.elements_ii’ to environment
[10:24:37.068] - copied ‘...future.seeds_ii’ to environment
[10:24:37.068] - copied ‘...future.globals.maxSize’ to environment
[10:24:37.068] assign_globals() ... done
[10:24:37.068] plan(): Setting new future strategy stack:
[10:24:37.068] List of future strategies:
[10:24:37.068] 1. sequential:
[10:24:37.068]    - args: function (..., envir = parent.frame())
[10:24:37.068]    - tweaked: FALSE
[10:24:37.068]    - call: NULL
[10:24:37.068] plan(): nbrOfWorkers() = 1
[10:24:37.570] plan(): Setting new future strategy stack:
[10:24:37.570] List of future strategies:
[10:24:37.570] 1. multicore:
[10:24:37.570]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:37.570]    - tweaked: FALSE
[10:24:37.570]    - call: plan(strategy)
[10:24:37.575] plan(): nbrOfWorkers() = 1
[10:24:37.575] SequentialFuture started (and completed)
[10:24:37.575] - Launch lazy future ... done
[10:24:37.575] run() for ‘SequentialFuture’ ... done
[10:24:37.575] Created future:
[10:24:37.575] SequentialFuture:
[10:24:37.575] Label: ‘future_mapply-1’
[10:24:37.575] Expression:
[10:24:37.575] {
[10:24:37.575]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:37.575]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:37.575]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:37.575]         on.exit(options(oopts), add = TRUE)
[10:24:37.575]     }
[10:24:37.575]     {
[10:24:37.575]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:37.575]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:24:37.575]         do.call(mapply, args = args)
[10:24:37.575]     }
[10:24:37.575] }
[10:24:37.575] Lazy evaluation: FALSE
[10:24:37.575] Asynchronous evaluation: FALSE
[10:24:37.575] Local evaluation: TRUE
[10:24:37.575] Environment: R_GlobalEnv
[10:24:37.575] Capture standard output: NA
[10:24:37.575] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:37.575] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:37.575] Packages: <none>
[10:24:37.575] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:37.575] Resolved: TRUE
[10:24:37.575] Value: 224 bytes of class ‘list’
[10:24:37.575] Early signaling: FALSE
[10:24:37.575] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:37.575] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:37.577] Chunk #1 of 1 ... DONE
[10:24:37.577] Launching 1 futures (chunks) ... DONE
[10:24:37.577] Resolving 1 futures (chunks) ...
[10:24:37.577] resolve() on list ...
[10:24:37.577]  recursive: 0
[10:24:37.577]  length: 1
[10:24:37.577] 
[10:24:37.577] resolved() for ‘SequentialFuture’ ...
[10:24:37.577] - state: ‘finished’
[10:24:37.578] - run: TRUE
[10:24:37.578] - result: ‘FutureResult’
[10:24:37.578] resolved() for ‘SequentialFuture’ ... done
[10:24:37.578] Future #1
[10:24:37.578] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:37.578] - nx: 1
[10:24:37.578] - relay: TRUE
[10:24:37.578] - stdout: TRUE
[10:24:37.578] - signal: TRUE
[10:24:37.578] - resignal: FALSE
[10:24:37.579] - force: TRUE
[10:24:37.579] - relayed: [n=1] FALSE
[10:24:37.579] - queued futures: [n=1] FALSE
[10:24:37.579]  - until=1
[10:24:37.579]  - relaying element #1
[10:24:37.579] - relayed: [n=1] TRUE
[10:24:37.579] - queued futures: [n=1] TRUE
[10:24:37.579] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:37.579]  length: 0 (resolved future 1)
[10:24:37.579] Relaying remaining futures
[10:24:37.580] signalConditionsASAP(NULL, pos=0) ...
[10:24:37.580] - nx: 1
[10:24:37.580] - relay: TRUE
[10:24:37.580] - stdout: TRUE
[10:24:37.580] - signal: TRUE
[10:24:37.580] - resignal: FALSE
[10:24:37.580] - force: TRUE
[10:24:37.580] - relayed: [n=1] TRUE
[10:24:37.580] - queued futures: [n=1] TRUE
 - flush all
[10:24:37.580] - relayed: [n=1] TRUE
[10:24:37.580] - queued futures: [n=1] TRUE
[10:24:37.581] signalConditionsASAP(NULL, pos=0) ... done
[10:24:37.581] resolve() on list ... DONE
[10:24:37.581]  - Number of value chunks collected: 1
[10:24:37.581] Resolving 1 futures (chunks) ... DONE
[10:24:37.581] Reducing values from 1 chunks ...
[10:24:37.581]  - Number of values collected after concatenation: 2
[10:24:37.581]  - Number of values expected: 2
[10:24:37.581] Reducing values from 1 chunks ... DONE
[10:24:37.581] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[10:24:37.582] plan(): Setting new future strategy stack:
[10:24:37.582] List of future strategies:
[10:24:37.582] 1. multisession:
[10:24:37.582]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:24:37.582]    - tweaked: FALSE
[10:24:37.582]    - call: plan(strategy)
[10:24:37.608] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:24:37.608] multisession:
[10:24:37.608] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:24:37.608] - tweaked: FALSE
[10:24:37.608] - call: plan(strategy)
[10:24:37.613] getGlobalsAndPackages() ...
[10:24:37.613] Not searching for globals
[10:24:37.613] - globals: [0] <none>
[10:24:37.613] getGlobalsAndPackages() ... DONE
[10:24:37.614] Packages needed by the future expression (n = 0): <none>
[10:24:37.614] Packages needed by future strategies (n = 0): <none>
[10:24:37.614] {
[10:24:37.614]     {
[10:24:37.614]         {
[10:24:37.614]             ...future.startTime <- base::Sys.time()
[10:24:37.614]             {
[10:24:37.614]                 {
[10:24:37.614]                   {
[10:24:37.614]                     base::local({
[10:24:37.614]                       has_future <- base::requireNamespace("future", 
[10:24:37.614]                         quietly = TRUE)
[10:24:37.614]                       if (has_future) {
[10:24:37.614]                         ns <- base::getNamespace("future")
[10:24:37.614]                         version <- ns[[".package"]][["version"]]
[10:24:37.614]                         if (is.null(version)) 
[10:24:37.614]                           version <- utils::packageVersion("future")
[10:24:37.614]                       }
[10:24:37.614]                       else {
[10:24:37.614]                         version <- NULL
[10:24:37.614]                       }
[10:24:37.614]                       if (!has_future || version < "1.8.0") {
[10:24:37.614]                         info <- base::c(r_version = base::gsub("R version ", 
[10:24:37.614]                           "", base::R.version$version.string), 
[10:24:37.614]                           platform = base::sprintf("%s (%s-bit)", 
[10:24:37.614]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:37.614]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:37.614]                             "release", "version")], collapse = " "), 
[10:24:37.614]                           hostname = base::Sys.info()[["nodename"]])
[10:24:37.614]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:24:37.614]                           info)
[10:24:37.614]                         info <- base::paste(info, collapse = "; ")
[10:24:37.614]                         if (!has_future) {
[10:24:37.614]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:37.614]                             info)
[10:24:37.614]                         }
[10:24:37.614]                         else {
[10:24:37.614]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:37.614]                             info, version)
[10:24:37.614]                         }
[10:24:37.614]                         base::stop(msg)
[10:24:37.614]                       }
[10:24:37.614]                     })
[10:24:37.614]                   }
[10:24:37.614]                   options(future.plan = NULL)
[10:24:37.614]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:37.614]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:37.614]                 }
[10:24:37.614]                 ...future.workdir <- getwd()
[10:24:37.614]             }
[10:24:37.614]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:37.614]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:37.614]         }
[10:24:37.614]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:37.614]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:37.614]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:37.614]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:37.614]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:37.614]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:37.614]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:37.614]             base::names(...future.oldOptions))
[10:24:37.614]     }
[10:24:37.614]     if (FALSE) {
[10:24:37.614]     }
[10:24:37.614]     else {
[10:24:37.614]         if (TRUE) {
[10:24:37.614]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:37.614]                 open = "w")
[10:24:37.614]         }
[10:24:37.614]         else {
[10:24:37.614]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:37.614]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:37.614]         }
[10:24:37.614]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:37.614]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:37.614]             base::sink(type = "output", split = FALSE)
[10:24:37.614]             base::close(...future.stdout)
[10:24:37.614]         }, add = TRUE)
[10:24:37.614]     }
[10:24:37.614]     ...future.frame <- base::sys.nframe()
[10:24:37.614]     ...future.conditions <- base::list()
[10:24:37.614]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:37.614]     if (FALSE) {
[10:24:37.614]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:37.614]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:37.614]     }
[10:24:37.614]     ...future.result <- base::tryCatch({
[10:24:37.614]         base::withCallingHandlers({
[10:24:37.614]             ...future.value <- base::withVisible(base::local(NA))
[10:24:37.614]             future::FutureResult(value = ...future.value$value, 
[10:24:37.614]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:37.614]                   ...future.rng), globalenv = if (FALSE) 
[10:24:37.614]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:37.614]                     ...future.globalenv.names))
[10:24:37.614]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:37.614]         }, condition = base::local({
[10:24:37.614]             c <- base::c
[10:24:37.614]             inherits <- base::inherits
[10:24:37.614]             invokeRestart <- base::invokeRestart
[10:24:37.614]             length <- base::length
[10:24:37.614]             list <- base::list
[10:24:37.614]             seq.int <- base::seq.int
[10:24:37.614]             signalCondition <- base::signalCondition
[10:24:37.614]             sys.calls <- base::sys.calls
[10:24:37.614]             `[[` <- base::`[[`
[10:24:37.614]             `+` <- base::`+`
[10:24:37.614]             `<<-` <- base::`<<-`
[10:24:37.614]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:37.614]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:37.614]                   3L)]
[10:24:37.614]             }
[10:24:37.614]             function(cond) {
[10:24:37.614]                 is_error <- inherits(cond, "error")
[10:24:37.614]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:37.614]                   NULL)
[10:24:37.614]                 if (is_error) {
[10:24:37.614]                   sessionInformation <- function() {
[10:24:37.614]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:37.614]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:37.614]                       search = base::search(), system = base::Sys.info())
[10:24:37.614]                   }
[10:24:37.614]                   ...future.conditions[[length(...future.conditions) + 
[10:24:37.614]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:37.614]                     cond$call), session = sessionInformation(), 
[10:24:37.614]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:37.614]                   signalCondition(cond)
[10:24:37.614]                 }
[10:24:37.614]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:37.614]                 "immediateCondition"))) {
[10:24:37.614]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:37.614]                   ...future.conditions[[length(...future.conditions) + 
[10:24:37.614]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:37.614]                   if (TRUE && !signal) {
[10:24:37.614]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:37.614]                     {
[10:24:37.614]                       inherits <- base::inherits
[10:24:37.614]                       invokeRestart <- base::invokeRestart
[10:24:37.614]                       is.null <- base::is.null
[10:24:37.614]                       muffled <- FALSE
[10:24:37.614]                       if (inherits(cond, "message")) {
[10:24:37.614]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:37.614]                         if (muffled) 
[10:24:37.614]                           invokeRestart("muffleMessage")
[10:24:37.614]                       }
[10:24:37.614]                       else if (inherits(cond, "warning")) {
[10:24:37.614]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:37.614]                         if (muffled) 
[10:24:37.614]                           invokeRestart("muffleWarning")
[10:24:37.614]                       }
[10:24:37.614]                       else if (inherits(cond, "condition")) {
[10:24:37.614]                         if (!is.null(pattern)) {
[10:24:37.614]                           computeRestarts <- base::computeRestarts
[10:24:37.614]                           grepl <- base::grepl
[10:24:37.614]                           restarts <- computeRestarts(cond)
[10:24:37.614]                           for (restart in restarts) {
[10:24:37.614]                             name <- restart$name
[10:24:37.614]                             if (is.null(name)) 
[10:24:37.614]                               next
[10:24:37.614]                             if (!grepl(pattern, name)) 
[10:24:37.614]                               next
[10:24:37.614]                             invokeRestart(restart)
[10:24:37.614]                             muffled <- TRUE
[10:24:37.614]                             break
[10:24:37.614]                           }
[10:24:37.614]                         }
[10:24:37.614]                       }
[10:24:37.614]                       invisible(muffled)
[10:24:37.614]                     }
[10:24:37.614]                     muffleCondition(cond, pattern = "^muffle")
[10:24:37.614]                   }
[10:24:37.614]                 }
[10:24:37.614]                 else {
[10:24:37.614]                   if (TRUE) {
[10:24:37.614]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:37.614]                     {
[10:24:37.614]                       inherits <- base::inherits
[10:24:37.614]                       invokeRestart <- base::invokeRestart
[10:24:37.614]                       is.null <- base::is.null
[10:24:37.614]                       muffled <- FALSE
[10:24:37.614]                       if (inherits(cond, "message")) {
[10:24:37.614]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:37.614]                         if (muffled) 
[10:24:37.614]                           invokeRestart("muffleMessage")
[10:24:37.614]                       }
[10:24:37.614]                       else if (inherits(cond, "warning")) {
[10:24:37.614]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:37.614]                         if (muffled) 
[10:24:37.614]                           invokeRestart("muffleWarning")
[10:24:37.614]                       }
[10:24:37.614]                       else if (inherits(cond, "condition")) {
[10:24:37.614]                         if (!is.null(pattern)) {
[10:24:37.614]                           computeRestarts <- base::computeRestarts
[10:24:37.614]                           grepl <- base::grepl
[10:24:37.614]                           restarts <- computeRestarts(cond)
[10:24:37.614]                           for (restart in restarts) {
[10:24:37.614]                             name <- restart$name
[10:24:37.614]                             if (is.null(name)) 
[10:24:37.614]                               next
[10:24:37.614]                             if (!grepl(pattern, name)) 
[10:24:37.614]                               next
[10:24:37.614]                             invokeRestart(restart)
[10:24:37.614]                             muffled <- TRUE
[10:24:37.614]                             break
[10:24:37.614]                           }
[10:24:37.614]                         }
[10:24:37.614]                       }
[10:24:37.614]                       invisible(muffled)
[10:24:37.614]                     }
[10:24:37.614]                     muffleCondition(cond, pattern = "^muffle")
[10:24:37.614]                   }
[10:24:37.614]                 }
[10:24:37.614]             }
[10:24:37.614]         }))
[10:24:37.614]     }, error = function(ex) {
[10:24:37.614]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:37.614]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:37.614]                 ...future.rng), started = ...future.startTime, 
[10:24:37.614]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:37.614]             version = "1.8"), class = "FutureResult")
[10:24:37.614]     }, finally = {
[10:24:37.614]         if (!identical(...future.workdir, getwd())) 
[10:24:37.614]             setwd(...future.workdir)
[10:24:37.614]         {
[10:24:37.614]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:37.614]                 ...future.oldOptions$nwarnings <- NULL
[10:24:37.614]             }
[10:24:37.614]             base::options(...future.oldOptions)
[10:24:37.614]             if (.Platform$OS.type == "windows") {
[10:24:37.614]                 old_names <- names(...future.oldEnvVars)
[10:24:37.614]                 envs <- base::Sys.getenv()
[10:24:37.614]                 names <- names(envs)
[10:24:37.614]                 common <- intersect(names, old_names)
[10:24:37.614]                 added <- setdiff(names, old_names)
[10:24:37.614]                 removed <- setdiff(old_names, names)
[10:24:37.614]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:37.614]                   envs[common]]
[10:24:37.614]                 NAMES <- toupper(changed)
[10:24:37.614]                 args <- list()
[10:24:37.614]                 for (kk in seq_along(NAMES)) {
[10:24:37.614]                   name <- changed[[kk]]
[10:24:37.614]                   NAME <- NAMES[[kk]]
[10:24:37.614]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:37.614]                     next
[10:24:37.614]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:37.614]                 }
[10:24:37.614]                 NAMES <- toupper(added)
[10:24:37.614]                 for (kk in seq_along(NAMES)) {
[10:24:37.614]                   name <- added[[kk]]
[10:24:37.614]                   NAME <- NAMES[[kk]]
[10:24:37.614]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:37.614]                     next
[10:24:37.614]                   args[[name]] <- ""
[10:24:37.614]                 }
[10:24:37.614]                 NAMES <- toupper(removed)
[10:24:37.614]                 for (kk in seq_along(NAMES)) {
[10:24:37.614]                   name <- removed[[kk]]
[10:24:37.614]                   NAME <- NAMES[[kk]]
[10:24:37.614]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:37.614]                     next
[10:24:37.614]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:37.614]                 }
[10:24:37.614]                 if (length(args) > 0) 
[10:24:37.614]                   base::do.call(base::Sys.setenv, args = args)
[10:24:37.614]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:37.614]             }
[10:24:37.614]             else {
[10:24:37.614]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:37.614]             }
[10:24:37.614]             {
[10:24:37.614]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:37.614]                   0L) {
[10:24:37.614]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:37.614]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:37.614]                   base::options(opts)
[10:24:37.614]                 }
[10:24:37.614]                 {
[10:24:37.614]                   {
[10:24:37.614]                     NULL
[10:24:37.614]                     RNGkind("Mersenne-Twister")
[10:24:37.614]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:37.614]                       inherits = FALSE)
[10:24:37.614]                   }
[10:24:37.614]                   options(future.plan = NULL)
[10:24:37.614]                   if (is.na(NA_character_)) 
[10:24:37.614]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:37.614]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:37.614]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:37.614]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:37.614]                     envir = parent.frame()) 
[10:24:37.614]                   {
[10:24:37.614]                     if (is.function(workers)) 
[10:24:37.614]                       workers <- workers()
[10:24:37.614]                     workers <- structure(as.integer(workers), 
[10:24:37.614]                       class = class(workers))
[10:24:37.614]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:37.614]                       workers >= 1)
[10:24:37.614]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:37.614]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:37.614]                     }
[10:24:37.614]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:37.614]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:37.614]                       envir = envir)
[10:24:37.614]                     if (!future$lazy) 
[10:24:37.614]                       future <- run(future)
[10:24:37.614]                     invisible(future)
[10:24:37.614]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:37.614]                 }
[10:24:37.614]             }
[10:24:37.614]         }
[10:24:37.614]     })
[10:24:37.614]     if (TRUE) {
[10:24:37.614]         base::sink(type = "output", split = FALSE)
[10:24:37.614]         if (TRUE) {
[10:24:37.614]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:37.614]         }
[10:24:37.614]         else {
[10:24:37.614]             ...future.result["stdout"] <- base::list(NULL)
[10:24:37.614]         }
[10:24:37.614]         base::close(...future.stdout)
[10:24:37.614]         ...future.stdout <- NULL
[10:24:37.614]     }
[10:24:37.614]     ...future.result$conditions <- ...future.conditions
[10:24:37.614]     ...future.result$finished <- base::Sys.time()
[10:24:37.614]     ...future.result
[10:24:37.614] }
[10:24:37.616] plan(): Setting new future strategy stack:
[10:24:37.616] List of future strategies:
[10:24:37.616] 1. sequential:
[10:24:37.616]    - args: function (..., envir = parent.frame())
[10:24:37.616]    - tweaked: FALSE
[10:24:37.616]    - call: NULL
[10:24:37.617] plan(): nbrOfWorkers() = 1
[10:24:37.617] plan(): Setting new future strategy stack:
[10:24:37.617] List of future strategies:
[10:24:37.617] 1. multisession:
[10:24:37.617]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:24:37.617]    - tweaked: FALSE
[10:24:37.617]    - call: plan(strategy)
[10:24:37.621] plan(): nbrOfWorkers() = 1
[10:24:37.621] SequentialFuture started (and completed)
[10:24:37.621] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:24:37.624] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[10:24:37.624] future_lapply() ...
[10:24:37.628] Number of chunks: 1
[10:24:37.628] getGlobalsAndPackagesXApply() ...
[10:24:37.628]  - future.globals: TRUE
[10:24:37.628] getGlobalsAndPackages() ...
[10:24:37.628] Searching for globals...
[10:24:37.630] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:24:37.630] Searching for globals ... DONE
[10:24:37.630] Resolving globals: FALSE
[10:24:37.630] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[10:24:37.631] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[10:24:37.631] - globals: [1] ‘FUN’
[10:24:37.631] 
[10:24:37.631] getGlobalsAndPackages() ... DONE
[10:24:37.631]  - globals found/used: [n=1] ‘FUN’
[10:24:37.631]  - needed namespaces: [n=0] 
[10:24:37.631] Finding globals ... DONE
[10:24:37.631]  - use_args: TRUE
[10:24:37.632]  - Getting '...' globals ...
[10:24:37.632] resolve() on list ...
[10:24:37.632]  recursive: 0
[10:24:37.632]  length: 1
[10:24:37.632]  elements: ‘...’
[10:24:37.632]  length: 0 (resolved future 1)
[10:24:37.632] resolve() on list ... DONE
[10:24:37.632]    - '...' content: [n=0] 
[10:24:37.633] List of 1
[10:24:37.633]  $ ...: list()
[10:24:37.633]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:37.633]  - attr(*, "where")=List of 1
[10:24:37.633]   ..$ ...:<environment: 0x55d20fa0c130> 
[10:24:37.633]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:37.633]  - attr(*, "resolved")= logi TRUE
[10:24:37.633]  - attr(*, "total_size")= num NA
[10:24:37.635]  - Getting '...' globals ... DONE
[10:24:37.635] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:24:37.635] List of 2
[10:24:37.635]  $ ...future.FUN:function (x)  
[10:24:37.635]  $ ...          : list()
[10:24:37.635]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:37.635]  - attr(*, "where")=List of 2
[10:24:37.635]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:37.635]   ..$ ...          :<environment: 0x55d20fa0c130> 
[10:24:37.635]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:37.635]  - attr(*, "resolved")= logi FALSE
[10:24:37.635]  - attr(*, "total_size")= num 4720
[10:24:37.638] Packages to be attached in all futures: [n=0] 
[10:24:37.638] getGlobalsAndPackagesXApply() ... DONE
[10:24:37.638] Number of futures (= number of chunks): 1
[10:24:37.638] Launching 1 futures (chunks) ...
[10:24:37.639] Chunk #1 of 1 ...
[10:24:37.639]  - Finding globals in 'X' for chunk #1 ...
[10:24:37.639] getGlobalsAndPackages() ...
[10:24:37.639] Searching for globals...
[10:24:37.639] 
[10:24:37.639] Searching for globals ... DONE
[10:24:37.639] - globals: [0] <none>
[10:24:37.639] getGlobalsAndPackages() ... DONE
[10:24:37.639]    + additional globals found: [n=0] 
[10:24:37.640]    + additional namespaces needed: [n=0] 
[10:24:37.640]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:37.640]  - seeds: <none>
[10:24:37.640]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:37.640] getGlobalsAndPackages() ...
[10:24:37.640] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:37.640] Resolving globals: FALSE
[10:24:37.640] Tweak future expression to call with '...' arguments ...
[10:24:37.640] {
[10:24:37.640]     do.call(function(...) {
[10:24:37.640]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:37.640]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:37.640]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:37.640]             on.exit(options(oopts), add = TRUE)
[10:24:37.640]         }
[10:24:37.640]         {
[10:24:37.640]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:37.640]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:37.640]                 ...future.FUN(...future.X_jj, ...)
[10:24:37.640]             })
[10:24:37.640]         }
[10:24:37.640]     }, args = future.call.arguments)
[10:24:37.640] }
[10:24:37.641] Tweak future expression to call with '...' arguments ... DONE
[10:24:37.641] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:37.641] 
[10:24:37.641] getGlobalsAndPackages() ... DONE
[10:24:37.641] run() for ‘Future’ ...
[10:24:37.642] - state: ‘created’
[10:24:37.642] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:37.645] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:37.645] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:37.645]   - Field: ‘label’
[10:24:37.645]   - Field: ‘local’
[10:24:37.645]   - Field: ‘owner’
[10:24:37.645]   - Field: ‘envir’
[10:24:37.646]   - Field: ‘packages’
[10:24:37.646]   - Field: ‘gc’
[10:24:37.646]   - Field: ‘conditions’
[10:24:37.646]   - Field: ‘expr’
[10:24:37.647]   - Field: ‘uuid’
[10:24:37.647]   - Field: ‘seed’
[10:24:37.647]   - Field: ‘version’
[10:24:37.647]   - Field: ‘result’
[10:24:37.648]   - Field: ‘asynchronous’
[10:24:37.648]   - Field: ‘calls’
[10:24:37.648]   - Field: ‘globals’
[10:24:37.648]   - Field: ‘stdout’
[10:24:37.648]   - Field: ‘earlySignal’
[10:24:37.648]   - Field: ‘lazy’
[10:24:37.648]   - Field: ‘state’
[10:24:37.648] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:37.648] - Launch lazy future ...
[10:24:37.648] Packages needed by the future expression (n = 0): <none>
[10:24:37.649] Packages needed by future strategies (n = 0): <none>
[10:24:37.649] {
[10:24:37.649]     {
[10:24:37.649]         {
[10:24:37.649]             ...future.startTime <- base::Sys.time()
[10:24:37.649]             {
[10:24:37.649]                 {
[10:24:37.649]                   {
[10:24:37.649]                     base::local({
[10:24:37.649]                       has_future <- base::requireNamespace("future", 
[10:24:37.649]                         quietly = TRUE)
[10:24:37.649]                       if (has_future) {
[10:24:37.649]                         ns <- base::getNamespace("future")
[10:24:37.649]                         version <- ns[[".package"]][["version"]]
[10:24:37.649]                         if (is.null(version)) 
[10:24:37.649]                           version <- utils::packageVersion("future")
[10:24:37.649]                       }
[10:24:37.649]                       else {
[10:24:37.649]                         version <- NULL
[10:24:37.649]                       }
[10:24:37.649]                       if (!has_future || version < "1.8.0") {
[10:24:37.649]                         info <- base::c(r_version = base::gsub("R version ", 
[10:24:37.649]                           "", base::R.version$version.string), 
[10:24:37.649]                           platform = base::sprintf("%s (%s-bit)", 
[10:24:37.649]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:37.649]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:37.649]                             "release", "version")], collapse = " "), 
[10:24:37.649]                           hostname = base::Sys.info()[["nodename"]])
[10:24:37.649]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:24:37.649]                           info)
[10:24:37.649]                         info <- base::paste(info, collapse = "; ")
[10:24:37.649]                         if (!has_future) {
[10:24:37.649]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:37.649]                             info)
[10:24:37.649]                         }
[10:24:37.649]                         else {
[10:24:37.649]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:37.649]                             info, version)
[10:24:37.649]                         }
[10:24:37.649]                         base::stop(msg)
[10:24:37.649]                       }
[10:24:37.649]                     })
[10:24:37.649]                   }
[10:24:37.649]                   options(future.plan = NULL)
[10:24:37.649]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:37.649]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:37.649]                 }
[10:24:37.649]                 ...future.workdir <- getwd()
[10:24:37.649]             }
[10:24:37.649]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:37.649]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:37.649]         }
[10:24:37.649]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:37.649]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:37.649]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:37.649]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:37.649]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:37.649]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:37.649]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:37.649]             base::names(...future.oldOptions))
[10:24:37.649]     }
[10:24:37.649]     if (FALSE) {
[10:24:37.649]     }
[10:24:37.649]     else {
[10:24:37.649]         if (FALSE) {
[10:24:37.649]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:37.649]                 open = "w")
[10:24:37.649]         }
[10:24:37.649]         else {
[10:24:37.649]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:37.649]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:37.649]         }
[10:24:37.649]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:37.649]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:37.649]             base::sink(type = "output", split = FALSE)
[10:24:37.649]             base::close(...future.stdout)
[10:24:37.649]         }, add = TRUE)
[10:24:37.649]     }
[10:24:37.649]     ...future.frame <- base::sys.nframe()
[10:24:37.649]     ...future.conditions <- base::list()
[10:24:37.649]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:37.649]     if (FALSE) {
[10:24:37.649]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:37.649]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:37.649]     }
[10:24:37.649]     ...future.result <- base::tryCatch({
[10:24:37.649]         base::withCallingHandlers({
[10:24:37.649]             ...future.value <- base::withVisible(base::local({
[10:24:37.649]                 do.call(function(...) {
[10:24:37.649]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:37.649]                   if (!identical(...future.globals.maxSize.org, 
[10:24:37.649]                     ...future.globals.maxSize)) {
[10:24:37.649]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:37.649]                     on.exit(options(oopts), add = TRUE)
[10:24:37.649]                   }
[10:24:37.649]                   {
[10:24:37.649]                     lapply(seq_along(...future.elements_ii), 
[10:24:37.649]                       FUN = function(jj) {
[10:24:37.649]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:37.649]                         ...future.FUN(...future.X_jj, ...)
[10:24:37.649]                       })
[10:24:37.649]                   }
[10:24:37.649]                 }, args = future.call.arguments)
[10:24:37.649]             }))
[10:24:37.649]             future::FutureResult(value = ...future.value$value, 
[10:24:37.649]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:37.649]                   ...future.rng), globalenv = if (FALSE) 
[10:24:37.649]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:37.649]                     ...future.globalenv.names))
[10:24:37.649]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:37.649]         }, condition = base::local({
[10:24:37.649]             c <- base::c
[10:24:37.649]             inherits <- base::inherits
[10:24:37.649]             invokeRestart <- base::invokeRestart
[10:24:37.649]             length <- base::length
[10:24:37.649]             list <- base::list
[10:24:37.649]             seq.int <- base::seq.int
[10:24:37.649]             signalCondition <- base::signalCondition
[10:24:37.649]             sys.calls <- base::sys.calls
[10:24:37.649]             `[[` <- base::`[[`
[10:24:37.649]             `+` <- base::`+`
[10:24:37.649]             `<<-` <- base::`<<-`
[10:24:37.649]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:37.649]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:37.649]                   3L)]
[10:24:37.649]             }
[10:24:37.649]             function(cond) {
[10:24:37.649]                 is_error <- inherits(cond, "error")
[10:24:37.649]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:37.649]                   NULL)
[10:24:37.649]                 if (is_error) {
[10:24:37.649]                   sessionInformation <- function() {
[10:24:37.649]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:37.649]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:37.649]                       search = base::search(), system = base::Sys.info())
[10:24:37.649]                   }
[10:24:37.649]                   ...future.conditions[[length(...future.conditions) + 
[10:24:37.649]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:37.649]                     cond$call), session = sessionInformation(), 
[10:24:37.649]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:37.649]                   signalCondition(cond)
[10:24:37.649]                 }
[10:24:37.649]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:37.649]                 "immediateCondition"))) {
[10:24:37.649]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:37.649]                   ...future.conditions[[length(...future.conditions) + 
[10:24:37.649]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:37.649]                   if (TRUE && !signal) {
[10:24:37.649]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:37.649]                     {
[10:24:37.649]                       inherits <- base::inherits
[10:24:37.649]                       invokeRestart <- base::invokeRestart
[10:24:37.649]                       is.null <- base::is.null
[10:24:37.649]                       muffled <- FALSE
[10:24:37.649]                       if (inherits(cond, "message")) {
[10:24:37.649]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:37.649]                         if (muffled) 
[10:24:37.649]                           invokeRestart("muffleMessage")
[10:24:37.649]                       }
[10:24:37.649]                       else if (inherits(cond, "warning")) {
[10:24:37.649]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:37.649]                         if (muffled) 
[10:24:37.649]                           invokeRestart("muffleWarning")
[10:24:37.649]                       }
[10:24:37.649]                       else if (inherits(cond, "condition")) {
[10:24:37.649]                         if (!is.null(pattern)) {
[10:24:37.649]                           computeRestarts <- base::computeRestarts
[10:24:37.649]                           grepl <- base::grepl
[10:24:37.649]                           restarts <- computeRestarts(cond)
[10:24:37.649]                           for (restart in restarts) {
[10:24:37.649]                             name <- restart$name
[10:24:37.649]                             if (is.null(name)) 
[10:24:37.649]                               next
[10:24:37.649]                             if (!grepl(pattern, name)) 
[10:24:37.649]                               next
[10:24:37.649]                             invokeRestart(restart)
[10:24:37.649]                             muffled <- TRUE
[10:24:37.649]                             break
[10:24:37.649]                           }
[10:24:37.649]                         }
[10:24:37.649]                       }
[10:24:37.649]                       invisible(muffled)
[10:24:37.649]                     }
[10:24:37.649]                     muffleCondition(cond, pattern = "^muffle")
[10:24:37.649]                   }
[10:24:37.649]                 }
[10:24:37.649]                 else {
[10:24:37.649]                   if (TRUE) {
[10:24:37.649]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:37.649]                     {
[10:24:37.649]                       inherits <- base::inherits
[10:24:37.649]                       invokeRestart <- base::invokeRestart
[10:24:37.649]                       is.null <- base::is.null
[10:24:37.649]                       muffled <- FALSE
[10:24:37.649]                       if (inherits(cond, "message")) {
[10:24:37.649]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:37.649]                         if (muffled) 
[10:24:37.649]                           invokeRestart("muffleMessage")
[10:24:37.649]                       }
[10:24:37.649]                       else if (inherits(cond, "warning")) {
[10:24:37.649]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:37.649]                         if (muffled) 
[10:24:37.649]                           invokeRestart("muffleWarning")
[10:24:37.649]                       }
[10:24:37.649]                       else if (inherits(cond, "condition")) {
[10:24:37.649]                         if (!is.null(pattern)) {
[10:24:37.649]                           computeRestarts <- base::computeRestarts
[10:24:37.649]                           grepl <- base::grepl
[10:24:37.649]                           restarts <- computeRestarts(cond)
[10:24:37.649]                           for (restart in restarts) {
[10:24:37.649]                             name <- restart$name
[10:24:37.649]                             if (is.null(name)) 
[10:24:37.649]                               next
[10:24:37.649]                             if (!grepl(pattern, name)) 
[10:24:37.649]                               next
[10:24:37.649]                             invokeRestart(restart)
[10:24:37.649]                             muffled <- TRUE
[10:24:37.649]                             break
[10:24:37.649]                           }
[10:24:37.649]                         }
[10:24:37.649]                       }
[10:24:37.649]                       invisible(muffled)
[10:24:37.649]                     }
[10:24:37.649]                     muffleCondition(cond, pattern = "^muffle")
[10:24:37.649]                   }
[10:24:37.649]                 }
[10:24:37.649]             }
[10:24:37.649]         }))
[10:24:37.649]     }, error = function(ex) {
[10:24:37.649]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:37.649]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:37.649]                 ...future.rng), started = ...future.startTime, 
[10:24:37.649]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:37.649]             version = "1.8"), class = "FutureResult")
[10:24:37.649]     }, finally = {
[10:24:37.649]         if (!identical(...future.workdir, getwd())) 
[10:24:37.649]             setwd(...future.workdir)
[10:24:37.649]         {
[10:24:37.649]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:37.649]                 ...future.oldOptions$nwarnings <- NULL
[10:24:37.649]             }
[10:24:37.649]             base::options(...future.oldOptions)
[10:24:37.649]             if (.Platform$OS.type == "windows") {
[10:24:37.649]                 old_names <- names(...future.oldEnvVars)
[10:24:37.649]                 envs <- base::Sys.getenv()
[10:24:37.649]                 names <- names(envs)
[10:24:37.649]                 common <- intersect(names, old_names)
[10:24:37.649]                 added <- setdiff(names, old_names)
[10:24:37.649]                 removed <- setdiff(old_names, names)
[10:24:37.649]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:37.649]                   envs[common]]
[10:24:37.649]                 NAMES <- toupper(changed)
[10:24:37.649]                 args <- list()
[10:24:37.649]                 for (kk in seq_along(NAMES)) {
[10:24:37.649]                   name <- changed[[kk]]
[10:24:37.649]                   NAME <- NAMES[[kk]]
[10:24:37.649]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:37.649]                     next
[10:24:37.649]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:37.649]                 }
[10:24:37.649]                 NAMES <- toupper(added)
[10:24:37.649]                 for (kk in seq_along(NAMES)) {
[10:24:37.649]                   name <- added[[kk]]
[10:24:37.649]                   NAME <- NAMES[[kk]]
[10:24:37.649]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:37.649]                     next
[10:24:37.649]                   args[[name]] <- ""
[10:24:37.649]                 }
[10:24:37.649]                 NAMES <- toupper(removed)
[10:24:37.649]                 for (kk in seq_along(NAMES)) {
[10:24:37.649]                   name <- removed[[kk]]
[10:24:37.649]                   NAME <- NAMES[[kk]]
[10:24:37.649]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:37.649]                     next
[10:24:37.649]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:37.649]                 }
[10:24:37.649]                 if (length(args) > 0) 
[10:24:37.649]                   base::do.call(base::Sys.setenv, args = args)
[10:24:37.649]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:37.649]             }
[10:24:37.649]             else {
[10:24:37.649]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:37.649]             }
[10:24:37.649]             {
[10:24:37.649]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:37.649]                   0L) {
[10:24:37.649]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:37.649]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:37.649]                   base::options(opts)
[10:24:37.649]                 }
[10:24:37.649]                 {
[10:24:37.649]                   {
[10:24:37.649]                     NULL
[10:24:37.649]                     RNGkind("Mersenne-Twister")
[10:24:37.649]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:37.649]                       inherits = FALSE)
[10:24:37.649]                   }
[10:24:37.649]                   options(future.plan = NULL)
[10:24:37.649]                   if (is.na(NA_character_)) 
[10:24:37.649]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:37.649]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:37.649]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:37.649]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:37.649]                     envir = parent.frame()) 
[10:24:37.649]                   {
[10:24:37.649]                     if (is.function(workers)) 
[10:24:37.649]                       workers <- workers()
[10:24:37.649]                     workers <- structure(as.integer(workers), 
[10:24:37.649]                       class = class(workers))
[10:24:37.649]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:37.649]                       workers >= 1)
[10:24:37.649]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:37.649]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:37.649]                     }
[10:24:37.649]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:37.649]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:37.649]                       envir = envir)
[10:24:37.649]                     if (!future$lazy) 
[10:24:37.649]                       future <- run(future)
[10:24:37.649]                     invisible(future)
[10:24:37.649]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:37.649]                 }
[10:24:37.649]             }
[10:24:37.649]         }
[10:24:37.649]     })
[10:24:37.649]     if (TRUE) {
[10:24:37.649]         base::sink(type = "output", split = FALSE)
[10:24:37.649]         if (FALSE) {
[10:24:37.649]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:37.649]         }
[10:24:37.649]         else {
[10:24:37.649]             ...future.result["stdout"] <- base::list(NULL)
[10:24:37.649]         }
[10:24:37.649]         base::close(...future.stdout)
[10:24:37.649]         ...future.stdout <- NULL
[10:24:37.649]     }
[10:24:37.649]     ...future.result$conditions <- ...future.conditions
[10:24:37.649]     ...future.result$finished <- base::Sys.time()
[10:24:37.649]     ...future.result
[10:24:37.649] }
[10:24:37.651] assign_globals() ...
[10:24:37.651] List of 5
[10:24:37.651]  $ ...future.FUN            :function (x)  
[10:24:37.651]  $ future.call.arguments    : list()
[10:24:37.651]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:37.651]  $ ...future.elements_ii    :List of 2
[10:24:37.651]   ..$ : int 1
[10:24:37.651]   ..$ : int 0
[10:24:37.651]  $ ...future.seeds_ii       : NULL
[10:24:37.651]  $ ...future.globals.maxSize: NULL
[10:24:37.651]  - attr(*, "where")=List of 5
[10:24:37.651]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:37.651]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:37.651]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:37.651]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:37.651]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:37.651]  - attr(*, "resolved")= logi FALSE
[10:24:37.651]  - attr(*, "total_size")= num 4720
[10:24:37.651]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:37.651]  - attr(*, "already-done")= logi TRUE
[10:24:37.656] - reassign environment for ‘...future.FUN’
[10:24:37.656] - copied ‘...future.FUN’ to environment
[10:24:37.656] - copied ‘future.call.arguments’ to environment
[10:24:37.656] - copied ‘...future.elements_ii’ to environment
[10:24:37.656] - copied ‘...future.seeds_ii’ to environment
[10:24:37.656] - copied ‘...future.globals.maxSize’ to environment
[10:24:37.656] assign_globals() ... done
[10:24:37.657] plan(): Setting new future strategy stack:
[10:24:37.657] List of future strategies:
[10:24:37.657] 1. sequential:
[10:24:37.657]    - args: function (..., envir = parent.frame())
[10:24:37.657]    - tweaked: FALSE
[10:24:37.657]    - call: NULL
[10:24:37.657] plan(): nbrOfWorkers() = 1
[10:24:38.159] plan(): Setting new future strategy stack:
[10:24:38.159] List of future strategies:
[10:24:38.159] 1. multisession:
[10:24:38.159]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:24:38.159]    - tweaked: FALSE
[10:24:38.159]    - call: plan(strategy)
[10:24:38.163] plan(): nbrOfWorkers() = 1
[10:24:38.163] SequentialFuture started (and completed)
[10:24:38.163] - Launch lazy future ... done
[10:24:38.163] run() for ‘SequentialFuture’ ... done
[10:24:38.163] Created future:
[10:24:38.164] SequentialFuture:
[10:24:38.164] Label: ‘future_lapply-1’
[10:24:38.164] Expression:
[10:24:38.164] {
[10:24:38.164]     do.call(function(...) {
[10:24:38.164]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:38.164]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:38.164]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:38.164]             on.exit(options(oopts), add = TRUE)
[10:24:38.164]         }
[10:24:38.164]         {
[10:24:38.164]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:38.164]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:38.164]                 ...future.FUN(...future.X_jj, ...)
[10:24:38.164]             })
[10:24:38.164]         }
[10:24:38.164]     }, args = future.call.arguments)
[10:24:38.164] }
[10:24:38.164] Lazy evaluation: FALSE
[10:24:38.164] Asynchronous evaluation: FALSE
[10:24:38.164] Local evaluation: TRUE
[10:24:38.164] Environment: R_GlobalEnv
[10:24:38.164] Capture standard output: FALSE
[10:24:38.164] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:38.164] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:38.164] Packages: <none>
[10:24:38.164] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:38.164] Resolved: TRUE
[10:24:38.164] Value: 112 bytes of class ‘list’
[10:24:38.164] Early signaling: FALSE
[10:24:38.164] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:38.164] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:38.165] Chunk #1 of 1 ... DONE
[10:24:38.165] Launching 1 futures (chunks) ... DONE
[10:24:38.165] Resolving 1 futures (chunks) ...
[10:24:38.165] resolve() on list ...
[10:24:38.165]  recursive: 0
[10:24:38.165]  length: 1
[10:24:38.165] 
[10:24:38.165] resolved() for ‘SequentialFuture’ ...
[10:24:38.166] - state: ‘finished’
[10:24:38.166] - run: TRUE
[10:24:38.166] - result: ‘FutureResult’
[10:24:38.166] resolved() for ‘SequentialFuture’ ... done
[10:24:38.166] Future #1
[10:24:38.166] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:38.166] - nx: 1
[10:24:38.166] - relay: TRUE
[10:24:38.166] - stdout: TRUE
[10:24:38.166] - signal: TRUE
[10:24:38.167] - resignal: FALSE
[10:24:38.167] - force: TRUE
[10:24:38.167] - relayed: [n=1] FALSE
[10:24:38.167] - queued futures: [n=1] FALSE
[10:24:38.167]  - until=1
[10:24:38.167]  - relaying element #1
[10:24:38.167] - relayed: [n=1] TRUE
[10:24:38.167] - queued futures: [n=1] TRUE
[10:24:38.167] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:38.167]  length: 0 (resolved future 1)
[10:24:38.168] Relaying remaining futures
[10:24:38.168] signalConditionsASAP(NULL, pos=0) ...
[10:24:38.168] - nx: 1
[10:24:38.168] - relay: TRUE
[10:24:38.168] - stdout: TRUE
[10:24:38.168] - signal: TRUE
[10:24:38.169] - resignal: FALSE
[10:24:38.169] - force: TRUE
[10:24:38.169] - relayed: [n=1] TRUE
[10:24:38.169] - queued futures: [n=1] TRUE
 - flush all
[10:24:38.169] - relayed: [n=1] TRUE
[10:24:38.169] - queued futures: [n=1] TRUE
[10:24:38.169] signalConditionsASAP(NULL, pos=0) ... done
[10:24:38.169] resolve() on list ... DONE
[10:24:38.169]  - Number of value chunks collected: 1
[10:24:38.170] Resolving 1 futures (chunks) ... DONE
[10:24:38.170] Reducing values from 1 chunks ...
[10:24:38.170]  - Number of values collected after concatenation: 2
[10:24:38.170]  - Number of values expected: 2
[10:24:38.170] Reducing values from 1 chunks ... DONE
[10:24:38.170] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[10:24:38.170] future_lapply() ...
[10:24:38.175] Number of chunks: 1
[10:24:38.175] getGlobalsAndPackagesXApply() ...
[10:24:38.175]  - future.globals: TRUE
[10:24:38.175] getGlobalsAndPackages() ...
[10:24:38.175] Searching for globals...
[10:24:38.177] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:24:38.177] Searching for globals ... DONE
[10:24:38.177] Resolving globals: FALSE
[10:24:38.177] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[10:24:38.178] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[10:24:38.178] - globals: [1] ‘FUN’
[10:24:38.178] 
[10:24:38.178] getGlobalsAndPackages() ... DONE
[10:24:38.178]  - globals found/used: [n=1] ‘FUN’
[10:24:38.178]  - needed namespaces: [n=0] 
[10:24:38.178] Finding globals ... DONE
[10:24:38.179]  - use_args: TRUE
[10:24:38.179]  - Getting '...' globals ...
[10:24:38.179] resolve() on list ...
[10:24:38.179]  recursive: 0
[10:24:38.179]  length: 1
[10:24:38.179]  elements: ‘...’
[10:24:38.179]  length: 0 (resolved future 1)
[10:24:38.179] resolve() on list ... DONE
[10:24:38.180]    - '...' content: [n=0] 
[10:24:38.180] List of 1
[10:24:38.180]  $ ...: list()
[10:24:38.180]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:38.180]  - attr(*, "where")=List of 1
[10:24:38.180]   ..$ ...:<environment: 0x55d2113619b0> 
[10:24:38.180]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:38.180]  - attr(*, "resolved")= logi TRUE
[10:24:38.180]  - attr(*, "total_size")= num NA
[10:24:38.185]  - Getting '...' globals ... DONE
[10:24:38.185] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:24:38.185] List of 2
[10:24:38.185]  $ ...future.FUN:function (x)  
[10:24:38.185]  $ ...          : list()
[10:24:38.185]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:38.185]  - attr(*, "where")=List of 2
[10:24:38.185]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:38.185]   ..$ ...          :<environment: 0x55d2113619b0> 
[10:24:38.185]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:38.185]  - attr(*, "resolved")= logi FALSE
[10:24:38.185]  - attr(*, "total_size")= num 4720
[10:24:38.188] Packages to be attached in all futures: [n=0] 
[10:24:38.188] getGlobalsAndPackagesXApply() ... DONE
[10:24:38.188] Number of futures (= number of chunks): 1
[10:24:38.188] Launching 1 futures (chunks) ...
[10:24:38.188] Chunk #1 of 1 ...
[10:24:38.189]  - Finding globals in 'X' for chunk #1 ...
[10:24:38.189] getGlobalsAndPackages() ...
[10:24:38.189] Searching for globals...
[10:24:38.189] 
[10:24:38.189] Searching for globals ... DONE
[10:24:38.189] - globals: [0] <none>
[10:24:38.189] getGlobalsAndPackages() ... DONE
[10:24:38.189]    + additional globals found: [n=0] 
[10:24:38.190]    + additional namespaces needed: [n=0] 
[10:24:38.190]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:38.190]  - seeds: <none>
[10:24:38.190]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:38.190] getGlobalsAndPackages() ...
[10:24:38.190] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:38.190] Resolving globals: FALSE
[10:24:38.190] Tweak future expression to call with '...' arguments ...
[10:24:38.190] {
[10:24:38.190]     do.call(function(...) {
[10:24:38.190]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:38.190]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:38.190]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:38.190]             on.exit(options(oopts), add = TRUE)
[10:24:38.190]         }
[10:24:38.190]         {
[10:24:38.190]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:38.190]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:38.190]                 ...future.FUN(...future.X_jj, ...)
[10:24:38.190]             })
[10:24:38.190]         }
[10:24:38.190]     }, args = future.call.arguments)
[10:24:38.190] }
[10:24:38.191] Tweak future expression to call with '...' arguments ... DONE
[10:24:38.191] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:38.191] 
[10:24:38.191] getGlobalsAndPackages() ... DONE
[10:24:38.191] run() for ‘Future’ ...
[10:24:38.192] - state: ‘created’
[10:24:38.192] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:38.195] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:38.195] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:38.195]   - Field: ‘label’
[10:24:38.196]   - Field: ‘local’
[10:24:38.196]   - Field: ‘owner’
[10:24:38.196]   - Field: ‘envir’
[10:24:38.196]   - Field: ‘packages’
[10:24:38.196]   - Field: ‘gc’
[10:24:38.196]   - Field: ‘conditions’
[10:24:38.196]   - Field: ‘expr’
[10:24:38.196]   - Field: ‘uuid’
[10:24:38.196]   - Field: ‘seed’
[10:24:38.196]   - Field: ‘version’
[10:24:38.197]   - Field: ‘result’
[10:24:38.197]   - Field: ‘asynchronous’
[10:24:38.197]   - Field: ‘calls’
[10:24:38.197]   - Field: ‘globals’
[10:24:38.197]   - Field: ‘stdout’
[10:24:38.197]   - Field: ‘earlySignal’
[10:24:38.197]   - Field: ‘lazy’
[10:24:38.197]   - Field: ‘state’
[10:24:38.197] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:38.197] - Launch lazy future ...
[10:24:38.198] Packages needed by the future expression (n = 0): <none>
[10:24:38.198] Packages needed by future strategies (n = 0): <none>
[10:24:38.198] {
[10:24:38.198]     {
[10:24:38.198]         {
[10:24:38.198]             ...future.startTime <- base::Sys.time()
[10:24:38.198]             {
[10:24:38.198]                 {
[10:24:38.198]                   {
[10:24:38.198]                     base::local({
[10:24:38.198]                       has_future <- base::requireNamespace("future", 
[10:24:38.198]                         quietly = TRUE)
[10:24:38.198]                       if (has_future) {
[10:24:38.198]                         ns <- base::getNamespace("future")
[10:24:38.198]                         version <- ns[[".package"]][["version"]]
[10:24:38.198]                         if (is.null(version)) 
[10:24:38.198]                           version <- utils::packageVersion("future")
[10:24:38.198]                       }
[10:24:38.198]                       else {
[10:24:38.198]                         version <- NULL
[10:24:38.198]                       }
[10:24:38.198]                       if (!has_future || version < "1.8.0") {
[10:24:38.198]                         info <- base::c(r_version = base::gsub("R version ", 
[10:24:38.198]                           "", base::R.version$version.string), 
[10:24:38.198]                           platform = base::sprintf("%s (%s-bit)", 
[10:24:38.198]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:38.198]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:38.198]                             "release", "version")], collapse = " "), 
[10:24:38.198]                           hostname = base::Sys.info()[["nodename"]])
[10:24:38.198]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:24:38.198]                           info)
[10:24:38.198]                         info <- base::paste(info, collapse = "; ")
[10:24:38.198]                         if (!has_future) {
[10:24:38.198]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:38.198]                             info)
[10:24:38.198]                         }
[10:24:38.198]                         else {
[10:24:38.198]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:38.198]                             info, version)
[10:24:38.198]                         }
[10:24:38.198]                         base::stop(msg)
[10:24:38.198]                       }
[10:24:38.198]                     })
[10:24:38.198]                   }
[10:24:38.198]                   options(future.plan = NULL)
[10:24:38.198]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:38.198]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:38.198]                 }
[10:24:38.198]                 ...future.workdir <- getwd()
[10:24:38.198]             }
[10:24:38.198]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:38.198]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:38.198]         }
[10:24:38.198]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:38.198]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:38.198]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:38.198]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:38.198]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:38.198]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:38.198]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:38.198]             base::names(...future.oldOptions))
[10:24:38.198]     }
[10:24:38.198]     if (FALSE) {
[10:24:38.198]     }
[10:24:38.198]     else {
[10:24:38.198]         if (TRUE) {
[10:24:38.198]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:38.198]                 open = "w")
[10:24:38.198]         }
[10:24:38.198]         else {
[10:24:38.198]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:38.198]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:38.198]         }
[10:24:38.198]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:38.198]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:38.198]             base::sink(type = "output", split = FALSE)
[10:24:38.198]             base::close(...future.stdout)
[10:24:38.198]         }, add = TRUE)
[10:24:38.198]     }
[10:24:38.198]     ...future.frame <- base::sys.nframe()
[10:24:38.198]     ...future.conditions <- base::list()
[10:24:38.198]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:38.198]     if (FALSE) {
[10:24:38.198]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:38.198]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:38.198]     }
[10:24:38.198]     ...future.result <- base::tryCatch({
[10:24:38.198]         base::withCallingHandlers({
[10:24:38.198]             ...future.value <- base::withVisible(base::local({
[10:24:38.198]                 do.call(function(...) {
[10:24:38.198]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:38.198]                   if (!identical(...future.globals.maxSize.org, 
[10:24:38.198]                     ...future.globals.maxSize)) {
[10:24:38.198]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:38.198]                     on.exit(options(oopts), add = TRUE)
[10:24:38.198]                   }
[10:24:38.198]                   {
[10:24:38.198]                     lapply(seq_along(...future.elements_ii), 
[10:24:38.198]                       FUN = function(jj) {
[10:24:38.198]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:38.198]                         ...future.FUN(...future.X_jj, ...)
[10:24:38.198]                       })
[10:24:38.198]                   }
[10:24:38.198]                 }, args = future.call.arguments)
[10:24:38.198]             }))
[10:24:38.198]             future::FutureResult(value = ...future.value$value, 
[10:24:38.198]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:38.198]                   ...future.rng), globalenv = if (FALSE) 
[10:24:38.198]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:38.198]                     ...future.globalenv.names))
[10:24:38.198]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:38.198]         }, condition = base::local({
[10:24:38.198]             c <- base::c
[10:24:38.198]             inherits <- base::inherits
[10:24:38.198]             invokeRestart <- base::invokeRestart
[10:24:38.198]             length <- base::length
[10:24:38.198]             list <- base::list
[10:24:38.198]             seq.int <- base::seq.int
[10:24:38.198]             signalCondition <- base::signalCondition
[10:24:38.198]             sys.calls <- base::sys.calls
[10:24:38.198]             `[[` <- base::`[[`
[10:24:38.198]             `+` <- base::`+`
[10:24:38.198]             `<<-` <- base::`<<-`
[10:24:38.198]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:38.198]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:38.198]                   3L)]
[10:24:38.198]             }
[10:24:38.198]             function(cond) {
[10:24:38.198]                 is_error <- inherits(cond, "error")
[10:24:38.198]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:38.198]                   NULL)
[10:24:38.198]                 if (is_error) {
[10:24:38.198]                   sessionInformation <- function() {
[10:24:38.198]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:38.198]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:38.198]                       search = base::search(), system = base::Sys.info())
[10:24:38.198]                   }
[10:24:38.198]                   ...future.conditions[[length(...future.conditions) + 
[10:24:38.198]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:38.198]                     cond$call), session = sessionInformation(), 
[10:24:38.198]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:38.198]                   signalCondition(cond)
[10:24:38.198]                 }
[10:24:38.198]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:38.198]                 "immediateCondition"))) {
[10:24:38.198]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:38.198]                   ...future.conditions[[length(...future.conditions) + 
[10:24:38.198]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:38.198]                   if (TRUE && !signal) {
[10:24:38.198]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:38.198]                     {
[10:24:38.198]                       inherits <- base::inherits
[10:24:38.198]                       invokeRestart <- base::invokeRestart
[10:24:38.198]                       is.null <- base::is.null
[10:24:38.198]                       muffled <- FALSE
[10:24:38.198]                       if (inherits(cond, "message")) {
[10:24:38.198]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:38.198]                         if (muffled) 
[10:24:38.198]                           invokeRestart("muffleMessage")
[10:24:38.198]                       }
[10:24:38.198]                       else if (inherits(cond, "warning")) {
[10:24:38.198]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:38.198]                         if (muffled) 
[10:24:38.198]                           invokeRestart("muffleWarning")
[10:24:38.198]                       }
[10:24:38.198]                       else if (inherits(cond, "condition")) {
[10:24:38.198]                         if (!is.null(pattern)) {
[10:24:38.198]                           computeRestarts <- base::computeRestarts
[10:24:38.198]                           grepl <- base::grepl
[10:24:38.198]                           restarts <- computeRestarts(cond)
[10:24:38.198]                           for (restart in restarts) {
[10:24:38.198]                             name <- restart$name
[10:24:38.198]                             if (is.null(name)) 
[10:24:38.198]                               next
[10:24:38.198]                             if (!grepl(pattern, name)) 
[10:24:38.198]                               next
[10:24:38.198]                             invokeRestart(restart)
[10:24:38.198]                             muffled <- TRUE
[10:24:38.198]                             break
[10:24:38.198]                           }
[10:24:38.198]                         }
[10:24:38.198]                       }
[10:24:38.198]                       invisible(muffled)
[10:24:38.198]                     }
[10:24:38.198]                     muffleCondition(cond, pattern = "^muffle")
[10:24:38.198]                   }
[10:24:38.198]                 }
[10:24:38.198]                 else {
[10:24:38.198]                   if (TRUE) {
[10:24:38.198]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:38.198]                     {
[10:24:38.198]                       inherits <- base::inherits
[10:24:38.198]                       invokeRestart <- base::invokeRestart
[10:24:38.198]                       is.null <- base::is.null
[10:24:38.198]                       muffled <- FALSE
[10:24:38.198]                       if (inherits(cond, "message")) {
[10:24:38.198]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:38.198]                         if (muffled) 
[10:24:38.198]                           invokeRestart("muffleMessage")
[10:24:38.198]                       }
[10:24:38.198]                       else if (inherits(cond, "warning")) {
[10:24:38.198]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:38.198]                         if (muffled) 
[10:24:38.198]                           invokeRestart("muffleWarning")
[10:24:38.198]                       }
[10:24:38.198]                       else if (inherits(cond, "condition")) {
[10:24:38.198]                         if (!is.null(pattern)) {
[10:24:38.198]                           computeRestarts <- base::computeRestarts
[10:24:38.198]                           grepl <- base::grepl
[10:24:38.198]                           restarts <- computeRestarts(cond)
[10:24:38.198]                           for (restart in restarts) {
[10:24:38.198]                             name <- restart$name
[10:24:38.198]                             if (is.null(name)) 
[10:24:38.198]                               next
[10:24:38.198]                             if (!grepl(pattern, name)) 
[10:24:38.198]                               next
[10:24:38.198]                             invokeRestart(restart)
[10:24:38.198]                             muffled <- TRUE
[10:24:38.198]                             break
[10:24:38.198]                           }
[10:24:38.198]                         }
[10:24:38.198]                       }
[10:24:38.198]                       invisible(muffled)
[10:24:38.198]                     }
[10:24:38.198]                     muffleCondition(cond, pattern = "^muffle")
[10:24:38.198]                   }
[10:24:38.198]                 }
[10:24:38.198]             }
[10:24:38.198]         }))
[10:24:38.198]     }, error = function(ex) {
[10:24:38.198]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:38.198]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:38.198]                 ...future.rng), started = ...future.startTime, 
[10:24:38.198]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:38.198]             version = "1.8"), class = "FutureResult")
[10:24:38.198]     }, finally = {
[10:24:38.198]         if (!identical(...future.workdir, getwd())) 
[10:24:38.198]             setwd(...future.workdir)
[10:24:38.198]         {
[10:24:38.198]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:38.198]                 ...future.oldOptions$nwarnings <- NULL
[10:24:38.198]             }
[10:24:38.198]             base::options(...future.oldOptions)
[10:24:38.198]             if (.Platform$OS.type == "windows") {
[10:24:38.198]                 old_names <- names(...future.oldEnvVars)
[10:24:38.198]                 envs <- base::Sys.getenv()
[10:24:38.198]                 names <- names(envs)
[10:24:38.198]                 common <- intersect(names, old_names)
[10:24:38.198]                 added <- setdiff(names, old_names)
[10:24:38.198]                 removed <- setdiff(old_names, names)
[10:24:38.198]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:38.198]                   envs[common]]
[10:24:38.198]                 NAMES <- toupper(changed)
[10:24:38.198]                 args <- list()
[10:24:38.198]                 for (kk in seq_along(NAMES)) {
[10:24:38.198]                   name <- changed[[kk]]
[10:24:38.198]                   NAME <- NAMES[[kk]]
[10:24:38.198]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:38.198]                     next
[10:24:38.198]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:38.198]                 }
[10:24:38.198]                 NAMES <- toupper(added)
[10:24:38.198]                 for (kk in seq_along(NAMES)) {
[10:24:38.198]                   name <- added[[kk]]
[10:24:38.198]                   NAME <- NAMES[[kk]]
[10:24:38.198]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:38.198]                     next
[10:24:38.198]                   args[[name]] <- ""
[10:24:38.198]                 }
[10:24:38.198]                 NAMES <- toupper(removed)
[10:24:38.198]                 for (kk in seq_along(NAMES)) {
[10:24:38.198]                   name <- removed[[kk]]
[10:24:38.198]                   NAME <- NAMES[[kk]]
[10:24:38.198]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:38.198]                     next
[10:24:38.198]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:38.198]                 }
[10:24:38.198]                 if (length(args) > 0) 
[10:24:38.198]                   base::do.call(base::Sys.setenv, args = args)
[10:24:38.198]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:38.198]             }
[10:24:38.198]             else {
[10:24:38.198]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:38.198]             }
[10:24:38.198]             {
[10:24:38.198]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:38.198]                   0L) {
[10:24:38.198]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:38.198]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:38.198]                   base::options(opts)
[10:24:38.198]                 }
[10:24:38.198]                 {
[10:24:38.198]                   {
[10:24:38.198]                     NULL
[10:24:38.198]                     RNGkind("Mersenne-Twister")
[10:24:38.198]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:38.198]                       inherits = FALSE)
[10:24:38.198]                   }
[10:24:38.198]                   options(future.plan = NULL)
[10:24:38.198]                   if (is.na(NA_character_)) 
[10:24:38.198]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:38.198]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:38.198]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:38.198]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:38.198]                     envir = parent.frame()) 
[10:24:38.198]                   {
[10:24:38.198]                     if (is.function(workers)) 
[10:24:38.198]                       workers <- workers()
[10:24:38.198]                     workers <- structure(as.integer(workers), 
[10:24:38.198]                       class = class(workers))
[10:24:38.198]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:38.198]                       workers >= 1)
[10:24:38.198]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:38.198]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:38.198]                     }
[10:24:38.198]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:38.198]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:38.198]                       envir = envir)
[10:24:38.198]                     if (!future$lazy) 
[10:24:38.198]                       future <- run(future)
[10:24:38.198]                     invisible(future)
[10:24:38.198]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:38.198]                 }
[10:24:38.198]             }
[10:24:38.198]         }
[10:24:38.198]     })
[10:24:38.198]     if (TRUE) {
[10:24:38.198]         base::sink(type = "output", split = FALSE)
[10:24:38.198]         if (TRUE) {
[10:24:38.198]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:38.198]         }
[10:24:38.198]         else {
[10:24:38.198]             ...future.result["stdout"] <- base::list(NULL)
[10:24:38.198]         }
[10:24:38.198]         base::close(...future.stdout)
[10:24:38.198]         ...future.stdout <- NULL
[10:24:38.198]     }
[10:24:38.198]     ...future.result$conditions <- ...future.conditions
[10:24:38.198]     ...future.result$finished <- base::Sys.time()
[10:24:38.198]     ...future.result
[10:24:38.198] }
[10:24:38.200] assign_globals() ...
[10:24:38.200] List of 5
[10:24:38.200]  $ ...future.FUN            :function (x)  
[10:24:38.200]  $ future.call.arguments    : list()
[10:24:38.200]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:38.200]  $ ...future.elements_ii    :List of 2
[10:24:38.200]   ..$ : int 1
[10:24:38.200]   ..$ : int 0
[10:24:38.200]  $ ...future.seeds_ii       : NULL
[10:24:38.200]  $ ...future.globals.maxSize: NULL
[10:24:38.200]  - attr(*, "where")=List of 5
[10:24:38.200]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:38.200]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:38.200]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:38.200]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:38.200]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:38.200]  - attr(*, "resolved")= logi FALSE
[10:24:38.200]  - attr(*, "total_size")= num 4720
[10:24:38.200]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:38.200]  - attr(*, "already-done")= logi TRUE
[10:24:38.205] - reassign environment for ‘...future.FUN’
[10:24:38.205] - copied ‘...future.FUN’ to environment
[10:24:38.205] - copied ‘future.call.arguments’ to environment
[10:24:38.205] - copied ‘...future.elements_ii’ to environment
[10:24:38.205] - copied ‘...future.seeds_ii’ to environment
[10:24:38.206] - copied ‘...future.globals.maxSize’ to environment
[10:24:38.206] assign_globals() ... done
[10:24:38.206] plan(): Setting new future strategy stack:
[10:24:38.206] List of future strategies:
[10:24:38.206] 1. sequential:
[10:24:38.206]    - args: function (..., envir = parent.frame())
[10:24:38.206]    - tweaked: FALSE
[10:24:38.206]    - call: NULL
[10:24:38.206] plan(): nbrOfWorkers() = 1
[10:24:38.708] plan(): Setting new future strategy stack:
[10:24:38.708] List of future strategies:
[10:24:38.708] 1. multisession:
[10:24:38.708]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:24:38.708]    - tweaked: FALSE
[10:24:38.708]    - call: plan(strategy)
[10:24:38.712] plan(): nbrOfWorkers() = 1
[10:24:38.713] SequentialFuture started (and completed)
[10:24:38.713] - Launch lazy future ... done
[10:24:38.713] run() for ‘SequentialFuture’ ... done
[10:24:38.713] Created future:
[10:24:38.713] SequentialFuture:
[10:24:38.713] Label: ‘future_lapply-1’
[10:24:38.713] Expression:
[10:24:38.713] {
[10:24:38.713]     do.call(function(...) {
[10:24:38.713]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:38.713]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:38.713]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:38.713]             on.exit(options(oopts), add = TRUE)
[10:24:38.713]         }
[10:24:38.713]         {
[10:24:38.713]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:38.713]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:38.713]                 ...future.FUN(...future.X_jj, ...)
[10:24:38.713]             })
[10:24:38.713]         }
[10:24:38.713]     }, args = future.call.arguments)
[10:24:38.713] }
[10:24:38.713] Lazy evaluation: FALSE
[10:24:38.713] Asynchronous evaluation: FALSE
[10:24:38.713] Local evaluation: TRUE
[10:24:38.713] Environment: R_GlobalEnv
[10:24:38.713] Capture standard output: TRUE
[10:24:38.713] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:38.713] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:38.713] Packages: <none>
[10:24:38.713] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:38.713] Resolved: TRUE
[10:24:38.713] Value: 112 bytes of class ‘list’
[10:24:38.713] Early signaling: FALSE
[10:24:38.713] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:38.713] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:38.714] Chunk #1 of 1 ... DONE
[10:24:38.715] Launching 1 futures (chunks) ... DONE
[10:24:38.715] Resolving 1 futures (chunks) ...
[10:24:38.715] resolve() on list ...
[10:24:38.715]  recursive: 0
[10:24:38.715]  length: 1
[10:24:38.715] 
[10:24:38.715] resolved() for ‘SequentialFuture’ ...
[10:24:38.715] - state: ‘finished’
[10:24:38.715] - run: TRUE
[10:24:38.716] - result: ‘FutureResult’
[10:24:38.717] resolved() for ‘SequentialFuture’ ... done
[10:24:38.717] Future #1
[10:24:38.718] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:38.718] - nx: 1
[10:24:38.718] - relay: TRUE
[10:24:38.718] - stdout: TRUE
[10:24:38.718] - signal: TRUE
[10:24:38.718] - resignal: FALSE
[10:24:38.718] - force: TRUE
[10:24:38.718] - relayed: [n=1] FALSE
[10:24:38.718] - queued futures: [n=1] FALSE
[10:24:38.718]  - until=1
[10:24:38.719]  - relaying element #1
[10:24:38.719] - relayed: [n=1] TRUE
[10:24:38.719] - queued futures: [n=1] TRUE
[10:24:38.719] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:38.719]  length: 0 (resolved future 1)
[10:24:38.719] Relaying remaining futures
[10:24:38.719] signalConditionsASAP(NULL, pos=0) ...
[10:24:38.720] - nx: 1
[10:24:38.720] - relay: TRUE
[10:24:38.720] - stdout: TRUE
[10:24:38.720] - signal: TRUE
[10:24:38.720] - resignal: FALSE
[10:24:38.720] - force: TRUE
[10:24:38.720] - relayed: [n=1] TRUE
[10:24:38.720] - queued futures: [n=1] TRUE
 - flush all
[10:24:38.720] - relayed: [n=1] TRUE
[10:24:38.720] - queued futures: [n=1] TRUE
[10:24:38.721] signalConditionsASAP(NULL, pos=0) ... done
[10:24:38.721] resolve() on list ... DONE
[10:24:38.721]  - Number of value chunks collected: 1
[10:24:38.721] Resolving 1 futures (chunks) ... DONE
[10:24:38.721] Reducing values from 1 chunks ...
[10:24:38.721]  - Number of values collected after concatenation: 2
[10:24:38.721]  - Number of values expected: 2
[10:24:38.721] Reducing values from 1 chunks ... DONE
[10:24:38.721] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[10:24:38.722] future_lapply() ...
[10:24:38.726] Number of chunks: 1
[10:24:38.726] getGlobalsAndPackagesXApply() ...
[10:24:38.726]  - future.globals: TRUE
[10:24:38.726] getGlobalsAndPackages() ...
[10:24:38.726] Searching for globals...
[10:24:38.727] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:24:38.728] Searching for globals ... DONE
[10:24:38.728] Resolving globals: FALSE
[10:24:38.728] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[10:24:38.728] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[10:24:38.729] - globals: [1] ‘FUN’
[10:24:38.729] 
[10:24:38.729] getGlobalsAndPackages() ... DONE
[10:24:38.729]  - globals found/used: [n=1] ‘FUN’
[10:24:38.729]  - needed namespaces: [n=0] 
[10:24:38.729] Finding globals ... DONE
[10:24:38.729]  - use_args: TRUE
[10:24:38.729]  - Getting '...' globals ...
[10:24:38.730] resolve() on list ...
[10:24:38.730]  recursive: 0
[10:24:38.730]  length: 1
[10:24:38.730]  elements: ‘...’
[10:24:38.730]  length: 0 (resolved future 1)
[10:24:38.730] resolve() on list ... DONE
[10:24:38.730]    - '...' content: [n=0] 
[10:24:38.730] List of 1
[10:24:38.730]  $ ...: list()
[10:24:38.730]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:38.730]  - attr(*, "where")=List of 1
[10:24:38.730]   ..$ ...:<environment: 0x55d20fffcfe0> 
[10:24:38.730]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:38.730]  - attr(*, "resolved")= logi TRUE
[10:24:38.730]  - attr(*, "total_size")= num NA
[10:24:38.733]  - Getting '...' globals ... DONE
[10:24:38.733] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:24:38.733] List of 2
[10:24:38.733]  $ ...future.FUN:function (x)  
[10:24:38.733]  $ ...          : list()
[10:24:38.733]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:38.733]  - attr(*, "where")=List of 2
[10:24:38.733]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:38.733]   ..$ ...          :<environment: 0x55d20fffcfe0> 
[10:24:38.733]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:38.733]  - attr(*, "resolved")= logi FALSE
[10:24:38.733]  - attr(*, "total_size")= num 4720
[10:24:38.736] Packages to be attached in all futures: [n=0] 
[10:24:38.736] getGlobalsAndPackagesXApply() ... DONE
[10:24:38.736] Number of futures (= number of chunks): 1
[10:24:38.736] Launching 1 futures (chunks) ...
[10:24:38.736] Chunk #1 of 1 ...
[10:24:38.736]  - Finding globals in 'X' for chunk #1 ...
[10:24:38.737] getGlobalsAndPackages() ...
[10:24:38.737] Searching for globals...
[10:24:38.737] 
[10:24:38.737] Searching for globals ... DONE
[10:24:38.737] - globals: [0] <none>
[10:24:38.737] getGlobalsAndPackages() ... DONE
[10:24:38.737]    + additional globals found: [n=0] 
[10:24:38.737]    + additional namespaces needed: [n=0] 
[10:24:38.737]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:38.738]  - seeds: <none>
[10:24:38.738]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:38.738] getGlobalsAndPackages() ...
[10:24:38.738] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:38.738] Resolving globals: FALSE
[10:24:38.738] Tweak future expression to call with '...' arguments ...
[10:24:38.738] {
[10:24:38.738]     do.call(function(...) {
[10:24:38.738]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:38.738]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:38.738]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:38.738]             on.exit(options(oopts), add = TRUE)
[10:24:38.738]         }
[10:24:38.738]         {
[10:24:38.738]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:38.738]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:38.738]                 ...future.FUN(...future.X_jj, ...)
[10:24:38.738]             })
[10:24:38.738]         }
[10:24:38.738]     }, args = future.call.arguments)
[10:24:38.738] }
[10:24:38.739] Tweak future expression to call with '...' arguments ... DONE
[10:24:38.739] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:38.739] 
[10:24:38.739] getGlobalsAndPackages() ... DONE
[10:24:38.739] run() for ‘Future’ ...
[10:24:38.739] - state: ‘created’
[10:24:38.740] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:38.743] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:38.743] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:38.743]   - Field: ‘label’
[10:24:38.744]   - Field: ‘local’
[10:24:38.744]   - Field: ‘owner’
[10:24:38.744]   - Field: ‘envir’
[10:24:38.744]   - Field: ‘packages’
[10:24:38.744]   - Field: ‘gc’
[10:24:38.744]   - Field: ‘conditions’
[10:24:38.744]   - Field: ‘expr’
[10:24:38.744]   - Field: ‘uuid’
[10:24:38.744]   - Field: ‘seed’
[10:24:38.744]   - Field: ‘version’
[10:24:38.745]   - Field: ‘result’
[10:24:38.745]   - Field: ‘asynchronous’
[10:24:38.745]   - Field: ‘calls’
[10:24:38.745]   - Field: ‘globals’
[10:24:38.745]   - Field: ‘stdout’
[10:24:38.745]   - Field: ‘earlySignal’
[10:24:38.745]   - Field: ‘lazy’
[10:24:38.745]   - Field: ‘state’
[10:24:38.745] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:38.745] - Launch lazy future ...
[10:24:38.746] Packages needed by the future expression (n = 0): <none>
[10:24:38.746] Packages needed by future strategies (n = 0): <none>
[10:24:38.746] {
[10:24:38.746]     {
[10:24:38.746]         {
[10:24:38.746]             ...future.startTime <- base::Sys.time()
[10:24:38.746]             {
[10:24:38.746]                 {
[10:24:38.746]                   {
[10:24:38.746]                     base::local({
[10:24:38.746]                       has_future <- base::requireNamespace("future", 
[10:24:38.746]                         quietly = TRUE)
[10:24:38.746]                       if (has_future) {
[10:24:38.746]                         ns <- base::getNamespace("future")
[10:24:38.746]                         version <- ns[[".package"]][["version"]]
[10:24:38.746]                         if (is.null(version)) 
[10:24:38.746]                           version <- utils::packageVersion("future")
[10:24:38.746]                       }
[10:24:38.746]                       else {
[10:24:38.746]                         version <- NULL
[10:24:38.746]                       }
[10:24:38.746]                       if (!has_future || version < "1.8.0") {
[10:24:38.746]                         info <- base::c(r_version = base::gsub("R version ", 
[10:24:38.746]                           "", base::R.version$version.string), 
[10:24:38.746]                           platform = base::sprintf("%s (%s-bit)", 
[10:24:38.746]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:38.746]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:38.746]                             "release", "version")], collapse = " "), 
[10:24:38.746]                           hostname = base::Sys.info()[["nodename"]])
[10:24:38.746]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:24:38.746]                           info)
[10:24:38.746]                         info <- base::paste(info, collapse = "; ")
[10:24:38.746]                         if (!has_future) {
[10:24:38.746]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:38.746]                             info)
[10:24:38.746]                         }
[10:24:38.746]                         else {
[10:24:38.746]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:38.746]                             info, version)
[10:24:38.746]                         }
[10:24:38.746]                         base::stop(msg)
[10:24:38.746]                       }
[10:24:38.746]                     })
[10:24:38.746]                   }
[10:24:38.746]                   options(future.plan = NULL)
[10:24:38.746]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:38.746]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:38.746]                 }
[10:24:38.746]                 ...future.workdir <- getwd()
[10:24:38.746]             }
[10:24:38.746]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:38.746]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:38.746]         }
[10:24:38.746]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:38.746]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:38.746]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:38.746]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:38.746]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:38.746]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:38.746]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:38.746]             base::names(...future.oldOptions))
[10:24:38.746]     }
[10:24:38.746]     if (TRUE) {
[10:24:38.746]     }
[10:24:38.746]     else {
[10:24:38.746]         if (NA) {
[10:24:38.746]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:38.746]                 open = "w")
[10:24:38.746]         }
[10:24:38.746]         else {
[10:24:38.746]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:38.746]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:38.746]         }
[10:24:38.746]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:38.746]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:38.746]             base::sink(type = "output", split = FALSE)
[10:24:38.746]             base::close(...future.stdout)
[10:24:38.746]         }, add = TRUE)
[10:24:38.746]     }
[10:24:38.746]     ...future.frame <- base::sys.nframe()
[10:24:38.746]     ...future.conditions <- base::list()
[10:24:38.746]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:38.746]     if (FALSE) {
[10:24:38.746]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:38.746]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:38.746]     }
[10:24:38.746]     ...future.result <- base::tryCatch({
[10:24:38.746]         base::withCallingHandlers({
[10:24:38.746]             ...future.value <- base::withVisible(base::local({
[10:24:38.746]                 do.call(function(...) {
[10:24:38.746]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:38.746]                   if (!identical(...future.globals.maxSize.org, 
[10:24:38.746]                     ...future.globals.maxSize)) {
[10:24:38.746]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:38.746]                     on.exit(options(oopts), add = TRUE)
[10:24:38.746]                   }
[10:24:38.746]                   {
[10:24:38.746]                     lapply(seq_along(...future.elements_ii), 
[10:24:38.746]                       FUN = function(jj) {
[10:24:38.746]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:38.746]                         ...future.FUN(...future.X_jj, ...)
[10:24:38.746]                       })
[10:24:38.746]                   }
[10:24:38.746]                 }, args = future.call.arguments)
[10:24:38.746]             }))
[10:24:38.746]             future::FutureResult(value = ...future.value$value, 
[10:24:38.746]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:38.746]                   ...future.rng), globalenv = if (FALSE) 
[10:24:38.746]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:38.746]                     ...future.globalenv.names))
[10:24:38.746]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:38.746]         }, condition = base::local({
[10:24:38.746]             c <- base::c
[10:24:38.746]             inherits <- base::inherits
[10:24:38.746]             invokeRestart <- base::invokeRestart
[10:24:38.746]             length <- base::length
[10:24:38.746]             list <- base::list
[10:24:38.746]             seq.int <- base::seq.int
[10:24:38.746]             signalCondition <- base::signalCondition
[10:24:38.746]             sys.calls <- base::sys.calls
[10:24:38.746]             `[[` <- base::`[[`
[10:24:38.746]             `+` <- base::`+`
[10:24:38.746]             `<<-` <- base::`<<-`
[10:24:38.746]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:38.746]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:38.746]                   3L)]
[10:24:38.746]             }
[10:24:38.746]             function(cond) {
[10:24:38.746]                 is_error <- inherits(cond, "error")
[10:24:38.746]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:38.746]                   NULL)
[10:24:38.746]                 if (is_error) {
[10:24:38.746]                   sessionInformation <- function() {
[10:24:38.746]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:38.746]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:38.746]                       search = base::search(), system = base::Sys.info())
[10:24:38.746]                   }
[10:24:38.746]                   ...future.conditions[[length(...future.conditions) + 
[10:24:38.746]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:38.746]                     cond$call), session = sessionInformation(), 
[10:24:38.746]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:38.746]                   signalCondition(cond)
[10:24:38.746]                 }
[10:24:38.746]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:38.746]                 "immediateCondition"))) {
[10:24:38.746]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:38.746]                   ...future.conditions[[length(...future.conditions) + 
[10:24:38.746]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:38.746]                   if (TRUE && !signal) {
[10:24:38.746]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:38.746]                     {
[10:24:38.746]                       inherits <- base::inherits
[10:24:38.746]                       invokeRestart <- base::invokeRestart
[10:24:38.746]                       is.null <- base::is.null
[10:24:38.746]                       muffled <- FALSE
[10:24:38.746]                       if (inherits(cond, "message")) {
[10:24:38.746]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:38.746]                         if (muffled) 
[10:24:38.746]                           invokeRestart("muffleMessage")
[10:24:38.746]                       }
[10:24:38.746]                       else if (inherits(cond, "warning")) {
[10:24:38.746]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:38.746]                         if (muffled) 
[10:24:38.746]                           invokeRestart("muffleWarning")
[10:24:38.746]                       }
[10:24:38.746]                       else if (inherits(cond, "condition")) {
[10:24:38.746]                         if (!is.null(pattern)) {
[10:24:38.746]                           computeRestarts <- base::computeRestarts
[10:24:38.746]                           grepl <- base::grepl
[10:24:38.746]                           restarts <- computeRestarts(cond)
[10:24:38.746]                           for (restart in restarts) {
[10:24:38.746]                             name <- restart$name
[10:24:38.746]                             if (is.null(name)) 
[10:24:38.746]                               next
[10:24:38.746]                             if (!grepl(pattern, name)) 
[10:24:38.746]                               next
[10:24:38.746]                             invokeRestart(restart)
[10:24:38.746]                             muffled <- TRUE
[10:24:38.746]                             break
[10:24:38.746]                           }
[10:24:38.746]                         }
[10:24:38.746]                       }
[10:24:38.746]                       invisible(muffled)
[10:24:38.746]                     }
[10:24:38.746]                     muffleCondition(cond, pattern = "^muffle")
[10:24:38.746]                   }
[10:24:38.746]                 }
[10:24:38.746]                 else {
[10:24:38.746]                   if (TRUE) {
[10:24:38.746]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:38.746]                     {
[10:24:38.746]                       inherits <- base::inherits
[10:24:38.746]                       invokeRestart <- base::invokeRestart
[10:24:38.746]                       is.null <- base::is.null
[10:24:38.746]                       muffled <- FALSE
[10:24:38.746]                       if (inherits(cond, "message")) {
[10:24:38.746]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:38.746]                         if (muffled) 
[10:24:38.746]                           invokeRestart("muffleMessage")
[10:24:38.746]                       }
[10:24:38.746]                       else if (inherits(cond, "warning")) {
[10:24:38.746]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:38.746]                         if (muffled) 
[10:24:38.746]                           invokeRestart("muffleWarning")
[10:24:38.746]                       }
[10:24:38.746]                       else if (inherits(cond, "condition")) {
[10:24:38.746]                         if (!is.null(pattern)) {
[10:24:38.746]                           computeRestarts <- base::computeRestarts
[10:24:38.746]                           grepl <- base::grepl
[10:24:38.746]                           restarts <- computeRestarts(cond)
[10:24:38.746]                           for (restart in restarts) {
[10:24:38.746]                             name <- restart$name
[10:24:38.746]                             if (is.null(name)) 
[10:24:38.746]                               next
[10:24:38.746]                             if (!grepl(pattern, name)) 
[10:24:38.746]                               next
[10:24:38.746]                             invokeRestart(restart)
[10:24:38.746]                             muffled <- TRUE
[10:24:38.746]                             break
[10:24:38.746]                           }
[10:24:38.746]                         }
[10:24:38.746]                       }
[10:24:38.746]                       invisible(muffled)
[10:24:38.746]                     }
[10:24:38.746]                     muffleCondition(cond, pattern = "^muffle")
[10:24:38.746]                   }
[10:24:38.746]                 }
[10:24:38.746]             }
[10:24:38.746]         }))
[10:24:38.746]     }, error = function(ex) {
[10:24:38.746]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:38.746]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:38.746]                 ...future.rng), started = ...future.startTime, 
[10:24:38.746]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:38.746]             version = "1.8"), class = "FutureResult")
[10:24:38.746]     }, finally = {
[10:24:38.746]         if (!identical(...future.workdir, getwd())) 
[10:24:38.746]             setwd(...future.workdir)
[10:24:38.746]         {
[10:24:38.746]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:38.746]                 ...future.oldOptions$nwarnings <- NULL
[10:24:38.746]             }
[10:24:38.746]             base::options(...future.oldOptions)
[10:24:38.746]             if (.Platform$OS.type == "windows") {
[10:24:38.746]                 old_names <- names(...future.oldEnvVars)
[10:24:38.746]                 envs <- base::Sys.getenv()
[10:24:38.746]                 names <- names(envs)
[10:24:38.746]                 common <- intersect(names, old_names)
[10:24:38.746]                 added <- setdiff(names, old_names)
[10:24:38.746]                 removed <- setdiff(old_names, names)
[10:24:38.746]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:38.746]                   envs[common]]
[10:24:38.746]                 NAMES <- toupper(changed)
[10:24:38.746]                 args <- list()
[10:24:38.746]                 for (kk in seq_along(NAMES)) {
[10:24:38.746]                   name <- changed[[kk]]
[10:24:38.746]                   NAME <- NAMES[[kk]]
[10:24:38.746]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:38.746]                     next
[10:24:38.746]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:38.746]                 }
[10:24:38.746]                 NAMES <- toupper(added)
[10:24:38.746]                 for (kk in seq_along(NAMES)) {
[10:24:38.746]                   name <- added[[kk]]
[10:24:38.746]                   NAME <- NAMES[[kk]]
[10:24:38.746]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:38.746]                     next
[10:24:38.746]                   args[[name]] <- ""
[10:24:38.746]                 }
[10:24:38.746]                 NAMES <- toupper(removed)
[10:24:38.746]                 for (kk in seq_along(NAMES)) {
[10:24:38.746]                   name <- removed[[kk]]
[10:24:38.746]                   NAME <- NAMES[[kk]]
[10:24:38.746]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:38.746]                     next
[10:24:38.746]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:38.746]                 }
[10:24:38.746]                 if (length(args) > 0) 
[10:24:38.746]                   base::do.call(base::Sys.setenv, args = args)
[10:24:38.746]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:38.746]             }
[10:24:38.746]             else {
[10:24:38.746]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:38.746]             }
[10:24:38.746]             {
[10:24:38.746]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:38.746]                   0L) {
[10:24:38.746]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:38.746]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:38.746]                   base::options(opts)
[10:24:38.746]                 }
[10:24:38.746]                 {
[10:24:38.746]                   {
[10:24:38.746]                     NULL
[10:24:38.746]                     RNGkind("Mersenne-Twister")
[10:24:38.746]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:38.746]                       inherits = FALSE)
[10:24:38.746]                   }
[10:24:38.746]                   options(future.plan = NULL)
[10:24:38.746]                   if (is.na(NA_character_)) 
[10:24:38.746]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:38.746]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:38.746]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:38.746]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:38.746]                     envir = parent.frame()) 
[10:24:38.746]                   {
[10:24:38.746]                     if (is.function(workers)) 
[10:24:38.746]                       workers <- workers()
[10:24:38.746]                     workers <- structure(as.integer(workers), 
[10:24:38.746]                       class = class(workers))
[10:24:38.746]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:38.746]                       workers >= 1)
[10:24:38.746]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:38.746]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:38.746]                     }
[10:24:38.746]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:38.746]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:38.746]                       envir = envir)
[10:24:38.746]                     if (!future$lazy) 
[10:24:38.746]                       future <- run(future)
[10:24:38.746]                     invisible(future)
[10:24:38.746]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:38.746]                 }
[10:24:38.746]             }
[10:24:38.746]         }
[10:24:38.746]     })
[10:24:38.746]     if (FALSE) {
[10:24:38.746]         base::sink(type = "output", split = FALSE)
[10:24:38.746]         if (NA) {
[10:24:38.746]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:38.746]         }
[10:24:38.746]         else {
[10:24:38.746]             ...future.result["stdout"] <- base::list(NULL)
[10:24:38.746]         }
[10:24:38.746]         base::close(...future.stdout)
[10:24:38.746]         ...future.stdout <- NULL
[10:24:38.746]     }
[10:24:38.746]     ...future.result$conditions <- ...future.conditions
[10:24:38.746]     ...future.result$finished <- base::Sys.time()
[10:24:38.746]     ...future.result
[10:24:38.746] }
[10:24:38.749] assign_globals() ...
[10:24:38.750] List of 5
[10:24:38.750]  $ ...future.FUN            :function (x)  
[10:24:38.750]  $ future.call.arguments    : list()
[10:24:38.750]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:38.750]  $ ...future.elements_ii    :List of 2
[10:24:38.750]   ..$ : int 1
[10:24:38.750]   ..$ : int 0
[10:24:38.750]  $ ...future.seeds_ii       : NULL
[10:24:38.750]  $ ...future.globals.maxSize: NULL
[10:24:38.750]  - attr(*, "where")=List of 5
[10:24:38.750]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:38.750]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:38.750]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:38.750]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:38.750]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:38.750]  - attr(*, "resolved")= logi FALSE
[10:24:38.750]  - attr(*, "total_size")= num 4720
[10:24:38.750]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:38.750]  - attr(*, "already-done")= logi TRUE
[10:24:38.755] - reassign environment for ‘...future.FUN’
[10:24:38.755] - copied ‘...future.FUN’ to environment
[10:24:38.755] - copied ‘future.call.arguments’ to environment
[10:24:38.755] - copied ‘...future.elements_ii’ to environment
[10:24:38.755] - copied ‘...future.seeds_ii’ to environment
[10:24:38.755] - copied ‘...future.globals.maxSize’ to environment
[10:24:38.755] assign_globals() ... done
[10:24:38.756] plan(): Setting new future strategy stack:
[10:24:38.756] List of future strategies:
[10:24:38.756] 1. sequential:
[10:24:38.756]    - args: function (..., envir = parent.frame())
[10:24:38.756]    - tweaked: FALSE
[10:24:38.756]    - call: NULL
[10:24:38.756] plan(): nbrOfWorkers() = 1
[10:24:39.258] plan(): Setting new future strategy stack:
[10:24:39.258] List of future strategies:
[10:24:39.258] 1. multisession:
[10:24:39.258]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:24:39.258]    - tweaked: FALSE
[10:24:39.258]    - call: plan(strategy)
[10:24:39.262] plan(): nbrOfWorkers() = 1
[10:24:39.262] SequentialFuture started (and completed)
[10:24:39.263] - Launch lazy future ... done
[10:24:39.263] run() for ‘SequentialFuture’ ... done
[10:24:39.263] Created future:
[10:24:39.263] SequentialFuture:
[10:24:39.263] Label: ‘future_lapply-1’
[10:24:39.263] Expression:
[10:24:39.263] {
[10:24:39.263]     do.call(function(...) {
[10:24:39.263]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:39.263]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:39.263]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:39.263]             on.exit(options(oopts), add = TRUE)
[10:24:39.263]         }
[10:24:39.263]         {
[10:24:39.263]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:39.263]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:39.263]                 ...future.FUN(...future.X_jj, ...)
[10:24:39.263]             })
[10:24:39.263]         }
[10:24:39.263]     }, args = future.call.arguments)
[10:24:39.263] }
[10:24:39.263] Lazy evaluation: FALSE
[10:24:39.263] Asynchronous evaluation: FALSE
[10:24:39.263] Local evaluation: TRUE
[10:24:39.263] Environment: R_GlobalEnv
[10:24:39.263] Capture standard output: NA
[10:24:39.263] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:39.263] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:39.263] Packages: <none>
[10:24:39.263] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:39.263] Resolved: TRUE
[10:24:39.263] Value: 112 bytes of class ‘list’
[10:24:39.263] Early signaling: FALSE
[10:24:39.263] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:39.263] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:39.264] Chunk #1 of 1 ... DONE
[10:24:39.264] Launching 1 futures (chunks) ... DONE
[10:24:39.264] Resolving 1 futures (chunks) ...
[10:24:39.265] resolve() on list ...
[10:24:39.265]  recursive: 0
[10:24:39.265]  length: 1
[10:24:39.265] 
[10:24:39.265] resolved() for ‘SequentialFuture’ ...
[10:24:39.265] - state: ‘finished’
[10:24:39.265] - run: TRUE
[10:24:39.265] - result: ‘FutureResult’
[10:24:39.265] resolved() for ‘SequentialFuture’ ... done
[10:24:39.265] Future #1
[10:24:39.266] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:39.266] - nx: 1
[10:24:39.266] - relay: TRUE
[10:24:39.266] - stdout: TRUE
[10:24:39.266] - signal: TRUE
[10:24:39.266] - resignal: FALSE
[10:24:39.266] - force: TRUE
[10:24:39.266] - relayed: [n=1] FALSE
[10:24:39.266] - queued futures: [n=1] FALSE
[10:24:39.266]  - until=1
[10:24:39.267]  - relaying element #1
[10:24:39.267] - relayed: [n=1] TRUE
[10:24:39.267] - queued futures: [n=1] TRUE
[10:24:39.267] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:39.267]  length: 0 (resolved future 1)
[10:24:39.267] Relaying remaining futures
[10:24:39.267] signalConditionsASAP(NULL, pos=0) ...
[10:24:39.267] - nx: 1
[10:24:39.267] - relay: TRUE
[10:24:39.267] - stdout: TRUE
[10:24:39.268] - signal: TRUE
[10:24:39.268] - resignal: FALSE
[10:24:39.268] - force: TRUE
[10:24:39.268] - relayed: [n=1] TRUE
[10:24:39.268] - queued futures: [n=1] TRUE
 - flush all
[10:24:39.268] - relayed: [n=1] TRUE
[10:24:39.268] - queued futures: [n=1] TRUE
[10:24:39.268] signalConditionsASAP(NULL, pos=0) ... done
[10:24:39.268] resolve() on list ... DONE
[10:24:39.268]  - Number of value chunks collected: 1
[10:24:39.268] Resolving 1 futures (chunks) ... DONE
[10:24:39.269] Reducing values from 1 chunks ...
[10:24:39.269]  - Number of values collected after concatenation: 2
[10:24:39.269]  - Number of values expected: 2
[10:24:39.269] Reducing values from 1 chunks ... DONE
[10:24:39.269] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[10:24:39.269] future_mapply() ...
[10:24:39.273] Number of chunks: 1
[10:24:39.273] getGlobalsAndPackagesXApply() ...
[10:24:39.273]  - future.globals: TRUE
[10:24:39.273] getGlobalsAndPackages() ...
[10:24:39.273] Searching for globals...
[10:24:39.275] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:24:39.275] Searching for globals ... DONE
[10:24:39.275] Resolving globals: FALSE
[10:24:39.275] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[10:24:39.276] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[10:24:39.276] - globals: [1] ‘FUN’
[10:24:39.276] 
[10:24:39.276] getGlobalsAndPackages() ... DONE
[10:24:39.276]  - globals found/used: [n=1] ‘FUN’
[10:24:39.276]  - needed namespaces: [n=0] 
[10:24:39.276] Finding globals ... DONE
[10:24:39.276] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:24:39.277] List of 2
[10:24:39.277]  $ ...future.FUN:function (x, y)  
[10:24:39.277]  $ MoreArgs     : NULL
[10:24:39.277]  - attr(*, "where")=List of 2
[10:24:39.277]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:39.277]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:24:39.277]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:39.277]  - attr(*, "resolved")= logi FALSE
[10:24:39.277]  - attr(*, "total_size")= num NA
[10:24:39.279] Packages to be attached in all futures: [n=0] 
[10:24:39.279] getGlobalsAndPackagesXApply() ... DONE
[10:24:39.280] Number of futures (= number of chunks): 1
[10:24:39.280] Launching 1 futures (chunks) ...
[10:24:39.280] Chunk #1 of 1 ...
[10:24:39.280]  - Finding globals in '...' for chunk #1 ...
[10:24:39.280] getGlobalsAndPackages() ...
[10:24:39.280] Searching for globals...
[10:24:39.282] 
[10:24:39.282] Searching for globals ... DONE
[10:24:39.282] - globals: [0] <none>
[10:24:39.282] getGlobalsAndPackages() ... DONE
[10:24:39.282]    + additional globals found: [n=0] 
[10:24:39.282]    + additional namespaces needed: [n=0] 
[10:24:39.283]  - Finding globals in '...' for chunk #1 ... DONE
[10:24:39.283]  - seeds: <none>
[10:24:39.283]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:39.283] getGlobalsAndPackages() ...
[10:24:39.283] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:39.283] Resolving globals: FALSE
[10:24:39.284] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[10:24:39.284] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:24:39.284] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:39.285] 
[10:24:39.285] getGlobalsAndPackages() ... DONE
[10:24:39.285] run() for ‘Future’ ...
[10:24:39.285] - state: ‘created’
[10:24:39.285] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:39.288] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:39.289] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:39.289]   - Field: ‘label’
[10:24:39.289]   - Field: ‘local’
[10:24:39.289]   - Field: ‘owner’
[10:24:39.289]   - Field: ‘envir’
[10:24:39.289]   - Field: ‘packages’
[10:24:39.289]   - Field: ‘gc’
[10:24:39.289]   - Field: ‘conditions’
[10:24:39.289]   - Field: ‘expr’
[10:24:39.289]   - Field: ‘uuid’
[10:24:39.290]   - Field: ‘seed’
[10:24:39.290]   - Field: ‘version’
[10:24:39.290]   - Field: ‘result’
[10:24:39.290]   - Field: ‘asynchronous’
[10:24:39.290]   - Field: ‘calls’
[10:24:39.290]   - Field: ‘globals’
[10:24:39.290]   - Field: ‘stdout’
[10:24:39.290]   - Field: ‘earlySignal’
[10:24:39.290]   - Field: ‘lazy’
[10:24:39.290]   - Field: ‘state’
[10:24:39.291] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:39.291] - Launch lazy future ...
[10:24:39.291] Packages needed by the future expression (n = 0): <none>
[10:24:39.291] Packages needed by future strategies (n = 0): <none>
[10:24:39.291] {
[10:24:39.291]     {
[10:24:39.291]         {
[10:24:39.291]             ...future.startTime <- base::Sys.time()
[10:24:39.291]             {
[10:24:39.291]                 {
[10:24:39.291]                   {
[10:24:39.291]                     base::local({
[10:24:39.291]                       has_future <- base::requireNamespace("future", 
[10:24:39.291]                         quietly = TRUE)
[10:24:39.291]                       if (has_future) {
[10:24:39.291]                         ns <- base::getNamespace("future")
[10:24:39.291]                         version <- ns[[".package"]][["version"]]
[10:24:39.291]                         if (is.null(version)) 
[10:24:39.291]                           version <- utils::packageVersion("future")
[10:24:39.291]                       }
[10:24:39.291]                       else {
[10:24:39.291]                         version <- NULL
[10:24:39.291]                       }
[10:24:39.291]                       if (!has_future || version < "1.8.0") {
[10:24:39.291]                         info <- base::c(r_version = base::gsub("R version ", 
[10:24:39.291]                           "", base::R.version$version.string), 
[10:24:39.291]                           platform = base::sprintf("%s (%s-bit)", 
[10:24:39.291]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:39.291]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:39.291]                             "release", "version")], collapse = " "), 
[10:24:39.291]                           hostname = base::Sys.info()[["nodename"]])
[10:24:39.291]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:24:39.291]                           info)
[10:24:39.291]                         info <- base::paste(info, collapse = "; ")
[10:24:39.291]                         if (!has_future) {
[10:24:39.291]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:39.291]                             info)
[10:24:39.291]                         }
[10:24:39.291]                         else {
[10:24:39.291]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:39.291]                             info, version)
[10:24:39.291]                         }
[10:24:39.291]                         base::stop(msg)
[10:24:39.291]                       }
[10:24:39.291]                     })
[10:24:39.291]                   }
[10:24:39.291]                   options(future.plan = NULL)
[10:24:39.291]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:39.291]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:39.291]                 }
[10:24:39.291]                 ...future.workdir <- getwd()
[10:24:39.291]             }
[10:24:39.291]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:39.291]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:39.291]         }
[10:24:39.291]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:39.291]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:39.291]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:39.291]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:39.291]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:39.291]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:39.291]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:39.291]             base::names(...future.oldOptions))
[10:24:39.291]     }
[10:24:39.291]     if (FALSE) {
[10:24:39.291]     }
[10:24:39.291]     else {
[10:24:39.291]         if (FALSE) {
[10:24:39.291]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:39.291]                 open = "w")
[10:24:39.291]         }
[10:24:39.291]         else {
[10:24:39.291]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:39.291]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:39.291]         }
[10:24:39.291]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:39.291]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:39.291]             base::sink(type = "output", split = FALSE)
[10:24:39.291]             base::close(...future.stdout)
[10:24:39.291]         }, add = TRUE)
[10:24:39.291]     }
[10:24:39.291]     ...future.frame <- base::sys.nframe()
[10:24:39.291]     ...future.conditions <- base::list()
[10:24:39.291]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:39.291]     if (FALSE) {
[10:24:39.291]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:39.291]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:39.291]     }
[10:24:39.291]     ...future.result <- base::tryCatch({
[10:24:39.291]         base::withCallingHandlers({
[10:24:39.291]             ...future.value <- base::withVisible(base::local({
[10:24:39.291]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:39.291]                 if (!identical(...future.globals.maxSize.org, 
[10:24:39.291]                   ...future.globals.maxSize)) {
[10:24:39.291]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:39.291]                   on.exit(options(oopts), add = TRUE)
[10:24:39.291]                 }
[10:24:39.291]                 {
[10:24:39.291]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:39.291]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:24:39.291]                     USE.NAMES = FALSE)
[10:24:39.291]                   do.call(mapply, args = args)
[10:24:39.291]                 }
[10:24:39.291]             }))
[10:24:39.291]             future::FutureResult(value = ...future.value$value, 
[10:24:39.291]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:39.291]                   ...future.rng), globalenv = if (FALSE) 
[10:24:39.291]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:39.291]                     ...future.globalenv.names))
[10:24:39.291]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:39.291]         }, condition = base::local({
[10:24:39.291]             c <- base::c
[10:24:39.291]             inherits <- base::inherits
[10:24:39.291]             invokeRestart <- base::invokeRestart
[10:24:39.291]             length <- base::length
[10:24:39.291]             list <- base::list
[10:24:39.291]             seq.int <- base::seq.int
[10:24:39.291]             signalCondition <- base::signalCondition
[10:24:39.291]             sys.calls <- base::sys.calls
[10:24:39.291]             `[[` <- base::`[[`
[10:24:39.291]             `+` <- base::`+`
[10:24:39.291]             `<<-` <- base::`<<-`
[10:24:39.291]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:39.291]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:39.291]                   3L)]
[10:24:39.291]             }
[10:24:39.291]             function(cond) {
[10:24:39.291]                 is_error <- inherits(cond, "error")
[10:24:39.291]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:39.291]                   NULL)
[10:24:39.291]                 if (is_error) {
[10:24:39.291]                   sessionInformation <- function() {
[10:24:39.291]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:39.291]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:39.291]                       search = base::search(), system = base::Sys.info())
[10:24:39.291]                   }
[10:24:39.291]                   ...future.conditions[[length(...future.conditions) + 
[10:24:39.291]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:39.291]                     cond$call), session = sessionInformation(), 
[10:24:39.291]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:39.291]                   signalCondition(cond)
[10:24:39.291]                 }
[10:24:39.291]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:39.291]                 "immediateCondition"))) {
[10:24:39.291]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:39.291]                   ...future.conditions[[length(...future.conditions) + 
[10:24:39.291]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:39.291]                   if (TRUE && !signal) {
[10:24:39.291]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:39.291]                     {
[10:24:39.291]                       inherits <- base::inherits
[10:24:39.291]                       invokeRestart <- base::invokeRestart
[10:24:39.291]                       is.null <- base::is.null
[10:24:39.291]                       muffled <- FALSE
[10:24:39.291]                       if (inherits(cond, "message")) {
[10:24:39.291]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:39.291]                         if (muffled) 
[10:24:39.291]                           invokeRestart("muffleMessage")
[10:24:39.291]                       }
[10:24:39.291]                       else if (inherits(cond, "warning")) {
[10:24:39.291]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:39.291]                         if (muffled) 
[10:24:39.291]                           invokeRestart("muffleWarning")
[10:24:39.291]                       }
[10:24:39.291]                       else if (inherits(cond, "condition")) {
[10:24:39.291]                         if (!is.null(pattern)) {
[10:24:39.291]                           computeRestarts <- base::computeRestarts
[10:24:39.291]                           grepl <- base::grepl
[10:24:39.291]                           restarts <- computeRestarts(cond)
[10:24:39.291]                           for (restart in restarts) {
[10:24:39.291]                             name <- restart$name
[10:24:39.291]                             if (is.null(name)) 
[10:24:39.291]                               next
[10:24:39.291]                             if (!grepl(pattern, name)) 
[10:24:39.291]                               next
[10:24:39.291]                             invokeRestart(restart)
[10:24:39.291]                             muffled <- TRUE
[10:24:39.291]                             break
[10:24:39.291]                           }
[10:24:39.291]                         }
[10:24:39.291]                       }
[10:24:39.291]                       invisible(muffled)
[10:24:39.291]                     }
[10:24:39.291]                     muffleCondition(cond, pattern = "^muffle")
[10:24:39.291]                   }
[10:24:39.291]                 }
[10:24:39.291]                 else {
[10:24:39.291]                   if (TRUE) {
[10:24:39.291]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:39.291]                     {
[10:24:39.291]                       inherits <- base::inherits
[10:24:39.291]                       invokeRestart <- base::invokeRestart
[10:24:39.291]                       is.null <- base::is.null
[10:24:39.291]                       muffled <- FALSE
[10:24:39.291]                       if (inherits(cond, "message")) {
[10:24:39.291]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:39.291]                         if (muffled) 
[10:24:39.291]                           invokeRestart("muffleMessage")
[10:24:39.291]                       }
[10:24:39.291]                       else if (inherits(cond, "warning")) {
[10:24:39.291]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:39.291]                         if (muffled) 
[10:24:39.291]                           invokeRestart("muffleWarning")
[10:24:39.291]                       }
[10:24:39.291]                       else if (inherits(cond, "condition")) {
[10:24:39.291]                         if (!is.null(pattern)) {
[10:24:39.291]                           computeRestarts <- base::computeRestarts
[10:24:39.291]                           grepl <- base::grepl
[10:24:39.291]                           restarts <- computeRestarts(cond)
[10:24:39.291]                           for (restart in restarts) {
[10:24:39.291]                             name <- restart$name
[10:24:39.291]                             if (is.null(name)) 
[10:24:39.291]                               next
[10:24:39.291]                             if (!grepl(pattern, name)) 
[10:24:39.291]                               next
[10:24:39.291]                             invokeRestart(restart)
[10:24:39.291]                             muffled <- TRUE
[10:24:39.291]                             break
[10:24:39.291]                           }
[10:24:39.291]                         }
[10:24:39.291]                       }
[10:24:39.291]                       invisible(muffled)
[10:24:39.291]                     }
[10:24:39.291]                     muffleCondition(cond, pattern = "^muffle")
[10:24:39.291]                   }
[10:24:39.291]                 }
[10:24:39.291]             }
[10:24:39.291]         }))
[10:24:39.291]     }, error = function(ex) {
[10:24:39.291]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:39.291]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:39.291]                 ...future.rng), started = ...future.startTime, 
[10:24:39.291]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:39.291]             version = "1.8"), class = "FutureResult")
[10:24:39.291]     }, finally = {
[10:24:39.291]         if (!identical(...future.workdir, getwd())) 
[10:24:39.291]             setwd(...future.workdir)
[10:24:39.291]         {
[10:24:39.291]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:39.291]                 ...future.oldOptions$nwarnings <- NULL
[10:24:39.291]             }
[10:24:39.291]             base::options(...future.oldOptions)
[10:24:39.291]             if (.Platform$OS.type == "windows") {
[10:24:39.291]                 old_names <- names(...future.oldEnvVars)
[10:24:39.291]                 envs <- base::Sys.getenv()
[10:24:39.291]                 names <- names(envs)
[10:24:39.291]                 common <- intersect(names, old_names)
[10:24:39.291]                 added <- setdiff(names, old_names)
[10:24:39.291]                 removed <- setdiff(old_names, names)
[10:24:39.291]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:39.291]                   envs[common]]
[10:24:39.291]                 NAMES <- toupper(changed)
[10:24:39.291]                 args <- list()
[10:24:39.291]                 for (kk in seq_along(NAMES)) {
[10:24:39.291]                   name <- changed[[kk]]
[10:24:39.291]                   NAME <- NAMES[[kk]]
[10:24:39.291]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:39.291]                     next
[10:24:39.291]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:39.291]                 }
[10:24:39.291]                 NAMES <- toupper(added)
[10:24:39.291]                 for (kk in seq_along(NAMES)) {
[10:24:39.291]                   name <- added[[kk]]
[10:24:39.291]                   NAME <- NAMES[[kk]]
[10:24:39.291]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:39.291]                     next
[10:24:39.291]                   args[[name]] <- ""
[10:24:39.291]                 }
[10:24:39.291]                 NAMES <- toupper(removed)
[10:24:39.291]                 for (kk in seq_along(NAMES)) {
[10:24:39.291]                   name <- removed[[kk]]
[10:24:39.291]                   NAME <- NAMES[[kk]]
[10:24:39.291]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:39.291]                     next
[10:24:39.291]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:39.291]                 }
[10:24:39.291]                 if (length(args) > 0) 
[10:24:39.291]                   base::do.call(base::Sys.setenv, args = args)
[10:24:39.291]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:39.291]             }
[10:24:39.291]             else {
[10:24:39.291]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:39.291]             }
[10:24:39.291]             {
[10:24:39.291]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:39.291]                   0L) {
[10:24:39.291]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:39.291]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:39.291]                   base::options(opts)
[10:24:39.291]                 }
[10:24:39.291]                 {
[10:24:39.291]                   {
[10:24:39.291]                     NULL
[10:24:39.291]                     RNGkind("Mersenne-Twister")
[10:24:39.291]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:39.291]                       inherits = FALSE)
[10:24:39.291]                   }
[10:24:39.291]                   options(future.plan = NULL)
[10:24:39.291]                   if (is.na(NA_character_)) 
[10:24:39.291]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:39.291]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:39.291]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:39.291]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:39.291]                     envir = parent.frame()) 
[10:24:39.291]                   {
[10:24:39.291]                     if (is.function(workers)) 
[10:24:39.291]                       workers <- workers()
[10:24:39.291]                     workers <- structure(as.integer(workers), 
[10:24:39.291]                       class = class(workers))
[10:24:39.291]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:39.291]                       workers >= 1)
[10:24:39.291]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:39.291]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:39.291]                     }
[10:24:39.291]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:39.291]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:39.291]                       envir = envir)
[10:24:39.291]                     if (!future$lazy) 
[10:24:39.291]                       future <- run(future)
[10:24:39.291]                     invisible(future)
[10:24:39.291]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:39.291]                 }
[10:24:39.291]             }
[10:24:39.291]         }
[10:24:39.291]     })
[10:24:39.291]     if (TRUE) {
[10:24:39.291]         base::sink(type = "output", split = FALSE)
[10:24:39.291]         if (FALSE) {
[10:24:39.291]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:39.291]         }
[10:24:39.291]         else {
[10:24:39.291]             ...future.result["stdout"] <- base::list(NULL)
[10:24:39.291]         }
[10:24:39.291]         base::close(...future.stdout)
[10:24:39.291]         ...future.stdout <- NULL
[10:24:39.291]     }
[10:24:39.291]     ...future.result$conditions <- ...future.conditions
[10:24:39.291]     ...future.result$finished <- base::Sys.time()
[10:24:39.291]     ...future.result
[10:24:39.291] }
[10:24:39.293] assign_globals() ...
[10:24:39.293] List of 5
[10:24:39.293]  $ ...future.FUN            :function (x, y)  
[10:24:39.293]  $ MoreArgs                 : NULL
[10:24:39.293]  $ ...future.elements_ii    :List of 2
[10:24:39.293]   ..$ :List of 2
[10:24:39.293]   .. ..$ : int 1
[10:24:39.293]   .. ..$ : int 0
[10:24:39.293]   ..$ :List of 2
[10:24:39.293]   .. ..$ : int 0
[10:24:39.293]   .. ..$ : int 1
[10:24:39.293]  $ ...future.seeds_ii       : NULL
[10:24:39.293]  $ ...future.globals.maxSize: NULL
[10:24:39.293]  - attr(*, "where")=List of 5
[10:24:39.293]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:39.293]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:24:39.293]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:39.293]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:39.293]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:39.293]  - attr(*, "resolved")= logi FALSE
[10:24:39.293]  - attr(*, "total_size")= num 6480
[10:24:39.293]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:39.293]  - attr(*, "already-done")= logi TRUE
[10:24:39.299] - reassign environment for ‘...future.FUN’
[10:24:39.299] - copied ‘...future.FUN’ to environment
[10:24:39.299] - copied ‘MoreArgs’ to environment
[10:24:39.299] - copied ‘...future.elements_ii’ to environment
[10:24:39.299] - copied ‘...future.seeds_ii’ to environment
[10:24:39.299] - copied ‘...future.globals.maxSize’ to environment
[10:24:39.300] assign_globals() ... done
[10:24:39.300] plan(): Setting new future strategy stack:
[10:24:39.300] List of future strategies:
[10:24:39.300] 1. sequential:
[10:24:39.300]    - args: function (..., envir = parent.frame())
[10:24:39.300]    - tweaked: FALSE
[10:24:39.300]    - call: NULL
[10:24:39.300] plan(): nbrOfWorkers() = 1
[10:24:39.802] plan(): Setting new future strategy stack:
[10:24:39.802] List of future strategies:
[10:24:39.802] 1. multisession:
[10:24:39.802]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:24:39.802]    - tweaked: FALSE
[10:24:39.802]    - call: plan(strategy)
[10:24:39.806] plan(): nbrOfWorkers() = 1
[10:24:39.806] SequentialFuture started (and completed)
[10:24:39.807] - Launch lazy future ... done
[10:24:39.807] run() for ‘SequentialFuture’ ... done
[10:24:39.807] Created future:
[10:24:39.807] SequentialFuture:
[10:24:39.807] Label: ‘future_mapply-1’
[10:24:39.807] Expression:
[10:24:39.807] {
[10:24:39.807]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:39.807]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:39.807]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:39.807]         on.exit(options(oopts), add = TRUE)
[10:24:39.807]     }
[10:24:39.807]     {
[10:24:39.807]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:39.807]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:24:39.807]         do.call(mapply, args = args)
[10:24:39.807]     }
[10:24:39.807] }
[10:24:39.807] Lazy evaluation: FALSE
[10:24:39.807] Asynchronous evaluation: FALSE
[10:24:39.807] Local evaluation: TRUE
[10:24:39.807] Environment: R_GlobalEnv
[10:24:39.807] Capture standard output: FALSE
[10:24:39.807] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:39.807] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:39.807] Packages: <none>
[10:24:39.807] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:39.807] Resolved: TRUE
[10:24:39.807] Value: 224 bytes of class ‘list’
[10:24:39.807] Early signaling: FALSE
[10:24:39.807] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:39.807] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:39.808] Chunk #1 of 1 ... DONE
[10:24:39.808] Launching 1 futures (chunks) ... DONE
[10:24:39.808] Resolving 1 futures (chunks) ...
[10:24:39.808] resolve() on list ...
[10:24:39.808]  recursive: 0
[10:24:39.808]  length: 1
[10:24:39.809] 
[10:24:39.809] resolved() for ‘SequentialFuture’ ...
[10:24:39.809] - state: ‘finished’
[10:24:39.809] - run: TRUE
[10:24:39.809] - result: ‘FutureResult’
[10:24:39.809] resolved() for ‘SequentialFuture’ ... done
[10:24:39.809] Future #1
[10:24:39.809] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:39.809] - nx: 1
[10:24:39.810] - relay: TRUE
[10:24:39.810] - stdout: TRUE
[10:24:39.810] - signal: TRUE
[10:24:39.810] - resignal: FALSE
[10:24:39.810] - force: TRUE
[10:24:39.810] - relayed: [n=1] FALSE
[10:24:39.810] - queued futures: [n=1] FALSE
[10:24:39.810]  - until=1
[10:24:39.810]  - relaying element #1
[10:24:39.810] - relayed: [n=1] TRUE
[10:24:39.810] - queued futures: [n=1] TRUE
[10:24:39.811] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:39.811]  length: 0 (resolved future 1)
[10:24:39.811] Relaying remaining futures
[10:24:39.811] signalConditionsASAP(NULL, pos=0) ...
[10:24:39.811] - nx: 1
[10:24:39.811] - relay: TRUE
[10:24:39.811] - stdout: TRUE
[10:24:39.811] - signal: TRUE
[10:24:39.811] - resignal: FALSE
[10:24:39.811] - force: TRUE
[10:24:39.811] - relayed: [n=1] TRUE
[10:24:39.812] - queued futures: [n=1] TRUE
 - flush all
[10:24:39.812] - relayed: [n=1] TRUE
[10:24:39.812] - queued futures: [n=1] TRUE
[10:24:39.812] signalConditionsASAP(NULL, pos=0) ... done
[10:24:39.812] resolve() on list ... DONE
[10:24:39.812]  - Number of value chunks collected: 1
[10:24:39.812] Resolving 1 futures (chunks) ... DONE
[10:24:39.812] Reducing values from 1 chunks ...
[10:24:39.812]  - Number of values collected after concatenation: 2
[10:24:39.812]  - Number of values expected: 2
[10:24:39.813] Reducing values from 1 chunks ... DONE
[10:24:39.813] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[10:24:39.813] future_mapply() ...
[10:24:39.818] Number of chunks: 1
[10:24:39.818] getGlobalsAndPackagesXApply() ...
[10:24:39.818]  - future.globals: TRUE
[10:24:39.818] getGlobalsAndPackages() ...
[10:24:39.818] Searching for globals...
[10:24:39.820] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:24:39.820] Searching for globals ... DONE
[10:24:39.820] Resolving globals: FALSE
[10:24:39.821] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[10:24:39.821] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[10:24:39.821] - globals: [1] ‘FUN’
[10:24:39.821] 
[10:24:39.821] getGlobalsAndPackages() ... DONE
[10:24:39.822]  - globals found/used: [n=1] ‘FUN’
[10:24:39.822]  - needed namespaces: [n=0] 
[10:24:39.822] Finding globals ... DONE
[10:24:39.822] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:24:39.822] List of 2
[10:24:39.822]  $ ...future.FUN:function (x, y)  
[10:24:39.822]  $ MoreArgs     : NULL
[10:24:39.822]  - attr(*, "where")=List of 2
[10:24:39.822]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:39.822]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:24:39.822]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:39.822]  - attr(*, "resolved")= logi FALSE
[10:24:39.822]  - attr(*, "total_size")= num NA
[10:24:39.825] Packages to be attached in all futures: [n=0] 
[10:24:39.825] getGlobalsAndPackagesXApply() ... DONE
[10:24:39.825] Number of futures (= number of chunks): 1
[10:24:39.825] Launching 1 futures (chunks) ...
[10:24:39.825] Chunk #1 of 1 ...
[10:24:39.825]  - Finding globals in '...' for chunk #1 ...
[10:24:39.825] getGlobalsAndPackages() ...
[10:24:39.826] Searching for globals...
[10:24:39.826] 
[10:24:39.826] Searching for globals ... DONE
[10:24:39.826] - globals: [0] <none>
[10:24:39.826] getGlobalsAndPackages() ... DONE
[10:24:39.826]    + additional globals found: [n=0] 
[10:24:39.826]    + additional namespaces needed: [n=0] 
[10:24:39.826]  - Finding globals in '...' for chunk #1 ... DONE
[10:24:39.826]  - seeds: <none>
[10:24:39.827]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:39.827] getGlobalsAndPackages() ...
[10:24:39.827] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:39.827] Resolving globals: FALSE
[10:24:39.827] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[10:24:39.828] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:24:39.828] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:39.828] 
[10:24:39.828] getGlobalsAndPackages() ... DONE
[10:24:39.828] run() for ‘Future’ ...
[10:24:39.828] - state: ‘created’
[10:24:39.829] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:39.832] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:39.832] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:39.832]   - Field: ‘label’
[10:24:39.832]   - Field: ‘local’
[10:24:39.832]   - Field: ‘owner’
[10:24:39.833]   - Field: ‘envir’
[10:24:39.833]   - Field: ‘packages’
[10:24:39.833]   - Field: ‘gc’
[10:24:39.833]   - Field: ‘conditions’
[10:24:39.833]   - Field: ‘expr’
[10:24:39.833]   - Field: ‘uuid’
[10:24:39.833]   - Field: ‘seed’
[10:24:39.833]   - Field: ‘version’
[10:24:39.833]   - Field: ‘result’
[10:24:39.833]   - Field: ‘asynchronous’
[10:24:39.833]   - Field: ‘calls’
[10:24:39.834]   - Field: ‘globals’
[10:24:39.834]   - Field: ‘stdout’
[10:24:39.834]   - Field: ‘earlySignal’
[10:24:39.834]   - Field: ‘lazy’
[10:24:39.834]   - Field: ‘state’
[10:24:39.834] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:39.834] - Launch lazy future ...
[10:24:39.834] Packages needed by the future expression (n = 0): <none>
[10:24:39.834] Packages needed by future strategies (n = 0): <none>
[10:24:39.835] {
[10:24:39.835]     {
[10:24:39.835]         {
[10:24:39.835]             ...future.startTime <- base::Sys.time()
[10:24:39.835]             {
[10:24:39.835]                 {
[10:24:39.835]                   {
[10:24:39.835]                     base::local({
[10:24:39.835]                       has_future <- base::requireNamespace("future", 
[10:24:39.835]                         quietly = TRUE)
[10:24:39.835]                       if (has_future) {
[10:24:39.835]                         ns <- base::getNamespace("future")
[10:24:39.835]                         version <- ns[[".package"]][["version"]]
[10:24:39.835]                         if (is.null(version)) 
[10:24:39.835]                           version <- utils::packageVersion("future")
[10:24:39.835]                       }
[10:24:39.835]                       else {
[10:24:39.835]                         version <- NULL
[10:24:39.835]                       }
[10:24:39.835]                       if (!has_future || version < "1.8.0") {
[10:24:39.835]                         info <- base::c(r_version = base::gsub("R version ", 
[10:24:39.835]                           "", base::R.version$version.string), 
[10:24:39.835]                           platform = base::sprintf("%s (%s-bit)", 
[10:24:39.835]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:39.835]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:39.835]                             "release", "version")], collapse = " "), 
[10:24:39.835]                           hostname = base::Sys.info()[["nodename"]])
[10:24:39.835]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:24:39.835]                           info)
[10:24:39.835]                         info <- base::paste(info, collapse = "; ")
[10:24:39.835]                         if (!has_future) {
[10:24:39.835]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:39.835]                             info)
[10:24:39.835]                         }
[10:24:39.835]                         else {
[10:24:39.835]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:39.835]                             info, version)
[10:24:39.835]                         }
[10:24:39.835]                         base::stop(msg)
[10:24:39.835]                       }
[10:24:39.835]                     })
[10:24:39.835]                   }
[10:24:39.835]                   options(future.plan = NULL)
[10:24:39.835]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:39.835]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:39.835]                 }
[10:24:39.835]                 ...future.workdir <- getwd()
[10:24:39.835]             }
[10:24:39.835]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:39.835]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:39.835]         }
[10:24:39.835]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:39.835]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:39.835]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:39.835]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:39.835]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:39.835]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:39.835]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:39.835]             base::names(...future.oldOptions))
[10:24:39.835]     }
[10:24:39.835]     if (FALSE) {
[10:24:39.835]     }
[10:24:39.835]     else {
[10:24:39.835]         if (TRUE) {
[10:24:39.835]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:39.835]                 open = "w")
[10:24:39.835]         }
[10:24:39.835]         else {
[10:24:39.835]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:39.835]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:39.835]         }
[10:24:39.835]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:39.835]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:39.835]             base::sink(type = "output", split = FALSE)
[10:24:39.835]             base::close(...future.stdout)
[10:24:39.835]         }, add = TRUE)
[10:24:39.835]     }
[10:24:39.835]     ...future.frame <- base::sys.nframe()
[10:24:39.835]     ...future.conditions <- base::list()
[10:24:39.835]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:39.835]     if (FALSE) {
[10:24:39.835]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:39.835]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:39.835]     }
[10:24:39.835]     ...future.result <- base::tryCatch({
[10:24:39.835]         base::withCallingHandlers({
[10:24:39.835]             ...future.value <- base::withVisible(base::local({
[10:24:39.835]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:39.835]                 if (!identical(...future.globals.maxSize.org, 
[10:24:39.835]                   ...future.globals.maxSize)) {
[10:24:39.835]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:39.835]                   on.exit(options(oopts), add = TRUE)
[10:24:39.835]                 }
[10:24:39.835]                 {
[10:24:39.835]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:39.835]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:24:39.835]                     USE.NAMES = FALSE)
[10:24:39.835]                   do.call(mapply, args = args)
[10:24:39.835]                 }
[10:24:39.835]             }))
[10:24:39.835]             future::FutureResult(value = ...future.value$value, 
[10:24:39.835]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:39.835]                   ...future.rng), globalenv = if (FALSE) 
[10:24:39.835]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:39.835]                     ...future.globalenv.names))
[10:24:39.835]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:39.835]         }, condition = base::local({
[10:24:39.835]             c <- base::c
[10:24:39.835]             inherits <- base::inherits
[10:24:39.835]             invokeRestart <- base::invokeRestart
[10:24:39.835]             length <- base::length
[10:24:39.835]             list <- base::list
[10:24:39.835]             seq.int <- base::seq.int
[10:24:39.835]             signalCondition <- base::signalCondition
[10:24:39.835]             sys.calls <- base::sys.calls
[10:24:39.835]             `[[` <- base::`[[`
[10:24:39.835]             `+` <- base::`+`
[10:24:39.835]             `<<-` <- base::`<<-`
[10:24:39.835]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:39.835]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:39.835]                   3L)]
[10:24:39.835]             }
[10:24:39.835]             function(cond) {
[10:24:39.835]                 is_error <- inherits(cond, "error")
[10:24:39.835]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:39.835]                   NULL)
[10:24:39.835]                 if (is_error) {
[10:24:39.835]                   sessionInformation <- function() {
[10:24:39.835]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:39.835]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:39.835]                       search = base::search(), system = base::Sys.info())
[10:24:39.835]                   }
[10:24:39.835]                   ...future.conditions[[length(...future.conditions) + 
[10:24:39.835]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:39.835]                     cond$call), session = sessionInformation(), 
[10:24:39.835]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:39.835]                   signalCondition(cond)
[10:24:39.835]                 }
[10:24:39.835]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:39.835]                 "immediateCondition"))) {
[10:24:39.835]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:39.835]                   ...future.conditions[[length(...future.conditions) + 
[10:24:39.835]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:39.835]                   if (TRUE && !signal) {
[10:24:39.835]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:39.835]                     {
[10:24:39.835]                       inherits <- base::inherits
[10:24:39.835]                       invokeRestart <- base::invokeRestart
[10:24:39.835]                       is.null <- base::is.null
[10:24:39.835]                       muffled <- FALSE
[10:24:39.835]                       if (inherits(cond, "message")) {
[10:24:39.835]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:39.835]                         if (muffled) 
[10:24:39.835]                           invokeRestart("muffleMessage")
[10:24:39.835]                       }
[10:24:39.835]                       else if (inherits(cond, "warning")) {
[10:24:39.835]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:39.835]                         if (muffled) 
[10:24:39.835]                           invokeRestart("muffleWarning")
[10:24:39.835]                       }
[10:24:39.835]                       else if (inherits(cond, "condition")) {
[10:24:39.835]                         if (!is.null(pattern)) {
[10:24:39.835]                           computeRestarts <- base::computeRestarts
[10:24:39.835]                           grepl <- base::grepl
[10:24:39.835]                           restarts <- computeRestarts(cond)
[10:24:39.835]                           for (restart in restarts) {
[10:24:39.835]                             name <- restart$name
[10:24:39.835]                             if (is.null(name)) 
[10:24:39.835]                               next
[10:24:39.835]                             if (!grepl(pattern, name)) 
[10:24:39.835]                               next
[10:24:39.835]                             invokeRestart(restart)
[10:24:39.835]                             muffled <- TRUE
[10:24:39.835]                             break
[10:24:39.835]                           }
[10:24:39.835]                         }
[10:24:39.835]                       }
[10:24:39.835]                       invisible(muffled)
[10:24:39.835]                     }
[10:24:39.835]                     muffleCondition(cond, pattern = "^muffle")
[10:24:39.835]                   }
[10:24:39.835]                 }
[10:24:39.835]                 else {
[10:24:39.835]                   if (TRUE) {
[10:24:39.835]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:39.835]                     {
[10:24:39.835]                       inherits <- base::inherits
[10:24:39.835]                       invokeRestart <- base::invokeRestart
[10:24:39.835]                       is.null <- base::is.null
[10:24:39.835]                       muffled <- FALSE
[10:24:39.835]                       if (inherits(cond, "message")) {
[10:24:39.835]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:39.835]                         if (muffled) 
[10:24:39.835]                           invokeRestart("muffleMessage")
[10:24:39.835]                       }
[10:24:39.835]                       else if (inherits(cond, "warning")) {
[10:24:39.835]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:39.835]                         if (muffled) 
[10:24:39.835]                           invokeRestart("muffleWarning")
[10:24:39.835]                       }
[10:24:39.835]                       else if (inherits(cond, "condition")) {
[10:24:39.835]                         if (!is.null(pattern)) {
[10:24:39.835]                           computeRestarts <- base::computeRestarts
[10:24:39.835]                           grepl <- base::grepl
[10:24:39.835]                           restarts <- computeRestarts(cond)
[10:24:39.835]                           for (restart in restarts) {
[10:24:39.835]                             name <- restart$name
[10:24:39.835]                             if (is.null(name)) 
[10:24:39.835]                               next
[10:24:39.835]                             if (!grepl(pattern, name)) 
[10:24:39.835]                               next
[10:24:39.835]                             invokeRestart(restart)
[10:24:39.835]                             muffled <- TRUE
[10:24:39.835]                             break
[10:24:39.835]                           }
[10:24:39.835]                         }
[10:24:39.835]                       }
[10:24:39.835]                       invisible(muffled)
[10:24:39.835]                     }
[10:24:39.835]                     muffleCondition(cond, pattern = "^muffle")
[10:24:39.835]                   }
[10:24:39.835]                 }
[10:24:39.835]             }
[10:24:39.835]         }))
[10:24:39.835]     }, error = function(ex) {
[10:24:39.835]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:39.835]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:39.835]                 ...future.rng), started = ...future.startTime, 
[10:24:39.835]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:39.835]             version = "1.8"), class = "FutureResult")
[10:24:39.835]     }, finally = {
[10:24:39.835]         if (!identical(...future.workdir, getwd())) 
[10:24:39.835]             setwd(...future.workdir)
[10:24:39.835]         {
[10:24:39.835]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:39.835]                 ...future.oldOptions$nwarnings <- NULL
[10:24:39.835]             }
[10:24:39.835]             base::options(...future.oldOptions)
[10:24:39.835]             if (.Platform$OS.type == "windows") {
[10:24:39.835]                 old_names <- names(...future.oldEnvVars)
[10:24:39.835]                 envs <- base::Sys.getenv()
[10:24:39.835]                 names <- names(envs)
[10:24:39.835]                 common <- intersect(names, old_names)
[10:24:39.835]                 added <- setdiff(names, old_names)
[10:24:39.835]                 removed <- setdiff(old_names, names)
[10:24:39.835]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:39.835]                   envs[common]]
[10:24:39.835]                 NAMES <- toupper(changed)
[10:24:39.835]                 args <- list()
[10:24:39.835]                 for (kk in seq_along(NAMES)) {
[10:24:39.835]                   name <- changed[[kk]]
[10:24:39.835]                   NAME <- NAMES[[kk]]
[10:24:39.835]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:39.835]                     next
[10:24:39.835]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:39.835]                 }
[10:24:39.835]                 NAMES <- toupper(added)
[10:24:39.835]                 for (kk in seq_along(NAMES)) {
[10:24:39.835]                   name <- added[[kk]]
[10:24:39.835]                   NAME <- NAMES[[kk]]
[10:24:39.835]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:39.835]                     next
[10:24:39.835]                   args[[name]] <- ""
[10:24:39.835]                 }
[10:24:39.835]                 NAMES <- toupper(removed)
[10:24:39.835]                 for (kk in seq_along(NAMES)) {
[10:24:39.835]                   name <- removed[[kk]]
[10:24:39.835]                   NAME <- NAMES[[kk]]
[10:24:39.835]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:39.835]                     next
[10:24:39.835]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:39.835]                 }
[10:24:39.835]                 if (length(args) > 0) 
[10:24:39.835]                   base::do.call(base::Sys.setenv, args = args)
[10:24:39.835]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:39.835]             }
[10:24:39.835]             else {
[10:24:39.835]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:39.835]             }
[10:24:39.835]             {
[10:24:39.835]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:39.835]                   0L) {
[10:24:39.835]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:39.835]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:39.835]                   base::options(opts)
[10:24:39.835]                 }
[10:24:39.835]                 {
[10:24:39.835]                   {
[10:24:39.835]                     NULL
[10:24:39.835]                     RNGkind("Mersenne-Twister")
[10:24:39.835]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:39.835]                       inherits = FALSE)
[10:24:39.835]                   }
[10:24:39.835]                   options(future.plan = NULL)
[10:24:39.835]                   if (is.na(NA_character_)) 
[10:24:39.835]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:39.835]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:39.835]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:39.835]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:39.835]                     envir = parent.frame()) 
[10:24:39.835]                   {
[10:24:39.835]                     if (is.function(workers)) 
[10:24:39.835]                       workers <- workers()
[10:24:39.835]                     workers <- structure(as.integer(workers), 
[10:24:39.835]                       class = class(workers))
[10:24:39.835]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:39.835]                       workers >= 1)
[10:24:39.835]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:39.835]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:39.835]                     }
[10:24:39.835]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:39.835]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:39.835]                       envir = envir)
[10:24:39.835]                     if (!future$lazy) 
[10:24:39.835]                       future <- run(future)
[10:24:39.835]                     invisible(future)
[10:24:39.835]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:39.835]                 }
[10:24:39.835]             }
[10:24:39.835]         }
[10:24:39.835]     })
[10:24:39.835]     if (TRUE) {
[10:24:39.835]         base::sink(type = "output", split = FALSE)
[10:24:39.835]         if (TRUE) {
[10:24:39.835]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:39.835]         }
[10:24:39.835]         else {
[10:24:39.835]             ...future.result["stdout"] <- base::list(NULL)
[10:24:39.835]         }
[10:24:39.835]         base::close(...future.stdout)
[10:24:39.835]         ...future.stdout <- NULL
[10:24:39.835]     }
[10:24:39.835]     ...future.result$conditions <- ...future.conditions
[10:24:39.835]     ...future.result$finished <- base::Sys.time()
[10:24:39.835]     ...future.result
[10:24:39.835] }
[10:24:39.837] assign_globals() ...
[10:24:39.837] List of 5
[10:24:39.837]  $ ...future.FUN            :function (x, y)  
[10:24:39.837]  $ MoreArgs                 : NULL
[10:24:39.837]  $ ...future.elements_ii    :List of 2
[10:24:39.837]   ..$ :List of 2
[10:24:39.837]   .. ..$ : int 1
[10:24:39.837]   .. ..$ : int 0
[10:24:39.837]   ..$ :List of 2
[10:24:39.837]   .. ..$ : int 0
[10:24:39.837]   .. ..$ : int 1
[10:24:39.837]  $ ...future.seeds_ii       : NULL
[10:24:39.837]  $ ...future.globals.maxSize: NULL
[10:24:39.837]  - attr(*, "where")=List of 5
[10:24:39.837]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:39.837]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:24:39.837]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:39.837]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:39.837]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:39.837]  - attr(*, "resolved")= logi FALSE
[10:24:39.837]  - attr(*, "total_size")= num 6480
[10:24:39.837]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:39.837]  - attr(*, "already-done")= logi TRUE
[10:24:39.842] - reassign environment for ‘...future.FUN’
[10:24:39.842] - copied ‘...future.FUN’ to environment
[10:24:39.843] - copied ‘MoreArgs’ to environment
[10:24:39.843] - copied ‘...future.elements_ii’ to environment
[10:24:39.843] - copied ‘...future.seeds_ii’ to environment
[10:24:39.843] - copied ‘...future.globals.maxSize’ to environment
[10:24:39.843] assign_globals() ... done
[10:24:39.843] plan(): Setting new future strategy stack:
[10:24:39.843] List of future strategies:
[10:24:39.843] 1. sequential:
[10:24:39.843]    - args: function (..., envir = parent.frame())
[10:24:39.843]    - tweaked: FALSE
[10:24:39.843]    - call: NULL
[10:24:39.844] plan(): nbrOfWorkers() = 1
[10:24:40.345] plan(): Setting new future strategy stack:
[10:24:40.345] List of future strategies:
[10:24:40.345] 1. multisession:
[10:24:40.345]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:24:40.345]    - tweaked: FALSE
[10:24:40.345]    - call: plan(strategy)
[10:24:40.352] plan(): nbrOfWorkers() = 1
[10:24:40.352] SequentialFuture started (and completed)
[10:24:40.352] - Launch lazy future ... done
[10:24:40.352] run() for ‘SequentialFuture’ ... done
[10:24:40.352] Created future:
[10:24:40.353] SequentialFuture:
[10:24:40.353] Label: ‘future_mapply-1’
[10:24:40.353] Expression:
[10:24:40.353] {
[10:24:40.353]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:40.353]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:40.353]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:40.353]         on.exit(options(oopts), add = TRUE)
[10:24:40.353]     }
[10:24:40.353]     {
[10:24:40.353]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:40.353]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:24:40.353]         do.call(mapply, args = args)
[10:24:40.353]     }
[10:24:40.353] }
[10:24:40.353] Lazy evaluation: FALSE
[10:24:40.353] Asynchronous evaluation: FALSE
[10:24:40.353] Local evaluation: TRUE
[10:24:40.353] Environment: R_GlobalEnv
[10:24:40.353] Capture standard output: TRUE
[10:24:40.353] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:40.353] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:40.353] Packages: <none>
[10:24:40.353] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:40.353] Resolved: TRUE
[10:24:40.353] Value: 224 bytes of class ‘list’
[10:24:40.353] Early signaling: FALSE
[10:24:40.353] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:40.353] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:40.354] Chunk #1 of 1 ... DONE
[10:24:40.354] Launching 1 futures (chunks) ... DONE
[10:24:40.354] Resolving 1 futures (chunks) ...
[10:24:40.354] resolve() on list ...
[10:24:40.354]  recursive: 0
[10:24:40.354]  length: 1
[10:24:40.354] 
[10:24:40.355] resolved() for ‘SequentialFuture’ ...
[10:24:40.355] - state: ‘finished’
[10:24:40.355] - run: TRUE
[10:24:40.355] - result: ‘FutureResult’
[10:24:40.355] resolved() for ‘SequentialFuture’ ... done
[10:24:40.355] Future #1
[10:24:40.355] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:40.355] - nx: 1
[10:24:40.355] - relay: TRUE
[10:24:40.355] - stdout: TRUE
[10:24:40.356] - signal: TRUE
[10:24:40.356] - resignal: FALSE
[10:24:40.356] - force: TRUE
[10:24:40.356] - relayed: [n=1] FALSE
[10:24:40.356] - queued futures: [n=1] FALSE
[10:24:40.356]  - until=1
[10:24:40.356]  - relaying element #1
[10:24:40.356] - relayed: [n=1] TRUE
[10:24:40.356] - queued futures: [n=1] TRUE
[10:24:40.356] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:40.357]  length: 0 (resolved future 1)
[10:24:40.357] Relaying remaining futures
[10:24:40.357] signalConditionsASAP(NULL, pos=0) ...
[10:24:40.357] - nx: 1
[10:24:40.357] - relay: TRUE
[10:24:40.357] - stdout: TRUE
[10:24:40.357] - signal: TRUE
[10:24:40.357] - resignal: FALSE
[10:24:40.357] - force: TRUE
[10:24:40.357] - relayed: [n=1] TRUE
[10:24:40.357] - queued futures: [n=1] TRUE
 - flush all
[10:24:40.358] - relayed: [n=1] TRUE
[10:24:40.358] - queued futures: [n=1] TRUE
[10:24:40.358] signalConditionsASAP(NULL, pos=0) ... done
[10:24:40.358] resolve() on list ... DONE
[10:24:40.358]  - Number of value chunks collected: 1
[10:24:40.358] Resolving 1 futures (chunks) ... DONE
[10:24:40.358] Reducing values from 1 chunks ...
[10:24:40.358]  - Number of values collected after concatenation: 2
[10:24:40.358]  - Number of values expected: 2
[10:24:40.359] Reducing values from 1 chunks ... DONE
[10:24:40.359] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[10:24:40.359] future_mapply() ...
[10:24:40.362] Number of chunks: 1
[10:24:40.362] getGlobalsAndPackagesXApply() ...
[10:24:40.362]  - future.globals: TRUE
[10:24:40.363] getGlobalsAndPackages() ...
[10:24:40.363] Searching for globals...
[10:24:40.364] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:24:40.364] Searching for globals ... DONE
[10:24:40.364] Resolving globals: FALSE
[10:24:40.365] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[10:24:40.365] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[10:24:40.365] - globals: [1] ‘FUN’
[10:24:40.366] 
[10:24:40.366] getGlobalsAndPackages() ... DONE
[10:24:40.366]  - globals found/used: [n=1] ‘FUN’
[10:24:40.366]  - needed namespaces: [n=0] 
[10:24:40.366] Finding globals ... DONE
[10:24:40.366] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:24:40.366] List of 2
[10:24:40.366]  $ ...future.FUN:function (x, y)  
[10:24:40.366]  $ MoreArgs     : NULL
[10:24:40.366]  - attr(*, "where")=List of 2
[10:24:40.366]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:40.366]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:24:40.366]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:40.366]  - attr(*, "resolved")= logi FALSE
[10:24:40.366]  - attr(*, "total_size")= num NA
[10:24:40.369] Packages to be attached in all futures: [n=0] 
[10:24:40.369] getGlobalsAndPackagesXApply() ... DONE
[10:24:40.369] Number of futures (= number of chunks): 1
[10:24:40.369] Launching 1 futures (chunks) ...
[10:24:40.369] Chunk #1 of 1 ...
[10:24:40.369]  - Finding globals in '...' for chunk #1 ...
[10:24:40.370] getGlobalsAndPackages() ...
[10:24:40.370] Searching for globals...
[10:24:40.370] 
[10:24:40.370] Searching for globals ... DONE
[10:24:40.370] - globals: [0] <none>
[10:24:40.370] getGlobalsAndPackages() ... DONE
[10:24:40.370]    + additional globals found: [n=0] 
[10:24:40.370]    + additional namespaces needed: [n=0] 
[10:24:40.371]  - Finding globals in '...' for chunk #1 ... DONE
[10:24:40.371]  - seeds: <none>
[10:24:40.371]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:40.371] getGlobalsAndPackages() ...
[10:24:40.371] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:40.371] Resolving globals: FALSE
[10:24:40.372] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[10:24:40.372] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:24:40.372] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:40.372] 
[10:24:40.372] getGlobalsAndPackages() ... DONE
[10:24:40.373] run() for ‘Future’ ...
[10:24:40.373] - state: ‘created’
[10:24:40.373] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:40.377] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:40.377] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:24:40.377]   - Field: ‘label’
[10:24:40.377]   - Field: ‘local’
[10:24:40.377]   - Field: ‘owner’
[10:24:40.378]   - Field: ‘envir’
[10:24:40.378]   - Field: ‘packages’
[10:24:40.378]   - Field: ‘gc’
[10:24:40.378]   - Field: ‘conditions’
[10:24:40.378]   - Field: ‘expr’
[10:24:40.378]   - Field: ‘uuid’
[10:24:40.378]   - Field: ‘seed’
[10:24:40.378]   - Field: ‘version’
[10:24:40.378]   - Field: ‘result’
[10:24:40.379]   - Field: ‘asynchronous’
[10:24:40.379]   - Field: ‘calls’
[10:24:40.379]   - Field: ‘globals’
[10:24:40.379]   - Field: ‘stdout’
[10:24:40.379]   - Field: ‘earlySignal’
[10:24:40.379]   - Field: ‘lazy’
[10:24:40.379]   - Field: ‘state’
[10:24:40.379] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:24:40.379] - Launch lazy future ...
[10:24:40.380] Packages needed by the future expression (n = 0): <none>
[10:24:40.380] Packages needed by future strategies (n = 0): <none>
[10:24:40.380] {
[10:24:40.380]     {
[10:24:40.380]         {
[10:24:40.380]             ...future.startTime <- base::Sys.time()
[10:24:40.380]             {
[10:24:40.380]                 {
[10:24:40.380]                   {
[10:24:40.380]                     base::local({
[10:24:40.380]                       has_future <- base::requireNamespace("future", 
[10:24:40.380]                         quietly = TRUE)
[10:24:40.380]                       if (has_future) {
[10:24:40.380]                         ns <- base::getNamespace("future")
[10:24:40.380]                         version <- ns[[".package"]][["version"]]
[10:24:40.380]                         if (is.null(version)) 
[10:24:40.380]                           version <- utils::packageVersion("future")
[10:24:40.380]                       }
[10:24:40.380]                       else {
[10:24:40.380]                         version <- NULL
[10:24:40.380]                       }
[10:24:40.380]                       if (!has_future || version < "1.8.0") {
[10:24:40.380]                         info <- base::c(r_version = base::gsub("R version ", 
[10:24:40.380]                           "", base::R.version$version.string), 
[10:24:40.380]                           platform = base::sprintf("%s (%s-bit)", 
[10:24:40.380]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:40.380]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:40.380]                             "release", "version")], collapse = " "), 
[10:24:40.380]                           hostname = base::Sys.info()[["nodename"]])
[10:24:40.380]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:24:40.380]                           info)
[10:24:40.380]                         info <- base::paste(info, collapse = "; ")
[10:24:40.380]                         if (!has_future) {
[10:24:40.380]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:40.380]                             info)
[10:24:40.380]                         }
[10:24:40.380]                         else {
[10:24:40.380]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:40.380]                             info, version)
[10:24:40.380]                         }
[10:24:40.380]                         base::stop(msg)
[10:24:40.380]                       }
[10:24:40.380]                     })
[10:24:40.380]                   }
[10:24:40.380]                   options(future.plan = NULL)
[10:24:40.380]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:40.380]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:40.380]                 }
[10:24:40.380]                 ...future.workdir <- getwd()
[10:24:40.380]             }
[10:24:40.380]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:40.380]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:40.380]         }
[10:24:40.380]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:40.380]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:40.380]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:40.380]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:40.380]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:40.380]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:40.380]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:40.380]             base::names(...future.oldOptions))
[10:24:40.380]     }
[10:24:40.380]     if (TRUE) {
[10:24:40.380]     }
[10:24:40.380]     else {
[10:24:40.380]         if (NA) {
[10:24:40.380]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:40.380]                 open = "w")
[10:24:40.380]         }
[10:24:40.380]         else {
[10:24:40.380]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:40.380]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:40.380]         }
[10:24:40.380]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:40.380]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:40.380]             base::sink(type = "output", split = FALSE)
[10:24:40.380]             base::close(...future.stdout)
[10:24:40.380]         }, add = TRUE)
[10:24:40.380]     }
[10:24:40.380]     ...future.frame <- base::sys.nframe()
[10:24:40.380]     ...future.conditions <- base::list()
[10:24:40.380]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:40.380]     if (FALSE) {
[10:24:40.380]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:40.380]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:40.380]     }
[10:24:40.380]     ...future.result <- base::tryCatch({
[10:24:40.380]         base::withCallingHandlers({
[10:24:40.380]             ...future.value <- base::withVisible(base::local({
[10:24:40.380]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:40.380]                 if (!identical(...future.globals.maxSize.org, 
[10:24:40.380]                   ...future.globals.maxSize)) {
[10:24:40.380]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:40.380]                   on.exit(options(oopts), add = TRUE)
[10:24:40.380]                 }
[10:24:40.380]                 {
[10:24:40.380]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:40.380]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:24:40.380]                     USE.NAMES = FALSE)
[10:24:40.380]                   do.call(mapply, args = args)
[10:24:40.380]                 }
[10:24:40.380]             }))
[10:24:40.380]             future::FutureResult(value = ...future.value$value, 
[10:24:40.380]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:40.380]                   ...future.rng), globalenv = if (FALSE) 
[10:24:40.380]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:40.380]                     ...future.globalenv.names))
[10:24:40.380]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:40.380]         }, condition = base::local({
[10:24:40.380]             c <- base::c
[10:24:40.380]             inherits <- base::inherits
[10:24:40.380]             invokeRestart <- base::invokeRestart
[10:24:40.380]             length <- base::length
[10:24:40.380]             list <- base::list
[10:24:40.380]             seq.int <- base::seq.int
[10:24:40.380]             signalCondition <- base::signalCondition
[10:24:40.380]             sys.calls <- base::sys.calls
[10:24:40.380]             `[[` <- base::`[[`
[10:24:40.380]             `+` <- base::`+`
[10:24:40.380]             `<<-` <- base::`<<-`
[10:24:40.380]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:40.380]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:40.380]                   3L)]
[10:24:40.380]             }
[10:24:40.380]             function(cond) {
[10:24:40.380]                 is_error <- inherits(cond, "error")
[10:24:40.380]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:40.380]                   NULL)
[10:24:40.380]                 if (is_error) {
[10:24:40.380]                   sessionInformation <- function() {
[10:24:40.380]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:40.380]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:40.380]                       search = base::search(), system = base::Sys.info())
[10:24:40.380]                   }
[10:24:40.380]                   ...future.conditions[[length(...future.conditions) + 
[10:24:40.380]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:40.380]                     cond$call), session = sessionInformation(), 
[10:24:40.380]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:40.380]                   signalCondition(cond)
[10:24:40.380]                 }
[10:24:40.380]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:40.380]                 "immediateCondition"))) {
[10:24:40.380]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:40.380]                   ...future.conditions[[length(...future.conditions) + 
[10:24:40.380]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:40.380]                   if (TRUE && !signal) {
[10:24:40.380]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:40.380]                     {
[10:24:40.380]                       inherits <- base::inherits
[10:24:40.380]                       invokeRestart <- base::invokeRestart
[10:24:40.380]                       is.null <- base::is.null
[10:24:40.380]                       muffled <- FALSE
[10:24:40.380]                       if (inherits(cond, "message")) {
[10:24:40.380]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:40.380]                         if (muffled) 
[10:24:40.380]                           invokeRestart("muffleMessage")
[10:24:40.380]                       }
[10:24:40.380]                       else if (inherits(cond, "warning")) {
[10:24:40.380]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:40.380]                         if (muffled) 
[10:24:40.380]                           invokeRestart("muffleWarning")
[10:24:40.380]                       }
[10:24:40.380]                       else if (inherits(cond, "condition")) {
[10:24:40.380]                         if (!is.null(pattern)) {
[10:24:40.380]                           computeRestarts <- base::computeRestarts
[10:24:40.380]                           grepl <- base::grepl
[10:24:40.380]                           restarts <- computeRestarts(cond)
[10:24:40.380]                           for (restart in restarts) {
[10:24:40.380]                             name <- restart$name
[10:24:40.380]                             if (is.null(name)) 
[10:24:40.380]                               next
[10:24:40.380]                             if (!grepl(pattern, name)) 
[10:24:40.380]                               next
[10:24:40.380]                             invokeRestart(restart)
[10:24:40.380]                             muffled <- TRUE
[10:24:40.380]                             break
[10:24:40.380]                           }
[10:24:40.380]                         }
[10:24:40.380]                       }
[10:24:40.380]                       invisible(muffled)
[10:24:40.380]                     }
[10:24:40.380]                     muffleCondition(cond, pattern = "^muffle")
[10:24:40.380]                   }
[10:24:40.380]                 }
[10:24:40.380]                 else {
[10:24:40.380]                   if (TRUE) {
[10:24:40.380]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:40.380]                     {
[10:24:40.380]                       inherits <- base::inherits
[10:24:40.380]                       invokeRestart <- base::invokeRestart
[10:24:40.380]                       is.null <- base::is.null
[10:24:40.380]                       muffled <- FALSE
[10:24:40.380]                       if (inherits(cond, "message")) {
[10:24:40.380]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:40.380]                         if (muffled) 
[10:24:40.380]                           invokeRestart("muffleMessage")
[10:24:40.380]                       }
[10:24:40.380]                       else if (inherits(cond, "warning")) {
[10:24:40.380]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:40.380]                         if (muffled) 
[10:24:40.380]                           invokeRestart("muffleWarning")
[10:24:40.380]                       }
[10:24:40.380]                       else if (inherits(cond, "condition")) {
[10:24:40.380]                         if (!is.null(pattern)) {
[10:24:40.380]                           computeRestarts <- base::computeRestarts
[10:24:40.380]                           grepl <- base::grepl
[10:24:40.380]                           restarts <- computeRestarts(cond)
[10:24:40.380]                           for (restart in restarts) {
[10:24:40.380]                             name <- restart$name
[10:24:40.380]                             if (is.null(name)) 
[10:24:40.380]                               next
[10:24:40.380]                             if (!grepl(pattern, name)) 
[10:24:40.380]                               next
[10:24:40.380]                             invokeRestart(restart)
[10:24:40.380]                             muffled <- TRUE
[10:24:40.380]                             break
[10:24:40.380]                           }
[10:24:40.380]                         }
[10:24:40.380]                       }
[10:24:40.380]                       invisible(muffled)
[10:24:40.380]                     }
[10:24:40.380]                     muffleCondition(cond, pattern = "^muffle")
[10:24:40.380]                   }
[10:24:40.380]                 }
[10:24:40.380]             }
[10:24:40.380]         }))
[10:24:40.380]     }, error = function(ex) {
[10:24:40.380]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:40.380]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:40.380]                 ...future.rng), started = ...future.startTime, 
[10:24:40.380]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:40.380]             version = "1.8"), class = "FutureResult")
[10:24:40.380]     }, finally = {
[10:24:40.380]         if (!identical(...future.workdir, getwd())) 
[10:24:40.380]             setwd(...future.workdir)
[10:24:40.380]         {
[10:24:40.380]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:40.380]                 ...future.oldOptions$nwarnings <- NULL
[10:24:40.380]             }
[10:24:40.380]             base::options(...future.oldOptions)
[10:24:40.380]             if (.Platform$OS.type == "windows") {
[10:24:40.380]                 old_names <- names(...future.oldEnvVars)
[10:24:40.380]                 envs <- base::Sys.getenv()
[10:24:40.380]                 names <- names(envs)
[10:24:40.380]                 common <- intersect(names, old_names)
[10:24:40.380]                 added <- setdiff(names, old_names)
[10:24:40.380]                 removed <- setdiff(old_names, names)
[10:24:40.380]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:40.380]                   envs[common]]
[10:24:40.380]                 NAMES <- toupper(changed)
[10:24:40.380]                 args <- list()
[10:24:40.380]                 for (kk in seq_along(NAMES)) {
[10:24:40.380]                   name <- changed[[kk]]
[10:24:40.380]                   NAME <- NAMES[[kk]]
[10:24:40.380]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:40.380]                     next
[10:24:40.380]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:40.380]                 }
[10:24:40.380]                 NAMES <- toupper(added)
[10:24:40.380]                 for (kk in seq_along(NAMES)) {
[10:24:40.380]                   name <- added[[kk]]
[10:24:40.380]                   NAME <- NAMES[[kk]]
[10:24:40.380]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:40.380]                     next
[10:24:40.380]                   args[[name]] <- ""
[10:24:40.380]                 }
[10:24:40.380]                 NAMES <- toupper(removed)
[10:24:40.380]                 for (kk in seq_along(NAMES)) {
[10:24:40.380]                   name <- removed[[kk]]
[10:24:40.380]                   NAME <- NAMES[[kk]]
[10:24:40.380]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:40.380]                     next
[10:24:40.380]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:40.380]                 }
[10:24:40.380]                 if (length(args) > 0) 
[10:24:40.380]                   base::do.call(base::Sys.setenv, args = args)
[10:24:40.380]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:40.380]             }
[10:24:40.380]             else {
[10:24:40.380]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:40.380]             }
[10:24:40.380]             {
[10:24:40.380]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:40.380]                   0L) {
[10:24:40.380]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:40.380]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:40.380]                   base::options(opts)
[10:24:40.380]                 }
[10:24:40.380]                 {
[10:24:40.380]                   {
[10:24:40.380]                     NULL
[10:24:40.380]                     RNGkind("Mersenne-Twister")
[10:24:40.380]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:24:40.380]                       inherits = FALSE)
[10:24:40.380]                   }
[10:24:40.380]                   options(future.plan = NULL)
[10:24:40.380]                   if (is.na(NA_character_)) 
[10:24:40.380]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:40.380]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:40.380]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:40.380]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:40.380]                     envir = parent.frame()) 
[10:24:40.380]                   {
[10:24:40.380]                     if (is.function(workers)) 
[10:24:40.380]                       workers <- workers()
[10:24:40.380]                     workers <- structure(as.integer(workers), 
[10:24:40.380]                       class = class(workers))
[10:24:40.380]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:40.380]                       workers >= 1)
[10:24:40.380]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:40.380]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:40.380]                     }
[10:24:40.380]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:40.380]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:40.380]                       envir = envir)
[10:24:40.380]                     if (!future$lazy) 
[10:24:40.380]                       future <- run(future)
[10:24:40.380]                     invisible(future)
[10:24:40.380]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:40.380]                 }
[10:24:40.380]             }
[10:24:40.380]         }
[10:24:40.380]     })
[10:24:40.380]     if (FALSE) {
[10:24:40.380]         base::sink(type = "output", split = FALSE)
[10:24:40.380]         if (NA) {
[10:24:40.380]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:40.380]         }
[10:24:40.380]         else {
[10:24:40.380]             ...future.result["stdout"] <- base::list(NULL)
[10:24:40.380]         }
[10:24:40.380]         base::close(...future.stdout)
[10:24:40.380]         ...future.stdout <- NULL
[10:24:40.380]     }
[10:24:40.380]     ...future.result$conditions <- ...future.conditions
[10:24:40.380]     ...future.result$finished <- base::Sys.time()
[10:24:40.380]     ...future.result
[10:24:40.380] }
[10:24:40.383] assign_globals() ...
[10:24:40.384] List of 5
[10:24:40.384]  $ ...future.FUN            :function (x, y)  
[10:24:40.384]  $ MoreArgs                 : NULL
[10:24:40.384]  $ ...future.elements_ii    :List of 2
[10:24:40.384]   ..$ :List of 2
[10:24:40.384]   .. ..$ : int 1
[10:24:40.384]   .. ..$ : int 0
[10:24:40.384]   ..$ :List of 2
[10:24:40.384]   .. ..$ : int 0
[10:24:40.384]   .. ..$ : int 1
[10:24:40.384]  $ ...future.seeds_ii       : NULL
[10:24:40.384]  $ ...future.globals.maxSize: NULL
[10:24:40.384]  - attr(*, "where")=List of 5
[10:24:40.384]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:40.384]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:24:40.384]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:40.384]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:40.384]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:40.384]  - attr(*, "resolved")= logi FALSE
[10:24:40.384]  - attr(*, "total_size")= num 6480
[10:24:40.384]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:40.384]  - attr(*, "already-done")= logi TRUE
[10:24:40.390] - reassign environment for ‘...future.FUN’
[10:24:40.390] - copied ‘...future.FUN’ to environment
[10:24:40.390] - copied ‘MoreArgs’ to environment
[10:24:40.390] - copied ‘...future.elements_ii’ to environment
[10:24:40.390] - copied ‘...future.seeds_ii’ to environment
[10:24:40.390] - copied ‘...future.globals.maxSize’ to environment
[10:24:40.390] assign_globals() ... done
[10:24:40.391] plan(): Setting new future strategy stack:
[10:24:40.391] List of future strategies:
[10:24:40.391] 1. sequential:
[10:24:40.391]    - args: function (..., envir = parent.frame())
[10:24:40.391]    - tweaked: FALSE
[10:24:40.391]    - call: NULL
[10:24:40.391] plan(): nbrOfWorkers() = 1
[10:24:40.893] plan(): Setting new future strategy stack:
[10:24:40.893] List of future strategies:
[10:24:40.893] 1. multisession:
[10:24:40.893]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:24:40.893]    - tweaked: FALSE
[10:24:40.893]    - call: plan(strategy)
[10:24:40.897] plan(): nbrOfWorkers() = 1
[10:24:40.897] SequentialFuture started (and completed)
[10:24:40.897] - Launch lazy future ... done
[10:24:40.897] run() for ‘SequentialFuture’ ... done
[10:24:40.898] Created future:
[10:24:40.898] SequentialFuture:
[10:24:40.898] Label: ‘future_mapply-1’
[10:24:40.898] Expression:
[10:24:40.898] {
[10:24:40.898]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:40.898]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:40.898]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:40.898]         on.exit(options(oopts), add = TRUE)
[10:24:40.898]     }
[10:24:40.898]     {
[10:24:40.898]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:40.898]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:24:40.898]         do.call(mapply, args = args)
[10:24:40.898]     }
[10:24:40.898] }
[10:24:40.898] Lazy evaluation: FALSE
[10:24:40.898] Asynchronous evaluation: FALSE
[10:24:40.898] Local evaluation: TRUE
[10:24:40.898] Environment: R_GlobalEnv
[10:24:40.898] Capture standard output: NA
[10:24:40.898] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:40.898] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:40.898] Packages: <none>
[10:24:40.898] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:40.898] Resolved: TRUE
[10:24:40.898] Value: 224 bytes of class ‘list’
[10:24:40.898] Early signaling: FALSE
[10:24:40.898] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:40.898] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:24:40.899] Chunk #1 of 1 ... DONE
[10:24:40.899] Launching 1 futures (chunks) ... DONE
[10:24:40.899] Resolving 1 futures (chunks) ...
[10:24:40.899] resolve() on list ...
[10:24:40.899]  recursive: 0
[10:24:40.899]  length: 1
[10:24:40.899] 
[10:24:40.899] resolved() for ‘SequentialFuture’ ...
[10:24:40.900] - state: ‘finished’
[10:24:40.900] - run: TRUE
[10:24:40.900] - result: ‘FutureResult’
[10:24:40.900] resolved() for ‘SequentialFuture’ ... done
[10:24:40.900] Future #1
[10:24:40.900] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:24:40.900] - nx: 1
[10:24:40.900] - relay: TRUE
[10:24:40.900] - stdout: TRUE
[10:24:40.900] - signal: TRUE
[10:24:40.901] - resignal: FALSE
[10:24:40.901] - force: TRUE
[10:24:40.901] - relayed: [n=1] FALSE
[10:24:40.901] - queued futures: [n=1] FALSE
[10:24:40.901]  - until=1
[10:24:40.901]  - relaying element #1
[10:24:40.901] - relayed: [n=1] TRUE
[10:24:40.901] - queued futures: [n=1] TRUE
[10:24:40.901] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:24:40.901]  length: 0 (resolved future 1)
[10:24:40.902] Relaying remaining futures
[10:24:40.902] signalConditionsASAP(NULL, pos=0) ...
[10:24:40.902] - nx: 1
[10:24:40.902] - relay: TRUE
[10:24:40.902] - stdout: TRUE
[10:24:40.902] - signal: TRUE
[10:24:40.902] - resignal: FALSE
[10:24:40.902] - force: TRUE
[10:24:40.902] - relayed: [n=1] TRUE
[10:24:40.902] - queued futures: [n=1] TRUE
 - flush all
[10:24:40.902] - relayed: [n=1] TRUE
[10:24:40.903] - queued futures: [n=1] TRUE
[10:24:40.903] signalConditionsASAP(NULL, pos=0) ... done
[10:24:40.903] resolve() on list ... DONE
[10:24:40.903]  - Number of value chunks collected: 1
[10:24:40.903] Resolving 1 futures (chunks) ... DONE
[10:24:40.903] Reducing values from 1 chunks ...
[10:24:40.903]  - Number of values collected after concatenation: 2
[10:24:40.903]  - Number of values expected: 2
[10:24:40.903] Reducing values from 1 chunks ... DONE
[10:24:40.903] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 1 cores ... DONE
  - Testing with 2 cores ...
* plan('multicore') ...
[10:24:40.907] plan(): Setting new future strategy stack:
[10:24:40.907] List of future strategies:
[10:24:40.907] 1. multicore:
[10:24:40.907]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:40.907]    - tweaked: FALSE
[10:24:40.907]    - call: plan(strategy)
[10:24:40.911] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[10:24:40.911] future_lapply() ...
[10:24:40.919] Number of chunks: 2
[10:24:40.919] getGlobalsAndPackagesXApply() ...
[10:24:40.919]  - future.globals: TRUE
[10:24:40.919] getGlobalsAndPackages() ...
[10:24:40.919] Searching for globals...
[10:24:40.921] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:24:40.921] Searching for globals ... DONE
[10:24:40.921] Resolving globals: FALSE
[10:24:40.921] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[10:24:40.922] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[10:24:40.922] - globals: [1] ‘FUN’
[10:24:40.922] 
[10:24:40.922] getGlobalsAndPackages() ... DONE
[10:24:40.922]  - globals found/used: [n=1] ‘FUN’
[10:24:40.922]  - needed namespaces: [n=0] 
[10:24:40.922] Finding globals ... DONE
[10:24:40.922]  - use_args: TRUE
[10:24:40.922]  - Getting '...' globals ...
[10:24:40.923] resolve() on list ...
[10:24:40.923]  recursive: 0
[10:24:40.923]  length: 1
[10:24:40.923]  elements: ‘...’
[10:24:40.923]  length: 0 (resolved future 1)
[10:24:40.923] resolve() on list ... DONE
[10:24:40.923]    - '...' content: [n=0] 
[10:24:40.923] List of 1
[10:24:40.923]  $ ...: list()
[10:24:40.923]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:40.923]  - attr(*, "where")=List of 1
[10:24:40.923]   ..$ ...:<environment: 0x55d21183bbe0> 
[10:24:40.923]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:40.923]  - attr(*, "resolved")= logi TRUE
[10:24:40.923]  - attr(*, "total_size")= num NA
[10:24:40.926]  - Getting '...' globals ... DONE
[10:24:40.926] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:24:40.927] List of 2
[10:24:40.927]  $ ...future.FUN:function (x)  
[10:24:40.927]  $ ...          : list()
[10:24:40.927]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:40.927]  - attr(*, "where")=List of 2
[10:24:40.927]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:40.927]   ..$ ...          :<environment: 0x55d21183bbe0> 
[10:24:40.927]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:40.927]  - attr(*, "resolved")= logi FALSE
[10:24:40.927]  - attr(*, "total_size")= num 4720
[10:24:40.929] Packages to be attached in all futures: [n=0] 
[10:24:40.929] getGlobalsAndPackagesXApply() ... DONE
[10:24:40.929] Number of futures (= number of chunks): 2
[10:24:40.930] Launching 2 futures (chunks) ...
[10:24:40.930] Chunk #1 of 2 ...
[10:24:40.930]  - Finding globals in 'X' for chunk #1 ...
[10:24:40.930] getGlobalsAndPackages() ...
[10:24:40.930] Searching for globals...
[10:24:40.930] 
[10:24:40.930] Searching for globals ... DONE
[10:24:40.930] - globals: [0] <none>
[10:24:40.930] getGlobalsAndPackages() ... DONE
[10:24:40.931]    + additional globals found: [n=0] 
[10:24:40.931]    + additional namespaces needed: [n=0] 
[10:24:40.931]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:40.931]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:40.931]  - seeds: <none>
[10:24:40.931]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:40.931] getGlobalsAndPackages() ...
[10:24:40.931] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:40.931] Resolving globals: FALSE
[10:24:40.931] Tweak future expression to call with '...' arguments ...
[10:24:40.932] {
[10:24:40.932]     do.call(function(...) {
[10:24:40.932]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:40.932]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:40.932]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:40.932]             on.exit(options(oopts), add = TRUE)
[10:24:40.932]         }
[10:24:40.932]         {
[10:24:40.932]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:40.932]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:40.932]                 ...future.FUN(...future.X_jj, ...)
[10:24:40.932]             })
[10:24:40.932]         }
[10:24:40.932]     }, args = future.call.arguments)
[10:24:40.932] }
[10:24:40.932] Tweak future expression to call with '...' arguments ... DONE
[10:24:40.932] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:40.932] 
[10:24:40.932] getGlobalsAndPackages() ... DONE
[10:24:40.933] run() for ‘Future’ ...
[10:24:40.933] - state: ‘created’
[10:24:40.933] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:40.937] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:40.937] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:40.937]   - Field: ‘label’
[10:24:40.937]   - Field: ‘local’
[10:24:40.937]   - Field: ‘owner’
[10:24:40.937]   - Field: ‘envir’
[10:24:40.937]   - Field: ‘workers’
[10:24:40.937]   - Field: ‘packages’
[10:24:40.937]   - Field: ‘gc’
[10:24:40.938]   - Field: ‘job’
[10:24:40.938]   - Field: ‘conditions’
[10:24:40.938]   - Field: ‘expr’
[10:24:40.938]   - Field: ‘uuid’
[10:24:40.938]   - Field: ‘seed’
[10:24:40.938]   - Field: ‘version’
[10:24:40.938]   - Field: ‘result’
[10:24:40.938]   - Field: ‘asynchronous’
[10:24:40.938]   - Field: ‘calls’
[10:24:40.938]   - Field: ‘globals’
[10:24:40.938]   - Field: ‘stdout’
[10:24:40.939]   - Field: ‘earlySignal’
[10:24:40.939]   - Field: ‘lazy’
[10:24:40.939]   - Field: ‘state’
[10:24:40.939] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:40.939] - Launch lazy future ...
[10:24:40.940] Packages needed by the future expression (n = 0): <none>
[10:24:40.940] Packages needed by future strategies (n = 0): <none>
[10:24:40.941] {
[10:24:40.941]     {
[10:24:40.941]         {
[10:24:40.941]             ...future.startTime <- base::Sys.time()
[10:24:40.941]             {
[10:24:40.941]                 {
[10:24:40.941]                   {
[10:24:40.941]                     {
[10:24:40.941]                       base::local({
[10:24:40.941]                         has_future <- base::requireNamespace("future", 
[10:24:40.941]                           quietly = TRUE)
[10:24:40.941]                         if (has_future) {
[10:24:40.941]                           ns <- base::getNamespace("future")
[10:24:40.941]                           version <- ns[[".package"]][["version"]]
[10:24:40.941]                           if (is.null(version)) 
[10:24:40.941]                             version <- utils::packageVersion("future")
[10:24:40.941]                         }
[10:24:40.941]                         else {
[10:24:40.941]                           version <- NULL
[10:24:40.941]                         }
[10:24:40.941]                         if (!has_future || version < "1.8.0") {
[10:24:40.941]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:40.941]                             "", base::R.version$version.string), 
[10:24:40.941]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:40.941]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:40.941]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:40.941]                               "release", "version")], collapse = " "), 
[10:24:40.941]                             hostname = base::Sys.info()[["nodename"]])
[10:24:40.941]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:40.941]                             info)
[10:24:40.941]                           info <- base::paste(info, collapse = "; ")
[10:24:40.941]                           if (!has_future) {
[10:24:40.941]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:40.941]                               info)
[10:24:40.941]                           }
[10:24:40.941]                           else {
[10:24:40.941]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:40.941]                               info, version)
[10:24:40.941]                           }
[10:24:40.941]                           base::stop(msg)
[10:24:40.941]                         }
[10:24:40.941]                       })
[10:24:40.941]                     }
[10:24:40.941]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:40.941]                     base::options(mc.cores = 1L)
[10:24:40.941]                   }
[10:24:40.941]                   options(future.plan = NULL)
[10:24:40.941]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:40.941]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:40.941]                 }
[10:24:40.941]                 ...future.workdir <- getwd()
[10:24:40.941]             }
[10:24:40.941]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:40.941]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:40.941]         }
[10:24:40.941]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:40.941]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:40.941]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:40.941]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:40.941]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:40.941]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:40.941]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:40.941]             base::names(...future.oldOptions))
[10:24:40.941]     }
[10:24:40.941]     if (FALSE) {
[10:24:40.941]     }
[10:24:40.941]     else {
[10:24:40.941]         if (FALSE) {
[10:24:40.941]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:40.941]                 open = "w")
[10:24:40.941]         }
[10:24:40.941]         else {
[10:24:40.941]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:40.941]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:40.941]         }
[10:24:40.941]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:40.941]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:40.941]             base::sink(type = "output", split = FALSE)
[10:24:40.941]             base::close(...future.stdout)
[10:24:40.941]         }, add = TRUE)
[10:24:40.941]     }
[10:24:40.941]     ...future.frame <- base::sys.nframe()
[10:24:40.941]     ...future.conditions <- base::list()
[10:24:40.941]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:40.941]     if (FALSE) {
[10:24:40.941]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:40.941]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:40.941]     }
[10:24:40.941]     ...future.result <- base::tryCatch({
[10:24:40.941]         base::withCallingHandlers({
[10:24:40.941]             ...future.value <- base::withVisible(base::local({
[10:24:40.941]                 withCallingHandlers({
[10:24:40.941]                   {
[10:24:40.941]                     do.call(function(...) {
[10:24:40.941]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:40.941]                       if (!identical(...future.globals.maxSize.org, 
[10:24:40.941]                         ...future.globals.maxSize)) {
[10:24:40.941]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:40.941]                         on.exit(options(oopts), add = TRUE)
[10:24:40.941]                       }
[10:24:40.941]                       {
[10:24:40.941]                         lapply(seq_along(...future.elements_ii), 
[10:24:40.941]                           FUN = function(jj) {
[10:24:40.941]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:40.941]                             ...future.FUN(...future.X_jj, ...)
[10:24:40.941]                           })
[10:24:40.941]                       }
[10:24:40.941]                     }, args = future.call.arguments)
[10:24:40.941]                   }
[10:24:40.941]                 }, immediateCondition = function(cond) {
[10:24:40.941]                   save_rds <- function (object, pathname, ...) 
[10:24:40.941]                   {
[10:24:40.941]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:40.941]                     if (file_test("-f", pathname_tmp)) {
[10:24:40.941]                       fi_tmp <- file.info(pathname_tmp)
[10:24:40.941]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:40.941]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:40.941]                         fi_tmp[["mtime"]])
[10:24:40.941]                     }
[10:24:40.941]                     tryCatch({
[10:24:40.941]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:40.941]                     }, error = function(ex) {
[10:24:40.941]                       msg <- conditionMessage(ex)
[10:24:40.941]                       fi_tmp <- file.info(pathname_tmp)
[10:24:40.941]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:40.941]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:40.941]                         fi_tmp[["mtime"]], msg)
[10:24:40.941]                       ex$message <- msg
[10:24:40.941]                       stop(ex)
[10:24:40.941]                     })
[10:24:40.941]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:40.941]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:40.941]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:40.941]                       fi_tmp <- file.info(pathname_tmp)
[10:24:40.941]                       fi <- file.info(pathname)
[10:24:40.941]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:40.941]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:40.941]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:40.941]                         fi[["size"]], fi[["mtime"]])
[10:24:40.941]                       stop(msg)
[10:24:40.941]                     }
[10:24:40.941]                     invisible(pathname)
[10:24:40.941]                   }
[10:24:40.941]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:40.941]                     rootPath = tempdir()) 
[10:24:40.941]                   {
[10:24:40.941]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:40.941]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:40.941]                       tmpdir = path, fileext = ".rds")
[10:24:40.941]                     save_rds(obj, file)
[10:24:40.941]                   }
[10:24:40.941]                   saveImmediateCondition(cond, path = "/tmp/Rtmp5boaqN/.future/immediateConditions")
[10:24:40.941]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:40.941]                   {
[10:24:40.941]                     inherits <- base::inherits
[10:24:40.941]                     invokeRestart <- base::invokeRestart
[10:24:40.941]                     is.null <- base::is.null
[10:24:40.941]                     muffled <- FALSE
[10:24:40.941]                     if (inherits(cond, "message")) {
[10:24:40.941]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:40.941]                       if (muffled) 
[10:24:40.941]                         invokeRestart("muffleMessage")
[10:24:40.941]                     }
[10:24:40.941]                     else if (inherits(cond, "warning")) {
[10:24:40.941]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:40.941]                       if (muffled) 
[10:24:40.941]                         invokeRestart("muffleWarning")
[10:24:40.941]                     }
[10:24:40.941]                     else if (inherits(cond, "condition")) {
[10:24:40.941]                       if (!is.null(pattern)) {
[10:24:40.941]                         computeRestarts <- base::computeRestarts
[10:24:40.941]                         grepl <- base::grepl
[10:24:40.941]                         restarts <- computeRestarts(cond)
[10:24:40.941]                         for (restart in restarts) {
[10:24:40.941]                           name <- restart$name
[10:24:40.941]                           if (is.null(name)) 
[10:24:40.941]                             next
[10:24:40.941]                           if (!grepl(pattern, name)) 
[10:24:40.941]                             next
[10:24:40.941]                           invokeRestart(restart)
[10:24:40.941]                           muffled <- TRUE
[10:24:40.941]                           break
[10:24:40.941]                         }
[10:24:40.941]                       }
[10:24:40.941]                     }
[10:24:40.941]                     invisible(muffled)
[10:24:40.941]                   }
[10:24:40.941]                   muffleCondition(cond)
[10:24:40.941]                 })
[10:24:40.941]             }))
[10:24:40.941]             future::FutureResult(value = ...future.value$value, 
[10:24:40.941]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:40.941]                   ...future.rng), globalenv = if (FALSE) 
[10:24:40.941]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:40.941]                     ...future.globalenv.names))
[10:24:40.941]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:40.941]         }, condition = base::local({
[10:24:40.941]             c <- base::c
[10:24:40.941]             inherits <- base::inherits
[10:24:40.941]             invokeRestart <- base::invokeRestart
[10:24:40.941]             length <- base::length
[10:24:40.941]             list <- base::list
[10:24:40.941]             seq.int <- base::seq.int
[10:24:40.941]             signalCondition <- base::signalCondition
[10:24:40.941]             sys.calls <- base::sys.calls
[10:24:40.941]             `[[` <- base::`[[`
[10:24:40.941]             `+` <- base::`+`
[10:24:40.941]             `<<-` <- base::`<<-`
[10:24:40.941]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:40.941]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:40.941]                   3L)]
[10:24:40.941]             }
[10:24:40.941]             function(cond) {
[10:24:40.941]                 is_error <- inherits(cond, "error")
[10:24:40.941]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:40.941]                   NULL)
[10:24:40.941]                 if (is_error) {
[10:24:40.941]                   sessionInformation <- function() {
[10:24:40.941]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:40.941]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:40.941]                       search = base::search(), system = base::Sys.info())
[10:24:40.941]                   }
[10:24:40.941]                   ...future.conditions[[length(...future.conditions) + 
[10:24:40.941]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:40.941]                     cond$call), session = sessionInformation(), 
[10:24:40.941]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:40.941]                   signalCondition(cond)
[10:24:40.941]                 }
[10:24:40.941]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:40.941]                 "immediateCondition"))) {
[10:24:40.941]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:40.941]                   ...future.conditions[[length(...future.conditions) + 
[10:24:40.941]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:40.941]                   if (TRUE && !signal) {
[10:24:40.941]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:40.941]                     {
[10:24:40.941]                       inherits <- base::inherits
[10:24:40.941]                       invokeRestart <- base::invokeRestart
[10:24:40.941]                       is.null <- base::is.null
[10:24:40.941]                       muffled <- FALSE
[10:24:40.941]                       if (inherits(cond, "message")) {
[10:24:40.941]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:40.941]                         if (muffled) 
[10:24:40.941]                           invokeRestart("muffleMessage")
[10:24:40.941]                       }
[10:24:40.941]                       else if (inherits(cond, "warning")) {
[10:24:40.941]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:40.941]                         if (muffled) 
[10:24:40.941]                           invokeRestart("muffleWarning")
[10:24:40.941]                       }
[10:24:40.941]                       else if (inherits(cond, "condition")) {
[10:24:40.941]                         if (!is.null(pattern)) {
[10:24:40.941]                           computeRestarts <- base::computeRestarts
[10:24:40.941]                           grepl <- base::grepl
[10:24:40.941]                           restarts <- computeRestarts(cond)
[10:24:40.941]                           for (restart in restarts) {
[10:24:40.941]                             name <- restart$name
[10:24:40.941]                             if (is.null(name)) 
[10:24:40.941]                               next
[10:24:40.941]                             if (!grepl(pattern, name)) 
[10:24:40.941]                               next
[10:24:40.941]                             invokeRestart(restart)
[10:24:40.941]                             muffled <- TRUE
[10:24:40.941]                             break
[10:24:40.941]                           }
[10:24:40.941]                         }
[10:24:40.941]                       }
[10:24:40.941]                       invisible(muffled)
[10:24:40.941]                     }
[10:24:40.941]                     muffleCondition(cond, pattern = "^muffle")
[10:24:40.941]                   }
[10:24:40.941]                 }
[10:24:40.941]                 else {
[10:24:40.941]                   if (TRUE) {
[10:24:40.941]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:40.941]                     {
[10:24:40.941]                       inherits <- base::inherits
[10:24:40.941]                       invokeRestart <- base::invokeRestart
[10:24:40.941]                       is.null <- base::is.null
[10:24:40.941]                       muffled <- FALSE
[10:24:40.941]                       if (inherits(cond, "message")) {
[10:24:40.941]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:40.941]                         if (muffled) 
[10:24:40.941]                           invokeRestart("muffleMessage")
[10:24:40.941]                       }
[10:24:40.941]                       else if (inherits(cond, "warning")) {
[10:24:40.941]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:40.941]                         if (muffled) 
[10:24:40.941]                           invokeRestart("muffleWarning")
[10:24:40.941]                       }
[10:24:40.941]                       else if (inherits(cond, "condition")) {
[10:24:40.941]                         if (!is.null(pattern)) {
[10:24:40.941]                           computeRestarts <- base::computeRestarts
[10:24:40.941]                           grepl <- base::grepl
[10:24:40.941]                           restarts <- computeRestarts(cond)
[10:24:40.941]                           for (restart in restarts) {
[10:24:40.941]                             name <- restart$name
[10:24:40.941]                             if (is.null(name)) 
[10:24:40.941]                               next
[10:24:40.941]                             if (!grepl(pattern, name)) 
[10:24:40.941]                               next
[10:24:40.941]                             invokeRestart(restart)
[10:24:40.941]                             muffled <- TRUE
[10:24:40.941]                             break
[10:24:40.941]                           }
[10:24:40.941]                         }
[10:24:40.941]                       }
[10:24:40.941]                       invisible(muffled)
[10:24:40.941]                     }
[10:24:40.941]                     muffleCondition(cond, pattern = "^muffle")
[10:24:40.941]                   }
[10:24:40.941]                 }
[10:24:40.941]             }
[10:24:40.941]         }))
[10:24:40.941]     }, error = function(ex) {
[10:24:40.941]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:40.941]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:40.941]                 ...future.rng), started = ...future.startTime, 
[10:24:40.941]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:40.941]             version = "1.8"), class = "FutureResult")
[10:24:40.941]     }, finally = {
[10:24:40.941]         if (!identical(...future.workdir, getwd())) 
[10:24:40.941]             setwd(...future.workdir)
[10:24:40.941]         {
[10:24:40.941]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:40.941]                 ...future.oldOptions$nwarnings <- NULL
[10:24:40.941]             }
[10:24:40.941]             base::options(...future.oldOptions)
[10:24:40.941]             if (.Platform$OS.type == "windows") {
[10:24:40.941]                 old_names <- names(...future.oldEnvVars)
[10:24:40.941]                 envs <- base::Sys.getenv()
[10:24:40.941]                 names <- names(envs)
[10:24:40.941]                 common <- intersect(names, old_names)
[10:24:40.941]                 added <- setdiff(names, old_names)
[10:24:40.941]                 removed <- setdiff(old_names, names)
[10:24:40.941]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:40.941]                   envs[common]]
[10:24:40.941]                 NAMES <- toupper(changed)
[10:24:40.941]                 args <- list()
[10:24:40.941]                 for (kk in seq_along(NAMES)) {
[10:24:40.941]                   name <- changed[[kk]]
[10:24:40.941]                   NAME <- NAMES[[kk]]
[10:24:40.941]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:40.941]                     next
[10:24:40.941]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:40.941]                 }
[10:24:40.941]                 NAMES <- toupper(added)
[10:24:40.941]                 for (kk in seq_along(NAMES)) {
[10:24:40.941]                   name <- added[[kk]]
[10:24:40.941]                   NAME <- NAMES[[kk]]
[10:24:40.941]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:40.941]                     next
[10:24:40.941]                   args[[name]] <- ""
[10:24:40.941]                 }
[10:24:40.941]                 NAMES <- toupper(removed)
[10:24:40.941]                 for (kk in seq_along(NAMES)) {
[10:24:40.941]                   name <- removed[[kk]]
[10:24:40.941]                   NAME <- NAMES[[kk]]
[10:24:40.941]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:40.941]                     next
[10:24:40.941]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:40.941]                 }
[10:24:40.941]                 if (length(args) > 0) 
[10:24:40.941]                   base::do.call(base::Sys.setenv, args = args)
[10:24:40.941]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:40.941]             }
[10:24:40.941]             else {
[10:24:40.941]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:40.941]             }
[10:24:40.941]             {
[10:24:40.941]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:40.941]                   0L) {
[10:24:40.941]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:40.941]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:40.941]                   base::options(opts)
[10:24:40.941]                 }
[10:24:40.941]                 {
[10:24:40.941]                   {
[10:24:40.941]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:40.941]                     NULL
[10:24:40.941]                   }
[10:24:40.941]                   options(future.plan = NULL)
[10:24:40.941]                   if (is.na(NA_character_)) 
[10:24:40.941]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:40.941]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:40.941]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:40.941]                     envir = parent.frame()) 
[10:24:40.941]                   {
[10:24:40.941]                     default_workers <- missing(workers)
[10:24:40.941]                     if (is.function(workers)) 
[10:24:40.941]                       workers <- workers()
[10:24:40.941]                     workers <- structure(as.integer(workers), 
[10:24:40.941]                       class = class(workers))
[10:24:40.941]                     stop_if_not(is.finite(workers), workers >= 
[10:24:40.941]                       1L)
[10:24:40.941]                     if ((workers == 1L && !inherits(workers, 
[10:24:40.941]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:40.941]                       if (default_workers) 
[10:24:40.941]                         supportsMulticore(warn = TRUE)
[10:24:40.941]                       return(sequential(..., envir = envir))
[10:24:40.941]                     }
[10:24:40.941]                     oopts <- options(mc.cores = workers)
[10:24:40.941]                     on.exit(options(oopts))
[10:24:40.941]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:40.941]                       envir = envir)
[10:24:40.941]                     if (!future$lazy) 
[10:24:40.941]                       future <- run(future)
[10:24:40.941]                     invisible(future)
[10:24:40.941]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:40.941]                 }
[10:24:40.941]             }
[10:24:40.941]         }
[10:24:40.941]     })
[10:24:40.941]     if (TRUE) {
[10:24:40.941]         base::sink(type = "output", split = FALSE)
[10:24:40.941]         if (FALSE) {
[10:24:40.941]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:40.941]         }
[10:24:40.941]         else {
[10:24:40.941]             ...future.result["stdout"] <- base::list(NULL)
[10:24:40.941]         }
[10:24:40.941]         base::close(...future.stdout)
[10:24:40.941]         ...future.stdout <- NULL
[10:24:40.941]     }
[10:24:40.941]     ...future.result$conditions <- ...future.conditions
[10:24:40.941]     ...future.result$finished <- base::Sys.time()
[10:24:40.941]     ...future.result
[10:24:40.941] }
[10:24:40.943] assign_globals() ...
[10:24:40.943] List of 5
[10:24:40.943]  $ ...future.FUN            :function (x)  
[10:24:40.943]  $ future.call.arguments    : list()
[10:24:40.943]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:40.943]  $ ...future.elements_ii    :List of 1
[10:24:40.943]   ..$ : int 1
[10:24:40.943]  $ ...future.seeds_ii       : NULL
[10:24:40.943]  $ ...future.globals.maxSize: NULL
[10:24:40.943]  - attr(*, "where")=List of 5
[10:24:40.943]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:40.943]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:40.943]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:40.943]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:40.943]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:40.943]  - attr(*, "resolved")= logi FALSE
[10:24:40.943]  - attr(*, "total_size")= num 4720
[10:24:40.943]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:40.943]  - attr(*, "already-done")= logi TRUE
[10:24:40.950] - reassign environment for ‘...future.FUN’
[10:24:40.950] - copied ‘...future.FUN’ to environment
[10:24:40.950] - copied ‘future.call.arguments’ to environment
[10:24:40.951] - copied ‘...future.elements_ii’ to environment
[10:24:40.951] - copied ‘...future.seeds_ii’ to environment
[10:24:40.951] - copied ‘...future.globals.maxSize’ to environment
[10:24:40.951] assign_globals() ... done
[10:24:40.951] requestCore(): workers = 2
[10:24:40.954] MulticoreFuture started
[10:24:40.955] - Launch lazy future ... done
[10:24:40.955] plan(): Setting new future strategy stack:
[10:24:40.956] run() for ‘MulticoreFuture’ ... done
[10:24:40.956] Created future:
[10:24:40.956] List of future strategies:
[10:24:40.956] 1. sequential:
[10:24:40.956]    - args: function (..., envir = parent.frame())
[10:24:40.956]    - tweaked: FALSE
[10:24:40.956]    - call: NULL
[10:24:40.957] plan(): nbrOfWorkers() = 1
[10:24:40.956] MulticoreFuture:
[10:24:40.956] Label: ‘future_lapply-1’
[10:24:40.956] Expression:
[10:24:40.956] {
[10:24:40.956]     do.call(function(...) {
[10:24:40.956]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:40.956]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:40.956]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:40.956]             on.exit(options(oopts), add = TRUE)
[10:24:40.956]         }
[10:24:40.956]         {
[10:24:40.956]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:40.956]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:40.956]                 ...future.FUN(...future.X_jj, ...)
[10:24:40.956]             })
[10:24:40.956]         }
[10:24:40.956]     }, args = future.call.arguments)
[10:24:40.956] }
[10:24:40.956] Lazy evaluation: FALSE
[10:24:40.956] Asynchronous evaluation: TRUE
[10:24:40.956] Local evaluation: TRUE
[10:24:40.956] Environment: R_GlobalEnv
[10:24:40.956] Capture standard output: FALSE
[10:24:40.956] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:40.956] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:40.956] Packages: <none>
[10:24:40.956] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:40.956] Resolved: FALSE
[10:24:40.956] Value: <not collected>
[10:24:40.956] Conditions captured: <none>
[10:24:40.956] Early signaling: FALSE
[10:24:40.956] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:40.956] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:40.973] Chunk #1 of 2 ... DONE
[10:24:40.973] Chunk #2 of 2 ...
[10:24:40.973]  - Finding globals in 'X' for chunk #2 ...
[10:24:40.974] getGlobalsAndPackages() ...
[10:24:40.974] Searching for globals...
[10:24:40.975] 
[10:24:40.975] Searching for globals ... DONE
[10:24:40.975] - globals: [0] <none>
[10:24:40.975] getGlobalsAndPackages() ... DONE
[10:24:40.975]    + additional globals found: [n=0] 
[10:24:40.976]    + additional namespaces needed: [n=0] 
[10:24:40.976]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:40.976]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:40.976]  - seeds: <none>
[10:24:40.976]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:40.977] getGlobalsAndPackages() ...
[10:24:40.977] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:40.977] Resolving globals: FALSE
[10:24:40.977] Tweak future expression to call with '...' arguments ...
[10:24:40.978] {
[10:24:40.978]     do.call(function(...) {
[10:24:40.978]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:40.978]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:40.978]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:40.978]             on.exit(options(oopts), add = TRUE)
[10:24:40.978]         }
[10:24:40.978]         {
[10:24:40.978]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:40.978]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:40.978]                 ...future.FUN(...future.X_jj, ...)
[10:24:40.978]             })
[10:24:40.978]         }
[10:24:40.978]     }, args = future.call.arguments)
[10:24:40.978] }
[10:24:40.978] Tweak future expression to call with '...' arguments ... DONE
[10:24:40.979] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:40.979] 
[10:24:40.979] getGlobalsAndPackages() ... DONE
[10:24:40.980] run() for ‘Future’ ...
[10:24:40.980] - state: ‘created’
[10:24:40.980] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:40.985] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:40.986] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:40.986]   - Field: ‘label’
[10:24:40.986]   - Field: ‘local’
[10:24:40.986]   - Field: ‘owner’
[10:24:40.986]   - Field: ‘envir’
[10:24:40.986]   - Field: ‘workers’
[10:24:40.986]   - Field: ‘packages’
[10:24:40.987]   - Field: ‘gc’
[10:24:40.987]   - Field: ‘job’
[10:24:40.987]   - Field: ‘conditions’
[10:24:40.987]   - Field: ‘expr’
[10:24:40.987]   - Field: ‘uuid’
[10:24:40.987]   - Field: ‘seed’
[10:24:40.988]   - Field: ‘version’
[10:24:40.988]   - Field: ‘result’
[10:24:40.988]   - Field: ‘asynchronous’
[10:24:40.988]   - Field: ‘calls’
[10:24:40.988]   - Field: ‘globals’
[10:24:40.988]   - Field: ‘stdout’
[10:24:40.988]   - Field: ‘earlySignal’
[10:24:40.989]   - Field: ‘lazy’
[10:24:40.989]   - Field: ‘state’
[10:24:40.989] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:40.989] - Launch lazy future ...
[10:24:40.989] Packages needed by the future expression (n = 0): <none>
[10:24:40.990] Packages needed by future strategies (n = 0): <none>
[10:24:40.990] {
[10:24:40.990]     {
[10:24:40.990]         {
[10:24:40.990]             ...future.startTime <- base::Sys.time()
[10:24:40.990]             {
[10:24:40.990]                 {
[10:24:40.990]                   {
[10:24:40.990]                     {
[10:24:40.990]                       base::local({
[10:24:40.990]                         has_future <- base::requireNamespace("future", 
[10:24:40.990]                           quietly = TRUE)
[10:24:40.990]                         if (has_future) {
[10:24:40.990]                           ns <- base::getNamespace("future")
[10:24:40.990]                           version <- ns[[".package"]][["version"]]
[10:24:40.990]                           if (is.null(version)) 
[10:24:40.990]                             version <- utils::packageVersion("future")
[10:24:40.990]                         }
[10:24:40.990]                         else {
[10:24:40.990]                           version <- NULL
[10:24:40.990]                         }
[10:24:40.990]                         if (!has_future || version < "1.8.0") {
[10:24:40.990]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:40.990]                             "", base::R.version$version.string), 
[10:24:40.990]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:40.990]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:40.990]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:40.990]                               "release", "version")], collapse = " "), 
[10:24:40.990]                             hostname = base::Sys.info()[["nodename"]])
[10:24:40.990]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:40.990]                             info)
[10:24:40.990]                           info <- base::paste(info, collapse = "; ")
[10:24:40.990]                           if (!has_future) {
[10:24:40.990]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:40.990]                               info)
[10:24:40.990]                           }
[10:24:40.990]                           else {
[10:24:40.990]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:40.990]                               info, version)
[10:24:40.990]                           }
[10:24:40.990]                           base::stop(msg)
[10:24:40.990]                         }
[10:24:40.990]                       })
[10:24:40.990]                     }
[10:24:40.990]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:40.990]                     base::options(mc.cores = 1L)
[10:24:40.990]                   }
[10:24:40.990]                   options(future.plan = NULL)
[10:24:40.990]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:40.990]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:40.990]                 }
[10:24:40.990]                 ...future.workdir <- getwd()
[10:24:40.990]             }
[10:24:40.990]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:40.990]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:40.990]         }
[10:24:40.990]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:40.990]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:40.990]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:40.990]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:40.990]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:40.990]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:40.990]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:40.990]             base::names(...future.oldOptions))
[10:24:40.990]     }
[10:24:40.990]     if (FALSE) {
[10:24:40.990]     }
[10:24:40.990]     else {
[10:24:40.990]         if (FALSE) {
[10:24:40.990]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:40.990]                 open = "w")
[10:24:40.990]         }
[10:24:40.990]         else {
[10:24:40.990]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:40.990]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:40.990]         }
[10:24:40.990]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:40.990]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:40.990]             base::sink(type = "output", split = FALSE)
[10:24:40.990]             base::close(...future.stdout)
[10:24:40.990]         }, add = TRUE)
[10:24:40.990]     }
[10:24:40.990]     ...future.frame <- base::sys.nframe()
[10:24:40.990]     ...future.conditions <- base::list()
[10:24:40.990]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:40.990]     if (FALSE) {
[10:24:40.990]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:40.990]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:40.990]     }
[10:24:40.990]     ...future.result <- base::tryCatch({
[10:24:40.990]         base::withCallingHandlers({
[10:24:40.990]             ...future.value <- base::withVisible(base::local({
[10:24:40.990]                 withCallingHandlers({
[10:24:40.990]                   {
[10:24:40.990]                     do.call(function(...) {
[10:24:40.990]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:40.990]                       if (!identical(...future.globals.maxSize.org, 
[10:24:40.990]                         ...future.globals.maxSize)) {
[10:24:40.990]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:40.990]                         on.exit(options(oopts), add = TRUE)
[10:24:40.990]                       }
[10:24:40.990]                       {
[10:24:40.990]                         lapply(seq_along(...future.elements_ii), 
[10:24:40.990]                           FUN = function(jj) {
[10:24:40.990]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:40.990]                             ...future.FUN(...future.X_jj, ...)
[10:24:40.990]                           })
[10:24:40.990]                       }
[10:24:40.990]                     }, args = future.call.arguments)
[10:24:40.990]                   }
[10:24:40.990]                 }, immediateCondition = function(cond) {
[10:24:40.990]                   save_rds <- function (object, pathname, ...) 
[10:24:40.990]                   {
[10:24:40.990]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:40.990]                     if (file_test("-f", pathname_tmp)) {
[10:24:40.990]                       fi_tmp <- file.info(pathname_tmp)
[10:24:40.990]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:40.990]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:40.990]                         fi_tmp[["mtime"]])
[10:24:40.990]                     }
[10:24:40.990]                     tryCatch({
[10:24:40.990]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:40.990]                     }, error = function(ex) {
[10:24:40.990]                       msg <- conditionMessage(ex)
[10:24:40.990]                       fi_tmp <- file.info(pathname_tmp)
[10:24:40.990]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:40.990]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:40.990]                         fi_tmp[["mtime"]], msg)
[10:24:40.990]                       ex$message <- msg
[10:24:40.990]                       stop(ex)
[10:24:40.990]                     })
[10:24:40.990]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:40.990]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:40.990]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:40.990]                       fi_tmp <- file.info(pathname_tmp)
[10:24:40.990]                       fi <- file.info(pathname)
[10:24:40.990]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:40.990]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:40.990]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:40.990]                         fi[["size"]], fi[["mtime"]])
[10:24:40.990]                       stop(msg)
[10:24:40.990]                     }
[10:24:40.990]                     invisible(pathname)
[10:24:40.990]                   }
[10:24:40.990]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:40.990]                     rootPath = tempdir()) 
[10:24:40.990]                   {
[10:24:40.990]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:40.990]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:40.990]                       tmpdir = path, fileext = ".rds")
[10:24:40.990]                     save_rds(obj, file)
[10:24:40.990]                   }
[10:24:40.990]                   saveImmediateCondition(cond, path = "/tmp/Rtmp5boaqN/.future/immediateConditions")
[10:24:40.990]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:40.990]                   {
[10:24:40.990]                     inherits <- base::inherits
[10:24:40.990]                     invokeRestart <- base::invokeRestart
[10:24:40.990]                     is.null <- base::is.null
[10:24:40.990]                     muffled <- FALSE
[10:24:40.990]                     if (inherits(cond, "message")) {
[10:24:40.990]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:40.990]                       if (muffled) 
[10:24:40.990]                         invokeRestart("muffleMessage")
[10:24:40.990]                     }
[10:24:40.990]                     else if (inherits(cond, "warning")) {
[10:24:40.990]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:40.990]                       if (muffled) 
[10:24:40.990]                         invokeRestart("muffleWarning")
[10:24:40.990]                     }
[10:24:40.990]                     else if (inherits(cond, "condition")) {
[10:24:40.990]                       if (!is.null(pattern)) {
[10:24:40.990]                         computeRestarts <- base::computeRestarts
[10:24:40.990]                         grepl <- base::grepl
[10:24:40.990]                         restarts <- computeRestarts(cond)
[10:24:40.990]                         for (restart in restarts) {
[10:24:40.990]                           name <- restart$name
[10:24:40.990]                           if (is.null(name)) 
[10:24:40.990]                             next
[10:24:40.990]                           if (!grepl(pattern, name)) 
[10:24:40.990]                             next
[10:24:40.990]                           invokeRestart(restart)
[10:24:40.990]                           muffled <- TRUE
[10:24:40.990]                           break
[10:24:40.990]                         }
[10:24:40.990]                       }
[10:24:40.990]                     }
[10:24:40.990]                     invisible(muffled)
[10:24:40.990]                   }
[10:24:40.990]                   muffleCondition(cond)
[10:24:40.990]                 })
[10:24:40.990]             }))
[10:24:40.990]             future::FutureResult(value = ...future.value$value, 
[10:24:40.990]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:40.990]                   ...future.rng), globalenv = if (FALSE) 
[10:24:40.990]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:40.990]                     ...future.globalenv.names))
[10:24:40.990]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:40.990]         }, condition = base::local({
[10:24:40.990]             c <- base::c
[10:24:40.990]             inherits <- base::inherits
[10:24:40.990]             invokeRestart <- base::invokeRestart
[10:24:40.990]             length <- base::length
[10:24:40.990]             list <- base::list
[10:24:40.990]             seq.int <- base::seq.int
[10:24:40.990]             signalCondition <- base::signalCondition
[10:24:40.990]             sys.calls <- base::sys.calls
[10:24:40.990]             `[[` <- base::`[[`
[10:24:40.990]             `+` <- base::`+`
[10:24:40.990]             `<<-` <- base::`<<-`
[10:24:40.990]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:40.990]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:40.990]                   3L)]
[10:24:40.990]             }
[10:24:40.990]             function(cond) {
[10:24:40.990]                 is_error <- inherits(cond, "error")
[10:24:40.990]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:40.990]                   NULL)
[10:24:40.990]                 if (is_error) {
[10:24:40.990]                   sessionInformation <- function() {
[10:24:40.990]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:40.990]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:40.990]                       search = base::search(), system = base::Sys.info())
[10:24:40.990]                   }
[10:24:40.990]                   ...future.conditions[[length(...future.conditions) + 
[10:24:40.990]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:40.990]                     cond$call), session = sessionInformation(), 
[10:24:40.990]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:40.990]                   signalCondition(cond)
[10:24:40.990]                 }
[10:24:40.990]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:40.990]                 "immediateCondition"))) {
[10:24:40.990]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:40.990]                   ...future.conditions[[length(...future.conditions) + 
[10:24:40.990]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:40.990]                   if (TRUE && !signal) {
[10:24:40.990]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:40.990]                     {
[10:24:40.990]                       inherits <- base::inherits
[10:24:40.990]                       invokeRestart <- base::invokeRestart
[10:24:40.990]                       is.null <- base::is.null
[10:24:40.990]                       muffled <- FALSE
[10:24:40.990]                       if (inherits(cond, "message")) {
[10:24:40.990]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:40.990]                         if (muffled) 
[10:24:40.990]                           invokeRestart("muffleMessage")
[10:24:40.990]                       }
[10:24:40.990]                       else if (inherits(cond, "warning")) {
[10:24:40.990]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:40.990]                         if (muffled) 
[10:24:40.990]                           invokeRestart("muffleWarning")
[10:24:40.990]                       }
[10:24:40.990]                       else if (inherits(cond, "condition")) {
[10:24:40.990]                         if (!is.null(pattern)) {
[10:24:40.990]                           computeRestarts <- base::computeRestarts
[10:24:40.990]                           grepl <- base::grepl
[10:24:40.990]                           restarts <- computeRestarts(cond)
[10:24:40.990]                           for (restart in restarts) {
[10:24:40.990]                             name <- restart$name
[10:24:40.990]                             if (is.null(name)) 
[10:24:40.990]                               next
[10:24:40.990]                             if (!grepl(pattern, name)) 
[10:24:40.990]                               next
[10:24:40.990]                             invokeRestart(restart)
[10:24:40.990]                             muffled <- TRUE
[10:24:40.990]                             break
[10:24:40.990]                           }
[10:24:40.990]                         }
[10:24:40.990]                       }
[10:24:40.990]                       invisible(muffled)
[10:24:40.990]                     }
[10:24:40.990]                     muffleCondition(cond, pattern = "^muffle")
[10:24:40.990]                   }
[10:24:40.990]                 }
[10:24:40.990]                 else {
[10:24:40.990]                   if (TRUE) {
[10:24:40.990]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:40.990]                     {
[10:24:40.990]                       inherits <- base::inherits
[10:24:40.990]                       invokeRestart <- base::invokeRestart
[10:24:40.990]                       is.null <- base::is.null
[10:24:40.990]                       muffled <- FALSE
[10:24:40.990]                       if (inherits(cond, "message")) {
[10:24:40.990]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:40.990]                         if (muffled) 
[10:24:40.990]                           invokeRestart("muffleMessage")
[10:24:40.990]                       }
[10:24:40.990]                       else if (inherits(cond, "warning")) {
[10:24:40.990]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:40.990]                         if (muffled) 
[10:24:40.990]                           invokeRestart("muffleWarning")
[10:24:40.990]                       }
[10:24:40.990]                       else if (inherits(cond, "condition")) {
[10:24:40.990]                         if (!is.null(pattern)) {
[10:24:40.990]                           computeRestarts <- base::computeRestarts
[10:24:40.990]                           grepl <- base::grepl
[10:24:40.990]                           restarts <- computeRestarts(cond)
[10:24:40.990]                           for (restart in restarts) {
[10:24:40.990]                             name <- restart$name
[10:24:40.990]                             if (is.null(name)) 
[10:24:40.990]                               next
[10:24:40.990]                             if (!grepl(pattern, name)) 
[10:24:40.990]                               next
[10:24:40.990]                             invokeRestart(restart)
[10:24:40.990]                             muffled <- TRUE
[10:24:40.990]                             break
[10:24:40.990]                           }
[10:24:40.990]                         }
[10:24:40.990]                       }
[10:24:40.990]                       invisible(muffled)
[10:24:40.990]                     }
[10:24:40.990]                     muffleCondition(cond, pattern = "^muffle")
[10:24:40.990]                   }
[10:24:40.990]                 }
[10:24:40.990]             }
[10:24:40.990]         }))
[10:24:40.990]     }, error = function(ex) {
[10:24:40.990]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:40.990]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:40.990]                 ...future.rng), started = ...future.startTime, 
[10:24:40.990]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:40.990]             version = "1.8"), class = "FutureResult")
[10:24:40.990]     }, finally = {
[10:24:40.990]         if (!identical(...future.workdir, getwd())) 
[10:24:40.990]             setwd(...future.workdir)
[10:24:40.990]         {
[10:24:40.990]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:40.990]                 ...future.oldOptions$nwarnings <- NULL
[10:24:40.990]             }
[10:24:40.990]             base::options(...future.oldOptions)
[10:24:40.990]             if (.Platform$OS.type == "windows") {
[10:24:40.990]                 old_names <- names(...future.oldEnvVars)
[10:24:40.990]                 envs <- base::Sys.getenv()
[10:24:40.990]                 names <- names(envs)
[10:24:40.990]                 common <- intersect(names, old_names)
[10:24:40.990]                 added <- setdiff(names, old_names)
[10:24:40.990]                 removed <- setdiff(old_names, names)
[10:24:40.990]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:40.990]                   envs[common]]
[10:24:40.990]                 NAMES <- toupper(changed)
[10:24:40.990]                 args <- list()
[10:24:40.990]                 for (kk in seq_along(NAMES)) {
[10:24:40.990]                   name <- changed[[kk]]
[10:24:40.990]                   NAME <- NAMES[[kk]]
[10:24:40.990]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:40.990]                     next
[10:24:40.990]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:40.990]                 }
[10:24:40.990]                 NAMES <- toupper(added)
[10:24:40.990]                 for (kk in seq_along(NAMES)) {
[10:24:40.990]                   name <- added[[kk]]
[10:24:40.990]                   NAME <- NAMES[[kk]]
[10:24:40.990]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:40.990]                     next
[10:24:40.990]                   args[[name]] <- ""
[10:24:40.990]                 }
[10:24:40.990]                 NAMES <- toupper(removed)
[10:24:40.990]                 for (kk in seq_along(NAMES)) {
[10:24:40.990]                   name <- removed[[kk]]
[10:24:40.990]                   NAME <- NAMES[[kk]]
[10:24:40.990]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:40.990]                     next
[10:24:40.990]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:40.990]                 }
[10:24:40.990]                 if (length(args) > 0) 
[10:24:40.990]                   base::do.call(base::Sys.setenv, args = args)
[10:24:40.990]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:40.990]             }
[10:24:40.990]             else {
[10:24:40.990]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:40.990]             }
[10:24:40.990]             {
[10:24:40.990]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:40.990]                   0L) {
[10:24:40.990]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:40.990]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:40.990]                   base::options(opts)
[10:24:40.990]                 }
[10:24:40.990]                 {
[10:24:40.990]                   {
[10:24:40.990]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:40.990]                     NULL
[10:24:40.990]                   }
[10:24:40.990]                   options(future.plan = NULL)
[10:24:40.990]                   if (is.na(NA_character_)) 
[10:24:40.990]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:40.990]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:40.990]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:40.990]                     envir = parent.frame()) 
[10:24:40.990]                   {
[10:24:40.990]                     default_workers <- missing(workers)
[10:24:40.990]                     if (is.function(workers)) 
[10:24:40.990]                       workers <- workers()
[10:24:40.990]                     workers <- structure(as.integer(workers), 
[10:24:40.990]                       class = class(workers))
[10:24:40.990]                     stop_if_not(is.finite(workers), workers >= 
[10:24:40.990]                       1L)
[10:24:40.990]                     if ((workers == 1L && !inherits(workers, 
[10:24:40.990]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:40.990]                       if (default_workers) 
[10:24:40.990]                         supportsMulticore(warn = TRUE)
[10:24:40.990]                       return(sequential(..., envir = envir))
[10:24:40.990]                     }
[10:24:40.990]                     oopts <- options(mc.cores = workers)
[10:24:40.990]                     on.exit(options(oopts))
[10:24:40.990]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:40.990]                       envir = envir)
[10:24:40.990]                     if (!future$lazy) 
[10:24:40.990]                       future <- run(future)
[10:24:40.990]                     invisible(future)
[10:24:40.990]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:40.990]                 }
[10:24:40.990]             }
[10:24:40.990]         }
[10:24:40.990]     })
[10:24:40.990]     if (TRUE) {
[10:24:40.990]         base::sink(type = "output", split = FALSE)
[10:24:40.990]         if (FALSE) {
[10:24:40.990]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:40.990]         }
[10:24:40.990]         else {
[10:24:40.990]             ...future.result["stdout"] <- base::list(NULL)
[10:24:40.990]         }
[10:24:40.990]         base::close(...future.stdout)
[10:24:40.990]         ...future.stdout <- NULL
[10:24:40.990]     }
[10:24:40.990]     ...future.result$conditions <- ...future.conditions
[10:24:40.990]     ...future.result$finished <- base::Sys.time()
[10:24:40.990]     ...future.result
[10:24:40.990] }
[10:24:40.994] assign_globals() ...
[10:24:40.994] List of 5
[10:24:40.994]  $ ...future.FUN            :function (x)  
[10:24:40.994]  $ future.call.arguments    : list()
[10:24:40.994]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:40.994]  $ ...future.elements_ii    :List of 1
[10:24:40.994]   ..$ : int 0
[10:24:40.994]  $ ...future.seeds_ii       : NULL
[10:24:40.994]  $ ...future.globals.maxSize: NULL
[10:24:40.994]  - attr(*, "where")=List of 5
[10:24:40.994]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:40.994]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:40.994]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:40.994]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:40.994]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:40.994]  - attr(*, "resolved")= logi FALSE
[10:24:40.994]  - attr(*, "total_size")= num 4720
[10:24:40.994]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:40.994]  - attr(*, "already-done")= logi TRUE
[10:24:41.001] - reassign environment for ‘...future.FUN’
[10:24:41.001] - copied ‘...future.FUN’ to environment
[10:24:41.001] - copied ‘future.call.arguments’ to environment
[10:24:41.002] - copied ‘...future.elements_ii’ to environment
[10:24:41.002] - copied ‘...future.seeds_ii’ to environment
[10:24:41.002] - copied ‘...future.globals.maxSize’ to environment
[10:24:41.002] assign_globals() ... done
[10:24:41.002] requestCore(): workers = 2
[10:24:41.011] MulticoreFuture started
[10:24:41.012] - Launch lazy future ... done
[10:24:41.012] plan(): Setting new future strategy stack:
[10:24:41.012] run() for ‘MulticoreFuture’ ... done
[10:24:41.013] Created future:
[10:24:41.013] List of future strategies:
[10:24:41.013] 1. sequential:
[10:24:41.013]    - args: function (..., envir = parent.frame())
[10:24:41.013]    - tweaked: FALSE
[10:24:41.013]    - call: NULL
[10:24:41.014] plan(): nbrOfWorkers() = 1
[10:24:41.017] plan(): Setting new future strategy stack:
[10:24:41.017] List of future strategies:
[10:24:41.017] 1. multicore:
[10:24:41.017]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:41.017]    - tweaked: FALSE
[10:24:41.017]    - call: plan(strategy)
[10:24:41.024] plan(): nbrOfWorkers() = 2
[10:24:41.013] MulticoreFuture:
[10:24:41.013] Label: ‘future_lapply-2’
[10:24:41.013] Expression:
[10:24:41.013] {
[10:24:41.013]     do.call(function(...) {
[10:24:41.013]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:41.013]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:41.013]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:41.013]             on.exit(options(oopts), add = TRUE)
[10:24:41.013]         }
[10:24:41.013]         {
[10:24:41.013]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:41.013]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:41.013]                 ...future.FUN(...future.X_jj, ...)
[10:24:41.013]             })
[10:24:41.013]         }
[10:24:41.013]     }, args = future.call.arguments)
[10:24:41.013] }
[10:24:41.013] Lazy evaluation: FALSE
[10:24:41.013] Asynchronous evaluation: TRUE
[10:24:41.013] Local evaluation: TRUE
[10:24:41.013] Environment: R_GlobalEnv
[10:24:41.013] Capture standard output: FALSE
[10:24:41.013] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:41.013] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:41.013] Packages: <none>
[10:24:41.013] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:41.013] Resolved: TRUE
[10:24:41.013] Value: <not collected>
[10:24:41.013] Conditions captured: <none>
[10:24:41.013] Early signaling: FALSE
[10:24:41.013] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:41.013] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:41.025] Chunk #2 of 2 ... DONE
[10:24:41.025] Launching 2 futures (chunks) ... DONE
[10:24:41.025] Resolving 2 futures (chunks) ...
[10:24:41.025] resolve() on list ...
[10:24:41.026]  recursive: 0
[10:24:41.026]  length: 2
[10:24:41.026] 
[10:24:41.037] Future #2
[10:24:41.038] result() for MulticoreFuture ...
[10:24:41.040] result() for MulticoreFuture ...
[10:24:41.040] result() for MulticoreFuture ... done
[10:24:41.040] result() for MulticoreFuture ... done
[10:24:41.041] result() for MulticoreFuture ...
[10:24:41.041] result() for MulticoreFuture ... done
[10:24:41.041] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:24:41.041] - nx: 2
[10:24:41.041] - relay: TRUE
[10:24:41.041] - stdout: TRUE
[10:24:41.042] - signal: TRUE
[10:24:41.042] - resignal: FALSE
[10:24:41.042] - force: TRUE
[10:24:41.042] - relayed: [n=2] FALSE, FALSE
[10:24:41.042] - queued futures: [n=2] FALSE, FALSE
[10:24:41.042]  - until=1
[10:24:41.042]  - relaying element #1
[10:24:41.042] - relayed: [n=2] FALSE, FALSE
[10:24:41.043] - queued futures: [n=2] FALSE, TRUE
[10:24:41.043] signalConditionsASAP(NULL, pos=2) ... done
[10:24:41.043]  length: 1 (resolved future 2)
[10:24:41.460] plan(): Setting new future strategy stack:
[10:24:41.460] List of future strategies:
[10:24:41.460] 1. multicore:
[10:24:41.460]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:41.460]    - tweaked: FALSE
[10:24:41.460]    - call: plan(strategy)
[10:24:41.465] plan(): nbrOfWorkers() = 2
[10:24:41.465] Future #1
[10:24:41.465] result() for MulticoreFuture ...
[10:24:41.466] result() for MulticoreFuture ...
[10:24:41.466] result() for MulticoreFuture ... done
[10:24:41.467] result() for MulticoreFuture ... done
[10:24:41.467] result() for MulticoreFuture ...
[10:24:41.467] result() for MulticoreFuture ... done
[10:24:41.467] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:24:41.467] - nx: 2
[10:24:41.467] - relay: TRUE
[10:24:41.467] - stdout: TRUE
[10:24:41.468] - signal: TRUE
[10:24:41.468] - resignal: FALSE
[10:24:41.468] - force: TRUE
[10:24:41.468] - relayed: [n=2] FALSE, FALSE
[10:24:41.468] - queued futures: [n=2] FALSE, TRUE
[10:24:41.468]  - until=1
[10:24:41.469]  - relaying element #1
[10:24:41.469] result() for MulticoreFuture ...
[10:24:41.469] result() for MulticoreFuture ... done
[10:24:41.469] result() for MulticoreFuture ...
[10:24:41.469] result() for MulticoreFuture ... done
[10:24:41.469] result() for MulticoreFuture ...
[10:24:41.469] result() for MulticoreFuture ... done
[10:24:41.470] result() for MulticoreFuture ...
[10:24:41.470] result() for MulticoreFuture ... done
[10:24:41.470] - relayed: [n=2] TRUE, FALSE
[10:24:41.470] - queued futures: [n=2] TRUE, TRUE
[10:24:41.470] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:24:41.470]  length: 0 (resolved future 1)
[10:24:41.471] Relaying remaining futures
[10:24:41.471] signalConditionsASAP(NULL, pos=0) ...
[10:24:41.471] - nx: 2
[10:24:41.471] - relay: TRUE
[10:24:41.471] - stdout: TRUE
[10:24:41.471] - signal: TRUE
[10:24:41.471] - resignal: FALSE
[10:24:41.471] - force: TRUE
[10:24:41.471] - relayed: [n=2] TRUE, FALSE
[10:24:41.472] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:41.472]  - relaying element #2
[10:24:41.472] result() for MulticoreFuture ...
[10:24:41.472] result() for MulticoreFuture ... done
[10:24:41.472] result() for MulticoreFuture ...
[10:24:41.472] result() for MulticoreFuture ... done
[10:24:41.472] result() for MulticoreFuture ...
[10:24:41.473] result() for MulticoreFuture ... done
[10:24:41.473] result() for MulticoreFuture ...
[10:24:41.473] result() for MulticoreFuture ... done
[10:24:41.473] - relayed: [n=2] TRUE, TRUE
[10:24:41.473] - queued futures: [n=2] TRUE, TRUE
[10:24:41.473] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[10:24:41.473] resolve() on list ... DONE
[10:24:41.473] result() for MulticoreFuture ...
[10:24:41.473] result() for MulticoreFuture ... done
[10:24:41.473] result() for MulticoreFuture ...
[10:24:41.474] result() for MulticoreFuture ... done
[10:24:41.474] result() for MulticoreFuture ...
[10:24:41.474] result() for MulticoreFuture ... done
[10:24:41.474] result() for MulticoreFuture ...
[10:24:41.474] result() for MulticoreFuture ... done
[10:24:41.474]  - Number of value chunks collected: 2
[10:24:41.474] Resolving 2 futures (chunks) ... DONE
[10:24:41.474] Reducing values from 2 chunks ...
[10:24:41.475]  - Number of values collected after concatenation: 2
[10:24:41.475]  - Number of values expected: 2
[10:24:41.475] Reducing values from 2 chunks ... DONE
[10:24:41.475] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[10:24:41.475] future_lapply() ...
[10:24:41.480] Number of chunks: 2
[10:24:41.480] getGlobalsAndPackagesXApply() ...
[10:24:41.480]  - future.globals: TRUE
[10:24:41.480] getGlobalsAndPackages() ...
[10:24:41.481] Searching for globals...
[10:24:41.482] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:24:41.482] Searching for globals ... DONE
[10:24:41.483] Resolving globals: FALSE
[10:24:41.483] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[10:24:41.483] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[10:24:41.484] - globals: [1] ‘FUN’
[10:24:41.484] 
[10:24:41.484] getGlobalsAndPackages() ... DONE
[10:24:41.484]  - globals found/used: [n=1] ‘FUN’
[10:24:41.484]  - needed namespaces: [n=0] 
[10:24:41.484] Finding globals ... DONE
[10:24:41.484]  - use_args: TRUE
[10:24:41.484]  - Getting '...' globals ...
[10:24:41.485] resolve() on list ...
[10:24:41.485]  recursive: 0
[10:24:41.485]  length: 1
[10:24:41.485]  elements: ‘...’
[10:24:41.485]  length: 0 (resolved future 1)
[10:24:41.485] resolve() on list ... DONE
[10:24:41.485]    - '...' content: [n=0] 
[10:24:41.485] List of 1
[10:24:41.485]  $ ...: list()
[10:24:41.485]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:41.485]  - attr(*, "where")=List of 1
[10:24:41.485]   ..$ ...:<environment: 0x55d2111e3810> 
[10:24:41.485]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:41.485]  - attr(*, "resolved")= logi TRUE
[10:24:41.485]  - attr(*, "total_size")= num NA
[10:24:41.490]  - Getting '...' globals ... DONE
[10:24:41.491] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:24:41.491] List of 2
[10:24:41.491]  $ ...future.FUN:function (x)  
[10:24:41.491]  $ ...          : list()
[10:24:41.491]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:41.491]  - attr(*, "where")=List of 2
[10:24:41.491]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:41.491]   ..$ ...          :<environment: 0x55d2111e3810> 
[10:24:41.491]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:41.491]  - attr(*, "resolved")= logi FALSE
[10:24:41.491]  - attr(*, "total_size")= num 4720
[10:24:41.494] Packages to be attached in all futures: [n=0] 
[10:24:41.494] getGlobalsAndPackagesXApply() ... DONE
[10:24:41.494] Number of futures (= number of chunks): 2
[10:24:41.494] Launching 2 futures (chunks) ...
[10:24:41.494] Chunk #1 of 2 ...
[10:24:41.494]  - Finding globals in 'X' for chunk #1 ...
[10:24:41.494] getGlobalsAndPackages() ...
[10:24:41.495] Searching for globals...
[10:24:41.495] 
[10:24:41.495] Searching for globals ... DONE
[10:24:41.495] - globals: [0] <none>
[10:24:41.495] getGlobalsAndPackages() ... DONE
[10:24:41.495]    + additional globals found: [n=0] 
[10:24:41.495]    + additional namespaces needed: [n=0] 
[10:24:41.495]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:41.495]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:41.496]  - seeds: <none>
[10:24:41.496]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:41.496] getGlobalsAndPackages() ...
[10:24:41.496] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:41.496] Resolving globals: FALSE
[10:24:41.496] Tweak future expression to call with '...' arguments ...
[10:24:41.496] {
[10:24:41.496]     do.call(function(...) {
[10:24:41.496]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:41.496]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:41.496]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:41.496]             on.exit(options(oopts), add = TRUE)
[10:24:41.496]         }
[10:24:41.496]         {
[10:24:41.496]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:41.496]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:41.496]                 ...future.FUN(...future.X_jj, ...)
[10:24:41.496]             })
[10:24:41.496]         }
[10:24:41.496]     }, args = future.call.arguments)
[10:24:41.496] }
[10:24:41.496] Tweak future expression to call with '...' arguments ... DONE
[10:24:41.497] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:41.497] 
[10:24:41.497] getGlobalsAndPackages() ... DONE
[10:24:41.497] run() for ‘Future’ ...
[10:24:41.497] - state: ‘created’
[10:24:41.498] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:41.501] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:41.501] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:41.501]   - Field: ‘label’
[10:24:41.502]   - Field: ‘local’
[10:24:41.502]   - Field: ‘owner’
[10:24:41.502]   - Field: ‘envir’
[10:24:41.502]   - Field: ‘workers’
[10:24:41.502]   - Field: ‘packages’
[10:24:41.502]   - Field: ‘gc’
[10:24:41.502]   - Field: ‘job’
[10:24:41.502]   - Field: ‘conditions’
[10:24:41.502]   - Field: ‘expr’
[10:24:41.502]   - Field: ‘uuid’
[10:24:41.503]   - Field: ‘seed’
[10:24:41.503]   - Field: ‘version’
[10:24:41.503]   - Field: ‘result’
[10:24:41.503]   - Field: ‘asynchronous’
[10:24:41.503]   - Field: ‘calls’
[10:24:41.503]   - Field: ‘globals’
[10:24:41.503]   - Field: ‘stdout’
[10:24:41.503]   - Field: ‘earlySignal’
[10:24:41.503]   - Field: ‘lazy’
[10:24:41.503]   - Field: ‘state’
[10:24:41.503] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:41.504] - Launch lazy future ...
[10:24:41.504] Packages needed by the future expression (n = 0): <none>
[10:24:41.504] Packages needed by future strategies (n = 0): <none>
[10:24:41.504] {
[10:24:41.504]     {
[10:24:41.504]         {
[10:24:41.504]             ...future.startTime <- base::Sys.time()
[10:24:41.504]             {
[10:24:41.504]                 {
[10:24:41.504]                   {
[10:24:41.504]                     {
[10:24:41.504]                       base::local({
[10:24:41.504]                         has_future <- base::requireNamespace("future", 
[10:24:41.504]                           quietly = TRUE)
[10:24:41.504]                         if (has_future) {
[10:24:41.504]                           ns <- base::getNamespace("future")
[10:24:41.504]                           version <- ns[[".package"]][["version"]]
[10:24:41.504]                           if (is.null(version)) 
[10:24:41.504]                             version <- utils::packageVersion("future")
[10:24:41.504]                         }
[10:24:41.504]                         else {
[10:24:41.504]                           version <- NULL
[10:24:41.504]                         }
[10:24:41.504]                         if (!has_future || version < "1.8.0") {
[10:24:41.504]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:41.504]                             "", base::R.version$version.string), 
[10:24:41.504]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:41.504]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:41.504]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:41.504]                               "release", "version")], collapse = " "), 
[10:24:41.504]                             hostname = base::Sys.info()[["nodename"]])
[10:24:41.504]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:41.504]                             info)
[10:24:41.504]                           info <- base::paste(info, collapse = "; ")
[10:24:41.504]                           if (!has_future) {
[10:24:41.504]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:41.504]                               info)
[10:24:41.504]                           }
[10:24:41.504]                           else {
[10:24:41.504]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:41.504]                               info, version)
[10:24:41.504]                           }
[10:24:41.504]                           base::stop(msg)
[10:24:41.504]                         }
[10:24:41.504]                       })
[10:24:41.504]                     }
[10:24:41.504]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:41.504]                     base::options(mc.cores = 1L)
[10:24:41.504]                   }
[10:24:41.504]                   options(future.plan = NULL)
[10:24:41.504]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:41.504]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:41.504]                 }
[10:24:41.504]                 ...future.workdir <- getwd()
[10:24:41.504]             }
[10:24:41.504]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:41.504]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:41.504]         }
[10:24:41.504]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:41.504]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:41.504]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:41.504]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:41.504]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:41.504]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:41.504]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:41.504]             base::names(...future.oldOptions))
[10:24:41.504]     }
[10:24:41.504]     if (FALSE) {
[10:24:41.504]     }
[10:24:41.504]     else {
[10:24:41.504]         if (TRUE) {
[10:24:41.504]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:41.504]                 open = "w")
[10:24:41.504]         }
[10:24:41.504]         else {
[10:24:41.504]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:41.504]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:41.504]         }
[10:24:41.504]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:41.504]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:41.504]             base::sink(type = "output", split = FALSE)
[10:24:41.504]             base::close(...future.stdout)
[10:24:41.504]         }, add = TRUE)
[10:24:41.504]     }
[10:24:41.504]     ...future.frame <- base::sys.nframe()
[10:24:41.504]     ...future.conditions <- base::list()
[10:24:41.504]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:41.504]     if (FALSE) {
[10:24:41.504]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:41.504]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:41.504]     }
[10:24:41.504]     ...future.result <- base::tryCatch({
[10:24:41.504]         base::withCallingHandlers({
[10:24:41.504]             ...future.value <- base::withVisible(base::local({
[10:24:41.504]                 withCallingHandlers({
[10:24:41.504]                   {
[10:24:41.504]                     do.call(function(...) {
[10:24:41.504]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:41.504]                       if (!identical(...future.globals.maxSize.org, 
[10:24:41.504]                         ...future.globals.maxSize)) {
[10:24:41.504]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:41.504]                         on.exit(options(oopts), add = TRUE)
[10:24:41.504]                       }
[10:24:41.504]                       {
[10:24:41.504]                         lapply(seq_along(...future.elements_ii), 
[10:24:41.504]                           FUN = function(jj) {
[10:24:41.504]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:41.504]                             ...future.FUN(...future.X_jj, ...)
[10:24:41.504]                           })
[10:24:41.504]                       }
[10:24:41.504]                     }, args = future.call.arguments)
[10:24:41.504]                   }
[10:24:41.504]                 }, immediateCondition = function(cond) {
[10:24:41.504]                   save_rds <- function (object, pathname, ...) 
[10:24:41.504]                   {
[10:24:41.504]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:41.504]                     if (file_test("-f", pathname_tmp)) {
[10:24:41.504]                       fi_tmp <- file.info(pathname_tmp)
[10:24:41.504]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:41.504]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:41.504]                         fi_tmp[["mtime"]])
[10:24:41.504]                     }
[10:24:41.504]                     tryCatch({
[10:24:41.504]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:41.504]                     }, error = function(ex) {
[10:24:41.504]                       msg <- conditionMessage(ex)
[10:24:41.504]                       fi_tmp <- file.info(pathname_tmp)
[10:24:41.504]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:41.504]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:41.504]                         fi_tmp[["mtime"]], msg)
[10:24:41.504]                       ex$message <- msg
[10:24:41.504]                       stop(ex)
[10:24:41.504]                     })
[10:24:41.504]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:41.504]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:41.504]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:41.504]                       fi_tmp <- file.info(pathname_tmp)
[10:24:41.504]                       fi <- file.info(pathname)
[10:24:41.504]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:41.504]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:41.504]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:41.504]                         fi[["size"]], fi[["mtime"]])
[10:24:41.504]                       stop(msg)
[10:24:41.504]                     }
[10:24:41.504]                     invisible(pathname)
[10:24:41.504]                   }
[10:24:41.504]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:41.504]                     rootPath = tempdir()) 
[10:24:41.504]                   {
[10:24:41.504]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:41.504]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:41.504]                       tmpdir = path, fileext = ".rds")
[10:24:41.504]                     save_rds(obj, file)
[10:24:41.504]                   }
[10:24:41.504]                   saveImmediateCondition(cond, path = "/tmp/Rtmp5boaqN/.future/immediateConditions")
[10:24:41.504]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:41.504]                   {
[10:24:41.504]                     inherits <- base::inherits
[10:24:41.504]                     invokeRestart <- base::invokeRestart
[10:24:41.504]                     is.null <- base::is.null
[10:24:41.504]                     muffled <- FALSE
[10:24:41.504]                     if (inherits(cond, "message")) {
[10:24:41.504]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:41.504]                       if (muffled) 
[10:24:41.504]                         invokeRestart("muffleMessage")
[10:24:41.504]                     }
[10:24:41.504]                     else if (inherits(cond, "warning")) {
[10:24:41.504]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:41.504]                       if (muffled) 
[10:24:41.504]                         invokeRestart("muffleWarning")
[10:24:41.504]                     }
[10:24:41.504]                     else if (inherits(cond, "condition")) {
[10:24:41.504]                       if (!is.null(pattern)) {
[10:24:41.504]                         computeRestarts <- base::computeRestarts
[10:24:41.504]                         grepl <- base::grepl
[10:24:41.504]                         restarts <- computeRestarts(cond)
[10:24:41.504]                         for (restart in restarts) {
[10:24:41.504]                           name <- restart$name
[10:24:41.504]                           if (is.null(name)) 
[10:24:41.504]                             next
[10:24:41.504]                           if (!grepl(pattern, name)) 
[10:24:41.504]                             next
[10:24:41.504]                           invokeRestart(restart)
[10:24:41.504]                           muffled <- TRUE
[10:24:41.504]                           break
[10:24:41.504]                         }
[10:24:41.504]                       }
[10:24:41.504]                     }
[10:24:41.504]                     invisible(muffled)
[10:24:41.504]                   }
[10:24:41.504]                   muffleCondition(cond)
[10:24:41.504]                 })
[10:24:41.504]             }))
[10:24:41.504]             future::FutureResult(value = ...future.value$value, 
[10:24:41.504]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:41.504]                   ...future.rng), globalenv = if (FALSE) 
[10:24:41.504]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:41.504]                     ...future.globalenv.names))
[10:24:41.504]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:41.504]         }, condition = base::local({
[10:24:41.504]             c <- base::c
[10:24:41.504]             inherits <- base::inherits
[10:24:41.504]             invokeRestart <- base::invokeRestart
[10:24:41.504]             length <- base::length
[10:24:41.504]             list <- base::list
[10:24:41.504]             seq.int <- base::seq.int
[10:24:41.504]             signalCondition <- base::signalCondition
[10:24:41.504]             sys.calls <- base::sys.calls
[10:24:41.504]             `[[` <- base::`[[`
[10:24:41.504]             `+` <- base::`+`
[10:24:41.504]             `<<-` <- base::`<<-`
[10:24:41.504]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:41.504]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:41.504]                   3L)]
[10:24:41.504]             }
[10:24:41.504]             function(cond) {
[10:24:41.504]                 is_error <- inherits(cond, "error")
[10:24:41.504]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:41.504]                   NULL)
[10:24:41.504]                 if (is_error) {
[10:24:41.504]                   sessionInformation <- function() {
[10:24:41.504]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:41.504]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:41.504]                       search = base::search(), system = base::Sys.info())
[10:24:41.504]                   }
[10:24:41.504]                   ...future.conditions[[length(...future.conditions) + 
[10:24:41.504]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:41.504]                     cond$call), session = sessionInformation(), 
[10:24:41.504]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:41.504]                   signalCondition(cond)
[10:24:41.504]                 }
[10:24:41.504]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:41.504]                 "immediateCondition"))) {
[10:24:41.504]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:41.504]                   ...future.conditions[[length(...future.conditions) + 
[10:24:41.504]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:41.504]                   if (TRUE && !signal) {
[10:24:41.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:41.504]                     {
[10:24:41.504]                       inherits <- base::inherits
[10:24:41.504]                       invokeRestart <- base::invokeRestart
[10:24:41.504]                       is.null <- base::is.null
[10:24:41.504]                       muffled <- FALSE
[10:24:41.504]                       if (inherits(cond, "message")) {
[10:24:41.504]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:41.504]                         if (muffled) 
[10:24:41.504]                           invokeRestart("muffleMessage")
[10:24:41.504]                       }
[10:24:41.504]                       else if (inherits(cond, "warning")) {
[10:24:41.504]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:41.504]                         if (muffled) 
[10:24:41.504]                           invokeRestart("muffleWarning")
[10:24:41.504]                       }
[10:24:41.504]                       else if (inherits(cond, "condition")) {
[10:24:41.504]                         if (!is.null(pattern)) {
[10:24:41.504]                           computeRestarts <- base::computeRestarts
[10:24:41.504]                           grepl <- base::grepl
[10:24:41.504]                           restarts <- computeRestarts(cond)
[10:24:41.504]                           for (restart in restarts) {
[10:24:41.504]                             name <- restart$name
[10:24:41.504]                             if (is.null(name)) 
[10:24:41.504]                               next
[10:24:41.504]                             if (!grepl(pattern, name)) 
[10:24:41.504]                               next
[10:24:41.504]                             invokeRestart(restart)
[10:24:41.504]                             muffled <- TRUE
[10:24:41.504]                             break
[10:24:41.504]                           }
[10:24:41.504]                         }
[10:24:41.504]                       }
[10:24:41.504]                       invisible(muffled)
[10:24:41.504]                     }
[10:24:41.504]                     muffleCondition(cond, pattern = "^muffle")
[10:24:41.504]                   }
[10:24:41.504]                 }
[10:24:41.504]                 else {
[10:24:41.504]                   if (TRUE) {
[10:24:41.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:41.504]                     {
[10:24:41.504]                       inherits <- base::inherits
[10:24:41.504]                       invokeRestart <- base::invokeRestart
[10:24:41.504]                       is.null <- base::is.null
[10:24:41.504]                       muffled <- FALSE
[10:24:41.504]                       if (inherits(cond, "message")) {
[10:24:41.504]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:41.504]                         if (muffled) 
[10:24:41.504]                           invokeRestart("muffleMessage")
[10:24:41.504]                       }
[10:24:41.504]                       else if (inherits(cond, "warning")) {
[10:24:41.504]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:41.504]                         if (muffled) 
[10:24:41.504]                           invokeRestart("muffleWarning")
[10:24:41.504]                       }
[10:24:41.504]                       else if (inherits(cond, "condition")) {
[10:24:41.504]                         if (!is.null(pattern)) {
[10:24:41.504]                           computeRestarts <- base::computeRestarts
[10:24:41.504]                           grepl <- base::grepl
[10:24:41.504]                           restarts <- computeRestarts(cond)
[10:24:41.504]                           for (restart in restarts) {
[10:24:41.504]                             name <- restart$name
[10:24:41.504]                             if (is.null(name)) 
[10:24:41.504]                               next
[10:24:41.504]                             if (!grepl(pattern, name)) 
[10:24:41.504]                               next
[10:24:41.504]                             invokeRestart(restart)
[10:24:41.504]                             muffled <- TRUE
[10:24:41.504]                             break
[10:24:41.504]                           }
[10:24:41.504]                         }
[10:24:41.504]                       }
[10:24:41.504]                       invisible(muffled)
[10:24:41.504]                     }
[10:24:41.504]                     muffleCondition(cond, pattern = "^muffle")
[10:24:41.504]                   }
[10:24:41.504]                 }
[10:24:41.504]             }
[10:24:41.504]         }))
[10:24:41.504]     }, error = function(ex) {
[10:24:41.504]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:41.504]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:41.504]                 ...future.rng), started = ...future.startTime, 
[10:24:41.504]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:41.504]             version = "1.8"), class = "FutureResult")
[10:24:41.504]     }, finally = {
[10:24:41.504]         if (!identical(...future.workdir, getwd())) 
[10:24:41.504]             setwd(...future.workdir)
[10:24:41.504]         {
[10:24:41.504]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:41.504]                 ...future.oldOptions$nwarnings <- NULL
[10:24:41.504]             }
[10:24:41.504]             base::options(...future.oldOptions)
[10:24:41.504]             if (.Platform$OS.type == "windows") {
[10:24:41.504]                 old_names <- names(...future.oldEnvVars)
[10:24:41.504]                 envs <- base::Sys.getenv()
[10:24:41.504]                 names <- names(envs)
[10:24:41.504]                 common <- intersect(names, old_names)
[10:24:41.504]                 added <- setdiff(names, old_names)
[10:24:41.504]                 removed <- setdiff(old_names, names)
[10:24:41.504]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:41.504]                   envs[common]]
[10:24:41.504]                 NAMES <- toupper(changed)
[10:24:41.504]                 args <- list()
[10:24:41.504]                 for (kk in seq_along(NAMES)) {
[10:24:41.504]                   name <- changed[[kk]]
[10:24:41.504]                   NAME <- NAMES[[kk]]
[10:24:41.504]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:41.504]                     next
[10:24:41.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:41.504]                 }
[10:24:41.504]                 NAMES <- toupper(added)
[10:24:41.504]                 for (kk in seq_along(NAMES)) {
[10:24:41.504]                   name <- added[[kk]]
[10:24:41.504]                   NAME <- NAMES[[kk]]
[10:24:41.504]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:41.504]                     next
[10:24:41.504]                   args[[name]] <- ""
[10:24:41.504]                 }
[10:24:41.504]                 NAMES <- toupper(removed)
[10:24:41.504]                 for (kk in seq_along(NAMES)) {
[10:24:41.504]                   name <- removed[[kk]]
[10:24:41.504]                   NAME <- NAMES[[kk]]
[10:24:41.504]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:41.504]                     next
[10:24:41.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:41.504]                 }
[10:24:41.504]                 if (length(args) > 0) 
[10:24:41.504]                   base::do.call(base::Sys.setenv, args = args)
[10:24:41.504]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:41.504]             }
[10:24:41.504]             else {
[10:24:41.504]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:41.504]             }
[10:24:41.504]             {
[10:24:41.504]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:41.504]                   0L) {
[10:24:41.504]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:41.504]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:41.504]                   base::options(opts)
[10:24:41.504]                 }
[10:24:41.504]                 {
[10:24:41.504]                   {
[10:24:41.504]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:41.504]                     NULL
[10:24:41.504]                   }
[10:24:41.504]                   options(future.plan = NULL)
[10:24:41.504]                   if (is.na(NA_character_)) 
[10:24:41.504]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:41.504]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:41.504]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:41.504]                     envir = parent.frame()) 
[10:24:41.504]                   {
[10:24:41.504]                     default_workers <- missing(workers)
[10:24:41.504]                     if (is.function(workers)) 
[10:24:41.504]                       workers <- workers()
[10:24:41.504]                     workers <- structure(as.integer(workers), 
[10:24:41.504]                       class = class(workers))
[10:24:41.504]                     stop_if_not(is.finite(workers), workers >= 
[10:24:41.504]                       1L)
[10:24:41.504]                     if ((workers == 1L && !inherits(workers, 
[10:24:41.504]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:41.504]                       if (default_workers) 
[10:24:41.504]                         supportsMulticore(warn = TRUE)
[10:24:41.504]                       return(sequential(..., envir = envir))
[10:24:41.504]                     }
[10:24:41.504]                     oopts <- options(mc.cores = workers)
[10:24:41.504]                     on.exit(options(oopts))
[10:24:41.504]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:41.504]                       envir = envir)
[10:24:41.504]                     if (!future$lazy) 
[10:24:41.504]                       future <- run(future)
[10:24:41.504]                     invisible(future)
[10:24:41.504]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:41.504]                 }
[10:24:41.504]             }
[10:24:41.504]         }
[10:24:41.504]     })
[10:24:41.504]     if (TRUE) {
[10:24:41.504]         base::sink(type = "output", split = FALSE)
[10:24:41.504]         if (TRUE) {
[10:24:41.504]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:41.504]         }
[10:24:41.504]         else {
[10:24:41.504]             ...future.result["stdout"] <- base::list(NULL)
[10:24:41.504]         }
[10:24:41.504]         base::close(...future.stdout)
[10:24:41.504]         ...future.stdout <- NULL
[10:24:41.504]     }
[10:24:41.504]     ...future.result$conditions <- ...future.conditions
[10:24:41.504]     ...future.result$finished <- base::Sys.time()
[10:24:41.504]     ...future.result
[10:24:41.504] }
[10:24:41.507] assign_globals() ...
[10:24:41.507] List of 5
[10:24:41.507]  $ ...future.FUN            :function (x)  
[10:24:41.507]  $ future.call.arguments    : list()
[10:24:41.507]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:41.507]  $ ...future.elements_ii    :List of 1
[10:24:41.507]   ..$ : int 1
[10:24:41.507]  $ ...future.seeds_ii       : NULL
[10:24:41.507]  $ ...future.globals.maxSize: NULL
[10:24:41.507]  - attr(*, "where")=List of 5
[10:24:41.507]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:41.507]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:41.507]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:41.507]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:41.507]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:41.507]  - attr(*, "resolved")= logi FALSE
[10:24:41.507]  - attr(*, "total_size")= num 4720
[10:24:41.507]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:41.507]  - attr(*, "already-done")= logi TRUE
[10:24:41.512] - reassign environment for ‘...future.FUN’
[10:24:41.512] - copied ‘...future.FUN’ to environment
[10:24:41.512] - copied ‘future.call.arguments’ to environment
[10:24:41.512] - copied ‘...future.elements_ii’ to environment
[10:24:41.512] - copied ‘...future.seeds_ii’ to environment
[10:24:41.512] - copied ‘...future.globals.maxSize’ to environment
[10:24:41.512] assign_globals() ... done
[10:24:41.513] requestCore(): workers = 2
[10:24:41.515] MulticoreFuture started
[10:24:41.515] - Launch lazy future ... done
[10:24:41.516] run() for ‘MulticoreFuture’ ... done
[10:24:41.516] Created future:
[10:24:41.516] plan(): Setting new future strategy stack:
[10:24:41.516] List of future strategies:
[10:24:41.516] 1. sequential:
[10:24:41.516]    - args: function (..., envir = parent.frame())
[10:24:41.516]    - tweaked: FALSE
[10:24:41.516]    - call: NULL
[10:24:41.517] plan(): nbrOfWorkers() = 1
[10:24:41.516] MulticoreFuture:
[10:24:41.516] Label: ‘future_lapply-1’
[10:24:41.516] Expression:
[10:24:41.516] {
[10:24:41.516]     do.call(function(...) {
[10:24:41.516]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:41.516]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:41.516]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:41.516]             on.exit(options(oopts), add = TRUE)
[10:24:41.516]         }
[10:24:41.516]         {
[10:24:41.516]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:41.516]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:41.516]                 ...future.FUN(...future.X_jj, ...)
[10:24:41.516]             })
[10:24:41.516]         }
[10:24:41.516]     }, args = future.call.arguments)
[10:24:41.516] }
[10:24:41.516] Lazy evaluation: FALSE
[10:24:41.516] Asynchronous evaluation: TRUE
[10:24:41.516] Local evaluation: TRUE
[10:24:41.516] Environment: R_GlobalEnv
[10:24:41.516] Capture standard output: TRUE
[10:24:41.516] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:41.516] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:41.516] Packages: <none>
[10:24:41.516] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:41.516] Resolved: FALSE
[10:24:41.516] Value: <not collected>
[10:24:41.516] Conditions captured: <none>
[10:24:41.516] Early signaling: FALSE
[10:24:41.516] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:41.516] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:41.534] Chunk #1 of 2 ... DONE
[10:24:41.534] Chunk #2 of 2 ...
[10:24:41.535]  - Finding globals in 'X' for chunk #2 ...
[10:24:41.535] getGlobalsAndPackages() ...
[10:24:41.536] Searching for globals...
[10:24:41.537] 
[10:24:41.537] Searching for globals ... DONE
[10:24:41.537] - globals: [0] <none>
[10:24:41.538] getGlobalsAndPackages() ... DONE
[10:24:41.538]    + additional globals found: [n=0] 
[10:24:41.538]    + additional namespaces needed: [n=0] 
[10:24:41.538]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:41.538]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:41.539]  - seeds: <none>
[10:24:41.539]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:41.539] getGlobalsAndPackages() ...
[10:24:41.539] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:41.539] Resolving globals: FALSE
[10:24:41.540] Tweak future expression to call with '...' arguments ...
[10:24:41.540] {
[10:24:41.540]     do.call(function(...) {
[10:24:41.540]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:41.540]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:41.540]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:41.540]             on.exit(options(oopts), add = TRUE)
[10:24:41.540]         }
[10:24:41.540]         {
[10:24:41.540]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:41.540]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:41.540]                 ...future.FUN(...future.X_jj, ...)
[10:24:41.540]             })
[10:24:41.540]         }
[10:24:41.540]     }, args = future.call.arguments)
[10:24:41.540] }
[10:24:41.540] Tweak future expression to call with '...' arguments ... DONE
[10:24:41.541] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:41.541] 
[10:24:41.542] getGlobalsAndPackages() ... DONE
[10:24:41.542] run() for ‘Future’ ...
[10:24:41.542] - state: ‘created’
[10:24:41.543] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:41.548] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:41.548] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:41.548]   - Field: ‘label’
[10:24:41.548]   - Field: ‘local’
[10:24:41.548]   - Field: ‘owner’
[10:24:41.549]   - Field: ‘envir’
[10:24:41.549]   - Field: ‘workers’
[10:24:41.549]   - Field: ‘packages’
[10:24:41.549]   - Field: ‘gc’
[10:24:41.549]   - Field: ‘job’
[10:24:41.549]   - Field: ‘conditions’
[10:24:41.549]   - Field: ‘expr’
[10:24:41.550]   - Field: ‘uuid’
[10:24:41.550]   - Field: ‘seed’
[10:24:41.550]   - Field: ‘version’
[10:24:41.550]   - Field: ‘result’
[10:24:41.550]   - Field: ‘asynchronous’
[10:24:41.550]   - Field: ‘calls’
[10:24:41.550]   - Field: ‘globals’
[10:24:41.551]   - Field: ‘stdout’
[10:24:41.551]   - Field: ‘earlySignal’
[10:24:41.551]   - Field: ‘lazy’
[10:24:41.551]   - Field: ‘state’
[10:24:41.551] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:41.551] - Launch lazy future ...
[10:24:41.552] Packages needed by the future expression (n = 0): <none>
[10:24:41.552] Packages needed by future strategies (n = 0): <none>
[10:24:41.553] {
[10:24:41.553]     {
[10:24:41.553]         {
[10:24:41.553]             ...future.startTime <- base::Sys.time()
[10:24:41.553]             {
[10:24:41.553]                 {
[10:24:41.553]                   {
[10:24:41.553]                     {
[10:24:41.553]                       base::local({
[10:24:41.553]                         has_future <- base::requireNamespace("future", 
[10:24:41.553]                           quietly = TRUE)
[10:24:41.553]                         if (has_future) {
[10:24:41.553]                           ns <- base::getNamespace("future")
[10:24:41.553]                           version <- ns[[".package"]][["version"]]
[10:24:41.553]                           if (is.null(version)) 
[10:24:41.553]                             version <- utils::packageVersion("future")
[10:24:41.553]                         }
[10:24:41.553]                         else {
[10:24:41.553]                           version <- NULL
[10:24:41.553]                         }
[10:24:41.553]                         if (!has_future || version < "1.8.0") {
[10:24:41.553]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:41.553]                             "", base::R.version$version.string), 
[10:24:41.553]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:41.553]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:41.553]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:41.553]                               "release", "version")], collapse = " "), 
[10:24:41.553]                             hostname = base::Sys.info()[["nodename"]])
[10:24:41.553]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:41.553]                             info)
[10:24:41.553]                           info <- base::paste(info, collapse = "; ")
[10:24:41.553]                           if (!has_future) {
[10:24:41.553]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:41.553]                               info)
[10:24:41.553]                           }
[10:24:41.553]                           else {
[10:24:41.553]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:41.553]                               info, version)
[10:24:41.553]                           }
[10:24:41.553]                           base::stop(msg)
[10:24:41.553]                         }
[10:24:41.553]                       })
[10:24:41.553]                     }
[10:24:41.553]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:41.553]                     base::options(mc.cores = 1L)
[10:24:41.553]                   }
[10:24:41.553]                   options(future.plan = NULL)
[10:24:41.553]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:41.553]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:41.553]                 }
[10:24:41.553]                 ...future.workdir <- getwd()
[10:24:41.553]             }
[10:24:41.553]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:41.553]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:41.553]         }
[10:24:41.553]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:41.553]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:41.553]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:41.553]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:41.553]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:41.553]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:41.553]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:41.553]             base::names(...future.oldOptions))
[10:24:41.553]     }
[10:24:41.553]     if (FALSE) {
[10:24:41.553]     }
[10:24:41.553]     else {
[10:24:41.553]         if (TRUE) {
[10:24:41.553]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:41.553]                 open = "w")
[10:24:41.553]         }
[10:24:41.553]         else {
[10:24:41.553]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:41.553]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:41.553]         }
[10:24:41.553]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:41.553]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:41.553]             base::sink(type = "output", split = FALSE)
[10:24:41.553]             base::close(...future.stdout)
[10:24:41.553]         }, add = TRUE)
[10:24:41.553]     }
[10:24:41.553]     ...future.frame <- base::sys.nframe()
[10:24:41.553]     ...future.conditions <- base::list()
[10:24:41.553]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:41.553]     if (FALSE) {
[10:24:41.553]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:41.553]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:41.553]     }
[10:24:41.553]     ...future.result <- base::tryCatch({
[10:24:41.553]         base::withCallingHandlers({
[10:24:41.553]             ...future.value <- base::withVisible(base::local({
[10:24:41.553]                 withCallingHandlers({
[10:24:41.553]                   {
[10:24:41.553]                     do.call(function(...) {
[10:24:41.553]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:41.553]                       if (!identical(...future.globals.maxSize.org, 
[10:24:41.553]                         ...future.globals.maxSize)) {
[10:24:41.553]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:41.553]                         on.exit(options(oopts), add = TRUE)
[10:24:41.553]                       }
[10:24:41.553]                       {
[10:24:41.553]                         lapply(seq_along(...future.elements_ii), 
[10:24:41.553]                           FUN = function(jj) {
[10:24:41.553]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:41.553]                             ...future.FUN(...future.X_jj, ...)
[10:24:41.553]                           })
[10:24:41.553]                       }
[10:24:41.553]                     }, args = future.call.arguments)
[10:24:41.553]                   }
[10:24:41.553]                 }, immediateCondition = function(cond) {
[10:24:41.553]                   save_rds <- function (object, pathname, ...) 
[10:24:41.553]                   {
[10:24:41.553]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:41.553]                     if (file_test("-f", pathname_tmp)) {
[10:24:41.553]                       fi_tmp <- file.info(pathname_tmp)
[10:24:41.553]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:41.553]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:41.553]                         fi_tmp[["mtime"]])
[10:24:41.553]                     }
[10:24:41.553]                     tryCatch({
[10:24:41.553]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:41.553]                     }, error = function(ex) {
[10:24:41.553]                       msg <- conditionMessage(ex)
[10:24:41.553]                       fi_tmp <- file.info(pathname_tmp)
[10:24:41.553]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:41.553]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:41.553]                         fi_tmp[["mtime"]], msg)
[10:24:41.553]                       ex$message <- msg
[10:24:41.553]                       stop(ex)
[10:24:41.553]                     })
[10:24:41.553]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:41.553]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:41.553]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:41.553]                       fi_tmp <- file.info(pathname_tmp)
[10:24:41.553]                       fi <- file.info(pathname)
[10:24:41.553]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:41.553]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:41.553]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:41.553]                         fi[["size"]], fi[["mtime"]])
[10:24:41.553]                       stop(msg)
[10:24:41.553]                     }
[10:24:41.553]                     invisible(pathname)
[10:24:41.553]                   }
[10:24:41.553]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:41.553]                     rootPath = tempdir()) 
[10:24:41.553]                   {
[10:24:41.553]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:41.553]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:41.553]                       tmpdir = path, fileext = ".rds")
[10:24:41.553]                     save_rds(obj, file)
[10:24:41.553]                   }
[10:24:41.553]                   saveImmediateCondition(cond, path = "/tmp/Rtmp5boaqN/.future/immediateConditions")
[10:24:41.553]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:41.553]                   {
[10:24:41.553]                     inherits <- base::inherits
[10:24:41.553]                     invokeRestart <- base::invokeRestart
[10:24:41.553]                     is.null <- base::is.null
[10:24:41.553]                     muffled <- FALSE
[10:24:41.553]                     if (inherits(cond, "message")) {
[10:24:41.553]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:41.553]                       if (muffled) 
[10:24:41.553]                         invokeRestart("muffleMessage")
[10:24:41.553]                     }
[10:24:41.553]                     else if (inherits(cond, "warning")) {
[10:24:41.553]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:41.553]                       if (muffled) 
[10:24:41.553]                         invokeRestart("muffleWarning")
[10:24:41.553]                     }
[10:24:41.553]                     else if (inherits(cond, "condition")) {
[10:24:41.553]                       if (!is.null(pattern)) {
[10:24:41.553]                         computeRestarts <- base::computeRestarts
[10:24:41.553]                         grepl <- base::grepl
[10:24:41.553]                         restarts <- computeRestarts(cond)
[10:24:41.553]                         for (restart in restarts) {
[10:24:41.553]                           name <- restart$name
[10:24:41.553]                           if (is.null(name)) 
[10:24:41.553]                             next
[10:24:41.553]                           if (!grepl(pattern, name)) 
[10:24:41.553]                             next
[10:24:41.553]                           invokeRestart(restart)
[10:24:41.553]                           muffled <- TRUE
[10:24:41.553]                           break
[10:24:41.553]                         }
[10:24:41.553]                       }
[10:24:41.553]                     }
[10:24:41.553]                     invisible(muffled)
[10:24:41.553]                   }
[10:24:41.553]                   muffleCondition(cond)
[10:24:41.553]                 })
[10:24:41.553]             }))
[10:24:41.553]             future::FutureResult(value = ...future.value$value, 
[10:24:41.553]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:41.553]                   ...future.rng), globalenv = if (FALSE) 
[10:24:41.553]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:41.553]                     ...future.globalenv.names))
[10:24:41.553]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:41.553]         }, condition = base::local({
[10:24:41.553]             c <- base::c
[10:24:41.553]             inherits <- base::inherits
[10:24:41.553]             invokeRestart <- base::invokeRestart
[10:24:41.553]             length <- base::length
[10:24:41.553]             list <- base::list
[10:24:41.553]             seq.int <- base::seq.int
[10:24:41.553]             signalCondition <- base::signalCondition
[10:24:41.553]             sys.calls <- base::sys.calls
[10:24:41.553]             `[[` <- base::`[[`
[10:24:41.553]             `+` <- base::`+`
[10:24:41.553]             `<<-` <- base::`<<-`
[10:24:41.553]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:41.553]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:41.553]                   3L)]
[10:24:41.553]             }
[10:24:41.553]             function(cond) {
[10:24:41.553]                 is_error <- inherits(cond, "error")
[10:24:41.553]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:41.553]                   NULL)
[10:24:41.553]                 if (is_error) {
[10:24:41.553]                   sessionInformation <- function() {
[10:24:41.553]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:41.553]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:41.553]                       search = base::search(), system = base::Sys.info())
[10:24:41.553]                   }
[10:24:41.553]                   ...future.conditions[[length(...future.conditions) + 
[10:24:41.553]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:41.553]                     cond$call), session = sessionInformation(), 
[10:24:41.553]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:41.553]                   signalCondition(cond)
[10:24:41.553]                 }
[10:24:41.553]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:41.553]                 "immediateCondition"))) {
[10:24:41.553]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:41.553]                   ...future.conditions[[length(...future.conditions) + 
[10:24:41.553]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:41.553]                   if (TRUE && !signal) {
[10:24:41.553]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:41.553]                     {
[10:24:41.553]                       inherits <- base::inherits
[10:24:41.553]                       invokeRestart <- base::invokeRestart
[10:24:41.553]                       is.null <- base::is.null
[10:24:41.553]                       muffled <- FALSE
[10:24:41.553]                       if (inherits(cond, "message")) {
[10:24:41.553]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:41.553]                         if (muffled) 
[10:24:41.553]                           invokeRestart("muffleMessage")
[10:24:41.553]                       }
[10:24:41.553]                       else if (inherits(cond, "warning")) {
[10:24:41.553]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:41.553]                         if (muffled) 
[10:24:41.553]                           invokeRestart("muffleWarning")
[10:24:41.553]                       }
[10:24:41.553]                       else if (inherits(cond, "condition")) {
[10:24:41.553]                         if (!is.null(pattern)) {
[10:24:41.553]                           computeRestarts <- base::computeRestarts
[10:24:41.553]                           grepl <- base::grepl
[10:24:41.553]                           restarts <- computeRestarts(cond)
[10:24:41.553]                           for (restart in restarts) {
[10:24:41.553]                             name <- restart$name
[10:24:41.553]                             if (is.null(name)) 
[10:24:41.553]                               next
[10:24:41.553]                             if (!grepl(pattern, name)) 
[10:24:41.553]                               next
[10:24:41.553]                             invokeRestart(restart)
[10:24:41.553]                             muffled <- TRUE
[10:24:41.553]                             break
[10:24:41.553]                           }
[10:24:41.553]                         }
[10:24:41.553]                       }
[10:24:41.553]                       invisible(muffled)
[10:24:41.553]                     }
[10:24:41.553]                     muffleCondition(cond, pattern = "^muffle")
[10:24:41.553]                   }
[10:24:41.553]                 }
[10:24:41.553]                 else {
[10:24:41.553]                   if (TRUE) {
[10:24:41.553]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:41.553]                     {
[10:24:41.553]                       inherits <- base::inherits
[10:24:41.553]                       invokeRestart <- base::invokeRestart
[10:24:41.553]                       is.null <- base::is.null
[10:24:41.553]                       muffled <- FALSE
[10:24:41.553]                       if (inherits(cond, "message")) {
[10:24:41.553]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:41.553]                         if (muffled) 
[10:24:41.553]                           invokeRestart("muffleMessage")
[10:24:41.553]                       }
[10:24:41.553]                       else if (inherits(cond, "warning")) {
[10:24:41.553]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:41.553]                         if (muffled) 
[10:24:41.553]                           invokeRestart("muffleWarning")
[10:24:41.553]                       }
[10:24:41.553]                       else if (inherits(cond, "condition")) {
[10:24:41.553]                         if (!is.null(pattern)) {
[10:24:41.553]                           computeRestarts <- base::computeRestarts
[10:24:41.553]                           grepl <- base::grepl
[10:24:41.553]                           restarts <- computeRestarts(cond)
[10:24:41.553]                           for (restart in restarts) {
[10:24:41.553]                             name <- restart$name
[10:24:41.553]                             if (is.null(name)) 
[10:24:41.553]                               next
[10:24:41.553]                             if (!grepl(pattern, name)) 
[10:24:41.553]                               next
[10:24:41.553]                             invokeRestart(restart)
[10:24:41.553]                             muffled <- TRUE
[10:24:41.553]                             break
[10:24:41.553]                           }
[10:24:41.553]                         }
[10:24:41.553]                       }
[10:24:41.553]                       invisible(muffled)
[10:24:41.553]                     }
[10:24:41.553]                     muffleCondition(cond, pattern = "^muffle")
[10:24:41.553]                   }
[10:24:41.553]                 }
[10:24:41.553]             }
[10:24:41.553]         }))
[10:24:41.553]     }, error = function(ex) {
[10:24:41.553]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:41.553]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:41.553]                 ...future.rng), started = ...future.startTime, 
[10:24:41.553]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:41.553]             version = "1.8"), class = "FutureResult")
[10:24:41.553]     }, finally = {
[10:24:41.553]         if (!identical(...future.workdir, getwd())) 
[10:24:41.553]             setwd(...future.workdir)
[10:24:41.553]         {
[10:24:41.553]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:41.553]                 ...future.oldOptions$nwarnings <- NULL
[10:24:41.553]             }
[10:24:41.553]             base::options(...future.oldOptions)
[10:24:41.553]             if (.Platform$OS.type == "windows") {
[10:24:41.553]                 old_names <- names(...future.oldEnvVars)
[10:24:41.553]                 envs <- base::Sys.getenv()
[10:24:41.553]                 names <- names(envs)
[10:24:41.553]                 common <- intersect(names, old_names)
[10:24:41.553]                 added <- setdiff(names, old_names)
[10:24:41.553]                 removed <- setdiff(old_names, names)
[10:24:41.553]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:41.553]                   envs[common]]
[10:24:41.553]                 NAMES <- toupper(changed)
[10:24:41.553]                 args <- list()
[10:24:41.553]                 for (kk in seq_along(NAMES)) {
[10:24:41.553]                   name <- changed[[kk]]
[10:24:41.553]                   NAME <- NAMES[[kk]]
[10:24:41.553]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:41.553]                     next
[10:24:41.553]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:41.553]                 }
[10:24:41.553]                 NAMES <- toupper(added)
[10:24:41.553]                 for (kk in seq_along(NAMES)) {
[10:24:41.553]                   name <- added[[kk]]
[10:24:41.553]                   NAME <- NAMES[[kk]]
[10:24:41.553]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:41.553]                     next
[10:24:41.553]                   args[[name]] <- ""
[10:24:41.553]                 }
[10:24:41.553]                 NAMES <- toupper(removed)
[10:24:41.553]                 for (kk in seq_along(NAMES)) {
[10:24:41.553]                   name <- removed[[kk]]
[10:24:41.553]                   NAME <- NAMES[[kk]]
[10:24:41.553]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:41.553]                     next
[10:24:41.553]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:41.553]                 }
[10:24:41.553]                 if (length(args) > 0) 
[10:24:41.553]                   base::do.call(base::Sys.setenv, args = args)
[10:24:41.553]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:41.553]             }
[10:24:41.553]             else {
[10:24:41.553]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:41.553]             }
[10:24:41.553]             {
[10:24:41.553]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:41.553]                   0L) {
[10:24:41.553]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:41.553]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:41.553]                   base::options(opts)
[10:24:41.553]                 }
[10:24:41.553]                 {
[10:24:41.553]                   {
[10:24:41.553]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:41.553]                     NULL
[10:24:41.553]                   }
[10:24:41.553]                   options(future.plan = NULL)
[10:24:41.553]                   if (is.na(NA_character_)) 
[10:24:41.553]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:41.553]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:41.553]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:41.553]                     envir = parent.frame()) 
[10:24:41.553]                   {
[10:24:41.553]                     default_workers <- missing(workers)
[10:24:41.553]                     if (is.function(workers)) 
[10:24:41.553]                       workers <- workers()
[10:24:41.553]                     workers <- structure(as.integer(workers), 
[10:24:41.553]                       class = class(workers))
[10:24:41.553]                     stop_if_not(is.finite(workers), workers >= 
[10:24:41.553]                       1L)
[10:24:41.553]                     if ((workers == 1L && !inherits(workers, 
[10:24:41.553]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:41.553]                       if (default_workers) 
[10:24:41.553]                         supportsMulticore(warn = TRUE)
[10:24:41.553]                       return(sequential(..., envir = envir))
[10:24:41.553]                     }
[10:24:41.553]                     oopts <- options(mc.cores = workers)
[10:24:41.553]                     on.exit(options(oopts))
[10:24:41.553]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:41.553]                       envir = envir)
[10:24:41.553]                     if (!future$lazy) 
[10:24:41.553]                       future <- run(future)
[10:24:41.553]                     invisible(future)
[10:24:41.553]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:41.553]                 }
[10:24:41.553]             }
[10:24:41.553]         }
[10:24:41.553]     })
[10:24:41.553]     if (TRUE) {
[10:24:41.553]         base::sink(type = "output", split = FALSE)
[10:24:41.553]         if (TRUE) {
[10:24:41.553]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:41.553]         }
[10:24:41.553]         else {
[10:24:41.553]             ...future.result["stdout"] <- base::list(NULL)
[10:24:41.553]         }
[10:24:41.553]         base::close(...future.stdout)
[10:24:41.553]         ...future.stdout <- NULL
[10:24:41.553]     }
[10:24:41.553]     ...future.result$conditions <- ...future.conditions
[10:24:41.553]     ...future.result$finished <- base::Sys.time()
[10:24:41.553]     ...future.result
[10:24:41.553] }
[10:24:41.555] assign_globals() ...
[10:24:41.555] List of 5
[10:24:41.555]  $ ...future.FUN            :function (x)  
[10:24:41.555]  $ future.call.arguments    : list()
[10:24:41.555]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:41.555]  $ ...future.elements_ii    :List of 1
[10:24:41.555]   ..$ : int 0
[10:24:41.555]  $ ...future.seeds_ii       : NULL
[10:24:41.555]  $ ...future.globals.maxSize: NULL
[10:24:41.555]  - attr(*, "where")=List of 5
[10:24:41.555]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:41.555]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:41.555]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:41.555]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:41.555]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:41.555]  - attr(*, "resolved")= logi FALSE
[10:24:41.555]  - attr(*, "total_size")= num 4720
[10:24:41.555]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:41.555]  - attr(*, "already-done")= logi TRUE
[10:24:41.562] - reassign environment for ‘...future.FUN’
[10:24:41.562] - copied ‘...future.FUN’ to environment
[10:24:41.562] - copied ‘future.call.arguments’ to environment
[10:24:41.562] - copied ‘...future.elements_ii’ to environment
[10:24:41.563] - copied ‘...future.seeds_ii’ to environment
[10:24:41.563] - copied ‘...future.globals.maxSize’ to environment
[10:24:41.563] assign_globals() ... done
[10:24:41.563] requestCore(): workers = 2
[10:24:41.565] MulticoreFuture started
[10:24:41.566] - Launch lazy future ... done
[10:24:41.566] run() for ‘MulticoreFuture’ ... done
[10:24:41.566] Created future:
[10:24:41.567] plan(): Setting new future strategy stack:
[10:24:41.567] List of future strategies:
[10:24:41.567] 1. sequential:
[10:24:41.567]    - args: function (..., envir = parent.frame())
[10:24:41.567]    - tweaked: FALSE
[10:24:41.567]    - call: NULL
[10:24:41.568] plan(): nbrOfWorkers() = 1
[10:24:41.570] plan(): Setting new future strategy stack:
[10:24:41.570] List of future strategies:
[10:24:41.570] 1. multicore:
[10:24:41.570]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:41.570]    - tweaked: FALSE
[10:24:41.570]    - call: plan(strategy)
[10:24:41.575] plan(): nbrOfWorkers() = 2
[10:24:41.566] MulticoreFuture:
[10:24:41.566] Label: ‘future_lapply-2’
[10:24:41.566] Expression:
[10:24:41.566] {
[10:24:41.566]     do.call(function(...) {
[10:24:41.566]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:41.566]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:41.566]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:41.566]             on.exit(options(oopts), add = TRUE)
[10:24:41.566]         }
[10:24:41.566]         {
[10:24:41.566]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:41.566]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:41.566]                 ...future.FUN(...future.X_jj, ...)
[10:24:41.566]             })
[10:24:41.566]         }
[10:24:41.566]     }, args = future.call.arguments)
[10:24:41.566] }
[10:24:41.566] Lazy evaluation: FALSE
[10:24:41.566] Asynchronous evaluation: TRUE
[10:24:41.566] Local evaluation: TRUE
[10:24:41.566] Environment: R_GlobalEnv
[10:24:41.566] Capture standard output: TRUE
[10:24:41.566] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:41.566] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:41.566] Packages: <none>
[10:24:41.566] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:41.566] Resolved: TRUE
[10:24:41.566] Value: <not collected>
[10:24:41.566] Conditions captured: <none>
[10:24:41.566] Early signaling: FALSE
[10:24:41.566] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:41.566] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:41.576] Chunk #2 of 2 ... DONE
[10:24:41.577] Launching 2 futures (chunks) ... DONE
[10:24:41.577] Resolving 2 futures (chunks) ...
[10:24:41.577] resolve() on list ...
[10:24:41.577]  recursive: 0
[10:24:41.577]  length: 2
[10:24:41.577] 
[10:24:41.588] Future #2
[10:24:41.588] result() for MulticoreFuture ...
[10:24:41.589] result() for MulticoreFuture ...
[10:24:41.590] result() for MulticoreFuture ... done
[10:24:41.590] result() for MulticoreFuture ... done
[10:24:41.590] result() for MulticoreFuture ...
[10:24:41.590] result() for MulticoreFuture ... done
[10:24:41.590] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:24:41.590] - nx: 2
[10:24:41.591] - relay: TRUE
[10:24:41.591] - stdout: TRUE
[10:24:41.591] - signal: TRUE
[10:24:41.591] - resignal: FALSE
[10:24:41.591] - force: TRUE
[10:24:41.591] - relayed: [n=2] FALSE, FALSE
[10:24:41.591] - queued futures: [n=2] FALSE, FALSE
[10:24:41.592]  - until=1
[10:24:41.592]  - relaying element #1
[10:24:41.592] - relayed: [n=2] FALSE, FALSE
[10:24:41.592] - queued futures: [n=2] FALSE, TRUE
[10:24:41.592] signalConditionsASAP(NULL, pos=2) ... done
[10:24:41.592]  length: 1 (resolved future 2)
[10:24:42.023] plan(): Setting new future strategy stack:
[10:24:42.023] List of future strategies:
[10:24:42.023] 1. multicore:
[10:24:42.023]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:42.023]    - tweaked: FALSE
[10:24:42.023]    - call: plan(strategy)
[10:24:42.029] plan(): nbrOfWorkers() = 2
[10:24:42.030] Future #1
[10:24:42.031] result() for MulticoreFuture ...
[10:24:42.034] result() for MulticoreFuture ...
[10:24:42.034] result() for MulticoreFuture ... done
[10:24:42.034] result() for MulticoreFuture ... done
[10:24:42.034] result() for MulticoreFuture ...
[10:24:42.035] result() for MulticoreFuture ... done
[10:24:42.035] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:24:42.035] - nx: 2
[10:24:42.035] - relay: TRUE
[10:24:42.035] - stdout: TRUE
[10:24:42.036] - signal: TRUE
[10:24:42.036] - resignal: FALSE
[10:24:42.036] - force: TRUE
[10:24:42.036] - relayed: [n=2] FALSE, FALSE
[10:24:42.036] - queued futures: [n=2] FALSE, TRUE
[10:24:42.036]  - until=1
[10:24:42.036]  - relaying element #1
[10:24:42.037] result() for MulticoreFuture ...
[10:24:42.037] result() for MulticoreFuture ... done
[10:24:42.037] result() for MulticoreFuture ...
[10:24:42.037] result() for MulticoreFuture ... done
[10:24:42.037] result() for MulticoreFuture ...
[10:24:42.037] result() for MulticoreFuture ... done
[10:24:42.037] result() for MulticoreFuture ...
[10:24:42.037] result() for MulticoreFuture ... done
[10:24:42.038] - relayed: [n=2] TRUE, FALSE
[10:24:42.038] - queued futures: [n=2] TRUE, TRUE
[10:24:42.038] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:24:42.038]  length: 0 (resolved future 1)
[10:24:42.038] Relaying remaining futures
[10:24:42.038] signalConditionsASAP(NULL, pos=0) ...
[10:24:42.038] - nx: 2
[10:24:42.038] - relay: TRUE
[10:24:42.039] - stdout: TRUE
[10:24:42.039] - signal: TRUE
[10:24:42.039] - resignal: FALSE
[10:24:42.039] - force: TRUE
[10:24:42.039] - relayed: [n=2] TRUE, FALSE
[10:24:42.039] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:42.039]  - relaying element #2
[10:24:42.039] result() for MulticoreFuture ...
[10:24:42.040] result() for MulticoreFuture ... done
[10:24:42.040] result() for MulticoreFuture ...
[10:24:42.040] result() for MulticoreFuture ... done
[10:24:42.040] result() for MulticoreFuture ...
[10:24:42.040] result() for MulticoreFuture ... done
[10:24:42.040] result() for MulticoreFuture ...
[10:24:42.040] result() for MulticoreFuture ... done
[10:24:42.040] - relayed: [n=2] TRUE, TRUE
[10:24:42.041] - queued futures: [n=2] TRUE, TRUE
[10:24:42.041] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[10:24:42.041] resolve() on list ... DONE
[10:24:42.041] result() for MulticoreFuture ...
[10:24:42.041] result() for MulticoreFuture ... done
[10:24:42.041] result() for MulticoreFuture ...
[10:24:42.041] result() for MulticoreFuture ... done
[10:24:42.041] result() for MulticoreFuture ...
[10:24:42.042] result() for MulticoreFuture ... done
[10:24:42.042] result() for MulticoreFuture ...
[10:24:42.042] result() for MulticoreFuture ... done
[10:24:42.042]  - Number of value chunks collected: 2
[10:24:42.042] Resolving 2 futures (chunks) ... DONE
[10:24:42.042] Reducing values from 2 chunks ...
[10:24:42.042]  - Number of values collected after concatenation: 2
[10:24:42.042]  - Number of values expected: 2
[10:24:42.042] Reducing values from 2 chunks ... DONE
[10:24:42.043] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[10:24:42.043] future_lapply() ...
[10:24:42.048] Number of chunks: 2
[10:24:42.048] getGlobalsAndPackagesXApply() ...
[10:24:42.048]  - future.globals: TRUE
[10:24:42.049] getGlobalsAndPackages() ...
[10:24:42.049] Searching for globals...
[10:24:42.051] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:24:42.051] Searching for globals ... DONE
[10:24:42.051] Resolving globals: FALSE
[10:24:42.052] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[10:24:42.053] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[10:24:42.053] - globals: [1] ‘FUN’
[10:24:42.053] 
[10:24:42.053] getGlobalsAndPackages() ... DONE
[10:24:42.053]  - globals found/used: [n=1] ‘FUN’
[10:24:42.053]  - needed namespaces: [n=0] 
[10:24:42.053] Finding globals ... DONE
[10:24:42.053]  - use_args: TRUE
[10:24:42.053]  - Getting '...' globals ...
[10:24:42.054] resolve() on list ...
[10:24:42.054]  recursive: 0
[10:24:42.054]  length: 1
[10:24:42.054]  elements: ‘...’
[10:24:42.054]  length: 0 (resolved future 1)
[10:24:42.054] resolve() on list ... DONE
[10:24:42.054]    - '...' content: [n=0] 
[10:24:42.055] List of 1
[10:24:42.055]  $ ...: list()
[10:24:42.055]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:42.055]  - attr(*, "where")=List of 1
[10:24:42.055]   ..$ ...:<environment: 0x55d210120aa8> 
[10:24:42.055]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:42.055]  - attr(*, "resolved")= logi TRUE
[10:24:42.055]  - attr(*, "total_size")= num NA
[10:24:42.057]  - Getting '...' globals ... DONE
[10:24:42.058] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:24:42.058] List of 2
[10:24:42.058]  $ ...future.FUN:function (x)  
[10:24:42.058]  $ ...          : list()
[10:24:42.058]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:42.058]  - attr(*, "where")=List of 2
[10:24:42.058]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:42.058]   ..$ ...          :<environment: 0x55d210120aa8> 
[10:24:42.058]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:42.058]  - attr(*, "resolved")= logi FALSE
[10:24:42.058]  - attr(*, "total_size")= num 4720
[10:24:42.060] Packages to be attached in all futures: [n=0] 
[10:24:42.061] getGlobalsAndPackagesXApply() ... DONE
[10:24:42.061] Number of futures (= number of chunks): 2
[10:24:42.061] Launching 2 futures (chunks) ...
[10:24:42.061] Chunk #1 of 2 ...
[10:24:42.061]  - Finding globals in 'X' for chunk #1 ...
[10:24:42.061] getGlobalsAndPackages() ...
[10:24:42.061] Searching for globals...
[10:24:42.062] 
[10:24:42.063] Searching for globals ... DONE
[10:24:42.063] - globals: [0] <none>
[10:24:42.063] getGlobalsAndPackages() ... DONE
[10:24:42.064]    + additional globals found: [n=0] 
[10:24:42.064]    + additional namespaces needed: [n=0] 
[10:24:42.064]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:42.064]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:42.064]  - seeds: <none>
[10:24:42.064]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:42.064] getGlobalsAndPackages() ...
[10:24:42.064] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:42.064] Resolving globals: FALSE
[10:24:42.065] Tweak future expression to call with '...' arguments ...
[10:24:42.065] {
[10:24:42.065]     do.call(function(...) {
[10:24:42.065]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:42.065]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:42.065]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:42.065]             on.exit(options(oopts), add = TRUE)
[10:24:42.065]         }
[10:24:42.065]         {
[10:24:42.065]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:42.065]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:42.065]                 ...future.FUN(...future.X_jj, ...)
[10:24:42.065]             })
[10:24:42.065]         }
[10:24:42.065]     }, args = future.call.arguments)
[10:24:42.065] }
[10:24:42.065] Tweak future expression to call with '...' arguments ... DONE
[10:24:42.065] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:42.065] 
[10:24:42.066] getGlobalsAndPackages() ... DONE
[10:24:42.066] run() for ‘Future’ ...
[10:24:42.066] - state: ‘created’
[10:24:42.066] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:42.070] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:42.070] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:42.070]   - Field: ‘label’
[10:24:42.070]   - Field: ‘local’
[10:24:42.070]   - Field: ‘owner’
[10:24:42.070]   - Field: ‘envir’
[10:24:42.070]   - Field: ‘workers’
[10:24:42.070]   - Field: ‘packages’
[10:24:42.071]   - Field: ‘gc’
[10:24:42.071]   - Field: ‘job’
[10:24:42.071]   - Field: ‘conditions’
[10:24:42.071]   - Field: ‘expr’
[10:24:42.071]   - Field: ‘uuid’
[10:24:42.071]   - Field: ‘seed’
[10:24:42.071]   - Field: ‘version’
[10:24:42.071]   - Field: ‘result’
[10:24:42.071]   - Field: ‘asynchronous’
[10:24:42.071]   - Field: ‘calls’
[10:24:42.071]   - Field: ‘globals’
[10:24:42.072]   - Field: ‘stdout’
[10:24:42.072]   - Field: ‘earlySignal’
[10:24:42.072]   - Field: ‘lazy’
[10:24:42.072]   - Field: ‘state’
[10:24:42.072] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:42.072] - Launch lazy future ...
[10:24:42.072] Packages needed by the future expression (n = 0): <none>
[10:24:42.072] Packages needed by future strategies (n = 0): <none>
[10:24:42.073] {
[10:24:42.073]     {
[10:24:42.073]         {
[10:24:42.073]             ...future.startTime <- base::Sys.time()
[10:24:42.073]             {
[10:24:42.073]                 {
[10:24:42.073]                   {
[10:24:42.073]                     {
[10:24:42.073]                       base::local({
[10:24:42.073]                         has_future <- base::requireNamespace("future", 
[10:24:42.073]                           quietly = TRUE)
[10:24:42.073]                         if (has_future) {
[10:24:42.073]                           ns <- base::getNamespace("future")
[10:24:42.073]                           version <- ns[[".package"]][["version"]]
[10:24:42.073]                           if (is.null(version)) 
[10:24:42.073]                             version <- utils::packageVersion("future")
[10:24:42.073]                         }
[10:24:42.073]                         else {
[10:24:42.073]                           version <- NULL
[10:24:42.073]                         }
[10:24:42.073]                         if (!has_future || version < "1.8.0") {
[10:24:42.073]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:42.073]                             "", base::R.version$version.string), 
[10:24:42.073]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:42.073]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:42.073]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:42.073]                               "release", "version")], collapse = " "), 
[10:24:42.073]                             hostname = base::Sys.info()[["nodename"]])
[10:24:42.073]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:42.073]                             info)
[10:24:42.073]                           info <- base::paste(info, collapse = "; ")
[10:24:42.073]                           if (!has_future) {
[10:24:42.073]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:42.073]                               info)
[10:24:42.073]                           }
[10:24:42.073]                           else {
[10:24:42.073]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:42.073]                               info, version)
[10:24:42.073]                           }
[10:24:42.073]                           base::stop(msg)
[10:24:42.073]                         }
[10:24:42.073]                       })
[10:24:42.073]                     }
[10:24:42.073]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:42.073]                     base::options(mc.cores = 1L)
[10:24:42.073]                   }
[10:24:42.073]                   options(future.plan = NULL)
[10:24:42.073]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:42.073]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:42.073]                 }
[10:24:42.073]                 ...future.workdir <- getwd()
[10:24:42.073]             }
[10:24:42.073]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:42.073]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:42.073]         }
[10:24:42.073]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:42.073]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:42.073]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:42.073]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:42.073]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:42.073]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:42.073]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:42.073]             base::names(...future.oldOptions))
[10:24:42.073]     }
[10:24:42.073]     if (TRUE) {
[10:24:42.073]     }
[10:24:42.073]     else {
[10:24:42.073]         if (NA) {
[10:24:42.073]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:42.073]                 open = "w")
[10:24:42.073]         }
[10:24:42.073]         else {
[10:24:42.073]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:42.073]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:42.073]         }
[10:24:42.073]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:42.073]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:42.073]             base::sink(type = "output", split = FALSE)
[10:24:42.073]             base::close(...future.stdout)
[10:24:42.073]         }, add = TRUE)
[10:24:42.073]     }
[10:24:42.073]     ...future.frame <- base::sys.nframe()
[10:24:42.073]     ...future.conditions <- base::list()
[10:24:42.073]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:42.073]     if (FALSE) {
[10:24:42.073]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:42.073]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:42.073]     }
[10:24:42.073]     ...future.result <- base::tryCatch({
[10:24:42.073]         base::withCallingHandlers({
[10:24:42.073]             ...future.value <- base::withVisible(base::local({
[10:24:42.073]                 withCallingHandlers({
[10:24:42.073]                   {
[10:24:42.073]                     do.call(function(...) {
[10:24:42.073]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:42.073]                       if (!identical(...future.globals.maxSize.org, 
[10:24:42.073]                         ...future.globals.maxSize)) {
[10:24:42.073]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:42.073]                         on.exit(options(oopts), add = TRUE)
[10:24:42.073]                       }
[10:24:42.073]                       {
[10:24:42.073]                         lapply(seq_along(...future.elements_ii), 
[10:24:42.073]                           FUN = function(jj) {
[10:24:42.073]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:42.073]                             ...future.FUN(...future.X_jj, ...)
[10:24:42.073]                           })
[10:24:42.073]                       }
[10:24:42.073]                     }, args = future.call.arguments)
[10:24:42.073]                   }
[10:24:42.073]                 }, immediateCondition = function(cond) {
[10:24:42.073]                   save_rds <- function (object, pathname, ...) 
[10:24:42.073]                   {
[10:24:42.073]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:42.073]                     if (file_test("-f", pathname_tmp)) {
[10:24:42.073]                       fi_tmp <- file.info(pathname_tmp)
[10:24:42.073]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:42.073]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:42.073]                         fi_tmp[["mtime"]])
[10:24:42.073]                     }
[10:24:42.073]                     tryCatch({
[10:24:42.073]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:42.073]                     }, error = function(ex) {
[10:24:42.073]                       msg <- conditionMessage(ex)
[10:24:42.073]                       fi_tmp <- file.info(pathname_tmp)
[10:24:42.073]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:42.073]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:42.073]                         fi_tmp[["mtime"]], msg)
[10:24:42.073]                       ex$message <- msg
[10:24:42.073]                       stop(ex)
[10:24:42.073]                     })
[10:24:42.073]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:42.073]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:42.073]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:42.073]                       fi_tmp <- file.info(pathname_tmp)
[10:24:42.073]                       fi <- file.info(pathname)
[10:24:42.073]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:42.073]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:42.073]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:42.073]                         fi[["size"]], fi[["mtime"]])
[10:24:42.073]                       stop(msg)
[10:24:42.073]                     }
[10:24:42.073]                     invisible(pathname)
[10:24:42.073]                   }
[10:24:42.073]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:42.073]                     rootPath = tempdir()) 
[10:24:42.073]                   {
[10:24:42.073]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:42.073]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:42.073]                       tmpdir = path, fileext = ".rds")
[10:24:42.073]                     save_rds(obj, file)
[10:24:42.073]                   }
[10:24:42.073]                   saveImmediateCondition(cond, path = "/tmp/Rtmp5boaqN/.future/immediateConditions")
[10:24:42.073]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:42.073]                   {
[10:24:42.073]                     inherits <- base::inherits
[10:24:42.073]                     invokeRestart <- base::invokeRestart
[10:24:42.073]                     is.null <- base::is.null
[10:24:42.073]                     muffled <- FALSE
[10:24:42.073]                     if (inherits(cond, "message")) {
[10:24:42.073]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:42.073]                       if (muffled) 
[10:24:42.073]                         invokeRestart("muffleMessage")
[10:24:42.073]                     }
[10:24:42.073]                     else if (inherits(cond, "warning")) {
[10:24:42.073]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:42.073]                       if (muffled) 
[10:24:42.073]                         invokeRestart("muffleWarning")
[10:24:42.073]                     }
[10:24:42.073]                     else if (inherits(cond, "condition")) {
[10:24:42.073]                       if (!is.null(pattern)) {
[10:24:42.073]                         computeRestarts <- base::computeRestarts
[10:24:42.073]                         grepl <- base::grepl
[10:24:42.073]                         restarts <- computeRestarts(cond)
[10:24:42.073]                         for (restart in restarts) {
[10:24:42.073]                           name <- restart$name
[10:24:42.073]                           if (is.null(name)) 
[10:24:42.073]                             next
[10:24:42.073]                           if (!grepl(pattern, name)) 
[10:24:42.073]                             next
[10:24:42.073]                           invokeRestart(restart)
[10:24:42.073]                           muffled <- TRUE
[10:24:42.073]                           break
[10:24:42.073]                         }
[10:24:42.073]                       }
[10:24:42.073]                     }
[10:24:42.073]                     invisible(muffled)
[10:24:42.073]                   }
[10:24:42.073]                   muffleCondition(cond)
[10:24:42.073]                 })
[10:24:42.073]             }))
[10:24:42.073]             future::FutureResult(value = ...future.value$value, 
[10:24:42.073]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:42.073]                   ...future.rng), globalenv = if (FALSE) 
[10:24:42.073]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:42.073]                     ...future.globalenv.names))
[10:24:42.073]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:42.073]         }, condition = base::local({
[10:24:42.073]             c <- base::c
[10:24:42.073]             inherits <- base::inherits
[10:24:42.073]             invokeRestart <- base::invokeRestart
[10:24:42.073]             length <- base::length
[10:24:42.073]             list <- base::list
[10:24:42.073]             seq.int <- base::seq.int
[10:24:42.073]             signalCondition <- base::signalCondition
[10:24:42.073]             sys.calls <- base::sys.calls
[10:24:42.073]             `[[` <- base::`[[`
[10:24:42.073]             `+` <- base::`+`
[10:24:42.073]             `<<-` <- base::`<<-`
[10:24:42.073]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:42.073]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:42.073]                   3L)]
[10:24:42.073]             }
[10:24:42.073]             function(cond) {
[10:24:42.073]                 is_error <- inherits(cond, "error")
[10:24:42.073]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:42.073]                   NULL)
[10:24:42.073]                 if (is_error) {
[10:24:42.073]                   sessionInformation <- function() {
[10:24:42.073]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:42.073]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:42.073]                       search = base::search(), system = base::Sys.info())
[10:24:42.073]                   }
[10:24:42.073]                   ...future.conditions[[length(...future.conditions) + 
[10:24:42.073]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:42.073]                     cond$call), session = sessionInformation(), 
[10:24:42.073]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:42.073]                   signalCondition(cond)
[10:24:42.073]                 }
[10:24:42.073]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:42.073]                 "immediateCondition"))) {
[10:24:42.073]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:42.073]                   ...future.conditions[[length(...future.conditions) + 
[10:24:42.073]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:42.073]                   if (TRUE && !signal) {
[10:24:42.073]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:42.073]                     {
[10:24:42.073]                       inherits <- base::inherits
[10:24:42.073]                       invokeRestart <- base::invokeRestart
[10:24:42.073]                       is.null <- base::is.null
[10:24:42.073]                       muffled <- FALSE
[10:24:42.073]                       if (inherits(cond, "message")) {
[10:24:42.073]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:42.073]                         if (muffled) 
[10:24:42.073]                           invokeRestart("muffleMessage")
[10:24:42.073]                       }
[10:24:42.073]                       else if (inherits(cond, "warning")) {
[10:24:42.073]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:42.073]                         if (muffled) 
[10:24:42.073]                           invokeRestart("muffleWarning")
[10:24:42.073]                       }
[10:24:42.073]                       else if (inherits(cond, "condition")) {
[10:24:42.073]                         if (!is.null(pattern)) {
[10:24:42.073]                           computeRestarts <- base::computeRestarts
[10:24:42.073]                           grepl <- base::grepl
[10:24:42.073]                           restarts <- computeRestarts(cond)
[10:24:42.073]                           for (restart in restarts) {
[10:24:42.073]                             name <- restart$name
[10:24:42.073]                             if (is.null(name)) 
[10:24:42.073]                               next
[10:24:42.073]                             if (!grepl(pattern, name)) 
[10:24:42.073]                               next
[10:24:42.073]                             invokeRestart(restart)
[10:24:42.073]                             muffled <- TRUE
[10:24:42.073]                             break
[10:24:42.073]                           }
[10:24:42.073]                         }
[10:24:42.073]                       }
[10:24:42.073]                       invisible(muffled)
[10:24:42.073]                     }
[10:24:42.073]                     muffleCondition(cond, pattern = "^muffle")
[10:24:42.073]                   }
[10:24:42.073]                 }
[10:24:42.073]                 else {
[10:24:42.073]                   if (TRUE) {
[10:24:42.073]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:42.073]                     {
[10:24:42.073]                       inherits <- base::inherits
[10:24:42.073]                       invokeRestart <- base::invokeRestart
[10:24:42.073]                       is.null <- base::is.null
[10:24:42.073]                       muffled <- FALSE
[10:24:42.073]                       if (inherits(cond, "message")) {
[10:24:42.073]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:42.073]                         if (muffled) 
[10:24:42.073]                           invokeRestart("muffleMessage")
[10:24:42.073]                       }
[10:24:42.073]                       else if (inherits(cond, "warning")) {
[10:24:42.073]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:42.073]                         if (muffled) 
[10:24:42.073]                           invokeRestart("muffleWarning")
[10:24:42.073]                       }
[10:24:42.073]                       else if (inherits(cond, "condition")) {
[10:24:42.073]                         if (!is.null(pattern)) {
[10:24:42.073]                           computeRestarts <- base::computeRestarts
[10:24:42.073]                           grepl <- base::grepl
[10:24:42.073]                           restarts <- computeRestarts(cond)
[10:24:42.073]                           for (restart in restarts) {
[10:24:42.073]                             name <- restart$name
[10:24:42.073]                             if (is.null(name)) 
[10:24:42.073]                               next
[10:24:42.073]                             if (!grepl(pattern, name)) 
[10:24:42.073]                               next
[10:24:42.073]                             invokeRestart(restart)
[10:24:42.073]                             muffled <- TRUE
[10:24:42.073]                             break
[10:24:42.073]                           }
[10:24:42.073]                         }
[10:24:42.073]                       }
[10:24:42.073]                       invisible(muffled)
[10:24:42.073]                     }
[10:24:42.073]                     muffleCondition(cond, pattern = "^muffle")
[10:24:42.073]                   }
[10:24:42.073]                 }
[10:24:42.073]             }
[10:24:42.073]         }))
[10:24:42.073]     }, error = function(ex) {
[10:24:42.073]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:42.073]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:42.073]                 ...future.rng), started = ...future.startTime, 
[10:24:42.073]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:42.073]             version = "1.8"), class = "FutureResult")
[10:24:42.073]     }, finally = {
[10:24:42.073]         if (!identical(...future.workdir, getwd())) 
[10:24:42.073]             setwd(...future.workdir)
[10:24:42.073]         {
[10:24:42.073]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:42.073]                 ...future.oldOptions$nwarnings <- NULL
[10:24:42.073]             }
[10:24:42.073]             base::options(...future.oldOptions)
[10:24:42.073]             if (.Platform$OS.type == "windows") {
[10:24:42.073]                 old_names <- names(...future.oldEnvVars)
[10:24:42.073]                 envs <- base::Sys.getenv()
[10:24:42.073]                 names <- names(envs)
[10:24:42.073]                 common <- intersect(names, old_names)
[10:24:42.073]                 added <- setdiff(names, old_names)
[10:24:42.073]                 removed <- setdiff(old_names, names)
[10:24:42.073]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:42.073]                   envs[common]]
[10:24:42.073]                 NAMES <- toupper(changed)
[10:24:42.073]                 args <- list()
[10:24:42.073]                 for (kk in seq_along(NAMES)) {
[10:24:42.073]                   name <- changed[[kk]]
[10:24:42.073]                   NAME <- NAMES[[kk]]
[10:24:42.073]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:42.073]                     next
[10:24:42.073]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:42.073]                 }
[10:24:42.073]                 NAMES <- toupper(added)
[10:24:42.073]                 for (kk in seq_along(NAMES)) {
[10:24:42.073]                   name <- added[[kk]]
[10:24:42.073]                   NAME <- NAMES[[kk]]
[10:24:42.073]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:42.073]                     next
[10:24:42.073]                   args[[name]] <- ""
[10:24:42.073]                 }
[10:24:42.073]                 NAMES <- toupper(removed)
[10:24:42.073]                 for (kk in seq_along(NAMES)) {
[10:24:42.073]                   name <- removed[[kk]]
[10:24:42.073]                   NAME <- NAMES[[kk]]
[10:24:42.073]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:42.073]                     next
[10:24:42.073]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:42.073]                 }
[10:24:42.073]                 if (length(args) > 0) 
[10:24:42.073]                   base::do.call(base::Sys.setenv, args = args)
[10:24:42.073]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:42.073]             }
[10:24:42.073]             else {
[10:24:42.073]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:42.073]             }
[10:24:42.073]             {
[10:24:42.073]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:42.073]                   0L) {
[10:24:42.073]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:42.073]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:42.073]                   base::options(opts)
[10:24:42.073]                 }
[10:24:42.073]                 {
[10:24:42.073]                   {
[10:24:42.073]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:42.073]                     NULL
[10:24:42.073]                   }
[10:24:42.073]                   options(future.plan = NULL)
[10:24:42.073]                   if (is.na(NA_character_)) 
[10:24:42.073]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:42.073]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:42.073]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:42.073]                     envir = parent.frame()) 
[10:24:42.073]                   {
[10:24:42.073]                     default_workers <- missing(workers)
[10:24:42.073]                     if (is.function(workers)) 
[10:24:42.073]                       workers <- workers()
[10:24:42.073]                     workers <- structure(as.integer(workers), 
[10:24:42.073]                       class = class(workers))
[10:24:42.073]                     stop_if_not(is.finite(workers), workers >= 
[10:24:42.073]                       1L)
[10:24:42.073]                     if ((workers == 1L && !inherits(workers, 
[10:24:42.073]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:42.073]                       if (default_workers) 
[10:24:42.073]                         supportsMulticore(warn = TRUE)
[10:24:42.073]                       return(sequential(..., envir = envir))
[10:24:42.073]                     }
[10:24:42.073]                     oopts <- options(mc.cores = workers)
[10:24:42.073]                     on.exit(options(oopts))
[10:24:42.073]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:42.073]                       envir = envir)
[10:24:42.073]                     if (!future$lazy) 
[10:24:42.073]                       future <- run(future)
[10:24:42.073]                     invisible(future)
[10:24:42.073]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:42.073]                 }
[10:24:42.073]             }
[10:24:42.073]         }
[10:24:42.073]     })
[10:24:42.073]     if (FALSE) {
[10:24:42.073]         base::sink(type = "output", split = FALSE)
[10:24:42.073]         if (NA) {
[10:24:42.073]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:42.073]         }
[10:24:42.073]         else {
[10:24:42.073]             ...future.result["stdout"] <- base::list(NULL)
[10:24:42.073]         }
[10:24:42.073]         base::close(...future.stdout)
[10:24:42.073]         ...future.stdout <- NULL
[10:24:42.073]     }
[10:24:42.073]     ...future.result$conditions <- ...future.conditions
[10:24:42.073]     ...future.result$finished <- base::Sys.time()
[10:24:42.073]     ...future.result
[10:24:42.073] }
[10:24:42.075] assign_globals() ...
[10:24:42.075] List of 5
[10:24:42.075]  $ ...future.FUN            :function (x)  
[10:24:42.075]  $ future.call.arguments    : list()
[10:24:42.075]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:42.075]  $ ...future.elements_ii    :List of 1
[10:24:42.075]   ..$ : int 1
[10:24:42.075]  $ ...future.seeds_ii       : NULL
[10:24:42.075]  $ ...future.globals.maxSize: NULL
[10:24:42.075]  - attr(*, "where")=List of 5
[10:24:42.075]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:42.075]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:42.075]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:42.075]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:42.075]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:42.075]  - attr(*, "resolved")= logi FALSE
[10:24:42.075]  - attr(*, "total_size")= num 4720
[10:24:42.075]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:42.075]  - attr(*, "already-done")= logi TRUE
[10:24:42.080] - reassign environment for ‘...future.FUN’
[10:24:42.080] - copied ‘...future.FUN’ to environment
[10:24:42.080] - copied ‘future.call.arguments’ to environment
[10:24:42.080] - copied ‘...future.elements_ii’ to environment
[10:24:42.080] - copied ‘...future.seeds_ii’ to environment
[10:24:42.080] - copied ‘...future.globals.maxSize’ to environment
[10:24:42.080] assign_globals() ... done
[10:24:42.081] requestCore(): workers = 2
[10:24:42.083] MulticoreFuture started
[10:24:42.083] - Launch lazy future ... done
[10:24:42.083] run() for ‘MulticoreFuture’ ... done
[10:24:42.084] Created future:
[10:24:42.084] plan(): Setting new future strategy stack:
[10:24:42.084] List of future strategies:
[10:24:42.084] 1. sequential:
[10:24:42.084]    - args: function (..., envir = parent.frame())
[10:24:42.084]    - tweaked: FALSE
[10:24:42.084]    - call: NULL
[10:24:42.085] plan(): nbrOfWorkers() = 1
[10:24:42.084] MulticoreFuture:
[10:24:42.084] Label: ‘future_lapply-1’
[10:24:42.084] Expression:
[10:24:42.084] {
[10:24:42.084]     do.call(function(...) {
[10:24:42.084]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:42.084]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:42.084]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:42.084]             on.exit(options(oopts), add = TRUE)
[10:24:42.084]         }
[10:24:42.084]         {
[10:24:42.084]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:42.084]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:42.084]                 ...future.FUN(...future.X_jj, ...)
[10:24:42.084]             })
[10:24:42.084]         }
[10:24:42.084]     }, args = future.call.arguments)
[10:24:42.084] }
[10:24:42.084] Lazy evaluation: FALSE
[10:24:42.084] Asynchronous evaluation: TRUE
[10:24:42.084] Local evaluation: TRUE
[10:24:42.084] Environment: R_GlobalEnv
[10:24:42.084] Capture standard output: NA
[10:24:42.084] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:42.084] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:42.084] Packages: <none>
[10:24:42.084] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:42.084] Resolved: FALSE
[10:24:42.084] Value: <not collected>
[10:24:42.084] Conditions captured: <none>
[10:24:42.084] Early signaling: FALSE
[10:24:42.084] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:42.084] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:42.097] Chunk #1 of 2 ... DONE
[10:24:42.097] Chunk #2 of 2 ...
[10:24:42.097]  - Finding globals in 'X' for chunk #2 ...
[10:24:42.097] getGlobalsAndPackages() ...
[10:24:42.098] Searching for globals...
[10:24:42.098] 
[10:24:42.098] Searching for globals ... DONE
[10:24:42.098] - globals: [0] <none>
[10:24:42.099] getGlobalsAndPackages() ... DONE
[10:24:42.099]    + additional globals found: [n=0] 
[10:24:42.099]    + additional namespaces needed: [n=0] 
[10:24:42.099]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:42.099]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:42.099]  - seeds: <none>
[10:24:42.099]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:42.100] getGlobalsAndPackages() ...
[10:24:42.100] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:42.100] Resolving globals: FALSE
[10:24:42.100] Tweak future expression to call with '...' arguments ...
[10:24:42.100] {
[10:24:42.100]     do.call(function(...) {
[10:24:42.100]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:42.100]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:42.100]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:42.100]             on.exit(options(oopts), add = TRUE)
[10:24:42.100]         }
[10:24:42.100]         {
[10:24:42.100]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:42.100]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:42.100]                 ...future.FUN(...future.X_jj, ...)
[10:24:42.100]             })
[10:24:42.100]         }
[10:24:42.100]     }, args = future.call.arguments)
[10:24:42.100] }
[10:24:42.101] Tweak future expression to call with '...' arguments ... DONE
[10:24:42.102] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:42.102] 
[10:24:42.102] getGlobalsAndPackages() ... DONE
[10:24:42.103] run() for ‘Future’ ...
[10:24:42.103] - state: ‘created’
[10:24:42.103] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:42.108] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:42.109] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:42.109]   - Field: ‘label’
[10:24:42.109]   - Field: ‘local’
[10:24:42.109]   - Field: ‘owner’
[10:24:42.109]   - Field: ‘envir’
[10:24:42.110]   - Field: ‘workers’
[10:24:42.110]   - Field: ‘packages’
[10:24:42.110]   - Field: ‘gc’
[10:24:42.110]   - Field: ‘job’
[10:24:42.110]   - Field: ‘conditions’
[10:24:42.110]   - Field: ‘expr’
[10:24:42.114]   - Field: ‘uuid’
[10:24:42.114]   - Field: ‘seed’
[10:24:42.114]   - Field: ‘version’
[10:24:42.115]   - Field: ‘result’
[10:24:42.115]   - Field: ‘asynchronous’
[10:24:42.115]   - Field: ‘calls’
[10:24:42.116]   - Field: ‘globals’
[10:24:42.116]   - Field: ‘stdout’
[10:24:42.116]   - Field: ‘earlySignal’
[10:24:42.116]   - Field: ‘lazy’
[10:24:42.117]   - Field: ‘state’
[10:24:42.117] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:42.117] - Launch lazy future ...
[10:24:42.118] Packages needed by the future expression (n = 0): <none>
[10:24:42.118] Packages needed by future strategies (n = 0): <none>
[10:24:42.119] {
[10:24:42.119]     {
[10:24:42.119]         {
[10:24:42.119]             ...future.startTime <- base::Sys.time()
[10:24:42.119]             {
[10:24:42.119]                 {
[10:24:42.119]                   {
[10:24:42.119]                     {
[10:24:42.119]                       base::local({
[10:24:42.119]                         has_future <- base::requireNamespace("future", 
[10:24:42.119]                           quietly = TRUE)
[10:24:42.119]                         if (has_future) {
[10:24:42.119]                           ns <- base::getNamespace("future")
[10:24:42.119]                           version <- ns[[".package"]][["version"]]
[10:24:42.119]                           if (is.null(version)) 
[10:24:42.119]                             version <- utils::packageVersion("future")
[10:24:42.119]                         }
[10:24:42.119]                         else {
[10:24:42.119]                           version <- NULL
[10:24:42.119]                         }
[10:24:42.119]                         if (!has_future || version < "1.8.0") {
[10:24:42.119]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:42.119]                             "", base::R.version$version.string), 
[10:24:42.119]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:42.119]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:42.119]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:42.119]                               "release", "version")], collapse = " "), 
[10:24:42.119]                             hostname = base::Sys.info()[["nodename"]])
[10:24:42.119]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:42.119]                             info)
[10:24:42.119]                           info <- base::paste(info, collapse = "; ")
[10:24:42.119]                           if (!has_future) {
[10:24:42.119]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:42.119]                               info)
[10:24:42.119]                           }
[10:24:42.119]                           else {
[10:24:42.119]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:42.119]                               info, version)
[10:24:42.119]                           }
[10:24:42.119]                           base::stop(msg)
[10:24:42.119]                         }
[10:24:42.119]                       })
[10:24:42.119]                     }
[10:24:42.119]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:42.119]                     base::options(mc.cores = 1L)
[10:24:42.119]                   }
[10:24:42.119]                   options(future.plan = NULL)
[10:24:42.119]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:42.119]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:42.119]                 }
[10:24:42.119]                 ...future.workdir <- getwd()
[10:24:42.119]             }
[10:24:42.119]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:42.119]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:42.119]         }
[10:24:42.119]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:42.119]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:42.119]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:42.119]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:42.119]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:42.119]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:42.119]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:42.119]             base::names(...future.oldOptions))
[10:24:42.119]     }
[10:24:42.119]     if (TRUE) {
[10:24:42.119]     }
[10:24:42.119]     else {
[10:24:42.119]         if (NA) {
[10:24:42.119]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:42.119]                 open = "w")
[10:24:42.119]         }
[10:24:42.119]         else {
[10:24:42.119]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:42.119]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:42.119]         }
[10:24:42.119]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:42.119]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:42.119]             base::sink(type = "output", split = FALSE)
[10:24:42.119]             base::close(...future.stdout)
[10:24:42.119]         }, add = TRUE)
[10:24:42.119]     }
[10:24:42.119]     ...future.frame <- base::sys.nframe()
[10:24:42.119]     ...future.conditions <- base::list()
[10:24:42.119]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:42.119]     if (FALSE) {
[10:24:42.119]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:42.119]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:42.119]     }
[10:24:42.119]     ...future.result <- base::tryCatch({
[10:24:42.119]         base::withCallingHandlers({
[10:24:42.119]             ...future.value <- base::withVisible(base::local({
[10:24:42.119]                 withCallingHandlers({
[10:24:42.119]                   {
[10:24:42.119]                     do.call(function(...) {
[10:24:42.119]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:42.119]                       if (!identical(...future.globals.maxSize.org, 
[10:24:42.119]                         ...future.globals.maxSize)) {
[10:24:42.119]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:42.119]                         on.exit(options(oopts), add = TRUE)
[10:24:42.119]                       }
[10:24:42.119]                       {
[10:24:42.119]                         lapply(seq_along(...future.elements_ii), 
[10:24:42.119]                           FUN = function(jj) {
[10:24:42.119]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:42.119]                             ...future.FUN(...future.X_jj, ...)
[10:24:42.119]                           })
[10:24:42.119]                       }
[10:24:42.119]                     }, args = future.call.arguments)
[10:24:42.119]                   }
[10:24:42.119]                 }, immediateCondition = function(cond) {
[10:24:42.119]                   save_rds <- function (object, pathname, ...) 
[10:24:42.119]                   {
[10:24:42.119]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:42.119]                     if (file_test("-f", pathname_tmp)) {
[10:24:42.119]                       fi_tmp <- file.info(pathname_tmp)
[10:24:42.119]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:42.119]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:42.119]                         fi_tmp[["mtime"]])
[10:24:42.119]                     }
[10:24:42.119]                     tryCatch({
[10:24:42.119]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:42.119]                     }, error = function(ex) {
[10:24:42.119]                       msg <- conditionMessage(ex)
[10:24:42.119]                       fi_tmp <- file.info(pathname_tmp)
[10:24:42.119]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:42.119]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:42.119]                         fi_tmp[["mtime"]], msg)
[10:24:42.119]                       ex$message <- msg
[10:24:42.119]                       stop(ex)
[10:24:42.119]                     })
[10:24:42.119]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:42.119]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:42.119]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:42.119]                       fi_tmp <- file.info(pathname_tmp)
[10:24:42.119]                       fi <- file.info(pathname)
[10:24:42.119]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:42.119]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:42.119]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:42.119]                         fi[["size"]], fi[["mtime"]])
[10:24:42.119]                       stop(msg)
[10:24:42.119]                     }
[10:24:42.119]                     invisible(pathname)
[10:24:42.119]                   }
[10:24:42.119]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:42.119]                     rootPath = tempdir()) 
[10:24:42.119]                   {
[10:24:42.119]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:42.119]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:42.119]                       tmpdir = path, fileext = ".rds")
[10:24:42.119]                     save_rds(obj, file)
[10:24:42.119]                   }
[10:24:42.119]                   saveImmediateCondition(cond, path = "/tmp/Rtmp5boaqN/.future/immediateConditions")
[10:24:42.119]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:42.119]                   {
[10:24:42.119]                     inherits <- base::inherits
[10:24:42.119]                     invokeRestart <- base::invokeRestart
[10:24:42.119]                     is.null <- base::is.null
[10:24:42.119]                     muffled <- FALSE
[10:24:42.119]                     if (inherits(cond, "message")) {
[10:24:42.119]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:42.119]                       if (muffled) 
[10:24:42.119]                         invokeRestart("muffleMessage")
[10:24:42.119]                     }
[10:24:42.119]                     else if (inherits(cond, "warning")) {
[10:24:42.119]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:42.119]                       if (muffled) 
[10:24:42.119]                         invokeRestart("muffleWarning")
[10:24:42.119]                     }
[10:24:42.119]                     else if (inherits(cond, "condition")) {
[10:24:42.119]                       if (!is.null(pattern)) {
[10:24:42.119]                         computeRestarts <- base::computeRestarts
[10:24:42.119]                         grepl <- base::grepl
[10:24:42.119]                         restarts <- computeRestarts(cond)
[10:24:42.119]                         for (restart in restarts) {
[10:24:42.119]                           name <- restart$name
[10:24:42.119]                           if (is.null(name)) 
[10:24:42.119]                             next
[10:24:42.119]                           if (!grepl(pattern, name)) 
[10:24:42.119]                             next
[10:24:42.119]                           invokeRestart(restart)
[10:24:42.119]                           muffled <- TRUE
[10:24:42.119]                           break
[10:24:42.119]                         }
[10:24:42.119]                       }
[10:24:42.119]                     }
[10:24:42.119]                     invisible(muffled)
[10:24:42.119]                   }
[10:24:42.119]                   muffleCondition(cond)
[10:24:42.119]                 })
[10:24:42.119]             }))
[10:24:42.119]             future::FutureResult(value = ...future.value$value, 
[10:24:42.119]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:42.119]                   ...future.rng), globalenv = if (FALSE) 
[10:24:42.119]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:42.119]                     ...future.globalenv.names))
[10:24:42.119]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:42.119]         }, condition = base::local({
[10:24:42.119]             c <- base::c
[10:24:42.119]             inherits <- base::inherits
[10:24:42.119]             invokeRestart <- base::invokeRestart
[10:24:42.119]             length <- base::length
[10:24:42.119]             list <- base::list
[10:24:42.119]             seq.int <- base::seq.int
[10:24:42.119]             signalCondition <- base::signalCondition
[10:24:42.119]             sys.calls <- base::sys.calls
[10:24:42.119]             `[[` <- base::`[[`
[10:24:42.119]             `+` <- base::`+`
[10:24:42.119]             `<<-` <- base::`<<-`
[10:24:42.119]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:42.119]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:42.119]                   3L)]
[10:24:42.119]             }
[10:24:42.119]             function(cond) {
[10:24:42.119]                 is_error <- inherits(cond, "error")
[10:24:42.119]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:42.119]                   NULL)
[10:24:42.119]                 if (is_error) {
[10:24:42.119]                   sessionInformation <- function() {
[10:24:42.119]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:42.119]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:42.119]                       search = base::search(), system = base::Sys.info())
[10:24:42.119]                   }
[10:24:42.119]                   ...future.conditions[[length(...future.conditions) + 
[10:24:42.119]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:42.119]                     cond$call), session = sessionInformation(), 
[10:24:42.119]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:42.119]                   signalCondition(cond)
[10:24:42.119]                 }
[10:24:42.119]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:42.119]                 "immediateCondition"))) {
[10:24:42.119]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:42.119]                   ...future.conditions[[length(...future.conditions) + 
[10:24:42.119]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:42.119]                   if (TRUE && !signal) {
[10:24:42.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:42.119]                     {
[10:24:42.119]                       inherits <- base::inherits
[10:24:42.119]                       invokeRestart <- base::invokeRestart
[10:24:42.119]                       is.null <- base::is.null
[10:24:42.119]                       muffled <- FALSE
[10:24:42.119]                       if (inherits(cond, "message")) {
[10:24:42.119]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:42.119]                         if (muffled) 
[10:24:42.119]                           invokeRestart("muffleMessage")
[10:24:42.119]                       }
[10:24:42.119]                       else if (inherits(cond, "warning")) {
[10:24:42.119]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:42.119]                         if (muffled) 
[10:24:42.119]                           invokeRestart("muffleWarning")
[10:24:42.119]                       }
[10:24:42.119]                       else if (inherits(cond, "condition")) {
[10:24:42.119]                         if (!is.null(pattern)) {
[10:24:42.119]                           computeRestarts <- base::computeRestarts
[10:24:42.119]                           grepl <- base::grepl
[10:24:42.119]                           restarts <- computeRestarts(cond)
[10:24:42.119]                           for (restart in restarts) {
[10:24:42.119]                             name <- restart$name
[10:24:42.119]                             if (is.null(name)) 
[10:24:42.119]                               next
[10:24:42.119]                             if (!grepl(pattern, name)) 
[10:24:42.119]                               next
[10:24:42.119]                             invokeRestart(restart)
[10:24:42.119]                             muffled <- TRUE
[10:24:42.119]                             break
[10:24:42.119]                           }
[10:24:42.119]                         }
[10:24:42.119]                       }
[10:24:42.119]                       invisible(muffled)
[10:24:42.119]                     }
[10:24:42.119]                     muffleCondition(cond, pattern = "^muffle")
[10:24:42.119]                   }
[10:24:42.119]                 }
[10:24:42.119]                 else {
[10:24:42.119]                   if (TRUE) {
[10:24:42.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:42.119]                     {
[10:24:42.119]                       inherits <- base::inherits
[10:24:42.119]                       invokeRestart <- base::invokeRestart
[10:24:42.119]                       is.null <- base::is.null
[10:24:42.119]                       muffled <- FALSE
[10:24:42.119]                       if (inherits(cond, "message")) {
[10:24:42.119]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:42.119]                         if (muffled) 
[10:24:42.119]                           invokeRestart("muffleMessage")
[10:24:42.119]                       }
[10:24:42.119]                       else if (inherits(cond, "warning")) {
[10:24:42.119]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:42.119]                         if (muffled) 
[10:24:42.119]                           invokeRestart("muffleWarning")
[10:24:42.119]                       }
[10:24:42.119]                       else if (inherits(cond, "condition")) {
[10:24:42.119]                         if (!is.null(pattern)) {
[10:24:42.119]                           computeRestarts <- base::computeRestarts
[10:24:42.119]                           grepl <- base::grepl
[10:24:42.119]                           restarts <- computeRestarts(cond)
[10:24:42.119]                           for (restart in restarts) {
[10:24:42.119]                             name <- restart$name
[10:24:42.119]                             if (is.null(name)) 
[10:24:42.119]                               next
[10:24:42.119]                             if (!grepl(pattern, name)) 
[10:24:42.119]                               next
[10:24:42.119]                             invokeRestart(restart)
[10:24:42.119]                             muffled <- TRUE
[10:24:42.119]                             break
[10:24:42.119]                           }
[10:24:42.119]                         }
[10:24:42.119]                       }
[10:24:42.119]                       invisible(muffled)
[10:24:42.119]                     }
[10:24:42.119]                     muffleCondition(cond, pattern = "^muffle")
[10:24:42.119]                   }
[10:24:42.119]                 }
[10:24:42.119]             }
[10:24:42.119]         }))
[10:24:42.119]     }, error = function(ex) {
[10:24:42.119]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:42.119]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:42.119]                 ...future.rng), started = ...future.startTime, 
[10:24:42.119]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:42.119]             version = "1.8"), class = "FutureResult")
[10:24:42.119]     }, finally = {
[10:24:42.119]         if (!identical(...future.workdir, getwd())) 
[10:24:42.119]             setwd(...future.workdir)
[10:24:42.119]         {
[10:24:42.119]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:42.119]                 ...future.oldOptions$nwarnings <- NULL
[10:24:42.119]             }
[10:24:42.119]             base::options(...future.oldOptions)
[10:24:42.119]             if (.Platform$OS.type == "windows") {
[10:24:42.119]                 old_names <- names(...future.oldEnvVars)
[10:24:42.119]                 envs <- base::Sys.getenv()
[10:24:42.119]                 names <- names(envs)
[10:24:42.119]                 common <- intersect(names, old_names)
[10:24:42.119]                 added <- setdiff(names, old_names)
[10:24:42.119]                 removed <- setdiff(old_names, names)
[10:24:42.119]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:42.119]                   envs[common]]
[10:24:42.119]                 NAMES <- toupper(changed)
[10:24:42.119]                 args <- list()
[10:24:42.119]                 for (kk in seq_along(NAMES)) {
[10:24:42.119]                   name <- changed[[kk]]
[10:24:42.119]                   NAME <- NAMES[[kk]]
[10:24:42.119]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:42.119]                     next
[10:24:42.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:42.119]                 }
[10:24:42.119]                 NAMES <- toupper(added)
[10:24:42.119]                 for (kk in seq_along(NAMES)) {
[10:24:42.119]                   name <- added[[kk]]
[10:24:42.119]                   NAME <- NAMES[[kk]]
[10:24:42.119]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:42.119]                     next
[10:24:42.119]                   args[[name]] <- ""
[10:24:42.119]                 }
[10:24:42.119]                 NAMES <- toupper(removed)
[10:24:42.119]                 for (kk in seq_along(NAMES)) {
[10:24:42.119]                   name <- removed[[kk]]
[10:24:42.119]                   NAME <- NAMES[[kk]]
[10:24:42.119]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:42.119]                     next
[10:24:42.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:42.119]                 }
[10:24:42.119]                 if (length(args) > 0) 
[10:24:42.119]                   base::do.call(base::Sys.setenv, args = args)
[10:24:42.119]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:42.119]             }
[10:24:42.119]             else {
[10:24:42.119]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:42.119]             }
[10:24:42.119]             {
[10:24:42.119]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:42.119]                   0L) {
[10:24:42.119]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:42.119]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:42.119]                   base::options(opts)
[10:24:42.119]                 }
[10:24:42.119]                 {
[10:24:42.119]                   {
[10:24:42.119]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:42.119]                     NULL
[10:24:42.119]                   }
[10:24:42.119]                   options(future.plan = NULL)
[10:24:42.119]                   if (is.na(NA_character_)) 
[10:24:42.119]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:42.119]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:42.119]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:42.119]                     envir = parent.frame()) 
[10:24:42.119]                   {
[10:24:42.119]                     default_workers <- missing(workers)
[10:24:42.119]                     if (is.function(workers)) 
[10:24:42.119]                       workers <- workers()
[10:24:42.119]                     workers <- structure(as.integer(workers), 
[10:24:42.119]                       class = class(workers))
[10:24:42.119]                     stop_if_not(is.finite(workers), workers >= 
[10:24:42.119]                       1L)
[10:24:42.119]                     if ((workers == 1L && !inherits(workers, 
[10:24:42.119]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:42.119]                       if (default_workers) 
[10:24:42.119]                         supportsMulticore(warn = TRUE)
[10:24:42.119]                       return(sequential(..., envir = envir))
[10:24:42.119]                     }
[10:24:42.119]                     oopts <- options(mc.cores = workers)
[10:24:42.119]                     on.exit(options(oopts))
[10:24:42.119]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:42.119]                       envir = envir)
[10:24:42.119]                     if (!future$lazy) 
[10:24:42.119]                       future <- run(future)
[10:24:42.119]                     invisible(future)
[10:24:42.119]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:42.119]                 }
[10:24:42.119]             }
[10:24:42.119]         }
[10:24:42.119]     })
[10:24:42.119]     if (FALSE) {
[10:24:42.119]         base::sink(type = "output", split = FALSE)
[10:24:42.119]         if (NA) {
[10:24:42.119]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:42.119]         }
[10:24:42.119]         else {
[10:24:42.119]             ...future.result["stdout"] <- base::list(NULL)
[10:24:42.119]         }
[10:24:42.119]         base::close(...future.stdout)
[10:24:42.119]         ...future.stdout <- NULL
[10:24:42.119]     }
[10:24:42.119]     ...future.result$conditions <- ...future.conditions
[10:24:42.119]     ...future.result$finished <- base::Sys.time()
[10:24:42.119]     ...future.result
[10:24:42.119] }
[10:24:42.122] assign_globals() ...
[10:24:42.122] List of 5
[10:24:42.122]  $ ...future.FUN            :function (x)  
[10:24:42.122]  $ future.call.arguments    : list()
[10:24:42.122]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:42.122]  $ ...future.elements_ii    :List of 1
[10:24:42.122]   ..$ : int 0
[10:24:42.122]  $ ...future.seeds_ii       : NULL
[10:24:42.122]  $ ...future.globals.maxSize: NULL
[10:24:42.122]  - attr(*, "where")=List of 5
[10:24:42.122]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:42.122]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:24:42.122]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:42.122]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:42.122]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:42.122]  - attr(*, "resolved")= logi FALSE
[10:24:42.122]  - attr(*, "total_size")= num 4720
[10:24:42.122]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:42.122]  - attr(*, "already-done")= logi TRUE
[10:24:42.129] - reassign environment for ‘...future.FUN’
[10:24:42.130] - copied ‘...future.FUN’ to environment
[10:24:42.130] - copied ‘future.call.arguments’ to environment
[10:24:42.130] - copied ‘...future.elements_ii’ to environment
[10:24:42.130] - copied ‘...future.seeds_ii’ to environment
[10:24:42.130] - copied ‘...future.globals.maxSize’ to environment
[10:24:42.130] assign_globals() ... done
[10:24:42.130] requestCore(): workers = 2
[10:24:42.133] MulticoreFuture started
[10:24:42.133] - Launch lazy future ... done
[10:24:42.133] run() for ‘MulticoreFuture’ ... done
[10:24:42.134] Created future:
[10:24:42.134] plan(): Setting new future strategy stack:
[10:24:42.134] List of future strategies:
[10:24:42.134] 1. sequential:
[10:24:42.134]    - args: function (..., envir = parent.frame())
[10:24:42.134]    - tweaked: FALSE
[10:24:42.134]    - call: NULL
[10:24:42.135] plan(): nbrOfWorkers() = 1
[10:24:42.137] plan(): Setting new future strategy stack:
[10:24:42.137] List of future strategies:
[10:24:42.137] 1. multicore:
[10:24:42.137]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:42.137]    - tweaked: FALSE
[10:24:42.137]    - call: plan(strategy)
[10:24:42.142] plan(): nbrOfWorkers() = 2
[10:24:42.134] MulticoreFuture:
[10:24:42.134] Label: ‘future_lapply-2’
[10:24:42.134] Expression:
[10:24:42.134] {
[10:24:42.134]     do.call(function(...) {
[10:24:42.134]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:42.134]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:42.134]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:42.134]             on.exit(options(oopts), add = TRUE)
[10:24:42.134]         }
[10:24:42.134]         {
[10:24:42.134]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:42.134]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:42.134]                 ...future.FUN(...future.X_jj, ...)
[10:24:42.134]             })
[10:24:42.134]         }
[10:24:42.134]     }, args = future.call.arguments)
[10:24:42.134] }
[10:24:42.134] Lazy evaluation: FALSE
[10:24:42.134] Asynchronous evaluation: TRUE
[10:24:42.134] Local evaluation: TRUE
[10:24:42.134] Environment: R_GlobalEnv
[10:24:42.134] Capture standard output: NA
[10:24:42.134] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:42.134] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:42.134] Packages: <none>
[10:24:42.134] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:42.134] Resolved: TRUE
[10:24:42.134] Value: <not collected>
[10:24:42.134] Conditions captured: <none>
[10:24:42.134] Early signaling: FALSE
[10:24:42.134] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:42.134] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:42.143] Chunk #2 of 2 ... DONE
[10:24:42.143] Launching 2 futures (chunks) ... DONE
[10:24:42.144] Resolving 2 futures (chunks) ...
[10:24:42.144] resolve() on list ...
[10:24:42.144]  recursive: 0
[10:24:42.144]  length: 2
[10:24:42.144] 
[10:24:42.155] Future #2
[10:24:42.155] result() for MulticoreFuture ...
[10:24:42.156] result() for MulticoreFuture ...
[10:24:42.156] result() for MulticoreFuture ... done
[10:24:42.156] result() for MulticoreFuture ... done
[10:24:42.157] result() for MulticoreFuture ...
[10:24:42.157] result() for MulticoreFuture ... done
[10:24:42.157] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:24:42.157] - nx: 2
[10:24:42.157] - relay: TRUE
[10:24:42.157] - stdout: TRUE
[10:24:42.157] - signal: TRUE
[10:24:42.158] - resignal: FALSE
[10:24:42.158] - force: TRUE
[10:24:42.158] - relayed: [n=2] FALSE, FALSE
[10:24:42.158] - queued futures: [n=2] FALSE, FALSE
[10:24:42.158]  - until=1
[10:24:42.158]  - relaying element #1
[10:24:42.158] - relayed: [n=2] FALSE, FALSE
[10:24:42.159] - queued futures: [n=2] FALSE, TRUE
[10:24:42.159] signalConditionsASAP(NULL, pos=2) ... done
[10:24:42.159]  length: 1 (resolved future 2)
[10:24:42.588] plan(): Setting new future strategy stack:
[10:24:42.588] List of future strategies:
[10:24:42.588] 1. multicore:
[10:24:42.588]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:42.588]    - tweaked: FALSE
[10:24:42.588]    - call: plan(strategy)
[10:24:42.592] plan(): nbrOfWorkers() = 2
[10:24:42.597] Future #1
[10:24:42.597] result() for MulticoreFuture ...
[10:24:42.598] result() for MulticoreFuture ...
[10:24:42.598] result() for MulticoreFuture ... done
[10:24:42.598] result() for MulticoreFuture ... done
[10:24:42.598] result() for MulticoreFuture ...
[10:24:42.598] result() for MulticoreFuture ... done
[10:24:42.598] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:24:42.598] - nx: 2
[10:24:42.598] - relay: TRUE
[10:24:42.599] - stdout: TRUE
[10:24:42.599] - signal: TRUE
[10:24:42.599] - resignal: FALSE
[10:24:42.599] - force: TRUE
[10:24:42.599] - relayed: [n=2] FALSE, FALSE
[10:24:42.599] - queued futures: [n=2] FALSE, TRUE
[10:24:42.599]  - until=1
[10:24:42.599]  - relaying element #1
[10:24:42.599] result() for MulticoreFuture ...
[10:24:42.600] result() for MulticoreFuture ... done
[10:24:42.600] result() for MulticoreFuture ...
[10:24:42.600] result() for MulticoreFuture ... done
[10:24:42.600] result() for MulticoreFuture ...
[10:24:42.600] result() for MulticoreFuture ... done
[10:24:42.600] result() for MulticoreFuture ...
[10:24:42.600] result() for MulticoreFuture ... done
[10:24:42.600] - relayed: [n=2] TRUE, FALSE
[10:24:42.601] - queued futures: [n=2] TRUE, TRUE
[10:24:42.601] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:24:42.601]  length: 0 (resolved future 1)
[10:24:42.601] Relaying remaining futures
[10:24:42.601] signalConditionsASAP(NULL, pos=0) ...
[10:24:42.601] - nx: 2
[10:24:42.601] - relay: TRUE
[10:24:42.601] - stdout: TRUE
[10:24:42.602] - signal: TRUE
[10:24:42.602] - resignal: FALSE
[10:24:42.602] - force: TRUE
[10:24:42.602] - relayed: [n=2] TRUE, FALSE
[10:24:42.602] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:42.602]  - relaying element #2
[10:24:42.602] result() for MulticoreFuture ...
[10:24:42.602] result() for MulticoreFuture ... done
[10:24:42.603] result() for MulticoreFuture ...
[10:24:42.603] result() for MulticoreFuture ... done
[10:24:42.603] result() for MulticoreFuture ...
[10:24:42.603] result() for MulticoreFuture ... done
[10:24:42.603] result() for MulticoreFuture ...
[10:24:42.603] result() for MulticoreFuture ... done
[10:24:42.603] - relayed: [n=2] TRUE, TRUE
[10:24:42.603] - queued futures: [n=2] TRUE, TRUE
[10:24:42.603] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[10:24:42.604] resolve() on list ... DONE
[10:24:42.604] result() for MulticoreFuture ...
[10:24:42.604] result() for MulticoreFuture ... done
[10:24:42.604] result() for MulticoreFuture ...
[10:24:42.604] result() for MulticoreFuture ... done
[10:24:42.607] result() for MulticoreFuture ...
[10:24:42.607] result() for MulticoreFuture ... done
[10:24:42.607] result() for MulticoreFuture ...
[10:24:42.607] result() for MulticoreFuture ... done
[10:24:42.607]  - Number of value chunks collected: 2
[10:24:42.607] Resolving 2 futures (chunks) ... DONE
[10:24:42.608] Reducing values from 2 chunks ...
[10:24:42.608]  - Number of values collected after concatenation: 2
[10:24:42.608]  - Number of values expected: 2
[10:24:42.608] Reducing values from 2 chunks ... DONE
[10:24:42.608] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[10:24:42.609] future_mapply() ...
[10:24:42.613] Number of chunks: 2
[10:24:42.613] getGlobalsAndPackagesXApply() ...
[10:24:42.613]  - future.globals: TRUE
[10:24:42.614] getGlobalsAndPackages() ...
[10:24:42.614] Searching for globals...
[10:24:42.616] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:24:42.616] Searching for globals ... DONE
[10:24:42.616] Resolving globals: FALSE
[10:24:42.616] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[10:24:42.617] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[10:24:42.617] - globals: [1] ‘FUN’
[10:24:42.617] 
[10:24:42.617] getGlobalsAndPackages() ... DONE
[10:24:42.617]  - globals found/used: [n=1] ‘FUN’
[10:24:42.618]  - needed namespaces: [n=0] 
[10:24:42.618] Finding globals ... DONE
[10:24:42.618] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:24:42.618] List of 2
[10:24:42.618]  $ ...future.FUN:function (x, y)  
[10:24:42.618]  $ MoreArgs     : NULL
[10:24:42.618]  - attr(*, "where")=List of 2
[10:24:42.618]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:42.618]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:24:42.618]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:42.618]  - attr(*, "resolved")= logi FALSE
[10:24:42.618]  - attr(*, "total_size")= num NA
[10:24:42.621] Packages to be attached in all futures: [n=0] 
[10:24:42.621] getGlobalsAndPackagesXApply() ... DONE
[10:24:42.621] Number of futures (= number of chunks): 2
[10:24:42.621] Launching 2 futures (chunks) ...
[10:24:42.621] Chunk #1 of 2 ...
[10:24:42.622]  - Finding globals in '...' for chunk #1 ...
[10:24:42.622] getGlobalsAndPackages() ...
[10:24:42.622] Searching for globals...
[10:24:42.622] 
[10:24:42.622] Searching for globals ... DONE
[10:24:42.622] - globals: [0] <none>
[10:24:42.622] getGlobalsAndPackages() ... DONE
[10:24:42.622]    + additional globals found: [n=0] 
[10:24:42.623]    + additional namespaces needed: [n=0] 
[10:24:42.623]  - Finding globals in '...' for chunk #1 ... DONE
[10:24:42.623]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:42.623]  - seeds: <none>
[10:24:42.623]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:42.623] getGlobalsAndPackages() ...
[10:24:42.623] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:42.623] Resolving globals: FALSE
[10:24:42.624] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[10:24:42.624] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:24:42.624] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:42.624] 
[10:24:42.625] getGlobalsAndPackages() ... DONE
[10:24:42.625] run() for ‘Future’ ...
[10:24:42.625] - state: ‘created’
[10:24:42.625] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:42.629] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:42.629] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:42.629]   - Field: ‘label’
[10:24:42.629]   - Field: ‘local’
[10:24:42.629]   - Field: ‘owner’
[10:24:42.629]   - Field: ‘envir’
[10:24:42.630]   - Field: ‘workers’
[10:24:42.630]   - Field: ‘packages’
[10:24:42.630]   - Field: ‘gc’
[10:24:42.630]   - Field: ‘job’
[10:24:42.630]   - Field: ‘conditions’
[10:24:42.630]   - Field: ‘expr’
[10:24:42.630]   - Field: ‘uuid’
[10:24:42.630]   - Field: ‘seed’
[10:24:42.630]   - Field: ‘version’
[10:24:42.630]   - Field: ‘result’
[10:24:42.630]   - Field: ‘asynchronous’
[10:24:42.631]   - Field: ‘calls’
[10:24:42.631]   - Field: ‘globals’
[10:24:42.631]   - Field: ‘stdout’
[10:24:42.631]   - Field: ‘earlySignal’
[10:24:42.631]   - Field: ‘lazy’
[10:24:42.631]   - Field: ‘state’
[10:24:42.631] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:42.631] - Launch lazy future ...
[10:24:42.632] Packages needed by the future expression (n = 0): <none>
[10:24:42.632] Packages needed by future strategies (n = 0): <none>
[10:24:42.632] {
[10:24:42.632]     {
[10:24:42.632]         {
[10:24:42.632]             ...future.startTime <- base::Sys.time()
[10:24:42.632]             {
[10:24:42.632]                 {
[10:24:42.632]                   {
[10:24:42.632]                     {
[10:24:42.632]                       base::local({
[10:24:42.632]                         has_future <- base::requireNamespace("future", 
[10:24:42.632]                           quietly = TRUE)
[10:24:42.632]                         if (has_future) {
[10:24:42.632]                           ns <- base::getNamespace("future")
[10:24:42.632]                           version <- ns[[".package"]][["version"]]
[10:24:42.632]                           if (is.null(version)) 
[10:24:42.632]                             version <- utils::packageVersion("future")
[10:24:42.632]                         }
[10:24:42.632]                         else {
[10:24:42.632]                           version <- NULL
[10:24:42.632]                         }
[10:24:42.632]                         if (!has_future || version < "1.8.0") {
[10:24:42.632]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:42.632]                             "", base::R.version$version.string), 
[10:24:42.632]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:42.632]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:42.632]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:42.632]                               "release", "version")], collapse = " "), 
[10:24:42.632]                             hostname = base::Sys.info()[["nodename"]])
[10:24:42.632]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:42.632]                             info)
[10:24:42.632]                           info <- base::paste(info, collapse = "; ")
[10:24:42.632]                           if (!has_future) {
[10:24:42.632]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:42.632]                               info)
[10:24:42.632]                           }
[10:24:42.632]                           else {
[10:24:42.632]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:42.632]                               info, version)
[10:24:42.632]                           }
[10:24:42.632]                           base::stop(msg)
[10:24:42.632]                         }
[10:24:42.632]                       })
[10:24:42.632]                     }
[10:24:42.632]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:42.632]                     base::options(mc.cores = 1L)
[10:24:42.632]                   }
[10:24:42.632]                   options(future.plan = NULL)
[10:24:42.632]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:42.632]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:42.632]                 }
[10:24:42.632]                 ...future.workdir <- getwd()
[10:24:42.632]             }
[10:24:42.632]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:42.632]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:42.632]         }
[10:24:42.632]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:42.632]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:42.632]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:42.632]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:42.632]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:42.632]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:42.632]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:42.632]             base::names(...future.oldOptions))
[10:24:42.632]     }
[10:24:42.632]     if (FALSE) {
[10:24:42.632]     }
[10:24:42.632]     else {
[10:24:42.632]         if (FALSE) {
[10:24:42.632]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:42.632]                 open = "w")
[10:24:42.632]         }
[10:24:42.632]         else {
[10:24:42.632]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:42.632]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:42.632]         }
[10:24:42.632]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:42.632]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:42.632]             base::sink(type = "output", split = FALSE)
[10:24:42.632]             base::close(...future.stdout)
[10:24:42.632]         }, add = TRUE)
[10:24:42.632]     }
[10:24:42.632]     ...future.frame <- base::sys.nframe()
[10:24:42.632]     ...future.conditions <- base::list()
[10:24:42.632]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:42.632]     if (FALSE) {
[10:24:42.632]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:42.632]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:42.632]     }
[10:24:42.632]     ...future.result <- base::tryCatch({
[10:24:42.632]         base::withCallingHandlers({
[10:24:42.632]             ...future.value <- base::withVisible(base::local({
[10:24:42.632]                 withCallingHandlers({
[10:24:42.632]                   {
[10:24:42.632]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:42.632]                     if (!identical(...future.globals.maxSize.org, 
[10:24:42.632]                       ...future.globals.maxSize)) {
[10:24:42.632]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:42.632]                       on.exit(options(oopts), add = TRUE)
[10:24:42.632]                     }
[10:24:42.632]                     {
[10:24:42.632]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:42.632]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:24:42.632]                         USE.NAMES = FALSE)
[10:24:42.632]                       do.call(mapply, args = args)
[10:24:42.632]                     }
[10:24:42.632]                   }
[10:24:42.632]                 }, immediateCondition = function(cond) {
[10:24:42.632]                   save_rds <- function (object, pathname, ...) 
[10:24:42.632]                   {
[10:24:42.632]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:42.632]                     if (file_test("-f", pathname_tmp)) {
[10:24:42.632]                       fi_tmp <- file.info(pathname_tmp)
[10:24:42.632]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:42.632]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:42.632]                         fi_tmp[["mtime"]])
[10:24:42.632]                     }
[10:24:42.632]                     tryCatch({
[10:24:42.632]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:42.632]                     }, error = function(ex) {
[10:24:42.632]                       msg <- conditionMessage(ex)
[10:24:42.632]                       fi_tmp <- file.info(pathname_tmp)
[10:24:42.632]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:42.632]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:42.632]                         fi_tmp[["mtime"]], msg)
[10:24:42.632]                       ex$message <- msg
[10:24:42.632]                       stop(ex)
[10:24:42.632]                     })
[10:24:42.632]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:42.632]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:42.632]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:42.632]                       fi_tmp <- file.info(pathname_tmp)
[10:24:42.632]                       fi <- file.info(pathname)
[10:24:42.632]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:42.632]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:42.632]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:42.632]                         fi[["size"]], fi[["mtime"]])
[10:24:42.632]                       stop(msg)
[10:24:42.632]                     }
[10:24:42.632]                     invisible(pathname)
[10:24:42.632]                   }
[10:24:42.632]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:42.632]                     rootPath = tempdir()) 
[10:24:42.632]                   {
[10:24:42.632]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:42.632]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:42.632]                       tmpdir = path, fileext = ".rds")
[10:24:42.632]                     save_rds(obj, file)
[10:24:42.632]                   }
[10:24:42.632]                   saveImmediateCondition(cond, path = "/tmp/Rtmp5boaqN/.future/immediateConditions")
[10:24:42.632]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:42.632]                   {
[10:24:42.632]                     inherits <- base::inherits
[10:24:42.632]                     invokeRestart <- base::invokeRestart
[10:24:42.632]                     is.null <- base::is.null
[10:24:42.632]                     muffled <- FALSE
[10:24:42.632]                     if (inherits(cond, "message")) {
[10:24:42.632]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:42.632]                       if (muffled) 
[10:24:42.632]                         invokeRestart("muffleMessage")
[10:24:42.632]                     }
[10:24:42.632]                     else if (inherits(cond, "warning")) {
[10:24:42.632]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:42.632]                       if (muffled) 
[10:24:42.632]                         invokeRestart("muffleWarning")
[10:24:42.632]                     }
[10:24:42.632]                     else if (inherits(cond, "condition")) {
[10:24:42.632]                       if (!is.null(pattern)) {
[10:24:42.632]                         computeRestarts <- base::computeRestarts
[10:24:42.632]                         grepl <- base::grepl
[10:24:42.632]                         restarts <- computeRestarts(cond)
[10:24:42.632]                         for (restart in restarts) {
[10:24:42.632]                           name <- restart$name
[10:24:42.632]                           if (is.null(name)) 
[10:24:42.632]                             next
[10:24:42.632]                           if (!grepl(pattern, name)) 
[10:24:42.632]                             next
[10:24:42.632]                           invokeRestart(restart)
[10:24:42.632]                           muffled <- TRUE
[10:24:42.632]                           break
[10:24:42.632]                         }
[10:24:42.632]                       }
[10:24:42.632]                     }
[10:24:42.632]                     invisible(muffled)
[10:24:42.632]                   }
[10:24:42.632]                   muffleCondition(cond)
[10:24:42.632]                 })
[10:24:42.632]             }))
[10:24:42.632]             future::FutureResult(value = ...future.value$value, 
[10:24:42.632]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:42.632]                   ...future.rng), globalenv = if (FALSE) 
[10:24:42.632]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:42.632]                     ...future.globalenv.names))
[10:24:42.632]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:42.632]         }, condition = base::local({
[10:24:42.632]             c <- base::c
[10:24:42.632]             inherits <- base::inherits
[10:24:42.632]             invokeRestart <- base::invokeRestart
[10:24:42.632]             length <- base::length
[10:24:42.632]             list <- base::list
[10:24:42.632]             seq.int <- base::seq.int
[10:24:42.632]             signalCondition <- base::signalCondition
[10:24:42.632]             sys.calls <- base::sys.calls
[10:24:42.632]             `[[` <- base::`[[`
[10:24:42.632]             `+` <- base::`+`
[10:24:42.632]             `<<-` <- base::`<<-`
[10:24:42.632]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:42.632]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:42.632]                   3L)]
[10:24:42.632]             }
[10:24:42.632]             function(cond) {
[10:24:42.632]                 is_error <- inherits(cond, "error")
[10:24:42.632]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:42.632]                   NULL)
[10:24:42.632]                 if (is_error) {
[10:24:42.632]                   sessionInformation <- function() {
[10:24:42.632]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:42.632]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:42.632]                       search = base::search(), system = base::Sys.info())
[10:24:42.632]                   }
[10:24:42.632]                   ...future.conditions[[length(...future.conditions) + 
[10:24:42.632]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:42.632]                     cond$call), session = sessionInformation(), 
[10:24:42.632]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:42.632]                   signalCondition(cond)
[10:24:42.632]                 }
[10:24:42.632]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:42.632]                 "immediateCondition"))) {
[10:24:42.632]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:42.632]                   ...future.conditions[[length(...future.conditions) + 
[10:24:42.632]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:42.632]                   if (TRUE && !signal) {
[10:24:42.632]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:42.632]                     {
[10:24:42.632]                       inherits <- base::inherits
[10:24:42.632]                       invokeRestart <- base::invokeRestart
[10:24:42.632]                       is.null <- base::is.null
[10:24:42.632]                       muffled <- FALSE
[10:24:42.632]                       if (inherits(cond, "message")) {
[10:24:42.632]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:42.632]                         if (muffled) 
[10:24:42.632]                           invokeRestart("muffleMessage")
[10:24:42.632]                       }
[10:24:42.632]                       else if (inherits(cond, "warning")) {
[10:24:42.632]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:42.632]                         if (muffled) 
[10:24:42.632]                           invokeRestart("muffleWarning")
[10:24:42.632]                       }
[10:24:42.632]                       else if (inherits(cond, "condition")) {
[10:24:42.632]                         if (!is.null(pattern)) {
[10:24:42.632]                           computeRestarts <- base::computeRestarts
[10:24:42.632]                           grepl <- base::grepl
[10:24:42.632]                           restarts <- computeRestarts(cond)
[10:24:42.632]                           for (restart in restarts) {
[10:24:42.632]                             name <- restart$name
[10:24:42.632]                             if (is.null(name)) 
[10:24:42.632]                               next
[10:24:42.632]                             if (!grepl(pattern, name)) 
[10:24:42.632]                               next
[10:24:42.632]                             invokeRestart(restart)
[10:24:42.632]                             muffled <- TRUE
[10:24:42.632]                             break
[10:24:42.632]                           }
[10:24:42.632]                         }
[10:24:42.632]                       }
[10:24:42.632]                       invisible(muffled)
[10:24:42.632]                     }
[10:24:42.632]                     muffleCondition(cond, pattern = "^muffle")
[10:24:42.632]                   }
[10:24:42.632]                 }
[10:24:42.632]                 else {
[10:24:42.632]                   if (TRUE) {
[10:24:42.632]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:42.632]                     {
[10:24:42.632]                       inherits <- base::inherits
[10:24:42.632]                       invokeRestart <- base::invokeRestart
[10:24:42.632]                       is.null <- base::is.null
[10:24:42.632]                       muffled <- FALSE
[10:24:42.632]                       if (inherits(cond, "message")) {
[10:24:42.632]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:42.632]                         if (muffled) 
[10:24:42.632]                           invokeRestart("muffleMessage")
[10:24:42.632]                       }
[10:24:42.632]                       else if (inherits(cond, "warning")) {
[10:24:42.632]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:42.632]                         if (muffled) 
[10:24:42.632]                           invokeRestart("muffleWarning")
[10:24:42.632]                       }
[10:24:42.632]                       else if (inherits(cond, "condition")) {
[10:24:42.632]                         if (!is.null(pattern)) {
[10:24:42.632]                           computeRestarts <- base::computeRestarts
[10:24:42.632]                           grepl <- base::grepl
[10:24:42.632]                           restarts <- computeRestarts(cond)
[10:24:42.632]                           for (restart in restarts) {
[10:24:42.632]                             name <- restart$name
[10:24:42.632]                             if (is.null(name)) 
[10:24:42.632]                               next
[10:24:42.632]                             if (!grepl(pattern, name)) 
[10:24:42.632]                               next
[10:24:42.632]                             invokeRestart(restart)
[10:24:42.632]                             muffled <- TRUE
[10:24:42.632]                             break
[10:24:42.632]                           }
[10:24:42.632]                         }
[10:24:42.632]                       }
[10:24:42.632]                       invisible(muffled)
[10:24:42.632]                     }
[10:24:42.632]                     muffleCondition(cond, pattern = "^muffle")
[10:24:42.632]                   }
[10:24:42.632]                 }
[10:24:42.632]             }
[10:24:42.632]         }))
[10:24:42.632]     }, error = function(ex) {
[10:24:42.632]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:42.632]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:42.632]                 ...future.rng), started = ...future.startTime, 
[10:24:42.632]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:42.632]             version = "1.8"), class = "FutureResult")
[10:24:42.632]     }, finally = {
[10:24:42.632]         if (!identical(...future.workdir, getwd())) 
[10:24:42.632]             setwd(...future.workdir)
[10:24:42.632]         {
[10:24:42.632]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:42.632]                 ...future.oldOptions$nwarnings <- NULL
[10:24:42.632]             }
[10:24:42.632]             base::options(...future.oldOptions)
[10:24:42.632]             if (.Platform$OS.type == "windows") {
[10:24:42.632]                 old_names <- names(...future.oldEnvVars)
[10:24:42.632]                 envs <- base::Sys.getenv()
[10:24:42.632]                 names <- names(envs)
[10:24:42.632]                 common <- intersect(names, old_names)
[10:24:42.632]                 added <- setdiff(names, old_names)
[10:24:42.632]                 removed <- setdiff(old_names, names)
[10:24:42.632]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:42.632]                   envs[common]]
[10:24:42.632]                 NAMES <- toupper(changed)
[10:24:42.632]                 args <- list()
[10:24:42.632]                 for (kk in seq_along(NAMES)) {
[10:24:42.632]                   name <- changed[[kk]]
[10:24:42.632]                   NAME <- NAMES[[kk]]
[10:24:42.632]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:42.632]                     next
[10:24:42.632]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:42.632]                 }
[10:24:42.632]                 NAMES <- toupper(added)
[10:24:42.632]                 for (kk in seq_along(NAMES)) {
[10:24:42.632]                   name <- added[[kk]]
[10:24:42.632]                   NAME <- NAMES[[kk]]
[10:24:42.632]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:42.632]                     next
[10:24:42.632]                   args[[name]] <- ""
[10:24:42.632]                 }
[10:24:42.632]                 NAMES <- toupper(removed)
[10:24:42.632]                 for (kk in seq_along(NAMES)) {
[10:24:42.632]                   name <- removed[[kk]]
[10:24:42.632]                   NAME <- NAMES[[kk]]
[10:24:42.632]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:42.632]                     next
[10:24:42.632]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:42.632]                 }
[10:24:42.632]                 if (length(args) > 0) 
[10:24:42.632]                   base::do.call(base::Sys.setenv, args = args)
[10:24:42.632]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:42.632]             }
[10:24:42.632]             else {
[10:24:42.632]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:42.632]             }
[10:24:42.632]             {
[10:24:42.632]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:42.632]                   0L) {
[10:24:42.632]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:42.632]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:42.632]                   base::options(opts)
[10:24:42.632]                 }
[10:24:42.632]                 {
[10:24:42.632]                   {
[10:24:42.632]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:42.632]                     NULL
[10:24:42.632]                   }
[10:24:42.632]                   options(future.plan = NULL)
[10:24:42.632]                   if (is.na(NA_character_)) 
[10:24:42.632]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:42.632]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:42.632]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:42.632]                     envir = parent.frame()) 
[10:24:42.632]                   {
[10:24:42.632]                     default_workers <- missing(workers)
[10:24:42.632]                     if (is.function(workers)) 
[10:24:42.632]                       workers <- workers()
[10:24:42.632]                     workers <- structure(as.integer(workers), 
[10:24:42.632]                       class = class(workers))
[10:24:42.632]                     stop_if_not(is.finite(workers), workers >= 
[10:24:42.632]                       1L)
[10:24:42.632]                     if ((workers == 1L && !inherits(workers, 
[10:24:42.632]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:42.632]                       if (default_workers) 
[10:24:42.632]                         supportsMulticore(warn = TRUE)
[10:24:42.632]                       return(sequential(..., envir = envir))
[10:24:42.632]                     }
[10:24:42.632]                     oopts <- options(mc.cores = workers)
[10:24:42.632]                     on.exit(options(oopts))
[10:24:42.632]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:42.632]                       envir = envir)
[10:24:42.632]                     if (!future$lazy) 
[10:24:42.632]                       future <- run(future)
[10:24:42.632]                     invisible(future)
[10:24:42.632]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:42.632]                 }
[10:24:42.632]             }
[10:24:42.632]         }
[10:24:42.632]     })
[10:24:42.632]     if (TRUE) {
[10:24:42.632]         base::sink(type = "output", split = FALSE)
[10:24:42.632]         if (FALSE) {
[10:24:42.632]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:42.632]         }
[10:24:42.632]         else {
[10:24:42.632]             ...future.result["stdout"] <- base::list(NULL)
[10:24:42.632]         }
[10:24:42.632]         base::close(...future.stdout)
[10:24:42.632]         ...future.stdout <- NULL
[10:24:42.632]     }
[10:24:42.632]     ...future.result$conditions <- ...future.conditions
[10:24:42.632]     ...future.result$finished <- base::Sys.time()
[10:24:42.632]     ...future.result
[10:24:42.632] }
[10:24:42.635] assign_globals() ...
[10:24:42.635] List of 5
[10:24:42.635]  $ ...future.FUN            :function (x, y)  
[10:24:42.635]  $ MoreArgs                 : NULL
[10:24:42.635]  $ ...future.elements_ii    :List of 2
[10:24:42.635]   ..$ :List of 1
[10:24:42.635]   .. ..$ : int 1
[10:24:42.635]   ..$ :List of 1
[10:24:42.635]   .. ..$ : int 0
[10:24:42.635]  $ ...future.seeds_ii       : NULL
[10:24:42.635]  $ ...future.globals.maxSize: NULL
[10:24:42.635]  - attr(*, "where")=List of 5
[10:24:42.635]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:42.635]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:24:42.635]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:42.635]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:42.635]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:42.635]  - attr(*, "resolved")= logi FALSE
[10:24:42.635]  - attr(*, "total_size")= num 6368
[10:24:42.635]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:42.635]  - attr(*, "already-done")= logi TRUE
[10:24:42.642] - reassign environment for ‘...future.FUN’
[10:24:42.642] - copied ‘...future.FUN’ to environment
[10:24:42.642] - copied ‘MoreArgs’ to environment
[10:24:42.642] - copied ‘...future.elements_ii’ to environment
[10:24:42.642] - copied ‘...future.seeds_ii’ to environment
[10:24:42.642] - copied ‘...future.globals.maxSize’ to environment
[10:24:42.643] assign_globals() ... done
[10:24:42.643] requestCore(): workers = 2
[10:24:42.645] MulticoreFuture started
[10:24:42.645] - Launch lazy future ... done
[10:24:42.646] run() for ‘MulticoreFuture’ ... done
[10:24:42.646] Created future:
[10:24:42.646] plan(): Setting new future strategy stack:
[10:24:42.646] List of future strategies:
[10:24:42.646] 1. sequential:
[10:24:42.646]    - args: function (..., envir = parent.frame())
[10:24:42.646]    - tweaked: FALSE
[10:24:42.646]    - call: NULL
[10:24:42.647] plan(): nbrOfWorkers() = 1
[10:24:42.646] MulticoreFuture:
[10:24:42.646] Label: ‘future_mapply-1’
[10:24:42.646] Expression:
[10:24:42.646] {
[10:24:42.646]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:42.646]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:42.646]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:42.646]         on.exit(options(oopts), add = TRUE)
[10:24:42.646]     }
[10:24:42.646]     {
[10:24:42.646]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:42.646]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:24:42.646]         do.call(mapply, args = args)
[10:24:42.646]     }
[10:24:42.646] }
[10:24:42.646] Lazy evaluation: FALSE
[10:24:42.646] Asynchronous evaluation: TRUE
[10:24:42.646] Local evaluation: TRUE
[10:24:42.646] Environment: R_GlobalEnv
[10:24:42.646] Capture standard output: FALSE
[10:24:42.646] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:42.646] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:42.646] Packages: <none>
[10:24:42.646] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:42.646] Resolved: FALSE
[10:24:42.646] Value: <not collected>
[10:24:42.646] Conditions captured: <none>
[10:24:42.646] Early signaling: FALSE
[10:24:42.646] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:42.646] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:42.659] Chunk #1 of 2 ... DONE
[10:24:42.659] Chunk #2 of 2 ...
[10:24:42.660]  - Finding globals in '...' for chunk #2 ...
[10:24:42.660] getGlobalsAndPackages() ...
[10:24:42.660] Searching for globals...
[10:24:42.661] 
[10:24:42.661] Searching for globals ... DONE
[10:24:42.661] - globals: [0] <none>
[10:24:42.661] getGlobalsAndPackages() ... DONE
[10:24:42.661]    + additional globals found: [n=0] 
[10:24:42.662]    + additional namespaces needed: [n=0] 
[10:24:42.662]  - Finding globals in '...' for chunk #2 ... DONE
[10:24:42.662]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:42.662]  - seeds: <none>
[10:24:42.662]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:42.662] getGlobalsAndPackages() ...
[10:24:42.663] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:42.663] Resolving globals: FALSE
[10:24:42.664] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[10:24:42.665] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:24:42.665] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:42.665] 
[10:24:42.665] getGlobalsAndPackages() ... DONE
[10:24:42.666] run() for ‘Future’ ...
[10:24:42.666] - state: ‘created’
[10:24:42.666] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:42.671] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:42.671] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:42.671]   - Field: ‘label’
[10:24:42.672]   - Field: ‘local’
[10:24:42.672]   - Field: ‘owner’
[10:24:42.672]   - Field: ‘envir’
[10:24:42.672]   - Field: ‘workers’
[10:24:42.672]   - Field: ‘packages’
[10:24:42.672]   - Field: ‘gc’
[10:24:42.672]   - Field: ‘job’
[10:24:42.673]   - Field: ‘conditions’
[10:24:42.673]   - Field: ‘expr’
[10:24:42.673]   - Field: ‘uuid’
[10:24:42.673]   - Field: ‘seed’
[10:24:42.673]   - Field: ‘version’
[10:24:42.673]   - Field: ‘result’
[10:24:42.674]   - Field: ‘asynchronous’
[10:24:42.674]   - Field: ‘calls’
[10:24:42.674]   - Field: ‘globals’
[10:24:42.674]   - Field: ‘stdout’
[10:24:42.674]   - Field: ‘earlySignal’
[10:24:42.674]   - Field: ‘lazy’
[10:24:42.674]   - Field: ‘state’
[10:24:42.675] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:42.675] - Launch lazy future ...
[10:24:42.675] Packages needed by the future expression (n = 0): <none>
[10:24:42.675] Packages needed by future strategies (n = 0): <none>
[10:24:42.676] {
[10:24:42.676]     {
[10:24:42.676]         {
[10:24:42.676]             ...future.startTime <- base::Sys.time()
[10:24:42.676]             {
[10:24:42.676]                 {
[10:24:42.676]                   {
[10:24:42.676]                     {
[10:24:42.676]                       base::local({
[10:24:42.676]                         has_future <- base::requireNamespace("future", 
[10:24:42.676]                           quietly = TRUE)
[10:24:42.676]                         if (has_future) {
[10:24:42.676]                           ns <- base::getNamespace("future")
[10:24:42.676]                           version <- ns[[".package"]][["version"]]
[10:24:42.676]                           if (is.null(version)) 
[10:24:42.676]                             version <- utils::packageVersion("future")
[10:24:42.676]                         }
[10:24:42.676]                         else {
[10:24:42.676]                           version <- NULL
[10:24:42.676]                         }
[10:24:42.676]                         if (!has_future || version < "1.8.0") {
[10:24:42.676]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:42.676]                             "", base::R.version$version.string), 
[10:24:42.676]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:42.676]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:42.676]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:42.676]                               "release", "version")], collapse = " "), 
[10:24:42.676]                             hostname = base::Sys.info()[["nodename"]])
[10:24:42.676]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:42.676]                             info)
[10:24:42.676]                           info <- base::paste(info, collapse = "; ")
[10:24:42.676]                           if (!has_future) {
[10:24:42.676]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:42.676]                               info)
[10:24:42.676]                           }
[10:24:42.676]                           else {
[10:24:42.676]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:42.676]                               info, version)
[10:24:42.676]                           }
[10:24:42.676]                           base::stop(msg)
[10:24:42.676]                         }
[10:24:42.676]                       })
[10:24:42.676]                     }
[10:24:42.676]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:42.676]                     base::options(mc.cores = 1L)
[10:24:42.676]                   }
[10:24:42.676]                   options(future.plan = NULL)
[10:24:42.676]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:42.676]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:42.676]                 }
[10:24:42.676]                 ...future.workdir <- getwd()
[10:24:42.676]             }
[10:24:42.676]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:42.676]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:42.676]         }
[10:24:42.676]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:42.676]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:42.676]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:42.676]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:42.676]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:42.676]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:42.676]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:42.676]             base::names(...future.oldOptions))
[10:24:42.676]     }
[10:24:42.676]     if (FALSE) {
[10:24:42.676]     }
[10:24:42.676]     else {
[10:24:42.676]         if (FALSE) {
[10:24:42.676]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:42.676]                 open = "w")
[10:24:42.676]         }
[10:24:42.676]         else {
[10:24:42.676]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:42.676]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:42.676]         }
[10:24:42.676]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:42.676]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:42.676]             base::sink(type = "output", split = FALSE)
[10:24:42.676]             base::close(...future.stdout)
[10:24:42.676]         }, add = TRUE)
[10:24:42.676]     }
[10:24:42.676]     ...future.frame <- base::sys.nframe()
[10:24:42.676]     ...future.conditions <- base::list()
[10:24:42.676]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:42.676]     if (FALSE) {
[10:24:42.676]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:42.676]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:42.676]     }
[10:24:42.676]     ...future.result <- base::tryCatch({
[10:24:42.676]         base::withCallingHandlers({
[10:24:42.676]             ...future.value <- base::withVisible(base::local({
[10:24:42.676]                 withCallingHandlers({
[10:24:42.676]                   {
[10:24:42.676]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:42.676]                     if (!identical(...future.globals.maxSize.org, 
[10:24:42.676]                       ...future.globals.maxSize)) {
[10:24:42.676]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:42.676]                       on.exit(options(oopts), add = TRUE)
[10:24:42.676]                     }
[10:24:42.676]                     {
[10:24:42.676]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:42.676]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:24:42.676]                         USE.NAMES = FALSE)
[10:24:42.676]                       do.call(mapply, args = args)
[10:24:42.676]                     }
[10:24:42.676]                   }
[10:24:42.676]                 }, immediateCondition = function(cond) {
[10:24:42.676]                   save_rds <- function (object, pathname, ...) 
[10:24:42.676]                   {
[10:24:42.676]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:42.676]                     if (file_test("-f", pathname_tmp)) {
[10:24:42.676]                       fi_tmp <- file.info(pathname_tmp)
[10:24:42.676]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:42.676]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:42.676]                         fi_tmp[["mtime"]])
[10:24:42.676]                     }
[10:24:42.676]                     tryCatch({
[10:24:42.676]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:42.676]                     }, error = function(ex) {
[10:24:42.676]                       msg <- conditionMessage(ex)
[10:24:42.676]                       fi_tmp <- file.info(pathname_tmp)
[10:24:42.676]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:42.676]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:42.676]                         fi_tmp[["mtime"]], msg)
[10:24:42.676]                       ex$message <- msg
[10:24:42.676]                       stop(ex)
[10:24:42.676]                     })
[10:24:42.676]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:42.676]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:42.676]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:42.676]                       fi_tmp <- file.info(pathname_tmp)
[10:24:42.676]                       fi <- file.info(pathname)
[10:24:42.676]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:42.676]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:42.676]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:42.676]                         fi[["size"]], fi[["mtime"]])
[10:24:42.676]                       stop(msg)
[10:24:42.676]                     }
[10:24:42.676]                     invisible(pathname)
[10:24:42.676]                   }
[10:24:42.676]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:42.676]                     rootPath = tempdir()) 
[10:24:42.676]                   {
[10:24:42.676]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:42.676]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:42.676]                       tmpdir = path, fileext = ".rds")
[10:24:42.676]                     save_rds(obj, file)
[10:24:42.676]                   }
[10:24:42.676]                   saveImmediateCondition(cond, path = "/tmp/Rtmp5boaqN/.future/immediateConditions")
[10:24:42.676]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:42.676]                   {
[10:24:42.676]                     inherits <- base::inherits
[10:24:42.676]                     invokeRestart <- base::invokeRestart
[10:24:42.676]                     is.null <- base::is.null
[10:24:42.676]                     muffled <- FALSE
[10:24:42.676]                     if (inherits(cond, "message")) {
[10:24:42.676]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:42.676]                       if (muffled) 
[10:24:42.676]                         invokeRestart("muffleMessage")
[10:24:42.676]                     }
[10:24:42.676]                     else if (inherits(cond, "warning")) {
[10:24:42.676]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:42.676]                       if (muffled) 
[10:24:42.676]                         invokeRestart("muffleWarning")
[10:24:42.676]                     }
[10:24:42.676]                     else if (inherits(cond, "condition")) {
[10:24:42.676]                       if (!is.null(pattern)) {
[10:24:42.676]                         computeRestarts <- base::computeRestarts
[10:24:42.676]                         grepl <- base::grepl
[10:24:42.676]                         restarts <- computeRestarts(cond)
[10:24:42.676]                         for (restart in restarts) {
[10:24:42.676]                           name <- restart$name
[10:24:42.676]                           if (is.null(name)) 
[10:24:42.676]                             next
[10:24:42.676]                           if (!grepl(pattern, name)) 
[10:24:42.676]                             next
[10:24:42.676]                           invokeRestart(restart)
[10:24:42.676]                           muffled <- TRUE
[10:24:42.676]                           break
[10:24:42.676]                         }
[10:24:42.676]                       }
[10:24:42.676]                     }
[10:24:42.676]                     invisible(muffled)
[10:24:42.676]                   }
[10:24:42.676]                   muffleCondition(cond)
[10:24:42.676]                 })
[10:24:42.676]             }))
[10:24:42.676]             future::FutureResult(value = ...future.value$value, 
[10:24:42.676]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:42.676]                   ...future.rng), globalenv = if (FALSE) 
[10:24:42.676]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:42.676]                     ...future.globalenv.names))
[10:24:42.676]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:42.676]         }, condition = base::local({
[10:24:42.676]             c <- base::c
[10:24:42.676]             inherits <- base::inherits
[10:24:42.676]             invokeRestart <- base::invokeRestart
[10:24:42.676]             length <- base::length
[10:24:42.676]             list <- base::list
[10:24:42.676]             seq.int <- base::seq.int
[10:24:42.676]             signalCondition <- base::signalCondition
[10:24:42.676]             sys.calls <- base::sys.calls
[10:24:42.676]             `[[` <- base::`[[`
[10:24:42.676]             `+` <- base::`+`
[10:24:42.676]             `<<-` <- base::`<<-`
[10:24:42.676]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:42.676]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:42.676]                   3L)]
[10:24:42.676]             }
[10:24:42.676]             function(cond) {
[10:24:42.676]                 is_error <- inherits(cond, "error")
[10:24:42.676]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:42.676]                   NULL)
[10:24:42.676]                 if (is_error) {
[10:24:42.676]                   sessionInformation <- function() {
[10:24:42.676]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:42.676]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:42.676]                       search = base::search(), system = base::Sys.info())
[10:24:42.676]                   }
[10:24:42.676]                   ...future.conditions[[length(...future.conditions) + 
[10:24:42.676]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:42.676]                     cond$call), session = sessionInformation(), 
[10:24:42.676]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:42.676]                   signalCondition(cond)
[10:24:42.676]                 }
[10:24:42.676]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:42.676]                 "immediateCondition"))) {
[10:24:42.676]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:42.676]                   ...future.conditions[[length(...future.conditions) + 
[10:24:42.676]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:42.676]                   if (TRUE && !signal) {
[10:24:42.676]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:42.676]                     {
[10:24:42.676]                       inherits <- base::inherits
[10:24:42.676]                       invokeRestart <- base::invokeRestart
[10:24:42.676]                       is.null <- base::is.null
[10:24:42.676]                       muffled <- FALSE
[10:24:42.676]                       if (inherits(cond, "message")) {
[10:24:42.676]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:42.676]                         if (muffled) 
[10:24:42.676]                           invokeRestart("muffleMessage")
[10:24:42.676]                       }
[10:24:42.676]                       else if (inherits(cond, "warning")) {
[10:24:42.676]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:42.676]                         if (muffled) 
[10:24:42.676]                           invokeRestart("muffleWarning")
[10:24:42.676]                       }
[10:24:42.676]                       else if (inherits(cond, "condition")) {
[10:24:42.676]                         if (!is.null(pattern)) {
[10:24:42.676]                           computeRestarts <- base::computeRestarts
[10:24:42.676]                           grepl <- base::grepl
[10:24:42.676]                           restarts <- computeRestarts(cond)
[10:24:42.676]                           for (restart in restarts) {
[10:24:42.676]                             name <- restart$name
[10:24:42.676]                             if (is.null(name)) 
[10:24:42.676]                               next
[10:24:42.676]                             if (!grepl(pattern, name)) 
[10:24:42.676]                               next
[10:24:42.676]                             invokeRestart(restart)
[10:24:42.676]                             muffled <- TRUE
[10:24:42.676]                             break
[10:24:42.676]                           }
[10:24:42.676]                         }
[10:24:42.676]                       }
[10:24:42.676]                       invisible(muffled)
[10:24:42.676]                     }
[10:24:42.676]                     muffleCondition(cond, pattern = "^muffle")
[10:24:42.676]                   }
[10:24:42.676]                 }
[10:24:42.676]                 else {
[10:24:42.676]                   if (TRUE) {
[10:24:42.676]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:42.676]                     {
[10:24:42.676]                       inherits <- base::inherits
[10:24:42.676]                       invokeRestart <- base::invokeRestart
[10:24:42.676]                       is.null <- base::is.null
[10:24:42.676]                       muffled <- FALSE
[10:24:42.676]                       if (inherits(cond, "message")) {
[10:24:42.676]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:42.676]                         if (muffled) 
[10:24:42.676]                           invokeRestart("muffleMessage")
[10:24:42.676]                       }
[10:24:42.676]                       else if (inherits(cond, "warning")) {
[10:24:42.676]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:42.676]                         if (muffled) 
[10:24:42.676]                           invokeRestart("muffleWarning")
[10:24:42.676]                       }
[10:24:42.676]                       else if (inherits(cond, "condition")) {
[10:24:42.676]                         if (!is.null(pattern)) {
[10:24:42.676]                           computeRestarts <- base::computeRestarts
[10:24:42.676]                           grepl <- base::grepl
[10:24:42.676]                           restarts <- computeRestarts(cond)
[10:24:42.676]                           for (restart in restarts) {
[10:24:42.676]                             name <- restart$name
[10:24:42.676]                             if (is.null(name)) 
[10:24:42.676]                               next
[10:24:42.676]                             if (!grepl(pattern, name)) 
[10:24:42.676]                               next
[10:24:42.676]                             invokeRestart(restart)
[10:24:42.676]                             muffled <- TRUE
[10:24:42.676]                             break
[10:24:42.676]                           }
[10:24:42.676]                         }
[10:24:42.676]                       }
[10:24:42.676]                       invisible(muffled)
[10:24:42.676]                     }
[10:24:42.676]                     muffleCondition(cond, pattern = "^muffle")
[10:24:42.676]                   }
[10:24:42.676]                 }
[10:24:42.676]             }
[10:24:42.676]         }))
[10:24:42.676]     }, error = function(ex) {
[10:24:42.676]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:42.676]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:42.676]                 ...future.rng), started = ...future.startTime, 
[10:24:42.676]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:42.676]             version = "1.8"), class = "FutureResult")
[10:24:42.676]     }, finally = {
[10:24:42.676]         if (!identical(...future.workdir, getwd())) 
[10:24:42.676]             setwd(...future.workdir)
[10:24:42.676]         {
[10:24:42.676]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:42.676]                 ...future.oldOptions$nwarnings <- NULL
[10:24:42.676]             }
[10:24:42.676]             base::options(...future.oldOptions)
[10:24:42.676]             if (.Platform$OS.type == "windows") {
[10:24:42.676]                 old_names <- names(...future.oldEnvVars)
[10:24:42.676]                 envs <- base::Sys.getenv()
[10:24:42.676]                 names <- names(envs)
[10:24:42.676]                 common <- intersect(names, old_names)
[10:24:42.676]                 added <- setdiff(names, old_names)
[10:24:42.676]                 removed <- setdiff(old_names, names)
[10:24:42.676]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:42.676]                   envs[common]]
[10:24:42.676]                 NAMES <- toupper(changed)
[10:24:42.676]                 args <- list()
[10:24:42.676]                 for (kk in seq_along(NAMES)) {
[10:24:42.676]                   name <- changed[[kk]]
[10:24:42.676]                   NAME <- NAMES[[kk]]
[10:24:42.676]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:42.676]                     next
[10:24:42.676]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:42.676]                 }
[10:24:42.676]                 NAMES <- toupper(added)
[10:24:42.676]                 for (kk in seq_along(NAMES)) {
[10:24:42.676]                   name <- added[[kk]]
[10:24:42.676]                   NAME <- NAMES[[kk]]
[10:24:42.676]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:42.676]                     next
[10:24:42.676]                   args[[name]] <- ""
[10:24:42.676]                 }
[10:24:42.676]                 NAMES <- toupper(removed)
[10:24:42.676]                 for (kk in seq_along(NAMES)) {
[10:24:42.676]                   name <- removed[[kk]]
[10:24:42.676]                   NAME <- NAMES[[kk]]
[10:24:42.676]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:42.676]                     next
[10:24:42.676]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:42.676]                 }
[10:24:42.676]                 if (length(args) > 0) 
[10:24:42.676]                   base::do.call(base::Sys.setenv, args = args)
[10:24:42.676]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:42.676]             }
[10:24:42.676]             else {
[10:24:42.676]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:42.676]             }
[10:24:42.676]             {
[10:24:42.676]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:42.676]                   0L) {
[10:24:42.676]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:42.676]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:42.676]                   base::options(opts)
[10:24:42.676]                 }
[10:24:42.676]                 {
[10:24:42.676]                   {
[10:24:42.676]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:42.676]                     NULL
[10:24:42.676]                   }
[10:24:42.676]                   options(future.plan = NULL)
[10:24:42.676]                   if (is.na(NA_character_)) 
[10:24:42.676]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:42.676]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:42.676]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:42.676]                     envir = parent.frame()) 
[10:24:42.676]                   {
[10:24:42.676]                     default_workers <- missing(workers)
[10:24:42.676]                     if (is.function(workers)) 
[10:24:42.676]                       workers <- workers()
[10:24:42.676]                     workers <- structure(as.integer(workers), 
[10:24:42.676]                       class = class(workers))
[10:24:42.676]                     stop_if_not(is.finite(workers), workers >= 
[10:24:42.676]                       1L)
[10:24:42.676]                     if ((workers == 1L && !inherits(workers, 
[10:24:42.676]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:42.676]                       if (default_workers) 
[10:24:42.676]                         supportsMulticore(warn = TRUE)
[10:24:42.676]                       return(sequential(..., envir = envir))
[10:24:42.676]                     }
[10:24:42.676]                     oopts <- options(mc.cores = workers)
[10:24:42.676]                     on.exit(options(oopts))
[10:24:42.676]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:42.676]                       envir = envir)
[10:24:42.676]                     if (!future$lazy) 
[10:24:42.676]                       future <- run(future)
[10:24:42.676]                     invisible(future)
[10:24:42.676]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:42.676]                 }
[10:24:42.676]             }
[10:24:42.676]         }
[10:24:42.676]     })
[10:24:42.676]     if (TRUE) {
[10:24:42.676]         base::sink(type = "output", split = FALSE)
[10:24:42.676]         if (FALSE) {
[10:24:42.676]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:42.676]         }
[10:24:42.676]         else {
[10:24:42.676]             ...future.result["stdout"] <- base::list(NULL)
[10:24:42.676]         }
[10:24:42.676]         base::close(...future.stdout)
[10:24:42.676]         ...future.stdout <- NULL
[10:24:42.676]     }
[10:24:42.676]     ...future.result$conditions <- ...future.conditions
[10:24:42.676]     ...future.result$finished <- base::Sys.time()
[10:24:42.676]     ...future.result
[10:24:42.676] }
[10:24:42.680] assign_globals() ...
[10:24:42.680] List of 5
[10:24:42.680]  $ ...future.FUN            :function (x, y)  
[10:24:42.680]  $ MoreArgs                 : NULL
[10:24:42.680]  $ ...future.elements_ii    :List of 2
[10:24:42.680]   ..$ :List of 1
[10:24:42.680]   .. ..$ : int 0
[10:24:42.680]   ..$ :List of 1
[10:24:42.680]   .. ..$ : int 1
[10:24:42.680]  $ ...future.seeds_ii       : NULL
[10:24:42.680]  $ ...future.globals.maxSize: NULL
[10:24:42.680]  - attr(*, "where")=List of 5
[10:24:42.680]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:42.680]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:24:42.680]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:42.680]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:42.680]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:42.680]  - attr(*, "resolved")= logi FALSE
[10:24:42.680]  - attr(*, "total_size")= num 6368
[10:24:42.680]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:42.680]  - attr(*, "already-done")= logi TRUE
[10:24:42.688] - reassign environment for ‘...future.FUN’
[10:24:42.688] - copied ‘...future.FUN’ to environment
[10:24:42.688] - copied ‘MoreArgs’ to environment
[10:24:42.690] - copied ‘...future.elements_ii’ to environment
[10:24:42.691] - copied ‘...future.seeds_ii’ to environment
[10:24:42.691] - copied ‘...future.globals.maxSize’ to environment
[10:24:42.691] assign_globals() ... done
[10:24:42.692] requestCore(): workers = 2
[10:24:42.694] MulticoreFuture started
[10:24:42.695] - Launch lazy future ... done
[10:24:42.696] run() for ‘MulticoreFuture’ ... done
[10:24:42.696] plan(): Setting new future strategy stack:
[10:24:42.696] Created future:
[10:24:42.696] List of future strategies:
[10:24:42.696] 1. sequential:
[10:24:42.696]    - args: function (..., envir = parent.frame())
[10:24:42.696]    - tweaked: FALSE
[10:24:42.696]    - call: NULL
[10:24:42.698] plan(): nbrOfWorkers() = 1
[10:24:42.700] plan(): Setting new future strategy stack:
[10:24:42.700] List of future strategies:
[10:24:42.700] 1. multicore:
[10:24:42.700]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:42.700]    - tweaked: FALSE
[10:24:42.700]    - call: plan(strategy)
[10:24:42.706] plan(): nbrOfWorkers() = 2
[10:24:42.697] MulticoreFuture:
[10:24:42.697] Label: ‘future_mapply-2’
[10:24:42.697] Expression:
[10:24:42.697] {
[10:24:42.697]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:42.697]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:42.697]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:42.697]         on.exit(options(oopts), add = TRUE)
[10:24:42.697]     }
[10:24:42.697]     {
[10:24:42.697]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:42.697]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:24:42.697]         do.call(mapply, args = args)
[10:24:42.697]     }
[10:24:42.697] }
[10:24:42.697] Lazy evaluation: FALSE
[10:24:42.697] Asynchronous evaluation: TRUE
[10:24:42.697] Local evaluation: TRUE
[10:24:42.697] Environment: R_GlobalEnv
[10:24:42.697] Capture standard output: FALSE
[10:24:42.697] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:42.697] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:42.697] Packages: <none>
[10:24:42.697] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:42.697] Resolved: TRUE
[10:24:42.697] Value: <not collected>
[10:24:42.697] Conditions captured: <none>
[10:24:42.697] Early signaling: FALSE
[10:24:42.697] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:42.697] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:42.707] Chunk #2 of 2 ... DONE
[10:24:42.707] Launching 2 futures (chunks) ... DONE
[10:24:42.707] Resolving 2 futures (chunks) ...
[10:24:42.708] resolve() on list ...
[10:24:42.708]  recursive: 0
[10:24:42.708]  length: 2
[10:24:42.708] 
[10:24:42.719] Future #2
[10:24:42.719] result() for MulticoreFuture ...
[10:24:42.720] result() for MulticoreFuture ...
[10:24:42.721] result() for MulticoreFuture ... done
[10:24:42.721] result() for MulticoreFuture ... done
[10:24:42.721] result() for MulticoreFuture ...
[10:24:42.721] result() for MulticoreFuture ... done
[10:24:42.721] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:24:42.722] - nx: 2
[10:24:42.722] - relay: TRUE
[10:24:42.722] - stdout: TRUE
[10:24:42.722] - signal: TRUE
[10:24:42.722] - resignal: FALSE
[10:24:42.722] - force: TRUE
[10:24:42.722] - relayed: [n=2] FALSE, FALSE
[10:24:42.723] - queued futures: [n=2] FALSE, FALSE
[10:24:42.723]  - until=1
[10:24:42.723]  - relaying element #1
[10:24:42.723] - relayed: [n=2] FALSE, FALSE
[10:24:42.723] - queued futures: [n=2] FALSE, TRUE
[10:24:42.723] signalConditionsASAP(NULL, pos=2) ... done
[10:24:42.723]  length: 1 (resolved future 2)
[10:24:43.150] plan(): Setting new future strategy stack:
[10:24:43.150] List of future strategies:
[10:24:43.150] 1. multicore:
[10:24:43.150]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:43.150]    - tweaked: FALSE
[10:24:43.150]    - call: plan(strategy)
[10:24:43.155] plan(): nbrOfWorkers() = 2
[10:24:43.161] Future #1
[10:24:43.161] result() for MulticoreFuture ...
[10:24:43.162] result() for MulticoreFuture ...
[10:24:43.162] result() for MulticoreFuture ... done
[10:24:43.163] result() for MulticoreFuture ... done
[10:24:43.163] result() for MulticoreFuture ...
[10:24:43.163] result() for MulticoreFuture ... done
[10:24:43.163] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:24:43.163] - nx: 2
[10:24:43.163] - relay: TRUE
[10:24:43.164] - stdout: TRUE
[10:24:43.164] - signal: TRUE
[10:24:43.164] - resignal: FALSE
[10:24:43.164] - force: TRUE
[10:24:43.164] - relayed: [n=2] FALSE, FALSE
[10:24:43.164] - queued futures: [n=2] FALSE, TRUE
[10:24:43.165]  - until=1
[10:24:43.165]  - relaying element #1
[10:24:43.165] result() for MulticoreFuture ...
[10:24:43.165] result() for MulticoreFuture ... done
[10:24:43.165] result() for MulticoreFuture ...
[10:24:43.165] result() for MulticoreFuture ... done
[10:24:43.165] result() for MulticoreFuture ...
[10:24:43.166] result() for MulticoreFuture ... done
[10:24:43.166] result() for MulticoreFuture ...
[10:24:43.166] result() for MulticoreFuture ... done
[10:24:43.166] - relayed: [n=2] TRUE, FALSE
[10:24:43.166] - queued futures: [n=2] TRUE, TRUE
[10:24:43.166] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:24:43.167]  length: 0 (resolved future 1)
[10:24:43.167] Relaying remaining futures
[10:24:43.167] signalConditionsASAP(NULL, pos=0) ...
[10:24:43.167] - nx: 2
[10:24:43.167] - relay: TRUE
[10:24:43.167] - stdout: TRUE
[10:24:43.167] - signal: TRUE
[10:24:43.168] - resignal: FALSE
[10:24:43.168] - force: TRUE
[10:24:43.168] - relayed: [n=2] TRUE, FALSE
[10:24:43.168] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:43.168]  - relaying element #2
[10:24:43.168] result() for MulticoreFuture ...
[10:24:43.168] result() for MulticoreFuture ... done
[10:24:43.168] result() for MulticoreFuture ...
[10:24:43.169] result() for MulticoreFuture ... done
[10:24:43.169] result() for MulticoreFuture ...
[10:24:43.169] result() for MulticoreFuture ... done
[10:24:43.169] result() for MulticoreFuture ...
[10:24:43.169] result() for MulticoreFuture ... done
[10:24:43.169] - relayed: [n=2] TRUE, TRUE
[10:24:43.169] - queued futures: [n=2] TRUE, TRUE
[10:24:43.169] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[10:24:43.169] resolve() on list ... DONE
[10:24:43.170] result() for MulticoreFuture ...
[10:24:43.170] result() for MulticoreFuture ... done
[10:24:43.170] result() for MulticoreFuture ...
[10:24:43.170] result() for MulticoreFuture ... done
[10:24:43.170] result() for MulticoreFuture ...
[10:24:43.170] result() for MulticoreFuture ... done
[10:24:43.170] result() for MulticoreFuture ...
[10:24:43.170] result() for MulticoreFuture ... done
[10:24:43.171]  - Number of value chunks collected: 2
[10:24:43.171] Resolving 2 futures (chunks) ... DONE
[10:24:43.171] Reducing values from 2 chunks ...
[10:24:43.171]  - Number of values collected after concatenation: 2
[10:24:43.171]  - Number of values expected: 2
[10:24:43.171] Reducing values from 2 chunks ... DONE
[10:24:43.171] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[10:24:43.172] future_mapply() ...
[10:24:43.176] Number of chunks: 2
[10:24:43.176] getGlobalsAndPackagesXApply() ...
[10:24:43.176]  - future.globals: TRUE
[10:24:43.176] getGlobalsAndPackages() ...
[10:24:43.177] Searching for globals...
[10:24:43.179] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:24:43.179] Searching for globals ... DONE
[10:24:43.179] Resolving globals: FALSE
[10:24:43.179] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[10:24:43.180] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[10:24:43.180] - globals: [1] ‘FUN’
[10:24:43.180] 
[10:24:43.180] getGlobalsAndPackages() ... DONE
[10:24:43.180]  - globals found/used: [n=1] ‘FUN’
[10:24:43.180]  - needed namespaces: [n=0] 
[10:24:43.181] Finding globals ... DONE
[10:24:43.181] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:24:43.181] List of 2
[10:24:43.181]  $ ...future.FUN:function (x, y)  
[10:24:43.181]  $ MoreArgs     : NULL
[10:24:43.181]  - attr(*, "where")=List of 2
[10:24:43.181]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:43.181]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:24:43.181]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:43.181]  - attr(*, "resolved")= logi FALSE
[10:24:43.181]  - attr(*, "total_size")= num NA
[10:24:43.186] Packages to be attached in all futures: [n=0] 
[10:24:43.186] getGlobalsAndPackagesXApply() ... DONE
[10:24:43.186] Number of futures (= number of chunks): 2
[10:24:43.186] Launching 2 futures (chunks) ...
[10:24:43.186] Chunk #1 of 2 ...
[10:24:43.187]  - Finding globals in '...' for chunk #1 ...
[10:24:43.187] getGlobalsAndPackages() ...
[10:24:43.187] Searching for globals...
[10:24:43.187] 
[10:24:43.187] Searching for globals ... DONE
[10:24:43.187] - globals: [0] <none>
[10:24:43.187] getGlobalsAndPackages() ... DONE
[10:24:43.188]    + additional globals found: [n=0] 
[10:24:43.188]    + additional namespaces needed: [n=0] 
[10:24:43.188]  - Finding globals in '...' for chunk #1 ... DONE
[10:24:43.188]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:43.188]  - seeds: <none>
[10:24:43.188]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:43.188] getGlobalsAndPackages() ...
[10:24:43.188] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:43.188] Resolving globals: FALSE
[10:24:43.189] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[10:24:43.189] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:24:43.189] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:43.190] 
[10:24:43.190] getGlobalsAndPackages() ... DONE
[10:24:43.190] run() for ‘Future’ ...
[10:24:43.190] - state: ‘created’
[10:24:43.190] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:43.194] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:43.194] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:43.194]   - Field: ‘label’
[10:24:43.194]   - Field: ‘local’
[10:24:43.194]   - Field: ‘owner’
[10:24:43.194]   - Field: ‘envir’
[10:24:43.194]   - Field: ‘workers’
[10:24:43.194]   - Field: ‘packages’
[10:24:43.195]   - Field: ‘gc’
[10:24:43.195]   - Field: ‘job’
[10:24:43.195]   - Field: ‘conditions’
[10:24:43.195]   - Field: ‘expr’
[10:24:43.195]   - Field: ‘uuid’
[10:24:43.195]   - Field: ‘seed’
[10:24:43.195]   - Field: ‘version’
[10:24:43.195]   - Field: ‘result’
[10:24:43.195]   - Field: ‘asynchronous’
[10:24:43.195]   - Field: ‘calls’
[10:24:43.196]   - Field: ‘globals’
[10:24:43.196]   - Field: ‘stdout’
[10:24:43.196]   - Field: ‘earlySignal’
[10:24:43.196]   - Field: ‘lazy’
[10:24:43.196]   - Field: ‘state’
[10:24:43.196] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:43.196] - Launch lazy future ...
[10:24:43.196] Packages needed by the future expression (n = 0): <none>
[10:24:43.196] Packages needed by future strategies (n = 0): <none>
[10:24:43.197] {
[10:24:43.197]     {
[10:24:43.197]         {
[10:24:43.197]             ...future.startTime <- base::Sys.time()
[10:24:43.197]             {
[10:24:43.197]                 {
[10:24:43.197]                   {
[10:24:43.197]                     {
[10:24:43.197]                       base::local({
[10:24:43.197]                         has_future <- base::requireNamespace("future", 
[10:24:43.197]                           quietly = TRUE)
[10:24:43.197]                         if (has_future) {
[10:24:43.197]                           ns <- base::getNamespace("future")
[10:24:43.197]                           version <- ns[[".package"]][["version"]]
[10:24:43.197]                           if (is.null(version)) 
[10:24:43.197]                             version <- utils::packageVersion("future")
[10:24:43.197]                         }
[10:24:43.197]                         else {
[10:24:43.197]                           version <- NULL
[10:24:43.197]                         }
[10:24:43.197]                         if (!has_future || version < "1.8.0") {
[10:24:43.197]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:43.197]                             "", base::R.version$version.string), 
[10:24:43.197]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:43.197]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:43.197]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:43.197]                               "release", "version")], collapse = " "), 
[10:24:43.197]                             hostname = base::Sys.info()[["nodename"]])
[10:24:43.197]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:43.197]                             info)
[10:24:43.197]                           info <- base::paste(info, collapse = "; ")
[10:24:43.197]                           if (!has_future) {
[10:24:43.197]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:43.197]                               info)
[10:24:43.197]                           }
[10:24:43.197]                           else {
[10:24:43.197]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:43.197]                               info, version)
[10:24:43.197]                           }
[10:24:43.197]                           base::stop(msg)
[10:24:43.197]                         }
[10:24:43.197]                       })
[10:24:43.197]                     }
[10:24:43.197]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:43.197]                     base::options(mc.cores = 1L)
[10:24:43.197]                   }
[10:24:43.197]                   options(future.plan = NULL)
[10:24:43.197]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:43.197]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:43.197]                 }
[10:24:43.197]                 ...future.workdir <- getwd()
[10:24:43.197]             }
[10:24:43.197]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:43.197]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:43.197]         }
[10:24:43.197]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:43.197]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:43.197]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:43.197]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:43.197]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:43.197]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:43.197]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:43.197]             base::names(...future.oldOptions))
[10:24:43.197]     }
[10:24:43.197]     if (FALSE) {
[10:24:43.197]     }
[10:24:43.197]     else {
[10:24:43.197]         if (TRUE) {
[10:24:43.197]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:43.197]                 open = "w")
[10:24:43.197]         }
[10:24:43.197]         else {
[10:24:43.197]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:43.197]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:43.197]         }
[10:24:43.197]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:43.197]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:43.197]             base::sink(type = "output", split = FALSE)
[10:24:43.197]             base::close(...future.stdout)
[10:24:43.197]         }, add = TRUE)
[10:24:43.197]     }
[10:24:43.197]     ...future.frame <- base::sys.nframe()
[10:24:43.197]     ...future.conditions <- base::list()
[10:24:43.197]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:43.197]     if (FALSE) {
[10:24:43.197]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:43.197]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:43.197]     }
[10:24:43.197]     ...future.result <- base::tryCatch({
[10:24:43.197]         base::withCallingHandlers({
[10:24:43.197]             ...future.value <- base::withVisible(base::local({
[10:24:43.197]                 withCallingHandlers({
[10:24:43.197]                   {
[10:24:43.197]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:43.197]                     if (!identical(...future.globals.maxSize.org, 
[10:24:43.197]                       ...future.globals.maxSize)) {
[10:24:43.197]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:43.197]                       on.exit(options(oopts), add = TRUE)
[10:24:43.197]                     }
[10:24:43.197]                     {
[10:24:43.197]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:43.197]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:24:43.197]                         USE.NAMES = FALSE)
[10:24:43.197]                       do.call(mapply, args = args)
[10:24:43.197]                     }
[10:24:43.197]                   }
[10:24:43.197]                 }, immediateCondition = function(cond) {
[10:24:43.197]                   save_rds <- function (object, pathname, ...) 
[10:24:43.197]                   {
[10:24:43.197]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:43.197]                     if (file_test("-f", pathname_tmp)) {
[10:24:43.197]                       fi_tmp <- file.info(pathname_tmp)
[10:24:43.197]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:43.197]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:43.197]                         fi_tmp[["mtime"]])
[10:24:43.197]                     }
[10:24:43.197]                     tryCatch({
[10:24:43.197]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:43.197]                     }, error = function(ex) {
[10:24:43.197]                       msg <- conditionMessage(ex)
[10:24:43.197]                       fi_tmp <- file.info(pathname_tmp)
[10:24:43.197]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:43.197]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:43.197]                         fi_tmp[["mtime"]], msg)
[10:24:43.197]                       ex$message <- msg
[10:24:43.197]                       stop(ex)
[10:24:43.197]                     })
[10:24:43.197]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:43.197]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:43.197]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:43.197]                       fi_tmp <- file.info(pathname_tmp)
[10:24:43.197]                       fi <- file.info(pathname)
[10:24:43.197]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:43.197]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:43.197]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:43.197]                         fi[["size"]], fi[["mtime"]])
[10:24:43.197]                       stop(msg)
[10:24:43.197]                     }
[10:24:43.197]                     invisible(pathname)
[10:24:43.197]                   }
[10:24:43.197]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:43.197]                     rootPath = tempdir()) 
[10:24:43.197]                   {
[10:24:43.197]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:43.197]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:43.197]                       tmpdir = path, fileext = ".rds")
[10:24:43.197]                     save_rds(obj, file)
[10:24:43.197]                   }
[10:24:43.197]                   saveImmediateCondition(cond, path = "/tmp/Rtmp5boaqN/.future/immediateConditions")
[10:24:43.197]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:43.197]                   {
[10:24:43.197]                     inherits <- base::inherits
[10:24:43.197]                     invokeRestart <- base::invokeRestart
[10:24:43.197]                     is.null <- base::is.null
[10:24:43.197]                     muffled <- FALSE
[10:24:43.197]                     if (inherits(cond, "message")) {
[10:24:43.197]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:43.197]                       if (muffled) 
[10:24:43.197]                         invokeRestart("muffleMessage")
[10:24:43.197]                     }
[10:24:43.197]                     else if (inherits(cond, "warning")) {
[10:24:43.197]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:43.197]                       if (muffled) 
[10:24:43.197]                         invokeRestart("muffleWarning")
[10:24:43.197]                     }
[10:24:43.197]                     else if (inherits(cond, "condition")) {
[10:24:43.197]                       if (!is.null(pattern)) {
[10:24:43.197]                         computeRestarts <- base::computeRestarts
[10:24:43.197]                         grepl <- base::grepl
[10:24:43.197]                         restarts <- computeRestarts(cond)
[10:24:43.197]                         for (restart in restarts) {
[10:24:43.197]                           name <- restart$name
[10:24:43.197]                           if (is.null(name)) 
[10:24:43.197]                             next
[10:24:43.197]                           if (!grepl(pattern, name)) 
[10:24:43.197]                             next
[10:24:43.197]                           invokeRestart(restart)
[10:24:43.197]                           muffled <- TRUE
[10:24:43.197]                           break
[10:24:43.197]                         }
[10:24:43.197]                       }
[10:24:43.197]                     }
[10:24:43.197]                     invisible(muffled)
[10:24:43.197]                   }
[10:24:43.197]                   muffleCondition(cond)
[10:24:43.197]                 })
[10:24:43.197]             }))
[10:24:43.197]             future::FutureResult(value = ...future.value$value, 
[10:24:43.197]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:43.197]                   ...future.rng), globalenv = if (FALSE) 
[10:24:43.197]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:43.197]                     ...future.globalenv.names))
[10:24:43.197]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:43.197]         }, condition = base::local({
[10:24:43.197]             c <- base::c
[10:24:43.197]             inherits <- base::inherits
[10:24:43.197]             invokeRestart <- base::invokeRestart
[10:24:43.197]             length <- base::length
[10:24:43.197]             list <- base::list
[10:24:43.197]             seq.int <- base::seq.int
[10:24:43.197]             signalCondition <- base::signalCondition
[10:24:43.197]             sys.calls <- base::sys.calls
[10:24:43.197]             `[[` <- base::`[[`
[10:24:43.197]             `+` <- base::`+`
[10:24:43.197]             `<<-` <- base::`<<-`
[10:24:43.197]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:43.197]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:43.197]                   3L)]
[10:24:43.197]             }
[10:24:43.197]             function(cond) {
[10:24:43.197]                 is_error <- inherits(cond, "error")
[10:24:43.197]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:43.197]                   NULL)
[10:24:43.197]                 if (is_error) {
[10:24:43.197]                   sessionInformation <- function() {
[10:24:43.197]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:43.197]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:43.197]                       search = base::search(), system = base::Sys.info())
[10:24:43.197]                   }
[10:24:43.197]                   ...future.conditions[[length(...future.conditions) + 
[10:24:43.197]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:43.197]                     cond$call), session = sessionInformation(), 
[10:24:43.197]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:43.197]                   signalCondition(cond)
[10:24:43.197]                 }
[10:24:43.197]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:43.197]                 "immediateCondition"))) {
[10:24:43.197]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:43.197]                   ...future.conditions[[length(...future.conditions) + 
[10:24:43.197]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:43.197]                   if (TRUE && !signal) {
[10:24:43.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:43.197]                     {
[10:24:43.197]                       inherits <- base::inherits
[10:24:43.197]                       invokeRestart <- base::invokeRestart
[10:24:43.197]                       is.null <- base::is.null
[10:24:43.197]                       muffled <- FALSE
[10:24:43.197]                       if (inherits(cond, "message")) {
[10:24:43.197]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:43.197]                         if (muffled) 
[10:24:43.197]                           invokeRestart("muffleMessage")
[10:24:43.197]                       }
[10:24:43.197]                       else if (inherits(cond, "warning")) {
[10:24:43.197]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:43.197]                         if (muffled) 
[10:24:43.197]                           invokeRestart("muffleWarning")
[10:24:43.197]                       }
[10:24:43.197]                       else if (inherits(cond, "condition")) {
[10:24:43.197]                         if (!is.null(pattern)) {
[10:24:43.197]                           computeRestarts <- base::computeRestarts
[10:24:43.197]                           grepl <- base::grepl
[10:24:43.197]                           restarts <- computeRestarts(cond)
[10:24:43.197]                           for (restart in restarts) {
[10:24:43.197]                             name <- restart$name
[10:24:43.197]                             if (is.null(name)) 
[10:24:43.197]                               next
[10:24:43.197]                             if (!grepl(pattern, name)) 
[10:24:43.197]                               next
[10:24:43.197]                             invokeRestart(restart)
[10:24:43.197]                             muffled <- TRUE
[10:24:43.197]                             break
[10:24:43.197]                           }
[10:24:43.197]                         }
[10:24:43.197]                       }
[10:24:43.197]                       invisible(muffled)
[10:24:43.197]                     }
[10:24:43.197]                     muffleCondition(cond, pattern = "^muffle")
[10:24:43.197]                   }
[10:24:43.197]                 }
[10:24:43.197]                 else {
[10:24:43.197]                   if (TRUE) {
[10:24:43.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:43.197]                     {
[10:24:43.197]                       inherits <- base::inherits
[10:24:43.197]                       invokeRestart <- base::invokeRestart
[10:24:43.197]                       is.null <- base::is.null
[10:24:43.197]                       muffled <- FALSE
[10:24:43.197]                       if (inherits(cond, "message")) {
[10:24:43.197]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:43.197]                         if (muffled) 
[10:24:43.197]                           invokeRestart("muffleMessage")
[10:24:43.197]                       }
[10:24:43.197]                       else if (inherits(cond, "warning")) {
[10:24:43.197]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:43.197]                         if (muffled) 
[10:24:43.197]                           invokeRestart("muffleWarning")
[10:24:43.197]                       }
[10:24:43.197]                       else if (inherits(cond, "condition")) {
[10:24:43.197]                         if (!is.null(pattern)) {
[10:24:43.197]                           computeRestarts <- base::computeRestarts
[10:24:43.197]                           grepl <- base::grepl
[10:24:43.197]                           restarts <- computeRestarts(cond)
[10:24:43.197]                           for (restart in restarts) {
[10:24:43.197]                             name <- restart$name
[10:24:43.197]                             if (is.null(name)) 
[10:24:43.197]                               next
[10:24:43.197]                             if (!grepl(pattern, name)) 
[10:24:43.197]                               next
[10:24:43.197]                             invokeRestart(restart)
[10:24:43.197]                             muffled <- TRUE
[10:24:43.197]                             break
[10:24:43.197]                           }
[10:24:43.197]                         }
[10:24:43.197]                       }
[10:24:43.197]                       invisible(muffled)
[10:24:43.197]                     }
[10:24:43.197]                     muffleCondition(cond, pattern = "^muffle")
[10:24:43.197]                   }
[10:24:43.197]                 }
[10:24:43.197]             }
[10:24:43.197]         }))
[10:24:43.197]     }, error = function(ex) {
[10:24:43.197]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:43.197]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:43.197]                 ...future.rng), started = ...future.startTime, 
[10:24:43.197]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:43.197]             version = "1.8"), class = "FutureResult")
[10:24:43.197]     }, finally = {
[10:24:43.197]         if (!identical(...future.workdir, getwd())) 
[10:24:43.197]             setwd(...future.workdir)
[10:24:43.197]         {
[10:24:43.197]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:43.197]                 ...future.oldOptions$nwarnings <- NULL
[10:24:43.197]             }
[10:24:43.197]             base::options(...future.oldOptions)
[10:24:43.197]             if (.Platform$OS.type == "windows") {
[10:24:43.197]                 old_names <- names(...future.oldEnvVars)
[10:24:43.197]                 envs <- base::Sys.getenv()
[10:24:43.197]                 names <- names(envs)
[10:24:43.197]                 common <- intersect(names, old_names)
[10:24:43.197]                 added <- setdiff(names, old_names)
[10:24:43.197]                 removed <- setdiff(old_names, names)
[10:24:43.197]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:43.197]                   envs[common]]
[10:24:43.197]                 NAMES <- toupper(changed)
[10:24:43.197]                 args <- list()
[10:24:43.197]                 for (kk in seq_along(NAMES)) {
[10:24:43.197]                   name <- changed[[kk]]
[10:24:43.197]                   NAME <- NAMES[[kk]]
[10:24:43.197]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:43.197]                     next
[10:24:43.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:43.197]                 }
[10:24:43.197]                 NAMES <- toupper(added)
[10:24:43.197]                 for (kk in seq_along(NAMES)) {
[10:24:43.197]                   name <- added[[kk]]
[10:24:43.197]                   NAME <- NAMES[[kk]]
[10:24:43.197]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:43.197]                     next
[10:24:43.197]                   args[[name]] <- ""
[10:24:43.197]                 }
[10:24:43.197]                 NAMES <- toupper(removed)
[10:24:43.197]                 for (kk in seq_along(NAMES)) {
[10:24:43.197]                   name <- removed[[kk]]
[10:24:43.197]                   NAME <- NAMES[[kk]]
[10:24:43.197]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:43.197]                     next
[10:24:43.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:43.197]                 }
[10:24:43.197]                 if (length(args) > 0) 
[10:24:43.197]                   base::do.call(base::Sys.setenv, args = args)
[10:24:43.197]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:43.197]             }
[10:24:43.197]             else {
[10:24:43.197]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:43.197]             }
[10:24:43.197]             {
[10:24:43.197]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:43.197]                   0L) {
[10:24:43.197]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:43.197]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:43.197]                   base::options(opts)
[10:24:43.197]                 }
[10:24:43.197]                 {
[10:24:43.197]                   {
[10:24:43.197]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:43.197]                     NULL
[10:24:43.197]                   }
[10:24:43.197]                   options(future.plan = NULL)
[10:24:43.197]                   if (is.na(NA_character_)) 
[10:24:43.197]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:43.197]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:43.197]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:43.197]                     envir = parent.frame()) 
[10:24:43.197]                   {
[10:24:43.197]                     default_workers <- missing(workers)
[10:24:43.197]                     if (is.function(workers)) 
[10:24:43.197]                       workers <- workers()
[10:24:43.197]                     workers <- structure(as.integer(workers), 
[10:24:43.197]                       class = class(workers))
[10:24:43.197]                     stop_if_not(is.finite(workers), workers >= 
[10:24:43.197]                       1L)
[10:24:43.197]                     if ((workers == 1L && !inherits(workers, 
[10:24:43.197]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:43.197]                       if (default_workers) 
[10:24:43.197]                         supportsMulticore(warn = TRUE)
[10:24:43.197]                       return(sequential(..., envir = envir))
[10:24:43.197]                     }
[10:24:43.197]                     oopts <- options(mc.cores = workers)
[10:24:43.197]                     on.exit(options(oopts))
[10:24:43.197]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:43.197]                       envir = envir)
[10:24:43.197]                     if (!future$lazy) 
[10:24:43.197]                       future <- run(future)
[10:24:43.197]                     invisible(future)
[10:24:43.197]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:43.197]                 }
[10:24:43.197]             }
[10:24:43.197]         }
[10:24:43.197]     })
[10:24:43.197]     if (TRUE) {
[10:24:43.197]         base::sink(type = "output", split = FALSE)
[10:24:43.197]         if (TRUE) {
[10:24:43.197]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:43.197]         }
[10:24:43.197]         else {
[10:24:43.197]             ...future.result["stdout"] <- base::list(NULL)
[10:24:43.197]         }
[10:24:43.197]         base::close(...future.stdout)
[10:24:43.197]         ...future.stdout <- NULL
[10:24:43.197]     }
[10:24:43.197]     ...future.result$conditions <- ...future.conditions
[10:24:43.197]     ...future.result$finished <- base::Sys.time()
[10:24:43.197]     ...future.result
[10:24:43.197] }
[10:24:43.200] assign_globals() ...
[10:24:43.200] List of 5
[10:24:43.200]  $ ...future.FUN            :function (x, y)  
[10:24:43.200]  $ MoreArgs                 : NULL
[10:24:43.200]  $ ...future.elements_ii    :List of 2
[10:24:43.200]   ..$ :List of 1
[10:24:43.200]   .. ..$ : int 1
[10:24:43.200]   ..$ :List of 1
[10:24:43.200]   .. ..$ : int 0
[10:24:43.200]  $ ...future.seeds_ii       : NULL
[10:24:43.200]  $ ...future.globals.maxSize: NULL
[10:24:43.200]  - attr(*, "where")=List of 5
[10:24:43.200]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:43.200]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:24:43.200]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:43.200]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:43.200]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:43.200]  - attr(*, "resolved")= logi FALSE
[10:24:43.200]  - attr(*, "total_size")= num 6368
[10:24:43.200]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:43.200]  - attr(*, "already-done")= logi TRUE
[10:24:43.205] - reassign environment for ‘...future.FUN’
[10:24:43.205] - copied ‘...future.FUN’ to environment
[10:24:43.205] - copied ‘MoreArgs’ to environment
[10:24:43.205] - copied ‘...future.elements_ii’ to environment
[10:24:43.205] - copied ‘...future.seeds_ii’ to environment
[10:24:43.205] - copied ‘...future.globals.maxSize’ to environment
[10:24:43.205] assign_globals() ... done
[10:24:43.205] requestCore(): workers = 2
[10:24:43.208] MulticoreFuture started
[10:24:43.208] - Launch lazy future ... done
[10:24:43.208] run() for ‘MulticoreFuture’ ... done
[10:24:43.209] Created future:
[10:24:43.209] plan(): Setting new future strategy stack:
[10:24:43.209] List of future strategies:
[10:24:43.209] 1. sequential:
[10:24:43.209]    - args: function (..., envir = parent.frame())
[10:24:43.209]    - tweaked: FALSE
[10:24:43.209]    - call: NULL
[10:24:43.210] plan(): nbrOfWorkers() = 1
[10:24:43.209] MulticoreFuture:
[10:24:43.209] Label: ‘future_mapply-1’
[10:24:43.209] Expression:
[10:24:43.209] {
[10:24:43.209]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:43.209]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:43.209]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:43.209]         on.exit(options(oopts), add = TRUE)
[10:24:43.209]     }
[10:24:43.209]     {
[10:24:43.209]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:43.209]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:24:43.209]         do.call(mapply, args = args)
[10:24:43.209]     }
[10:24:43.209] }
[10:24:43.209] Lazy evaluation: FALSE
[10:24:43.209] Asynchronous evaluation: TRUE
[10:24:43.209] Local evaluation: TRUE
[10:24:43.209] Environment: R_GlobalEnv
[10:24:43.209] Capture standard output: TRUE
[10:24:43.209] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:43.209] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:43.209] Packages: <none>
[10:24:43.209] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:43.209] Resolved: FALSE
[10:24:43.209] Value: <not collected>
[10:24:43.209] Conditions captured: <none>
[10:24:43.209] Early signaling: FALSE
[10:24:43.209] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:43.209] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:43.221] Chunk #1 of 2 ... DONE
[10:24:43.222] Chunk #2 of 2 ...
[10:24:43.222]  - Finding globals in '...' for chunk #2 ...
[10:24:43.222] getGlobalsAndPackages() ...
[10:24:43.222] Searching for globals...
[10:24:43.223] 
[10:24:43.223] Searching for globals ... DONE
[10:24:43.223] - globals: [0] <none>
[10:24:43.223] getGlobalsAndPackages() ... DONE
[10:24:43.223]    + additional globals found: [n=0] 
[10:24:43.224]    + additional namespaces needed: [n=0] 
[10:24:43.224]  - Finding globals in '...' for chunk #2 ... DONE
[10:24:43.237]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:43.237]  - seeds: <none>
[10:24:43.237]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:43.237] getGlobalsAndPackages() ...
[10:24:43.237] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:43.237] Resolving globals: FALSE
[10:24:43.238] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[10:24:43.239] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:24:43.239] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:43.239] 
[10:24:43.239] getGlobalsAndPackages() ... DONE
[10:24:43.240] run() for ‘Future’ ...
[10:24:43.240] - state: ‘created’
[10:24:43.240] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:43.246] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:43.246] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:43.246]   - Field: ‘label’
[10:24:43.246]   - Field: ‘local’
[10:24:43.246]   - Field: ‘owner’
[10:24:43.246]   - Field: ‘envir’
[10:24:43.247]   - Field: ‘workers’
[10:24:43.247]   - Field: ‘packages’
[10:24:43.247]   - Field: ‘gc’
[10:24:43.247]   - Field: ‘job’
[10:24:43.247]   - Field: ‘conditions’
[10:24:43.247]   - Field: ‘expr’
[10:24:43.248]   - Field: ‘uuid’
[10:24:43.248]   - Field: ‘seed’
[10:24:43.248]   - Field: ‘version’
[10:24:43.248]   - Field: ‘result’
[10:24:43.248]   - Field: ‘asynchronous’
[10:24:43.248]   - Field: ‘calls’
[10:24:43.248]   - Field: ‘globals’
[10:24:43.249]   - Field: ‘stdout’
[10:24:43.249]   - Field: ‘earlySignal’
[10:24:43.249]   - Field: ‘lazy’
[10:24:43.249]   - Field: ‘state’
[10:24:43.249] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:43.249] - Launch lazy future ...
[10:24:43.250] Packages needed by the future expression (n = 0): <none>
[10:24:43.250] Packages needed by future strategies (n = 0): <none>
[10:24:43.250] {
[10:24:43.250]     {
[10:24:43.250]         {
[10:24:43.250]             ...future.startTime <- base::Sys.time()
[10:24:43.250]             {
[10:24:43.250]                 {
[10:24:43.250]                   {
[10:24:43.250]                     {
[10:24:43.250]                       base::local({
[10:24:43.250]                         has_future <- base::requireNamespace("future", 
[10:24:43.250]                           quietly = TRUE)
[10:24:43.250]                         if (has_future) {
[10:24:43.250]                           ns <- base::getNamespace("future")
[10:24:43.250]                           version <- ns[[".package"]][["version"]]
[10:24:43.250]                           if (is.null(version)) 
[10:24:43.250]                             version <- utils::packageVersion("future")
[10:24:43.250]                         }
[10:24:43.250]                         else {
[10:24:43.250]                           version <- NULL
[10:24:43.250]                         }
[10:24:43.250]                         if (!has_future || version < "1.8.0") {
[10:24:43.250]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:43.250]                             "", base::R.version$version.string), 
[10:24:43.250]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:43.250]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:43.250]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:43.250]                               "release", "version")], collapse = " "), 
[10:24:43.250]                             hostname = base::Sys.info()[["nodename"]])
[10:24:43.250]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:43.250]                             info)
[10:24:43.250]                           info <- base::paste(info, collapse = "; ")
[10:24:43.250]                           if (!has_future) {
[10:24:43.250]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:43.250]                               info)
[10:24:43.250]                           }
[10:24:43.250]                           else {
[10:24:43.250]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:43.250]                               info, version)
[10:24:43.250]                           }
[10:24:43.250]                           base::stop(msg)
[10:24:43.250]                         }
[10:24:43.250]                       })
[10:24:43.250]                     }
[10:24:43.250]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:43.250]                     base::options(mc.cores = 1L)
[10:24:43.250]                   }
[10:24:43.250]                   options(future.plan = NULL)
[10:24:43.250]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:43.250]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:43.250]                 }
[10:24:43.250]                 ...future.workdir <- getwd()
[10:24:43.250]             }
[10:24:43.250]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:43.250]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:43.250]         }
[10:24:43.250]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:43.250]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:43.250]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:43.250]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:43.250]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:43.250]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:43.250]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:43.250]             base::names(...future.oldOptions))
[10:24:43.250]     }
[10:24:43.250]     if (FALSE) {
[10:24:43.250]     }
[10:24:43.250]     else {
[10:24:43.250]         if (TRUE) {
[10:24:43.250]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:43.250]                 open = "w")
[10:24:43.250]         }
[10:24:43.250]         else {
[10:24:43.250]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:43.250]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:43.250]         }
[10:24:43.250]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:43.250]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:43.250]             base::sink(type = "output", split = FALSE)
[10:24:43.250]             base::close(...future.stdout)
[10:24:43.250]         }, add = TRUE)
[10:24:43.250]     }
[10:24:43.250]     ...future.frame <- base::sys.nframe()
[10:24:43.250]     ...future.conditions <- base::list()
[10:24:43.250]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:43.250]     if (FALSE) {
[10:24:43.250]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:43.250]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:43.250]     }
[10:24:43.250]     ...future.result <- base::tryCatch({
[10:24:43.250]         base::withCallingHandlers({
[10:24:43.250]             ...future.value <- base::withVisible(base::local({
[10:24:43.250]                 withCallingHandlers({
[10:24:43.250]                   {
[10:24:43.250]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:43.250]                     if (!identical(...future.globals.maxSize.org, 
[10:24:43.250]                       ...future.globals.maxSize)) {
[10:24:43.250]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:43.250]                       on.exit(options(oopts), add = TRUE)
[10:24:43.250]                     }
[10:24:43.250]                     {
[10:24:43.250]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:43.250]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:24:43.250]                         USE.NAMES = FALSE)
[10:24:43.250]                       do.call(mapply, args = args)
[10:24:43.250]                     }
[10:24:43.250]                   }
[10:24:43.250]                 }, immediateCondition = function(cond) {
[10:24:43.250]                   save_rds <- function (object, pathname, ...) 
[10:24:43.250]                   {
[10:24:43.250]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:43.250]                     if (file_test("-f", pathname_tmp)) {
[10:24:43.250]                       fi_tmp <- file.info(pathname_tmp)
[10:24:43.250]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:43.250]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:43.250]                         fi_tmp[["mtime"]])
[10:24:43.250]                     }
[10:24:43.250]                     tryCatch({
[10:24:43.250]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:43.250]                     }, error = function(ex) {
[10:24:43.250]                       msg <- conditionMessage(ex)
[10:24:43.250]                       fi_tmp <- file.info(pathname_tmp)
[10:24:43.250]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:43.250]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:43.250]                         fi_tmp[["mtime"]], msg)
[10:24:43.250]                       ex$message <- msg
[10:24:43.250]                       stop(ex)
[10:24:43.250]                     })
[10:24:43.250]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:43.250]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:43.250]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:43.250]                       fi_tmp <- file.info(pathname_tmp)
[10:24:43.250]                       fi <- file.info(pathname)
[10:24:43.250]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:43.250]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:43.250]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:43.250]                         fi[["size"]], fi[["mtime"]])
[10:24:43.250]                       stop(msg)
[10:24:43.250]                     }
[10:24:43.250]                     invisible(pathname)
[10:24:43.250]                   }
[10:24:43.250]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:43.250]                     rootPath = tempdir()) 
[10:24:43.250]                   {
[10:24:43.250]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:43.250]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:43.250]                       tmpdir = path, fileext = ".rds")
[10:24:43.250]                     save_rds(obj, file)
[10:24:43.250]                   }
[10:24:43.250]                   saveImmediateCondition(cond, path = "/tmp/Rtmp5boaqN/.future/immediateConditions")
[10:24:43.250]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:43.250]                   {
[10:24:43.250]                     inherits <- base::inherits
[10:24:43.250]                     invokeRestart <- base::invokeRestart
[10:24:43.250]                     is.null <- base::is.null
[10:24:43.250]                     muffled <- FALSE
[10:24:43.250]                     if (inherits(cond, "message")) {
[10:24:43.250]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:43.250]                       if (muffled) 
[10:24:43.250]                         invokeRestart("muffleMessage")
[10:24:43.250]                     }
[10:24:43.250]                     else if (inherits(cond, "warning")) {
[10:24:43.250]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:43.250]                       if (muffled) 
[10:24:43.250]                         invokeRestart("muffleWarning")
[10:24:43.250]                     }
[10:24:43.250]                     else if (inherits(cond, "condition")) {
[10:24:43.250]                       if (!is.null(pattern)) {
[10:24:43.250]                         computeRestarts <- base::computeRestarts
[10:24:43.250]                         grepl <- base::grepl
[10:24:43.250]                         restarts <- computeRestarts(cond)
[10:24:43.250]                         for (restart in restarts) {
[10:24:43.250]                           name <- restart$name
[10:24:43.250]                           if (is.null(name)) 
[10:24:43.250]                             next
[10:24:43.250]                           if (!grepl(pattern, name)) 
[10:24:43.250]                             next
[10:24:43.250]                           invokeRestart(restart)
[10:24:43.250]                           muffled <- TRUE
[10:24:43.250]                           break
[10:24:43.250]                         }
[10:24:43.250]                       }
[10:24:43.250]                     }
[10:24:43.250]                     invisible(muffled)
[10:24:43.250]                   }
[10:24:43.250]                   muffleCondition(cond)
[10:24:43.250]                 })
[10:24:43.250]             }))
[10:24:43.250]             future::FutureResult(value = ...future.value$value, 
[10:24:43.250]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:43.250]                   ...future.rng), globalenv = if (FALSE) 
[10:24:43.250]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:43.250]                     ...future.globalenv.names))
[10:24:43.250]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:43.250]         }, condition = base::local({
[10:24:43.250]             c <- base::c
[10:24:43.250]             inherits <- base::inherits
[10:24:43.250]             invokeRestart <- base::invokeRestart
[10:24:43.250]             length <- base::length
[10:24:43.250]             list <- base::list
[10:24:43.250]             seq.int <- base::seq.int
[10:24:43.250]             signalCondition <- base::signalCondition
[10:24:43.250]             sys.calls <- base::sys.calls
[10:24:43.250]             `[[` <- base::`[[`
[10:24:43.250]             `+` <- base::`+`
[10:24:43.250]             `<<-` <- base::`<<-`
[10:24:43.250]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:43.250]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:43.250]                   3L)]
[10:24:43.250]             }
[10:24:43.250]             function(cond) {
[10:24:43.250]                 is_error <- inherits(cond, "error")
[10:24:43.250]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:43.250]                   NULL)
[10:24:43.250]                 if (is_error) {
[10:24:43.250]                   sessionInformation <- function() {
[10:24:43.250]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:43.250]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:43.250]                       search = base::search(), system = base::Sys.info())
[10:24:43.250]                   }
[10:24:43.250]                   ...future.conditions[[length(...future.conditions) + 
[10:24:43.250]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:43.250]                     cond$call), session = sessionInformation(), 
[10:24:43.250]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:43.250]                   signalCondition(cond)
[10:24:43.250]                 }
[10:24:43.250]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:43.250]                 "immediateCondition"))) {
[10:24:43.250]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:43.250]                   ...future.conditions[[length(...future.conditions) + 
[10:24:43.250]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:43.250]                   if (TRUE && !signal) {
[10:24:43.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:43.250]                     {
[10:24:43.250]                       inherits <- base::inherits
[10:24:43.250]                       invokeRestart <- base::invokeRestart
[10:24:43.250]                       is.null <- base::is.null
[10:24:43.250]                       muffled <- FALSE
[10:24:43.250]                       if (inherits(cond, "message")) {
[10:24:43.250]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:43.250]                         if (muffled) 
[10:24:43.250]                           invokeRestart("muffleMessage")
[10:24:43.250]                       }
[10:24:43.250]                       else if (inherits(cond, "warning")) {
[10:24:43.250]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:43.250]                         if (muffled) 
[10:24:43.250]                           invokeRestart("muffleWarning")
[10:24:43.250]                       }
[10:24:43.250]                       else if (inherits(cond, "condition")) {
[10:24:43.250]                         if (!is.null(pattern)) {
[10:24:43.250]                           computeRestarts <- base::computeRestarts
[10:24:43.250]                           grepl <- base::grepl
[10:24:43.250]                           restarts <- computeRestarts(cond)
[10:24:43.250]                           for (restart in restarts) {
[10:24:43.250]                             name <- restart$name
[10:24:43.250]                             if (is.null(name)) 
[10:24:43.250]                               next
[10:24:43.250]                             if (!grepl(pattern, name)) 
[10:24:43.250]                               next
[10:24:43.250]                             invokeRestart(restart)
[10:24:43.250]                             muffled <- TRUE
[10:24:43.250]                             break
[10:24:43.250]                           }
[10:24:43.250]                         }
[10:24:43.250]                       }
[10:24:43.250]                       invisible(muffled)
[10:24:43.250]                     }
[10:24:43.250]                     muffleCondition(cond, pattern = "^muffle")
[10:24:43.250]                   }
[10:24:43.250]                 }
[10:24:43.250]                 else {
[10:24:43.250]                   if (TRUE) {
[10:24:43.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:43.250]                     {
[10:24:43.250]                       inherits <- base::inherits
[10:24:43.250]                       invokeRestart <- base::invokeRestart
[10:24:43.250]                       is.null <- base::is.null
[10:24:43.250]                       muffled <- FALSE
[10:24:43.250]                       if (inherits(cond, "message")) {
[10:24:43.250]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:43.250]                         if (muffled) 
[10:24:43.250]                           invokeRestart("muffleMessage")
[10:24:43.250]                       }
[10:24:43.250]                       else if (inherits(cond, "warning")) {
[10:24:43.250]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:43.250]                         if (muffled) 
[10:24:43.250]                           invokeRestart("muffleWarning")
[10:24:43.250]                       }
[10:24:43.250]                       else if (inherits(cond, "condition")) {
[10:24:43.250]                         if (!is.null(pattern)) {
[10:24:43.250]                           computeRestarts <- base::computeRestarts
[10:24:43.250]                           grepl <- base::grepl
[10:24:43.250]                           restarts <- computeRestarts(cond)
[10:24:43.250]                           for (restart in restarts) {
[10:24:43.250]                             name <- restart$name
[10:24:43.250]                             if (is.null(name)) 
[10:24:43.250]                               next
[10:24:43.250]                             if (!grepl(pattern, name)) 
[10:24:43.250]                               next
[10:24:43.250]                             invokeRestart(restart)
[10:24:43.250]                             muffled <- TRUE
[10:24:43.250]                             break
[10:24:43.250]                           }
[10:24:43.250]                         }
[10:24:43.250]                       }
[10:24:43.250]                       invisible(muffled)
[10:24:43.250]                     }
[10:24:43.250]                     muffleCondition(cond, pattern = "^muffle")
[10:24:43.250]                   }
[10:24:43.250]                 }
[10:24:43.250]             }
[10:24:43.250]         }))
[10:24:43.250]     }, error = function(ex) {
[10:24:43.250]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:43.250]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:43.250]                 ...future.rng), started = ...future.startTime, 
[10:24:43.250]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:43.250]             version = "1.8"), class = "FutureResult")
[10:24:43.250]     }, finally = {
[10:24:43.250]         if (!identical(...future.workdir, getwd())) 
[10:24:43.250]             setwd(...future.workdir)
[10:24:43.250]         {
[10:24:43.250]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:43.250]                 ...future.oldOptions$nwarnings <- NULL
[10:24:43.250]             }
[10:24:43.250]             base::options(...future.oldOptions)
[10:24:43.250]             if (.Platform$OS.type == "windows") {
[10:24:43.250]                 old_names <- names(...future.oldEnvVars)
[10:24:43.250]                 envs <- base::Sys.getenv()
[10:24:43.250]                 names <- names(envs)
[10:24:43.250]                 common <- intersect(names, old_names)
[10:24:43.250]                 added <- setdiff(names, old_names)
[10:24:43.250]                 removed <- setdiff(old_names, names)
[10:24:43.250]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:43.250]                   envs[common]]
[10:24:43.250]                 NAMES <- toupper(changed)
[10:24:43.250]                 args <- list()
[10:24:43.250]                 for (kk in seq_along(NAMES)) {
[10:24:43.250]                   name <- changed[[kk]]
[10:24:43.250]                   NAME <- NAMES[[kk]]
[10:24:43.250]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:43.250]                     next
[10:24:43.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:43.250]                 }
[10:24:43.250]                 NAMES <- toupper(added)
[10:24:43.250]                 for (kk in seq_along(NAMES)) {
[10:24:43.250]                   name <- added[[kk]]
[10:24:43.250]                   NAME <- NAMES[[kk]]
[10:24:43.250]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:43.250]                     next
[10:24:43.250]                   args[[name]] <- ""
[10:24:43.250]                 }
[10:24:43.250]                 NAMES <- toupper(removed)
[10:24:43.250]                 for (kk in seq_along(NAMES)) {
[10:24:43.250]                   name <- removed[[kk]]
[10:24:43.250]                   NAME <- NAMES[[kk]]
[10:24:43.250]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:43.250]                     next
[10:24:43.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:43.250]                 }
[10:24:43.250]                 if (length(args) > 0) 
[10:24:43.250]                   base::do.call(base::Sys.setenv, args = args)
[10:24:43.250]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:43.250]             }
[10:24:43.250]             else {
[10:24:43.250]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:43.250]             }
[10:24:43.250]             {
[10:24:43.250]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:43.250]                   0L) {
[10:24:43.250]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:43.250]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:43.250]                   base::options(opts)
[10:24:43.250]                 }
[10:24:43.250]                 {
[10:24:43.250]                   {
[10:24:43.250]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:43.250]                     NULL
[10:24:43.250]                   }
[10:24:43.250]                   options(future.plan = NULL)
[10:24:43.250]                   if (is.na(NA_character_)) 
[10:24:43.250]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:43.250]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:43.250]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:43.250]                     envir = parent.frame()) 
[10:24:43.250]                   {
[10:24:43.250]                     default_workers <- missing(workers)
[10:24:43.250]                     if (is.function(workers)) 
[10:24:43.250]                       workers <- workers()
[10:24:43.250]                     workers <- structure(as.integer(workers), 
[10:24:43.250]                       class = class(workers))
[10:24:43.250]                     stop_if_not(is.finite(workers), workers >= 
[10:24:43.250]                       1L)
[10:24:43.250]                     if ((workers == 1L && !inherits(workers, 
[10:24:43.250]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:43.250]                       if (default_workers) 
[10:24:43.250]                         supportsMulticore(warn = TRUE)
[10:24:43.250]                       return(sequential(..., envir = envir))
[10:24:43.250]                     }
[10:24:43.250]                     oopts <- options(mc.cores = workers)
[10:24:43.250]                     on.exit(options(oopts))
[10:24:43.250]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:43.250]                       envir = envir)
[10:24:43.250]                     if (!future$lazy) 
[10:24:43.250]                       future <- run(future)
[10:24:43.250]                     invisible(future)
[10:24:43.250]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:43.250]                 }
[10:24:43.250]             }
[10:24:43.250]         }
[10:24:43.250]     })
[10:24:43.250]     if (TRUE) {
[10:24:43.250]         base::sink(type = "output", split = FALSE)
[10:24:43.250]         if (TRUE) {
[10:24:43.250]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:43.250]         }
[10:24:43.250]         else {
[10:24:43.250]             ...future.result["stdout"] <- base::list(NULL)
[10:24:43.250]         }
[10:24:43.250]         base::close(...future.stdout)
[10:24:43.250]         ...future.stdout <- NULL
[10:24:43.250]     }
[10:24:43.250]     ...future.result$conditions <- ...future.conditions
[10:24:43.250]     ...future.result$finished <- base::Sys.time()
[10:24:43.250]     ...future.result
[10:24:43.250] }
[10:24:43.253] assign_globals() ...
[10:24:43.253] List of 5
[10:24:43.253]  $ ...future.FUN            :function (x, y)  
[10:24:43.253]  $ MoreArgs                 : NULL
[10:24:43.253]  $ ...future.elements_ii    :List of 2
[10:24:43.253]   ..$ :List of 1
[10:24:43.253]   .. ..$ : int 0
[10:24:43.253]   ..$ :List of 1
[10:24:43.253]   .. ..$ : int 1
[10:24:43.253]  $ ...future.seeds_ii       : NULL
[10:24:43.253]  $ ...future.globals.maxSize: NULL
[10:24:43.253]  - attr(*, "where")=List of 5
[10:24:43.253]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:43.253]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:24:43.253]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:43.253]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:43.253]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:43.253]  - attr(*, "resolved")= logi FALSE
[10:24:43.253]  - attr(*, "total_size")= num 6368
[10:24:43.253]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:43.253]  - attr(*, "already-done")= logi TRUE
[10:24:43.260] - reassign environment for ‘...future.FUN’
[10:24:43.260] - copied ‘...future.FUN’ to environment
[10:24:43.260] - copied ‘MoreArgs’ to environment
[10:24:43.260] - copied ‘...future.elements_ii’ to environment
[10:24:43.260] - copied ‘...future.seeds_ii’ to environment
[10:24:43.260] - copied ‘...future.globals.maxSize’ to environment
[10:24:43.261] assign_globals() ... done
[10:24:43.261] requestCore(): workers = 2
[10:24:43.263] MulticoreFuture started
[10:24:43.263] - Launch lazy future ... done
[10:24:43.264] run() for ‘MulticoreFuture’ ... done
[10:24:43.264] Created future:
[10:24:43.264] plan(): Setting new future strategy stack:
[10:24:43.265] List of future strategies:
[10:24:43.265] 1. sequential:
[10:24:43.265]    - args: function (..., envir = parent.frame())
[10:24:43.265]    - tweaked: FALSE
[10:24:43.265]    - call: NULL
[10:24:43.265] plan(): nbrOfWorkers() = 1
[10:24:43.268] plan(): Setting new future strategy stack:
[10:24:43.268] List of future strategies:
[10:24:43.268] 1. multicore:
[10:24:43.268]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:43.268]    - tweaked: FALSE
[10:24:43.268]    - call: plan(strategy)
[10:24:43.273] plan(): nbrOfWorkers() = 2
[10:24:43.264] MulticoreFuture:
[10:24:43.264] Label: ‘future_mapply-2’
[10:24:43.264] Expression:
[10:24:43.264] {
[10:24:43.264]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:43.264]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:43.264]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:43.264]         on.exit(options(oopts), add = TRUE)
[10:24:43.264]     }
[10:24:43.264]     {
[10:24:43.264]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:43.264]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:24:43.264]         do.call(mapply, args = args)
[10:24:43.264]     }
[10:24:43.264] }
[10:24:43.264] Lazy evaluation: FALSE
[10:24:43.264] Asynchronous evaluation: TRUE
[10:24:43.264] Local evaluation: TRUE
[10:24:43.264] Environment: R_GlobalEnv
[10:24:43.264] Capture standard output: TRUE
[10:24:43.264] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:43.264] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:43.264] Packages: <none>
[10:24:43.264] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:43.264] Resolved: TRUE
[10:24:43.264] Value: <not collected>
[10:24:43.264] Conditions captured: <none>
[10:24:43.264] Early signaling: FALSE
[10:24:43.264] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:43.264] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:43.274] Chunk #2 of 2 ... DONE
[10:24:43.274] Launching 2 futures (chunks) ... DONE
[10:24:43.275] Resolving 2 futures (chunks) ...
[10:24:43.275] resolve() on list ...
[10:24:43.275]  recursive: 0
[10:24:43.275]  length: 2
[10:24:43.275] 
[10:24:43.286] Future #2
[10:24:43.286] result() for MulticoreFuture ...
[10:24:43.287] result() for MulticoreFuture ...
[10:24:43.287] result() for MulticoreFuture ... done
[10:24:43.287] result() for MulticoreFuture ... done
[10:24:43.288] result() for MulticoreFuture ...
[10:24:43.288] result() for MulticoreFuture ... done
[10:24:43.288] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:24:43.288] - nx: 2
[10:24:43.288] - relay: TRUE
[10:24:43.288] - stdout: TRUE
[10:24:43.289] - signal: TRUE
[10:24:43.289] - resignal: FALSE
[10:24:43.289] - force: TRUE
[10:24:43.289] - relayed: [n=2] FALSE, FALSE
[10:24:43.289] - queued futures: [n=2] FALSE, FALSE
[10:24:43.289]  - until=1
[10:24:43.289]  - relaying element #1
[10:24:43.289] - relayed: [n=2] FALSE, FALSE
[10:24:43.290] - queued futures: [n=2] FALSE, TRUE
[10:24:43.290] signalConditionsASAP(NULL, pos=2) ... done
[10:24:43.290]  length: 1 (resolved future 2)
[10:24:43.712] plan(): Setting new future strategy stack:
[10:24:43.713] List of future strategies:
[10:24:43.713] 1. multicore:
[10:24:43.713]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:43.713]    - tweaked: FALSE
[10:24:43.713]    - call: plan(strategy)
[10:24:43.717] plan(): nbrOfWorkers() = 2
[10:24:43.728] Future #1
[10:24:43.728] result() for MulticoreFuture ...
[10:24:43.729] result() for MulticoreFuture ...
[10:24:43.729] result() for MulticoreFuture ... done
[10:24:43.730] result() for MulticoreFuture ... done
[10:24:43.730] result() for MulticoreFuture ...
[10:24:43.730] result() for MulticoreFuture ... done
[10:24:43.730] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:24:43.730] - nx: 2
[10:24:43.730] - relay: TRUE
[10:24:43.731] - stdout: TRUE
[10:24:43.731] - signal: TRUE
[10:24:43.731] - resignal: FALSE
[10:24:43.731] - force: TRUE
[10:24:43.731] - relayed: [n=2] FALSE, FALSE
[10:24:43.731] - queued futures: [n=2] FALSE, TRUE
[10:24:43.732]  - until=1
[10:24:43.732]  - relaying element #1
[10:24:43.732] result() for MulticoreFuture ...
[10:24:43.732] result() for MulticoreFuture ... done
[10:24:43.735] result() for MulticoreFuture ...
[10:24:43.735] result() for MulticoreFuture ... done
[10:24:43.736] result() for MulticoreFuture ...
[10:24:43.736] result() for MulticoreFuture ... done
[10:24:43.736] result() for MulticoreFuture ...
[10:24:43.736] result() for MulticoreFuture ... done
[10:24:43.736] - relayed: [n=2] TRUE, FALSE
[10:24:43.736] - queued futures: [n=2] TRUE, TRUE
[10:24:43.737] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:24:43.737]  length: 0 (resolved future 1)
[10:24:43.737] Relaying remaining futures
[10:24:43.737] signalConditionsASAP(NULL, pos=0) ...
[10:24:43.737] - nx: 2
[10:24:43.737] - relay: TRUE
[10:24:43.738] - stdout: TRUE
[10:24:43.738] - signal: TRUE
[10:24:43.738] - resignal: FALSE
[10:24:43.738] - force: TRUE
[10:24:43.738] - relayed: [n=2] TRUE, FALSE
[10:24:43.738] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:43.739]  - relaying element #2
[10:24:43.739] result() for MulticoreFuture ...
[10:24:43.739] result() for MulticoreFuture ... done
[10:24:43.739] result() for MulticoreFuture ...
[10:24:43.739] result() for MulticoreFuture ... done
[10:24:43.739] result() for MulticoreFuture ...
[10:24:43.740] result() for MulticoreFuture ... done
[10:24:43.740] result() for MulticoreFuture ...
[10:24:43.740] result() for MulticoreFuture ... done
[10:24:43.740] - relayed: [n=2] TRUE, TRUE
[10:24:43.740] - queued futures: [n=2] TRUE, TRUE
[10:24:43.740] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[10:24:43.740] resolve() on list ... DONE
[10:24:43.740] result() for MulticoreFuture ...
[10:24:43.741] result() for MulticoreFuture ... done
[10:24:43.741] result() for MulticoreFuture ...
[10:24:43.741] result() for MulticoreFuture ... done
[10:24:43.741] result() for MulticoreFuture ...
[10:24:43.741] result() for MulticoreFuture ... done
[10:24:43.741] result() for MulticoreFuture ...
[10:24:43.741] result() for MulticoreFuture ... done
[10:24:43.741]  - Number of value chunks collected: 2
[10:24:43.742] Resolving 2 futures (chunks) ... DONE
[10:24:43.742] Reducing values from 2 chunks ...
[10:24:43.742]  - Number of values collected after concatenation: 2
[10:24:43.742]  - Number of values expected: 2
[10:24:43.742] Reducing values from 2 chunks ... DONE
[10:24:43.742] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[10:24:43.743] future_mapply() ...
[10:24:43.747] Number of chunks: 2
[10:24:43.747] getGlobalsAndPackagesXApply() ...
[10:24:43.747]  - future.globals: TRUE
[10:24:43.747] getGlobalsAndPackages() ...
[10:24:43.747] Searching for globals...
[10:24:43.749] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:24:43.749] Searching for globals ... DONE
[10:24:43.749] Resolving globals: FALSE
[10:24:43.750] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[10:24:43.750] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[10:24:43.750] - globals: [1] ‘FUN’
[10:24:43.751] 
[10:24:43.751] getGlobalsAndPackages() ... DONE
[10:24:43.751]  - globals found/used: [n=1] ‘FUN’
[10:24:43.751]  - needed namespaces: [n=0] 
[10:24:43.751] Finding globals ... DONE
[10:24:43.751] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:24:43.751] List of 2
[10:24:43.751]  $ ...future.FUN:function (x, y)  
[10:24:43.751]  $ MoreArgs     : NULL
[10:24:43.751]  - attr(*, "where")=List of 2
[10:24:43.751]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:43.751]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:24:43.751]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:43.751]  - attr(*, "resolved")= logi FALSE
[10:24:43.751]  - attr(*, "total_size")= num NA
[10:24:43.754] Packages to be attached in all futures: [n=0] 
[10:24:43.754] getGlobalsAndPackagesXApply() ... DONE
[10:24:43.754] Number of futures (= number of chunks): 2
[10:24:43.755] Launching 2 futures (chunks) ...
[10:24:43.755] Chunk #1 of 2 ...
[10:24:43.755]  - Finding globals in '...' for chunk #1 ...
[10:24:43.755] getGlobalsAndPackages() ...
[10:24:43.755] Searching for globals...
[10:24:43.755] 
[10:24:43.755] Searching for globals ... DONE
[10:24:43.756] - globals: [0] <none>
[10:24:43.756] getGlobalsAndPackages() ... DONE
[10:24:43.756]    + additional globals found: [n=0] 
[10:24:43.756]    + additional namespaces needed: [n=0] 
[10:24:43.756]  - Finding globals in '...' for chunk #1 ... DONE
[10:24:43.756]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:43.756]  - seeds: <none>
[10:24:43.756]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:43.756] getGlobalsAndPackages() ...
[10:24:43.756] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:43.757] Resolving globals: FALSE
[10:24:43.757] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[10:24:43.757] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:24:43.758] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:43.758] 
[10:24:43.758] getGlobalsAndPackages() ... DONE
[10:24:43.758] run() for ‘Future’ ...
[10:24:43.758] - state: ‘created’
[10:24:43.758] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:43.762] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:43.762] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:43.763]   - Field: ‘label’
[10:24:43.763]   - Field: ‘local’
[10:24:43.763]   - Field: ‘owner’
[10:24:43.763]   - Field: ‘envir’
[10:24:43.763]   - Field: ‘workers’
[10:24:43.763]   - Field: ‘packages’
[10:24:43.763]   - Field: ‘gc’
[10:24:43.763]   - Field: ‘job’
[10:24:43.764]   - Field: ‘conditions’
[10:24:43.764]   - Field: ‘expr’
[10:24:43.764]   - Field: ‘uuid’
[10:24:43.764]   - Field: ‘seed’
[10:24:43.764]   - Field: ‘version’
[10:24:43.764]   - Field: ‘result’
[10:24:43.764]   - Field: ‘asynchronous’
[10:24:43.764]   - Field: ‘calls’
[10:24:43.764]   - Field: ‘globals’
[10:24:43.764]   - Field: ‘stdout’
[10:24:43.764]   - Field: ‘earlySignal’
[10:24:43.765]   - Field: ‘lazy’
[10:24:43.765]   - Field: ‘state’
[10:24:43.765] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:43.765] - Launch lazy future ...
[10:24:43.765] Packages needed by the future expression (n = 0): <none>
[10:24:43.765] Packages needed by future strategies (n = 0): <none>
[10:24:43.766] {
[10:24:43.766]     {
[10:24:43.766]         {
[10:24:43.766]             ...future.startTime <- base::Sys.time()
[10:24:43.766]             {
[10:24:43.766]                 {
[10:24:43.766]                   {
[10:24:43.766]                     {
[10:24:43.766]                       base::local({
[10:24:43.766]                         has_future <- base::requireNamespace("future", 
[10:24:43.766]                           quietly = TRUE)
[10:24:43.766]                         if (has_future) {
[10:24:43.766]                           ns <- base::getNamespace("future")
[10:24:43.766]                           version <- ns[[".package"]][["version"]]
[10:24:43.766]                           if (is.null(version)) 
[10:24:43.766]                             version <- utils::packageVersion("future")
[10:24:43.766]                         }
[10:24:43.766]                         else {
[10:24:43.766]                           version <- NULL
[10:24:43.766]                         }
[10:24:43.766]                         if (!has_future || version < "1.8.0") {
[10:24:43.766]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:43.766]                             "", base::R.version$version.string), 
[10:24:43.766]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:43.766]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:43.766]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:43.766]                               "release", "version")], collapse = " "), 
[10:24:43.766]                             hostname = base::Sys.info()[["nodename"]])
[10:24:43.766]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:43.766]                             info)
[10:24:43.766]                           info <- base::paste(info, collapse = "; ")
[10:24:43.766]                           if (!has_future) {
[10:24:43.766]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:43.766]                               info)
[10:24:43.766]                           }
[10:24:43.766]                           else {
[10:24:43.766]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:43.766]                               info, version)
[10:24:43.766]                           }
[10:24:43.766]                           base::stop(msg)
[10:24:43.766]                         }
[10:24:43.766]                       })
[10:24:43.766]                     }
[10:24:43.766]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:43.766]                     base::options(mc.cores = 1L)
[10:24:43.766]                   }
[10:24:43.766]                   options(future.plan = NULL)
[10:24:43.766]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:43.766]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:43.766]                 }
[10:24:43.766]                 ...future.workdir <- getwd()
[10:24:43.766]             }
[10:24:43.766]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:43.766]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:43.766]         }
[10:24:43.766]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:43.766]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:43.766]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:43.766]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:43.766]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:43.766]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:43.766]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:43.766]             base::names(...future.oldOptions))
[10:24:43.766]     }
[10:24:43.766]     if (TRUE) {
[10:24:43.766]     }
[10:24:43.766]     else {
[10:24:43.766]         if (NA) {
[10:24:43.766]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:43.766]                 open = "w")
[10:24:43.766]         }
[10:24:43.766]         else {
[10:24:43.766]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:43.766]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:43.766]         }
[10:24:43.766]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:43.766]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:43.766]             base::sink(type = "output", split = FALSE)
[10:24:43.766]             base::close(...future.stdout)
[10:24:43.766]         }, add = TRUE)
[10:24:43.766]     }
[10:24:43.766]     ...future.frame <- base::sys.nframe()
[10:24:43.766]     ...future.conditions <- base::list()
[10:24:43.766]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:43.766]     if (FALSE) {
[10:24:43.766]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:43.766]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:43.766]     }
[10:24:43.766]     ...future.result <- base::tryCatch({
[10:24:43.766]         base::withCallingHandlers({
[10:24:43.766]             ...future.value <- base::withVisible(base::local({
[10:24:43.766]                 withCallingHandlers({
[10:24:43.766]                   {
[10:24:43.766]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:43.766]                     if (!identical(...future.globals.maxSize.org, 
[10:24:43.766]                       ...future.globals.maxSize)) {
[10:24:43.766]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:43.766]                       on.exit(options(oopts), add = TRUE)
[10:24:43.766]                     }
[10:24:43.766]                     {
[10:24:43.766]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:43.766]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:24:43.766]                         USE.NAMES = FALSE)
[10:24:43.766]                       do.call(mapply, args = args)
[10:24:43.766]                     }
[10:24:43.766]                   }
[10:24:43.766]                 }, immediateCondition = function(cond) {
[10:24:43.766]                   save_rds <- function (object, pathname, ...) 
[10:24:43.766]                   {
[10:24:43.766]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:43.766]                     if (file_test("-f", pathname_tmp)) {
[10:24:43.766]                       fi_tmp <- file.info(pathname_tmp)
[10:24:43.766]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:43.766]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:43.766]                         fi_tmp[["mtime"]])
[10:24:43.766]                     }
[10:24:43.766]                     tryCatch({
[10:24:43.766]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:43.766]                     }, error = function(ex) {
[10:24:43.766]                       msg <- conditionMessage(ex)
[10:24:43.766]                       fi_tmp <- file.info(pathname_tmp)
[10:24:43.766]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:43.766]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:43.766]                         fi_tmp[["mtime"]], msg)
[10:24:43.766]                       ex$message <- msg
[10:24:43.766]                       stop(ex)
[10:24:43.766]                     })
[10:24:43.766]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:43.766]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:43.766]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:43.766]                       fi_tmp <- file.info(pathname_tmp)
[10:24:43.766]                       fi <- file.info(pathname)
[10:24:43.766]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:43.766]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:43.766]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:43.766]                         fi[["size"]], fi[["mtime"]])
[10:24:43.766]                       stop(msg)
[10:24:43.766]                     }
[10:24:43.766]                     invisible(pathname)
[10:24:43.766]                   }
[10:24:43.766]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:43.766]                     rootPath = tempdir()) 
[10:24:43.766]                   {
[10:24:43.766]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:43.766]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:43.766]                       tmpdir = path, fileext = ".rds")
[10:24:43.766]                     save_rds(obj, file)
[10:24:43.766]                   }
[10:24:43.766]                   saveImmediateCondition(cond, path = "/tmp/Rtmp5boaqN/.future/immediateConditions")
[10:24:43.766]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:43.766]                   {
[10:24:43.766]                     inherits <- base::inherits
[10:24:43.766]                     invokeRestart <- base::invokeRestart
[10:24:43.766]                     is.null <- base::is.null
[10:24:43.766]                     muffled <- FALSE
[10:24:43.766]                     if (inherits(cond, "message")) {
[10:24:43.766]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:43.766]                       if (muffled) 
[10:24:43.766]                         invokeRestart("muffleMessage")
[10:24:43.766]                     }
[10:24:43.766]                     else if (inherits(cond, "warning")) {
[10:24:43.766]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:43.766]                       if (muffled) 
[10:24:43.766]                         invokeRestart("muffleWarning")
[10:24:43.766]                     }
[10:24:43.766]                     else if (inherits(cond, "condition")) {
[10:24:43.766]                       if (!is.null(pattern)) {
[10:24:43.766]                         computeRestarts <- base::computeRestarts
[10:24:43.766]                         grepl <- base::grepl
[10:24:43.766]                         restarts <- computeRestarts(cond)
[10:24:43.766]                         for (restart in restarts) {
[10:24:43.766]                           name <- restart$name
[10:24:43.766]                           if (is.null(name)) 
[10:24:43.766]                             next
[10:24:43.766]                           if (!grepl(pattern, name)) 
[10:24:43.766]                             next
[10:24:43.766]                           invokeRestart(restart)
[10:24:43.766]                           muffled <- TRUE
[10:24:43.766]                           break
[10:24:43.766]                         }
[10:24:43.766]                       }
[10:24:43.766]                     }
[10:24:43.766]                     invisible(muffled)
[10:24:43.766]                   }
[10:24:43.766]                   muffleCondition(cond)
[10:24:43.766]                 })
[10:24:43.766]             }))
[10:24:43.766]             future::FutureResult(value = ...future.value$value, 
[10:24:43.766]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:43.766]                   ...future.rng), globalenv = if (FALSE) 
[10:24:43.766]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:43.766]                     ...future.globalenv.names))
[10:24:43.766]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:43.766]         }, condition = base::local({
[10:24:43.766]             c <- base::c
[10:24:43.766]             inherits <- base::inherits
[10:24:43.766]             invokeRestart <- base::invokeRestart
[10:24:43.766]             length <- base::length
[10:24:43.766]             list <- base::list
[10:24:43.766]             seq.int <- base::seq.int
[10:24:43.766]             signalCondition <- base::signalCondition
[10:24:43.766]             sys.calls <- base::sys.calls
[10:24:43.766]             `[[` <- base::`[[`
[10:24:43.766]             `+` <- base::`+`
[10:24:43.766]             `<<-` <- base::`<<-`
[10:24:43.766]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:43.766]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:43.766]                   3L)]
[10:24:43.766]             }
[10:24:43.766]             function(cond) {
[10:24:43.766]                 is_error <- inherits(cond, "error")
[10:24:43.766]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:43.766]                   NULL)
[10:24:43.766]                 if (is_error) {
[10:24:43.766]                   sessionInformation <- function() {
[10:24:43.766]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:43.766]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:43.766]                       search = base::search(), system = base::Sys.info())
[10:24:43.766]                   }
[10:24:43.766]                   ...future.conditions[[length(...future.conditions) + 
[10:24:43.766]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:43.766]                     cond$call), session = sessionInformation(), 
[10:24:43.766]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:43.766]                   signalCondition(cond)
[10:24:43.766]                 }
[10:24:43.766]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:43.766]                 "immediateCondition"))) {
[10:24:43.766]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:43.766]                   ...future.conditions[[length(...future.conditions) + 
[10:24:43.766]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:43.766]                   if (TRUE && !signal) {
[10:24:43.766]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:43.766]                     {
[10:24:43.766]                       inherits <- base::inherits
[10:24:43.766]                       invokeRestart <- base::invokeRestart
[10:24:43.766]                       is.null <- base::is.null
[10:24:43.766]                       muffled <- FALSE
[10:24:43.766]                       if (inherits(cond, "message")) {
[10:24:43.766]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:43.766]                         if (muffled) 
[10:24:43.766]                           invokeRestart("muffleMessage")
[10:24:43.766]                       }
[10:24:43.766]                       else if (inherits(cond, "warning")) {
[10:24:43.766]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:43.766]                         if (muffled) 
[10:24:43.766]                           invokeRestart("muffleWarning")
[10:24:43.766]                       }
[10:24:43.766]                       else if (inherits(cond, "condition")) {
[10:24:43.766]                         if (!is.null(pattern)) {
[10:24:43.766]                           computeRestarts <- base::computeRestarts
[10:24:43.766]                           grepl <- base::grepl
[10:24:43.766]                           restarts <- computeRestarts(cond)
[10:24:43.766]                           for (restart in restarts) {
[10:24:43.766]                             name <- restart$name
[10:24:43.766]                             if (is.null(name)) 
[10:24:43.766]                               next
[10:24:43.766]                             if (!grepl(pattern, name)) 
[10:24:43.766]                               next
[10:24:43.766]                             invokeRestart(restart)
[10:24:43.766]                             muffled <- TRUE
[10:24:43.766]                             break
[10:24:43.766]                           }
[10:24:43.766]                         }
[10:24:43.766]                       }
[10:24:43.766]                       invisible(muffled)
[10:24:43.766]                     }
[10:24:43.766]                     muffleCondition(cond, pattern = "^muffle")
[10:24:43.766]                   }
[10:24:43.766]                 }
[10:24:43.766]                 else {
[10:24:43.766]                   if (TRUE) {
[10:24:43.766]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:43.766]                     {
[10:24:43.766]                       inherits <- base::inherits
[10:24:43.766]                       invokeRestart <- base::invokeRestart
[10:24:43.766]                       is.null <- base::is.null
[10:24:43.766]                       muffled <- FALSE
[10:24:43.766]                       if (inherits(cond, "message")) {
[10:24:43.766]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:43.766]                         if (muffled) 
[10:24:43.766]                           invokeRestart("muffleMessage")
[10:24:43.766]                       }
[10:24:43.766]                       else if (inherits(cond, "warning")) {
[10:24:43.766]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:43.766]                         if (muffled) 
[10:24:43.766]                           invokeRestart("muffleWarning")
[10:24:43.766]                       }
[10:24:43.766]                       else if (inherits(cond, "condition")) {
[10:24:43.766]                         if (!is.null(pattern)) {
[10:24:43.766]                           computeRestarts <- base::computeRestarts
[10:24:43.766]                           grepl <- base::grepl
[10:24:43.766]                           restarts <- computeRestarts(cond)
[10:24:43.766]                           for (restart in restarts) {
[10:24:43.766]                             name <- restart$name
[10:24:43.766]                             if (is.null(name)) 
[10:24:43.766]                               next
[10:24:43.766]                             if (!grepl(pattern, name)) 
[10:24:43.766]                               next
[10:24:43.766]                             invokeRestart(restart)
[10:24:43.766]                             muffled <- TRUE
[10:24:43.766]                             break
[10:24:43.766]                           }
[10:24:43.766]                         }
[10:24:43.766]                       }
[10:24:43.766]                       invisible(muffled)
[10:24:43.766]                     }
[10:24:43.766]                     muffleCondition(cond, pattern = "^muffle")
[10:24:43.766]                   }
[10:24:43.766]                 }
[10:24:43.766]             }
[10:24:43.766]         }))
[10:24:43.766]     }, error = function(ex) {
[10:24:43.766]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:43.766]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:43.766]                 ...future.rng), started = ...future.startTime, 
[10:24:43.766]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:43.766]             version = "1.8"), class = "FutureResult")
[10:24:43.766]     }, finally = {
[10:24:43.766]         if (!identical(...future.workdir, getwd())) 
[10:24:43.766]             setwd(...future.workdir)
[10:24:43.766]         {
[10:24:43.766]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:43.766]                 ...future.oldOptions$nwarnings <- NULL
[10:24:43.766]             }
[10:24:43.766]             base::options(...future.oldOptions)
[10:24:43.766]             if (.Platform$OS.type == "windows") {
[10:24:43.766]                 old_names <- names(...future.oldEnvVars)
[10:24:43.766]                 envs <- base::Sys.getenv()
[10:24:43.766]                 names <- names(envs)
[10:24:43.766]                 common <- intersect(names, old_names)
[10:24:43.766]                 added <- setdiff(names, old_names)
[10:24:43.766]                 removed <- setdiff(old_names, names)
[10:24:43.766]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:43.766]                   envs[common]]
[10:24:43.766]                 NAMES <- toupper(changed)
[10:24:43.766]                 args <- list()
[10:24:43.766]                 for (kk in seq_along(NAMES)) {
[10:24:43.766]                   name <- changed[[kk]]
[10:24:43.766]                   NAME <- NAMES[[kk]]
[10:24:43.766]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:43.766]                     next
[10:24:43.766]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:43.766]                 }
[10:24:43.766]                 NAMES <- toupper(added)
[10:24:43.766]                 for (kk in seq_along(NAMES)) {
[10:24:43.766]                   name <- added[[kk]]
[10:24:43.766]                   NAME <- NAMES[[kk]]
[10:24:43.766]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:43.766]                     next
[10:24:43.766]                   args[[name]] <- ""
[10:24:43.766]                 }
[10:24:43.766]                 NAMES <- toupper(removed)
[10:24:43.766]                 for (kk in seq_along(NAMES)) {
[10:24:43.766]                   name <- removed[[kk]]
[10:24:43.766]                   NAME <- NAMES[[kk]]
[10:24:43.766]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:43.766]                     next
[10:24:43.766]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:43.766]                 }
[10:24:43.766]                 if (length(args) > 0) 
[10:24:43.766]                   base::do.call(base::Sys.setenv, args = args)
[10:24:43.766]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:43.766]             }
[10:24:43.766]             else {
[10:24:43.766]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:43.766]             }
[10:24:43.766]             {
[10:24:43.766]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:43.766]                   0L) {
[10:24:43.766]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:43.766]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:43.766]                   base::options(opts)
[10:24:43.766]                 }
[10:24:43.766]                 {
[10:24:43.766]                   {
[10:24:43.766]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:43.766]                     NULL
[10:24:43.766]                   }
[10:24:43.766]                   options(future.plan = NULL)
[10:24:43.766]                   if (is.na(NA_character_)) 
[10:24:43.766]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:43.766]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:43.766]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:43.766]                     envir = parent.frame()) 
[10:24:43.766]                   {
[10:24:43.766]                     default_workers <- missing(workers)
[10:24:43.766]                     if (is.function(workers)) 
[10:24:43.766]                       workers <- workers()
[10:24:43.766]                     workers <- structure(as.integer(workers), 
[10:24:43.766]                       class = class(workers))
[10:24:43.766]                     stop_if_not(is.finite(workers), workers >= 
[10:24:43.766]                       1L)
[10:24:43.766]                     if ((workers == 1L && !inherits(workers, 
[10:24:43.766]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:43.766]                       if (default_workers) 
[10:24:43.766]                         supportsMulticore(warn = TRUE)
[10:24:43.766]                       return(sequential(..., envir = envir))
[10:24:43.766]                     }
[10:24:43.766]                     oopts <- options(mc.cores = workers)
[10:24:43.766]                     on.exit(options(oopts))
[10:24:43.766]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:43.766]                       envir = envir)
[10:24:43.766]                     if (!future$lazy) 
[10:24:43.766]                       future <- run(future)
[10:24:43.766]                     invisible(future)
[10:24:43.766]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:43.766]                 }
[10:24:43.766]             }
[10:24:43.766]         }
[10:24:43.766]     })
[10:24:43.766]     if (FALSE) {
[10:24:43.766]         base::sink(type = "output", split = FALSE)
[10:24:43.766]         if (NA) {
[10:24:43.766]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:43.766]         }
[10:24:43.766]         else {
[10:24:43.766]             ...future.result["stdout"] <- base::list(NULL)
[10:24:43.766]         }
[10:24:43.766]         base::close(...future.stdout)
[10:24:43.766]         ...future.stdout <- NULL
[10:24:43.766]     }
[10:24:43.766]     ...future.result$conditions <- ...future.conditions
[10:24:43.766]     ...future.result$finished <- base::Sys.time()
[10:24:43.766]     ...future.result
[10:24:43.766] }
[10:24:43.770] assign_globals() ...
[10:24:43.770] List of 5
[10:24:43.770]  $ ...future.FUN            :function (x, y)  
[10:24:43.770]  $ MoreArgs                 : NULL
[10:24:43.770]  $ ...future.elements_ii    :List of 2
[10:24:43.770]   ..$ :List of 1
[10:24:43.770]   .. ..$ : int 1
[10:24:43.770]   ..$ :List of 1
[10:24:43.770]   .. ..$ : int 0
[10:24:43.770]  $ ...future.seeds_ii       : NULL
[10:24:43.770]  $ ...future.globals.maxSize: NULL
[10:24:43.770]  - attr(*, "where")=List of 5
[10:24:43.770]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:43.770]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:24:43.770]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:43.770]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:43.770]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:43.770]  - attr(*, "resolved")= logi FALSE
[10:24:43.770]  - attr(*, "total_size")= num 6368
[10:24:43.770]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:43.770]  - attr(*, "already-done")= logi TRUE
[10:24:43.775] - reassign environment for ‘...future.FUN’
[10:24:43.775] - copied ‘...future.FUN’ to environment
[10:24:43.775] - copied ‘MoreArgs’ to environment
[10:24:43.775] - copied ‘...future.elements_ii’ to environment
[10:24:43.775] - copied ‘...future.seeds_ii’ to environment
[10:24:43.776] - copied ‘...future.globals.maxSize’ to environment
[10:24:43.776] assign_globals() ... done
[10:24:43.776] requestCore(): workers = 2
[10:24:43.778] MulticoreFuture started
[10:24:43.778] - Launch lazy future ... done
[10:24:43.779] run() for ‘MulticoreFuture’ ... done
[10:24:43.779] Created future:
[10:24:43.779] plan(): Setting new future strategy stack:
[10:24:43.779] List of future strategies:
[10:24:43.779] 1. sequential:
[10:24:43.779]    - args: function (..., envir = parent.frame())
[10:24:43.779]    - tweaked: FALSE
[10:24:43.779]    - call: NULL
[10:24:43.780] plan(): nbrOfWorkers() = 1
[10:24:43.779] MulticoreFuture:
[10:24:43.779] Label: ‘future_mapply-1’
[10:24:43.779] Expression:
[10:24:43.779] {
[10:24:43.779]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:43.779]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:43.779]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:43.779]         on.exit(options(oopts), add = TRUE)
[10:24:43.779]     }
[10:24:43.779]     {
[10:24:43.779]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:43.779]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:24:43.779]         do.call(mapply, args = args)
[10:24:43.779]     }
[10:24:43.779] }
[10:24:43.779] Lazy evaluation: FALSE
[10:24:43.779] Asynchronous evaluation: TRUE
[10:24:43.779] Local evaluation: TRUE
[10:24:43.779] Environment: R_GlobalEnv
[10:24:43.779] Capture standard output: NA
[10:24:43.779] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:43.779] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:43.779] Packages: <none>
[10:24:43.779] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:43.779] Resolved: FALSE
[10:24:43.779] Value: <not collected>
[10:24:43.779] Conditions captured: <none>
[10:24:43.779] Early signaling: FALSE
[10:24:43.779] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:43.779] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:43.792] Chunk #1 of 2 ... DONE
[10:24:43.792] Chunk #2 of 2 ...
[10:24:43.792]  - Finding globals in '...' for chunk #2 ...
[10:24:43.792] getGlobalsAndPackages() ...
[10:24:43.793] Searching for globals...
[10:24:43.793] 
[10:24:43.793] Searching for globals ... DONE
[10:24:43.794] - globals: [0] <none>
[10:24:43.794] getGlobalsAndPackages() ... DONE
[10:24:43.794]    + additional globals found: [n=0] 
[10:24:43.794]    + additional namespaces needed: [n=0] 
[10:24:43.794]  - Finding globals in '...' for chunk #2 ... DONE
[10:24:43.794]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:43.795]  - seeds: <none>
[10:24:43.795]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:43.795] getGlobalsAndPackages() ...
[10:24:43.795] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:43.795] Resolving globals: FALSE
[10:24:43.796] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[10:24:43.797] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:24:43.797] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:43.798] 
[10:24:43.798] getGlobalsAndPackages() ... DONE
[10:24:43.798] run() for ‘Future’ ...
[10:24:43.798] - state: ‘created’
[10:24:43.799] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:24:43.804] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:43.804] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:24:43.804]   - Field: ‘label’
[10:24:43.804]   - Field: ‘local’
[10:24:43.805]   - Field: ‘owner’
[10:24:43.805]   - Field: ‘envir’
[10:24:43.805]   - Field: ‘workers’
[10:24:43.805]   - Field: ‘packages’
[10:24:43.805]   - Field: ‘gc’
[10:24:43.805]   - Field: ‘job’
[10:24:43.806]   - Field: ‘conditions’
[10:24:43.806]   - Field: ‘expr’
[10:24:43.806]   - Field: ‘uuid’
[10:24:43.806]   - Field: ‘seed’
[10:24:43.806]   - Field: ‘version’
[10:24:43.806]   - Field: ‘result’
[10:24:43.806]   - Field: ‘asynchronous’
[10:24:43.807]   - Field: ‘calls’
[10:24:43.807]   - Field: ‘globals’
[10:24:43.807]   - Field: ‘stdout’
[10:24:43.807]   - Field: ‘earlySignal’
[10:24:43.807]   - Field: ‘lazy’
[10:24:43.807]   - Field: ‘state’
[10:24:43.808] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:24:43.808] - Launch lazy future ...
[10:24:43.808] Packages needed by the future expression (n = 0): <none>
[10:24:43.808] Packages needed by future strategies (n = 0): <none>
[10:24:43.809] {
[10:24:43.809]     {
[10:24:43.809]         {
[10:24:43.809]             ...future.startTime <- base::Sys.time()
[10:24:43.809]             {
[10:24:43.809]                 {
[10:24:43.809]                   {
[10:24:43.809]                     {
[10:24:43.809]                       base::local({
[10:24:43.809]                         has_future <- base::requireNamespace("future", 
[10:24:43.809]                           quietly = TRUE)
[10:24:43.809]                         if (has_future) {
[10:24:43.809]                           ns <- base::getNamespace("future")
[10:24:43.809]                           version <- ns[[".package"]][["version"]]
[10:24:43.809]                           if (is.null(version)) 
[10:24:43.809]                             version <- utils::packageVersion("future")
[10:24:43.809]                         }
[10:24:43.809]                         else {
[10:24:43.809]                           version <- NULL
[10:24:43.809]                         }
[10:24:43.809]                         if (!has_future || version < "1.8.0") {
[10:24:43.809]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:43.809]                             "", base::R.version$version.string), 
[10:24:43.809]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:43.809]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:43.809]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:43.809]                               "release", "version")], collapse = " "), 
[10:24:43.809]                             hostname = base::Sys.info()[["nodename"]])
[10:24:43.809]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:43.809]                             info)
[10:24:43.809]                           info <- base::paste(info, collapse = "; ")
[10:24:43.809]                           if (!has_future) {
[10:24:43.809]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:43.809]                               info)
[10:24:43.809]                           }
[10:24:43.809]                           else {
[10:24:43.809]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:43.809]                               info, version)
[10:24:43.809]                           }
[10:24:43.809]                           base::stop(msg)
[10:24:43.809]                         }
[10:24:43.809]                       })
[10:24:43.809]                     }
[10:24:43.809]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:43.809]                     base::options(mc.cores = 1L)
[10:24:43.809]                   }
[10:24:43.809]                   options(future.plan = NULL)
[10:24:43.809]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:43.809]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:43.809]                 }
[10:24:43.809]                 ...future.workdir <- getwd()
[10:24:43.809]             }
[10:24:43.809]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:43.809]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:43.809]         }
[10:24:43.809]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:43.809]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:43.809]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:43.809]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:43.809]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:43.809]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:43.809]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:43.809]             base::names(...future.oldOptions))
[10:24:43.809]     }
[10:24:43.809]     if (TRUE) {
[10:24:43.809]     }
[10:24:43.809]     else {
[10:24:43.809]         if (NA) {
[10:24:43.809]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:43.809]                 open = "w")
[10:24:43.809]         }
[10:24:43.809]         else {
[10:24:43.809]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:43.809]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:43.809]         }
[10:24:43.809]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:43.809]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:43.809]             base::sink(type = "output", split = FALSE)
[10:24:43.809]             base::close(...future.stdout)
[10:24:43.809]         }, add = TRUE)
[10:24:43.809]     }
[10:24:43.809]     ...future.frame <- base::sys.nframe()
[10:24:43.809]     ...future.conditions <- base::list()
[10:24:43.809]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:43.809]     if (FALSE) {
[10:24:43.809]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:43.809]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:43.809]     }
[10:24:43.809]     ...future.result <- base::tryCatch({
[10:24:43.809]         base::withCallingHandlers({
[10:24:43.809]             ...future.value <- base::withVisible(base::local({
[10:24:43.809]                 withCallingHandlers({
[10:24:43.809]                   {
[10:24:43.809]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:43.809]                     if (!identical(...future.globals.maxSize.org, 
[10:24:43.809]                       ...future.globals.maxSize)) {
[10:24:43.809]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:43.809]                       on.exit(options(oopts), add = TRUE)
[10:24:43.809]                     }
[10:24:43.809]                     {
[10:24:43.809]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:43.809]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:24:43.809]                         USE.NAMES = FALSE)
[10:24:43.809]                       do.call(mapply, args = args)
[10:24:43.809]                     }
[10:24:43.809]                   }
[10:24:43.809]                 }, immediateCondition = function(cond) {
[10:24:43.809]                   save_rds <- function (object, pathname, ...) 
[10:24:43.809]                   {
[10:24:43.809]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:24:43.809]                     if (file_test("-f", pathname_tmp)) {
[10:24:43.809]                       fi_tmp <- file.info(pathname_tmp)
[10:24:43.809]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:24:43.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:43.809]                         fi_tmp[["mtime"]])
[10:24:43.809]                     }
[10:24:43.809]                     tryCatch({
[10:24:43.809]                       saveRDS(object, file = pathname_tmp, ...)
[10:24:43.809]                     }, error = function(ex) {
[10:24:43.809]                       msg <- conditionMessage(ex)
[10:24:43.809]                       fi_tmp <- file.info(pathname_tmp)
[10:24:43.809]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:24:43.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:43.809]                         fi_tmp[["mtime"]], msg)
[10:24:43.809]                       ex$message <- msg
[10:24:43.809]                       stop(ex)
[10:24:43.809]                     })
[10:24:43.809]                     stopifnot(file_test("-f", pathname_tmp))
[10:24:43.809]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:24:43.809]                     if (!res || file_test("-f", pathname_tmp)) {
[10:24:43.809]                       fi_tmp <- file.info(pathname_tmp)
[10:24:43.809]                       fi <- file.info(pathname)
[10:24:43.809]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:24:43.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:24:43.809]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:24:43.809]                         fi[["size"]], fi[["mtime"]])
[10:24:43.809]                       stop(msg)
[10:24:43.809]                     }
[10:24:43.809]                     invisible(pathname)
[10:24:43.809]                   }
[10:24:43.809]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:24:43.809]                     rootPath = tempdir()) 
[10:24:43.809]                   {
[10:24:43.809]                     obj <- list(time = Sys.time(), condition = cond)
[10:24:43.809]                     file <- tempfile(pattern = class(cond)[1], 
[10:24:43.809]                       tmpdir = path, fileext = ".rds")
[10:24:43.809]                     save_rds(obj, file)
[10:24:43.809]                   }
[10:24:43.809]                   saveImmediateCondition(cond, path = "/tmp/Rtmp5boaqN/.future/immediateConditions")
[10:24:43.809]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:43.809]                   {
[10:24:43.809]                     inherits <- base::inherits
[10:24:43.809]                     invokeRestart <- base::invokeRestart
[10:24:43.809]                     is.null <- base::is.null
[10:24:43.809]                     muffled <- FALSE
[10:24:43.809]                     if (inherits(cond, "message")) {
[10:24:43.809]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:43.809]                       if (muffled) 
[10:24:43.809]                         invokeRestart("muffleMessage")
[10:24:43.809]                     }
[10:24:43.809]                     else if (inherits(cond, "warning")) {
[10:24:43.809]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:43.809]                       if (muffled) 
[10:24:43.809]                         invokeRestart("muffleWarning")
[10:24:43.809]                     }
[10:24:43.809]                     else if (inherits(cond, "condition")) {
[10:24:43.809]                       if (!is.null(pattern)) {
[10:24:43.809]                         computeRestarts <- base::computeRestarts
[10:24:43.809]                         grepl <- base::grepl
[10:24:43.809]                         restarts <- computeRestarts(cond)
[10:24:43.809]                         for (restart in restarts) {
[10:24:43.809]                           name <- restart$name
[10:24:43.809]                           if (is.null(name)) 
[10:24:43.809]                             next
[10:24:43.809]                           if (!grepl(pattern, name)) 
[10:24:43.809]                             next
[10:24:43.809]                           invokeRestart(restart)
[10:24:43.809]                           muffled <- TRUE
[10:24:43.809]                           break
[10:24:43.809]                         }
[10:24:43.809]                       }
[10:24:43.809]                     }
[10:24:43.809]                     invisible(muffled)
[10:24:43.809]                   }
[10:24:43.809]                   muffleCondition(cond)
[10:24:43.809]                 })
[10:24:43.809]             }))
[10:24:43.809]             future::FutureResult(value = ...future.value$value, 
[10:24:43.809]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:43.809]                   ...future.rng), globalenv = if (FALSE) 
[10:24:43.809]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:43.809]                     ...future.globalenv.names))
[10:24:43.809]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:43.809]         }, condition = base::local({
[10:24:43.809]             c <- base::c
[10:24:43.809]             inherits <- base::inherits
[10:24:43.809]             invokeRestart <- base::invokeRestart
[10:24:43.809]             length <- base::length
[10:24:43.809]             list <- base::list
[10:24:43.809]             seq.int <- base::seq.int
[10:24:43.809]             signalCondition <- base::signalCondition
[10:24:43.809]             sys.calls <- base::sys.calls
[10:24:43.809]             `[[` <- base::`[[`
[10:24:43.809]             `+` <- base::`+`
[10:24:43.809]             `<<-` <- base::`<<-`
[10:24:43.809]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:43.809]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:43.809]                   3L)]
[10:24:43.809]             }
[10:24:43.809]             function(cond) {
[10:24:43.809]                 is_error <- inherits(cond, "error")
[10:24:43.809]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:43.809]                   NULL)
[10:24:43.809]                 if (is_error) {
[10:24:43.809]                   sessionInformation <- function() {
[10:24:43.809]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:43.809]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:43.809]                       search = base::search(), system = base::Sys.info())
[10:24:43.809]                   }
[10:24:43.809]                   ...future.conditions[[length(...future.conditions) + 
[10:24:43.809]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:43.809]                     cond$call), session = sessionInformation(), 
[10:24:43.809]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:43.809]                   signalCondition(cond)
[10:24:43.809]                 }
[10:24:43.809]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:43.809]                 "immediateCondition"))) {
[10:24:43.809]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:43.809]                   ...future.conditions[[length(...future.conditions) + 
[10:24:43.809]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:43.809]                   if (TRUE && !signal) {
[10:24:43.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:43.809]                     {
[10:24:43.809]                       inherits <- base::inherits
[10:24:43.809]                       invokeRestart <- base::invokeRestart
[10:24:43.809]                       is.null <- base::is.null
[10:24:43.809]                       muffled <- FALSE
[10:24:43.809]                       if (inherits(cond, "message")) {
[10:24:43.809]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:43.809]                         if (muffled) 
[10:24:43.809]                           invokeRestart("muffleMessage")
[10:24:43.809]                       }
[10:24:43.809]                       else if (inherits(cond, "warning")) {
[10:24:43.809]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:43.809]                         if (muffled) 
[10:24:43.809]                           invokeRestart("muffleWarning")
[10:24:43.809]                       }
[10:24:43.809]                       else if (inherits(cond, "condition")) {
[10:24:43.809]                         if (!is.null(pattern)) {
[10:24:43.809]                           computeRestarts <- base::computeRestarts
[10:24:43.809]                           grepl <- base::grepl
[10:24:43.809]                           restarts <- computeRestarts(cond)
[10:24:43.809]                           for (restart in restarts) {
[10:24:43.809]                             name <- restart$name
[10:24:43.809]                             if (is.null(name)) 
[10:24:43.809]                               next
[10:24:43.809]                             if (!grepl(pattern, name)) 
[10:24:43.809]                               next
[10:24:43.809]                             invokeRestart(restart)
[10:24:43.809]                             muffled <- TRUE
[10:24:43.809]                             break
[10:24:43.809]                           }
[10:24:43.809]                         }
[10:24:43.809]                       }
[10:24:43.809]                       invisible(muffled)
[10:24:43.809]                     }
[10:24:43.809]                     muffleCondition(cond, pattern = "^muffle")
[10:24:43.809]                   }
[10:24:43.809]                 }
[10:24:43.809]                 else {
[10:24:43.809]                   if (TRUE) {
[10:24:43.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:43.809]                     {
[10:24:43.809]                       inherits <- base::inherits
[10:24:43.809]                       invokeRestart <- base::invokeRestart
[10:24:43.809]                       is.null <- base::is.null
[10:24:43.809]                       muffled <- FALSE
[10:24:43.809]                       if (inherits(cond, "message")) {
[10:24:43.809]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:43.809]                         if (muffled) 
[10:24:43.809]                           invokeRestart("muffleMessage")
[10:24:43.809]                       }
[10:24:43.809]                       else if (inherits(cond, "warning")) {
[10:24:43.809]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:43.809]                         if (muffled) 
[10:24:43.809]                           invokeRestart("muffleWarning")
[10:24:43.809]                       }
[10:24:43.809]                       else if (inherits(cond, "condition")) {
[10:24:43.809]                         if (!is.null(pattern)) {
[10:24:43.809]                           computeRestarts <- base::computeRestarts
[10:24:43.809]                           grepl <- base::grepl
[10:24:43.809]                           restarts <- computeRestarts(cond)
[10:24:43.809]                           for (restart in restarts) {
[10:24:43.809]                             name <- restart$name
[10:24:43.809]                             if (is.null(name)) 
[10:24:43.809]                               next
[10:24:43.809]                             if (!grepl(pattern, name)) 
[10:24:43.809]                               next
[10:24:43.809]                             invokeRestart(restart)
[10:24:43.809]                             muffled <- TRUE
[10:24:43.809]                             break
[10:24:43.809]                           }
[10:24:43.809]                         }
[10:24:43.809]                       }
[10:24:43.809]                       invisible(muffled)
[10:24:43.809]                     }
[10:24:43.809]                     muffleCondition(cond, pattern = "^muffle")
[10:24:43.809]                   }
[10:24:43.809]                 }
[10:24:43.809]             }
[10:24:43.809]         }))
[10:24:43.809]     }, error = function(ex) {
[10:24:43.809]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:43.809]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:43.809]                 ...future.rng), started = ...future.startTime, 
[10:24:43.809]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:43.809]             version = "1.8"), class = "FutureResult")
[10:24:43.809]     }, finally = {
[10:24:43.809]         if (!identical(...future.workdir, getwd())) 
[10:24:43.809]             setwd(...future.workdir)
[10:24:43.809]         {
[10:24:43.809]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:43.809]                 ...future.oldOptions$nwarnings <- NULL
[10:24:43.809]             }
[10:24:43.809]             base::options(...future.oldOptions)
[10:24:43.809]             if (.Platform$OS.type == "windows") {
[10:24:43.809]                 old_names <- names(...future.oldEnvVars)
[10:24:43.809]                 envs <- base::Sys.getenv()
[10:24:43.809]                 names <- names(envs)
[10:24:43.809]                 common <- intersect(names, old_names)
[10:24:43.809]                 added <- setdiff(names, old_names)
[10:24:43.809]                 removed <- setdiff(old_names, names)
[10:24:43.809]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:43.809]                   envs[common]]
[10:24:43.809]                 NAMES <- toupper(changed)
[10:24:43.809]                 args <- list()
[10:24:43.809]                 for (kk in seq_along(NAMES)) {
[10:24:43.809]                   name <- changed[[kk]]
[10:24:43.809]                   NAME <- NAMES[[kk]]
[10:24:43.809]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:43.809]                     next
[10:24:43.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:43.809]                 }
[10:24:43.809]                 NAMES <- toupper(added)
[10:24:43.809]                 for (kk in seq_along(NAMES)) {
[10:24:43.809]                   name <- added[[kk]]
[10:24:43.809]                   NAME <- NAMES[[kk]]
[10:24:43.809]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:43.809]                     next
[10:24:43.809]                   args[[name]] <- ""
[10:24:43.809]                 }
[10:24:43.809]                 NAMES <- toupper(removed)
[10:24:43.809]                 for (kk in seq_along(NAMES)) {
[10:24:43.809]                   name <- removed[[kk]]
[10:24:43.809]                   NAME <- NAMES[[kk]]
[10:24:43.809]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:43.809]                     next
[10:24:43.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:43.809]                 }
[10:24:43.809]                 if (length(args) > 0) 
[10:24:43.809]                   base::do.call(base::Sys.setenv, args = args)
[10:24:43.809]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:43.809]             }
[10:24:43.809]             else {
[10:24:43.809]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:43.809]             }
[10:24:43.809]             {
[10:24:43.809]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:43.809]                   0L) {
[10:24:43.809]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:43.809]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:43.809]                   base::options(opts)
[10:24:43.809]                 }
[10:24:43.809]                 {
[10:24:43.809]                   {
[10:24:43.809]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:43.809]                     NULL
[10:24:43.809]                   }
[10:24:43.809]                   options(future.plan = NULL)
[10:24:43.809]                   if (is.na(NA_character_)) 
[10:24:43.809]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:43.809]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:43.809]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:24:43.809]                     envir = parent.frame()) 
[10:24:43.809]                   {
[10:24:43.809]                     default_workers <- missing(workers)
[10:24:43.809]                     if (is.function(workers)) 
[10:24:43.809]                       workers <- workers()
[10:24:43.809]                     workers <- structure(as.integer(workers), 
[10:24:43.809]                       class = class(workers))
[10:24:43.809]                     stop_if_not(is.finite(workers), workers >= 
[10:24:43.809]                       1L)
[10:24:43.809]                     if ((workers == 1L && !inherits(workers, 
[10:24:43.809]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:24:43.809]                       if (default_workers) 
[10:24:43.809]                         supportsMulticore(warn = TRUE)
[10:24:43.809]                       return(sequential(..., envir = envir))
[10:24:43.809]                     }
[10:24:43.809]                     oopts <- options(mc.cores = workers)
[10:24:43.809]                     on.exit(options(oopts))
[10:24:43.809]                     future <- MulticoreFuture(..., workers = workers, 
[10:24:43.809]                       envir = envir)
[10:24:43.809]                     if (!future$lazy) 
[10:24:43.809]                       future <- run(future)
[10:24:43.809]                     invisible(future)
[10:24:43.809]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:43.809]                 }
[10:24:43.809]             }
[10:24:43.809]         }
[10:24:43.809]     })
[10:24:43.809]     if (FALSE) {
[10:24:43.809]         base::sink(type = "output", split = FALSE)
[10:24:43.809]         if (NA) {
[10:24:43.809]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:43.809]         }
[10:24:43.809]         else {
[10:24:43.809]             ...future.result["stdout"] <- base::list(NULL)
[10:24:43.809]         }
[10:24:43.809]         base::close(...future.stdout)
[10:24:43.809]         ...future.stdout <- NULL
[10:24:43.809]     }
[10:24:43.809]     ...future.result$conditions <- ...future.conditions
[10:24:43.809]     ...future.result$finished <- base::Sys.time()
[10:24:43.809]     ...future.result
[10:24:43.809] }
[10:24:43.813] assign_globals() ...
[10:24:43.813] List of 5
[10:24:43.813]  $ ...future.FUN            :function (x, y)  
[10:24:43.813]  $ MoreArgs                 : NULL
[10:24:43.813]  $ ...future.elements_ii    :List of 2
[10:24:43.813]   ..$ :List of 1
[10:24:43.813]   .. ..$ : int 0
[10:24:43.813]   ..$ :List of 1
[10:24:43.813]   .. ..$ : int 1
[10:24:43.813]  $ ...future.seeds_ii       : NULL
[10:24:43.813]  $ ...future.globals.maxSize: NULL
[10:24:43.813]  - attr(*, "where")=List of 5
[10:24:43.813]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:24:43.813]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:24:43.813]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:24:43.813]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:24:43.813]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:24:43.813]  - attr(*, "resolved")= logi FALSE
[10:24:43.813]  - attr(*, "total_size")= num 6368
[10:24:43.813]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:43.813]  - attr(*, "already-done")= logi TRUE
[10:24:43.825] - reassign environment for ‘...future.FUN’
[10:24:43.825] - copied ‘...future.FUN’ to environment
[10:24:43.825] - copied ‘MoreArgs’ to environment
[10:24:43.825] - copied ‘...future.elements_ii’ to environment
[10:24:43.825] - copied ‘...future.seeds_ii’ to environment
[10:24:43.826] - copied ‘...future.globals.maxSize’ to environment
[10:24:43.826] assign_globals() ... done
[10:24:43.826] requestCore(): workers = 2
[10:24:43.829] MulticoreFuture started
[10:24:43.829] - Launch lazy future ... done
[10:24:43.830] run() for ‘MulticoreFuture’ ... done
[10:24:43.830] plan(): Setting new future strategy stack:
[10:24:43.830] Created future:
[10:24:43.830] List of future strategies:
[10:24:43.830] 1. sequential:
[10:24:43.830]    - args: function (..., envir = parent.frame())
[10:24:43.830]    - tweaked: FALSE
[10:24:43.830]    - call: NULL
[10:24:43.832] plan(): nbrOfWorkers() = 1
[10:24:43.834] plan(): Setting new future strategy stack:
[10:24:43.835] List of future strategies:
[10:24:43.835] 1. multicore:
[10:24:43.835]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:43.835]    - tweaked: FALSE
[10:24:43.835]    - call: plan(strategy)
[10:24:43.841] plan(): nbrOfWorkers() = 2
[10:24:43.831] MulticoreFuture:
[10:24:43.831] Label: ‘future_mapply-2’
[10:24:43.831] Expression:
[10:24:43.831] {
[10:24:43.831]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:43.831]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:43.831]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:43.831]         on.exit(options(oopts), add = TRUE)
[10:24:43.831]     }
[10:24:43.831]     {
[10:24:43.831]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:43.831]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:24:43.831]         do.call(mapply, args = args)
[10:24:43.831]     }
[10:24:43.831] }
[10:24:43.831] Lazy evaluation: FALSE
[10:24:43.831] Asynchronous evaluation: TRUE
[10:24:43.831] Local evaluation: TRUE
[10:24:43.831] Environment: R_GlobalEnv
[10:24:43.831] Capture standard output: NA
[10:24:43.831] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:43.831] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:43.831] Packages: <none>
[10:24:43.831] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:43.831] Resolved: TRUE
[10:24:43.831] Value: <not collected>
[10:24:43.831] Conditions captured: <none>
[10:24:43.831] Early signaling: FALSE
[10:24:43.831] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:43.831] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:43.842] Chunk #2 of 2 ... DONE
[10:24:43.842] Launching 2 futures (chunks) ... DONE
[10:24:43.842] Resolving 2 futures (chunks) ...
[10:24:43.843] resolve() on list ...
[10:24:43.843]  recursive: 0
[10:24:43.843]  length: 2
[10:24:43.843] 
[10:24:43.854] Future #2
[10:24:43.854] result() for MulticoreFuture ...
[10:24:43.855] result() for MulticoreFuture ...
[10:24:43.855] result() for MulticoreFuture ... done
[10:24:43.855] result() for MulticoreFuture ... done
[10:24:43.856] result() for MulticoreFuture ...
[10:24:43.856] result() for MulticoreFuture ... done
[10:24:43.856] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:24:43.856] - nx: 2
[10:24:43.856] - relay: TRUE
[10:24:43.857] - stdout: TRUE
[10:24:43.857] - signal: TRUE
[10:24:43.857] - resignal: FALSE
[10:24:43.857] - force: TRUE
[10:24:43.857] - relayed: [n=2] FALSE, FALSE
[10:24:43.857] - queued futures: [n=2] FALSE, FALSE
[10:24:43.858]  - until=1
[10:24:43.858]  - relaying element #1
[10:24:43.858] - relayed: [n=2] FALSE, FALSE
[10:24:43.858] - queued futures: [n=2] FALSE, TRUE
[10:24:43.858] signalConditionsASAP(NULL, pos=2) ... done
[10:24:43.858]  length: 1 (resolved future 2)
[10:24:44.283] plan(): Setting new future strategy stack:
[10:24:44.283] List of future strategies:
[10:24:44.283] 1. multicore:
[10:24:44.283]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:24:44.283]    - tweaked: FALSE
[10:24:44.283]    - call: plan(strategy)
[10:24:44.288] plan(): nbrOfWorkers() = 2
[10:24:44.296] Future #1
[10:24:44.296] result() for MulticoreFuture ...
[10:24:44.297] result() for MulticoreFuture ...
[10:24:44.297] result() for MulticoreFuture ... done
[10:24:44.298] result() for MulticoreFuture ... done
[10:24:44.298] result() for MulticoreFuture ...
[10:24:44.298] result() for MulticoreFuture ... done
[10:24:44.298] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:24:44.298] - nx: 2
[10:24:44.298] - relay: TRUE
[10:24:44.299] - stdout: TRUE
[10:24:44.299] - signal: TRUE
[10:24:44.299] - resignal: FALSE
[10:24:44.299] - force: TRUE
[10:24:44.299] - relayed: [n=2] FALSE, FALSE
[10:24:44.299] - queued futures: [n=2] FALSE, TRUE
[10:24:44.299]  - until=1
[10:24:44.300]  - relaying element #1
[10:24:44.300] result() for MulticoreFuture ...
[10:24:44.300] result() for MulticoreFuture ... done
[10:24:44.300] result() for MulticoreFuture ...
[10:24:44.300] result() for MulticoreFuture ... done
[10:24:44.300] result() for MulticoreFuture ...
[10:24:44.301] result() for MulticoreFuture ... done
[10:24:44.301] result() for MulticoreFuture ...
[10:24:44.301] result() for MulticoreFuture ... done
[10:24:44.301] - relayed: [n=2] TRUE, FALSE
[10:24:44.301] - queued futures: [n=2] TRUE, TRUE
[10:24:44.301] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:24:44.301]  length: 0 (resolved future 1)
[10:24:44.302] Relaying remaining futures
[10:24:44.302] signalConditionsASAP(NULL, pos=0) ...
[10:24:44.302] - nx: 2
[10:24:44.302] - relay: TRUE
[10:24:44.302] - stdout: TRUE
[10:24:44.302] - signal: TRUE
[10:24:44.302] - resignal: FALSE
[10:24:44.302] - force: TRUE
[10:24:44.303] - relayed: [n=2] TRUE, FALSE
[10:24:44.303] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:44.303]  - relaying element #2
[10:24:44.303] result() for MulticoreFuture ...
[10:24:44.303] result() for MulticoreFuture ... done
[10:24:44.303] result() for MulticoreFuture ...
[10:24:44.303] result() for MulticoreFuture ... done
[10:24:44.304] result() for MulticoreFuture ...
[10:24:44.304] result() for MulticoreFuture ... done
[10:24:44.304] result() for MulticoreFuture ...
[10:24:44.304] result() for MulticoreFuture ... done
[10:24:44.304] - relayed: [n=2] TRUE, TRUE
[10:24:44.304] - queued futures: [n=2] TRUE, TRUE
[10:24:44.304] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[10:24:44.304] resolve() on list ... DONE
[10:24:44.304] result() for MulticoreFuture ...
[10:24:44.305] result() for MulticoreFuture ... done
[10:24:44.305] result() for MulticoreFuture ...
[10:24:44.305] result() for MulticoreFuture ... done
[10:24:44.305] result() for MulticoreFuture ...
[10:24:44.305] result() for MulticoreFuture ... done
[10:24:44.305] result() for MulticoreFuture ...
[10:24:44.305] result() for MulticoreFuture ... done
[10:24:44.305]  - Number of value chunks collected: 2
[10:24:44.305] Resolving 2 futures (chunks) ... DONE
[10:24:44.306] Reducing values from 2 chunks ...
[10:24:44.306]  - Number of values collected after concatenation: 2
[10:24:44.306]  - Number of values expected: 2
[10:24:44.306] Reducing values from 2 chunks ... DONE
[10:24:44.306] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[10:24:44.307] plan(): Setting new future strategy stack:
[10:24:44.307] List of future strategies:
[10:24:44.307] 1. multisession:
[10:24:44.307]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:24:44.307]    - tweaked: FALSE
[10:24:44.307]    - call: plan(strategy)
[10:24:44.307] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:24:44.307] multisession:
[10:24:44.307] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:24:44.307] - tweaked: FALSE
[10:24:44.307] - call: plan(strategy)
[10:24:44.314] getGlobalsAndPackages() ...
[10:24:44.314] Not searching for globals
[10:24:44.314] - globals: [0] <none>
[10:24:44.314] getGlobalsAndPackages() ... DONE
[10:24:44.315] [local output] makeClusterPSOCK() ...
[10:24:44.358] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:24:44.360] [local output] Base port: 11862
[10:24:44.360] [local output] Getting setup options for 2 cluster nodes ...
[10:24:44.360] [local output]  - Node 1 of 2 ...
[10:24:44.360] [local output] localMachine=TRUE => revtunnel=FALSE

[10:24:44.361] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp5boaqN/worker.rank=1.parallelly.parent=79154.13532174d5fd6.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp5boaqN/worker.rank=1.parallelly.parent=79154.13532174d5fd6.pid")'’
[10:24:44.552] - Possible to infer worker's PID: TRUE
[10:24:44.552] [local output] Rscript port: 11862

[10:24:44.552] [local output]  - Node 2 of 2 ...
[10:24:44.553] [local output] localMachine=TRUE => revtunnel=FALSE

[10:24:44.553] [local output] Rscript port: 11862

[10:24:44.554] [local output] Getting setup options for 2 cluster nodes ... done
[10:24:44.554] [local output]  - Parallel setup requested for some PSOCK nodes
[10:24:44.554] [local output] Setting up PSOCK nodes in parallel
[10:24:44.555] List of 36
[10:24:44.555]  $ worker          : chr "localhost"
[10:24:44.555]   ..- attr(*, "localhost")= logi TRUE
[10:24:44.555]  $ master          : chr "localhost"
[10:24:44.555]  $ port            : int 11862
[10:24:44.555]  $ connectTimeout  : num 120
[10:24:44.555]  $ timeout         : num 2592000
[10:24:44.555]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:24:44.555]  $ homogeneous     : logi TRUE
[10:24:44.555]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:24:44.555]  $ rscript_envs    : NULL
[10:24:44.555]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:24:44.555]  $ rscript_startup : NULL
[10:24:44.555]  $ rscript_sh      : chr "sh"
[10:24:44.555]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:24:44.555]  $ methods         : logi TRUE
[10:24:44.555]  $ socketOptions   : chr "no-delay"
[10:24:44.555]  $ useXDR          : logi FALSE
[10:24:44.555]  $ outfile         : chr "/dev/null"
[10:24:44.555]  $ renice          : int NA
[10:24:44.555]  $ rshcmd          : NULL
[10:24:44.555]  $ user            : chr(0) 
[10:24:44.555]  $ revtunnel       : logi FALSE
[10:24:44.555]  $ rshlogfile      : NULL
[10:24:44.555]  $ rshopts         : chr(0) 
[10:24:44.555]  $ rank            : int 1
[10:24:44.555]  $ manual          : logi FALSE
[10:24:44.555]  $ dryrun          : logi FALSE
[10:24:44.555]  $ quiet           : logi FALSE
[10:24:44.555]  $ setup_strategy  : chr "parallel"
[10:24:44.555]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:24:44.555]  $ pidfile         : chr "/tmp/Rtmp5boaqN/worker.rank=1.parallelly.parent=79154.13532174d5fd6.pid"
[10:24:44.555]  $ rshcmd_label    : NULL
[10:24:44.555]  $ rsh_call        : NULL
[10:24:44.555]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:24:44.555]  $ localMachine    : logi TRUE
[10:24:44.555]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:24:44.555]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:24:44.555]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:24:44.555]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:24:44.555]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:24:44.555]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:24:44.555]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:24:44.555]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:24:44.555]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:24:44.555]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:24:44.555]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:24:44.555]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:24:44.555]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:24:44.555]  $ arguments       :List of 28
[10:24:44.555]   ..$ worker          : chr "localhost"
[10:24:44.555]   ..$ master          : NULL
[10:24:44.555]   ..$ port            : int 11862
[10:24:44.555]   ..$ connectTimeout  : num 120
[10:24:44.555]   ..$ timeout         : num 2592000
[10:24:44.555]   ..$ rscript         : NULL
[10:24:44.555]   ..$ homogeneous     : NULL
[10:24:44.555]   ..$ rscript_args    : NULL
[10:24:44.555]   ..$ rscript_envs    : NULL
[10:24:44.555]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:24:44.555]   ..$ rscript_startup : NULL
[10:24:44.555]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:24:44.555]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:24:44.555]   ..$ methods         : logi TRUE
[10:24:44.555]   ..$ socketOptions   : chr "no-delay"
[10:24:44.555]   ..$ useXDR          : logi FALSE
[10:24:44.555]   ..$ outfile         : chr "/dev/null"
[10:24:44.555]   ..$ renice          : int NA
[10:24:44.555]   ..$ rshcmd          : NULL
[10:24:44.555]   ..$ user            : NULL
[10:24:44.555]   ..$ revtunnel       : logi NA
[10:24:44.555]   ..$ rshlogfile      : NULL
[10:24:44.555]   ..$ rshopts         : NULL
[10:24:44.555]   ..$ rank            : int 1
[10:24:44.555]   ..$ manual          : logi FALSE
[10:24:44.555]   ..$ dryrun          : logi FALSE
[10:24:44.555]   ..$ quiet           : logi FALSE
[10:24:44.555]   ..$ setup_strategy  : chr "parallel"
[10:24:44.555]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:24:44.572] [local output] System call to launch all workers:
[10:24:44.572] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp5boaqN/worker.rank=1.parallelly.parent=79154.13532174d5fd6.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11862 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:24:44.572] [local output] Starting PSOCK main server
[10:24:44.578] [local output] Workers launched
[10:24:44.578] [local output] Waiting for workers to connect back
[10:24:44.578]  - [local output] 0 workers out of 2 ready
[10:24:44.826]  - [local output] 0 workers out of 2 ready
[10:24:44.826]  - [local output] 1 workers out of 2 ready
[10:24:44.827]  - [local output] 2 workers out of 2 ready
[10:24:44.827] [local output] Launching of workers completed
[10:24:44.827] [local output] Collecting session information from workers
[10:24:44.828] [local output]  - Worker #1 of 2
[10:24:44.828] [local output]  - Worker #2 of 2
[10:24:44.828] [local output] makeClusterPSOCK() ... done
[10:24:44.840] Packages needed by the future expression (n = 0): <none>
[10:24:44.840] Packages needed by future strategies (n = 0): <none>
[10:24:44.841] {
[10:24:44.841]     {
[10:24:44.841]         {
[10:24:44.841]             ...future.startTime <- base::Sys.time()
[10:24:44.841]             {
[10:24:44.841]                 {
[10:24:44.841]                   {
[10:24:44.841]                     {
[10:24:44.841]                       base::local({
[10:24:44.841]                         has_future <- base::requireNamespace("future", 
[10:24:44.841]                           quietly = TRUE)
[10:24:44.841]                         if (has_future) {
[10:24:44.841]                           ns <- base::getNamespace("future")
[10:24:44.841]                           version <- ns[[".package"]][["version"]]
[10:24:44.841]                           if (is.null(version)) 
[10:24:44.841]                             version <- utils::packageVersion("future")
[10:24:44.841]                         }
[10:24:44.841]                         else {
[10:24:44.841]                           version <- NULL
[10:24:44.841]                         }
[10:24:44.841]                         if (!has_future || version < "1.8.0") {
[10:24:44.841]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:44.841]                             "", base::R.version$version.string), 
[10:24:44.841]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:44.841]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:44.841]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:44.841]                               "release", "version")], collapse = " "), 
[10:24:44.841]                             hostname = base::Sys.info()[["nodename"]])
[10:24:44.841]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:44.841]                             info)
[10:24:44.841]                           info <- base::paste(info, collapse = "; ")
[10:24:44.841]                           if (!has_future) {
[10:24:44.841]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:44.841]                               info)
[10:24:44.841]                           }
[10:24:44.841]                           else {
[10:24:44.841]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:44.841]                               info, version)
[10:24:44.841]                           }
[10:24:44.841]                           base::stop(msg)
[10:24:44.841]                         }
[10:24:44.841]                       })
[10:24:44.841]                     }
[10:24:44.841]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:44.841]                     base::options(mc.cores = 1L)
[10:24:44.841]                   }
[10:24:44.841]                   options(future.plan = NULL)
[10:24:44.841]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:44.841]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:44.841]                 }
[10:24:44.841]                 ...future.workdir <- getwd()
[10:24:44.841]             }
[10:24:44.841]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:44.841]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:44.841]         }
[10:24:44.841]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:44.841]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:24:44.841]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:44.841]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:44.841]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:44.841]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:44.841]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:44.841]             base::names(...future.oldOptions))
[10:24:44.841]     }
[10:24:44.841]     if (FALSE) {
[10:24:44.841]     }
[10:24:44.841]     else {
[10:24:44.841]         if (TRUE) {
[10:24:44.841]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:44.841]                 open = "w")
[10:24:44.841]         }
[10:24:44.841]         else {
[10:24:44.841]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:44.841]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:44.841]         }
[10:24:44.841]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:44.841]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:44.841]             base::sink(type = "output", split = FALSE)
[10:24:44.841]             base::close(...future.stdout)
[10:24:44.841]         }, add = TRUE)
[10:24:44.841]     }
[10:24:44.841]     ...future.frame <- base::sys.nframe()
[10:24:44.841]     ...future.conditions <- base::list()
[10:24:44.841]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:44.841]     if (FALSE) {
[10:24:44.841]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:44.841]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:44.841]     }
[10:24:44.841]     ...future.result <- base::tryCatch({
[10:24:44.841]         base::withCallingHandlers({
[10:24:44.841]             ...future.value <- base::withVisible(base::local({
[10:24:44.841]                 ...future.makeSendCondition <- base::local({
[10:24:44.841]                   sendCondition <- NULL
[10:24:44.841]                   function(frame = 1L) {
[10:24:44.841]                     if (is.function(sendCondition)) 
[10:24:44.841]                       return(sendCondition)
[10:24:44.841]                     ns <- getNamespace("parallel")
[10:24:44.841]                     if (exists("sendData", mode = "function", 
[10:24:44.841]                       envir = ns)) {
[10:24:44.841]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:44.841]                         envir = ns)
[10:24:44.841]                       envir <- sys.frame(frame)
[10:24:44.841]                       master <- NULL
[10:24:44.841]                       while (!identical(envir, .GlobalEnv) && 
[10:24:44.841]                         !identical(envir, emptyenv())) {
[10:24:44.841]                         if (exists("master", mode = "list", envir = envir, 
[10:24:44.841]                           inherits = FALSE)) {
[10:24:44.841]                           master <- get("master", mode = "list", 
[10:24:44.841]                             envir = envir, inherits = FALSE)
[10:24:44.841]                           if (inherits(master, c("SOCKnode", 
[10:24:44.841]                             "SOCK0node"))) {
[10:24:44.841]                             sendCondition <<- function(cond) {
[10:24:44.841]                               data <- list(type = "VALUE", value = cond, 
[10:24:44.841]                                 success = TRUE)
[10:24:44.841]                               parallel_sendData(master, data)
[10:24:44.841]                             }
[10:24:44.841]                             return(sendCondition)
[10:24:44.841]                           }
[10:24:44.841]                         }
[10:24:44.841]                         frame <- frame + 1L
[10:24:44.841]                         envir <- sys.frame(frame)
[10:24:44.841]                       }
[10:24:44.841]                     }
[10:24:44.841]                     sendCondition <<- function(cond) NULL
[10:24:44.841]                   }
[10:24:44.841]                 })
[10:24:44.841]                 withCallingHandlers({
[10:24:44.841]                   NA
[10:24:44.841]                 }, immediateCondition = function(cond) {
[10:24:44.841]                   sendCondition <- ...future.makeSendCondition()
[10:24:44.841]                   sendCondition(cond)
[10:24:44.841]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:44.841]                   {
[10:24:44.841]                     inherits <- base::inherits
[10:24:44.841]                     invokeRestart <- base::invokeRestart
[10:24:44.841]                     is.null <- base::is.null
[10:24:44.841]                     muffled <- FALSE
[10:24:44.841]                     if (inherits(cond, "message")) {
[10:24:44.841]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:44.841]                       if (muffled) 
[10:24:44.841]                         invokeRestart("muffleMessage")
[10:24:44.841]                     }
[10:24:44.841]                     else if (inherits(cond, "warning")) {
[10:24:44.841]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:44.841]                       if (muffled) 
[10:24:44.841]                         invokeRestart("muffleWarning")
[10:24:44.841]                     }
[10:24:44.841]                     else if (inherits(cond, "condition")) {
[10:24:44.841]                       if (!is.null(pattern)) {
[10:24:44.841]                         computeRestarts <- base::computeRestarts
[10:24:44.841]                         grepl <- base::grepl
[10:24:44.841]                         restarts <- computeRestarts(cond)
[10:24:44.841]                         for (restart in restarts) {
[10:24:44.841]                           name <- restart$name
[10:24:44.841]                           if (is.null(name)) 
[10:24:44.841]                             next
[10:24:44.841]                           if (!grepl(pattern, name)) 
[10:24:44.841]                             next
[10:24:44.841]                           invokeRestart(restart)
[10:24:44.841]                           muffled <- TRUE
[10:24:44.841]                           break
[10:24:44.841]                         }
[10:24:44.841]                       }
[10:24:44.841]                     }
[10:24:44.841]                     invisible(muffled)
[10:24:44.841]                   }
[10:24:44.841]                   muffleCondition(cond)
[10:24:44.841]                 })
[10:24:44.841]             }))
[10:24:44.841]             future::FutureResult(value = ...future.value$value, 
[10:24:44.841]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:44.841]                   ...future.rng), globalenv = if (FALSE) 
[10:24:44.841]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:44.841]                     ...future.globalenv.names))
[10:24:44.841]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:44.841]         }, condition = base::local({
[10:24:44.841]             c <- base::c
[10:24:44.841]             inherits <- base::inherits
[10:24:44.841]             invokeRestart <- base::invokeRestart
[10:24:44.841]             length <- base::length
[10:24:44.841]             list <- base::list
[10:24:44.841]             seq.int <- base::seq.int
[10:24:44.841]             signalCondition <- base::signalCondition
[10:24:44.841]             sys.calls <- base::sys.calls
[10:24:44.841]             `[[` <- base::`[[`
[10:24:44.841]             `+` <- base::`+`
[10:24:44.841]             `<<-` <- base::`<<-`
[10:24:44.841]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:44.841]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:44.841]                   3L)]
[10:24:44.841]             }
[10:24:44.841]             function(cond) {
[10:24:44.841]                 is_error <- inherits(cond, "error")
[10:24:44.841]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:44.841]                   NULL)
[10:24:44.841]                 if (is_error) {
[10:24:44.841]                   sessionInformation <- function() {
[10:24:44.841]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:44.841]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:44.841]                       search = base::search(), system = base::Sys.info())
[10:24:44.841]                   }
[10:24:44.841]                   ...future.conditions[[length(...future.conditions) + 
[10:24:44.841]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:44.841]                     cond$call), session = sessionInformation(), 
[10:24:44.841]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:44.841]                   signalCondition(cond)
[10:24:44.841]                 }
[10:24:44.841]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:44.841]                 "immediateCondition"))) {
[10:24:44.841]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:44.841]                   ...future.conditions[[length(...future.conditions) + 
[10:24:44.841]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:44.841]                   if (TRUE && !signal) {
[10:24:44.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:44.841]                     {
[10:24:44.841]                       inherits <- base::inherits
[10:24:44.841]                       invokeRestart <- base::invokeRestart
[10:24:44.841]                       is.null <- base::is.null
[10:24:44.841]                       muffled <- FALSE
[10:24:44.841]                       if (inherits(cond, "message")) {
[10:24:44.841]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:44.841]                         if (muffled) 
[10:24:44.841]                           invokeRestart("muffleMessage")
[10:24:44.841]                       }
[10:24:44.841]                       else if (inherits(cond, "warning")) {
[10:24:44.841]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:44.841]                         if (muffled) 
[10:24:44.841]                           invokeRestart("muffleWarning")
[10:24:44.841]                       }
[10:24:44.841]                       else if (inherits(cond, "condition")) {
[10:24:44.841]                         if (!is.null(pattern)) {
[10:24:44.841]                           computeRestarts <- base::computeRestarts
[10:24:44.841]                           grepl <- base::grepl
[10:24:44.841]                           restarts <- computeRestarts(cond)
[10:24:44.841]                           for (restart in restarts) {
[10:24:44.841]                             name <- restart$name
[10:24:44.841]                             if (is.null(name)) 
[10:24:44.841]                               next
[10:24:44.841]                             if (!grepl(pattern, name)) 
[10:24:44.841]                               next
[10:24:44.841]                             invokeRestart(restart)
[10:24:44.841]                             muffled <- TRUE
[10:24:44.841]                             break
[10:24:44.841]                           }
[10:24:44.841]                         }
[10:24:44.841]                       }
[10:24:44.841]                       invisible(muffled)
[10:24:44.841]                     }
[10:24:44.841]                     muffleCondition(cond, pattern = "^muffle")
[10:24:44.841]                   }
[10:24:44.841]                 }
[10:24:44.841]                 else {
[10:24:44.841]                   if (TRUE) {
[10:24:44.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:44.841]                     {
[10:24:44.841]                       inherits <- base::inherits
[10:24:44.841]                       invokeRestart <- base::invokeRestart
[10:24:44.841]                       is.null <- base::is.null
[10:24:44.841]                       muffled <- FALSE
[10:24:44.841]                       if (inherits(cond, "message")) {
[10:24:44.841]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:44.841]                         if (muffled) 
[10:24:44.841]                           invokeRestart("muffleMessage")
[10:24:44.841]                       }
[10:24:44.841]                       else if (inherits(cond, "warning")) {
[10:24:44.841]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:44.841]                         if (muffled) 
[10:24:44.841]                           invokeRestart("muffleWarning")
[10:24:44.841]                       }
[10:24:44.841]                       else if (inherits(cond, "condition")) {
[10:24:44.841]                         if (!is.null(pattern)) {
[10:24:44.841]                           computeRestarts <- base::computeRestarts
[10:24:44.841]                           grepl <- base::grepl
[10:24:44.841]                           restarts <- computeRestarts(cond)
[10:24:44.841]                           for (restart in restarts) {
[10:24:44.841]                             name <- restart$name
[10:24:44.841]                             if (is.null(name)) 
[10:24:44.841]                               next
[10:24:44.841]                             if (!grepl(pattern, name)) 
[10:24:44.841]                               next
[10:24:44.841]                             invokeRestart(restart)
[10:24:44.841]                             muffled <- TRUE
[10:24:44.841]                             break
[10:24:44.841]                           }
[10:24:44.841]                         }
[10:24:44.841]                       }
[10:24:44.841]                       invisible(muffled)
[10:24:44.841]                     }
[10:24:44.841]                     muffleCondition(cond, pattern = "^muffle")
[10:24:44.841]                   }
[10:24:44.841]                 }
[10:24:44.841]             }
[10:24:44.841]         }))
[10:24:44.841]     }, error = function(ex) {
[10:24:44.841]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:44.841]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:44.841]                 ...future.rng), started = ...future.startTime, 
[10:24:44.841]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:44.841]             version = "1.8"), class = "FutureResult")
[10:24:44.841]     }, finally = {
[10:24:44.841]         if (!identical(...future.workdir, getwd())) 
[10:24:44.841]             setwd(...future.workdir)
[10:24:44.841]         {
[10:24:44.841]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:44.841]                 ...future.oldOptions$nwarnings <- NULL
[10:24:44.841]             }
[10:24:44.841]             base::options(...future.oldOptions)
[10:24:44.841]             if (.Platform$OS.type == "windows") {
[10:24:44.841]                 old_names <- names(...future.oldEnvVars)
[10:24:44.841]                 envs <- base::Sys.getenv()
[10:24:44.841]                 names <- names(envs)
[10:24:44.841]                 common <- intersect(names, old_names)
[10:24:44.841]                 added <- setdiff(names, old_names)
[10:24:44.841]                 removed <- setdiff(old_names, names)
[10:24:44.841]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:44.841]                   envs[common]]
[10:24:44.841]                 NAMES <- toupper(changed)
[10:24:44.841]                 args <- list()
[10:24:44.841]                 for (kk in seq_along(NAMES)) {
[10:24:44.841]                   name <- changed[[kk]]
[10:24:44.841]                   NAME <- NAMES[[kk]]
[10:24:44.841]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:44.841]                     next
[10:24:44.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:44.841]                 }
[10:24:44.841]                 NAMES <- toupper(added)
[10:24:44.841]                 for (kk in seq_along(NAMES)) {
[10:24:44.841]                   name <- added[[kk]]
[10:24:44.841]                   NAME <- NAMES[[kk]]
[10:24:44.841]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:44.841]                     next
[10:24:44.841]                   args[[name]] <- ""
[10:24:44.841]                 }
[10:24:44.841]                 NAMES <- toupper(removed)
[10:24:44.841]                 for (kk in seq_along(NAMES)) {
[10:24:44.841]                   name <- removed[[kk]]
[10:24:44.841]                   NAME <- NAMES[[kk]]
[10:24:44.841]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:44.841]                     next
[10:24:44.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:44.841]                 }
[10:24:44.841]                 if (length(args) > 0) 
[10:24:44.841]                   base::do.call(base::Sys.setenv, args = args)
[10:24:44.841]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:44.841]             }
[10:24:44.841]             else {
[10:24:44.841]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:44.841]             }
[10:24:44.841]             {
[10:24:44.841]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:44.841]                   0L) {
[10:24:44.841]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:44.841]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:44.841]                   base::options(opts)
[10:24:44.841]                 }
[10:24:44.841]                 {
[10:24:44.841]                   {
[10:24:44.841]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:44.841]                     NULL
[10:24:44.841]                   }
[10:24:44.841]                   options(future.plan = NULL)
[10:24:44.841]                   if (is.na(NA_character_)) 
[10:24:44.841]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:44.841]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:44.841]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:44.841]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:44.841]                     envir = parent.frame()) 
[10:24:44.841]                   {
[10:24:44.841]                     if (is.function(workers)) 
[10:24:44.841]                       workers <- workers()
[10:24:44.841]                     workers <- structure(as.integer(workers), 
[10:24:44.841]                       class = class(workers))
[10:24:44.841]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:44.841]                       workers >= 1)
[10:24:44.841]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:44.841]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:44.841]                     }
[10:24:44.841]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:44.841]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:44.841]                       envir = envir)
[10:24:44.841]                     if (!future$lazy) 
[10:24:44.841]                       future <- run(future)
[10:24:44.841]                     invisible(future)
[10:24:44.841]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:44.841]                 }
[10:24:44.841]             }
[10:24:44.841]         }
[10:24:44.841]     })
[10:24:44.841]     if (TRUE) {
[10:24:44.841]         base::sink(type = "output", split = FALSE)
[10:24:44.841]         if (TRUE) {
[10:24:44.841]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:44.841]         }
[10:24:44.841]         else {
[10:24:44.841]             ...future.result["stdout"] <- base::list(NULL)
[10:24:44.841]         }
[10:24:44.841]         base::close(...future.stdout)
[10:24:44.841]         ...future.stdout <- NULL
[10:24:44.841]     }
[10:24:44.841]     ...future.result$conditions <- ...future.conditions
[10:24:44.841]     ...future.result$finished <- base::Sys.time()
[10:24:44.841]     ...future.result
[10:24:44.841] }
[10:24:44.895] MultisessionFuture started
[10:24:44.896] result() for ClusterFuture ...
[10:24:44.897] receiveMessageFromWorker() for ClusterFuture ...
[10:24:44.897] - Validating connection of MultisessionFuture
[10:24:44.941] - received message: FutureResult
[10:24:44.941] - Received FutureResult
[10:24:44.942] - Erased future from FutureRegistry
[10:24:44.942] result() for ClusterFuture ...
[10:24:44.942] - result already collected: FutureResult
[10:24:44.942] result() for ClusterFuture ... done
[10:24:44.942] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:44.942] result() for ClusterFuture ... done
[10:24:44.942] result() for ClusterFuture ...
[10:24:44.942] - result already collected: FutureResult
[10:24:44.943] result() for ClusterFuture ... done
[10:24:44.943] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:24:44.946] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[10:24:44.947] future_lapply() ...
[10:24:44.951] Number of chunks: 2
[10:24:44.951] getGlobalsAndPackagesXApply() ...
[10:24:44.951]  - future.globals: TRUE
[10:24:44.952] getGlobalsAndPackages() ...
[10:24:44.952] Searching for globals...
[10:24:44.953] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:24:44.954] Searching for globals ... DONE
[10:24:44.954] Resolving globals: FALSE
[10:24:44.954] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[10:24:44.955] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[10:24:44.955] - globals: [1] ‘FUN’
[10:24:44.955] 
[10:24:44.955] getGlobalsAndPackages() ... DONE
[10:24:44.955]  - globals found/used: [n=1] ‘FUN’
[10:24:44.955]  - needed namespaces: [n=0] 
[10:24:44.955] Finding globals ... DONE
[10:24:44.956]  - use_args: TRUE
[10:24:44.956]  - Getting '...' globals ...
[10:24:44.956] resolve() on list ...
[10:24:44.956]  recursive: 0
[10:24:44.956]  length: 1
[10:24:44.956]  elements: ‘...’
[10:24:44.957]  length: 0 (resolved future 1)
[10:24:44.957] resolve() on list ... DONE
[10:24:44.957]    - '...' content: [n=0] 
[10:24:44.957] List of 1
[10:24:44.957]  $ ...: list()
[10:24:44.957]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:44.957]  - attr(*, "where")=List of 1
[10:24:44.957]   ..$ ...:<environment: 0x55d2125f1c78> 
[10:24:44.957]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:44.957]  - attr(*, "resolved")= logi TRUE
[10:24:44.957]  - attr(*, "total_size")= num NA
[10:24:44.960]  - Getting '...' globals ... DONE
[10:24:44.960] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:24:44.961] List of 2
[10:24:44.961]  $ ...future.FUN:function (x)  
[10:24:44.961]  $ ...          : list()
[10:24:44.961]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:44.961]  - attr(*, "where")=List of 2
[10:24:44.961]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:44.961]   ..$ ...          :<environment: 0x55d2125f1c78> 
[10:24:44.961]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:44.961]  - attr(*, "resolved")= logi FALSE
[10:24:44.961]  - attr(*, "total_size")= num 4720
[10:24:44.964] Packages to be attached in all futures: [n=0] 
[10:24:44.964] getGlobalsAndPackagesXApply() ... DONE
[10:24:44.964] Number of futures (= number of chunks): 2
[10:24:44.965] Launching 2 futures (chunks) ...
[10:24:44.965] Chunk #1 of 2 ...
[10:24:44.965]  - Finding globals in 'X' for chunk #1 ...
[10:24:44.965] getGlobalsAndPackages() ...
[10:24:44.965] Searching for globals...
[10:24:44.965] 
[10:24:44.966] Searching for globals ... DONE
[10:24:44.966] - globals: [0] <none>
[10:24:44.966] getGlobalsAndPackages() ... DONE
[10:24:44.966]    + additional globals found: [n=0] 
[10:24:44.966]    + additional namespaces needed: [n=0] 
[10:24:44.966]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:44.966]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:44.966]  - seeds: <none>
[10:24:44.966]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:44.967] getGlobalsAndPackages() ...
[10:24:44.967] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:44.967] Resolving globals: FALSE
[10:24:44.967] Tweak future expression to call with '...' arguments ...
[10:24:44.967] {
[10:24:44.967]     do.call(function(...) {
[10:24:44.967]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:44.967]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:44.967]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:44.967]             on.exit(options(oopts), add = TRUE)
[10:24:44.967]         }
[10:24:44.967]         {
[10:24:44.967]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:44.967]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:44.967]                 ...future.FUN(...future.X_jj, ...)
[10:24:44.967]             })
[10:24:44.967]         }
[10:24:44.967]     }, args = future.call.arguments)
[10:24:44.967] }
[10:24:44.967] Tweak future expression to call with '...' arguments ... DONE
[10:24:44.968] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:44.968] 
[10:24:44.968] getGlobalsAndPackages() ... DONE
[10:24:44.968] run() for ‘Future’ ...
[10:24:44.969] - state: ‘created’
[10:24:44.969] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:44.983] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:44.983] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:44.983]   - Field: ‘node’
[10:24:44.983]   - Field: ‘label’
[10:24:44.984]   - Field: ‘local’
[10:24:44.984]   - Field: ‘owner’
[10:24:44.984]   - Field: ‘envir’
[10:24:44.984]   - Field: ‘workers’
[10:24:44.984]   - Field: ‘packages’
[10:24:44.984]   - Field: ‘gc’
[10:24:44.984]   - Field: ‘conditions’
[10:24:44.984]   - Field: ‘persistent’
[10:24:44.984]   - Field: ‘expr’
[10:24:44.984]   - Field: ‘uuid’
[10:24:44.985]   - Field: ‘seed’
[10:24:44.985]   - Field: ‘version’
[10:24:44.985]   - Field: ‘result’
[10:24:44.985]   - Field: ‘asynchronous’
[10:24:44.985]   - Field: ‘calls’
[10:24:44.985]   - Field: ‘globals’
[10:24:44.985]   - Field: ‘stdout’
[10:24:44.985]   - Field: ‘earlySignal’
[10:24:44.986]   - Field: ‘lazy’
[10:24:44.986]   - Field: ‘state’
[10:24:44.986] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:44.986] - Launch lazy future ...
[10:24:44.986] Packages needed by the future expression (n = 0): <none>
[10:24:44.986] Packages needed by future strategies (n = 0): <none>
[10:24:44.987] {
[10:24:44.987]     {
[10:24:44.987]         {
[10:24:44.987]             ...future.startTime <- base::Sys.time()
[10:24:44.987]             {
[10:24:44.987]                 {
[10:24:44.987]                   {
[10:24:44.987]                     {
[10:24:44.987]                       base::local({
[10:24:44.987]                         has_future <- base::requireNamespace("future", 
[10:24:44.987]                           quietly = TRUE)
[10:24:44.987]                         if (has_future) {
[10:24:44.987]                           ns <- base::getNamespace("future")
[10:24:44.987]                           version <- ns[[".package"]][["version"]]
[10:24:44.987]                           if (is.null(version)) 
[10:24:44.987]                             version <- utils::packageVersion("future")
[10:24:44.987]                         }
[10:24:44.987]                         else {
[10:24:44.987]                           version <- NULL
[10:24:44.987]                         }
[10:24:44.987]                         if (!has_future || version < "1.8.0") {
[10:24:44.987]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:44.987]                             "", base::R.version$version.string), 
[10:24:44.987]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:44.987]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:44.987]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:44.987]                               "release", "version")], collapse = " "), 
[10:24:44.987]                             hostname = base::Sys.info()[["nodename"]])
[10:24:44.987]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:44.987]                             info)
[10:24:44.987]                           info <- base::paste(info, collapse = "; ")
[10:24:44.987]                           if (!has_future) {
[10:24:44.987]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:44.987]                               info)
[10:24:44.987]                           }
[10:24:44.987]                           else {
[10:24:44.987]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:44.987]                               info, version)
[10:24:44.987]                           }
[10:24:44.987]                           base::stop(msg)
[10:24:44.987]                         }
[10:24:44.987]                       })
[10:24:44.987]                     }
[10:24:44.987]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:44.987]                     base::options(mc.cores = 1L)
[10:24:44.987]                   }
[10:24:44.987]                   options(future.plan = NULL)
[10:24:44.987]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:44.987]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:44.987]                 }
[10:24:44.987]                 ...future.workdir <- getwd()
[10:24:44.987]             }
[10:24:44.987]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:44.987]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:44.987]         }
[10:24:44.987]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:44.987]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:44.987]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:44.987]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:44.987]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:44.987]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:44.987]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:44.987]             base::names(...future.oldOptions))
[10:24:44.987]     }
[10:24:44.987]     if (FALSE) {
[10:24:44.987]     }
[10:24:44.987]     else {
[10:24:44.987]         if (FALSE) {
[10:24:44.987]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:44.987]                 open = "w")
[10:24:44.987]         }
[10:24:44.987]         else {
[10:24:44.987]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:44.987]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:44.987]         }
[10:24:44.987]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:44.987]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:44.987]             base::sink(type = "output", split = FALSE)
[10:24:44.987]             base::close(...future.stdout)
[10:24:44.987]         }, add = TRUE)
[10:24:44.987]     }
[10:24:44.987]     ...future.frame <- base::sys.nframe()
[10:24:44.987]     ...future.conditions <- base::list()
[10:24:44.987]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:44.987]     if (FALSE) {
[10:24:44.987]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:44.987]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:44.987]     }
[10:24:44.987]     ...future.result <- base::tryCatch({
[10:24:44.987]         base::withCallingHandlers({
[10:24:44.987]             ...future.value <- base::withVisible(base::local({
[10:24:44.987]                 ...future.makeSendCondition <- base::local({
[10:24:44.987]                   sendCondition <- NULL
[10:24:44.987]                   function(frame = 1L) {
[10:24:44.987]                     if (is.function(sendCondition)) 
[10:24:44.987]                       return(sendCondition)
[10:24:44.987]                     ns <- getNamespace("parallel")
[10:24:44.987]                     if (exists("sendData", mode = "function", 
[10:24:44.987]                       envir = ns)) {
[10:24:44.987]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:44.987]                         envir = ns)
[10:24:44.987]                       envir <- sys.frame(frame)
[10:24:44.987]                       master <- NULL
[10:24:44.987]                       while (!identical(envir, .GlobalEnv) && 
[10:24:44.987]                         !identical(envir, emptyenv())) {
[10:24:44.987]                         if (exists("master", mode = "list", envir = envir, 
[10:24:44.987]                           inherits = FALSE)) {
[10:24:44.987]                           master <- get("master", mode = "list", 
[10:24:44.987]                             envir = envir, inherits = FALSE)
[10:24:44.987]                           if (inherits(master, c("SOCKnode", 
[10:24:44.987]                             "SOCK0node"))) {
[10:24:44.987]                             sendCondition <<- function(cond) {
[10:24:44.987]                               data <- list(type = "VALUE", value = cond, 
[10:24:44.987]                                 success = TRUE)
[10:24:44.987]                               parallel_sendData(master, data)
[10:24:44.987]                             }
[10:24:44.987]                             return(sendCondition)
[10:24:44.987]                           }
[10:24:44.987]                         }
[10:24:44.987]                         frame <- frame + 1L
[10:24:44.987]                         envir <- sys.frame(frame)
[10:24:44.987]                       }
[10:24:44.987]                     }
[10:24:44.987]                     sendCondition <<- function(cond) NULL
[10:24:44.987]                   }
[10:24:44.987]                 })
[10:24:44.987]                 withCallingHandlers({
[10:24:44.987]                   {
[10:24:44.987]                     do.call(function(...) {
[10:24:44.987]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:44.987]                       if (!identical(...future.globals.maxSize.org, 
[10:24:44.987]                         ...future.globals.maxSize)) {
[10:24:44.987]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:44.987]                         on.exit(options(oopts), add = TRUE)
[10:24:44.987]                       }
[10:24:44.987]                       {
[10:24:44.987]                         lapply(seq_along(...future.elements_ii), 
[10:24:44.987]                           FUN = function(jj) {
[10:24:44.987]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:44.987]                             ...future.FUN(...future.X_jj, ...)
[10:24:44.987]                           })
[10:24:44.987]                       }
[10:24:44.987]                     }, args = future.call.arguments)
[10:24:44.987]                   }
[10:24:44.987]                 }, immediateCondition = function(cond) {
[10:24:44.987]                   sendCondition <- ...future.makeSendCondition()
[10:24:44.987]                   sendCondition(cond)
[10:24:44.987]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:44.987]                   {
[10:24:44.987]                     inherits <- base::inherits
[10:24:44.987]                     invokeRestart <- base::invokeRestart
[10:24:44.987]                     is.null <- base::is.null
[10:24:44.987]                     muffled <- FALSE
[10:24:44.987]                     if (inherits(cond, "message")) {
[10:24:44.987]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:44.987]                       if (muffled) 
[10:24:44.987]                         invokeRestart("muffleMessage")
[10:24:44.987]                     }
[10:24:44.987]                     else if (inherits(cond, "warning")) {
[10:24:44.987]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:44.987]                       if (muffled) 
[10:24:44.987]                         invokeRestart("muffleWarning")
[10:24:44.987]                     }
[10:24:44.987]                     else if (inherits(cond, "condition")) {
[10:24:44.987]                       if (!is.null(pattern)) {
[10:24:44.987]                         computeRestarts <- base::computeRestarts
[10:24:44.987]                         grepl <- base::grepl
[10:24:44.987]                         restarts <- computeRestarts(cond)
[10:24:44.987]                         for (restart in restarts) {
[10:24:44.987]                           name <- restart$name
[10:24:44.987]                           if (is.null(name)) 
[10:24:44.987]                             next
[10:24:44.987]                           if (!grepl(pattern, name)) 
[10:24:44.987]                             next
[10:24:44.987]                           invokeRestart(restart)
[10:24:44.987]                           muffled <- TRUE
[10:24:44.987]                           break
[10:24:44.987]                         }
[10:24:44.987]                       }
[10:24:44.987]                     }
[10:24:44.987]                     invisible(muffled)
[10:24:44.987]                   }
[10:24:44.987]                   muffleCondition(cond)
[10:24:44.987]                 })
[10:24:44.987]             }))
[10:24:44.987]             future::FutureResult(value = ...future.value$value, 
[10:24:44.987]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:44.987]                   ...future.rng), globalenv = if (FALSE) 
[10:24:44.987]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:44.987]                     ...future.globalenv.names))
[10:24:44.987]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:44.987]         }, condition = base::local({
[10:24:44.987]             c <- base::c
[10:24:44.987]             inherits <- base::inherits
[10:24:44.987]             invokeRestart <- base::invokeRestart
[10:24:44.987]             length <- base::length
[10:24:44.987]             list <- base::list
[10:24:44.987]             seq.int <- base::seq.int
[10:24:44.987]             signalCondition <- base::signalCondition
[10:24:44.987]             sys.calls <- base::sys.calls
[10:24:44.987]             `[[` <- base::`[[`
[10:24:44.987]             `+` <- base::`+`
[10:24:44.987]             `<<-` <- base::`<<-`
[10:24:44.987]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:44.987]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:44.987]                   3L)]
[10:24:44.987]             }
[10:24:44.987]             function(cond) {
[10:24:44.987]                 is_error <- inherits(cond, "error")
[10:24:44.987]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:44.987]                   NULL)
[10:24:44.987]                 if (is_error) {
[10:24:44.987]                   sessionInformation <- function() {
[10:24:44.987]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:44.987]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:44.987]                       search = base::search(), system = base::Sys.info())
[10:24:44.987]                   }
[10:24:44.987]                   ...future.conditions[[length(...future.conditions) + 
[10:24:44.987]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:44.987]                     cond$call), session = sessionInformation(), 
[10:24:44.987]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:44.987]                   signalCondition(cond)
[10:24:44.987]                 }
[10:24:44.987]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:44.987]                 "immediateCondition"))) {
[10:24:44.987]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:44.987]                   ...future.conditions[[length(...future.conditions) + 
[10:24:44.987]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:44.987]                   if (TRUE && !signal) {
[10:24:44.987]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:44.987]                     {
[10:24:44.987]                       inherits <- base::inherits
[10:24:44.987]                       invokeRestart <- base::invokeRestart
[10:24:44.987]                       is.null <- base::is.null
[10:24:44.987]                       muffled <- FALSE
[10:24:44.987]                       if (inherits(cond, "message")) {
[10:24:44.987]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:44.987]                         if (muffled) 
[10:24:44.987]                           invokeRestart("muffleMessage")
[10:24:44.987]                       }
[10:24:44.987]                       else if (inherits(cond, "warning")) {
[10:24:44.987]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:44.987]                         if (muffled) 
[10:24:44.987]                           invokeRestart("muffleWarning")
[10:24:44.987]                       }
[10:24:44.987]                       else if (inherits(cond, "condition")) {
[10:24:44.987]                         if (!is.null(pattern)) {
[10:24:44.987]                           computeRestarts <- base::computeRestarts
[10:24:44.987]                           grepl <- base::grepl
[10:24:44.987]                           restarts <- computeRestarts(cond)
[10:24:44.987]                           for (restart in restarts) {
[10:24:44.987]                             name <- restart$name
[10:24:44.987]                             if (is.null(name)) 
[10:24:44.987]                               next
[10:24:44.987]                             if (!grepl(pattern, name)) 
[10:24:44.987]                               next
[10:24:44.987]                             invokeRestart(restart)
[10:24:44.987]                             muffled <- TRUE
[10:24:44.987]                             break
[10:24:44.987]                           }
[10:24:44.987]                         }
[10:24:44.987]                       }
[10:24:44.987]                       invisible(muffled)
[10:24:44.987]                     }
[10:24:44.987]                     muffleCondition(cond, pattern = "^muffle")
[10:24:44.987]                   }
[10:24:44.987]                 }
[10:24:44.987]                 else {
[10:24:44.987]                   if (TRUE) {
[10:24:44.987]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:44.987]                     {
[10:24:44.987]                       inherits <- base::inherits
[10:24:44.987]                       invokeRestart <- base::invokeRestart
[10:24:44.987]                       is.null <- base::is.null
[10:24:44.987]                       muffled <- FALSE
[10:24:44.987]                       if (inherits(cond, "message")) {
[10:24:44.987]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:44.987]                         if (muffled) 
[10:24:44.987]                           invokeRestart("muffleMessage")
[10:24:44.987]                       }
[10:24:44.987]                       else if (inherits(cond, "warning")) {
[10:24:44.987]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:44.987]                         if (muffled) 
[10:24:44.987]                           invokeRestart("muffleWarning")
[10:24:44.987]                       }
[10:24:44.987]                       else if (inherits(cond, "condition")) {
[10:24:44.987]                         if (!is.null(pattern)) {
[10:24:44.987]                           computeRestarts <- base::computeRestarts
[10:24:44.987]                           grepl <- base::grepl
[10:24:44.987]                           restarts <- computeRestarts(cond)
[10:24:44.987]                           for (restart in restarts) {
[10:24:44.987]                             name <- restart$name
[10:24:44.987]                             if (is.null(name)) 
[10:24:44.987]                               next
[10:24:44.987]                             if (!grepl(pattern, name)) 
[10:24:44.987]                               next
[10:24:44.987]                             invokeRestart(restart)
[10:24:44.987]                             muffled <- TRUE
[10:24:44.987]                             break
[10:24:44.987]                           }
[10:24:44.987]                         }
[10:24:44.987]                       }
[10:24:44.987]                       invisible(muffled)
[10:24:44.987]                     }
[10:24:44.987]                     muffleCondition(cond, pattern = "^muffle")
[10:24:44.987]                   }
[10:24:44.987]                 }
[10:24:44.987]             }
[10:24:44.987]         }))
[10:24:44.987]     }, error = function(ex) {
[10:24:44.987]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:44.987]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:44.987]                 ...future.rng), started = ...future.startTime, 
[10:24:44.987]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:44.987]             version = "1.8"), class = "FutureResult")
[10:24:44.987]     }, finally = {
[10:24:44.987]         if (!identical(...future.workdir, getwd())) 
[10:24:44.987]             setwd(...future.workdir)
[10:24:44.987]         {
[10:24:44.987]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:44.987]                 ...future.oldOptions$nwarnings <- NULL
[10:24:44.987]             }
[10:24:44.987]             base::options(...future.oldOptions)
[10:24:44.987]             if (.Platform$OS.type == "windows") {
[10:24:44.987]                 old_names <- names(...future.oldEnvVars)
[10:24:44.987]                 envs <- base::Sys.getenv()
[10:24:44.987]                 names <- names(envs)
[10:24:44.987]                 common <- intersect(names, old_names)
[10:24:44.987]                 added <- setdiff(names, old_names)
[10:24:44.987]                 removed <- setdiff(old_names, names)
[10:24:44.987]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:44.987]                   envs[common]]
[10:24:44.987]                 NAMES <- toupper(changed)
[10:24:44.987]                 args <- list()
[10:24:44.987]                 for (kk in seq_along(NAMES)) {
[10:24:44.987]                   name <- changed[[kk]]
[10:24:44.987]                   NAME <- NAMES[[kk]]
[10:24:44.987]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:44.987]                     next
[10:24:44.987]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:44.987]                 }
[10:24:44.987]                 NAMES <- toupper(added)
[10:24:44.987]                 for (kk in seq_along(NAMES)) {
[10:24:44.987]                   name <- added[[kk]]
[10:24:44.987]                   NAME <- NAMES[[kk]]
[10:24:44.987]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:44.987]                     next
[10:24:44.987]                   args[[name]] <- ""
[10:24:44.987]                 }
[10:24:44.987]                 NAMES <- toupper(removed)
[10:24:44.987]                 for (kk in seq_along(NAMES)) {
[10:24:44.987]                   name <- removed[[kk]]
[10:24:44.987]                   NAME <- NAMES[[kk]]
[10:24:44.987]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:44.987]                     next
[10:24:44.987]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:44.987]                 }
[10:24:44.987]                 if (length(args) > 0) 
[10:24:44.987]                   base::do.call(base::Sys.setenv, args = args)
[10:24:44.987]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:44.987]             }
[10:24:44.987]             else {
[10:24:44.987]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:44.987]             }
[10:24:44.987]             {
[10:24:44.987]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:44.987]                   0L) {
[10:24:44.987]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:44.987]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:44.987]                   base::options(opts)
[10:24:44.987]                 }
[10:24:44.987]                 {
[10:24:44.987]                   {
[10:24:44.987]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:44.987]                     NULL
[10:24:44.987]                   }
[10:24:44.987]                   options(future.plan = NULL)
[10:24:44.987]                   if (is.na(NA_character_)) 
[10:24:44.987]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:44.987]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:44.987]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:44.987]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:44.987]                     envir = parent.frame()) 
[10:24:44.987]                   {
[10:24:44.987]                     if (is.function(workers)) 
[10:24:44.987]                       workers <- workers()
[10:24:44.987]                     workers <- structure(as.integer(workers), 
[10:24:44.987]                       class = class(workers))
[10:24:44.987]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:44.987]                       workers >= 1)
[10:24:44.987]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:44.987]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:44.987]                     }
[10:24:44.987]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:44.987]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:44.987]                       envir = envir)
[10:24:44.987]                     if (!future$lazy) 
[10:24:44.987]                       future <- run(future)
[10:24:44.987]                     invisible(future)
[10:24:44.987]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:44.987]                 }
[10:24:44.987]             }
[10:24:44.987]         }
[10:24:44.987]     })
[10:24:44.987]     if (TRUE) {
[10:24:44.987]         base::sink(type = "output", split = FALSE)
[10:24:44.987]         if (FALSE) {
[10:24:44.987]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:44.987]         }
[10:24:44.987]         else {
[10:24:44.987]             ...future.result["stdout"] <- base::list(NULL)
[10:24:44.987]         }
[10:24:44.987]         base::close(...future.stdout)
[10:24:44.987]         ...future.stdout <- NULL
[10:24:44.987]     }
[10:24:44.987]     ...future.result$conditions <- ...future.conditions
[10:24:44.987]     ...future.result$finished <- base::Sys.time()
[10:24:44.987]     ...future.result
[10:24:44.987] }
[10:24:44.990] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[10:24:44.990] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[10:24:44.991] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[10:24:44.991] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:24:44.991] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:24:44.991] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[10:24:44.992] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[10:24:44.992] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:24:44.992] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:24:44.992] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:24:44.993] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:24:44.993] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[10:24:44.994] MultisessionFuture started
[10:24:44.994] - Launch lazy future ... done
[10:24:44.994] run() for ‘MultisessionFuture’ ... done
[10:24:44.994] Created future:
[10:24:44.994] MultisessionFuture:
[10:24:44.994] Label: ‘future_lapply-1’
[10:24:44.994] Expression:
[10:24:44.994] {
[10:24:44.994]     do.call(function(...) {
[10:24:44.994]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:44.994]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:44.994]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:44.994]             on.exit(options(oopts), add = TRUE)
[10:24:44.994]         }
[10:24:44.994]         {
[10:24:44.994]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:44.994]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:44.994]                 ...future.FUN(...future.X_jj, ...)
[10:24:44.994]             })
[10:24:44.994]         }
[10:24:44.994]     }, args = future.call.arguments)
[10:24:44.994] }
[10:24:44.994] Lazy evaluation: FALSE
[10:24:44.994] Asynchronous evaluation: TRUE
[10:24:44.994] Local evaluation: TRUE
[10:24:44.994] Environment: R_GlobalEnv
[10:24:44.994] Capture standard output: FALSE
[10:24:44.994] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:44.994] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:44.994] Packages: <none>
[10:24:44.994] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:44.994] Resolved: FALSE
[10:24:44.994] Value: <not collected>
[10:24:44.994] Conditions captured: <none>
[10:24:44.994] Early signaling: FALSE
[10:24:44.994] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:44.994] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:45.006] Chunk #1 of 2 ... DONE
[10:24:45.006] Chunk #2 of 2 ...
[10:24:45.006]  - Finding globals in 'X' for chunk #2 ...
[10:24:45.006] getGlobalsAndPackages() ...
[10:24:45.007] Searching for globals...
[10:24:45.007] 
[10:24:45.007] Searching for globals ... DONE
[10:24:45.007] - globals: [0] <none>
[10:24:45.007] getGlobalsAndPackages() ... DONE
[10:24:45.007]    + additional globals found: [n=0] 
[10:24:45.007]    + additional namespaces needed: [n=0] 
[10:24:45.007]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:45.008]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:45.008]  - seeds: <none>
[10:24:45.008]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:45.008] getGlobalsAndPackages() ...
[10:24:45.008] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:45.008] Resolving globals: FALSE
[10:24:45.008] Tweak future expression to call with '...' arguments ...
[10:24:45.009] {
[10:24:45.009]     do.call(function(...) {
[10:24:45.009]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:45.009]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:45.009]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:45.009]             on.exit(options(oopts), add = TRUE)
[10:24:45.009]         }
[10:24:45.009]         {
[10:24:45.009]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:45.009]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:45.009]                 ...future.FUN(...future.X_jj, ...)
[10:24:45.009]             })
[10:24:45.009]         }
[10:24:45.009]     }, args = future.call.arguments)
[10:24:45.009] }
[10:24:45.009] Tweak future expression to call with '...' arguments ... DONE
[10:24:45.009] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:45.009] 
[10:24:45.010] getGlobalsAndPackages() ... DONE
[10:24:45.010] run() for ‘Future’ ...
[10:24:45.010] - state: ‘created’
[10:24:45.010] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:45.024] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:45.025] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:45.025]   - Field: ‘node’
[10:24:45.025]   - Field: ‘label’
[10:24:45.025]   - Field: ‘local’
[10:24:45.025]   - Field: ‘owner’
[10:24:45.025]   - Field: ‘envir’
[10:24:45.025]   - Field: ‘workers’
[10:24:45.025]   - Field: ‘packages’
[10:24:45.025]   - Field: ‘gc’
[10:24:45.025]   - Field: ‘conditions’
[10:24:45.026]   - Field: ‘persistent’
[10:24:45.026]   - Field: ‘expr’
[10:24:45.026]   - Field: ‘uuid’
[10:24:45.026]   - Field: ‘seed’
[10:24:45.026]   - Field: ‘version’
[10:24:45.026]   - Field: ‘result’
[10:24:45.026]   - Field: ‘asynchronous’
[10:24:45.026]   - Field: ‘calls’
[10:24:45.026]   - Field: ‘globals’
[10:24:45.027]   - Field: ‘stdout’
[10:24:45.027]   - Field: ‘earlySignal’
[10:24:45.027]   - Field: ‘lazy’
[10:24:45.027]   - Field: ‘state’
[10:24:45.027] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:45.027] - Launch lazy future ...
[10:24:45.027] Packages needed by the future expression (n = 0): <none>
[10:24:45.028] Packages needed by future strategies (n = 0): <none>
[10:24:45.028] {
[10:24:45.028]     {
[10:24:45.028]         {
[10:24:45.028]             ...future.startTime <- base::Sys.time()
[10:24:45.028]             {
[10:24:45.028]                 {
[10:24:45.028]                   {
[10:24:45.028]                     {
[10:24:45.028]                       base::local({
[10:24:45.028]                         has_future <- base::requireNamespace("future", 
[10:24:45.028]                           quietly = TRUE)
[10:24:45.028]                         if (has_future) {
[10:24:45.028]                           ns <- base::getNamespace("future")
[10:24:45.028]                           version <- ns[[".package"]][["version"]]
[10:24:45.028]                           if (is.null(version)) 
[10:24:45.028]                             version <- utils::packageVersion("future")
[10:24:45.028]                         }
[10:24:45.028]                         else {
[10:24:45.028]                           version <- NULL
[10:24:45.028]                         }
[10:24:45.028]                         if (!has_future || version < "1.8.0") {
[10:24:45.028]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:45.028]                             "", base::R.version$version.string), 
[10:24:45.028]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:45.028]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:45.028]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:45.028]                               "release", "version")], collapse = " "), 
[10:24:45.028]                             hostname = base::Sys.info()[["nodename"]])
[10:24:45.028]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:45.028]                             info)
[10:24:45.028]                           info <- base::paste(info, collapse = "; ")
[10:24:45.028]                           if (!has_future) {
[10:24:45.028]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:45.028]                               info)
[10:24:45.028]                           }
[10:24:45.028]                           else {
[10:24:45.028]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:45.028]                               info, version)
[10:24:45.028]                           }
[10:24:45.028]                           base::stop(msg)
[10:24:45.028]                         }
[10:24:45.028]                       })
[10:24:45.028]                     }
[10:24:45.028]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:45.028]                     base::options(mc.cores = 1L)
[10:24:45.028]                   }
[10:24:45.028]                   options(future.plan = NULL)
[10:24:45.028]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:45.028]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:45.028]                 }
[10:24:45.028]                 ...future.workdir <- getwd()
[10:24:45.028]             }
[10:24:45.028]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:45.028]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:45.028]         }
[10:24:45.028]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:45.028]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:45.028]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:45.028]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:45.028]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:45.028]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:45.028]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:45.028]             base::names(...future.oldOptions))
[10:24:45.028]     }
[10:24:45.028]     if (FALSE) {
[10:24:45.028]     }
[10:24:45.028]     else {
[10:24:45.028]         if (FALSE) {
[10:24:45.028]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:45.028]                 open = "w")
[10:24:45.028]         }
[10:24:45.028]         else {
[10:24:45.028]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:45.028]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:45.028]         }
[10:24:45.028]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:45.028]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:45.028]             base::sink(type = "output", split = FALSE)
[10:24:45.028]             base::close(...future.stdout)
[10:24:45.028]         }, add = TRUE)
[10:24:45.028]     }
[10:24:45.028]     ...future.frame <- base::sys.nframe()
[10:24:45.028]     ...future.conditions <- base::list()
[10:24:45.028]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:45.028]     if (FALSE) {
[10:24:45.028]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:45.028]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:45.028]     }
[10:24:45.028]     ...future.result <- base::tryCatch({
[10:24:45.028]         base::withCallingHandlers({
[10:24:45.028]             ...future.value <- base::withVisible(base::local({
[10:24:45.028]                 ...future.makeSendCondition <- base::local({
[10:24:45.028]                   sendCondition <- NULL
[10:24:45.028]                   function(frame = 1L) {
[10:24:45.028]                     if (is.function(sendCondition)) 
[10:24:45.028]                       return(sendCondition)
[10:24:45.028]                     ns <- getNamespace("parallel")
[10:24:45.028]                     if (exists("sendData", mode = "function", 
[10:24:45.028]                       envir = ns)) {
[10:24:45.028]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:45.028]                         envir = ns)
[10:24:45.028]                       envir <- sys.frame(frame)
[10:24:45.028]                       master <- NULL
[10:24:45.028]                       while (!identical(envir, .GlobalEnv) && 
[10:24:45.028]                         !identical(envir, emptyenv())) {
[10:24:45.028]                         if (exists("master", mode = "list", envir = envir, 
[10:24:45.028]                           inherits = FALSE)) {
[10:24:45.028]                           master <- get("master", mode = "list", 
[10:24:45.028]                             envir = envir, inherits = FALSE)
[10:24:45.028]                           if (inherits(master, c("SOCKnode", 
[10:24:45.028]                             "SOCK0node"))) {
[10:24:45.028]                             sendCondition <<- function(cond) {
[10:24:45.028]                               data <- list(type = "VALUE", value = cond, 
[10:24:45.028]                                 success = TRUE)
[10:24:45.028]                               parallel_sendData(master, data)
[10:24:45.028]                             }
[10:24:45.028]                             return(sendCondition)
[10:24:45.028]                           }
[10:24:45.028]                         }
[10:24:45.028]                         frame <- frame + 1L
[10:24:45.028]                         envir <- sys.frame(frame)
[10:24:45.028]                       }
[10:24:45.028]                     }
[10:24:45.028]                     sendCondition <<- function(cond) NULL
[10:24:45.028]                   }
[10:24:45.028]                 })
[10:24:45.028]                 withCallingHandlers({
[10:24:45.028]                   {
[10:24:45.028]                     do.call(function(...) {
[10:24:45.028]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:45.028]                       if (!identical(...future.globals.maxSize.org, 
[10:24:45.028]                         ...future.globals.maxSize)) {
[10:24:45.028]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:45.028]                         on.exit(options(oopts), add = TRUE)
[10:24:45.028]                       }
[10:24:45.028]                       {
[10:24:45.028]                         lapply(seq_along(...future.elements_ii), 
[10:24:45.028]                           FUN = function(jj) {
[10:24:45.028]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:45.028]                             ...future.FUN(...future.X_jj, ...)
[10:24:45.028]                           })
[10:24:45.028]                       }
[10:24:45.028]                     }, args = future.call.arguments)
[10:24:45.028]                   }
[10:24:45.028]                 }, immediateCondition = function(cond) {
[10:24:45.028]                   sendCondition <- ...future.makeSendCondition()
[10:24:45.028]                   sendCondition(cond)
[10:24:45.028]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:45.028]                   {
[10:24:45.028]                     inherits <- base::inherits
[10:24:45.028]                     invokeRestart <- base::invokeRestart
[10:24:45.028]                     is.null <- base::is.null
[10:24:45.028]                     muffled <- FALSE
[10:24:45.028]                     if (inherits(cond, "message")) {
[10:24:45.028]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:45.028]                       if (muffled) 
[10:24:45.028]                         invokeRestart("muffleMessage")
[10:24:45.028]                     }
[10:24:45.028]                     else if (inherits(cond, "warning")) {
[10:24:45.028]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:45.028]                       if (muffled) 
[10:24:45.028]                         invokeRestart("muffleWarning")
[10:24:45.028]                     }
[10:24:45.028]                     else if (inherits(cond, "condition")) {
[10:24:45.028]                       if (!is.null(pattern)) {
[10:24:45.028]                         computeRestarts <- base::computeRestarts
[10:24:45.028]                         grepl <- base::grepl
[10:24:45.028]                         restarts <- computeRestarts(cond)
[10:24:45.028]                         for (restart in restarts) {
[10:24:45.028]                           name <- restart$name
[10:24:45.028]                           if (is.null(name)) 
[10:24:45.028]                             next
[10:24:45.028]                           if (!grepl(pattern, name)) 
[10:24:45.028]                             next
[10:24:45.028]                           invokeRestart(restart)
[10:24:45.028]                           muffled <- TRUE
[10:24:45.028]                           break
[10:24:45.028]                         }
[10:24:45.028]                       }
[10:24:45.028]                     }
[10:24:45.028]                     invisible(muffled)
[10:24:45.028]                   }
[10:24:45.028]                   muffleCondition(cond)
[10:24:45.028]                 })
[10:24:45.028]             }))
[10:24:45.028]             future::FutureResult(value = ...future.value$value, 
[10:24:45.028]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:45.028]                   ...future.rng), globalenv = if (FALSE) 
[10:24:45.028]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:45.028]                     ...future.globalenv.names))
[10:24:45.028]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:45.028]         }, condition = base::local({
[10:24:45.028]             c <- base::c
[10:24:45.028]             inherits <- base::inherits
[10:24:45.028]             invokeRestart <- base::invokeRestart
[10:24:45.028]             length <- base::length
[10:24:45.028]             list <- base::list
[10:24:45.028]             seq.int <- base::seq.int
[10:24:45.028]             signalCondition <- base::signalCondition
[10:24:45.028]             sys.calls <- base::sys.calls
[10:24:45.028]             `[[` <- base::`[[`
[10:24:45.028]             `+` <- base::`+`
[10:24:45.028]             `<<-` <- base::`<<-`
[10:24:45.028]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:45.028]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:45.028]                   3L)]
[10:24:45.028]             }
[10:24:45.028]             function(cond) {
[10:24:45.028]                 is_error <- inherits(cond, "error")
[10:24:45.028]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:45.028]                   NULL)
[10:24:45.028]                 if (is_error) {
[10:24:45.028]                   sessionInformation <- function() {
[10:24:45.028]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:45.028]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:45.028]                       search = base::search(), system = base::Sys.info())
[10:24:45.028]                   }
[10:24:45.028]                   ...future.conditions[[length(...future.conditions) + 
[10:24:45.028]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:45.028]                     cond$call), session = sessionInformation(), 
[10:24:45.028]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:45.028]                   signalCondition(cond)
[10:24:45.028]                 }
[10:24:45.028]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:45.028]                 "immediateCondition"))) {
[10:24:45.028]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:45.028]                   ...future.conditions[[length(...future.conditions) + 
[10:24:45.028]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:45.028]                   if (TRUE && !signal) {
[10:24:45.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:45.028]                     {
[10:24:45.028]                       inherits <- base::inherits
[10:24:45.028]                       invokeRestart <- base::invokeRestart
[10:24:45.028]                       is.null <- base::is.null
[10:24:45.028]                       muffled <- FALSE
[10:24:45.028]                       if (inherits(cond, "message")) {
[10:24:45.028]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:45.028]                         if (muffled) 
[10:24:45.028]                           invokeRestart("muffleMessage")
[10:24:45.028]                       }
[10:24:45.028]                       else if (inherits(cond, "warning")) {
[10:24:45.028]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:45.028]                         if (muffled) 
[10:24:45.028]                           invokeRestart("muffleWarning")
[10:24:45.028]                       }
[10:24:45.028]                       else if (inherits(cond, "condition")) {
[10:24:45.028]                         if (!is.null(pattern)) {
[10:24:45.028]                           computeRestarts <- base::computeRestarts
[10:24:45.028]                           grepl <- base::grepl
[10:24:45.028]                           restarts <- computeRestarts(cond)
[10:24:45.028]                           for (restart in restarts) {
[10:24:45.028]                             name <- restart$name
[10:24:45.028]                             if (is.null(name)) 
[10:24:45.028]                               next
[10:24:45.028]                             if (!grepl(pattern, name)) 
[10:24:45.028]                               next
[10:24:45.028]                             invokeRestart(restart)
[10:24:45.028]                             muffled <- TRUE
[10:24:45.028]                             break
[10:24:45.028]                           }
[10:24:45.028]                         }
[10:24:45.028]                       }
[10:24:45.028]                       invisible(muffled)
[10:24:45.028]                     }
[10:24:45.028]                     muffleCondition(cond, pattern = "^muffle")
[10:24:45.028]                   }
[10:24:45.028]                 }
[10:24:45.028]                 else {
[10:24:45.028]                   if (TRUE) {
[10:24:45.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:45.028]                     {
[10:24:45.028]                       inherits <- base::inherits
[10:24:45.028]                       invokeRestart <- base::invokeRestart
[10:24:45.028]                       is.null <- base::is.null
[10:24:45.028]                       muffled <- FALSE
[10:24:45.028]                       if (inherits(cond, "message")) {
[10:24:45.028]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:45.028]                         if (muffled) 
[10:24:45.028]                           invokeRestart("muffleMessage")
[10:24:45.028]                       }
[10:24:45.028]                       else if (inherits(cond, "warning")) {
[10:24:45.028]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:45.028]                         if (muffled) 
[10:24:45.028]                           invokeRestart("muffleWarning")
[10:24:45.028]                       }
[10:24:45.028]                       else if (inherits(cond, "condition")) {
[10:24:45.028]                         if (!is.null(pattern)) {
[10:24:45.028]                           computeRestarts <- base::computeRestarts
[10:24:45.028]                           grepl <- base::grepl
[10:24:45.028]                           restarts <- computeRestarts(cond)
[10:24:45.028]                           for (restart in restarts) {
[10:24:45.028]                             name <- restart$name
[10:24:45.028]                             if (is.null(name)) 
[10:24:45.028]                               next
[10:24:45.028]                             if (!grepl(pattern, name)) 
[10:24:45.028]                               next
[10:24:45.028]                             invokeRestart(restart)
[10:24:45.028]                             muffled <- TRUE
[10:24:45.028]                             break
[10:24:45.028]                           }
[10:24:45.028]                         }
[10:24:45.028]                       }
[10:24:45.028]                       invisible(muffled)
[10:24:45.028]                     }
[10:24:45.028]                     muffleCondition(cond, pattern = "^muffle")
[10:24:45.028]                   }
[10:24:45.028]                 }
[10:24:45.028]             }
[10:24:45.028]         }))
[10:24:45.028]     }, error = function(ex) {
[10:24:45.028]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:45.028]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:45.028]                 ...future.rng), started = ...future.startTime, 
[10:24:45.028]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:45.028]             version = "1.8"), class = "FutureResult")
[10:24:45.028]     }, finally = {
[10:24:45.028]         if (!identical(...future.workdir, getwd())) 
[10:24:45.028]             setwd(...future.workdir)
[10:24:45.028]         {
[10:24:45.028]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:45.028]                 ...future.oldOptions$nwarnings <- NULL
[10:24:45.028]             }
[10:24:45.028]             base::options(...future.oldOptions)
[10:24:45.028]             if (.Platform$OS.type == "windows") {
[10:24:45.028]                 old_names <- names(...future.oldEnvVars)
[10:24:45.028]                 envs <- base::Sys.getenv()
[10:24:45.028]                 names <- names(envs)
[10:24:45.028]                 common <- intersect(names, old_names)
[10:24:45.028]                 added <- setdiff(names, old_names)
[10:24:45.028]                 removed <- setdiff(old_names, names)
[10:24:45.028]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:45.028]                   envs[common]]
[10:24:45.028]                 NAMES <- toupper(changed)
[10:24:45.028]                 args <- list()
[10:24:45.028]                 for (kk in seq_along(NAMES)) {
[10:24:45.028]                   name <- changed[[kk]]
[10:24:45.028]                   NAME <- NAMES[[kk]]
[10:24:45.028]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:45.028]                     next
[10:24:45.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:45.028]                 }
[10:24:45.028]                 NAMES <- toupper(added)
[10:24:45.028]                 for (kk in seq_along(NAMES)) {
[10:24:45.028]                   name <- added[[kk]]
[10:24:45.028]                   NAME <- NAMES[[kk]]
[10:24:45.028]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:45.028]                     next
[10:24:45.028]                   args[[name]] <- ""
[10:24:45.028]                 }
[10:24:45.028]                 NAMES <- toupper(removed)
[10:24:45.028]                 for (kk in seq_along(NAMES)) {
[10:24:45.028]                   name <- removed[[kk]]
[10:24:45.028]                   NAME <- NAMES[[kk]]
[10:24:45.028]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:45.028]                     next
[10:24:45.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:45.028]                 }
[10:24:45.028]                 if (length(args) > 0) 
[10:24:45.028]                   base::do.call(base::Sys.setenv, args = args)
[10:24:45.028]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:45.028]             }
[10:24:45.028]             else {
[10:24:45.028]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:45.028]             }
[10:24:45.028]             {
[10:24:45.028]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:45.028]                   0L) {
[10:24:45.028]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:45.028]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:45.028]                   base::options(opts)
[10:24:45.028]                 }
[10:24:45.028]                 {
[10:24:45.028]                   {
[10:24:45.028]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:45.028]                     NULL
[10:24:45.028]                   }
[10:24:45.028]                   options(future.plan = NULL)
[10:24:45.028]                   if (is.na(NA_character_)) 
[10:24:45.028]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:45.028]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:45.028]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:45.028]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:45.028]                     envir = parent.frame()) 
[10:24:45.028]                   {
[10:24:45.028]                     if (is.function(workers)) 
[10:24:45.028]                       workers <- workers()
[10:24:45.028]                     workers <- structure(as.integer(workers), 
[10:24:45.028]                       class = class(workers))
[10:24:45.028]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:45.028]                       workers >= 1)
[10:24:45.028]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:45.028]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:45.028]                     }
[10:24:45.028]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:45.028]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:45.028]                       envir = envir)
[10:24:45.028]                     if (!future$lazy) 
[10:24:45.028]                       future <- run(future)
[10:24:45.028]                     invisible(future)
[10:24:45.028]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:45.028]                 }
[10:24:45.028]             }
[10:24:45.028]         }
[10:24:45.028]     })
[10:24:45.028]     if (TRUE) {
[10:24:45.028]         base::sink(type = "output", split = FALSE)
[10:24:45.028]         if (FALSE) {
[10:24:45.028]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:45.028]         }
[10:24:45.028]         else {
[10:24:45.028]             ...future.result["stdout"] <- base::list(NULL)
[10:24:45.028]         }
[10:24:45.028]         base::close(...future.stdout)
[10:24:45.028]         ...future.stdout <- NULL
[10:24:45.028]     }
[10:24:45.028]     ...future.result$conditions <- ...future.conditions
[10:24:45.028]     ...future.result$finished <- base::Sys.time()
[10:24:45.028]     ...future.result
[10:24:45.028] }
[10:24:45.083] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[10:24:45.084] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[10:24:45.084] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[10:24:45.085] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:24:45.085] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:24:45.085] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[10:24:45.086] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[10:24:45.086] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:24:45.086] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:24:45.086] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:24:45.087] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:24:45.087] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[10:24:45.088] MultisessionFuture started
[10:24:45.088] - Launch lazy future ... done
[10:24:45.088] run() for ‘MultisessionFuture’ ... done
[10:24:45.088] Created future:
[10:24:45.088] MultisessionFuture:
[10:24:45.088] Label: ‘future_lapply-2’
[10:24:45.088] Expression:
[10:24:45.088] {
[10:24:45.088]     do.call(function(...) {
[10:24:45.088]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:45.088]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:45.088]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:45.088]             on.exit(options(oopts), add = TRUE)
[10:24:45.088]         }
[10:24:45.088]         {
[10:24:45.088]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:45.088]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:45.088]                 ...future.FUN(...future.X_jj, ...)
[10:24:45.088]             })
[10:24:45.088]         }
[10:24:45.088]     }, args = future.call.arguments)
[10:24:45.088] }
[10:24:45.088] Lazy evaluation: FALSE
[10:24:45.088] Asynchronous evaluation: TRUE
[10:24:45.088] Local evaluation: TRUE
[10:24:45.088] Environment: R_GlobalEnv
[10:24:45.088] Capture standard output: FALSE
[10:24:45.088] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:45.088] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:45.088] Packages: <none>
[10:24:45.088] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:45.088] Resolved: FALSE
[10:24:45.088] Value: <not collected>
[10:24:45.088] Conditions captured: <none>
[10:24:45.088] Early signaling: FALSE
[10:24:45.088] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:45.088] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:45.100] Chunk #2 of 2 ... DONE
[10:24:45.100] Launching 2 futures (chunks) ... DONE
[10:24:45.101] Resolving 2 futures (chunks) ...
[10:24:45.101] resolve() on list ...
[10:24:45.101]  recursive: 0
[10:24:45.101]  length: 2
[10:24:45.103] 
[10:24:45.177] receiveMessageFromWorker() for ClusterFuture ...
[10:24:45.177] - Validating connection of MultisessionFuture
[10:24:45.178] - received message: FutureResult
[10:24:45.178] - Received FutureResult
[10:24:45.178] - Erased future from FutureRegistry
[10:24:45.178] result() for ClusterFuture ...
[10:24:45.178] - result already collected: FutureResult
[10:24:45.178] result() for ClusterFuture ... done
[10:24:45.178] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:45.178] Future #2
[10:24:45.178] result() for ClusterFuture ...
[10:24:45.178] - result already collected: FutureResult
[10:24:45.179] result() for ClusterFuture ... done
[10:24:45.179] result() for ClusterFuture ...
[10:24:45.179] - result already collected: FutureResult
[10:24:45.179] result() for ClusterFuture ... done
[10:24:45.179] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:24:45.179] - nx: 2
[10:24:45.179] - relay: TRUE
[10:24:45.179] - stdout: TRUE
[10:24:45.179] - signal: TRUE
[10:24:45.179] - resignal: FALSE
[10:24:45.179] - force: TRUE
[10:24:45.180] - relayed: [n=2] FALSE, FALSE
[10:24:45.180] - queued futures: [n=2] FALSE, FALSE
[10:24:45.180]  - until=1
[10:24:45.180]  - relaying element #1
[10:24:45.180] - relayed: [n=2] FALSE, FALSE
[10:24:45.180] - queued futures: [n=2] FALSE, TRUE
[10:24:45.180] signalConditionsASAP(NULL, pos=2) ... done
[10:24:45.180]  length: 1 (resolved future 2)
[10:24:45.543] receiveMessageFromWorker() for ClusterFuture ...
[10:24:45.544] - Validating connection of MultisessionFuture
[10:24:45.544] - received message: FutureResult
[10:24:45.544] - Received FutureResult
[10:24:45.544] - Erased future from FutureRegistry
[10:24:45.544] result() for ClusterFuture ...
[10:24:45.545] - result already collected: FutureResult
[10:24:45.545] result() for ClusterFuture ... done
[10:24:45.545] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:45.545] Future #1
[10:24:45.545] result() for ClusterFuture ...
[10:24:45.545] - result already collected: FutureResult
[10:24:45.545] result() for ClusterFuture ... done
[10:24:45.545] result() for ClusterFuture ...
[10:24:45.545] - result already collected: FutureResult
[10:24:45.546] result() for ClusterFuture ... done
[10:24:45.546] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:24:45.546] - nx: 2
[10:24:45.546] - relay: TRUE
[10:24:45.546] - stdout: TRUE
[10:24:45.546] - signal: TRUE
[10:24:45.546] - resignal: FALSE
[10:24:45.546] - force: TRUE
[10:24:45.546] - relayed: [n=2] FALSE, FALSE
[10:24:45.546] - queued futures: [n=2] FALSE, TRUE
[10:24:45.546]  - until=1
[10:24:45.547]  - relaying element #1
[10:24:45.547] result() for ClusterFuture ...
[10:24:45.547] - result already collected: FutureResult
[10:24:45.547] result() for ClusterFuture ... done
[10:24:45.547] result() for ClusterFuture ...
[10:24:45.547] - result already collected: FutureResult
[10:24:45.547] result() for ClusterFuture ... done
[10:24:45.547] result() for ClusterFuture ...
[10:24:45.547] - result already collected: FutureResult
[10:24:45.547] result() for ClusterFuture ... done
[10:24:45.547] result() for ClusterFuture ...
[10:24:45.547] - result already collected: FutureResult
[10:24:45.548] result() for ClusterFuture ... done
[10:24:45.548] - relayed: [n=2] TRUE, FALSE
[10:24:45.548] - queued futures: [n=2] TRUE, TRUE
[10:24:45.548] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:24:45.548]  length: 0 (resolved future 1)
[10:24:45.548] Relaying remaining futures
[10:24:45.548] signalConditionsASAP(NULL, pos=0) ...
[10:24:45.548] - nx: 2
[10:24:45.548] - relay: TRUE
[10:24:45.548] - stdout: TRUE
[10:24:45.548] - signal: TRUE
[10:24:45.549] - resignal: FALSE
[10:24:45.549] - force: TRUE
[10:24:45.549] - relayed: [n=2] TRUE, FALSE
[10:24:45.549] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:45.549]  - relaying element #2
[10:24:45.549] result() for ClusterFuture ...
[10:24:45.549] - result already collected: FutureResult
[10:24:45.549] result() for ClusterFuture ... done
[10:24:45.549] result() for ClusterFuture ...
[10:24:45.549] - result already collected: FutureResult
[10:24:45.549] result() for ClusterFuture ... done
[10:24:45.550] result() for ClusterFuture ...
[10:24:45.550] - result already collected: FutureResult
[10:24:45.550] result() for ClusterFuture ... done
[10:24:45.550] result() for ClusterFuture ...
[10:24:45.550] - result already collected: FutureResult
[10:24:45.550] result() for ClusterFuture ... done
[10:24:45.550] - relayed: [n=2] TRUE, TRUE
[10:24:45.550] - queued futures: [n=2] TRUE, TRUE
[10:24:45.550] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[10:24:45.550] resolve() on list ... DONE
[10:24:45.550] result() for ClusterFuture ...
[10:24:45.551] - result already collected: FutureResult
[10:24:45.551] result() for ClusterFuture ... done
[10:24:45.551] result() for ClusterFuture ...
[10:24:45.551] - result already collected: FutureResult
[10:24:45.551] result() for ClusterFuture ... done
[10:24:45.551] result() for ClusterFuture ...
[10:24:45.551] - result already collected: FutureResult
[10:24:45.551] result() for ClusterFuture ... done
[10:24:45.551] result() for ClusterFuture ...
[10:24:45.551] - result already collected: FutureResult
[10:24:45.551] result() for ClusterFuture ... done
[10:24:45.552]  - Number of value chunks collected: 2
[10:24:45.552] Resolving 2 futures (chunks) ... DONE
[10:24:45.552] Reducing values from 2 chunks ...
[10:24:45.552]  - Number of values collected after concatenation: 2
[10:24:45.552]  - Number of values expected: 2
[10:24:45.552] Reducing values from 2 chunks ... DONE
[10:24:45.552] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[10:24:45.552] future_lapply() ...
[10:24:45.557] Number of chunks: 2
[10:24:45.557] getGlobalsAndPackagesXApply() ...
[10:24:45.557]  - future.globals: TRUE
[10:24:45.557] getGlobalsAndPackages() ...
[10:24:45.557] Searching for globals...
[10:24:45.558] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:24:45.559] Searching for globals ... DONE
[10:24:45.559] Resolving globals: FALSE
[10:24:45.559] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[10:24:45.559] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[10:24:45.560] - globals: [1] ‘FUN’
[10:24:45.560] 
[10:24:45.560] getGlobalsAndPackages() ... DONE
[10:24:45.560]  - globals found/used: [n=1] ‘FUN’
[10:24:45.560]  - needed namespaces: [n=0] 
[10:24:45.560] Finding globals ... DONE
[10:24:45.560]  - use_args: TRUE
[10:24:45.560]  - Getting '...' globals ...
[10:24:45.561] resolve() on list ...
[10:24:45.561]  recursive: 0
[10:24:45.561]  length: 1
[10:24:45.561]  elements: ‘...’
[10:24:45.561]  length: 0 (resolved future 1)
[10:24:45.561] resolve() on list ... DONE
[10:24:45.561]    - '...' content: [n=0] 
[10:24:45.561] List of 1
[10:24:45.561]  $ ...: list()
[10:24:45.561]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:45.561]  - attr(*, "where")=List of 1
[10:24:45.561]   ..$ ...:<environment: 0x55d2109fce60> 
[10:24:45.561]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:45.561]  - attr(*, "resolved")= logi TRUE
[10:24:45.561]  - attr(*, "total_size")= num NA
[10:24:45.564]  - Getting '...' globals ... DONE
[10:24:45.564] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:24:45.564] List of 2
[10:24:45.564]  $ ...future.FUN:function (x)  
[10:24:45.564]  $ ...          : list()
[10:24:45.564]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:45.564]  - attr(*, "where")=List of 2
[10:24:45.564]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:45.564]   ..$ ...          :<environment: 0x55d2109fce60> 
[10:24:45.564]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:45.564]  - attr(*, "resolved")= logi FALSE
[10:24:45.564]  - attr(*, "total_size")= num 4720
[10:24:45.567] Packages to be attached in all futures: [n=0] 
[10:24:45.567] getGlobalsAndPackagesXApply() ... DONE
[10:24:45.567] Number of futures (= number of chunks): 2
[10:24:45.567] Launching 2 futures (chunks) ...
[10:24:45.567] Chunk #1 of 2 ...
[10:24:45.567]  - Finding globals in 'X' for chunk #1 ...
[10:24:45.567] getGlobalsAndPackages() ...
[10:24:45.568] Searching for globals...
[10:24:45.568] 
[10:24:45.568] Searching for globals ... DONE
[10:24:45.568] - globals: [0] <none>
[10:24:45.568] getGlobalsAndPackages() ... DONE
[10:24:45.568]    + additional globals found: [n=0] 
[10:24:45.568]    + additional namespaces needed: [n=0] 
[10:24:45.568]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:45.568]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:45.568]  - seeds: <none>
[10:24:45.569]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:45.569] getGlobalsAndPackages() ...
[10:24:45.569] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:45.569] Resolving globals: FALSE
[10:24:45.569] Tweak future expression to call with '...' arguments ...
[10:24:45.569] {
[10:24:45.569]     do.call(function(...) {
[10:24:45.569]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:45.569]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:45.569]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:45.569]             on.exit(options(oopts), add = TRUE)
[10:24:45.569]         }
[10:24:45.569]         {
[10:24:45.569]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:45.569]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:45.569]                 ...future.FUN(...future.X_jj, ...)
[10:24:45.569]             })
[10:24:45.569]         }
[10:24:45.569]     }, args = future.call.arguments)
[10:24:45.569] }
[10:24:45.569] Tweak future expression to call with '...' arguments ... DONE
[10:24:45.570] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:45.570] 
[10:24:45.570] getGlobalsAndPackages() ... DONE
[10:24:45.570] run() for ‘Future’ ...
[10:24:45.570] - state: ‘created’
[10:24:45.570] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:45.584] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:45.584] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:45.584]   - Field: ‘node’
[10:24:45.584]   - Field: ‘label’
[10:24:45.585]   - Field: ‘local’
[10:24:45.585]   - Field: ‘owner’
[10:24:45.585]   - Field: ‘envir’
[10:24:45.585]   - Field: ‘workers’
[10:24:45.585]   - Field: ‘packages’
[10:24:45.585]   - Field: ‘gc’
[10:24:45.585]   - Field: ‘conditions’
[10:24:45.585]   - Field: ‘persistent’
[10:24:45.585]   - Field: ‘expr’
[10:24:45.585]   - Field: ‘uuid’
[10:24:45.586]   - Field: ‘seed’
[10:24:45.586]   - Field: ‘version’
[10:24:45.586]   - Field: ‘result’
[10:24:45.586]   - Field: ‘asynchronous’
[10:24:45.586]   - Field: ‘calls’
[10:24:45.586]   - Field: ‘globals’
[10:24:45.586]   - Field: ‘stdout’
[10:24:45.586]   - Field: ‘earlySignal’
[10:24:45.586]   - Field: ‘lazy’
[10:24:45.586]   - Field: ‘state’
[10:24:45.586] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:45.587] - Launch lazy future ...
[10:24:45.587] Packages needed by the future expression (n = 0): <none>
[10:24:45.587] Packages needed by future strategies (n = 0): <none>
[10:24:45.587] {
[10:24:45.587]     {
[10:24:45.587]         {
[10:24:45.587]             ...future.startTime <- base::Sys.time()
[10:24:45.587]             {
[10:24:45.587]                 {
[10:24:45.587]                   {
[10:24:45.587]                     {
[10:24:45.587]                       base::local({
[10:24:45.587]                         has_future <- base::requireNamespace("future", 
[10:24:45.587]                           quietly = TRUE)
[10:24:45.587]                         if (has_future) {
[10:24:45.587]                           ns <- base::getNamespace("future")
[10:24:45.587]                           version <- ns[[".package"]][["version"]]
[10:24:45.587]                           if (is.null(version)) 
[10:24:45.587]                             version <- utils::packageVersion("future")
[10:24:45.587]                         }
[10:24:45.587]                         else {
[10:24:45.587]                           version <- NULL
[10:24:45.587]                         }
[10:24:45.587]                         if (!has_future || version < "1.8.0") {
[10:24:45.587]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:45.587]                             "", base::R.version$version.string), 
[10:24:45.587]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:45.587]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:45.587]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:45.587]                               "release", "version")], collapse = " "), 
[10:24:45.587]                             hostname = base::Sys.info()[["nodename"]])
[10:24:45.587]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:45.587]                             info)
[10:24:45.587]                           info <- base::paste(info, collapse = "; ")
[10:24:45.587]                           if (!has_future) {
[10:24:45.587]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:45.587]                               info)
[10:24:45.587]                           }
[10:24:45.587]                           else {
[10:24:45.587]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:45.587]                               info, version)
[10:24:45.587]                           }
[10:24:45.587]                           base::stop(msg)
[10:24:45.587]                         }
[10:24:45.587]                       })
[10:24:45.587]                     }
[10:24:45.587]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:45.587]                     base::options(mc.cores = 1L)
[10:24:45.587]                   }
[10:24:45.587]                   options(future.plan = NULL)
[10:24:45.587]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:45.587]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:45.587]                 }
[10:24:45.587]                 ...future.workdir <- getwd()
[10:24:45.587]             }
[10:24:45.587]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:45.587]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:45.587]         }
[10:24:45.587]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:45.587]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:45.587]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:45.587]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:45.587]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:45.587]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:45.587]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:45.587]             base::names(...future.oldOptions))
[10:24:45.587]     }
[10:24:45.587]     if (FALSE) {
[10:24:45.587]     }
[10:24:45.587]     else {
[10:24:45.587]         if (TRUE) {
[10:24:45.587]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:45.587]                 open = "w")
[10:24:45.587]         }
[10:24:45.587]         else {
[10:24:45.587]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:45.587]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:45.587]         }
[10:24:45.587]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:45.587]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:45.587]             base::sink(type = "output", split = FALSE)
[10:24:45.587]             base::close(...future.stdout)
[10:24:45.587]         }, add = TRUE)
[10:24:45.587]     }
[10:24:45.587]     ...future.frame <- base::sys.nframe()
[10:24:45.587]     ...future.conditions <- base::list()
[10:24:45.587]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:45.587]     if (FALSE) {
[10:24:45.587]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:45.587]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:45.587]     }
[10:24:45.587]     ...future.result <- base::tryCatch({
[10:24:45.587]         base::withCallingHandlers({
[10:24:45.587]             ...future.value <- base::withVisible(base::local({
[10:24:45.587]                 ...future.makeSendCondition <- base::local({
[10:24:45.587]                   sendCondition <- NULL
[10:24:45.587]                   function(frame = 1L) {
[10:24:45.587]                     if (is.function(sendCondition)) 
[10:24:45.587]                       return(sendCondition)
[10:24:45.587]                     ns <- getNamespace("parallel")
[10:24:45.587]                     if (exists("sendData", mode = "function", 
[10:24:45.587]                       envir = ns)) {
[10:24:45.587]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:45.587]                         envir = ns)
[10:24:45.587]                       envir <- sys.frame(frame)
[10:24:45.587]                       master <- NULL
[10:24:45.587]                       while (!identical(envir, .GlobalEnv) && 
[10:24:45.587]                         !identical(envir, emptyenv())) {
[10:24:45.587]                         if (exists("master", mode = "list", envir = envir, 
[10:24:45.587]                           inherits = FALSE)) {
[10:24:45.587]                           master <- get("master", mode = "list", 
[10:24:45.587]                             envir = envir, inherits = FALSE)
[10:24:45.587]                           if (inherits(master, c("SOCKnode", 
[10:24:45.587]                             "SOCK0node"))) {
[10:24:45.587]                             sendCondition <<- function(cond) {
[10:24:45.587]                               data <- list(type = "VALUE", value = cond, 
[10:24:45.587]                                 success = TRUE)
[10:24:45.587]                               parallel_sendData(master, data)
[10:24:45.587]                             }
[10:24:45.587]                             return(sendCondition)
[10:24:45.587]                           }
[10:24:45.587]                         }
[10:24:45.587]                         frame <- frame + 1L
[10:24:45.587]                         envir <- sys.frame(frame)
[10:24:45.587]                       }
[10:24:45.587]                     }
[10:24:45.587]                     sendCondition <<- function(cond) NULL
[10:24:45.587]                   }
[10:24:45.587]                 })
[10:24:45.587]                 withCallingHandlers({
[10:24:45.587]                   {
[10:24:45.587]                     do.call(function(...) {
[10:24:45.587]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:45.587]                       if (!identical(...future.globals.maxSize.org, 
[10:24:45.587]                         ...future.globals.maxSize)) {
[10:24:45.587]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:45.587]                         on.exit(options(oopts), add = TRUE)
[10:24:45.587]                       }
[10:24:45.587]                       {
[10:24:45.587]                         lapply(seq_along(...future.elements_ii), 
[10:24:45.587]                           FUN = function(jj) {
[10:24:45.587]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:45.587]                             ...future.FUN(...future.X_jj, ...)
[10:24:45.587]                           })
[10:24:45.587]                       }
[10:24:45.587]                     }, args = future.call.arguments)
[10:24:45.587]                   }
[10:24:45.587]                 }, immediateCondition = function(cond) {
[10:24:45.587]                   sendCondition <- ...future.makeSendCondition()
[10:24:45.587]                   sendCondition(cond)
[10:24:45.587]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:45.587]                   {
[10:24:45.587]                     inherits <- base::inherits
[10:24:45.587]                     invokeRestart <- base::invokeRestart
[10:24:45.587]                     is.null <- base::is.null
[10:24:45.587]                     muffled <- FALSE
[10:24:45.587]                     if (inherits(cond, "message")) {
[10:24:45.587]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:45.587]                       if (muffled) 
[10:24:45.587]                         invokeRestart("muffleMessage")
[10:24:45.587]                     }
[10:24:45.587]                     else if (inherits(cond, "warning")) {
[10:24:45.587]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:45.587]                       if (muffled) 
[10:24:45.587]                         invokeRestart("muffleWarning")
[10:24:45.587]                     }
[10:24:45.587]                     else if (inherits(cond, "condition")) {
[10:24:45.587]                       if (!is.null(pattern)) {
[10:24:45.587]                         computeRestarts <- base::computeRestarts
[10:24:45.587]                         grepl <- base::grepl
[10:24:45.587]                         restarts <- computeRestarts(cond)
[10:24:45.587]                         for (restart in restarts) {
[10:24:45.587]                           name <- restart$name
[10:24:45.587]                           if (is.null(name)) 
[10:24:45.587]                             next
[10:24:45.587]                           if (!grepl(pattern, name)) 
[10:24:45.587]                             next
[10:24:45.587]                           invokeRestart(restart)
[10:24:45.587]                           muffled <- TRUE
[10:24:45.587]                           break
[10:24:45.587]                         }
[10:24:45.587]                       }
[10:24:45.587]                     }
[10:24:45.587]                     invisible(muffled)
[10:24:45.587]                   }
[10:24:45.587]                   muffleCondition(cond)
[10:24:45.587]                 })
[10:24:45.587]             }))
[10:24:45.587]             future::FutureResult(value = ...future.value$value, 
[10:24:45.587]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:45.587]                   ...future.rng), globalenv = if (FALSE) 
[10:24:45.587]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:45.587]                     ...future.globalenv.names))
[10:24:45.587]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:45.587]         }, condition = base::local({
[10:24:45.587]             c <- base::c
[10:24:45.587]             inherits <- base::inherits
[10:24:45.587]             invokeRestart <- base::invokeRestart
[10:24:45.587]             length <- base::length
[10:24:45.587]             list <- base::list
[10:24:45.587]             seq.int <- base::seq.int
[10:24:45.587]             signalCondition <- base::signalCondition
[10:24:45.587]             sys.calls <- base::sys.calls
[10:24:45.587]             `[[` <- base::`[[`
[10:24:45.587]             `+` <- base::`+`
[10:24:45.587]             `<<-` <- base::`<<-`
[10:24:45.587]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:45.587]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:45.587]                   3L)]
[10:24:45.587]             }
[10:24:45.587]             function(cond) {
[10:24:45.587]                 is_error <- inherits(cond, "error")
[10:24:45.587]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:45.587]                   NULL)
[10:24:45.587]                 if (is_error) {
[10:24:45.587]                   sessionInformation <- function() {
[10:24:45.587]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:45.587]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:45.587]                       search = base::search(), system = base::Sys.info())
[10:24:45.587]                   }
[10:24:45.587]                   ...future.conditions[[length(...future.conditions) + 
[10:24:45.587]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:45.587]                     cond$call), session = sessionInformation(), 
[10:24:45.587]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:45.587]                   signalCondition(cond)
[10:24:45.587]                 }
[10:24:45.587]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:45.587]                 "immediateCondition"))) {
[10:24:45.587]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:45.587]                   ...future.conditions[[length(...future.conditions) + 
[10:24:45.587]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:45.587]                   if (TRUE && !signal) {
[10:24:45.587]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:45.587]                     {
[10:24:45.587]                       inherits <- base::inherits
[10:24:45.587]                       invokeRestart <- base::invokeRestart
[10:24:45.587]                       is.null <- base::is.null
[10:24:45.587]                       muffled <- FALSE
[10:24:45.587]                       if (inherits(cond, "message")) {
[10:24:45.587]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:45.587]                         if (muffled) 
[10:24:45.587]                           invokeRestart("muffleMessage")
[10:24:45.587]                       }
[10:24:45.587]                       else if (inherits(cond, "warning")) {
[10:24:45.587]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:45.587]                         if (muffled) 
[10:24:45.587]                           invokeRestart("muffleWarning")
[10:24:45.587]                       }
[10:24:45.587]                       else if (inherits(cond, "condition")) {
[10:24:45.587]                         if (!is.null(pattern)) {
[10:24:45.587]                           computeRestarts <- base::computeRestarts
[10:24:45.587]                           grepl <- base::grepl
[10:24:45.587]                           restarts <- computeRestarts(cond)
[10:24:45.587]                           for (restart in restarts) {
[10:24:45.587]                             name <- restart$name
[10:24:45.587]                             if (is.null(name)) 
[10:24:45.587]                               next
[10:24:45.587]                             if (!grepl(pattern, name)) 
[10:24:45.587]                               next
[10:24:45.587]                             invokeRestart(restart)
[10:24:45.587]                             muffled <- TRUE
[10:24:45.587]                             break
[10:24:45.587]                           }
[10:24:45.587]                         }
[10:24:45.587]                       }
[10:24:45.587]                       invisible(muffled)
[10:24:45.587]                     }
[10:24:45.587]                     muffleCondition(cond, pattern = "^muffle")
[10:24:45.587]                   }
[10:24:45.587]                 }
[10:24:45.587]                 else {
[10:24:45.587]                   if (TRUE) {
[10:24:45.587]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:45.587]                     {
[10:24:45.587]                       inherits <- base::inherits
[10:24:45.587]                       invokeRestart <- base::invokeRestart
[10:24:45.587]                       is.null <- base::is.null
[10:24:45.587]                       muffled <- FALSE
[10:24:45.587]                       if (inherits(cond, "message")) {
[10:24:45.587]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:45.587]                         if (muffled) 
[10:24:45.587]                           invokeRestart("muffleMessage")
[10:24:45.587]                       }
[10:24:45.587]                       else if (inherits(cond, "warning")) {
[10:24:45.587]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:45.587]                         if (muffled) 
[10:24:45.587]                           invokeRestart("muffleWarning")
[10:24:45.587]                       }
[10:24:45.587]                       else if (inherits(cond, "condition")) {
[10:24:45.587]                         if (!is.null(pattern)) {
[10:24:45.587]                           computeRestarts <- base::computeRestarts
[10:24:45.587]                           grepl <- base::grepl
[10:24:45.587]                           restarts <- computeRestarts(cond)
[10:24:45.587]                           for (restart in restarts) {
[10:24:45.587]                             name <- restart$name
[10:24:45.587]                             if (is.null(name)) 
[10:24:45.587]                               next
[10:24:45.587]                             if (!grepl(pattern, name)) 
[10:24:45.587]                               next
[10:24:45.587]                             invokeRestart(restart)
[10:24:45.587]                             muffled <- TRUE
[10:24:45.587]                             break
[10:24:45.587]                           }
[10:24:45.587]                         }
[10:24:45.587]                       }
[10:24:45.587]                       invisible(muffled)
[10:24:45.587]                     }
[10:24:45.587]                     muffleCondition(cond, pattern = "^muffle")
[10:24:45.587]                   }
[10:24:45.587]                 }
[10:24:45.587]             }
[10:24:45.587]         }))
[10:24:45.587]     }, error = function(ex) {
[10:24:45.587]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:45.587]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:45.587]                 ...future.rng), started = ...future.startTime, 
[10:24:45.587]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:45.587]             version = "1.8"), class = "FutureResult")
[10:24:45.587]     }, finally = {
[10:24:45.587]         if (!identical(...future.workdir, getwd())) 
[10:24:45.587]             setwd(...future.workdir)
[10:24:45.587]         {
[10:24:45.587]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:45.587]                 ...future.oldOptions$nwarnings <- NULL
[10:24:45.587]             }
[10:24:45.587]             base::options(...future.oldOptions)
[10:24:45.587]             if (.Platform$OS.type == "windows") {
[10:24:45.587]                 old_names <- names(...future.oldEnvVars)
[10:24:45.587]                 envs <- base::Sys.getenv()
[10:24:45.587]                 names <- names(envs)
[10:24:45.587]                 common <- intersect(names, old_names)
[10:24:45.587]                 added <- setdiff(names, old_names)
[10:24:45.587]                 removed <- setdiff(old_names, names)
[10:24:45.587]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:45.587]                   envs[common]]
[10:24:45.587]                 NAMES <- toupper(changed)
[10:24:45.587]                 args <- list()
[10:24:45.587]                 for (kk in seq_along(NAMES)) {
[10:24:45.587]                   name <- changed[[kk]]
[10:24:45.587]                   NAME <- NAMES[[kk]]
[10:24:45.587]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:45.587]                     next
[10:24:45.587]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:45.587]                 }
[10:24:45.587]                 NAMES <- toupper(added)
[10:24:45.587]                 for (kk in seq_along(NAMES)) {
[10:24:45.587]                   name <- added[[kk]]
[10:24:45.587]                   NAME <- NAMES[[kk]]
[10:24:45.587]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:45.587]                     next
[10:24:45.587]                   args[[name]] <- ""
[10:24:45.587]                 }
[10:24:45.587]                 NAMES <- toupper(removed)
[10:24:45.587]                 for (kk in seq_along(NAMES)) {
[10:24:45.587]                   name <- removed[[kk]]
[10:24:45.587]                   NAME <- NAMES[[kk]]
[10:24:45.587]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:45.587]                     next
[10:24:45.587]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:45.587]                 }
[10:24:45.587]                 if (length(args) > 0) 
[10:24:45.587]                   base::do.call(base::Sys.setenv, args = args)
[10:24:45.587]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:45.587]             }
[10:24:45.587]             else {
[10:24:45.587]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:45.587]             }
[10:24:45.587]             {
[10:24:45.587]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:45.587]                   0L) {
[10:24:45.587]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:45.587]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:45.587]                   base::options(opts)
[10:24:45.587]                 }
[10:24:45.587]                 {
[10:24:45.587]                   {
[10:24:45.587]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:45.587]                     NULL
[10:24:45.587]                   }
[10:24:45.587]                   options(future.plan = NULL)
[10:24:45.587]                   if (is.na(NA_character_)) 
[10:24:45.587]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:45.587]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:45.587]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:45.587]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:45.587]                     envir = parent.frame()) 
[10:24:45.587]                   {
[10:24:45.587]                     if (is.function(workers)) 
[10:24:45.587]                       workers <- workers()
[10:24:45.587]                     workers <- structure(as.integer(workers), 
[10:24:45.587]                       class = class(workers))
[10:24:45.587]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:45.587]                       workers >= 1)
[10:24:45.587]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:45.587]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:45.587]                     }
[10:24:45.587]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:45.587]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:45.587]                       envir = envir)
[10:24:45.587]                     if (!future$lazy) 
[10:24:45.587]                       future <- run(future)
[10:24:45.587]                     invisible(future)
[10:24:45.587]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:45.587]                 }
[10:24:45.587]             }
[10:24:45.587]         }
[10:24:45.587]     })
[10:24:45.587]     if (TRUE) {
[10:24:45.587]         base::sink(type = "output", split = FALSE)
[10:24:45.587]         if (TRUE) {
[10:24:45.587]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:45.587]         }
[10:24:45.587]         else {
[10:24:45.587]             ...future.result["stdout"] <- base::list(NULL)
[10:24:45.587]         }
[10:24:45.587]         base::close(...future.stdout)
[10:24:45.587]         ...future.stdout <- NULL
[10:24:45.587]     }
[10:24:45.587]     ...future.result$conditions <- ...future.conditions
[10:24:45.587]     ...future.result$finished <- base::Sys.time()
[10:24:45.587]     ...future.result
[10:24:45.587] }
[10:24:45.590] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[10:24:45.590] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[10:24:45.591] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[10:24:45.591] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:24:45.591] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:24:45.591] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[10:24:45.592] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[10:24:45.592] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:24:45.592] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:24:45.592] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:24:45.592] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:24:45.593] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[10:24:45.593] MultisessionFuture started
[10:24:45.593] - Launch lazy future ... done
[10:24:45.593] run() for ‘MultisessionFuture’ ... done
[10:24:45.593] Created future:
[10:24:45.594] MultisessionFuture:
[10:24:45.594] Label: ‘future_lapply-1’
[10:24:45.594] Expression:
[10:24:45.594] {
[10:24:45.594]     do.call(function(...) {
[10:24:45.594]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:45.594]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:45.594]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:45.594]             on.exit(options(oopts), add = TRUE)
[10:24:45.594]         }
[10:24:45.594]         {
[10:24:45.594]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:45.594]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:45.594]                 ...future.FUN(...future.X_jj, ...)
[10:24:45.594]             })
[10:24:45.594]         }
[10:24:45.594]     }, args = future.call.arguments)
[10:24:45.594] }
[10:24:45.594] Lazy evaluation: FALSE
[10:24:45.594] Asynchronous evaluation: TRUE
[10:24:45.594] Local evaluation: TRUE
[10:24:45.594] Environment: R_GlobalEnv
[10:24:45.594] Capture standard output: TRUE
[10:24:45.594] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:45.594] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:45.594] Packages: <none>
[10:24:45.594] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:45.594] Resolved: FALSE
[10:24:45.594] Value: <not collected>
[10:24:45.594] Conditions captured: <none>
[10:24:45.594] Early signaling: FALSE
[10:24:45.594] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:45.594] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:45.605] Chunk #1 of 2 ... DONE
[10:24:45.605] Chunk #2 of 2 ...
[10:24:45.605]  - Finding globals in 'X' for chunk #2 ...
[10:24:45.605] getGlobalsAndPackages() ...
[10:24:45.606] Searching for globals...
[10:24:45.606] 
[10:24:45.606] Searching for globals ... DONE
[10:24:45.606] - globals: [0] <none>
[10:24:45.606] getGlobalsAndPackages() ... DONE
[10:24:45.606]    + additional globals found: [n=0] 
[10:24:45.606]    + additional namespaces needed: [n=0] 
[10:24:45.606]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:45.607]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:45.607]  - seeds: <none>
[10:24:45.607]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:45.607] getGlobalsAndPackages() ...
[10:24:45.607] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:45.607] Resolving globals: FALSE
[10:24:45.607] Tweak future expression to call with '...' arguments ...
[10:24:45.607] {
[10:24:45.607]     do.call(function(...) {
[10:24:45.607]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:45.607]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:45.607]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:45.607]             on.exit(options(oopts), add = TRUE)
[10:24:45.607]         }
[10:24:45.607]         {
[10:24:45.607]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:45.607]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:45.607]                 ...future.FUN(...future.X_jj, ...)
[10:24:45.607]             })
[10:24:45.607]         }
[10:24:45.607]     }, args = future.call.arguments)
[10:24:45.607] }
[10:24:45.608] Tweak future expression to call with '...' arguments ... DONE
[10:24:45.608] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:45.608] 
[10:24:45.608] getGlobalsAndPackages() ... DONE
[10:24:45.608] run() for ‘Future’ ...
[10:24:45.608] - state: ‘created’
[10:24:45.609] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:45.623] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:45.623] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:45.623]   - Field: ‘node’
[10:24:45.623]   - Field: ‘label’
[10:24:45.623]   - Field: ‘local’
[10:24:45.623]   - Field: ‘owner’
[10:24:45.623]   - Field: ‘envir’
[10:24:45.624]   - Field: ‘workers’
[10:24:45.624]   - Field: ‘packages’
[10:24:45.624]   - Field: ‘gc’
[10:24:45.624]   - Field: ‘conditions’
[10:24:45.624]   - Field: ‘persistent’
[10:24:45.624]   - Field: ‘expr’
[10:24:45.624]   - Field: ‘uuid’
[10:24:45.624]   - Field: ‘seed’
[10:24:45.624]   - Field: ‘version’
[10:24:45.624]   - Field: ‘result’
[10:24:45.624]   - Field: ‘asynchronous’
[10:24:45.625]   - Field: ‘calls’
[10:24:45.625]   - Field: ‘globals’
[10:24:45.625]   - Field: ‘stdout’
[10:24:45.625]   - Field: ‘earlySignal’
[10:24:45.625]   - Field: ‘lazy’
[10:24:45.625]   - Field: ‘state’
[10:24:45.625] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:45.625] - Launch lazy future ...
[10:24:45.626] Packages needed by the future expression (n = 0): <none>
[10:24:45.626] Packages needed by future strategies (n = 0): <none>
[10:24:45.626] {
[10:24:45.626]     {
[10:24:45.626]         {
[10:24:45.626]             ...future.startTime <- base::Sys.time()
[10:24:45.626]             {
[10:24:45.626]                 {
[10:24:45.626]                   {
[10:24:45.626]                     {
[10:24:45.626]                       base::local({
[10:24:45.626]                         has_future <- base::requireNamespace("future", 
[10:24:45.626]                           quietly = TRUE)
[10:24:45.626]                         if (has_future) {
[10:24:45.626]                           ns <- base::getNamespace("future")
[10:24:45.626]                           version <- ns[[".package"]][["version"]]
[10:24:45.626]                           if (is.null(version)) 
[10:24:45.626]                             version <- utils::packageVersion("future")
[10:24:45.626]                         }
[10:24:45.626]                         else {
[10:24:45.626]                           version <- NULL
[10:24:45.626]                         }
[10:24:45.626]                         if (!has_future || version < "1.8.0") {
[10:24:45.626]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:45.626]                             "", base::R.version$version.string), 
[10:24:45.626]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:45.626]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:45.626]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:45.626]                               "release", "version")], collapse = " "), 
[10:24:45.626]                             hostname = base::Sys.info()[["nodename"]])
[10:24:45.626]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:45.626]                             info)
[10:24:45.626]                           info <- base::paste(info, collapse = "; ")
[10:24:45.626]                           if (!has_future) {
[10:24:45.626]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:45.626]                               info)
[10:24:45.626]                           }
[10:24:45.626]                           else {
[10:24:45.626]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:45.626]                               info, version)
[10:24:45.626]                           }
[10:24:45.626]                           base::stop(msg)
[10:24:45.626]                         }
[10:24:45.626]                       })
[10:24:45.626]                     }
[10:24:45.626]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:45.626]                     base::options(mc.cores = 1L)
[10:24:45.626]                   }
[10:24:45.626]                   options(future.plan = NULL)
[10:24:45.626]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:45.626]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:45.626]                 }
[10:24:45.626]                 ...future.workdir <- getwd()
[10:24:45.626]             }
[10:24:45.626]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:45.626]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:45.626]         }
[10:24:45.626]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:45.626]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:45.626]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:45.626]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:45.626]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:45.626]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:45.626]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:45.626]             base::names(...future.oldOptions))
[10:24:45.626]     }
[10:24:45.626]     if (FALSE) {
[10:24:45.626]     }
[10:24:45.626]     else {
[10:24:45.626]         if (TRUE) {
[10:24:45.626]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:45.626]                 open = "w")
[10:24:45.626]         }
[10:24:45.626]         else {
[10:24:45.626]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:45.626]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:45.626]         }
[10:24:45.626]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:45.626]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:45.626]             base::sink(type = "output", split = FALSE)
[10:24:45.626]             base::close(...future.stdout)
[10:24:45.626]         }, add = TRUE)
[10:24:45.626]     }
[10:24:45.626]     ...future.frame <- base::sys.nframe()
[10:24:45.626]     ...future.conditions <- base::list()
[10:24:45.626]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:45.626]     if (FALSE) {
[10:24:45.626]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:45.626]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:45.626]     }
[10:24:45.626]     ...future.result <- base::tryCatch({
[10:24:45.626]         base::withCallingHandlers({
[10:24:45.626]             ...future.value <- base::withVisible(base::local({
[10:24:45.626]                 ...future.makeSendCondition <- base::local({
[10:24:45.626]                   sendCondition <- NULL
[10:24:45.626]                   function(frame = 1L) {
[10:24:45.626]                     if (is.function(sendCondition)) 
[10:24:45.626]                       return(sendCondition)
[10:24:45.626]                     ns <- getNamespace("parallel")
[10:24:45.626]                     if (exists("sendData", mode = "function", 
[10:24:45.626]                       envir = ns)) {
[10:24:45.626]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:45.626]                         envir = ns)
[10:24:45.626]                       envir <- sys.frame(frame)
[10:24:45.626]                       master <- NULL
[10:24:45.626]                       while (!identical(envir, .GlobalEnv) && 
[10:24:45.626]                         !identical(envir, emptyenv())) {
[10:24:45.626]                         if (exists("master", mode = "list", envir = envir, 
[10:24:45.626]                           inherits = FALSE)) {
[10:24:45.626]                           master <- get("master", mode = "list", 
[10:24:45.626]                             envir = envir, inherits = FALSE)
[10:24:45.626]                           if (inherits(master, c("SOCKnode", 
[10:24:45.626]                             "SOCK0node"))) {
[10:24:45.626]                             sendCondition <<- function(cond) {
[10:24:45.626]                               data <- list(type = "VALUE", value = cond, 
[10:24:45.626]                                 success = TRUE)
[10:24:45.626]                               parallel_sendData(master, data)
[10:24:45.626]                             }
[10:24:45.626]                             return(sendCondition)
[10:24:45.626]                           }
[10:24:45.626]                         }
[10:24:45.626]                         frame <- frame + 1L
[10:24:45.626]                         envir <- sys.frame(frame)
[10:24:45.626]                       }
[10:24:45.626]                     }
[10:24:45.626]                     sendCondition <<- function(cond) NULL
[10:24:45.626]                   }
[10:24:45.626]                 })
[10:24:45.626]                 withCallingHandlers({
[10:24:45.626]                   {
[10:24:45.626]                     do.call(function(...) {
[10:24:45.626]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:45.626]                       if (!identical(...future.globals.maxSize.org, 
[10:24:45.626]                         ...future.globals.maxSize)) {
[10:24:45.626]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:45.626]                         on.exit(options(oopts), add = TRUE)
[10:24:45.626]                       }
[10:24:45.626]                       {
[10:24:45.626]                         lapply(seq_along(...future.elements_ii), 
[10:24:45.626]                           FUN = function(jj) {
[10:24:45.626]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:45.626]                             ...future.FUN(...future.X_jj, ...)
[10:24:45.626]                           })
[10:24:45.626]                       }
[10:24:45.626]                     }, args = future.call.arguments)
[10:24:45.626]                   }
[10:24:45.626]                 }, immediateCondition = function(cond) {
[10:24:45.626]                   sendCondition <- ...future.makeSendCondition()
[10:24:45.626]                   sendCondition(cond)
[10:24:45.626]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:45.626]                   {
[10:24:45.626]                     inherits <- base::inherits
[10:24:45.626]                     invokeRestart <- base::invokeRestart
[10:24:45.626]                     is.null <- base::is.null
[10:24:45.626]                     muffled <- FALSE
[10:24:45.626]                     if (inherits(cond, "message")) {
[10:24:45.626]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:45.626]                       if (muffled) 
[10:24:45.626]                         invokeRestart("muffleMessage")
[10:24:45.626]                     }
[10:24:45.626]                     else if (inherits(cond, "warning")) {
[10:24:45.626]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:45.626]                       if (muffled) 
[10:24:45.626]                         invokeRestart("muffleWarning")
[10:24:45.626]                     }
[10:24:45.626]                     else if (inherits(cond, "condition")) {
[10:24:45.626]                       if (!is.null(pattern)) {
[10:24:45.626]                         computeRestarts <- base::computeRestarts
[10:24:45.626]                         grepl <- base::grepl
[10:24:45.626]                         restarts <- computeRestarts(cond)
[10:24:45.626]                         for (restart in restarts) {
[10:24:45.626]                           name <- restart$name
[10:24:45.626]                           if (is.null(name)) 
[10:24:45.626]                             next
[10:24:45.626]                           if (!grepl(pattern, name)) 
[10:24:45.626]                             next
[10:24:45.626]                           invokeRestart(restart)
[10:24:45.626]                           muffled <- TRUE
[10:24:45.626]                           break
[10:24:45.626]                         }
[10:24:45.626]                       }
[10:24:45.626]                     }
[10:24:45.626]                     invisible(muffled)
[10:24:45.626]                   }
[10:24:45.626]                   muffleCondition(cond)
[10:24:45.626]                 })
[10:24:45.626]             }))
[10:24:45.626]             future::FutureResult(value = ...future.value$value, 
[10:24:45.626]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:45.626]                   ...future.rng), globalenv = if (FALSE) 
[10:24:45.626]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:45.626]                     ...future.globalenv.names))
[10:24:45.626]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:45.626]         }, condition = base::local({
[10:24:45.626]             c <- base::c
[10:24:45.626]             inherits <- base::inherits
[10:24:45.626]             invokeRestart <- base::invokeRestart
[10:24:45.626]             length <- base::length
[10:24:45.626]             list <- base::list
[10:24:45.626]             seq.int <- base::seq.int
[10:24:45.626]             signalCondition <- base::signalCondition
[10:24:45.626]             sys.calls <- base::sys.calls
[10:24:45.626]             `[[` <- base::`[[`
[10:24:45.626]             `+` <- base::`+`
[10:24:45.626]             `<<-` <- base::`<<-`
[10:24:45.626]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:45.626]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:45.626]                   3L)]
[10:24:45.626]             }
[10:24:45.626]             function(cond) {
[10:24:45.626]                 is_error <- inherits(cond, "error")
[10:24:45.626]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:45.626]                   NULL)
[10:24:45.626]                 if (is_error) {
[10:24:45.626]                   sessionInformation <- function() {
[10:24:45.626]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:45.626]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:45.626]                       search = base::search(), system = base::Sys.info())
[10:24:45.626]                   }
[10:24:45.626]                   ...future.conditions[[length(...future.conditions) + 
[10:24:45.626]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:45.626]                     cond$call), session = sessionInformation(), 
[10:24:45.626]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:45.626]                   signalCondition(cond)
[10:24:45.626]                 }
[10:24:45.626]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:45.626]                 "immediateCondition"))) {
[10:24:45.626]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:45.626]                   ...future.conditions[[length(...future.conditions) + 
[10:24:45.626]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:45.626]                   if (TRUE && !signal) {
[10:24:45.626]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:45.626]                     {
[10:24:45.626]                       inherits <- base::inherits
[10:24:45.626]                       invokeRestart <- base::invokeRestart
[10:24:45.626]                       is.null <- base::is.null
[10:24:45.626]                       muffled <- FALSE
[10:24:45.626]                       if (inherits(cond, "message")) {
[10:24:45.626]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:45.626]                         if (muffled) 
[10:24:45.626]                           invokeRestart("muffleMessage")
[10:24:45.626]                       }
[10:24:45.626]                       else if (inherits(cond, "warning")) {
[10:24:45.626]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:45.626]                         if (muffled) 
[10:24:45.626]                           invokeRestart("muffleWarning")
[10:24:45.626]                       }
[10:24:45.626]                       else if (inherits(cond, "condition")) {
[10:24:45.626]                         if (!is.null(pattern)) {
[10:24:45.626]                           computeRestarts <- base::computeRestarts
[10:24:45.626]                           grepl <- base::grepl
[10:24:45.626]                           restarts <- computeRestarts(cond)
[10:24:45.626]                           for (restart in restarts) {
[10:24:45.626]                             name <- restart$name
[10:24:45.626]                             if (is.null(name)) 
[10:24:45.626]                               next
[10:24:45.626]                             if (!grepl(pattern, name)) 
[10:24:45.626]                               next
[10:24:45.626]                             invokeRestart(restart)
[10:24:45.626]                             muffled <- TRUE
[10:24:45.626]                             break
[10:24:45.626]                           }
[10:24:45.626]                         }
[10:24:45.626]                       }
[10:24:45.626]                       invisible(muffled)
[10:24:45.626]                     }
[10:24:45.626]                     muffleCondition(cond, pattern = "^muffle")
[10:24:45.626]                   }
[10:24:45.626]                 }
[10:24:45.626]                 else {
[10:24:45.626]                   if (TRUE) {
[10:24:45.626]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:45.626]                     {
[10:24:45.626]                       inherits <- base::inherits
[10:24:45.626]                       invokeRestart <- base::invokeRestart
[10:24:45.626]                       is.null <- base::is.null
[10:24:45.626]                       muffled <- FALSE
[10:24:45.626]                       if (inherits(cond, "message")) {
[10:24:45.626]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:45.626]                         if (muffled) 
[10:24:45.626]                           invokeRestart("muffleMessage")
[10:24:45.626]                       }
[10:24:45.626]                       else if (inherits(cond, "warning")) {
[10:24:45.626]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:45.626]                         if (muffled) 
[10:24:45.626]                           invokeRestart("muffleWarning")
[10:24:45.626]                       }
[10:24:45.626]                       else if (inherits(cond, "condition")) {
[10:24:45.626]                         if (!is.null(pattern)) {
[10:24:45.626]                           computeRestarts <- base::computeRestarts
[10:24:45.626]                           grepl <- base::grepl
[10:24:45.626]                           restarts <- computeRestarts(cond)
[10:24:45.626]                           for (restart in restarts) {
[10:24:45.626]                             name <- restart$name
[10:24:45.626]                             if (is.null(name)) 
[10:24:45.626]                               next
[10:24:45.626]                             if (!grepl(pattern, name)) 
[10:24:45.626]                               next
[10:24:45.626]                             invokeRestart(restart)
[10:24:45.626]                             muffled <- TRUE
[10:24:45.626]                             break
[10:24:45.626]                           }
[10:24:45.626]                         }
[10:24:45.626]                       }
[10:24:45.626]                       invisible(muffled)
[10:24:45.626]                     }
[10:24:45.626]                     muffleCondition(cond, pattern = "^muffle")
[10:24:45.626]                   }
[10:24:45.626]                 }
[10:24:45.626]             }
[10:24:45.626]         }))
[10:24:45.626]     }, error = function(ex) {
[10:24:45.626]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:45.626]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:45.626]                 ...future.rng), started = ...future.startTime, 
[10:24:45.626]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:45.626]             version = "1.8"), class = "FutureResult")
[10:24:45.626]     }, finally = {
[10:24:45.626]         if (!identical(...future.workdir, getwd())) 
[10:24:45.626]             setwd(...future.workdir)
[10:24:45.626]         {
[10:24:45.626]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:45.626]                 ...future.oldOptions$nwarnings <- NULL
[10:24:45.626]             }
[10:24:45.626]             base::options(...future.oldOptions)
[10:24:45.626]             if (.Platform$OS.type == "windows") {
[10:24:45.626]                 old_names <- names(...future.oldEnvVars)
[10:24:45.626]                 envs <- base::Sys.getenv()
[10:24:45.626]                 names <- names(envs)
[10:24:45.626]                 common <- intersect(names, old_names)
[10:24:45.626]                 added <- setdiff(names, old_names)
[10:24:45.626]                 removed <- setdiff(old_names, names)
[10:24:45.626]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:45.626]                   envs[common]]
[10:24:45.626]                 NAMES <- toupper(changed)
[10:24:45.626]                 args <- list()
[10:24:45.626]                 for (kk in seq_along(NAMES)) {
[10:24:45.626]                   name <- changed[[kk]]
[10:24:45.626]                   NAME <- NAMES[[kk]]
[10:24:45.626]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:45.626]                     next
[10:24:45.626]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:45.626]                 }
[10:24:45.626]                 NAMES <- toupper(added)
[10:24:45.626]                 for (kk in seq_along(NAMES)) {
[10:24:45.626]                   name <- added[[kk]]
[10:24:45.626]                   NAME <- NAMES[[kk]]
[10:24:45.626]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:45.626]                     next
[10:24:45.626]                   args[[name]] <- ""
[10:24:45.626]                 }
[10:24:45.626]                 NAMES <- toupper(removed)
[10:24:45.626]                 for (kk in seq_along(NAMES)) {
[10:24:45.626]                   name <- removed[[kk]]
[10:24:45.626]                   NAME <- NAMES[[kk]]
[10:24:45.626]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:45.626]                     next
[10:24:45.626]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:45.626]                 }
[10:24:45.626]                 if (length(args) > 0) 
[10:24:45.626]                   base::do.call(base::Sys.setenv, args = args)
[10:24:45.626]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:45.626]             }
[10:24:45.626]             else {
[10:24:45.626]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:45.626]             }
[10:24:45.626]             {
[10:24:45.626]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:45.626]                   0L) {
[10:24:45.626]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:45.626]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:45.626]                   base::options(opts)
[10:24:45.626]                 }
[10:24:45.626]                 {
[10:24:45.626]                   {
[10:24:45.626]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:45.626]                     NULL
[10:24:45.626]                   }
[10:24:45.626]                   options(future.plan = NULL)
[10:24:45.626]                   if (is.na(NA_character_)) 
[10:24:45.626]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:45.626]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:45.626]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:45.626]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:45.626]                     envir = parent.frame()) 
[10:24:45.626]                   {
[10:24:45.626]                     if (is.function(workers)) 
[10:24:45.626]                       workers <- workers()
[10:24:45.626]                     workers <- structure(as.integer(workers), 
[10:24:45.626]                       class = class(workers))
[10:24:45.626]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:45.626]                       workers >= 1)
[10:24:45.626]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:45.626]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:45.626]                     }
[10:24:45.626]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:45.626]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:45.626]                       envir = envir)
[10:24:45.626]                     if (!future$lazy) 
[10:24:45.626]                       future <- run(future)
[10:24:45.626]                     invisible(future)
[10:24:45.626]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:45.626]                 }
[10:24:45.626]             }
[10:24:45.626]         }
[10:24:45.626]     })
[10:24:45.626]     if (TRUE) {
[10:24:45.626]         base::sink(type = "output", split = FALSE)
[10:24:45.626]         if (TRUE) {
[10:24:45.626]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:45.626]         }
[10:24:45.626]         else {
[10:24:45.626]             ...future.result["stdout"] <- base::list(NULL)
[10:24:45.626]         }
[10:24:45.626]         base::close(...future.stdout)
[10:24:45.626]         ...future.stdout <- NULL
[10:24:45.626]     }
[10:24:45.626]     ...future.result$conditions <- ...future.conditions
[10:24:45.626]     ...future.result$finished <- base::Sys.time()
[10:24:45.626]     ...future.result
[10:24:45.626] }
[10:24:45.629] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[10:24:45.629] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[10:24:45.629] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[10:24:45.630] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:24:45.630] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:24:45.630] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[10:24:45.630] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[10:24:45.631] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:24:45.631] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:24:45.631] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:24:45.631] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:24:45.631] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[10:24:45.632] MultisessionFuture started
[10:24:45.632] - Launch lazy future ... done
[10:24:45.632] run() for ‘MultisessionFuture’ ... done
[10:24:45.632] Created future:
[10:24:45.632] MultisessionFuture:
[10:24:45.632] Label: ‘future_lapply-2’
[10:24:45.632] Expression:
[10:24:45.632] {
[10:24:45.632]     do.call(function(...) {
[10:24:45.632]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:45.632]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:45.632]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:45.632]             on.exit(options(oopts), add = TRUE)
[10:24:45.632]         }
[10:24:45.632]         {
[10:24:45.632]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:45.632]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:45.632]                 ...future.FUN(...future.X_jj, ...)
[10:24:45.632]             })
[10:24:45.632]         }
[10:24:45.632]     }, args = future.call.arguments)
[10:24:45.632] }
[10:24:45.632] Lazy evaluation: FALSE
[10:24:45.632] Asynchronous evaluation: TRUE
[10:24:45.632] Local evaluation: TRUE
[10:24:45.632] Environment: R_GlobalEnv
[10:24:45.632] Capture standard output: TRUE
[10:24:45.632] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:45.632] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:45.632] Packages: <none>
[10:24:45.632] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:45.632] Resolved: FALSE
[10:24:45.632] Value: <not collected>
[10:24:45.632] Conditions captured: <none>
[10:24:45.632] Early signaling: FALSE
[10:24:45.632] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:45.632] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:45.644] Chunk #2 of 2 ... DONE
[10:24:45.644] Launching 2 futures (chunks) ... DONE
[10:24:45.644] Resolving 2 futures (chunks) ...
[10:24:45.644] resolve() on list ...
[10:24:45.644]  recursive: 0
[10:24:45.644]  length: 2
[10:24:45.644] 
[10:24:45.687] receiveMessageFromWorker() for ClusterFuture ...
[10:24:45.687] - Validating connection of MultisessionFuture
[10:24:45.687] - received message: FutureResult
[10:24:45.687] - Received FutureResult
[10:24:45.687] - Erased future from FutureRegistry
[10:24:45.687] result() for ClusterFuture ...
[10:24:45.687] - result already collected: FutureResult
[10:24:45.687] result() for ClusterFuture ... done
[10:24:45.688] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:45.688] Future #2
[10:24:45.688] result() for ClusterFuture ...
[10:24:45.688] - result already collected: FutureResult
[10:24:45.688] result() for ClusterFuture ... done
[10:24:45.688] result() for ClusterFuture ...
[10:24:45.688] - result already collected: FutureResult
[10:24:45.688] result() for ClusterFuture ... done
[10:24:45.688] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:24:45.688] - nx: 2
[10:24:45.688] - relay: TRUE
[10:24:45.689] - stdout: TRUE
[10:24:45.689] - signal: TRUE
[10:24:45.689] - resignal: FALSE
[10:24:45.689] - force: TRUE
[10:24:45.689] - relayed: [n=2] FALSE, FALSE
[10:24:45.689] - queued futures: [n=2] FALSE, FALSE
[10:24:45.689]  - until=1
[10:24:45.689]  - relaying element #1
[10:24:45.689] - relayed: [n=2] FALSE, FALSE
[10:24:45.689] - queued futures: [n=2] FALSE, TRUE
[10:24:45.689] signalConditionsASAP(NULL, pos=2) ... done
[10:24:45.690]  length: 1 (resolved future 2)
[10:24:46.139] receiveMessageFromWorker() for ClusterFuture ...
[10:24:46.140] - Validating connection of MultisessionFuture
[10:24:46.140] - received message: FutureResult
[10:24:46.140] - Received FutureResult
[10:24:46.140] - Erased future from FutureRegistry
[10:24:46.140] result() for ClusterFuture ...
[10:24:46.140] - result already collected: FutureResult
[10:24:46.140] result() for ClusterFuture ... done
[10:24:46.140] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:46.141] Future #1
[10:24:46.141] result() for ClusterFuture ...
[10:24:46.141] - result already collected: FutureResult
[10:24:46.141] result() for ClusterFuture ... done
[10:24:46.141] result() for ClusterFuture ...
[10:24:46.141] - result already collected: FutureResult
[10:24:46.141] result() for ClusterFuture ... done
[10:24:46.141] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:24:46.141] - nx: 2
[10:24:46.141] - relay: TRUE
[10:24:46.141] - stdout: TRUE
[10:24:46.142] - signal: TRUE
[10:24:46.142] - resignal: FALSE
[10:24:46.142] - force: TRUE
[10:24:46.142] - relayed: [n=2] FALSE, FALSE
[10:24:46.142] - queued futures: [n=2] FALSE, TRUE
[10:24:46.142]  - until=1
[10:24:46.142]  - relaying element #1
[10:24:46.142] result() for ClusterFuture ...
[10:24:46.142] - result already collected: FutureResult
[10:24:46.142] result() for ClusterFuture ... done
[10:24:46.142] result() for ClusterFuture ...
[10:24:46.142] - result already collected: FutureResult
[10:24:46.143] result() for ClusterFuture ... done
[10:24:46.143] result() for ClusterFuture ...
[10:24:46.143] - result already collected: FutureResult
[10:24:46.143] result() for ClusterFuture ... done
[10:24:46.143] result() for ClusterFuture ...
[10:24:46.143] - result already collected: FutureResult
[10:24:46.143] result() for ClusterFuture ... done
[10:24:46.143] - relayed: [n=2] TRUE, FALSE
[10:24:46.143] - queued futures: [n=2] TRUE, TRUE
[10:24:46.143] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:24:46.143]  length: 0 (resolved future 1)
[10:24:46.144] Relaying remaining futures
[10:24:46.144] signalConditionsASAP(NULL, pos=0) ...
[10:24:46.144] - nx: 2
[10:24:46.144] - relay: TRUE
[10:24:46.144] - stdout: TRUE
[10:24:46.146] - signal: TRUE
[10:24:46.146] - resignal: FALSE
[10:24:46.146] - force: TRUE
[10:24:46.146] - relayed: [n=2] TRUE, FALSE
[10:24:46.146] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:46.146]  - relaying element #2
[10:24:46.146] result() for ClusterFuture ...
[10:24:46.147] - result already collected: FutureResult
[10:24:46.147] result() for ClusterFuture ... done
[10:24:46.147] result() for ClusterFuture ...
[10:24:46.147] - result already collected: FutureResult
[10:24:46.147] result() for ClusterFuture ... done
[10:24:46.147] result() for ClusterFuture ...
[10:24:46.147] - result already collected: FutureResult
[10:24:46.147] result() for ClusterFuture ... done
[10:24:46.147] result() for ClusterFuture ...
[10:24:46.147] - result already collected: FutureResult
[10:24:46.147] result() for ClusterFuture ... done
[10:24:46.148] - relayed: [n=2] TRUE, TRUE
[10:24:46.148] - queued futures: [n=2] TRUE, TRUE
[10:24:46.148] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[10:24:46.148] resolve() on list ... DONE
[10:24:46.148] result() for ClusterFuture ...
[10:24:46.148] - result already collected: FutureResult
[10:24:46.148] result() for ClusterFuture ... done
[10:24:46.148] result() for ClusterFuture ...
[10:24:46.148] - result already collected: FutureResult
[10:24:46.148] result() for ClusterFuture ... done
[10:24:46.148] result() for ClusterFuture ...
[10:24:46.148] - result already collected: FutureResult
[10:24:46.149] result() for ClusterFuture ... done
[10:24:46.149] result() for ClusterFuture ...
[10:24:46.149] - result already collected: FutureResult
[10:24:46.149] result() for ClusterFuture ... done
[10:24:46.149]  - Number of value chunks collected: 2
[10:24:46.149] Resolving 2 futures (chunks) ... DONE
[10:24:46.149] Reducing values from 2 chunks ...
[10:24:46.149]  - Number of values collected after concatenation: 2
[10:24:46.149]  - Number of values expected: 2
[10:24:46.149] Reducing values from 2 chunks ... DONE
[10:24:46.149] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[10:24:46.150] future_lapply() ...
[10:24:46.154] Number of chunks: 2
[10:24:46.154] getGlobalsAndPackagesXApply() ...
[10:24:46.154]  - future.globals: TRUE
[10:24:46.154] getGlobalsAndPackages() ...
[10:24:46.155] Searching for globals...
[10:24:46.156] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:24:46.156] Searching for globals ... DONE
[10:24:46.156] Resolving globals: FALSE
[10:24:46.156] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[10:24:46.157] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[10:24:46.157] - globals: [1] ‘FUN’
[10:24:46.157] 
[10:24:46.157] getGlobalsAndPackages() ... DONE
[10:24:46.157]  - globals found/used: [n=1] ‘FUN’
[10:24:46.157]  - needed namespaces: [n=0] 
[10:24:46.157] Finding globals ... DONE
[10:24:46.158]  - use_args: TRUE
[10:24:46.158]  - Getting '...' globals ...
[10:24:46.158] resolve() on list ...
[10:24:46.158]  recursive: 0
[10:24:46.158]  length: 1
[10:24:46.158]  elements: ‘...’
[10:24:46.158]  length: 0 (resolved future 1)
[10:24:46.158] resolve() on list ... DONE
[10:24:46.158]    - '...' content: [n=0] 
[10:24:46.159] List of 1
[10:24:46.159]  $ ...: list()
[10:24:46.159]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:46.159]  - attr(*, "where")=List of 1
[10:24:46.159]   ..$ ...:<environment: 0x55d2118e87c0> 
[10:24:46.159]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:46.159]  - attr(*, "resolved")= logi TRUE
[10:24:46.159]  - attr(*, "total_size")= num NA
[10:24:46.161]  - Getting '...' globals ... DONE
[10:24:46.161] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:24:46.161] List of 2
[10:24:46.161]  $ ...future.FUN:function (x)  
[10:24:46.161]  $ ...          : list()
[10:24:46.161]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:24:46.161]  - attr(*, "where")=List of 2
[10:24:46.161]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:46.161]   ..$ ...          :<environment: 0x55d2118e87c0> 
[10:24:46.161]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:46.161]  - attr(*, "resolved")= logi FALSE
[10:24:46.161]  - attr(*, "total_size")= num 4720
[10:24:46.164] Packages to be attached in all futures: [n=0] 
[10:24:46.164] getGlobalsAndPackagesXApply() ... DONE
[10:24:46.164] Number of futures (= number of chunks): 2
[10:24:46.164] Launching 2 futures (chunks) ...
[10:24:46.164] Chunk #1 of 2 ...
[10:24:46.165]  - Finding globals in 'X' for chunk #1 ...
[10:24:46.165] getGlobalsAndPackages() ...
[10:24:46.165] Searching for globals...
[10:24:46.165] 
[10:24:46.165] Searching for globals ... DONE
[10:24:46.165] - globals: [0] <none>
[10:24:46.165] getGlobalsAndPackages() ... DONE
[10:24:46.165]    + additional globals found: [n=0] 
[10:24:46.166]    + additional namespaces needed: [n=0] 
[10:24:46.166]  - Finding globals in 'X' for chunk #1 ... DONE
[10:24:46.166]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:46.166]  - seeds: <none>
[10:24:46.166]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:46.166] getGlobalsAndPackages() ...
[10:24:46.166] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:46.166] Resolving globals: FALSE
[10:24:46.166] Tweak future expression to call with '...' arguments ...
[10:24:46.166] {
[10:24:46.166]     do.call(function(...) {
[10:24:46.166]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:46.166]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:46.166]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:46.166]             on.exit(options(oopts), add = TRUE)
[10:24:46.166]         }
[10:24:46.166]         {
[10:24:46.166]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:46.166]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:46.166]                 ...future.FUN(...future.X_jj, ...)
[10:24:46.166]             })
[10:24:46.166]         }
[10:24:46.166]     }, args = future.call.arguments)
[10:24:46.166] }
[10:24:46.167] Tweak future expression to call with '...' arguments ... DONE
[10:24:46.167] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:46.167] 
[10:24:46.167] getGlobalsAndPackages() ... DONE
[10:24:46.168] run() for ‘Future’ ...
[10:24:46.168] - state: ‘created’
[10:24:46.168] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:46.184] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:46.184] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:46.184]   - Field: ‘node’
[10:24:46.184]   - Field: ‘label’
[10:24:46.184]   - Field: ‘local’
[10:24:46.184]   - Field: ‘owner’
[10:24:46.184]   - Field: ‘envir’
[10:24:46.184]   - Field: ‘workers’
[10:24:46.185]   - Field: ‘packages’
[10:24:46.185]   - Field: ‘gc’
[10:24:46.185]   - Field: ‘conditions’
[10:24:46.185]   - Field: ‘persistent’
[10:24:46.185]   - Field: ‘expr’
[10:24:46.185]   - Field: ‘uuid’
[10:24:46.185]   - Field: ‘seed’
[10:24:46.185]   - Field: ‘version’
[10:24:46.185]   - Field: ‘result’
[10:24:46.185]   - Field: ‘asynchronous’
[10:24:46.186]   - Field: ‘calls’
[10:24:46.186]   - Field: ‘globals’
[10:24:46.186]   - Field: ‘stdout’
[10:24:46.186]   - Field: ‘earlySignal’
[10:24:46.186]   - Field: ‘lazy’
[10:24:46.186]   - Field: ‘state’
[10:24:46.186] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:46.186] - Launch lazy future ...
[10:24:46.186] Packages needed by the future expression (n = 0): <none>
[10:24:46.187] Packages needed by future strategies (n = 0): <none>
[10:24:46.187] {
[10:24:46.187]     {
[10:24:46.187]         {
[10:24:46.187]             ...future.startTime <- base::Sys.time()
[10:24:46.187]             {
[10:24:46.187]                 {
[10:24:46.187]                   {
[10:24:46.187]                     {
[10:24:46.187]                       base::local({
[10:24:46.187]                         has_future <- base::requireNamespace("future", 
[10:24:46.187]                           quietly = TRUE)
[10:24:46.187]                         if (has_future) {
[10:24:46.187]                           ns <- base::getNamespace("future")
[10:24:46.187]                           version <- ns[[".package"]][["version"]]
[10:24:46.187]                           if (is.null(version)) 
[10:24:46.187]                             version <- utils::packageVersion("future")
[10:24:46.187]                         }
[10:24:46.187]                         else {
[10:24:46.187]                           version <- NULL
[10:24:46.187]                         }
[10:24:46.187]                         if (!has_future || version < "1.8.0") {
[10:24:46.187]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:46.187]                             "", base::R.version$version.string), 
[10:24:46.187]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:46.187]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:46.187]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:46.187]                               "release", "version")], collapse = " "), 
[10:24:46.187]                             hostname = base::Sys.info()[["nodename"]])
[10:24:46.187]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:46.187]                             info)
[10:24:46.187]                           info <- base::paste(info, collapse = "; ")
[10:24:46.187]                           if (!has_future) {
[10:24:46.187]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:46.187]                               info)
[10:24:46.187]                           }
[10:24:46.187]                           else {
[10:24:46.187]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:46.187]                               info, version)
[10:24:46.187]                           }
[10:24:46.187]                           base::stop(msg)
[10:24:46.187]                         }
[10:24:46.187]                       })
[10:24:46.187]                     }
[10:24:46.187]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:46.187]                     base::options(mc.cores = 1L)
[10:24:46.187]                   }
[10:24:46.187]                   options(future.plan = NULL)
[10:24:46.187]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:46.187]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:46.187]                 }
[10:24:46.187]                 ...future.workdir <- getwd()
[10:24:46.187]             }
[10:24:46.187]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:46.187]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:46.187]         }
[10:24:46.187]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:46.187]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:46.187]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:46.187]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:46.187]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:46.187]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:46.187]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:46.187]             base::names(...future.oldOptions))
[10:24:46.187]     }
[10:24:46.187]     if (TRUE) {
[10:24:46.187]     }
[10:24:46.187]     else {
[10:24:46.187]         if (NA) {
[10:24:46.187]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:46.187]                 open = "w")
[10:24:46.187]         }
[10:24:46.187]         else {
[10:24:46.187]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:46.187]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:46.187]         }
[10:24:46.187]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:46.187]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:46.187]             base::sink(type = "output", split = FALSE)
[10:24:46.187]             base::close(...future.stdout)
[10:24:46.187]         }, add = TRUE)
[10:24:46.187]     }
[10:24:46.187]     ...future.frame <- base::sys.nframe()
[10:24:46.187]     ...future.conditions <- base::list()
[10:24:46.187]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:46.187]     if (FALSE) {
[10:24:46.187]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:46.187]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:46.187]     }
[10:24:46.187]     ...future.result <- base::tryCatch({
[10:24:46.187]         base::withCallingHandlers({
[10:24:46.187]             ...future.value <- base::withVisible(base::local({
[10:24:46.187]                 ...future.makeSendCondition <- base::local({
[10:24:46.187]                   sendCondition <- NULL
[10:24:46.187]                   function(frame = 1L) {
[10:24:46.187]                     if (is.function(sendCondition)) 
[10:24:46.187]                       return(sendCondition)
[10:24:46.187]                     ns <- getNamespace("parallel")
[10:24:46.187]                     if (exists("sendData", mode = "function", 
[10:24:46.187]                       envir = ns)) {
[10:24:46.187]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:46.187]                         envir = ns)
[10:24:46.187]                       envir <- sys.frame(frame)
[10:24:46.187]                       master <- NULL
[10:24:46.187]                       while (!identical(envir, .GlobalEnv) && 
[10:24:46.187]                         !identical(envir, emptyenv())) {
[10:24:46.187]                         if (exists("master", mode = "list", envir = envir, 
[10:24:46.187]                           inherits = FALSE)) {
[10:24:46.187]                           master <- get("master", mode = "list", 
[10:24:46.187]                             envir = envir, inherits = FALSE)
[10:24:46.187]                           if (inherits(master, c("SOCKnode", 
[10:24:46.187]                             "SOCK0node"))) {
[10:24:46.187]                             sendCondition <<- function(cond) {
[10:24:46.187]                               data <- list(type = "VALUE", value = cond, 
[10:24:46.187]                                 success = TRUE)
[10:24:46.187]                               parallel_sendData(master, data)
[10:24:46.187]                             }
[10:24:46.187]                             return(sendCondition)
[10:24:46.187]                           }
[10:24:46.187]                         }
[10:24:46.187]                         frame <- frame + 1L
[10:24:46.187]                         envir <- sys.frame(frame)
[10:24:46.187]                       }
[10:24:46.187]                     }
[10:24:46.187]                     sendCondition <<- function(cond) NULL
[10:24:46.187]                   }
[10:24:46.187]                 })
[10:24:46.187]                 withCallingHandlers({
[10:24:46.187]                   {
[10:24:46.187]                     do.call(function(...) {
[10:24:46.187]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:46.187]                       if (!identical(...future.globals.maxSize.org, 
[10:24:46.187]                         ...future.globals.maxSize)) {
[10:24:46.187]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:46.187]                         on.exit(options(oopts), add = TRUE)
[10:24:46.187]                       }
[10:24:46.187]                       {
[10:24:46.187]                         lapply(seq_along(...future.elements_ii), 
[10:24:46.187]                           FUN = function(jj) {
[10:24:46.187]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:46.187]                             ...future.FUN(...future.X_jj, ...)
[10:24:46.187]                           })
[10:24:46.187]                       }
[10:24:46.187]                     }, args = future.call.arguments)
[10:24:46.187]                   }
[10:24:46.187]                 }, immediateCondition = function(cond) {
[10:24:46.187]                   sendCondition <- ...future.makeSendCondition()
[10:24:46.187]                   sendCondition(cond)
[10:24:46.187]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:46.187]                   {
[10:24:46.187]                     inherits <- base::inherits
[10:24:46.187]                     invokeRestart <- base::invokeRestart
[10:24:46.187]                     is.null <- base::is.null
[10:24:46.187]                     muffled <- FALSE
[10:24:46.187]                     if (inherits(cond, "message")) {
[10:24:46.187]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:46.187]                       if (muffled) 
[10:24:46.187]                         invokeRestart("muffleMessage")
[10:24:46.187]                     }
[10:24:46.187]                     else if (inherits(cond, "warning")) {
[10:24:46.187]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:46.187]                       if (muffled) 
[10:24:46.187]                         invokeRestart("muffleWarning")
[10:24:46.187]                     }
[10:24:46.187]                     else if (inherits(cond, "condition")) {
[10:24:46.187]                       if (!is.null(pattern)) {
[10:24:46.187]                         computeRestarts <- base::computeRestarts
[10:24:46.187]                         grepl <- base::grepl
[10:24:46.187]                         restarts <- computeRestarts(cond)
[10:24:46.187]                         for (restart in restarts) {
[10:24:46.187]                           name <- restart$name
[10:24:46.187]                           if (is.null(name)) 
[10:24:46.187]                             next
[10:24:46.187]                           if (!grepl(pattern, name)) 
[10:24:46.187]                             next
[10:24:46.187]                           invokeRestart(restart)
[10:24:46.187]                           muffled <- TRUE
[10:24:46.187]                           break
[10:24:46.187]                         }
[10:24:46.187]                       }
[10:24:46.187]                     }
[10:24:46.187]                     invisible(muffled)
[10:24:46.187]                   }
[10:24:46.187]                   muffleCondition(cond)
[10:24:46.187]                 })
[10:24:46.187]             }))
[10:24:46.187]             future::FutureResult(value = ...future.value$value, 
[10:24:46.187]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:46.187]                   ...future.rng), globalenv = if (FALSE) 
[10:24:46.187]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:46.187]                     ...future.globalenv.names))
[10:24:46.187]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:46.187]         }, condition = base::local({
[10:24:46.187]             c <- base::c
[10:24:46.187]             inherits <- base::inherits
[10:24:46.187]             invokeRestart <- base::invokeRestart
[10:24:46.187]             length <- base::length
[10:24:46.187]             list <- base::list
[10:24:46.187]             seq.int <- base::seq.int
[10:24:46.187]             signalCondition <- base::signalCondition
[10:24:46.187]             sys.calls <- base::sys.calls
[10:24:46.187]             `[[` <- base::`[[`
[10:24:46.187]             `+` <- base::`+`
[10:24:46.187]             `<<-` <- base::`<<-`
[10:24:46.187]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:46.187]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:46.187]                   3L)]
[10:24:46.187]             }
[10:24:46.187]             function(cond) {
[10:24:46.187]                 is_error <- inherits(cond, "error")
[10:24:46.187]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:46.187]                   NULL)
[10:24:46.187]                 if (is_error) {
[10:24:46.187]                   sessionInformation <- function() {
[10:24:46.187]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:46.187]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:46.187]                       search = base::search(), system = base::Sys.info())
[10:24:46.187]                   }
[10:24:46.187]                   ...future.conditions[[length(...future.conditions) + 
[10:24:46.187]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:46.187]                     cond$call), session = sessionInformation(), 
[10:24:46.187]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:46.187]                   signalCondition(cond)
[10:24:46.187]                 }
[10:24:46.187]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:46.187]                 "immediateCondition"))) {
[10:24:46.187]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:46.187]                   ...future.conditions[[length(...future.conditions) + 
[10:24:46.187]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:46.187]                   if (TRUE && !signal) {
[10:24:46.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:46.187]                     {
[10:24:46.187]                       inherits <- base::inherits
[10:24:46.187]                       invokeRestart <- base::invokeRestart
[10:24:46.187]                       is.null <- base::is.null
[10:24:46.187]                       muffled <- FALSE
[10:24:46.187]                       if (inherits(cond, "message")) {
[10:24:46.187]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:46.187]                         if (muffled) 
[10:24:46.187]                           invokeRestart("muffleMessage")
[10:24:46.187]                       }
[10:24:46.187]                       else if (inherits(cond, "warning")) {
[10:24:46.187]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:46.187]                         if (muffled) 
[10:24:46.187]                           invokeRestart("muffleWarning")
[10:24:46.187]                       }
[10:24:46.187]                       else if (inherits(cond, "condition")) {
[10:24:46.187]                         if (!is.null(pattern)) {
[10:24:46.187]                           computeRestarts <- base::computeRestarts
[10:24:46.187]                           grepl <- base::grepl
[10:24:46.187]                           restarts <- computeRestarts(cond)
[10:24:46.187]                           for (restart in restarts) {
[10:24:46.187]                             name <- restart$name
[10:24:46.187]                             if (is.null(name)) 
[10:24:46.187]                               next
[10:24:46.187]                             if (!grepl(pattern, name)) 
[10:24:46.187]                               next
[10:24:46.187]                             invokeRestart(restart)
[10:24:46.187]                             muffled <- TRUE
[10:24:46.187]                             break
[10:24:46.187]                           }
[10:24:46.187]                         }
[10:24:46.187]                       }
[10:24:46.187]                       invisible(muffled)
[10:24:46.187]                     }
[10:24:46.187]                     muffleCondition(cond, pattern = "^muffle")
[10:24:46.187]                   }
[10:24:46.187]                 }
[10:24:46.187]                 else {
[10:24:46.187]                   if (TRUE) {
[10:24:46.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:46.187]                     {
[10:24:46.187]                       inherits <- base::inherits
[10:24:46.187]                       invokeRestart <- base::invokeRestart
[10:24:46.187]                       is.null <- base::is.null
[10:24:46.187]                       muffled <- FALSE
[10:24:46.187]                       if (inherits(cond, "message")) {
[10:24:46.187]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:46.187]                         if (muffled) 
[10:24:46.187]                           invokeRestart("muffleMessage")
[10:24:46.187]                       }
[10:24:46.187]                       else if (inherits(cond, "warning")) {
[10:24:46.187]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:46.187]                         if (muffled) 
[10:24:46.187]                           invokeRestart("muffleWarning")
[10:24:46.187]                       }
[10:24:46.187]                       else if (inherits(cond, "condition")) {
[10:24:46.187]                         if (!is.null(pattern)) {
[10:24:46.187]                           computeRestarts <- base::computeRestarts
[10:24:46.187]                           grepl <- base::grepl
[10:24:46.187]                           restarts <- computeRestarts(cond)
[10:24:46.187]                           for (restart in restarts) {
[10:24:46.187]                             name <- restart$name
[10:24:46.187]                             if (is.null(name)) 
[10:24:46.187]                               next
[10:24:46.187]                             if (!grepl(pattern, name)) 
[10:24:46.187]                               next
[10:24:46.187]                             invokeRestart(restart)
[10:24:46.187]                             muffled <- TRUE
[10:24:46.187]                             break
[10:24:46.187]                           }
[10:24:46.187]                         }
[10:24:46.187]                       }
[10:24:46.187]                       invisible(muffled)
[10:24:46.187]                     }
[10:24:46.187]                     muffleCondition(cond, pattern = "^muffle")
[10:24:46.187]                   }
[10:24:46.187]                 }
[10:24:46.187]             }
[10:24:46.187]         }))
[10:24:46.187]     }, error = function(ex) {
[10:24:46.187]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:46.187]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:46.187]                 ...future.rng), started = ...future.startTime, 
[10:24:46.187]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:46.187]             version = "1.8"), class = "FutureResult")
[10:24:46.187]     }, finally = {
[10:24:46.187]         if (!identical(...future.workdir, getwd())) 
[10:24:46.187]             setwd(...future.workdir)
[10:24:46.187]         {
[10:24:46.187]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:46.187]                 ...future.oldOptions$nwarnings <- NULL
[10:24:46.187]             }
[10:24:46.187]             base::options(...future.oldOptions)
[10:24:46.187]             if (.Platform$OS.type == "windows") {
[10:24:46.187]                 old_names <- names(...future.oldEnvVars)
[10:24:46.187]                 envs <- base::Sys.getenv()
[10:24:46.187]                 names <- names(envs)
[10:24:46.187]                 common <- intersect(names, old_names)
[10:24:46.187]                 added <- setdiff(names, old_names)
[10:24:46.187]                 removed <- setdiff(old_names, names)
[10:24:46.187]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:46.187]                   envs[common]]
[10:24:46.187]                 NAMES <- toupper(changed)
[10:24:46.187]                 args <- list()
[10:24:46.187]                 for (kk in seq_along(NAMES)) {
[10:24:46.187]                   name <- changed[[kk]]
[10:24:46.187]                   NAME <- NAMES[[kk]]
[10:24:46.187]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:46.187]                     next
[10:24:46.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:46.187]                 }
[10:24:46.187]                 NAMES <- toupper(added)
[10:24:46.187]                 for (kk in seq_along(NAMES)) {
[10:24:46.187]                   name <- added[[kk]]
[10:24:46.187]                   NAME <- NAMES[[kk]]
[10:24:46.187]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:46.187]                     next
[10:24:46.187]                   args[[name]] <- ""
[10:24:46.187]                 }
[10:24:46.187]                 NAMES <- toupper(removed)
[10:24:46.187]                 for (kk in seq_along(NAMES)) {
[10:24:46.187]                   name <- removed[[kk]]
[10:24:46.187]                   NAME <- NAMES[[kk]]
[10:24:46.187]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:46.187]                     next
[10:24:46.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:46.187]                 }
[10:24:46.187]                 if (length(args) > 0) 
[10:24:46.187]                   base::do.call(base::Sys.setenv, args = args)
[10:24:46.187]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:46.187]             }
[10:24:46.187]             else {
[10:24:46.187]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:46.187]             }
[10:24:46.187]             {
[10:24:46.187]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:46.187]                   0L) {
[10:24:46.187]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:46.187]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:46.187]                   base::options(opts)
[10:24:46.187]                 }
[10:24:46.187]                 {
[10:24:46.187]                   {
[10:24:46.187]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:46.187]                     NULL
[10:24:46.187]                   }
[10:24:46.187]                   options(future.plan = NULL)
[10:24:46.187]                   if (is.na(NA_character_)) 
[10:24:46.187]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:46.187]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:46.187]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:46.187]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:46.187]                     envir = parent.frame()) 
[10:24:46.187]                   {
[10:24:46.187]                     if (is.function(workers)) 
[10:24:46.187]                       workers <- workers()
[10:24:46.187]                     workers <- structure(as.integer(workers), 
[10:24:46.187]                       class = class(workers))
[10:24:46.187]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:46.187]                       workers >= 1)
[10:24:46.187]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:46.187]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:46.187]                     }
[10:24:46.187]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:46.187]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:46.187]                       envir = envir)
[10:24:46.187]                     if (!future$lazy) 
[10:24:46.187]                       future <- run(future)
[10:24:46.187]                     invisible(future)
[10:24:46.187]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:46.187]                 }
[10:24:46.187]             }
[10:24:46.187]         }
[10:24:46.187]     })
[10:24:46.187]     if (FALSE) {
[10:24:46.187]         base::sink(type = "output", split = FALSE)
[10:24:46.187]         if (NA) {
[10:24:46.187]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:46.187]         }
[10:24:46.187]         else {
[10:24:46.187]             ...future.result["stdout"] <- base::list(NULL)
[10:24:46.187]         }
[10:24:46.187]         base::close(...future.stdout)
[10:24:46.187]         ...future.stdout <- NULL
[10:24:46.187]     }
[10:24:46.187]     ...future.result$conditions <- ...future.conditions
[10:24:46.187]     ...future.result$finished <- base::Sys.time()
[10:24:46.187]     ...future.result
[10:24:46.187] }
[10:24:46.190] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[10:24:46.190] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[10:24:46.190] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[10:24:46.190] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:24:46.191] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:24:46.191] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[10:24:46.191] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[10:24:46.191] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:24:46.192] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:24:46.192] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:24:46.192] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:24:46.192] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[10:24:46.193] MultisessionFuture started
[10:24:46.193] - Launch lazy future ... done
[10:24:46.193] run() for ‘MultisessionFuture’ ... done
[10:24:46.193] Created future:
[10:24:46.193] MultisessionFuture:
[10:24:46.193] Label: ‘future_lapply-1’
[10:24:46.193] Expression:
[10:24:46.193] {
[10:24:46.193]     do.call(function(...) {
[10:24:46.193]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:46.193]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:46.193]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:46.193]             on.exit(options(oopts), add = TRUE)
[10:24:46.193]         }
[10:24:46.193]         {
[10:24:46.193]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:46.193]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:46.193]                 ...future.FUN(...future.X_jj, ...)
[10:24:46.193]             })
[10:24:46.193]         }
[10:24:46.193]     }, args = future.call.arguments)
[10:24:46.193] }
[10:24:46.193] Lazy evaluation: FALSE
[10:24:46.193] Asynchronous evaluation: TRUE
[10:24:46.193] Local evaluation: TRUE
[10:24:46.193] Environment: R_GlobalEnv
[10:24:46.193] Capture standard output: NA
[10:24:46.193] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:46.193] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:46.193] Packages: <none>
[10:24:46.193] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:46.193] Resolved: FALSE
[10:24:46.193] Value: <not collected>
[10:24:46.193] Conditions captured: <none>
[10:24:46.193] Early signaling: FALSE
[10:24:46.193] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:46.193] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:46.205] Chunk #1 of 2 ... DONE
[10:24:46.205] Chunk #2 of 2 ...
[10:24:46.205]  - Finding globals in 'X' for chunk #2 ...
[10:24:46.205] getGlobalsAndPackages() ...
[10:24:46.205] Searching for globals...
[10:24:46.205] 
[10:24:46.205] Searching for globals ... DONE
[10:24:46.206] - globals: [0] <none>
[10:24:46.206] getGlobalsAndPackages() ... DONE
[10:24:46.206]    + additional globals found: [n=0] 
[10:24:46.206]    + additional namespaces needed: [n=0] 
[10:24:46.206]  - Finding globals in 'X' for chunk #2 ... DONE
[10:24:46.206]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:46.206]  - seeds: <none>
[10:24:46.206]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:46.206] getGlobalsAndPackages() ...
[10:24:46.206] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:46.207] Resolving globals: FALSE
[10:24:46.207] Tweak future expression to call with '...' arguments ...
[10:24:46.207] {
[10:24:46.207]     do.call(function(...) {
[10:24:46.207]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:46.207]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:46.207]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:46.207]             on.exit(options(oopts), add = TRUE)
[10:24:46.207]         }
[10:24:46.207]         {
[10:24:46.207]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:46.207]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:46.207]                 ...future.FUN(...future.X_jj, ...)
[10:24:46.207]             })
[10:24:46.207]         }
[10:24:46.207]     }, args = future.call.arguments)
[10:24:46.207] }
[10:24:46.207] Tweak future expression to call with '...' arguments ... DONE
[10:24:46.207] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:46.207] 
[10:24:46.208] getGlobalsAndPackages() ... DONE
[10:24:46.208] run() for ‘Future’ ...
[10:24:46.208] - state: ‘created’
[10:24:46.208] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:46.221] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:46.222] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:46.222]   - Field: ‘node’
[10:24:46.222]   - Field: ‘label’
[10:24:46.222]   - Field: ‘local’
[10:24:46.222]   - Field: ‘owner’
[10:24:46.222]   - Field: ‘envir’
[10:24:46.222]   - Field: ‘workers’
[10:24:46.222]   - Field: ‘packages’
[10:24:46.222]   - Field: ‘gc’
[10:24:46.223]   - Field: ‘conditions’
[10:24:46.223]   - Field: ‘persistent’
[10:24:46.223]   - Field: ‘expr’
[10:24:46.223]   - Field: ‘uuid’
[10:24:46.223]   - Field: ‘seed’
[10:24:46.223]   - Field: ‘version’
[10:24:46.223]   - Field: ‘result’
[10:24:46.223]   - Field: ‘asynchronous’
[10:24:46.223]   - Field: ‘calls’
[10:24:46.223]   - Field: ‘globals’
[10:24:46.223]   - Field: ‘stdout’
[10:24:46.224]   - Field: ‘earlySignal’
[10:24:46.224]   - Field: ‘lazy’
[10:24:46.224]   - Field: ‘state’
[10:24:46.224] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:46.224] - Launch lazy future ...
[10:24:46.224] Packages needed by the future expression (n = 0): <none>
[10:24:46.224] Packages needed by future strategies (n = 0): <none>
[10:24:46.225] {
[10:24:46.225]     {
[10:24:46.225]         {
[10:24:46.225]             ...future.startTime <- base::Sys.time()
[10:24:46.225]             {
[10:24:46.225]                 {
[10:24:46.225]                   {
[10:24:46.225]                     {
[10:24:46.225]                       base::local({
[10:24:46.225]                         has_future <- base::requireNamespace("future", 
[10:24:46.225]                           quietly = TRUE)
[10:24:46.225]                         if (has_future) {
[10:24:46.225]                           ns <- base::getNamespace("future")
[10:24:46.225]                           version <- ns[[".package"]][["version"]]
[10:24:46.225]                           if (is.null(version)) 
[10:24:46.225]                             version <- utils::packageVersion("future")
[10:24:46.225]                         }
[10:24:46.225]                         else {
[10:24:46.225]                           version <- NULL
[10:24:46.225]                         }
[10:24:46.225]                         if (!has_future || version < "1.8.0") {
[10:24:46.225]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:46.225]                             "", base::R.version$version.string), 
[10:24:46.225]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:46.225]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:46.225]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:46.225]                               "release", "version")], collapse = " "), 
[10:24:46.225]                             hostname = base::Sys.info()[["nodename"]])
[10:24:46.225]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:46.225]                             info)
[10:24:46.225]                           info <- base::paste(info, collapse = "; ")
[10:24:46.225]                           if (!has_future) {
[10:24:46.225]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:46.225]                               info)
[10:24:46.225]                           }
[10:24:46.225]                           else {
[10:24:46.225]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:46.225]                               info, version)
[10:24:46.225]                           }
[10:24:46.225]                           base::stop(msg)
[10:24:46.225]                         }
[10:24:46.225]                       })
[10:24:46.225]                     }
[10:24:46.225]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:46.225]                     base::options(mc.cores = 1L)
[10:24:46.225]                   }
[10:24:46.225]                   options(future.plan = NULL)
[10:24:46.225]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:46.225]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:46.225]                 }
[10:24:46.225]                 ...future.workdir <- getwd()
[10:24:46.225]             }
[10:24:46.225]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:46.225]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:46.225]         }
[10:24:46.225]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:46.225]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:46.225]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:46.225]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:46.225]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:46.225]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:46.225]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:46.225]             base::names(...future.oldOptions))
[10:24:46.225]     }
[10:24:46.225]     if (TRUE) {
[10:24:46.225]     }
[10:24:46.225]     else {
[10:24:46.225]         if (NA) {
[10:24:46.225]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:46.225]                 open = "w")
[10:24:46.225]         }
[10:24:46.225]         else {
[10:24:46.225]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:46.225]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:46.225]         }
[10:24:46.225]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:46.225]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:46.225]             base::sink(type = "output", split = FALSE)
[10:24:46.225]             base::close(...future.stdout)
[10:24:46.225]         }, add = TRUE)
[10:24:46.225]     }
[10:24:46.225]     ...future.frame <- base::sys.nframe()
[10:24:46.225]     ...future.conditions <- base::list()
[10:24:46.225]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:46.225]     if (FALSE) {
[10:24:46.225]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:46.225]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:46.225]     }
[10:24:46.225]     ...future.result <- base::tryCatch({
[10:24:46.225]         base::withCallingHandlers({
[10:24:46.225]             ...future.value <- base::withVisible(base::local({
[10:24:46.225]                 ...future.makeSendCondition <- base::local({
[10:24:46.225]                   sendCondition <- NULL
[10:24:46.225]                   function(frame = 1L) {
[10:24:46.225]                     if (is.function(sendCondition)) 
[10:24:46.225]                       return(sendCondition)
[10:24:46.225]                     ns <- getNamespace("parallel")
[10:24:46.225]                     if (exists("sendData", mode = "function", 
[10:24:46.225]                       envir = ns)) {
[10:24:46.225]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:46.225]                         envir = ns)
[10:24:46.225]                       envir <- sys.frame(frame)
[10:24:46.225]                       master <- NULL
[10:24:46.225]                       while (!identical(envir, .GlobalEnv) && 
[10:24:46.225]                         !identical(envir, emptyenv())) {
[10:24:46.225]                         if (exists("master", mode = "list", envir = envir, 
[10:24:46.225]                           inherits = FALSE)) {
[10:24:46.225]                           master <- get("master", mode = "list", 
[10:24:46.225]                             envir = envir, inherits = FALSE)
[10:24:46.225]                           if (inherits(master, c("SOCKnode", 
[10:24:46.225]                             "SOCK0node"))) {
[10:24:46.225]                             sendCondition <<- function(cond) {
[10:24:46.225]                               data <- list(type = "VALUE", value = cond, 
[10:24:46.225]                                 success = TRUE)
[10:24:46.225]                               parallel_sendData(master, data)
[10:24:46.225]                             }
[10:24:46.225]                             return(sendCondition)
[10:24:46.225]                           }
[10:24:46.225]                         }
[10:24:46.225]                         frame <- frame + 1L
[10:24:46.225]                         envir <- sys.frame(frame)
[10:24:46.225]                       }
[10:24:46.225]                     }
[10:24:46.225]                     sendCondition <<- function(cond) NULL
[10:24:46.225]                   }
[10:24:46.225]                 })
[10:24:46.225]                 withCallingHandlers({
[10:24:46.225]                   {
[10:24:46.225]                     do.call(function(...) {
[10:24:46.225]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:46.225]                       if (!identical(...future.globals.maxSize.org, 
[10:24:46.225]                         ...future.globals.maxSize)) {
[10:24:46.225]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:46.225]                         on.exit(options(oopts), add = TRUE)
[10:24:46.225]                       }
[10:24:46.225]                       {
[10:24:46.225]                         lapply(seq_along(...future.elements_ii), 
[10:24:46.225]                           FUN = function(jj) {
[10:24:46.225]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:46.225]                             ...future.FUN(...future.X_jj, ...)
[10:24:46.225]                           })
[10:24:46.225]                       }
[10:24:46.225]                     }, args = future.call.arguments)
[10:24:46.225]                   }
[10:24:46.225]                 }, immediateCondition = function(cond) {
[10:24:46.225]                   sendCondition <- ...future.makeSendCondition()
[10:24:46.225]                   sendCondition(cond)
[10:24:46.225]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:46.225]                   {
[10:24:46.225]                     inherits <- base::inherits
[10:24:46.225]                     invokeRestart <- base::invokeRestart
[10:24:46.225]                     is.null <- base::is.null
[10:24:46.225]                     muffled <- FALSE
[10:24:46.225]                     if (inherits(cond, "message")) {
[10:24:46.225]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:46.225]                       if (muffled) 
[10:24:46.225]                         invokeRestart("muffleMessage")
[10:24:46.225]                     }
[10:24:46.225]                     else if (inherits(cond, "warning")) {
[10:24:46.225]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:46.225]                       if (muffled) 
[10:24:46.225]                         invokeRestart("muffleWarning")
[10:24:46.225]                     }
[10:24:46.225]                     else if (inherits(cond, "condition")) {
[10:24:46.225]                       if (!is.null(pattern)) {
[10:24:46.225]                         computeRestarts <- base::computeRestarts
[10:24:46.225]                         grepl <- base::grepl
[10:24:46.225]                         restarts <- computeRestarts(cond)
[10:24:46.225]                         for (restart in restarts) {
[10:24:46.225]                           name <- restart$name
[10:24:46.225]                           if (is.null(name)) 
[10:24:46.225]                             next
[10:24:46.225]                           if (!grepl(pattern, name)) 
[10:24:46.225]                             next
[10:24:46.225]                           invokeRestart(restart)
[10:24:46.225]                           muffled <- TRUE
[10:24:46.225]                           break
[10:24:46.225]                         }
[10:24:46.225]                       }
[10:24:46.225]                     }
[10:24:46.225]                     invisible(muffled)
[10:24:46.225]                   }
[10:24:46.225]                   muffleCondition(cond)
[10:24:46.225]                 })
[10:24:46.225]             }))
[10:24:46.225]             future::FutureResult(value = ...future.value$value, 
[10:24:46.225]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:46.225]                   ...future.rng), globalenv = if (FALSE) 
[10:24:46.225]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:46.225]                     ...future.globalenv.names))
[10:24:46.225]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:46.225]         }, condition = base::local({
[10:24:46.225]             c <- base::c
[10:24:46.225]             inherits <- base::inherits
[10:24:46.225]             invokeRestart <- base::invokeRestart
[10:24:46.225]             length <- base::length
[10:24:46.225]             list <- base::list
[10:24:46.225]             seq.int <- base::seq.int
[10:24:46.225]             signalCondition <- base::signalCondition
[10:24:46.225]             sys.calls <- base::sys.calls
[10:24:46.225]             `[[` <- base::`[[`
[10:24:46.225]             `+` <- base::`+`
[10:24:46.225]             `<<-` <- base::`<<-`
[10:24:46.225]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:46.225]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:46.225]                   3L)]
[10:24:46.225]             }
[10:24:46.225]             function(cond) {
[10:24:46.225]                 is_error <- inherits(cond, "error")
[10:24:46.225]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:46.225]                   NULL)
[10:24:46.225]                 if (is_error) {
[10:24:46.225]                   sessionInformation <- function() {
[10:24:46.225]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:46.225]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:46.225]                       search = base::search(), system = base::Sys.info())
[10:24:46.225]                   }
[10:24:46.225]                   ...future.conditions[[length(...future.conditions) + 
[10:24:46.225]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:46.225]                     cond$call), session = sessionInformation(), 
[10:24:46.225]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:46.225]                   signalCondition(cond)
[10:24:46.225]                 }
[10:24:46.225]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:46.225]                 "immediateCondition"))) {
[10:24:46.225]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:46.225]                   ...future.conditions[[length(...future.conditions) + 
[10:24:46.225]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:46.225]                   if (TRUE && !signal) {
[10:24:46.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:46.225]                     {
[10:24:46.225]                       inherits <- base::inherits
[10:24:46.225]                       invokeRestart <- base::invokeRestart
[10:24:46.225]                       is.null <- base::is.null
[10:24:46.225]                       muffled <- FALSE
[10:24:46.225]                       if (inherits(cond, "message")) {
[10:24:46.225]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:46.225]                         if (muffled) 
[10:24:46.225]                           invokeRestart("muffleMessage")
[10:24:46.225]                       }
[10:24:46.225]                       else if (inherits(cond, "warning")) {
[10:24:46.225]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:46.225]                         if (muffled) 
[10:24:46.225]                           invokeRestart("muffleWarning")
[10:24:46.225]                       }
[10:24:46.225]                       else if (inherits(cond, "condition")) {
[10:24:46.225]                         if (!is.null(pattern)) {
[10:24:46.225]                           computeRestarts <- base::computeRestarts
[10:24:46.225]                           grepl <- base::grepl
[10:24:46.225]                           restarts <- computeRestarts(cond)
[10:24:46.225]                           for (restart in restarts) {
[10:24:46.225]                             name <- restart$name
[10:24:46.225]                             if (is.null(name)) 
[10:24:46.225]                               next
[10:24:46.225]                             if (!grepl(pattern, name)) 
[10:24:46.225]                               next
[10:24:46.225]                             invokeRestart(restart)
[10:24:46.225]                             muffled <- TRUE
[10:24:46.225]                             break
[10:24:46.225]                           }
[10:24:46.225]                         }
[10:24:46.225]                       }
[10:24:46.225]                       invisible(muffled)
[10:24:46.225]                     }
[10:24:46.225]                     muffleCondition(cond, pattern = "^muffle")
[10:24:46.225]                   }
[10:24:46.225]                 }
[10:24:46.225]                 else {
[10:24:46.225]                   if (TRUE) {
[10:24:46.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:46.225]                     {
[10:24:46.225]                       inherits <- base::inherits
[10:24:46.225]                       invokeRestart <- base::invokeRestart
[10:24:46.225]                       is.null <- base::is.null
[10:24:46.225]                       muffled <- FALSE
[10:24:46.225]                       if (inherits(cond, "message")) {
[10:24:46.225]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:46.225]                         if (muffled) 
[10:24:46.225]                           invokeRestart("muffleMessage")
[10:24:46.225]                       }
[10:24:46.225]                       else if (inherits(cond, "warning")) {
[10:24:46.225]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:46.225]                         if (muffled) 
[10:24:46.225]                           invokeRestart("muffleWarning")
[10:24:46.225]                       }
[10:24:46.225]                       else if (inherits(cond, "condition")) {
[10:24:46.225]                         if (!is.null(pattern)) {
[10:24:46.225]                           computeRestarts <- base::computeRestarts
[10:24:46.225]                           grepl <- base::grepl
[10:24:46.225]                           restarts <- computeRestarts(cond)
[10:24:46.225]                           for (restart in restarts) {
[10:24:46.225]                             name <- restart$name
[10:24:46.225]                             if (is.null(name)) 
[10:24:46.225]                               next
[10:24:46.225]                             if (!grepl(pattern, name)) 
[10:24:46.225]                               next
[10:24:46.225]                             invokeRestart(restart)
[10:24:46.225]                             muffled <- TRUE
[10:24:46.225]                             break
[10:24:46.225]                           }
[10:24:46.225]                         }
[10:24:46.225]                       }
[10:24:46.225]                       invisible(muffled)
[10:24:46.225]                     }
[10:24:46.225]                     muffleCondition(cond, pattern = "^muffle")
[10:24:46.225]                   }
[10:24:46.225]                 }
[10:24:46.225]             }
[10:24:46.225]         }))
[10:24:46.225]     }, error = function(ex) {
[10:24:46.225]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:46.225]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:46.225]                 ...future.rng), started = ...future.startTime, 
[10:24:46.225]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:46.225]             version = "1.8"), class = "FutureResult")
[10:24:46.225]     }, finally = {
[10:24:46.225]         if (!identical(...future.workdir, getwd())) 
[10:24:46.225]             setwd(...future.workdir)
[10:24:46.225]         {
[10:24:46.225]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:46.225]                 ...future.oldOptions$nwarnings <- NULL
[10:24:46.225]             }
[10:24:46.225]             base::options(...future.oldOptions)
[10:24:46.225]             if (.Platform$OS.type == "windows") {
[10:24:46.225]                 old_names <- names(...future.oldEnvVars)
[10:24:46.225]                 envs <- base::Sys.getenv()
[10:24:46.225]                 names <- names(envs)
[10:24:46.225]                 common <- intersect(names, old_names)
[10:24:46.225]                 added <- setdiff(names, old_names)
[10:24:46.225]                 removed <- setdiff(old_names, names)
[10:24:46.225]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:46.225]                   envs[common]]
[10:24:46.225]                 NAMES <- toupper(changed)
[10:24:46.225]                 args <- list()
[10:24:46.225]                 for (kk in seq_along(NAMES)) {
[10:24:46.225]                   name <- changed[[kk]]
[10:24:46.225]                   NAME <- NAMES[[kk]]
[10:24:46.225]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:46.225]                     next
[10:24:46.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:46.225]                 }
[10:24:46.225]                 NAMES <- toupper(added)
[10:24:46.225]                 for (kk in seq_along(NAMES)) {
[10:24:46.225]                   name <- added[[kk]]
[10:24:46.225]                   NAME <- NAMES[[kk]]
[10:24:46.225]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:46.225]                     next
[10:24:46.225]                   args[[name]] <- ""
[10:24:46.225]                 }
[10:24:46.225]                 NAMES <- toupper(removed)
[10:24:46.225]                 for (kk in seq_along(NAMES)) {
[10:24:46.225]                   name <- removed[[kk]]
[10:24:46.225]                   NAME <- NAMES[[kk]]
[10:24:46.225]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:46.225]                     next
[10:24:46.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:46.225]                 }
[10:24:46.225]                 if (length(args) > 0) 
[10:24:46.225]                   base::do.call(base::Sys.setenv, args = args)
[10:24:46.225]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:46.225]             }
[10:24:46.225]             else {
[10:24:46.225]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:46.225]             }
[10:24:46.225]             {
[10:24:46.225]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:46.225]                   0L) {
[10:24:46.225]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:46.225]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:46.225]                   base::options(opts)
[10:24:46.225]                 }
[10:24:46.225]                 {
[10:24:46.225]                   {
[10:24:46.225]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:46.225]                     NULL
[10:24:46.225]                   }
[10:24:46.225]                   options(future.plan = NULL)
[10:24:46.225]                   if (is.na(NA_character_)) 
[10:24:46.225]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:46.225]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:46.225]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:46.225]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:46.225]                     envir = parent.frame()) 
[10:24:46.225]                   {
[10:24:46.225]                     if (is.function(workers)) 
[10:24:46.225]                       workers <- workers()
[10:24:46.225]                     workers <- structure(as.integer(workers), 
[10:24:46.225]                       class = class(workers))
[10:24:46.225]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:46.225]                       workers >= 1)
[10:24:46.225]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:46.225]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:46.225]                     }
[10:24:46.225]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:46.225]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:46.225]                       envir = envir)
[10:24:46.225]                     if (!future$lazy) 
[10:24:46.225]                       future <- run(future)
[10:24:46.225]                     invisible(future)
[10:24:46.225]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:46.225]                 }
[10:24:46.225]             }
[10:24:46.225]         }
[10:24:46.225]     })
[10:24:46.225]     if (FALSE) {
[10:24:46.225]         base::sink(type = "output", split = FALSE)
[10:24:46.225]         if (NA) {
[10:24:46.225]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:46.225]         }
[10:24:46.225]         else {
[10:24:46.225]             ...future.result["stdout"] <- base::list(NULL)
[10:24:46.225]         }
[10:24:46.225]         base::close(...future.stdout)
[10:24:46.225]         ...future.stdout <- NULL
[10:24:46.225]     }
[10:24:46.225]     ...future.result$conditions <- ...future.conditions
[10:24:46.225]     ...future.result$finished <- base::Sys.time()
[10:24:46.225]     ...future.result
[10:24:46.225] }
[10:24:46.227] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[10:24:46.228] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[10:24:46.228] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[10:24:46.228] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:24:46.229] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:24:46.229] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[10:24:46.229] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[10:24:46.229] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:24:46.229] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:24:46.230] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:24:46.230] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:24:46.230] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[10:24:46.230] MultisessionFuture started
[10:24:46.231] - Launch lazy future ... done
[10:24:46.231] run() for ‘MultisessionFuture’ ... done
[10:24:46.231] Created future:
[10:24:46.231] MultisessionFuture:
[10:24:46.231] Label: ‘future_lapply-2’
[10:24:46.231] Expression:
[10:24:46.231] {
[10:24:46.231]     do.call(function(...) {
[10:24:46.231]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:46.231]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:46.231]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:46.231]             on.exit(options(oopts), add = TRUE)
[10:24:46.231]         }
[10:24:46.231]         {
[10:24:46.231]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:24:46.231]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:24:46.231]                 ...future.FUN(...future.X_jj, ...)
[10:24:46.231]             })
[10:24:46.231]         }
[10:24:46.231]     }, args = future.call.arguments)
[10:24:46.231] }
[10:24:46.231] Lazy evaluation: FALSE
[10:24:46.231] Asynchronous evaluation: TRUE
[10:24:46.231] Local evaluation: TRUE
[10:24:46.231] Environment: R_GlobalEnv
[10:24:46.231] Capture standard output: NA
[10:24:46.231] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:46.231] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:46.231] Packages: <none>
[10:24:46.231] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:46.231] Resolved: FALSE
[10:24:46.231] Value: <not collected>
[10:24:46.231] Conditions captured: <none>
[10:24:46.231] Early signaling: FALSE
[10:24:46.231] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:46.231] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:46.242] Chunk #2 of 2 ... DONE
[10:24:46.242] Launching 2 futures (chunks) ... DONE
[10:24:46.243] Resolving 2 futures (chunks) ...
[10:24:46.243] resolve() on list ...
[10:24:46.243]  recursive: 0
[10:24:46.243]  length: 2
[10:24:46.243] 
[10:24:46.285] receiveMessageFromWorker() for ClusterFuture ...
[10:24:46.285] - Validating connection of MultisessionFuture
[10:24:46.285] - received message: FutureResult
[10:24:46.285] - Received FutureResult
[10:24:46.286] - Erased future from FutureRegistry
[10:24:46.286] result() for ClusterFuture ...
[10:24:46.286] - result already collected: FutureResult
[10:24:46.286] result() for ClusterFuture ... done
[10:24:46.286] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:46.286] Future #2
[10:24:46.286] result() for ClusterFuture ...
[10:24:46.286] - result already collected: FutureResult
[10:24:46.286] result() for ClusterFuture ... done
[10:24:46.286] result() for ClusterFuture ...
[10:24:46.287] - result already collected: FutureResult
[10:24:46.287] result() for ClusterFuture ... done
[10:24:46.287] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:24:46.287] - nx: 2
[10:24:46.287] - relay: TRUE
[10:24:46.287] - stdout: TRUE
[10:24:46.287] - signal: TRUE
[10:24:46.287] - resignal: FALSE
[10:24:46.287] - force: TRUE
[10:24:46.287] - relayed: [n=2] FALSE, FALSE
[10:24:46.287] - queued futures: [n=2] FALSE, FALSE
[10:24:46.287]  - until=1
[10:24:46.288]  - relaying element #1
[10:24:46.288] - relayed: [n=2] FALSE, FALSE
[10:24:46.288] - queued futures: [n=2] FALSE, TRUE
[10:24:46.288] signalConditionsASAP(NULL, pos=2) ... done
[10:24:46.288]  length: 1 (resolved future 2)
[10:24:46.739] receiveMessageFromWorker() for ClusterFuture ...
[10:24:46.739] - Validating connection of MultisessionFuture
[10:24:46.740] - received message: FutureResult
[10:24:46.740] - Received FutureResult
[10:24:46.740] - Erased future from FutureRegistry
[10:24:46.740] result() for ClusterFuture ...
[10:24:46.740] - result already collected: FutureResult
[10:24:46.740] result() for ClusterFuture ... done
[10:24:46.740] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:46.740] Future #1
[10:24:46.740] result() for ClusterFuture ...
[10:24:46.740] - result already collected: FutureResult
[10:24:46.741] result() for ClusterFuture ... done
[10:24:46.741] result() for ClusterFuture ...
[10:24:46.741] - result already collected: FutureResult
[10:24:46.741] result() for ClusterFuture ... done
[10:24:46.741] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:24:46.741] - nx: 2
[10:24:46.741] - relay: TRUE
[10:24:46.741] - stdout: TRUE
[10:24:46.741] - signal: TRUE
[10:24:46.741] - resignal: FALSE
[10:24:46.741] - force: TRUE
[10:24:46.742] - relayed: [n=2] FALSE, FALSE
[10:24:46.742] - queued futures: [n=2] FALSE, TRUE
[10:24:46.742]  - until=1
[10:24:46.742]  - relaying element #1
[10:24:46.742] result() for ClusterFuture ...
[10:24:46.742] - result already collected: FutureResult
[10:24:46.742] result() for ClusterFuture ... done
[10:24:46.742] result() for ClusterFuture ...
[10:24:46.742] - result already collected: FutureResult
[10:24:46.742] result() for ClusterFuture ... done
[10:24:46.742] result() for ClusterFuture ...
[10:24:46.743] - result already collected: FutureResult
[10:24:46.743] result() for ClusterFuture ... done
[10:24:46.743] result() for ClusterFuture ...
[10:24:46.743] - result already collected: FutureResult
[10:24:46.743] result() for ClusterFuture ... done
[10:24:46.743] - relayed: [n=2] TRUE, FALSE
[10:24:46.743] - queued futures: [n=2] TRUE, TRUE
[10:24:46.743] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:24:46.743]  length: 0 (resolved future 1)
[10:24:46.743] Relaying remaining futures
[10:24:46.743] signalConditionsASAP(NULL, pos=0) ...
[10:24:46.743] - nx: 2
[10:24:46.744] - relay: TRUE
[10:24:46.744] - stdout: TRUE
[10:24:46.744] - signal: TRUE
[10:24:46.744] - resignal: FALSE
[10:24:46.744] - force: TRUE
[10:24:46.744] - relayed: [n=2] TRUE, FALSE
[10:24:46.744] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:46.744]  - relaying element #2
[10:24:46.744] result() for ClusterFuture ...
[10:24:46.744] - result already collected: FutureResult
[10:24:46.744] result() for ClusterFuture ... done
[10:24:46.745] result() for ClusterFuture ...
[10:24:46.745] - result already collected: FutureResult
[10:24:46.745] result() for ClusterFuture ... done
[10:24:46.745] result() for ClusterFuture ...
[10:24:46.745] - result already collected: FutureResult
[10:24:46.745] result() for ClusterFuture ... done
[10:24:46.745] result() for ClusterFuture ...
[10:24:46.745] - result already collected: FutureResult
[10:24:46.745] result() for ClusterFuture ... done
[10:24:46.745] - relayed: [n=2] TRUE, TRUE
[10:24:46.745] - queued futures: [n=2] TRUE, TRUE
[10:24:46.746] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[10:24:46.746] resolve() on list ... DONE
[10:24:46.746] result() for ClusterFuture ...
[10:24:46.746] - result already collected: FutureResult
[10:24:46.746] result() for ClusterFuture ... done
[10:24:46.746] result() for ClusterFuture ...
[10:24:46.746] - result already collected: FutureResult
[10:24:46.746] result() for ClusterFuture ... done
[10:24:46.746] result() for ClusterFuture ...
[10:24:46.746] - result already collected: FutureResult
[10:24:46.746] result() for ClusterFuture ... done
[10:24:46.747] result() for ClusterFuture ...
[10:24:46.747] - result already collected: FutureResult
[10:24:46.747] result() for ClusterFuture ... done
[10:24:46.747]  - Number of value chunks collected: 2
[10:24:46.747] Resolving 2 futures (chunks) ... DONE
[10:24:46.747] Reducing values from 2 chunks ...
[10:24:46.747]  - Number of values collected after concatenation: 2
[10:24:46.747]  - Number of values expected: 2
[10:24:46.747] Reducing values from 2 chunks ... DONE
[10:24:46.747] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[10:24:46.748] future_mapply() ...
[10:24:46.751] Number of chunks: 2
[10:24:46.752] getGlobalsAndPackagesXApply() ...
[10:24:46.752]  - future.globals: TRUE
[10:24:46.752] getGlobalsAndPackages() ...
[10:24:46.752] Searching for globals...
[10:24:46.753] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:24:46.753] Searching for globals ... DONE
[10:24:46.754] Resolving globals: FALSE
[10:24:46.754] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[10:24:46.754] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[10:24:46.754] - globals: [1] ‘FUN’
[10:24:46.755] 
[10:24:46.755] getGlobalsAndPackages() ... DONE
[10:24:46.755]  - globals found/used: [n=1] ‘FUN’
[10:24:46.755]  - needed namespaces: [n=0] 
[10:24:46.755] Finding globals ... DONE
[10:24:46.755] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:24:46.755] List of 2
[10:24:46.755]  $ ...future.FUN:function (x, y)  
[10:24:46.755]  $ MoreArgs     : NULL
[10:24:46.755]  - attr(*, "where")=List of 2
[10:24:46.755]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:46.755]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:24:46.755]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:46.755]  - attr(*, "resolved")= logi FALSE
[10:24:46.755]  - attr(*, "total_size")= num NA
[10:24:46.758] Packages to be attached in all futures: [n=0] 
[10:24:46.758] getGlobalsAndPackagesXApply() ... DONE
[10:24:46.758] Number of futures (= number of chunks): 2
[10:24:46.758] Launching 2 futures (chunks) ...
[10:24:46.758] Chunk #1 of 2 ...
[10:24:46.758]  - Finding globals in '...' for chunk #1 ...
[10:24:46.758] getGlobalsAndPackages() ...
[10:24:46.759] Searching for globals...
[10:24:46.759] 
[10:24:46.759] Searching for globals ... DONE
[10:24:46.759] - globals: [0] <none>
[10:24:46.761] getGlobalsAndPackages() ... DONE
[10:24:46.761]    + additional globals found: [n=0] 
[10:24:46.761]    + additional namespaces needed: [n=0] 
[10:24:46.761]  - Finding globals in '...' for chunk #1 ... DONE
[10:24:46.761]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:46.761]  - seeds: <none>
[10:24:46.761]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:46.762] getGlobalsAndPackages() ...
[10:24:46.762] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:46.762] Resolving globals: FALSE
[10:24:46.762] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[10:24:46.763] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:24:46.763] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:46.763] 
[10:24:46.763] getGlobalsAndPackages() ... DONE
[10:24:46.763] run() for ‘Future’ ...
[10:24:46.763] - state: ‘created’
[10:24:46.764] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:46.778] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:46.778] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:46.778]   - Field: ‘node’
[10:24:46.778]   - Field: ‘label’
[10:24:46.778]   - Field: ‘local’
[10:24:46.778]   - Field: ‘owner’
[10:24:46.778]   - Field: ‘envir’
[10:24:46.778]   - Field: ‘workers’
[10:24:46.779]   - Field: ‘packages’
[10:24:46.779]   - Field: ‘gc’
[10:24:46.779]   - Field: ‘conditions’
[10:24:46.779]   - Field: ‘persistent’
[10:24:46.779]   - Field: ‘expr’
[10:24:46.779]   - Field: ‘uuid’
[10:24:46.779]   - Field: ‘seed’
[10:24:46.779]   - Field: ‘version’
[10:24:46.779]   - Field: ‘result’
[10:24:46.779]   - Field: ‘asynchronous’
[10:24:46.779]   - Field: ‘calls’
[10:24:46.780]   - Field: ‘globals’
[10:24:46.780]   - Field: ‘stdout’
[10:24:46.780]   - Field: ‘earlySignal’
[10:24:46.780]   - Field: ‘lazy’
[10:24:46.780]   - Field: ‘state’
[10:24:46.780] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:46.780] - Launch lazy future ...
[10:24:46.780] Packages needed by the future expression (n = 0): <none>
[10:24:46.780] Packages needed by future strategies (n = 0): <none>
[10:24:46.781] {
[10:24:46.781]     {
[10:24:46.781]         {
[10:24:46.781]             ...future.startTime <- base::Sys.time()
[10:24:46.781]             {
[10:24:46.781]                 {
[10:24:46.781]                   {
[10:24:46.781]                     {
[10:24:46.781]                       base::local({
[10:24:46.781]                         has_future <- base::requireNamespace("future", 
[10:24:46.781]                           quietly = TRUE)
[10:24:46.781]                         if (has_future) {
[10:24:46.781]                           ns <- base::getNamespace("future")
[10:24:46.781]                           version <- ns[[".package"]][["version"]]
[10:24:46.781]                           if (is.null(version)) 
[10:24:46.781]                             version <- utils::packageVersion("future")
[10:24:46.781]                         }
[10:24:46.781]                         else {
[10:24:46.781]                           version <- NULL
[10:24:46.781]                         }
[10:24:46.781]                         if (!has_future || version < "1.8.0") {
[10:24:46.781]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:46.781]                             "", base::R.version$version.string), 
[10:24:46.781]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:46.781]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:46.781]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:46.781]                               "release", "version")], collapse = " "), 
[10:24:46.781]                             hostname = base::Sys.info()[["nodename"]])
[10:24:46.781]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:46.781]                             info)
[10:24:46.781]                           info <- base::paste(info, collapse = "; ")
[10:24:46.781]                           if (!has_future) {
[10:24:46.781]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:46.781]                               info)
[10:24:46.781]                           }
[10:24:46.781]                           else {
[10:24:46.781]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:46.781]                               info, version)
[10:24:46.781]                           }
[10:24:46.781]                           base::stop(msg)
[10:24:46.781]                         }
[10:24:46.781]                       })
[10:24:46.781]                     }
[10:24:46.781]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:46.781]                     base::options(mc.cores = 1L)
[10:24:46.781]                   }
[10:24:46.781]                   options(future.plan = NULL)
[10:24:46.781]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:46.781]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:46.781]                 }
[10:24:46.781]                 ...future.workdir <- getwd()
[10:24:46.781]             }
[10:24:46.781]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:46.781]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:46.781]         }
[10:24:46.781]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:46.781]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:46.781]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:46.781]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:46.781]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:46.781]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:46.781]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:46.781]             base::names(...future.oldOptions))
[10:24:46.781]     }
[10:24:46.781]     if (FALSE) {
[10:24:46.781]     }
[10:24:46.781]     else {
[10:24:46.781]         if (FALSE) {
[10:24:46.781]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:46.781]                 open = "w")
[10:24:46.781]         }
[10:24:46.781]         else {
[10:24:46.781]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:46.781]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:46.781]         }
[10:24:46.781]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:46.781]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:46.781]             base::sink(type = "output", split = FALSE)
[10:24:46.781]             base::close(...future.stdout)
[10:24:46.781]         }, add = TRUE)
[10:24:46.781]     }
[10:24:46.781]     ...future.frame <- base::sys.nframe()
[10:24:46.781]     ...future.conditions <- base::list()
[10:24:46.781]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:46.781]     if (FALSE) {
[10:24:46.781]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:46.781]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:46.781]     }
[10:24:46.781]     ...future.result <- base::tryCatch({
[10:24:46.781]         base::withCallingHandlers({
[10:24:46.781]             ...future.value <- base::withVisible(base::local({
[10:24:46.781]                 ...future.makeSendCondition <- base::local({
[10:24:46.781]                   sendCondition <- NULL
[10:24:46.781]                   function(frame = 1L) {
[10:24:46.781]                     if (is.function(sendCondition)) 
[10:24:46.781]                       return(sendCondition)
[10:24:46.781]                     ns <- getNamespace("parallel")
[10:24:46.781]                     if (exists("sendData", mode = "function", 
[10:24:46.781]                       envir = ns)) {
[10:24:46.781]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:46.781]                         envir = ns)
[10:24:46.781]                       envir <- sys.frame(frame)
[10:24:46.781]                       master <- NULL
[10:24:46.781]                       while (!identical(envir, .GlobalEnv) && 
[10:24:46.781]                         !identical(envir, emptyenv())) {
[10:24:46.781]                         if (exists("master", mode = "list", envir = envir, 
[10:24:46.781]                           inherits = FALSE)) {
[10:24:46.781]                           master <- get("master", mode = "list", 
[10:24:46.781]                             envir = envir, inherits = FALSE)
[10:24:46.781]                           if (inherits(master, c("SOCKnode", 
[10:24:46.781]                             "SOCK0node"))) {
[10:24:46.781]                             sendCondition <<- function(cond) {
[10:24:46.781]                               data <- list(type = "VALUE", value = cond, 
[10:24:46.781]                                 success = TRUE)
[10:24:46.781]                               parallel_sendData(master, data)
[10:24:46.781]                             }
[10:24:46.781]                             return(sendCondition)
[10:24:46.781]                           }
[10:24:46.781]                         }
[10:24:46.781]                         frame <- frame + 1L
[10:24:46.781]                         envir <- sys.frame(frame)
[10:24:46.781]                       }
[10:24:46.781]                     }
[10:24:46.781]                     sendCondition <<- function(cond) NULL
[10:24:46.781]                   }
[10:24:46.781]                 })
[10:24:46.781]                 withCallingHandlers({
[10:24:46.781]                   {
[10:24:46.781]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:46.781]                     if (!identical(...future.globals.maxSize.org, 
[10:24:46.781]                       ...future.globals.maxSize)) {
[10:24:46.781]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:46.781]                       on.exit(options(oopts), add = TRUE)
[10:24:46.781]                     }
[10:24:46.781]                     {
[10:24:46.781]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:46.781]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:24:46.781]                         USE.NAMES = FALSE)
[10:24:46.781]                       do.call(mapply, args = args)
[10:24:46.781]                     }
[10:24:46.781]                   }
[10:24:46.781]                 }, immediateCondition = function(cond) {
[10:24:46.781]                   sendCondition <- ...future.makeSendCondition()
[10:24:46.781]                   sendCondition(cond)
[10:24:46.781]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:46.781]                   {
[10:24:46.781]                     inherits <- base::inherits
[10:24:46.781]                     invokeRestart <- base::invokeRestart
[10:24:46.781]                     is.null <- base::is.null
[10:24:46.781]                     muffled <- FALSE
[10:24:46.781]                     if (inherits(cond, "message")) {
[10:24:46.781]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:46.781]                       if (muffled) 
[10:24:46.781]                         invokeRestart("muffleMessage")
[10:24:46.781]                     }
[10:24:46.781]                     else if (inherits(cond, "warning")) {
[10:24:46.781]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:46.781]                       if (muffled) 
[10:24:46.781]                         invokeRestart("muffleWarning")
[10:24:46.781]                     }
[10:24:46.781]                     else if (inherits(cond, "condition")) {
[10:24:46.781]                       if (!is.null(pattern)) {
[10:24:46.781]                         computeRestarts <- base::computeRestarts
[10:24:46.781]                         grepl <- base::grepl
[10:24:46.781]                         restarts <- computeRestarts(cond)
[10:24:46.781]                         for (restart in restarts) {
[10:24:46.781]                           name <- restart$name
[10:24:46.781]                           if (is.null(name)) 
[10:24:46.781]                             next
[10:24:46.781]                           if (!grepl(pattern, name)) 
[10:24:46.781]                             next
[10:24:46.781]                           invokeRestart(restart)
[10:24:46.781]                           muffled <- TRUE
[10:24:46.781]                           break
[10:24:46.781]                         }
[10:24:46.781]                       }
[10:24:46.781]                     }
[10:24:46.781]                     invisible(muffled)
[10:24:46.781]                   }
[10:24:46.781]                   muffleCondition(cond)
[10:24:46.781]                 })
[10:24:46.781]             }))
[10:24:46.781]             future::FutureResult(value = ...future.value$value, 
[10:24:46.781]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:46.781]                   ...future.rng), globalenv = if (FALSE) 
[10:24:46.781]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:46.781]                     ...future.globalenv.names))
[10:24:46.781]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:46.781]         }, condition = base::local({
[10:24:46.781]             c <- base::c
[10:24:46.781]             inherits <- base::inherits
[10:24:46.781]             invokeRestart <- base::invokeRestart
[10:24:46.781]             length <- base::length
[10:24:46.781]             list <- base::list
[10:24:46.781]             seq.int <- base::seq.int
[10:24:46.781]             signalCondition <- base::signalCondition
[10:24:46.781]             sys.calls <- base::sys.calls
[10:24:46.781]             `[[` <- base::`[[`
[10:24:46.781]             `+` <- base::`+`
[10:24:46.781]             `<<-` <- base::`<<-`
[10:24:46.781]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:46.781]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:46.781]                   3L)]
[10:24:46.781]             }
[10:24:46.781]             function(cond) {
[10:24:46.781]                 is_error <- inherits(cond, "error")
[10:24:46.781]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:46.781]                   NULL)
[10:24:46.781]                 if (is_error) {
[10:24:46.781]                   sessionInformation <- function() {
[10:24:46.781]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:46.781]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:46.781]                       search = base::search(), system = base::Sys.info())
[10:24:46.781]                   }
[10:24:46.781]                   ...future.conditions[[length(...future.conditions) + 
[10:24:46.781]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:46.781]                     cond$call), session = sessionInformation(), 
[10:24:46.781]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:46.781]                   signalCondition(cond)
[10:24:46.781]                 }
[10:24:46.781]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:46.781]                 "immediateCondition"))) {
[10:24:46.781]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:46.781]                   ...future.conditions[[length(...future.conditions) + 
[10:24:46.781]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:46.781]                   if (TRUE && !signal) {
[10:24:46.781]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:46.781]                     {
[10:24:46.781]                       inherits <- base::inherits
[10:24:46.781]                       invokeRestart <- base::invokeRestart
[10:24:46.781]                       is.null <- base::is.null
[10:24:46.781]                       muffled <- FALSE
[10:24:46.781]                       if (inherits(cond, "message")) {
[10:24:46.781]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:46.781]                         if (muffled) 
[10:24:46.781]                           invokeRestart("muffleMessage")
[10:24:46.781]                       }
[10:24:46.781]                       else if (inherits(cond, "warning")) {
[10:24:46.781]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:46.781]                         if (muffled) 
[10:24:46.781]                           invokeRestart("muffleWarning")
[10:24:46.781]                       }
[10:24:46.781]                       else if (inherits(cond, "condition")) {
[10:24:46.781]                         if (!is.null(pattern)) {
[10:24:46.781]                           computeRestarts <- base::computeRestarts
[10:24:46.781]                           grepl <- base::grepl
[10:24:46.781]                           restarts <- computeRestarts(cond)
[10:24:46.781]                           for (restart in restarts) {
[10:24:46.781]                             name <- restart$name
[10:24:46.781]                             if (is.null(name)) 
[10:24:46.781]                               next
[10:24:46.781]                             if (!grepl(pattern, name)) 
[10:24:46.781]                               next
[10:24:46.781]                             invokeRestart(restart)
[10:24:46.781]                             muffled <- TRUE
[10:24:46.781]                             break
[10:24:46.781]                           }
[10:24:46.781]                         }
[10:24:46.781]                       }
[10:24:46.781]                       invisible(muffled)
[10:24:46.781]                     }
[10:24:46.781]                     muffleCondition(cond, pattern = "^muffle")
[10:24:46.781]                   }
[10:24:46.781]                 }
[10:24:46.781]                 else {
[10:24:46.781]                   if (TRUE) {
[10:24:46.781]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:46.781]                     {
[10:24:46.781]                       inherits <- base::inherits
[10:24:46.781]                       invokeRestart <- base::invokeRestart
[10:24:46.781]                       is.null <- base::is.null
[10:24:46.781]                       muffled <- FALSE
[10:24:46.781]                       if (inherits(cond, "message")) {
[10:24:46.781]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:46.781]                         if (muffled) 
[10:24:46.781]                           invokeRestart("muffleMessage")
[10:24:46.781]                       }
[10:24:46.781]                       else if (inherits(cond, "warning")) {
[10:24:46.781]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:46.781]                         if (muffled) 
[10:24:46.781]                           invokeRestart("muffleWarning")
[10:24:46.781]                       }
[10:24:46.781]                       else if (inherits(cond, "condition")) {
[10:24:46.781]                         if (!is.null(pattern)) {
[10:24:46.781]                           computeRestarts <- base::computeRestarts
[10:24:46.781]                           grepl <- base::grepl
[10:24:46.781]                           restarts <- computeRestarts(cond)
[10:24:46.781]                           for (restart in restarts) {
[10:24:46.781]                             name <- restart$name
[10:24:46.781]                             if (is.null(name)) 
[10:24:46.781]                               next
[10:24:46.781]                             if (!grepl(pattern, name)) 
[10:24:46.781]                               next
[10:24:46.781]                             invokeRestart(restart)
[10:24:46.781]                             muffled <- TRUE
[10:24:46.781]                             break
[10:24:46.781]                           }
[10:24:46.781]                         }
[10:24:46.781]                       }
[10:24:46.781]                       invisible(muffled)
[10:24:46.781]                     }
[10:24:46.781]                     muffleCondition(cond, pattern = "^muffle")
[10:24:46.781]                   }
[10:24:46.781]                 }
[10:24:46.781]             }
[10:24:46.781]         }))
[10:24:46.781]     }, error = function(ex) {
[10:24:46.781]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:46.781]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:46.781]                 ...future.rng), started = ...future.startTime, 
[10:24:46.781]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:46.781]             version = "1.8"), class = "FutureResult")
[10:24:46.781]     }, finally = {
[10:24:46.781]         if (!identical(...future.workdir, getwd())) 
[10:24:46.781]             setwd(...future.workdir)
[10:24:46.781]         {
[10:24:46.781]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:46.781]                 ...future.oldOptions$nwarnings <- NULL
[10:24:46.781]             }
[10:24:46.781]             base::options(...future.oldOptions)
[10:24:46.781]             if (.Platform$OS.type == "windows") {
[10:24:46.781]                 old_names <- names(...future.oldEnvVars)
[10:24:46.781]                 envs <- base::Sys.getenv()
[10:24:46.781]                 names <- names(envs)
[10:24:46.781]                 common <- intersect(names, old_names)
[10:24:46.781]                 added <- setdiff(names, old_names)
[10:24:46.781]                 removed <- setdiff(old_names, names)
[10:24:46.781]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:46.781]                   envs[common]]
[10:24:46.781]                 NAMES <- toupper(changed)
[10:24:46.781]                 args <- list()
[10:24:46.781]                 for (kk in seq_along(NAMES)) {
[10:24:46.781]                   name <- changed[[kk]]
[10:24:46.781]                   NAME <- NAMES[[kk]]
[10:24:46.781]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:46.781]                     next
[10:24:46.781]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:46.781]                 }
[10:24:46.781]                 NAMES <- toupper(added)
[10:24:46.781]                 for (kk in seq_along(NAMES)) {
[10:24:46.781]                   name <- added[[kk]]
[10:24:46.781]                   NAME <- NAMES[[kk]]
[10:24:46.781]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:46.781]                     next
[10:24:46.781]                   args[[name]] <- ""
[10:24:46.781]                 }
[10:24:46.781]                 NAMES <- toupper(removed)
[10:24:46.781]                 for (kk in seq_along(NAMES)) {
[10:24:46.781]                   name <- removed[[kk]]
[10:24:46.781]                   NAME <- NAMES[[kk]]
[10:24:46.781]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:46.781]                     next
[10:24:46.781]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:46.781]                 }
[10:24:46.781]                 if (length(args) > 0) 
[10:24:46.781]                   base::do.call(base::Sys.setenv, args = args)
[10:24:46.781]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:46.781]             }
[10:24:46.781]             else {
[10:24:46.781]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:46.781]             }
[10:24:46.781]             {
[10:24:46.781]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:46.781]                   0L) {
[10:24:46.781]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:46.781]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:46.781]                   base::options(opts)
[10:24:46.781]                 }
[10:24:46.781]                 {
[10:24:46.781]                   {
[10:24:46.781]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:46.781]                     NULL
[10:24:46.781]                   }
[10:24:46.781]                   options(future.plan = NULL)
[10:24:46.781]                   if (is.na(NA_character_)) 
[10:24:46.781]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:46.781]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:46.781]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:46.781]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:46.781]                     envir = parent.frame()) 
[10:24:46.781]                   {
[10:24:46.781]                     if (is.function(workers)) 
[10:24:46.781]                       workers <- workers()
[10:24:46.781]                     workers <- structure(as.integer(workers), 
[10:24:46.781]                       class = class(workers))
[10:24:46.781]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:46.781]                       workers >= 1)
[10:24:46.781]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:46.781]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:46.781]                     }
[10:24:46.781]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:46.781]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:46.781]                       envir = envir)
[10:24:46.781]                     if (!future$lazy) 
[10:24:46.781]                       future <- run(future)
[10:24:46.781]                     invisible(future)
[10:24:46.781]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:46.781]                 }
[10:24:46.781]             }
[10:24:46.781]         }
[10:24:46.781]     })
[10:24:46.781]     if (TRUE) {
[10:24:46.781]         base::sink(type = "output", split = FALSE)
[10:24:46.781]         if (FALSE) {
[10:24:46.781]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:46.781]         }
[10:24:46.781]         else {
[10:24:46.781]             ...future.result["stdout"] <- base::list(NULL)
[10:24:46.781]         }
[10:24:46.781]         base::close(...future.stdout)
[10:24:46.781]         ...future.stdout <- NULL
[10:24:46.781]     }
[10:24:46.781]     ...future.result$conditions <- ...future.conditions
[10:24:46.781]     ...future.result$finished <- base::Sys.time()
[10:24:46.781]     ...future.result
[10:24:46.781] }
[10:24:46.784] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[10:24:46.784] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[10:24:46.784] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[10:24:46.784] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[10:24:46.784] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[10:24:46.785] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[10:24:46.785] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[10:24:46.785] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:24:46.785] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:24:46.785] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:24:46.786] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:24:46.786] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[10:24:46.786] MultisessionFuture started
[10:24:46.786] - Launch lazy future ... done
[10:24:46.787] run() for ‘MultisessionFuture’ ... done
[10:24:46.787] Created future:
[10:24:46.787] MultisessionFuture:
[10:24:46.787] Label: ‘future_mapply-1’
[10:24:46.787] Expression:
[10:24:46.787] {
[10:24:46.787]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:46.787]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:46.787]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:46.787]         on.exit(options(oopts), add = TRUE)
[10:24:46.787]     }
[10:24:46.787]     {
[10:24:46.787]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:46.787]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:24:46.787]         do.call(mapply, args = args)
[10:24:46.787]     }
[10:24:46.787] }
[10:24:46.787] Lazy evaluation: FALSE
[10:24:46.787] Asynchronous evaluation: TRUE
[10:24:46.787] Local evaluation: TRUE
[10:24:46.787] Environment: R_GlobalEnv
[10:24:46.787] Capture standard output: FALSE
[10:24:46.787] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:46.787] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:46.787] Packages: <none>
[10:24:46.787] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:46.787] Resolved: FALSE
[10:24:46.787] Value: <not collected>
[10:24:46.787] Conditions captured: <none>
[10:24:46.787] Early signaling: FALSE
[10:24:46.787] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:46.787] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:46.798] Chunk #1 of 2 ... DONE
[10:24:46.798] Chunk #2 of 2 ...
[10:24:46.798]  - Finding globals in '...' for chunk #2 ...
[10:24:46.798] getGlobalsAndPackages() ...
[10:24:46.799] Searching for globals...
[10:24:46.799] 
[10:24:46.799] Searching for globals ... DONE
[10:24:46.799] - globals: [0] <none>
[10:24:46.799] getGlobalsAndPackages() ... DONE
[10:24:46.799]    + additional globals found: [n=0] 
[10:24:46.799]    + additional namespaces needed: [n=0] 
[10:24:46.799]  - Finding globals in '...' for chunk #2 ... DONE
[10:24:46.799]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:46.800]  - seeds: <none>
[10:24:46.800]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:46.800] getGlobalsAndPackages() ...
[10:24:46.800] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:46.800] Resolving globals: FALSE
[10:24:46.800] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[10:24:46.801] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:24:46.801] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:46.801] 
[10:24:46.801] getGlobalsAndPackages() ... DONE
[10:24:46.801] run() for ‘Future’ ...
[10:24:46.802] - state: ‘created’
[10:24:46.802] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:46.816] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:46.816] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:46.816]   - Field: ‘node’
[10:24:46.816]   - Field: ‘label’
[10:24:46.816]   - Field: ‘local’
[10:24:46.816]   - Field: ‘owner’
[10:24:46.816]   - Field: ‘envir’
[10:24:46.816]   - Field: ‘workers’
[10:24:46.817]   - Field: ‘packages’
[10:24:46.817]   - Field: ‘gc’
[10:24:46.817]   - Field: ‘conditions’
[10:24:46.817]   - Field: ‘persistent’
[10:24:46.817]   - Field: ‘expr’
[10:24:46.817]   - Field: ‘uuid’
[10:24:46.817]   - Field: ‘seed’
[10:24:46.817]   - Field: ‘version’
[10:24:46.817]   - Field: ‘result’
[10:24:46.817]   - Field: ‘asynchronous’
[10:24:46.818]   - Field: ‘calls’
[10:24:46.818]   - Field: ‘globals’
[10:24:46.818]   - Field: ‘stdout’
[10:24:46.818]   - Field: ‘earlySignal’
[10:24:46.818]   - Field: ‘lazy’
[10:24:46.818]   - Field: ‘state’
[10:24:46.818] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:46.818] - Launch lazy future ...
[10:24:46.818] Packages needed by the future expression (n = 0): <none>
[10:24:46.819] Packages needed by future strategies (n = 0): <none>
[10:24:46.819] {
[10:24:46.819]     {
[10:24:46.819]         {
[10:24:46.819]             ...future.startTime <- base::Sys.time()
[10:24:46.819]             {
[10:24:46.819]                 {
[10:24:46.819]                   {
[10:24:46.819]                     {
[10:24:46.819]                       base::local({
[10:24:46.819]                         has_future <- base::requireNamespace("future", 
[10:24:46.819]                           quietly = TRUE)
[10:24:46.819]                         if (has_future) {
[10:24:46.819]                           ns <- base::getNamespace("future")
[10:24:46.819]                           version <- ns[[".package"]][["version"]]
[10:24:46.819]                           if (is.null(version)) 
[10:24:46.819]                             version <- utils::packageVersion("future")
[10:24:46.819]                         }
[10:24:46.819]                         else {
[10:24:46.819]                           version <- NULL
[10:24:46.819]                         }
[10:24:46.819]                         if (!has_future || version < "1.8.0") {
[10:24:46.819]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:46.819]                             "", base::R.version$version.string), 
[10:24:46.819]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:46.819]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:46.819]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:46.819]                               "release", "version")], collapse = " "), 
[10:24:46.819]                             hostname = base::Sys.info()[["nodename"]])
[10:24:46.819]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:46.819]                             info)
[10:24:46.819]                           info <- base::paste(info, collapse = "; ")
[10:24:46.819]                           if (!has_future) {
[10:24:46.819]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:46.819]                               info)
[10:24:46.819]                           }
[10:24:46.819]                           else {
[10:24:46.819]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:46.819]                               info, version)
[10:24:46.819]                           }
[10:24:46.819]                           base::stop(msg)
[10:24:46.819]                         }
[10:24:46.819]                       })
[10:24:46.819]                     }
[10:24:46.819]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:46.819]                     base::options(mc.cores = 1L)
[10:24:46.819]                   }
[10:24:46.819]                   options(future.plan = NULL)
[10:24:46.819]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:46.819]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:46.819]                 }
[10:24:46.819]                 ...future.workdir <- getwd()
[10:24:46.819]             }
[10:24:46.819]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:46.819]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:46.819]         }
[10:24:46.819]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:46.819]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:46.819]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:46.819]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:46.819]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:46.819]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:46.819]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:46.819]             base::names(...future.oldOptions))
[10:24:46.819]     }
[10:24:46.819]     if (FALSE) {
[10:24:46.819]     }
[10:24:46.819]     else {
[10:24:46.819]         if (FALSE) {
[10:24:46.819]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:46.819]                 open = "w")
[10:24:46.819]         }
[10:24:46.819]         else {
[10:24:46.819]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:46.819]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:46.819]         }
[10:24:46.819]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:46.819]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:46.819]             base::sink(type = "output", split = FALSE)
[10:24:46.819]             base::close(...future.stdout)
[10:24:46.819]         }, add = TRUE)
[10:24:46.819]     }
[10:24:46.819]     ...future.frame <- base::sys.nframe()
[10:24:46.819]     ...future.conditions <- base::list()
[10:24:46.819]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:46.819]     if (FALSE) {
[10:24:46.819]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:46.819]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:46.819]     }
[10:24:46.819]     ...future.result <- base::tryCatch({
[10:24:46.819]         base::withCallingHandlers({
[10:24:46.819]             ...future.value <- base::withVisible(base::local({
[10:24:46.819]                 ...future.makeSendCondition <- base::local({
[10:24:46.819]                   sendCondition <- NULL
[10:24:46.819]                   function(frame = 1L) {
[10:24:46.819]                     if (is.function(sendCondition)) 
[10:24:46.819]                       return(sendCondition)
[10:24:46.819]                     ns <- getNamespace("parallel")
[10:24:46.819]                     if (exists("sendData", mode = "function", 
[10:24:46.819]                       envir = ns)) {
[10:24:46.819]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:46.819]                         envir = ns)
[10:24:46.819]                       envir <- sys.frame(frame)
[10:24:46.819]                       master <- NULL
[10:24:46.819]                       while (!identical(envir, .GlobalEnv) && 
[10:24:46.819]                         !identical(envir, emptyenv())) {
[10:24:46.819]                         if (exists("master", mode = "list", envir = envir, 
[10:24:46.819]                           inherits = FALSE)) {
[10:24:46.819]                           master <- get("master", mode = "list", 
[10:24:46.819]                             envir = envir, inherits = FALSE)
[10:24:46.819]                           if (inherits(master, c("SOCKnode", 
[10:24:46.819]                             "SOCK0node"))) {
[10:24:46.819]                             sendCondition <<- function(cond) {
[10:24:46.819]                               data <- list(type = "VALUE", value = cond, 
[10:24:46.819]                                 success = TRUE)
[10:24:46.819]                               parallel_sendData(master, data)
[10:24:46.819]                             }
[10:24:46.819]                             return(sendCondition)
[10:24:46.819]                           }
[10:24:46.819]                         }
[10:24:46.819]                         frame <- frame + 1L
[10:24:46.819]                         envir <- sys.frame(frame)
[10:24:46.819]                       }
[10:24:46.819]                     }
[10:24:46.819]                     sendCondition <<- function(cond) NULL
[10:24:46.819]                   }
[10:24:46.819]                 })
[10:24:46.819]                 withCallingHandlers({
[10:24:46.819]                   {
[10:24:46.819]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:46.819]                     if (!identical(...future.globals.maxSize.org, 
[10:24:46.819]                       ...future.globals.maxSize)) {
[10:24:46.819]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:46.819]                       on.exit(options(oopts), add = TRUE)
[10:24:46.819]                     }
[10:24:46.819]                     {
[10:24:46.819]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:46.819]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:24:46.819]                         USE.NAMES = FALSE)
[10:24:46.819]                       do.call(mapply, args = args)
[10:24:46.819]                     }
[10:24:46.819]                   }
[10:24:46.819]                 }, immediateCondition = function(cond) {
[10:24:46.819]                   sendCondition <- ...future.makeSendCondition()
[10:24:46.819]                   sendCondition(cond)
[10:24:46.819]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:46.819]                   {
[10:24:46.819]                     inherits <- base::inherits
[10:24:46.819]                     invokeRestart <- base::invokeRestart
[10:24:46.819]                     is.null <- base::is.null
[10:24:46.819]                     muffled <- FALSE
[10:24:46.819]                     if (inherits(cond, "message")) {
[10:24:46.819]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:46.819]                       if (muffled) 
[10:24:46.819]                         invokeRestart("muffleMessage")
[10:24:46.819]                     }
[10:24:46.819]                     else if (inherits(cond, "warning")) {
[10:24:46.819]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:46.819]                       if (muffled) 
[10:24:46.819]                         invokeRestart("muffleWarning")
[10:24:46.819]                     }
[10:24:46.819]                     else if (inherits(cond, "condition")) {
[10:24:46.819]                       if (!is.null(pattern)) {
[10:24:46.819]                         computeRestarts <- base::computeRestarts
[10:24:46.819]                         grepl <- base::grepl
[10:24:46.819]                         restarts <- computeRestarts(cond)
[10:24:46.819]                         for (restart in restarts) {
[10:24:46.819]                           name <- restart$name
[10:24:46.819]                           if (is.null(name)) 
[10:24:46.819]                             next
[10:24:46.819]                           if (!grepl(pattern, name)) 
[10:24:46.819]                             next
[10:24:46.819]                           invokeRestart(restart)
[10:24:46.819]                           muffled <- TRUE
[10:24:46.819]                           break
[10:24:46.819]                         }
[10:24:46.819]                       }
[10:24:46.819]                     }
[10:24:46.819]                     invisible(muffled)
[10:24:46.819]                   }
[10:24:46.819]                   muffleCondition(cond)
[10:24:46.819]                 })
[10:24:46.819]             }))
[10:24:46.819]             future::FutureResult(value = ...future.value$value, 
[10:24:46.819]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:46.819]                   ...future.rng), globalenv = if (FALSE) 
[10:24:46.819]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:46.819]                     ...future.globalenv.names))
[10:24:46.819]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:46.819]         }, condition = base::local({
[10:24:46.819]             c <- base::c
[10:24:46.819]             inherits <- base::inherits
[10:24:46.819]             invokeRestart <- base::invokeRestart
[10:24:46.819]             length <- base::length
[10:24:46.819]             list <- base::list
[10:24:46.819]             seq.int <- base::seq.int
[10:24:46.819]             signalCondition <- base::signalCondition
[10:24:46.819]             sys.calls <- base::sys.calls
[10:24:46.819]             `[[` <- base::`[[`
[10:24:46.819]             `+` <- base::`+`
[10:24:46.819]             `<<-` <- base::`<<-`
[10:24:46.819]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:46.819]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:46.819]                   3L)]
[10:24:46.819]             }
[10:24:46.819]             function(cond) {
[10:24:46.819]                 is_error <- inherits(cond, "error")
[10:24:46.819]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:46.819]                   NULL)
[10:24:46.819]                 if (is_error) {
[10:24:46.819]                   sessionInformation <- function() {
[10:24:46.819]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:46.819]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:46.819]                       search = base::search(), system = base::Sys.info())
[10:24:46.819]                   }
[10:24:46.819]                   ...future.conditions[[length(...future.conditions) + 
[10:24:46.819]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:46.819]                     cond$call), session = sessionInformation(), 
[10:24:46.819]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:46.819]                   signalCondition(cond)
[10:24:46.819]                 }
[10:24:46.819]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:46.819]                 "immediateCondition"))) {
[10:24:46.819]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:46.819]                   ...future.conditions[[length(...future.conditions) + 
[10:24:46.819]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:46.819]                   if (TRUE && !signal) {
[10:24:46.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:46.819]                     {
[10:24:46.819]                       inherits <- base::inherits
[10:24:46.819]                       invokeRestart <- base::invokeRestart
[10:24:46.819]                       is.null <- base::is.null
[10:24:46.819]                       muffled <- FALSE
[10:24:46.819]                       if (inherits(cond, "message")) {
[10:24:46.819]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:46.819]                         if (muffled) 
[10:24:46.819]                           invokeRestart("muffleMessage")
[10:24:46.819]                       }
[10:24:46.819]                       else if (inherits(cond, "warning")) {
[10:24:46.819]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:46.819]                         if (muffled) 
[10:24:46.819]                           invokeRestart("muffleWarning")
[10:24:46.819]                       }
[10:24:46.819]                       else if (inherits(cond, "condition")) {
[10:24:46.819]                         if (!is.null(pattern)) {
[10:24:46.819]                           computeRestarts <- base::computeRestarts
[10:24:46.819]                           grepl <- base::grepl
[10:24:46.819]                           restarts <- computeRestarts(cond)
[10:24:46.819]                           for (restart in restarts) {
[10:24:46.819]                             name <- restart$name
[10:24:46.819]                             if (is.null(name)) 
[10:24:46.819]                               next
[10:24:46.819]                             if (!grepl(pattern, name)) 
[10:24:46.819]                               next
[10:24:46.819]                             invokeRestart(restart)
[10:24:46.819]                             muffled <- TRUE
[10:24:46.819]                             break
[10:24:46.819]                           }
[10:24:46.819]                         }
[10:24:46.819]                       }
[10:24:46.819]                       invisible(muffled)
[10:24:46.819]                     }
[10:24:46.819]                     muffleCondition(cond, pattern = "^muffle")
[10:24:46.819]                   }
[10:24:46.819]                 }
[10:24:46.819]                 else {
[10:24:46.819]                   if (TRUE) {
[10:24:46.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:46.819]                     {
[10:24:46.819]                       inherits <- base::inherits
[10:24:46.819]                       invokeRestart <- base::invokeRestart
[10:24:46.819]                       is.null <- base::is.null
[10:24:46.819]                       muffled <- FALSE
[10:24:46.819]                       if (inherits(cond, "message")) {
[10:24:46.819]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:46.819]                         if (muffled) 
[10:24:46.819]                           invokeRestart("muffleMessage")
[10:24:46.819]                       }
[10:24:46.819]                       else if (inherits(cond, "warning")) {
[10:24:46.819]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:46.819]                         if (muffled) 
[10:24:46.819]                           invokeRestart("muffleWarning")
[10:24:46.819]                       }
[10:24:46.819]                       else if (inherits(cond, "condition")) {
[10:24:46.819]                         if (!is.null(pattern)) {
[10:24:46.819]                           computeRestarts <- base::computeRestarts
[10:24:46.819]                           grepl <- base::grepl
[10:24:46.819]                           restarts <- computeRestarts(cond)
[10:24:46.819]                           for (restart in restarts) {
[10:24:46.819]                             name <- restart$name
[10:24:46.819]                             if (is.null(name)) 
[10:24:46.819]                               next
[10:24:46.819]                             if (!grepl(pattern, name)) 
[10:24:46.819]                               next
[10:24:46.819]                             invokeRestart(restart)
[10:24:46.819]                             muffled <- TRUE
[10:24:46.819]                             break
[10:24:46.819]                           }
[10:24:46.819]                         }
[10:24:46.819]                       }
[10:24:46.819]                       invisible(muffled)
[10:24:46.819]                     }
[10:24:46.819]                     muffleCondition(cond, pattern = "^muffle")
[10:24:46.819]                   }
[10:24:46.819]                 }
[10:24:46.819]             }
[10:24:46.819]         }))
[10:24:46.819]     }, error = function(ex) {
[10:24:46.819]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:46.819]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:46.819]                 ...future.rng), started = ...future.startTime, 
[10:24:46.819]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:46.819]             version = "1.8"), class = "FutureResult")
[10:24:46.819]     }, finally = {
[10:24:46.819]         if (!identical(...future.workdir, getwd())) 
[10:24:46.819]             setwd(...future.workdir)
[10:24:46.819]         {
[10:24:46.819]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:46.819]                 ...future.oldOptions$nwarnings <- NULL
[10:24:46.819]             }
[10:24:46.819]             base::options(...future.oldOptions)
[10:24:46.819]             if (.Platform$OS.type == "windows") {
[10:24:46.819]                 old_names <- names(...future.oldEnvVars)
[10:24:46.819]                 envs <- base::Sys.getenv()
[10:24:46.819]                 names <- names(envs)
[10:24:46.819]                 common <- intersect(names, old_names)
[10:24:46.819]                 added <- setdiff(names, old_names)
[10:24:46.819]                 removed <- setdiff(old_names, names)
[10:24:46.819]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:46.819]                   envs[common]]
[10:24:46.819]                 NAMES <- toupper(changed)
[10:24:46.819]                 args <- list()
[10:24:46.819]                 for (kk in seq_along(NAMES)) {
[10:24:46.819]                   name <- changed[[kk]]
[10:24:46.819]                   NAME <- NAMES[[kk]]
[10:24:46.819]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:46.819]                     next
[10:24:46.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:46.819]                 }
[10:24:46.819]                 NAMES <- toupper(added)
[10:24:46.819]                 for (kk in seq_along(NAMES)) {
[10:24:46.819]                   name <- added[[kk]]
[10:24:46.819]                   NAME <- NAMES[[kk]]
[10:24:46.819]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:46.819]                     next
[10:24:46.819]                   args[[name]] <- ""
[10:24:46.819]                 }
[10:24:46.819]                 NAMES <- toupper(removed)
[10:24:46.819]                 for (kk in seq_along(NAMES)) {
[10:24:46.819]                   name <- removed[[kk]]
[10:24:46.819]                   NAME <- NAMES[[kk]]
[10:24:46.819]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:46.819]                     next
[10:24:46.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:46.819]                 }
[10:24:46.819]                 if (length(args) > 0) 
[10:24:46.819]                   base::do.call(base::Sys.setenv, args = args)
[10:24:46.819]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:46.819]             }
[10:24:46.819]             else {
[10:24:46.819]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:46.819]             }
[10:24:46.819]             {
[10:24:46.819]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:46.819]                   0L) {
[10:24:46.819]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:46.819]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:46.819]                   base::options(opts)
[10:24:46.819]                 }
[10:24:46.819]                 {
[10:24:46.819]                   {
[10:24:46.819]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:46.819]                     NULL
[10:24:46.819]                   }
[10:24:46.819]                   options(future.plan = NULL)
[10:24:46.819]                   if (is.na(NA_character_)) 
[10:24:46.819]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:46.819]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:46.819]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:46.819]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:46.819]                     envir = parent.frame()) 
[10:24:46.819]                   {
[10:24:46.819]                     if (is.function(workers)) 
[10:24:46.819]                       workers <- workers()
[10:24:46.819]                     workers <- structure(as.integer(workers), 
[10:24:46.819]                       class = class(workers))
[10:24:46.819]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:46.819]                       workers >= 1)
[10:24:46.819]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:46.819]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:46.819]                     }
[10:24:46.819]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:46.819]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:46.819]                       envir = envir)
[10:24:46.819]                     if (!future$lazy) 
[10:24:46.819]                       future <- run(future)
[10:24:46.819]                     invisible(future)
[10:24:46.819]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:46.819]                 }
[10:24:46.819]             }
[10:24:46.819]         }
[10:24:46.819]     })
[10:24:46.819]     if (TRUE) {
[10:24:46.819]         base::sink(type = "output", split = FALSE)
[10:24:46.819]         if (FALSE) {
[10:24:46.819]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:46.819]         }
[10:24:46.819]         else {
[10:24:46.819]             ...future.result["stdout"] <- base::list(NULL)
[10:24:46.819]         }
[10:24:46.819]         base::close(...future.stdout)
[10:24:46.819]         ...future.stdout <- NULL
[10:24:46.819]     }
[10:24:46.819]     ...future.result$conditions <- ...future.conditions
[10:24:46.819]     ...future.result$finished <- base::Sys.time()
[10:24:46.819]     ...future.result
[10:24:46.819] }
[10:24:46.822] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[10:24:46.822] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[10:24:46.822] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[10:24:46.823] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[10:24:46.823] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[10:24:46.823] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[10:24:46.823] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[10:24:46.824] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:24:46.824] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:24:46.824] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:24:46.825] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:24:46.825] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[10:24:46.825] MultisessionFuture started
[10:24:46.825] - Launch lazy future ... done
[10:24:46.826] run() for ‘MultisessionFuture’ ... done
[10:24:46.826] Created future:
[10:24:46.826] MultisessionFuture:
[10:24:46.826] Label: ‘future_mapply-2’
[10:24:46.826] Expression:
[10:24:46.826] {
[10:24:46.826]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:46.826]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:46.826]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:46.826]         on.exit(options(oopts), add = TRUE)
[10:24:46.826]     }
[10:24:46.826]     {
[10:24:46.826]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:46.826]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:24:46.826]         do.call(mapply, args = args)
[10:24:46.826]     }
[10:24:46.826] }
[10:24:46.826] Lazy evaluation: FALSE
[10:24:46.826] Asynchronous evaluation: TRUE
[10:24:46.826] Local evaluation: TRUE
[10:24:46.826] Environment: R_GlobalEnv
[10:24:46.826] Capture standard output: FALSE
[10:24:46.826] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:46.826] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:46.826] Packages: <none>
[10:24:46.826] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:46.826] Resolved: FALSE
[10:24:46.826] Value: <not collected>
[10:24:46.826] Conditions captured: <none>
[10:24:46.826] Early signaling: FALSE
[10:24:46.826] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:46.826] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:46.837] Chunk #2 of 2 ... DONE
[10:24:46.837] Launching 2 futures (chunks) ... DONE
[10:24:46.838] Resolving 2 futures (chunks) ...
[10:24:46.838] resolve() on list ...
[10:24:46.838]  recursive: 0
[10:24:46.838]  length: 2
[10:24:46.838] 
[10:24:46.880] receiveMessageFromWorker() for ClusterFuture ...
[10:24:46.880] - Validating connection of MultisessionFuture
[10:24:46.881] - received message: FutureResult
[10:24:46.881] - Received FutureResult
[10:24:46.881] - Erased future from FutureRegistry
[10:24:46.881] result() for ClusterFuture ...
[10:24:46.881] - result already collected: FutureResult
[10:24:46.881] result() for ClusterFuture ... done
[10:24:46.881] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:46.881] Future #2
[10:24:46.881] result() for ClusterFuture ...
[10:24:46.881] - result already collected: FutureResult
[10:24:46.882] result() for ClusterFuture ... done
[10:24:46.882] result() for ClusterFuture ...
[10:24:46.882] - result already collected: FutureResult
[10:24:46.882] result() for ClusterFuture ... done
[10:24:46.882] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:24:46.882] - nx: 2
[10:24:46.882] - relay: TRUE
[10:24:46.882] - stdout: TRUE
[10:24:46.882] - signal: TRUE
[10:24:46.882] - resignal: FALSE
[10:24:46.882] - force: TRUE
[10:24:46.883] - relayed: [n=2] FALSE, FALSE
[10:24:46.883] - queued futures: [n=2] FALSE, FALSE
[10:24:46.883]  - until=1
[10:24:46.883]  - relaying element #1
[10:24:46.883] - relayed: [n=2] FALSE, FALSE
[10:24:46.883] - queued futures: [n=2] FALSE, TRUE
[10:24:46.883] signalConditionsASAP(NULL, pos=2) ... done
[10:24:46.883]  length: 1 (resolved future 2)
[10:24:47.335] receiveMessageFromWorker() for ClusterFuture ...
[10:24:47.336] - Validating connection of MultisessionFuture
[10:24:47.336] - received message: FutureResult
[10:24:47.336] - Received FutureResult
[10:24:47.336] - Erased future from FutureRegistry
[10:24:47.336] result() for ClusterFuture ...
[10:24:47.336] - result already collected: FutureResult
[10:24:47.336] result() for ClusterFuture ... done
[10:24:47.336] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:47.337] Future #1
[10:24:47.337] result() for ClusterFuture ...
[10:24:47.337] - result already collected: FutureResult
[10:24:47.337] result() for ClusterFuture ... done
[10:24:47.337] result() for ClusterFuture ...
[10:24:47.337] - result already collected: FutureResult
[10:24:47.337] result() for ClusterFuture ... done
[10:24:47.337] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:24:47.337] - nx: 2
[10:24:47.337] - relay: TRUE
[10:24:47.337] - stdout: TRUE
[10:24:47.338] - signal: TRUE
[10:24:47.338] - resignal: FALSE
[10:24:47.338] - force: TRUE
[10:24:47.338] - relayed: [n=2] FALSE, FALSE
[10:24:47.338] - queued futures: [n=2] FALSE, TRUE
[10:24:47.338]  - until=1
[10:24:47.338]  - relaying element #1
[10:24:47.338] result() for ClusterFuture ...
[10:24:47.338] - result already collected: FutureResult
[10:24:47.338] result() for ClusterFuture ... done
[10:24:47.339] result() for ClusterFuture ...
[10:24:47.339] - result already collected: FutureResult
[10:24:47.339] result() for ClusterFuture ... done
[10:24:47.339] result() for ClusterFuture ...
[10:24:47.339] - result already collected: FutureResult
[10:24:47.339] result() for ClusterFuture ... done
[10:24:47.339] result() for ClusterFuture ...
[10:24:47.339] - result already collected: FutureResult
[10:24:47.339] result() for ClusterFuture ... done
[10:24:47.339] - relayed: [n=2] TRUE, FALSE
[10:24:47.339] - queued futures: [n=2] TRUE, TRUE
[10:24:47.339] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:24:47.340]  length: 0 (resolved future 1)
[10:24:47.340] Relaying remaining futures
[10:24:47.340] signalConditionsASAP(NULL, pos=0) ...
[10:24:47.340] - nx: 2
[10:24:47.340] - relay: TRUE
[10:24:47.340] - stdout: TRUE
[10:24:47.340] - signal: TRUE
[10:24:47.340] - resignal: FALSE
[10:24:47.340] - force: TRUE
[10:24:47.340] - relayed: [n=2] TRUE, FALSE
[10:24:47.340] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:47.341]  - relaying element #2
[10:24:47.341] result() for ClusterFuture ...
[10:24:47.341] - result already collected: FutureResult
[10:24:47.341] result() for ClusterFuture ... done
[10:24:47.341] result() for ClusterFuture ...
[10:24:47.341] - result already collected: FutureResult
[10:24:47.341] result() for ClusterFuture ... done
[10:24:47.341] result() for ClusterFuture ...
[10:24:47.341] - result already collected: FutureResult
[10:24:47.341] result() for ClusterFuture ... done
[10:24:47.341] result() for ClusterFuture ...
[10:24:47.342] - result already collected: FutureResult
[10:24:47.342] result() for ClusterFuture ... done
[10:24:47.342] - relayed: [n=2] TRUE, TRUE
[10:24:47.342] - queued futures: [n=2] TRUE, TRUE
[10:24:47.342] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[10:24:47.342] resolve() on list ... DONE
[10:24:47.342] result() for ClusterFuture ...
[10:24:47.342] - result already collected: FutureResult
[10:24:47.342] result() for ClusterFuture ... done
[10:24:47.342] result() for ClusterFuture ...
[10:24:47.342] - result already collected: FutureResult
[10:24:47.342] result() for ClusterFuture ... done
[10:24:47.343] result() for ClusterFuture ...
[10:24:47.343] - result already collected: FutureResult
[10:24:47.343] result() for ClusterFuture ... done
[10:24:47.343] result() for ClusterFuture ...
[10:24:47.343] - result already collected: FutureResult
[10:24:47.343] result() for ClusterFuture ... done
[10:24:47.343]  - Number of value chunks collected: 2
[10:24:47.343] Resolving 2 futures (chunks) ... DONE
[10:24:47.343] Reducing values from 2 chunks ...
[10:24:47.343]  - Number of values collected after concatenation: 2
[10:24:47.343]  - Number of values expected: 2
[10:24:47.344] Reducing values from 2 chunks ... DONE
[10:24:47.344] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[10:24:47.344] future_mapply() ...
[10:24:47.348] Number of chunks: 2
[10:24:47.348] getGlobalsAndPackagesXApply() ...
[10:24:47.348]  - future.globals: TRUE
[10:24:47.348] getGlobalsAndPackages() ...
[10:24:47.348] Searching for globals...
[10:24:47.350] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:24:47.350] Searching for globals ... DONE
[10:24:47.350] Resolving globals: FALSE
[10:24:47.350] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[10:24:47.351] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[10:24:47.351] - globals: [1] ‘FUN’
[10:24:47.351] 
[10:24:47.351] getGlobalsAndPackages() ... DONE
[10:24:47.351]  - globals found/used: [n=1] ‘FUN’
[10:24:47.351]  - needed namespaces: [n=0] 
[10:24:47.351] Finding globals ... DONE
[10:24:47.351] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:24:47.352] List of 2
[10:24:47.352]  $ ...future.FUN:function (x, y)  
[10:24:47.352]  $ MoreArgs     : NULL
[10:24:47.352]  - attr(*, "where")=List of 2
[10:24:47.352]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:47.352]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:24:47.352]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:47.352]  - attr(*, "resolved")= logi FALSE
[10:24:47.352]  - attr(*, "total_size")= num NA
[10:24:47.354] Packages to be attached in all futures: [n=0] 
[10:24:47.354] getGlobalsAndPackagesXApply() ... DONE
[10:24:47.354] Number of futures (= number of chunks): 2
[10:24:47.354] Launching 2 futures (chunks) ...
[10:24:47.355] Chunk #1 of 2 ...
[10:24:47.355]  - Finding globals in '...' for chunk #1 ...
[10:24:47.355] getGlobalsAndPackages() ...
[10:24:47.355] Searching for globals...
[10:24:47.355] 
[10:24:47.355] Searching for globals ... DONE
[10:24:47.355] - globals: [0] <none>
[10:24:47.355] getGlobalsAndPackages() ... DONE
[10:24:47.356]    + additional globals found: [n=0] 
[10:24:47.356]    + additional namespaces needed: [n=0] 
[10:24:47.356]  - Finding globals in '...' for chunk #1 ... DONE
[10:24:47.356]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:47.356]  - seeds: <none>
[10:24:47.356]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:47.356] getGlobalsAndPackages() ...
[10:24:47.356] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:47.356] Resolving globals: FALSE
[10:24:47.357] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[10:24:47.357] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:24:47.357] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:47.357] 
[10:24:47.358] getGlobalsAndPackages() ... DONE
[10:24:47.358] run() for ‘Future’ ...
[10:24:47.358] - state: ‘created’
[10:24:47.358] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:47.372] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:47.372] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:47.372]   - Field: ‘node’
[10:24:47.372]   - Field: ‘label’
[10:24:47.372]   - Field: ‘local’
[10:24:47.372]   - Field: ‘owner’
[10:24:47.372]   - Field: ‘envir’
[10:24:47.372]   - Field: ‘workers’
[10:24:47.372]   - Field: ‘packages’
[10:24:47.372]   - Field: ‘gc’
[10:24:47.373]   - Field: ‘conditions’
[10:24:47.373]   - Field: ‘persistent’
[10:24:47.373]   - Field: ‘expr’
[10:24:47.373]   - Field: ‘uuid’
[10:24:47.373]   - Field: ‘seed’
[10:24:47.373]   - Field: ‘version’
[10:24:47.373]   - Field: ‘result’
[10:24:47.373]   - Field: ‘asynchronous’
[10:24:47.373]   - Field: ‘calls’
[10:24:47.373]   - Field: ‘globals’
[10:24:47.374]   - Field: ‘stdout’
[10:24:47.374]   - Field: ‘earlySignal’
[10:24:47.374]   - Field: ‘lazy’
[10:24:47.374]   - Field: ‘state’
[10:24:47.374] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:47.374] - Launch lazy future ...
[10:24:47.374] Packages needed by the future expression (n = 0): <none>
[10:24:47.374] Packages needed by future strategies (n = 0): <none>
[10:24:47.375] {
[10:24:47.375]     {
[10:24:47.375]         {
[10:24:47.375]             ...future.startTime <- base::Sys.time()
[10:24:47.375]             {
[10:24:47.375]                 {
[10:24:47.375]                   {
[10:24:47.375]                     {
[10:24:47.375]                       base::local({
[10:24:47.375]                         has_future <- base::requireNamespace("future", 
[10:24:47.375]                           quietly = TRUE)
[10:24:47.375]                         if (has_future) {
[10:24:47.375]                           ns <- base::getNamespace("future")
[10:24:47.375]                           version <- ns[[".package"]][["version"]]
[10:24:47.375]                           if (is.null(version)) 
[10:24:47.375]                             version <- utils::packageVersion("future")
[10:24:47.375]                         }
[10:24:47.375]                         else {
[10:24:47.375]                           version <- NULL
[10:24:47.375]                         }
[10:24:47.375]                         if (!has_future || version < "1.8.0") {
[10:24:47.375]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:47.375]                             "", base::R.version$version.string), 
[10:24:47.375]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:47.375]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:47.375]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:47.375]                               "release", "version")], collapse = " "), 
[10:24:47.375]                             hostname = base::Sys.info()[["nodename"]])
[10:24:47.375]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:47.375]                             info)
[10:24:47.375]                           info <- base::paste(info, collapse = "; ")
[10:24:47.375]                           if (!has_future) {
[10:24:47.375]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:47.375]                               info)
[10:24:47.375]                           }
[10:24:47.375]                           else {
[10:24:47.375]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:47.375]                               info, version)
[10:24:47.375]                           }
[10:24:47.375]                           base::stop(msg)
[10:24:47.375]                         }
[10:24:47.375]                       })
[10:24:47.375]                     }
[10:24:47.375]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:47.375]                     base::options(mc.cores = 1L)
[10:24:47.375]                   }
[10:24:47.375]                   options(future.plan = NULL)
[10:24:47.375]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:47.375]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:47.375]                 }
[10:24:47.375]                 ...future.workdir <- getwd()
[10:24:47.375]             }
[10:24:47.375]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:47.375]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:47.375]         }
[10:24:47.375]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:47.375]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:47.375]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:47.375]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:47.375]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:47.375]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:47.375]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:47.375]             base::names(...future.oldOptions))
[10:24:47.375]     }
[10:24:47.375]     if (FALSE) {
[10:24:47.375]     }
[10:24:47.375]     else {
[10:24:47.375]         if (TRUE) {
[10:24:47.375]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:47.375]                 open = "w")
[10:24:47.375]         }
[10:24:47.375]         else {
[10:24:47.375]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:47.375]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:47.375]         }
[10:24:47.375]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:47.375]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:47.375]             base::sink(type = "output", split = FALSE)
[10:24:47.375]             base::close(...future.stdout)
[10:24:47.375]         }, add = TRUE)
[10:24:47.375]     }
[10:24:47.375]     ...future.frame <- base::sys.nframe()
[10:24:47.375]     ...future.conditions <- base::list()
[10:24:47.375]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:47.375]     if (FALSE) {
[10:24:47.375]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:47.375]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:47.375]     }
[10:24:47.375]     ...future.result <- base::tryCatch({
[10:24:47.375]         base::withCallingHandlers({
[10:24:47.375]             ...future.value <- base::withVisible(base::local({
[10:24:47.375]                 ...future.makeSendCondition <- base::local({
[10:24:47.375]                   sendCondition <- NULL
[10:24:47.375]                   function(frame = 1L) {
[10:24:47.375]                     if (is.function(sendCondition)) 
[10:24:47.375]                       return(sendCondition)
[10:24:47.375]                     ns <- getNamespace("parallel")
[10:24:47.375]                     if (exists("sendData", mode = "function", 
[10:24:47.375]                       envir = ns)) {
[10:24:47.375]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:47.375]                         envir = ns)
[10:24:47.375]                       envir <- sys.frame(frame)
[10:24:47.375]                       master <- NULL
[10:24:47.375]                       while (!identical(envir, .GlobalEnv) && 
[10:24:47.375]                         !identical(envir, emptyenv())) {
[10:24:47.375]                         if (exists("master", mode = "list", envir = envir, 
[10:24:47.375]                           inherits = FALSE)) {
[10:24:47.375]                           master <- get("master", mode = "list", 
[10:24:47.375]                             envir = envir, inherits = FALSE)
[10:24:47.375]                           if (inherits(master, c("SOCKnode", 
[10:24:47.375]                             "SOCK0node"))) {
[10:24:47.375]                             sendCondition <<- function(cond) {
[10:24:47.375]                               data <- list(type = "VALUE", value = cond, 
[10:24:47.375]                                 success = TRUE)
[10:24:47.375]                               parallel_sendData(master, data)
[10:24:47.375]                             }
[10:24:47.375]                             return(sendCondition)
[10:24:47.375]                           }
[10:24:47.375]                         }
[10:24:47.375]                         frame <- frame + 1L
[10:24:47.375]                         envir <- sys.frame(frame)
[10:24:47.375]                       }
[10:24:47.375]                     }
[10:24:47.375]                     sendCondition <<- function(cond) NULL
[10:24:47.375]                   }
[10:24:47.375]                 })
[10:24:47.375]                 withCallingHandlers({
[10:24:47.375]                   {
[10:24:47.375]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:47.375]                     if (!identical(...future.globals.maxSize.org, 
[10:24:47.375]                       ...future.globals.maxSize)) {
[10:24:47.375]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:47.375]                       on.exit(options(oopts), add = TRUE)
[10:24:47.375]                     }
[10:24:47.375]                     {
[10:24:47.375]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:47.375]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:24:47.375]                         USE.NAMES = FALSE)
[10:24:47.375]                       do.call(mapply, args = args)
[10:24:47.375]                     }
[10:24:47.375]                   }
[10:24:47.375]                 }, immediateCondition = function(cond) {
[10:24:47.375]                   sendCondition <- ...future.makeSendCondition()
[10:24:47.375]                   sendCondition(cond)
[10:24:47.375]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:47.375]                   {
[10:24:47.375]                     inherits <- base::inherits
[10:24:47.375]                     invokeRestart <- base::invokeRestart
[10:24:47.375]                     is.null <- base::is.null
[10:24:47.375]                     muffled <- FALSE
[10:24:47.375]                     if (inherits(cond, "message")) {
[10:24:47.375]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:47.375]                       if (muffled) 
[10:24:47.375]                         invokeRestart("muffleMessage")
[10:24:47.375]                     }
[10:24:47.375]                     else if (inherits(cond, "warning")) {
[10:24:47.375]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:47.375]                       if (muffled) 
[10:24:47.375]                         invokeRestart("muffleWarning")
[10:24:47.375]                     }
[10:24:47.375]                     else if (inherits(cond, "condition")) {
[10:24:47.375]                       if (!is.null(pattern)) {
[10:24:47.375]                         computeRestarts <- base::computeRestarts
[10:24:47.375]                         grepl <- base::grepl
[10:24:47.375]                         restarts <- computeRestarts(cond)
[10:24:47.375]                         for (restart in restarts) {
[10:24:47.375]                           name <- restart$name
[10:24:47.375]                           if (is.null(name)) 
[10:24:47.375]                             next
[10:24:47.375]                           if (!grepl(pattern, name)) 
[10:24:47.375]                             next
[10:24:47.375]                           invokeRestart(restart)
[10:24:47.375]                           muffled <- TRUE
[10:24:47.375]                           break
[10:24:47.375]                         }
[10:24:47.375]                       }
[10:24:47.375]                     }
[10:24:47.375]                     invisible(muffled)
[10:24:47.375]                   }
[10:24:47.375]                   muffleCondition(cond)
[10:24:47.375]                 })
[10:24:47.375]             }))
[10:24:47.375]             future::FutureResult(value = ...future.value$value, 
[10:24:47.375]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:47.375]                   ...future.rng), globalenv = if (FALSE) 
[10:24:47.375]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:47.375]                     ...future.globalenv.names))
[10:24:47.375]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:47.375]         }, condition = base::local({
[10:24:47.375]             c <- base::c
[10:24:47.375]             inherits <- base::inherits
[10:24:47.375]             invokeRestart <- base::invokeRestart
[10:24:47.375]             length <- base::length
[10:24:47.375]             list <- base::list
[10:24:47.375]             seq.int <- base::seq.int
[10:24:47.375]             signalCondition <- base::signalCondition
[10:24:47.375]             sys.calls <- base::sys.calls
[10:24:47.375]             `[[` <- base::`[[`
[10:24:47.375]             `+` <- base::`+`
[10:24:47.375]             `<<-` <- base::`<<-`
[10:24:47.375]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:47.375]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:47.375]                   3L)]
[10:24:47.375]             }
[10:24:47.375]             function(cond) {
[10:24:47.375]                 is_error <- inherits(cond, "error")
[10:24:47.375]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:47.375]                   NULL)
[10:24:47.375]                 if (is_error) {
[10:24:47.375]                   sessionInformation <- function() {
[10:24:47.375]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:47.375]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:47.375]                       search = base::search(), system = base::Sys.info())
[10:24:47.375]                   }
[10:24:47.375]                   ...future.conditions[[length(...future.conditions) + 
[10:24:47.375]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:47.375]                     cond$call), session = sessionInformation(), 
[10:24:47.375]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:47.375]                   signalCondition(cond)
[10:24:47.375]                 }
[10:24:47.375]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:47.375]                 "immediateCondition"))) {
[10:24:47.375]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:47.375]                   ...future.conditions[[length(...future.conditions) + 
[10:24:47.375]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:47.375]                   if (TRUE && !signal) {
[10:24:47.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:47.375]                     {
[10:24:47.375]                       inherits <- base::inherits
[10:24:47.375]                       invokeRestart <- base::invokeRestart
[10:24:47.375]                       is.null <- base::is.null
[10:24:47.375]                       muffled <- FALSE
[10:24:47.375]                       if (inherits(cond, "message")) {
[10:24:47.375]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:47.375]                         if (muffled) 
[10:24:47.375]                           invokeRestart("muffleMessage")
[10:24:47.375]                       }
[10:24:47.375]                       else if (inherits(cond, "warning")) {
[10:24:47.375]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:47.375]                         if (muffled) 
[10:24:47.375]                           invokeRestart("muffleWarning")
[10:24:47.375]                       }
[10:24:47.375]                       else if (inherits(cond, "condition")) {
[10:24:47.375]                         if (!is.null(pattern)) {
[10:24:47.375]                           computeRestarts <- base::computeRestarts
[10:24:47.375]                           grepl <- base::grepl
[10:24:47.375]                           restarts <- computeRestarts(cond)
[10:24:47.375]                           for (restart in restarts) {
[10:24:47.375]                             name <- restart$name
[10:24:47.375]                             if (is.null(name)) 
[10:24:47.375]                               next
[10:24:47.375]                             if (!grepl(pattern, name)) 
[10:24:47.375]                               next
[10:24:47.375]                             invokeRestart(restart)
[10:24:47.375]                             muffled <- TRUE
[10:24:47.375]                             break
[10:24:47.375]                           }
[10:24:47.375]                         }
[10:24:47.375]                       }
[10:24:47.375]                       invisible(muffled)
[10:24:47.375]                     }
[10:24:47.375]                     muffleCondition(cond, pattern = "^muffle")
[10:24:47.375]                   }
[10:24:47.375]                 }
[10:24:47.375]                 else {
[10:24:47.375]                   if (TRUE) {
[10:24:47.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:47.375]                     {
[10:24:47.375]                       inherits <- base::inherits
[10:24:47.375]                       invokeRestart <- base::invokeRestart
[10:24:47.375]                       is.null <- base::is.null
[10:24:47.375]                       muffled <- FALSE
[10:24:47.375]                       if (inherits(cond, "message")) {
[10:24:47.375]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:47.375]                         if (muffled) 
[10:24:47.375]                           invokeRestart("muffleMessage")
[10:24:47.375]                       }
[10:24:47.375]                       else if (inherits(cond, "warning")) {
[10:24:47.375]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:47.375]                         if (muffled) 
[10:24:47.375]                           invokeRestart("muffleWarning")
[10:24:47.375]                       }
[10:24:47.375]                       else if (inherits(cond, "condition")) {
[10:24:47.375]                         if (!is.null(pattern)) {
[10:24:47.375]                           computeRestarts <- base::computeRestarts
[10:24:47.375]                           grepl <- base::grepl
[10:24:47.375]                           restarts <- computeRestarts(cond)
[10:24:47.375]                           for (restart in restarts) {
[10:24:47.375]                             name <- restart$name
[10:24:47.375]                             if (is.null(name)) 
[10:24:47.375]                               next
[10:24:47.375]                             if (!grepl(pattern, name)) 
[10:24:47.375]                               next
[10:24:47.375]                             invokeRestart(restart)
[10:24:47.375]                             muffled <- TRUE
[10:24:47.375]                             break
[10:24:47.375]                           }
[10:24:47.375]                         }
[10:24:47.375]                       }
[10:24:47.375]                       invisible(muffled)
[10:24:47.375]                     }
[10:24:47.375]                     muffleCondition(cond, pattern = "^muffle")
[10:24:47.375]                   }
[10:24:47.375]                 }
[10:24:47.375]             }
[10:24:47.375]         }))
[10:24:47.375]     }, error = function(ex) {
[10:24:47.375]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:47.375]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:47.375]                 ...future.rng), started = ...future.startTime, 
[10:24:47.375]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:47.375]             version = "1.8"), class = "FutureResult")
[10:24:47.375]     }, finally = {
[10:24:47.375]         if (!identical(...future.workdir, getwd())) 
[10:24:47.375]             setwd(...future.workdir)
[10:24:47.375]         {
[10:24:47.375]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:47.375]                 ...future.oldOptions$nwarnings <- NULL
[10:24:47.375]             }
[10:24:47.375]             base::options(...future.oldOptions)
[10:24:47.375]             if (.Platform$OS.type == "windows") {
[10:24:47.375]                 old_names <- names(...future.oldEnvVars)
[10:24:47.375]                 envs <- base::Sys.getenv()
[10:24:47.375]                 names <- names(envs)
[10:24:47.375]                 common <- intersect(names, old_names)
[10:24:47.375]                 added <- setdiff(names, old_names)
[10:24:47.375]                 removed <- setdiff(old_names, names)
[10:24:47.375]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:47.375]                   envs[common]]
[10:24:47.375]                 NAMES <- toupper(changed)
[10:24:47.375]                 args <- list()
[10:24:47.375]                 for (kk in seq_along(NAMES)) {
[10:24:47.375]                   name <- changed[[kk]]
[10:24:47.375]                   NAME <- NAMES[[kk]]
[10:24:47.375]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:47.375]                     next
[10:24:47.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:47.375]                 }
[10:24:47.375]                 NAMES <- toupper(added)
[10:24:47.375]                 for (kk in seq_along(NAMES)) {
[10:24:47.375]                   name <- added[[kk]]
[10:24:47.375]                   NAME <- NAMES[[kk]]
[10:24:47.375]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:47.375]                     next
[10:24:47.375]                   args[[name]] <- ""
[10:24:47.375]                 }
[10:24:47.375]                 NAMES <- toupper(removed)
[10:24:47.375]                 for (kk in seq_along(NAMES)) {
[10:24:47.375]                   name <- removed[[kk]]
[10:24:47.375]                   NAME <- NAMES[[kk]]
[10:24:47.375]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:47.375]                     next
[10:24:47.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:47.375]                 }
[10:24:47.375]                 if (length(args) > 0) 
[10:24:47.375]                   base::do.call(base::Sys.setenv, args = args)
[10:24:47.375]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:47.375]             }
[10:24:47.375]             else {
[10:24:47.375]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:47.375]             }
[10:24:47.375]             {
[10:24:47.375]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:47.375]                   0L) {
[10:24:47.375]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:47.375]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:47.375]                   base::options(opts)
[10:24:47.375]                 }
[10:24:47.375]                 {
[10:24:47.375]                   {
[10:24:47.375]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:47.375]                     NULL
[10:24:47.375]                   }
[10:24:47.375]                   options(future.plan = NULL)
[10:24:47.375]                   if (is.na(NA_character_)) 
[10:24:47.375]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:47.375]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:47.375]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:47.375]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:47.375]                     envir = parent.frame()) 
[10:24:47.375]                   {
[10:24:47.375]                     if (is.function(workers)) 
[10:24:47.375]                       workers <- workers()
[10:24:47.375]                     workers <- structure(as.integer(workers), 
[10:24:47.375]                       class = class(workers))
[10:24:47.375]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:47.375]                       workers >= 1)
[10:24:47.375]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:47.375]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:47.375]                     }
[10:24:47.375]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:47.375]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:47.375]                       envir = envir)
[10:24:47.375]                     if (!future$lazy) 
[10:24:47.375]                       future <- run(future)
[10:24:47.375]                     invisible(future)
[10:24:47.375]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:47.375]                 }
[10:24:47.375]             }
[10:24:47.375]         }
[10:24:47.375]     })
[10:24:47.375]     if (TRUE) {
[10:24:47.375]         base::sink(type = "output", split = FALSE)
[10:24:47.375]         if (TRUE) {
[10:24:47.375]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:47.375]         }
[10:24:47.375]         else {
[10:24:47.375]             ...future.result["stdout"] <- base::list(NULL)
[10:24:47.375]         }
[10:24:47.375]         base::close(...future.stdout)
[10:24:47.375]         ...future.stdout <- NULL
[10:24:47.375]     }
[10:24:47.375]     ...future.result$conditions <- ...future.conditions
[10:24:47.375]     ...future.result$finished <- base::Sys.time()
[10:24:47.375]     ...future.result
[10:24:47.375] }
[10:24:47.378] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[10:24:47.378] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[10:24:47.378] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[10:24:47.378] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[10:24:47.379] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[10:24:47.379] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[10:24:47.379] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[10:24:47.379] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:24:47.380] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:24:47.380] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:24:47.380] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:24:47.380] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[10:24:47.381] MultisessionFuture started
[10:24:47.381] - Launch lazy future ... done
[10:24:47.381] run() for ‘MultisessionFuture’ ... done
[10:24:47.381] Created future:
[10:24:47.381] MultisessionFuture:
[10:24:47.381] Label: ‘future_mapply-1’
[10:24:47.381] Expression:
[10:24:47.381] {
[10:24:47.381]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:47.381]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:47.381]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:47.381]         on.exit(options(oopts), add = TRUE)
[10:24:47.381]     }
[10:24:47.381]     {
[10:24:47.381]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:47.381]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:24:47.381]         do.call(mapply, args = args)
[10:24:47.381]     }
[10:24:47.381] }
[10:24:47.381] Lazy evaluation: FALSE
[10:24:47.381] Asynchronous evaluation: TRUE
[10:24:47.381] Local evaluation: TRUE
[10:24:47.381] Environment: R_GlobalEnv
[10:24:47.381] Capture standard output: TRUE
[10:24:47.381] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:47.381] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:47.381] Packages: <none>
[10:24:47.381] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:47.381] Resolved: FALSE
[10:24:47.381] Value: <not collected>
[10:24:47.381] Conditions captured: <none>
[10:24:47.381] Early signaling: FALSE
[10:24:47.381] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:47.381] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:47.393] Chunk #1 of 2 ... DONE
[10:24:47.393] Chunk #2 of 2 ...
[10:24:47.393]  - Finding globals in '...' for chunk #2 ...
[10:24:47.393] getGlobalsAndPackages() ...
[10:24:47.393] Searching for globals...
[10:24:47.394] 
[10:24:47.394] Searching for globals ... DONE
[10:24:47.394] - globals: [0] <none>
[10:24:47.394] getGlobalsAndPackages() ... DONE
[10:24:47.394]    + additional globals found: [n=0] 
[10:24:47.394]    + additional namespaces needed: [n=0] 
[10:24:47.394]  - Finding globals in '...' for chunk #2 ... DONE
[10:24:47.394]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:47.395]  - seeds: <none>
[10:24:47.395]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:47.395] getGlobalsAndPackages() ...
[10:24:47.395] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:47.395] Resolving globals: FALSE
[10:24:47.395] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[10:24:47.396] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:24:47.396] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:47.396] 
[10:24:47.396] getGlobalsAndPackages() ... DONE
[10:24:47.396] run() for ‘Future’ ...
[10:24:47.397] - state: ‘created’
[10:24:47.397] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:47.413] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:47.413] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:47.413]   - Field: ‘node’
[10:24:47.413]   - Field: ‘label’
[10:24:47.413]   - Field: ‘local’
[10:24:47.413]   - Field: ‘owner’
[10:24:47.413]   - Field: ‘envir’
[10:24:47.414]   - Field: ‘workers’
[10:24:47.414]   - Field: ‘packages’
[10:24:47.414]   - Field: ‘gc’
[10:24:47.414]   - Field: ‘conditions’
[10:24:47.414]   - Field: ‘persistent’
[10:24:47.414]   - Field: ‘expr’
[10:24:47.414]   - Field: ‘uuid’
[10:24:47.414]   - Field: ‘seed’
[10:24:47.414]   - Field: ‘version’
[10:24:47.414]   - Field: ‘result’
[10:24:47.414]   - Field: ‘asynchronous’
[10:24:47.415]   - Field: ‘calls’
[10:24:47.415]   - Field: ‘globals’
[10:24:47.415]   - Field: ‘stdout’
[10:24:47.415]   - Field: ‘earlySignal’
[10:24:47.415]   - Field: ‘lazy’
[10:24:47.415]   - Field: ‘state’
[10:24:47.415] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:47.415] - Launch lazy future ...
[10:24:47.415] Packages needed by the future expression (n = 0): <none>
[10:24:47.415] Packages needed by future strategies (n = 0): <none>
[10:24:47.416] {
[10:24:47.416]     {
[10:24:47.416]         {
[10:24:47.416]             ...future.startTime <- base::Sys.time()
[10:24:47.416]             {
[10:24:47.416]                 {
[10:24:47.416]                   {
[10:24:47.416]                     {
[10:24:47.416]                       base::local({
[10:24:47.416]                         has_future <- base::requireNamespace("future", 
[10:24:47.416]                           quietly = TRUE)
[10:24:47.416]                         if (has_future) {
[10:24:47.416]                           ns <- base::getNamespace("future")
[10:24:47.416]                           version <- ns[[".package"]][["version"]]
[10:24:47.416]                           if (is.null(version)) 
[10:24:47.416]                             version <- utils::packageVersion("future")
[10:24:47.416]                         }
[10:24:47.416]                         else {
[10:24:47.416]                           version <- NULL
[10:24:47.416]                         }
[10:24:47.416]                         if (!has_future || version < "1.8.0") {
[10:24:47.416]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:47.416]                             "", base::R.version$version.string), 
[10:24:47.416]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:47.416]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:47.416]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:47.416]                               "release", "version")], collapse = " "), 
[10:24:47.416]                             hostname = base::Sys.info()[["nodename"]])
[10:24:47.416]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:47.416]                             info)
[10:24:47.416]                           info <- base::paste(info, collapse = "; ")
[10:24:47.416]                           if (!has_future) {
[10:24:47.416]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:47.416]                               info)
[10:24:47.416]                           }
[10:24:47.416]                           else {
[10:24:47.416]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:47.416]                               info, version)
[10:24:47.416]                           }
[10:24:47.416]                           base::stop(msg)
[10:24:47.416]                         }
[10:24:47.416]                       })
[10:24:47.416]                     }
[10:24:47.416]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:47.416]                     base::options(mc.cores = 1L)
[10:24:47.416]                   }
[10:24:47.416]                   options(future.plan = NULL)
[10:24:47.416]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:47.416]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:47.416]                 }
[10:24:47.416]                 ...future.workdir <- getwd()
[10:24:47.416]             }
[10:24:47.416]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:47.416]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:47.416]         }
[10:24:47.416]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:47.416]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:47.416]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:47.416]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:47.416]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:47.416]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:47.416]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:47.416]             base::names(...future.oldOptions))
[10:24:47.416]     }
[10:24:47.416]     if (FALSE) {
[10:24:47.416]     }
[10:24:47.416]     else {
[10:24:47.416]         if (TRUE) {
[10:24:47.416]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:47.416]                 open = "w")
[10:24:47.416]         }
[10:24:47.416]         else {
[10:24:47.416]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:47.416]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:47.416]         }
[10:24:47.416]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:47.416]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:47.416]             base::sink(type = "output", split = FALSE)
[10:24:47.416]             base::close(...future.stdout)
[10:24:47.416]         }, add = TRUE)
[10:24:47.416]     }
[10:24:47.416]     ...future.frame <- base::sys.nframe()
[10:24:47.416]     ...future.conditions <- base::list()
[10:24:47.416]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:47.416]     if (FALSE) {
[10:24:47.416]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:47.416]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:47.416]     }
[10:24:47.416]     ...future.result <- base::tryCatch({
[10:24:47.416]         base::withCallingHandlers({
[10:24:47.416]             ...future.value <- base::withVisible(base::local({
[10:24:47.416]                 ...future.makeSendCondition <- base::local({
[10:24:47.416]                   sendCondition <- NULL
[10:24:47.416]                   function(frame = 1L) {
[10:24:47.416]                     if (is.function(sendCondition)) 
[10:24:47.416]                       return(sendCondition)
[10:24:47.416]                     ns <- getNamespace("parallel")
[10:24:47.416]                     if (exists("sendData", mode = "function", 
[10:24:47.416]                       envir = ns)) {
[10:24:47.416]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:47.416]                         envir = ns)
[10:24:47.416]                       envir <- sys.frame(frame)
[10:24:47.416]                       master <- NULL
[10:24:47.416]                       while (!identical(envir, .GlobalEnv) && 
[10:24:47.416]                         !identical(envir, emptyenv())) {
[10:24:47.416]                         if (exists("master", mode = "list", envir = envir, 
[10:24:47.416]                           inherits = FALSE)) {
[10:24:47.416]                           master <- get("master", mode = "list", 
[10:24:47.416]                             envir = envir, inherits = FALSE)
[10:24:47.416]                           if (inherits(master, c("SOCKnode", 
[10:24:47.416]                             "SOCK0node"))) {
[10:24:47.416]                             sendCondition <<- function(cond) {
[10:24:47.416]                               data <- list(type = "VALUE", value = cond, 
[10:24:47.416]                                 success = TRUE)
[10:24:47.416]                               parallel_sendData(master, data)
[10:24:47.416]                             }
[10:24:47.416]                             return(sendCondition)
[10:24:47.416]                           }
[10:24:47.416]                         }
[10:24:47.416]                         frame <- frame + 1L
[10:24:47.416]                         envir <- sys.frame(frame)
[10:24:47.416]                       }
[10:24:47.416]                     }
[10:24:47.416]                     sendCondition <<- function(cond) NULL
[10:24:47.416]                   }
[10:24:47.416]                 })
[10:24:47.416]                 withCallingHandlers({
[10:24:47.416]                   {
[10:24:47.416]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:47.416]                     if (!identical(...future.globals.maxSize.org, 
[10:24:47.416]                       ...future.globals.maxSize)) {
[10:24:47.416]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:47.416]                       on.exit(options(oopts), add = TRUE)
[10:24:47.416]                     }
[10:24:47.416]                     {
[10:24:47.416]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:47.416]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:24:47.416]                         USE.NAMES = FALSE)
[10:24:47.416]                       do.call(mapply, args = args)
[10:24:47.416]                     }
[10:24:47.416]                   }
[10:24:47.416]                 }, immediateCondition = function(cond) {
[10:24:47.416]                   sendCondition <- ...future.makeSendCondition()
[10:24:47.416]                   sendCondition(cond)
[10:24:47.416]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:47.416]                   {
[10:24:47.416]                     inherits <- base::inherits
[10:24:47.416]                     invokeRestart <- base::invokeRestart
[10:24:47.416]                     is.null <- base::is.null
[10:24:47.416]                     muffled <- FALSE
[10:24:47.416]                     if (inherits(cond, "message")) {
[10:24:47.416]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:47.416]                       if (muffled) 
[10:24:47.416]                         invokeRestart("muffleMessage")
[10:24:47.416]                     }
[10:24:47.416]                     else if (inherits(cond, "warning")) {
[10:24:47.416]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:47.416]                       if (muffled) 
[10:24:47.416]                         invokeRestart("muffleWarning")
[10:24:47.416]                     }
[10:24:47.416]                     else if (inherits(cond, "condition")) {
[10:24:47.416]                       if (!is.null(pattern)) {
[10:24:47.416]                         computeRestarts <- base::computeRestarts
[10:24:47.416]                         grepl <- base::grepl
[10:24:47.416]                         restarts <- computeRestarts(cond)
[10:24:47.416]                         for (restart in restarts) {
[10:24:47.416]                           name <- restart$name
[10:24:47.416]                           if (is.null(name)) 
[10:24:47.416]                             next
[10:24:47.416]                           if (!grepl(pattern, name)) 
[10:24:47.416]                             next
[10:24:47.416]                           invokeRestart(restart)
[10:24:47.416]                           muffled <- TRUE
[10:24:47.416]                           break
[10:24:47.416]                         }
[10:24:47.416]                       }
[10:24:47.416]                     }
[10:24:47.416]                     invisible(muffled)
[10:24:47.416]                   }
[10:24:47.416]                   muffleCondition(cond)
[10:24:47.416]                 })
[10:24:47.416]             }))
[10:24:47.416]             future::FutureResult(value = ...future.value$value, 
[10:24:47.416]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:47.416]                   ...future.rng), globalenv = if (FALSE) 
[10:24:47.416]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:47.416]                     ...future.globalenv.names))
[10:24:47.416]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:47.416]         }, condition = base::local({
[10:24:47.416]             c <- base::c
[10:24:47.416]             inherits <- base::inherits
[10:24:47.416]             invokeRestart <- base::invokeRestart
[10:24:47.416]             length <- base::length
[10:24:47.416]             list <- base::list
[10:24:47.416]             seq.int <- base::seq.int
[10:24:47.416]             signalCondition <- base::signalCondition
[10:24:47.416]             sys.calls <- base::sys.calls
[10:24:47.416]             `[[` <- base::`[[`
[10:24:47.416]             `+` <- base::`+`
[10:24:47.416]             `<<-` <- base::`<<-`
[10:24:47.416]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:47.416]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:47.416]                   3L)]
[10:24:47.416]             }
[10:24:47.416]             function(cond) {
[10:24:47.416]                 is_error <- inherits(cond, "error")
[10:24:47.416]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:47.416]                   NULL)
[10:24:47.416]                 if (is_error) {
[10:24:47.416]                   sessionInformation <- function() {
[10:24:47.416]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:47.416]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:47.416]                       search = base::search(), system = base::Sys.info())
[10:24:47.416]                   }
[10:24:47.416]                   ...future.conditions[[length(...future.conditions) + 
[10:24:47.416]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:47.416]                     cond$call), session = sessionInformation(), 
[10:24:47.416]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:47.416]                   signalCondition(cond)
[10:24:47.416]                 }
[10:24:47.416]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:47.416]                 "immediateCondition"))) {
[10:24:47.416]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:47.416]                   ...future.conditions[[length(...future.conditions) + 
[10:24:47.416]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:47.416]                   if (TRUE && !signal) {
[10:24:47.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:47.416]                     {
[10:24:47.416]                       inherits <- base::inherits
[10:24:47.416]                       invokeRestart <- base::invokeRestart
[10:24:47.416]                       is.null <- base::is.null
[10:24:47.416]                       muffled <- FALSE
[10:24:47.416]                       if (inherits(cond, "message")) {
[10:24:47.416]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:47.416]                         if (muffled) 
[10:24:47.416]                           invokeRestart("muffleMessage")
[10:24:47.416]                       }
[10:24:47.416]                       else if (inherits(cond, "warning")) {
[10:24:47.416]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:47.416]                         if (muffled) 
[10:24:47.416]                           invokeRestart("muffleWarning")
[10:24:47.416]                       }
[10:24:47.416]                       else if (inherits(cond, "condition")) {
[10:24:47.416]                         if (!is.null(pattern)) {
[10:24:47.416]                           computeRestarts <- base::computeRestarts
[10:24:47.416]                           grepl <- base::grepl
[10:24:47.416]                           restarts <- computeRestarts(cond)
[10:24:47.416]                           for (restart in restarts) {
[10:24:47.416]                             name <- restart$name
[10:24:47.416]                             if (is.null(name)) 
[10:24:47.416]                               next
[10:24:47.416]                             if (!grepl(pattern, name)) 
[10:24:47.416]                               next
[10:24:47.416]                             invokeRestart(restart)
[10:24:47.416]                             muffled <- TRUE
[10:24:47.416]                             break
[10:24:47.416]                           }
[10:24:47.416]                         }
[10:24:47.416]                       }
[10:24:47.416]                       invisible(muffled)
[10:24:47.416]                     }
[10:24:47.416]                     muffleCondition(cond, pattern = "^muffle")
[10:24:47.416]                   }
[10:24:47.416]                 }
[10:24:47.416]                 else {
[10:24:47.416]                   if (TRUE) {
[10:24:47.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:47.416]                     {
[10:24:47.416]                       inherits <- base::inherits
[10:24:47.416]                       invokeRestart <- base::invokeRestart
[10:24:47.416]                       is.null <- base::is.null
[10:24:47.416]                       muffled <- FALSE
[10:24:47.416]                       if (inherits(cond, "message")) {
[10:24:47.416]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:47.416]                         if (muffled) 
[10:24:47.416]                           invokeRestart("muffleMessage")
[10:24:47.416]                       }
[10:24:47.416]                       else if (inherits(cond, "warning")) {
[10:24:47.416]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:47.416]                         if (muffled) 
[10:24:47.416]                           invokeRestart("muffleWarning")
[10:24:47.416]                       }
[10:24:47.416]                       else if (inherits(cond, "condition")) {
[10:24:47.416]                         if (!is.null(pattern)) {
[10:24:47.416]                           computeRestarts <- base::computeRestarts
[10:24:47.416]                           grepl <- base::grepl
[10:24:47.416]                           restarts <- computeRestarts(cond)
[10:24:47.416]                           for (restart in restarts) {
[10:24:47.416]                             name <- restart$name
[10:24:47.416]                             if (is.null(name)) 
[10:24:47.416]                               next
[10:24:47.416]                             if (!grepl(pattern, name)) 
[10:24:47.416]                               next
[10:24:47.416]                             invokeRestart(restart)
[10:24:47.416]                             muffled <- TRUE
[10:24:47.416]                             break
[10:24:47.416]                           }
[10:24:47.416]                         }
[10:24:47.416]                       }
[10:24:47.416]                       invisible(muffled)
[10:24:47.416]                     }
[10:24:47.416]                     muffleCondition(cond, pattern = "^muffle")
[10:24:47.416]                   }
[10:24:47.416]                 }
[10:24:47.416]             }
[10:24:47.416]         }))
[10:24:47.416]     }, error = function(ex) {
[10:24:47.416]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:47.416]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:47.416]                 ...future.rng), started = ...future.startTime, 
[10:24:47.416]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:47.416]             version = "1.8"), class = "FutureResult")
[10:24:47.416]     }, finally = {
[10:24:47.416]         if (!identical(...future.workdir, getwd())) 
[10:24:47.416]             setwd(...future.workdir)
[10:24:47.416]         {
[10:24:47.416]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:47.416]                 ...future.oldOptions$nwarnings <- NULL
[10:24:47.416]             }
[10:24:47.416]             base::options(...future.oldOptions)
[10:24:47.416]             if (.Platform$OS.type == "windows") {
[10:24:47.416]                 old_names <- names(...future.oldEnvVars)
[10:24:47.416]                 envs <- base::Sys.getenv()
[10:24:47.416]                 names <- names(envs)
[10:24:47.416]                 common <- intersect(names, old_names)
[10:24:47.416]                 added <- setdiff(names, old_names)
[10:24:47.416]                 removed <- setdiff(old_names, names)
[10:24:47.416]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:47.416]                   envs[common]]
[10:24:47.416]                 NAMES <- toupper(changed)
[10:24:47.416]                 args <- list()
[10:24:47.416]                 for (kk in seq_along(NAMES)) {
[10:24:47.416]                   name <- changed[[kk]]
[10:24:47.416]                   NAME <- NAMES[[kk]]
[10:24:47.416]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:47.416]                     next
[10:24:47.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:47.416]                 }
[10:24:47.416]                 NAMES <- toupper(added)
[10:24:47.416]                 for (kk in seq_along(NAMES)) {
[10:24:47.416]                   name <- added[[kk]]
[10:24:47.416]                   NAME <- NAMES[[kk]]
[10:24:47.416]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:47.416]                     next
[10:24:47.416]                   args[[name]] <- ""
[10:24:47.416]                 }
[10:24:47.416]                 NAMES <- toupper(removed)
[10:24:47.416]                 for (kk in seq_along(NAMES)) {
[10:24:47.416]                   name <- removed[[kk]]
[10:24:47.416]                   NAME <- NAMES[[kk]]
[10:24:47.416]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:47.416]                     next
[10:24:47.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:47.416]                 }
[10:24:47.416]                 if (length(args) > 0) 
[10:24:47.416]                   base::do.call(base::Sys.setenv, args = args)
[10:24:47.416]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:47.416]             }
[10:24:47.416]             else {
[10:24:47.416]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:47.416]             }
[10:24:47.416]             {
[10:24:47.416]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:47.416]                   0L) {
[10:24:47.416]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:47.416]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:47.416]                   base::options(opts)
[10:24:47.416]                 }
[10:24:47.416]                 {
[10:24:47.416]                   {
[10:24:47.416]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:47.416]                     NULL
[10:24:47.416]                   }
[10:24:47.416]                   options(future.plan = NULL)
[10:24:47.416]                   if (is.na(NA_character_)) 
[10:24:47.416]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:47.416]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:47.416]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:47.416]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:47.416]                     envir = parent.frame()) 
[10:24:47.416]                   {
[10:24:47.416]                     if (is.function(workers)) 
[10:24:47.416]                       workers <- workers()
[10:24:47.416]                     workers <- structure(as.integer(workers), 
[10:24:47.416]                       class = class(workers))
[10:24:47.416]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:47.416]                       workers >= 1)
[10:24:47.416]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:47.416]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:47.416]                     }
[10:24:47.416]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:47.416]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:47.416]                       envir = envir)
[10:24:47.416]                     if (!future$lazy) 
[10:24:47.416]                       future <- run(future)
[10:24:47.416]                     invisible(future)
[10:24:47.416]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:47.416]                 }
[10:24:47.416]             }
[10:24:47.416]         }
[10:24:47.416]     })
[10:24:47.416]     if (TRUE) {
[10:24:47.416]         base::sink(type = "output", split = FALSE)
[10:24:47.416]         if (TRUE) {
[10:24:47.416]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:47.416]         }
[10:24:47.416]         else {
[10:24:47.416]             ...future.result["stdout"] <- base::list(NULL)
[10:24:47.416]         }
[10:24:47.416]         base::close(...future.stdout)
[10:24:47.416]         ...future.stdout <- NULL
[10:24:47.416]     }
[10:24:47.416]     ...future.result$conditions <- ...future.conditions
[10:24:47.416]     ...future.result$finished <- base::Sys.time()
[10:24:47.416]     ...future.result
[10:24:47.416] }
[10:24:47.419] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[10:24:47.419] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[10:24:47.419] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[10:24:47.419] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[10:24:47.420] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[10:24:47.420] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[10:24:47.420] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[10:24:47.420] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:24:47.421] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:24:47.421] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:24:47.421] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:24:47.421] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[10:24:47.422] MultisessionFuture started
[10:24:47.422] - Launch lazy future ... done
[10:24:47.422] run() for ‘MultisessionFuture’ ... done
[10:24:47.422] Created future:
[10:24:47.422] MultisessionFuture:
[10:24:47.422] Label: ‘future_mapply-2’
[10:24:47.422] Expression:
[10:24:47.422] {
[10:24:47.422]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:47.422]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:47.422]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:47.422]         on.exit(options(oopts), add = TRUE)
[10:24:47.422]     }
[10:24:47.422]     {
[10:24:47.422]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:47.422]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:24:47.422]         do.call(mapply, args = args)
[10:24:47.422]     }
[10:24:47.422] }
[10:24:47.422] Lazy evaluation: FALSE
[10:24:47.422] Asynchronous evaluation: TRUE
[10:24:47.422] Local evaluation: TRUE
[10:24:47.422] Environment: R_GlobalEnv
[10:24:47.422] Capture standard output: TRUE
[10:24:47.422] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:47.422] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:47.422] Packages: <none>
[10:24:47.422] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:47.422] Resolved: FALSE
[10:24:47.422] Value: <not collected>
[10:24:47.422] Conditions captured: <none>
[10:24:47.422] Early signaling: FALSE
[10:24:47.422] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:47.422] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:47.434] Chunk #2 of 2 ... DONE
[10:24:47.434] Launching 2 futures (chunks) ... DONE
[10:24:47.434] Resolving 2 futures (chunks) ...
[10:24:47.434] resolve() on list ...
[10:24:47.434]  recursive: 0
[10:24:47.434]  length: 2
[10:24:47.435] 
[10:24:47.477] receiveMessageFromWorker() for ClusterFuture ...
[10:24:47.477] - Validating connection of MultisessionFuture
[10:24:47.477] - received message: FutureResult
[10:24:47.477] - Received FutureResult
[10:24:47.477] - Erased future from FutureRegistry
[10:24:47.478] result() for ClusterFuture ...
[10:24:47.478] - result already collected: FutureResult
[10:24:47.478] result() for ClusterFuture ... done
[10:24:47.478] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:47.478] Future #2
[10:24:47.478] result() for ClusterFuture ...
[10:24:47.478] - result already collected: FutureResult
[10:24:47.478] result() for ClusterFuture ... done
[10:24:47.478] result() for ClusterFuture ...
[10:24:47.478] - result already collected: FutureResult
[10:24:47.478] result() for ClusterFuture ... done
[10:24:47.479] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:24:47.479] - nx: 2
[10:24:47.479] - relay: TRUE
[10:24:47.479] - stdout: TRUE
[10:24:47.479] - signal: TRUE
[10:24:47.479] - resignal: FALSE
[10:24:47.479] - force: TRUE
[10:24:47.479] - relayed: [n=2] FALSE, FALSE
[10:24:47.479] - queued futures: [n=2] FALSE, FALSE
[10:24:47.479]  - until=1
[10:24:47.479]  - relaying element #1
[10:24:47.480] - relayed: [n=2] FALSE, FALSE
[10:24:47.480] - queued futures: [n=2] FALSE, TRUE
[10:24:47.480] signalConditionsASAP(NULL, pos=2) ... done
[10:24:47.480]  length: 1 (resolved future 2)
[10:24:47.927] receiveMessageFromWorker() for ClusterFuture ...
[10:24:47.927] - Validating connection of MultisessionFuture
[10:24:47.928] - received message: FutureResult
[10:24:47.928] - Received FutureResult
[10:24:47.928] - Erased future from FutureRegistry
[10:24:47.928] result() for ClusterFuture ...
[10:24:47.928] - result already collected: FutureResult
[10:24:47.928] result() for ClusterFuture ... done
[10:24:47.928] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:47.929] Future #1
[10:24:47.929] result() for ClusterFuture ...
[10:24:47.929] - result already collected: FutureResult
[10:24:47.929] result() for ClusterFuture ... done
[10:24:47.929] result() for ClusterFuture ...
[10:24:47.929] - result already collected: FutureResult
[10:24:47.929] result() for ClusterFuture ... done
[10:24:47.929] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:24:47.929] - nx: 2
[10:24:47.930] - relay: TRUE
[10:24:47.930] - stdout: TRUE
[10:24:47.930] - signal: TRUE
[10:24:47.930] - resignal: FALSE
[10:24:47.930] - force: TRUE
[10:24:47.930] - relayed: [n=2] FALSE, FALSE
[10:24:47.930] - queued futures: [n=2] FALSE, TRUE
[10:24:47.930]  - until=1
[10:24:47.930]  - relaying element #1
[10:24:47.930] result() for ClusterFuture ...
[10:24:47.930] - result already collected: FutureResult
[10:24:47.931] result() for ClusterFuture ... done
[10:24:47.931] result() for ClusterFuture ...
[10:24:47.931] - result already collected: FutureResult
[10:24:47.931] result() for ClusterFuture ... done
[10:24:47.931] result() for ClusterFuture ...
[10:24:47.931] - result already collected: FutureResult
[10:24:47.931] result() for ClusterFuture ... done
[10:24:47.931] result() for ClusterFuture ...
[10:24:47.931] - result already collected: FutureResult
[10:24:47.931] result() for ClusterFuture ... done
[10:24:47.931] - relayed: [n=2] TRUE, FALSE
[10:24:47.932] - queued futures: [n=2] TRUE, TRUE
[10:24:47.932] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:24:47.932]  length: 0 (resolved future 1)
[10:24:47.932] Relaying remaining futures
[10:24:47.932] signalConditionsASAP(NULL, pos=0) ...
[10:24:47.932] - nx: 2
[10:24:47.932] - relay: TRUE
[10:24:47.932] - stdout: TRUE
[10:24:47.932] - signal: TRUE
[10:24:47.932] - resignal: FALSE
[10:24:47.932] - force: TRUE
[10:24:47.933] - relayed: [n=2] TRUE, FALSE
[10:24:47.933] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:47.933]  - relaying element #2
[10:24:47.933] result() for ClusterFuture ...
[10:24:47.933] - result already collected: FutureResult
[10:24:47.933] result() for ClusterFuture ... done
[10:24:47.933] result() for ClusterFuture ...
[10:24:47.933] - result already collected: FutureResult
[10:24:47.933] result() for ClusterFuture ... done
[10:24:47.933] result() for ClusterFuture ...
[10:24:47.934] - result already collected: FutureResult
[10:24:47.934] result() for ClusterFuture ... done
[10:24:47.934] result() for ClusterFuture ...
[10:24:47.934] - result already collected: FutureResult
[10:24:47.934] result() for ClusterFuture ... done
[10:24:47.934] - relayed: [n=2] TRUE, TRUE
[10:24:47.934] - queued futures: [n=2] TRUE, TRUE
[10:24:47.934] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[10:24:47.934] resolve() on list ... DONE
[10:24:47.934] result() for ClusterFuture ...
[10:24:47.934] - result already collected: FutureResult
[10:24:47.934] result() for ClusterFuture ... done
[10:24:47.935] result() for ClusterFuture ...
[10:24:47.935] - result already collected: FutureResult
[10:24:47.935] result() for ClusterFuture ... done
[10:24:47.935] result() for ClusterFuture ...
[10:24:47.935] - result already collected: FutureResult
[10:24:47.935] result() for ClusterFuture ... done
[10:24:47.935] result() for ClusterFuture ...
[10:24:47.935] - result already collected: FutureResult
[10:24:47.935] result() for ClusterFuture ... done
[10:24:47.935]  - Number of value chunks collected: 2
[10:24:47.935] Resolving 2 futures (chunks) ... DONE
[10:24:47.936] Reducing values from 2 chunks ...
[10:24:47.936]  - Number of values collected after concatenation: 2
[10:24:47.936]  - Number of values expected: 2
[10:24:47.936] Reducing values from 2 chunks ... DONE
[10:24:47.936] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[10:24:47.936] future_mapply() ...
[10:24:47.940] Number of chunks: 2
[10:24:47.940] getGlobalsAndPackagesXApply() ...
[10:24:47.940]  - future.globals: TRUE
[10:24:47.940] getGlobalsAndPackages() ...
[10:24:47.940] Searching for globals...
[10:24:47.942] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:24:47.942] Searching for globals ... DONE
[10:24:47.942] Resolving globals: FALSE
[10:24:47.943] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[10:24:47.943] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[10:24:47.943] - globals: [1] ‘FUN’
[10:24:47.943] 
[10:24:47.943] getGlobalsAndPackages() ... DONE
[10:24:47.944]  - globals found/used: [n=1] ‘FUN’
[10:24:47.944]  - needed namespaces: [n=0] 
[10:24:47.944] Finding globals ... DONE
[10:24:47.944] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:24:47.944] List of 2
[10:24:47.944]  $ ...future.FUN:function (x, y)  
[10:24:47.944]  $ MoreArgs     : NULL
[10:24:47.944]  - attr(*, "where")=List of 2
[10:24:47.944]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:24:47.944]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:24:47.944]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:24:47.944]  - attr(*, "resolved")= logi FALSE
[10:24:47.944]  - attr(*, "total_size")= num NA
[10:24:47.947] Packages to be attached in all futures: [n=0] 
[10:24:47.947] getGlobalsAndPackagesXApply() ... DONE
[10:24:47.947] Number of futures (= number of chunks): 2
[10:24:47.947] Launching 2 futures (chunks) ...
[10:24:47.947] Chunk #1 of 2 ...
[10:24:47.947]  - Finding globals in '...' for chunk #1 ...
[10:24:47.947] getGlobalsAndPackages() ...
[10:24:47.947] Searching for globals...
[10:24:47.948] 
[10:24:47.948] Searching for globals ... DONE
[10:24:47.948] - globals: [0] <none>
[10:24:47.948] getGlobalsAndPackages() ... DONE
[10:24:47.948]    + additional globals found: [n=0] 
[10:24:47.948]    + additional namespaces needed: [n=0] 
[10:24:47.948]  - Finding globals in '...' for chunk #1 ... DONE
[10:24:47.948]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:47.948]  - seeds: <none>
[10:24:47.948]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:47.949] getGlobalsAndPackages() ...
[10:24:47.949] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:47.949] Resolving globals: FALSE
[10:24:47.949] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[10:24:47.950] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:24:47.950] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:47.950] 
[10:24:47.950] getGlobalsAndPackages() ... DONE
[10:24:47.950] run() for ‘Future’ ...
[10:24:47.950] - state: ‘created’
[10:24:47.951] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:47.964] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:47.964] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:47.964]   - Field: ‘node’
[10:24:47.964]   - Field: ‘label’
[10:24:47.965]   - Field: ‘local’
[10:24:47.965]   - Field: ‘owner’
[10:24:47.965]   - Field: ‘envir’
[10:24:47.965]   - Field: ‘workers’
[10:24:47.965]   - Field: ‘packages’
[10:24:47.965]   - Field: ‘gc’
[10:24:47.965]   - Field: ‘conditions’
[10:24:47.965]   - Field: ‘persistent’
[10:24:47.965]   - Field: ‘expr’
[10:24:47.965]   - Field: ‘uuid’
[10:24:47.966]   - Field: ‘seed’
[10:24:47.966]   - Field: ‘version’
[10:24:47.966]   - Field: ‘result’
[10:24:47.966]   - Field: ‘asynchronous’
[10:24:47.966]   - Field: ‘calls’
[10:24:47.966]   - Field: ‘globals’
[10:24:47.966]   - Field: ‘stdout’
[10:24:47.966]   - Field: ‘earlySignal’
[10:24:47.966]   - Field: ‘lazy’
[10:24:47.966]   - Field: ‘state’
[10:24:47.966] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:47.967] - Launch lazy future ...
[10:24:47.967] Packages needed by the future expression (n = 0): <none>
[10:24:47.967] Packages needed by future strategies (n = 0): <none>
[10:24:47.967] {
[10:24:47.967]     {
[10:24:47.967]         {
[10:24:47.967]             ...future.startTime <- base::Sys.time()
[10:24:47.967]             {
[10:24:47.967]                 {
[10:24:47.967]                   {
[10:24:47.967]                     {
[10:24:47.967]                       base::local({
[10:24:47.967]                         has_future <- base::requireNamespace("future", 
[10:24:47.967]                           quietly = TRUE)
[10:24:47.967]                         if (has_future) {
[10:24:47.967]                           ns <- base::getNamespace("future")
[10:24:47.967]                           version <- ns[[".package"]][["version"]]
[10:24:47.967]                           if (is.null(version)) 
[10:24:47.967]                             version <- utils::packageVersion("future")
[10:24:47.967]                         }
[10:24:47.967]                         else {
[10:24:47.967]                           version <- NULL
[10:24:47.967]                         }
[10:24:47.967]                         if (!has_future || version < "1.8.0") {
[10:24:47.967]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:47.967]                             "", base::R.version$version.string), 
[10:24:47.967]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:47.967]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:47.967]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:47.967]                               "release", "version")], collapse = " "), 
[10:24:47.967]                             hostname = base::Sys.info()[["nodename"]])
[10:24:47.967]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:47.967]                             info)
[10:24:47.967]                           info <- base::paste(info, collapse = "; ")
[10:24:47.967]                           if (!has_future) {
[10:24:47.967]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:47.967]                               info)
[10:24:47.967]                           }
[10:24:47.967]                           else {
[10:24:47.967]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:47.967]                               info, version)
[10:24:47.967]                           }
[10:24:47.967]                           base::stop(msg)
[10:24:47.967]                         }
[10:24:47.967]                       })
[10:24:47.967]                     }
[10:24:47.967]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:47.967]                     base::options(mc.cores = 1L)
[10:24:47.967]                   }
[10:24:47.967]                   options(future.plan = NULL)
[10:24:47.967]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:47.967]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:47.967]                 }
[10:24:47.967]                 ...future.workdir <- getwd()
[10:24:47.967]             }
[10:24:47.967]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:47.967]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:47.967]         }
[10:24:47.967]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:47.967]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:47.967]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:47.967]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:47.967]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:47.967]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:47.967]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:47.967]             base::names(...future.oldOptions))
[10:24:47.967]     }
[10:24:47.967]     if (TRUE) {
[10:24:47.967]     }
[10:24:47.967]     else {
[10:24:47.967]         if (NA) {
[10:24:47.967]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:47.967]                 open = "w")
[10:24:47.967]         }
[10:24:47.967]         else {
[10:24:47.967]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:47.967]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:47.967]         }
[10:24:47.967]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:47.967]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:47.967]             base::sink(type = "output", split = FALSE)
[10:24:47.967]             base::close(...future.stdout)
[10:24:47.967]         }, add = TRUE)
[10:24:47.967]     }
[10:24:47.967]     ...future.frame <- base::sys.nframe()
[10:24:47.967]     ...future.conditions <- base::list()
[10:24:47.967]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:47.967]     if (FALSE) {
[10:24:47.967]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:47.967]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:47.967]     }
[10:24:47.967]     ...future.result <- base::tryCatch({
[10:24:47.967]         base::withCallingHandlers({
[10:24:47.967]             ...future.value <- base::withVisible(base::local({
[10:24:47.967]                 ...future.makeSendCondition <- base::local({
[10:24:47.967]                   sendCondition <- NULL
[10:24:47.967]                   function(frame = 1L) {
[10:24:47.967]                     if (is.function(sendCondition)) 
[10:24:47.967]                       return(sendCondition)
[10:24:47.967]                     ns <- getNamespace("parallel")
[10:24:47.967]                     if (exists("sendData", mode = "function", 
[10:24:47.967]                       envir = ns)) {
[10:24:47.967]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:47.967]                         envir = ns)
[10:24:47.967]                       envir <- sys.frame(frame)
[10:24:47.967]                       master <- NULL
[10:24:47.967]                       while (!identical(envir, .GlobalEnv) && 
[10:24:47.967]                         !identical(envir, emptyenv())) {
[10:24:47.967]                         if (exists("master", mode = "list", envir = envir, 
[10:24:47.967]                           inherits = FALSE)) {
[10:24:47.967]                           master <- get("master", mode = "list", 
[10:24:47.967]                             envir = envir, inherits = FALSE)
[10:24:47.967]                           if (inherits(master, c("SOCKnode", 
[10:24:47.967]                             "SOCK0node"))) {
[10:24:47.967]                             sendCondition <<- function(cond) {
[10:24:47.967]                               data <- list(type = "VALUE", value = cond, 
[10:24:47.967]                                 success = TRUE)
[10:24:47.967]                               parallel_sendData(master, data)
[10:24:47.967]                             }
[10:24:47.967]                             return(sendCondition)
[10:24:47.967]                           }
[10:24:47.967]                         }
[10:24:47.967]                         frame <- frame + 1L
[10:24:47.967]                         envir <- sys.frame(frame)
[10:24:47.967]                       }
[10:24:47.967]                     }
[10:24:47.967]                     sendCondition <<- function(cond) NULL
[10:24:47.967]                   }
[10:24:47.967]                 })
[10:24:47.967]                 withCallingHandlers({
[10:24:47.967]                   {
[10:24:47.967]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:47.967]                     if (!identical(...future.globals.maxSize.org, 
[10:24:47.967]                       ...future.globals.maxSize)) {
[10:24:47.967]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:47.967]                       on.exit(options(oopts), add = TRUE)
[10:24:47.967]                     }
[10:24:47.967]                     {
[10:24:47.967]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:47.967]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:24:47.967]                         USE.NAMES = FALSE)
[10:24:47.967]                       do.call(mapply, args = args)
[10:24:47.967]                     }
[10:24:47.967]                   }
[10:24:47.967]                 }, immediateCondition = function(cond) {
[10:24:47.967]                   sendCondition <- ...future.makeSendCondition()
[10:24:47.967]                   sendCondition(cond)
[10:24:47.967]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:47.967]                   {
[10:24:47.967]                     inherits <- base::inherits
[10:24:47.967]                     invokeRestart <- base::invokeRestart
[10:24:47.967]                     is.null <- base::is.null
[10:24:47.967]                     muffled <- FALSE
[10:24:47.967]                     if (inherits(cond, "message")) {
[10:24:47.967]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:47.967]                       if (muffled) 
[10:24:47.967]                         invokeRestart("muffleMessage")
[10:24:47.967]                     }
[10:24:47.967]                     else if (inherits(cond, "warning")) {
[10:24:47.967]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:47.967]                       if (muffled) 
[10:24:47.967]                         invokeRestart("muffleWarning")
[10:24:47.967]                     }
[10:24:47.967]                     else if (inherits(cond, "condition")) {
[10:24:47.967]                       if (!is.null(pattern)) {
[10:24:47.967]                         computeRestarts <- base::computeRestarts
[10:24:47.967]                         grepl <- base::grepl
[10:24:47.967]                         restarts <- computeRestarts(cond)
[10:24:47.967]                         for (restart in restarts) {
[10:24:47.967]                           name <- restart$name
[10:24:47.967]                           if (is.null(name)) 
[10:24:47.967]                             next
[10:24:47.967]                           if (!grepl(pattern, name)) 
[10:24:47.967]                             next
[10:24:47.967]                           invokeRestart(restart)
[10:24:47.967]                           muffled <- TRUE
[10:24:47.967]                           break
[10:24:47.967]                         }
[10:24:47.967]                       }
[10:24:47.967]                     }
[10:24:47.967]                     invisible(muffled)
[10:24:47.967]                   }
[10:24:47.967]                   muffleCondition(cond)
[10:24:47.967]                 })
[10:24:47.967]             }))
[10:24:47.967]             future::FutureResult(value = ...future.value$value, 
[10:24:47.967]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:47.967]                   ...future.rng), globalenv = if (FALSE) 
[10:24:47.967]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:47.967]                     ...future.globalenv.names))
[10:24:47.967]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:47.967]         }, condition = base::local({
[10:24:47.967]             c <- base::c
[10:24:47.967]             inherits <- base::inherits
[10:24:47.967]             invokeRestart <- base::invokeRestart
[10:24:47.967]             length <- base::length
[10:24:47.967]             list <- base::list
[10:24:47.967]             seq.int <- base::seq.int
[10:24:47.967]             signalCondition <- base::signalCondition
[10:24:47.967]             sys.calls <- base::sys.calls
[10:24:47.967]             `[[` <- base::`[[`
[10:24:47.967]             `+` <- base::`+`
[10:24:47.967]             `<<-` <- base::`<<-`
[10:24:47.967]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:47.967]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:47.967]                   3L)]
[10:24:47.967]             }
[10:24:47.967]             function(cond) {
[10:24:47.967]                 is_error <- inherits(cond, "error")
[10:24:47.967]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:47.967]                   NULL)
[10:24:47.967]                 if (is_error) {
[10:24:47.967]                   sessionInformation <- function() {
[10:24:47.967]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:47.967]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:47.967]                       search = base::search(), system = base::Sys.info())
[10:24:47.967]                   }
[10:24:47.967]                   ...future.conditions[[length(...future.conditions) + 
[10:24:47.967]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:47.967]                     cond$call), session = sessionInformation(), 
[10:24:47.967]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:47.967]                   signalCondition(cond)
[10:24:47.967]                 }
[10:24:47.967]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:47.967]                 "immediateCondition"))) {
[10:24:47.967]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:47.967]                   ...future.conditions[[length(...future.conditions) + 
[10:24:47.967]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:47.967]                   if (TRUE && !signal) {
[10:24:47.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:47.967]                     {
[10:24:47.967]                       inherits <- base::inherits
[10:24:47.967]                       invokeRestart <- base::invokeRestart
[10:24:47.967]                       is.null <- base::is.null
[10:24:47.967]                       muffled <- FALSE
[10:24:47.967]                       if (inherits(cond, "message")) {
[10:24:47.967]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:47.967]                         if (muffled) 
[10:24:47.967]                           invokeRestart("muffleMessage")
[10:24:47.967]                       }
[10:24:47.967]                       else if (inherits(cond, "warning")) {
[10:24:47.967]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:47.967]                         if (muffled) 
[10:24:47.967]                           invokeRestart("muffleWarning")
[10:24:47.967]                       }
[10:24:47.967]                       else if (inherits(cond, "condition")) {
[10:24:47.967]                         if (!is.null(pattern)) {
[10:24:47.967]                           computeRestarts <- base::computeRestarts
[10:24:47.967]                           grepl <- base::grepl
[10:24:47.967]                           restarts <- computeRestarts(cond)
[10:24:47.967]                           for (restart in restarts) {
[10:24:47.967]                             name <- restart$name
[10:24:47.967]                             if (is.null(name)) 
[10:24:47.967]                               next
[10:24:47.967]                             if (!grepl(pattern, name)) 
[10:24:47.967]                               next
[10:24:47.967]                             invokeRestart(restart)
[10:24:47.967]                             muffled <- TRUE
[10:24:47.967]                             break
[10:24:47.967]                           }
[10:24:47.967]                         }
[10:24:47.967]                       }
[10:24:47.967]                       invisible(muffled)
[10:24:47.967]                     }
[10:24:47.967]                     muffleCondition(cond, pattern = "^muffle")
[10:24:47.967]                   }
[10:24:47.967]                 }
[10:24:47.967]                 else {
[10:24:47.967]                   if (TRUE) {
[10:24:47.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:47.967]                     {
[10:24:47.967]                       inherits <- base::inherits
[10:24:47.967]                       invokeRestart <- base::invokeRestart
[10:24:47.967]                       is.null <- base::is.null
[10:24:47.967]                       muffled <- FALSE
[10:24:47.967]                       if (inherits(cond, "message")) {
[10:24:47.967]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:47.967]                         if (muffled) 
[10:24:47.967]                           invokeRestart("muffleMessage")
[10:24:47.967]                       }
[10:24:47.967]                       else if (inherits(cond, "warning")) {
[10:24:47.967]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:47.967]                         if (muffled) 
[10:24:47.967]                           invokeRestart("muffleWarning")
[10:24:47.967]                       }
[10:24:47.967]                       else if (inherits(cond, "condition")) {
[10:24:47.967]                         if (!is.null(pattern)) {
[10:24:47.967]                           computeRestarts <- base::computeRestarts
[10:24:47.967]                           grepl <- base::grepl
[10:24:47.967]                           restarts <- computeRestarts(cond)
[10:24:47.967]                           for (restart in restarts) {
[10:24:47.967]                             name <- restart$name
[10:24:47.967]                             if (is.null(name)) 
[10:24:47.967]                               next
[10:24:47.967]                             if (!grepl(pattern, name)) 
[10:24:47.967]                               next
[10:24:47.967]                             invokeRestart(restart)
[10:24:47.967]                             muffled <- TRUE
[10:24:47.967]                             break
[10:24:47.967]                           }
[10:24:47.967]                         }
[10:24:47.967]                       }
[10:24:47.967]                       invisible(muffled)
[10:24:47.967]                     }
[10:24:47.967]                     muffleCondition(cond, pattern = "^muffle")
[10:24:47.967]                   }
[10:24:47.967]                 }
[10:24:47.967]             }
[10:24:47.967]         }))
[10:24:47.967]     }, error = function(ex) {
[10:24:47.967]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:47.967]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:47.967]                 ...future.rng), started = ...future.startTime, 
[10:24:47.967]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:47.967]             version = "1.8"), class = "FutureResult")
[10:24:47.967]     }, finally = {
[10:24:47.967]         if (!identical(...future.workdir, getwd())) 
[10:24:47.967]             setwd(...future.workdir)
[10:24:47.967]         {
[10:24:47.967]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:47.967]                 ...future.oldOptions$nwarnings <- NULL
[10:24:47.967]             }
[10:24:47.967]             base::options(...future.oldOptions)
[10:24:47.967]             if (.Platform$OS.type == "windows") {
[10:24:47.967]                 old_names <- names(...future.oldEnvVars)
[10:24:47.967]                 envs <- base::Sys.getenv()
[10:24:47.967]                 names <- names(envs)
[10:24:47.967]                 common <- intersect(names, old_names)
[10:24:47.967]                 added <- setdiff(names, old_names)
[10:24:47.967]                 removed <- setdiff(old_names, names)
[10:24:47.967]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:47.967]                   envs[common]]
[10:24:47.967]                 NAMES <- toupper(changed)
[10:24:47.967]                 args <- list()
[10:24:47.967]                 for (kk in seq_along(NAMES)) {
[10:24:47.967]                   name <- changed[[kk]]
[10:24:47.967]                   NAME <- NAMES[[kk]]
[10:24:47.967]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:47.967]                     next
[10:24:47.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:47.967]                 }
[10:24:47.967]                 NAMES <- toupper(added)
[10:24:47.967]                 for (kk in seq_along(NAMES)) {
[10:24:47.967]                   name <- added[[kk]]
[10:24:47.967]                   NAME <- NAMES[[kk]]
[10:24:47.967]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:47.967]                     next
[10:24:47.967]                   args[[name]] <- ""
[10:24:47.967]                 }
[10:24:47.967]                 NAMES <- toupper(removed)
[10:24:47.967]                 for (kk in seq_along(NAMES)) {
[10:24:47.967]                   name <- removed[[kk]]
[10:24:47.967]                   NAME <- NAMES[[kk]]
[10:24:47.967]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:47.967]                     next
[10:24:47.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:47.967]                 }
[10:24:47.967]                 if (length(args) > 0) 
[10:24:47.967]                   base::do.call(base::Sys.setenv, args = args)
[10:24:47.967]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:47.967]             }
[10:24:47.967]             else {
[10:24:47.967]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:47.967]             }
[10:24:47.967]             {
[10:24:47.967]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:47.967]                   0L) {
[10:24:47.967]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:47.967]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:47.967]                   base::options(opts)
[10:24:47.967]                 }
[10:24:47.967]                 {
[10:24:47.967]                   {
[10:24:47.967]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:47.967]                     NULL
[10:24:47.967]                   }
[10:24:47.967]                   options(future.plan = NULL)
[10:24:47.967]                   if (is.na(NA_character_)) 
[10:24:47.967]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:47.967]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:47.967]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:47.967]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:47.967]                     envir = parent.frame()) 
[10:24:47.967]                   {
[10:24:47.967]                     if (is.function(workers)) 
[10:24:47.967]                       workers <- workers()
[10:24:47.967]                     workers <- structure(as.integer(workers), 
[10:24:47.967]                       class = class(workers))
[10:24:47.967]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:47.967]                       workers >= 1)
[10:24:47.967]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:47.967]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:47.967]                     }
[10:24:47.967]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:47.967]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:47.967]                       envir = envir)
[10:24:47.967]                     if (!future$lazy) 
[10:24:47.967]                       future <- run(future)
[10:24:47.967]                     invisible(future)
[10:24:47.967]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:47.967]                 }
[10:24:47.967]             }
[10:24:47.967]         }
[10:24:47.967]     })
[10:24:47.967]     if (FALSE) {
[10:24:47.967]         base::sink(type = "output", split = FALSE)
[10:24:47.967]         if (NA) {
[10:24:47.967]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:47.967]         }
[10:24:47.967]         else {
[10:24:47.967]             ...future.result["stdout"] <- base::list(NULL)
[10:24:47.967]         }
[10:24:47.967]         base::close(...future.stdout)
[10:24:47.967]         ...future.stdout <- NULL
[10:24:47.967]     }
[10:24:47.967]     ...future.result$conditions <- ...future.conditions
[10:24:47.967]     ...future.result$finished <- base::Sys.time()
[10:24:47.967]     ...future.result
[10:24:47.967] }
[10:24:47.970] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[10:24:47.970] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[10:24:47.971] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[10:24:47.971] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[10:24:47.971] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[10:24:47.971] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[10:24:47.972] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[10:24:47.972] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:24:47.972] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:24:47.972] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:24:47.972] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:24:47.973] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[10:24:47.973] MultisessionFuture started
[10:24:47.973] - Launch lazy future ... done
[10:24:47.973] run() for ‘MultisessionFuture’ ... done
[10:24:47.973] Created future:
[10:24:47.973] MultisessionFuture:
[10:24:47.973] Label: ‘future_mapply-1’
[10:24:47.973] Expression:
[10:24:47.973] {
[10:24:47.973]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:47.973]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:47.973]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:47.973]         on.exit(options(oopts), add = TRUE)
[10:24:47.973]     }
[10:24:47.973]     {
[10:24:47.973]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:47.973]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:24:47.973]         do.call(mapply, args = args)
[10:24:47.973]     }
[10:24:47.973] }
[10:24:47.973] Lazy evaluation: FALSE
[10:24:47.973] Asynchronous evaluation: TRUE
[10:24:47.973] Local evaluation: TRUE
[10:24:47.973] Environment: R_GlobalEnv
[10:24:47.973] Capture standard output: NA
[10:24:47.973] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:47.973] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:47.973] Packages: <none>
[10:24:47.973] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:47.973] Resolved: FALSE
[10:24:47.973] Value: <not collected>
[10:24:47.973] Conditions captured: <none>
[10:24:47.973] Early signaling: FALSE
[10:24:47.973] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:47.973] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:47.985] Chunk #1 of 2 ... DONE
[10:24:47.985] Chunk #2 of 2 ...
[10:24:47.985]  - Finding globals in '...' for chunk #2 ...
[10:24:47.985] getGlobalsAndPackages() ...
[10:24:47.985] Searching for globals...
[10:24:47.986] 
[10:24:47.986] Searching for globals ... DONE
[10:24:47.986] - globals: [0] <none>
[10:24:47.986] getGlobalsAndPackages() ... DONE
[10:24:47.986]    + additional globals found: [n=0] 
[10:24:47.986]    + additional namespaces needed: [n=0] 
[10:24:47.986]  - Finding globals in '...' for chunk #2 ... DONE
[10:24:47.986]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:24:47.986]  - seeds: <none>
[10:24:47.987]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:47.987] getGlobalsAndPackages() ...
[10:24:47.987] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:47.987] Resolving globals: FALSE
[10:24:47.987] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[10:24:47.988] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:24:47.988] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:24:47.988] 
[10:24:47.988] getGlobalsAndPackages() ... DONE
[10:24:47.988] run() for ‘Future’ ...
[10:24:47.988] - state: ‘created’
[10:24:47.989] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:24:48.002] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:48.002] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:24:48.002]   - Field: ‘node’
[10:24:48.002]   - Field: ‘label’
[10:24:48.003]   - Field: ‘local’
[10:24:48.003]   - Field: ‘owner’
[10:24:48.003]   - Field: ‘envir’
[10:24:48.003]   - Field: ‘workers’
[10:24:48.003]   - Field: ‘packages’
[10:24:48.003]   - Field: ‘gc’
[10:24:48.003]   - Field: ‘conditions’
[10:24:48.003]   - Field: ‘persistent’
[10:24:48.003]   - Field: ‘expr’
[10:24:48.003]   - Field: ‘uuid’
[10:24:48.004]   - Field: ‘seed’
[10:24:48.004]   - Field: ‘version’
[10:24:48.004]   - Field: ‘result’
[10:24:48.004]   - Field: ‘asynchronous’
[10:24:48.004]   - Field: ‘calls’
[10:24:48.004]   - Field: ‘globals’
[10:24:48.004]   - Field: ‘stdout’
[10:24:48.004]   - Field: ‘earlySignal’
[10:24:48.004]   - Field: ‘lazy’
[10:24:48.004]   - Field: ‘state’
[10:24:48.004] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:24:48.005] - Launch lazy future ...
[10:24:48.005] Packages needed by the future expression (n = 0): <none>
[10:24:48.005] Packages needed by future strategies (n = 0): <none>
[10:24:48.005] {
[10:24:48.005]     {
[10:24:48.005]         {
[10:24:48.005]             ...future.startTime <- base::Sys.time()
[10:24:48.005]             {
[10:24:48.005]                 {
[10:24:48.005]                   {
[10:24:48.005]                     {
[10:24:48.005]                       base::local({
[10:24:48.005]                         has_future <- base::requireNamespace("future", 
[10:24:48.005]                           quietly = TRUE)
[10:24:48.005]                         if (has_future) {
[10:24:48.005]                           ns <- base::getNamespace("future")
[10:24:48.005]                           version <- ns[[".package"]][["version"]]
[10:24:48.005]                           if (is.null(version)) 
[10:24:48.005]                             version <- utils::packageVersion("future")
[10:24:48.005]                         }
[10:24:48.005]                         else {
[10:24:48.005]                           version <- NULL
[10:24:48.005]                         }
[10:24:48.005]                         if (!has_future || version < "1.8.0") {
[10:24:48.005]                           info <- base::c(r_version = base::gsub("R version ", 
[10:24:48.005]                             "", base::R.version$version.string), 
[10:24:48.005]                             platform = base::sprintf("%s (%s-bit)", 
[10:24:48.005]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:24:48.005]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:24:48.005]                               "release", "version")], collapse = " "), 
[10:24:48.005]                             hostname = base::Sys.info()[["nodename"]])
[10:24:48.005]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:24:48.005]                             info)
[10:24:48.005]                           info <- base::paste(info, collapse = "; ")
[10:24:48.005]                           if (!has_future) {
[10:24:48.005]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:24:48.005]                               info)
[10:24:48.005]                           }
[10:24:48.005]                           else {
[10:24:48.005]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:24:48.005]                               info, version)
[10:24:48.005]                           }
[10:24:48.005]                           base::stop(msg)
[10:24:48.005]                         }
[10:24:48.005]                       })
[10:24:48.005]                     }
[10:24:48.005]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:24:48.005]                     base::options(mc.cores = 1L)
[10:24:48.005]                   }
[10:24:48.005]                   options(future.plan = NULL)
[10:24:48.005]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:24:48.005]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:24:48.005]                 }
[10:24:48.005]                 ...future.workdir <- getwd()
[10:24:48.005]             }
[10:24:48.005]             ...future.oldOptions <- base::as.list(base::.Options)
[10:24:48.005]             ...future.oldEnvVars <- base::Sys.getenv()
[10:24:48.005]         }
[10:24:48.005]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:24:48.005]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:24:48.005]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:24:48.005]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:24:48.005]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:24:48.005]             future.stdout.windows.reencode = NULL, width = 80L)
[10:24:48.005]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:24:48.005]             base::names(...future.oldOptions))
[10:24:48.005]     }
[10:24:48.005]     if (TRUE) {
[10:24:48.005]     }
[10:24:48.005]     else {
[10:24:48.005]         if (NA) {
[10:24:48.005]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:24:48.005]                 open = "w")
[10:24:48.005]         }
[10:24:48.005]         else {
[10:24:48.005]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:24:48.005]                 windows = "NUL", "/dev/null"), open = "w")
[10:24:48.005]         }
[10:24:48.005]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:24:48.005]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:24:48.005]             base::sink(type = "output", split = FALSE)
[10:24:48.005]             base::close(...future.stdout)
[10:24:48.005]         }, add = TRUE)
[10:24:48.005]     }
[10:24:48.005]     ...future.frame <- base::sys.nframe()
[10:24:48.005]     ...future.conditions <- base::list()
[10:24:48.005]     ...future.rng <- base::globalenv()$.Random.seed
[10:24:48.005]     if (FALSE) {
[10:24:48.005]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:24:48.005]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:24:48.005]     }
[10:24:48.005]     ...future.result <- base::tryCatch({
[10:24:48.005]         base::withCallingHandlers({
[10:24:48.005]             ...future.value <- base::withVisible(base::local({
[10:24:48.005]                 ...future.makeSendCondition <- base::local({
[10:24:48.005]                   sendCondition <- NULL
[10:24:48.005]                   function(frame = 1L) {
[10:24:48.005]                     if (is.function(sendCondition)) 
[10:24:48.005]                       return(sendCondition)
[10:24:48.005]                     ns <- getNamespace("parallel")
[10:24:48.005]                     if (exists("sendData", mode = "function", 
[10:24:48.005]                       envir = ns)) {
[10:24:48.005]                       parallel_sendData <- get("sendData", mode = "function", 
[10:24:48.005]                         envir = ns)
[10:24:48.005]                       envir <- sys.frame(frame)
[10:24:48.005]                       master <- NULL
[10:24:48.005]                       while (!identical(envir, .GlobalEnv) && 
[10:24:48.005]                         !identical(envir, emptyenv())) {
[10:24:48.005]                         if (exists("master", mode = "list", envir = envir, 
[10:24:48.005]                           inherits = FALSE)) {
[10:24:48.005]                           master <- get("master", mode = "list", 
[10:24:48.005]                             envir = envir, inherits = FALSE)
[10:24:48.005]                           if (inherits(master, c("SOCKnode", 
[10:24:48.005]                             "SOCK0node"))) {
[10:24:48.005]                             sendCondition <<- function(cond) {
[10:24:48.005]                               data <- list(type = "VALUE", value = cond, 
[10:24:48.005]                                 success = TRUE)
[10:24:48.005]                               parallel_sendData(master, data)
[10:24:48.005]                             }
[10:24:48.005]                             return(sendCondition)
[10:24:48.005]                           }
[10:24:48.005]                         }
[10:24:48.005]                         frame <- frame + 1L
[10:24:48.005]                         envir <- sys.frame(frame)
[10:24:48.005]                       }
[10:24:48.005]                     }
[10:24:48.005]                     sendCondition <<- function(cond) NULL
[10:24:48.005]                   }
[10:24:48.005]                 })
[10:24:48.005]                 withCallingHandlers({
[10:24:48.005]                   {
[10:24:48.005]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:48.005]                     if (!identical(...future.globals.maxSize.org, 
[10:24:48.005]                       ...future.globals.maxSize)) {
[10:24:48.005]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:48.005]                       on.exit(options(oopts), add = TRUE)
[10:24:48.005]                     }
[10:24:48.005]                     {
[10:24:48.005]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:48.005]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:24:48.005]                         USE.NAMES = FALSE)
[10:24:48.005]                       do.call(mapply, args = args)
[10:24:48.005]                     }
[10:24:48.005]                   }
[10:24:48.005]                 }, immediateCondition = function(cond) {
[10:24:48.005]                   sendCondition <- ...future.makeSendCondition()
[10:24:48.005]                   sendCondition(cond)
[10:24:48.005]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:48.005]                   {
[10:24:48.005]                     inherits <- base::inherits
[10:24:48.005]                     invokeRestart <- base::invokeRestart
[10:24:48.005]                     is.null <- base::is.null
[10:24:48.005]                     muffled <- FALSE
[10:24:48.005]                     if (inherits(cond, "message")) {
[10:24:48.005]                       muffled <- grepl(pattern, "muffleMessage")
[10:24:48.005]                       if (muffled) 
[10:24:48.005]                         invokeRestart("muffleMessage")
[10:24:48.005]                     }
[10:24:48.005]                     else if (inherits(cond, "warning")) {
[10:24:48.005]                       muffled <- grepl(pattern, "muffleWarning")
[10:24:48.005]                       if (muffled) 
[10:24:48.005]                         invokeRestart("muffleWarning")
[10:24:48.005]                     }
[10:24:48.005]                     else if (inherits(cond, "condition")) {
[10:24:48.005]                       if (!is.null(pattern)) {
[10:24:48.005]                         computeRestarts <- base::computeRestarts
[10:24:48.005]                         grepl <- base::grepl
[10:24:48.005]                         restarts <- computeRestarts(cond)
[10:24:48.005]                         for (restart in restarts) {
[10:24:48.005]                           name <- restart$name
[10:24:48.005]                           if (is.null(name)) 
[10:24:48.005]                             next
[10:24:48.005]                           if (!grepl(pattern, name)) 
[10:24:48.005]                             next
[10:24:48.005]                           invokeRestart(restart)
[10:24:48.005]                           muffled <- TRUE
[10:24:48.005]                           break
[10:24:48.005]                         }
[10:24:48.005]                       }
[10:24:48.005]                     }
[10:24:48.005]                     invisible(muffled)
[10:24:48.005]                   }
[10:24:48.005]                   muffleCondition(cond)
[10:24:48.005]                 })
[10:24:48.005]             }))
[10:24:48.005]             future::FutureResult(value = ...future.value$value, 
[10:24:48.005]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:48.005]                   ...future.rng), globalenv = if (FALSE) 
[10:24:48.005]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:24:48.005]                     ...future.globalenv.names))
[10:24:48.005]                 else NULL, started = ...future.startTime, version = "1.8")
[10:24:48.005]         }, condition = base::local({
[10:24:48.005]             c <- base::c
[10:24:48.005]             inherits <- base::inherits
[10:24:48.005]             invokeRestart <- base::invokeRestart
[10:24:48.005]             length <- base::length
[10:24:48.005]             list <- base::list
[10:24:48.005]             seq.int <- base::seq.int
[10:24:48.005]             signalCondition <- base::signalCondition
[10:24:48.005]             sys.calls <- base::sys.calls
[10:24:48.005]             `[[` <- base::`[[`
[10:24:48.005]             `+` <- base::`+`
[10:24:48.005]             `<<-` <- base::`<<-`
[10:24:48.005]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:24:48.005]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:24:48.005]                   3L)]
[10:24:48.005]             }
[10:24:48.005]             function(cond) {
[10:24:48.005]                 is_error <- inherits(cond, "error")
[10:24:48.005]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:24:48.005]                   NULL)
[10:24:48.005]                 if (is_error) {
[10:24:48.005]                   sessionInformation <- function() {
[10:24:48.005]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:24:48.005]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:24:48.005]                       search = base::search(), system = base::Sys.info())
[10:24:48.005]                   }
[10:24:48.005]                   ...future.conditions[[length(...future.conditions) + 
[10:24:48.005]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:24:48.005]                     cond$call), session = sessionInformation(), 
[10:24:48.005]                     timestamp = base::Sys.time(), signaled = 0L)
[10:24:48.005]                   signalCondition(cond)
[10:24:48.005]                 }
[10:24:48.005]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:24:48.005]                 "immediateCondition"))) {
[10:24:48.005]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:24:48.005]                   ...future.conditions[[length(...future.conditions) + 
[10:24:48.005]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:24:48.005]                   if (TRUE && !signal) {
[10:24:48.005]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:48.005]                     {
[10:24:48.005]                       inherits <- base::inherits
[10:24:48.005]                       invokeRestart <- base::invokeRestart
[10:24:48.005]                       is.null <- base::is.null
[10:24:48.005]                       muffled <- FALSE
[10:24:48.005]                       if (inherits(cond, "message")) {
[10:24:48.005]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:48.005]                         if (muffled) 
[10:24:48.005]                           invokeRestart("muffleMessage")
[10:24:48.005]                       }
[10:24:48.005]                       else if (inherits(cond, "warning")) {
[10:24:48.005]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:48.005]                         if (muffled) 
[10:24:48.005]                           invokeRestart("muffleWarning")
[10:24:48.005]                       }
[10:24:48.005]                       else if (inherits(cond, "condition")) {
[10:24:48.005]                         if (!is.null(pattern)) {
[10:24:48.005]                           computeRestarts <- base::computeRestarts
[10:24:48.005]                           grepl <- base::grepl
[10:24:48.005]                           restarts <- computeRestarts(cond)
[10:24:48.005]                           for (restart in restarts) {
[10:24:48.005]                             name <- restart$name
[10:24:48.005]                             if (is.null(name)) 
[10:24:48.005]                               next
[10:24:48.005]                             if (!grepl(pattern, name)) 
[10:24:48.005]                               next
[10:24:48.005]                             invokeRestart(restart)
[10:24:48.005]                             muffled <- TRUE
[10:24:48.005]                             break
[10:24:48.005]                           }
[10:24:48.005]                         }
[10:24:48.005]                       }
[10:24:48.005]                       invisible(muffled)
[10:24:48.005]                     }
[10:24:48.005]                     muffleCondition(cond, pattern = "^muffle")
[10:24:48.005]                   }
[10:24:48.005]                 }
[10:24:48.005]                 else {
[10:24:48.005]                   if (TRUE) {
[10:24:48.005]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:24:48.005]                     {
[10:24:48.005]                       inherits <- base::inherits
[10:24:48.005]                       invokeRestart <- base::invokeRestart
[10:24:48.005]                       is.null <- base::is.null
[10:24:48.005]                       muffled <- FALSE
[10:24:48.005]                       if (inherits(cond, "message")) {
[10:24:48.005]                         muffled <- grepl(pattern, "muffleMessage")
[10:24:48.005]                         if (muffled) 
[10:24:48.005]                           invokeRestart("muffleMessage")
[10:24:48.005]                       }
[10:24:48.005]                       else if (inherits(cond, "warning")) {
[10:24:48.005]                         muffled <- grepl(pattern, "muffleWarning")
[10:24:48.005]                         if (muffled) 
[10:24:48.005]                           invokeRestart("muffleWarning")
[10:24:48.005]                       }
[10:24:48.005]                       else if (inherits(cond, "condition")) {
[10:24:48.005]                         if (!is.null(pattern)) {
[10:24:48.005]                           computeRestarts <- base::computeRestarts
[10:24:48.005]                           grepl <- base::grepl
[10:24:48.005]                           restarts <- computeRestarts(cond)
[10:24:48.005]                           for (restart in restarts) {
[10:24:48.005]                             name <- restart$name
[10:24:48.005]                             if (is.null(name)) 
[10:24:48.005]                               next
[10:24:48.005]                             if (!grepl(pattern, name)) 
[10:24:48.005]                               next
[10:24:48.005]                             invokeRestart(restart)
[10:24:48.005]                             muffled <- TRUE
[10:24:48.005]                             break
[10:24:48.005]                           }
[10:24:48.005]                         }
[10:24:48.005]                       }
[10:24:48.005]                       invisible(muffled)
[10:24:48.005]                     }
[10:24:48.005]                     muffleCondition(cond, pattern = "^muffle")
[10:24:48.005]                   }
[10:24:48.005]                 }
[10:24:48.005]             }
[10:24:48.005]         }))
[10:24:48.005]     }, error = function(ex) {
[10:24:48.005]         base::structure(base::list(value = NULL, visible = NULL, 
[10:24:48.005]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:24:48.005]                 ...future.rng), started = ...future.startTime, 
[10:24:48.005]             finished = Sys.time(), session_uuid = NA_character_, 
[10:24:48.005]             version = "1.8"), class = "FutureResult")
[10:24:48.005]     }, finally = {
[10:24:48.005]         if (!identical(...future.workdir, getwd())) 
[10:24:48.005]             setwd(...future.workdir)
[10:24:48.005]         {
[10:24:48.005]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:24:48.005]                 ...future.oldOptions$nwarnings <- NULL
[10:24:48.005]             }
[10:24:48.005]             base::options(...future.oldOptions)
[10:24:48.005]             if (.Platform$OS.type == "windows") {
[10:24:48.005]                 old_names <- names(...future.oldEnvVars)
[10:24:48.005]                 envs <- base::Sys.getenv()
[10:24:48.005]                 names <- names(envs)
[10:24:48.005]                 common <- intersect(names, old_names)
[10:24:48.005]                 added <- setdiff(names, old_names)
[10:24:48.005]                 removed <- setdiff(old_names, names)
[10:24:48.005]                 changed <- common[...future.oldEnvVars[common] != 
[10:24:48.005]                   envs[common]]
[10:24:48.005]                 NAMES <- toupper(changed)
[10:24:48.005]                 args <- list()
[10:24:48.005]                 for (kk in seq_along(NAMES)) {
[10:24:48.005]                   name <- changed[[kk]]
[10:24:48.005]                   NAME <- NAMES[[kk]]
[10:24:48.005]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:48.005]                     next
[10:24:48.005]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:48.005]                 }
[10:24:48.005]                 NAMES <- toupper(added)
[10:24:48.005]                 for (kk in seq_along(NAMES)) {
[10:24:48.005]                   name <- added[[kk]]
[10:24:48.005]                   NAME <- NAMES[[kk]]
[10:24:48.005]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:48.005]                     next
[10:24:48.005]                   args[[name]] <- ""
[10:24:48.005]                 }
[10:24:48.005]                 NAMES <- toupper(removed)
[10:24:48.005]                 for (kk in seq_along(NAMES)) {
[10:24:48.005]                   name <- removed[[kk]]
[10:24:48.005]                   NAME <- NAMES[[kk]]
[10:24:48.005]                   if (name != NAME && is.element(NAME, old_names)) 
[10:24:48.005]                     next
[10:24:48.005]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:24:48.005]                 }
[10:24:48.005]                 if (length(args) > 0) 
[10:24:48.005]                   base::do.call(base::Sys.setenv, args = args)
[10:24:48.005]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:24:48.005]             }
[10:24:48.005]             else {
[10:24:48.005]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:24:48.005]             }
[10:24:48.005]             {
[10:24:48.005]                 if (base::length(...future.futureOptionsAdded) > 
[10:24:48.005]                   0L) {
[10:24:48.005]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:24:48.005]                   base::names(opts) <- ...future.futureOptionsAdded
[10:24:48.005]                   base::options(opts)
[10:24:48.005]                 }
[10:24:48.005]                 {
[10:24:48.005]                   {
[10:24:48.005]                     base::options(mc.cores = ...future.mc.cores.old)
[10:24:48.005]                     NULL
[10:24:48.005]                   }
[10:24:48.005]                   options(future.plan = NULL)
[10:24:48.005]                   if (is.na(NA_character_)) 
[10:24:48.005]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:24:48.005]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:24:48.005]                   future::plan(list(function (..., workers = availableCores(), 
[10:24:48.005]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:24:48.005]                     envir = parent.frame()) 
[10:24:48.005]                   {
[10:24:48.005]                     if (is.function(workers)) 
[10:24:48.005]                       workers <- workers()
[10:24:48.005]                     workers <- structure(as.integer(workers), 
[10:24:48.005]                       class = class(workers))
[10:24:48.005]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:24:48.005]                       workers >= 1)
[10:24:48.005]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:24:48.005]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:24:48.005]                     }
[10:24:48.005]                     future <- MultisessionFuture(..., workers = workers, 
[10:24:48.005]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:24:48.005]                       envir = envir)
[10:24:48.005]                     if (!future$lazy) 
[10:24:48.005]                       future <- run(future)
[10:24:48.005]                     invisible(future)
[10:24:48.005]                   }), .cleanup = FALSE, .init = FALSE)
[10:24:48.005]                 }
[10:24:48.005]             }
[10:24:48.005]         }
[10:24:48.005]     })
[10:24:48.005]     if (FALSE) {
[10:24:48.005]         base::sink(type = "output", split = FALSE)
[10:24:48.005]         if (NA) {
[10:24:48.005]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:24:48.005]         }
[10:24:48.005]         else {
[10:24:48.005]             ...future.result["stdout"] <- base::list(NULL)
[10:24:48.005]         }
[10:24:48.005]         base::close(...future.stdout)
[10:24:48.005]         ...future.stdout <- NULL
[10:24:48.005]     }
[10:24:48.005]     ...future.result$conditions <- ...future.conditions
[10:24:48.005]     ...future.result$finished <- base::Sys.time()
[10:24:48.005]     ...future.result
[10:24:48.005] }
[10:24:48.008] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[10:24:48.008] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[10:24:48.009] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[10:24:48.009] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[10:24:48.009] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[10:24:48.009] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[10:24:48.010] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[10:24:48.010] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:24:48.010] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:24:48.010] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:24:48.011] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:24:48.011] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[10:24:48.011] MultisessionFuture started
[10:24:48.012] - Launch lazy future ... done
[10:24:48.012] run() for ‘MultisessionFuture’ ... done
[10:24:48.012] Created future:
[10:24:48.012] MultisessionFuture:
[10:24:48.012] Label: ‘future_mapply-2’
[10:24:48.012] Expression:
[10:24:48.012] {
[10:24:48.012]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:24:48.012]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:24:48.012]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:24:48.012]         on.exit(options(oopts), add = TRUE)
[10:24:48.012]     }
[10:24:48.012]     {
[10:24:48.012]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:24:48.012]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:24:48.012]         do.call(mapply, args = args)
[10:24:48.012]     }
[10:24:48.012] }
[10:24:48.012] Lazy evaluation: FALSE
[10:24:48.012] Asynchronous evaluation: TRUE
[10:24:48.012] Local evaluation: TRUE
[10:24:48.012] Environment: R_GlobalEnv
[10:24:48.012] Capture standard output: NA
[10:24:48.012] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:24:48.012] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:24:48.012] Packages: <none>
[10:24:48.012] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:24:48.012] Resolved: FALSE
[10:24:48.012] Value: <not collected>
[10:24:48.012] Conditions captured: <none>
[10:24:48.012] Early signaling: FALSE
[10:24:48.012] Owner process: 1a4f1699-2e1b-49b0-6d37-b9dd70f8b7f6
[10:24:48.012] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:24:48.023] Chunk #2 of 2 ... DONE
[10:24:48.023] Launching 2 futures (chunks) ... DONE
[10:24:48.023] Resolving 2 futures (chunks) ...
[10:24:48.024] resolve() on list ...
[10:24:48.024]  recursive: 0
[10:24:48.024]  length: 2
[10:24:48.024] 
[10:24:48.066] receiveMessageFromWorker() for ClusterFuture ...
[10:24:48.066] - Validating connection of MultisessionFuture
[10:24:48.066] - received message: FutureResult
[10:24:48.067] - Received FutureResult
[10:24:48.067] - Erased future from FutureRegistry
[10:24:48.067] result() for ClusterFuture ...
[10:24:48.067] - result already collected: FutureResult
[10:24:48.067] result() for ClusterFuture ... done
[10:24:48.067] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:48.067] Future #2
[10:24:48.067] result() for ClusterFuture ...
[10:24:48.067] - result already collected: FutureResult
[10:24:48.067] result() for ClusterFuture ... done
[10:24:48.068] result() for ClusterFuture ...
[10:24:48.068] - result already collected: FutureResult
[10:24:48.068] result() for ClusterFuture ... done
[10:24:48.068] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:24:48.068] - nx: 2
[10:24:48.068] - relay: TRUE
[10:24:48.068] - stdout: TRUE
[10:24:48.068] - signal: TRUE
[10:24:48.068] - resignal: FALSE
[10:24:48.068] - force: TRUE
[10:24:48.068] - relayed: [n=2] FALSE, FALSE
[10:24:48.069] - queued futures: [n=2] FALSE, FALSE
[10:24:48.069]  - until=1
[10:24:48.069]  - relaying element #1
[10:24:48.069] - relayed: [n=2] FALSE, FALSE
[10:24:48.069] - queued futures: [n=2] FALSE, TRUE
[10:24:48.069] signalConditionsASAP(NULL, pos=2) ... done
[10:24:48.069]  length: 1 (resolved future 2)
[10:24:48.519] receiveMessageFromWorker() for ClusterFuture ...
[10:24:48.519] - Validating connection of MultisessionFuture
[10:24:48.520] - received message: FutureResult
[10:24:48.520] - Received FutureResult
[10:24:48.520] - Erased future from FutureRegistry
[10:24:48.520] result() for ClusterFuture ...
[10:24:48.520] - result already collected: FutureResult
[10:24:48.520] result() for ClusterFuture ... done
[10:24:48.520] receiveMessageFromWorker() for ClusterFuture ... done
[10:24:48.520] Future #1
[10:24:48.520] result() for ClusterFuture ...
[10:24:48.521] - result already collected: FutureResult
[10:24:48.521] result() for ClusterFuture ... done
[10:24:48.521] result() for ClusterFuture ...
[10:24:48.521] - result already collected: FutureResult
[10:24:48.521] result() for ClusterFuture ... done
[10:24:48.521] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:24:48.521] - nx: 2
[10:24:48.521] - relay: TRUE
[10:24:48.521] - stdout: TRUE
[10:24:48.521] - signal: TRUE
[10:24:48.521] - resignal: FALSE
[10:24:48.522] - force: TRUE
[10:24:48.522] - relayed: [n=2] FALSE, FALSE
[10:24:48.522] - queued futures: [n=2] FALSE, TRUE
[10:24:48.522]  - until=1
[10:24:48.522]  - relaying element #1
[10:24:48.522] result() for ClusterFuture ...
[10:24:48.522] - result already collected: FutureResult
[10:24:48.522] result() for ClusterFuture ... done
[10:24:48.522] result() for ClusterFuture ...
[10:24:48.522] - result already collected: FutureResult
[10:24:48.522] result() for ClusterFuture ... done
[10:24:48.523] result() for ClusterFuture ...
[10:24:48.523] - result already collected: FutureResult
[10:24:48.523] result() for ClusterFuture ... done
[10:24:48.523] result() for ClusterFuture ...
[10:24:48.523] - result already collected: FutureResult
[10:24:48.523] result() for ClusterFuture ... done
[10:24:48.523] - relayed: [n=2] TRUE, FALSE
[10:24:48.523] - queued futures: [n=2] TRUE, TRUE
[10:24:48.523] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:24:48.523]  length: 0 (resolved future 1)
[10:24:48.523] Relaying remaining futures
[10:24:48.523] signalConditionsASAP(NULL, pos=0) ...
[10:24:48.524] - nx: 2
[10:24:48.524] - relay: TRUE
[10:24:48.524] - stdout: TRUE
[10:24:48.524] - signal: TRUE
[10:24:48.524] - resignal: FALSE
[10:24:48.524] - force: TRUE
[10:24:48.524] - relayed: [n=2] TRUE, FALSE
[10:24:48.524] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:24:48.524]  - relaying element #2
[10:24:48.524] result() for ClusterFuture ...
[10:24:48.524] - result already collected: FutureResult
[10:24:48.525] result() for ClusterFuture ... done
[10:24:48.525] result() for ClusterFuture ...
[10:24:48.525] - result already collected: FutureResult
[10:24:48.525] result() for ClusterFuture ... done
[10:24:48.525] result() for ClusterFuture ...
[10:24:48.525] - result already collected: FutureResult
[10:24:48.525] result() for ClusterFuture ... done
[10:24:48.525] result() for ClusterFuture ...
[10:24:48.525] - result already collected: FutureResult
[10:24:48.525] result() for ClusterFuture ... done
[10:24:48.525] - relayed: [n=2] TRUE, TRUE
[10:24:48.526] - queued futures: [n=2] TRUE, TRUE
[10:24:48.526] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[10:24:48.526] resolve() on list ... DONE
[10:24:48.526] result() for ClusterFuture ...
[10:24:48.526] - result already collected: FutureResult
[10:24:48.526] result() for ClusterFuture ... done
[10:24:48.526] result() for ClusterFuture ...
[10:24:48.526] - result already collected: FutureResult
[10:24:48.526] result() for ClusterFuture ... done
[10:24:48.526] result() for ClusterFuture ...
[10:24:48.526] - result already collected: FutureResult
[10:24:48.527] result() for ClusterFuture ... done
[10:24:48.527] result() for ClusterFuture ...
[10:24:48.527] - result already collected: FutureResult
[10:24:48.527] result() for ClusterFuture ... done
[10:24:48.527]  - Number of value chunks collected: 2
[10:24:48.527] Resolving 2 futures (chunks) ... DONE
[10:24:48.527] Reducing values from 2 chunks ...
[10:24:48.527]  - Number of values collected after concatenation: 2
[10:24:48.527]  - Number of values expected: 2
[10:24:48.527] Reducing values from 2 chunks ... DONE
[10:24:48.527] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 2 cores ... DONE
> 
> message("*** future_*apply() and 'future.stdout' ... DONE")
*** future_*apply() and 'future.stdout' ... DONE
> 
> source("incl/end.R")
[10:24:48.528] plan(): Setting new future strategy stack:
[10:24:48.528] List of future strategies:
[10:24:48.528] 1. FutureStrategy:
[10:24:48.528]    - args: function (..., envir = parent.frame())
[10:24:48.528]    - tweaked: FALSE
[10:24:48.528]    - call: future::plan(oplan)
[10:24:48.529] plan(): nbrOfWorkers() = 1
> 
