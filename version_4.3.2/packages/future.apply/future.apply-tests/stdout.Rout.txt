
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[16:03:27.205] plan(): Setting new future strategy stack:
[16:03:27.205] List of future strategies:
[16:03:27.205] 1. sequential:
[16:03:27.205]    - args: function (..., envir = parent.frame())
[16:03:27.205]    - tweaked: FALSE
[16:03:27.205]    - call: future::plan("sequential")
[16:03:27.219] plan(): nbrOfWorkers() = 1
> 
> message("*** future_*apply() and 'future.stdout' ...")
*** future_*apply() and 'future.stdout' ...
> 
> options(future.debug = TRUE)
> 
> truth <- list()
> 
> out <- utils::capture.output({
+   y <- lapply(1:0, FUN = function(x) {
+     print(x)
+   })
+ })
> truth[["lapply"]] <- list(value = y, stdout = out)
> 
> out <- utils::capture.output({
+   y <- mapply(1:0, 0:1, FUN = function(x, y) {
+     print(list(x = x, y = y))
+   })
+ })
> truth[["mapply"]] <- list(value = y, stdout = out)
> 
> for (cores in 1:availCores) {
+   message(sprintf("  - Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+   
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("* plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     for (fun in names(truth)) {
+       for (stdout in c(FALSE, TRUE, NA)) {
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ...", fun, stdout))
+   
+         out <- utils::capture.output({
+           if (fun == "lapply") {
+             y <- future_lapply(1:0, FUN = function(x) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+ 	      print(x)
+             }, future.stdout = stdout)
+ 	  } else if (fun == "mapply") {
+             y <- future_mapply(1:0, 0:1, FUN = function(x, y) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+               print(list(x = x, y = y))
+             }, future.stdout = stdout)
+ 	  }
+         })
+         stopifnot(identical(y, truth[[fun]]$value))
+   
+         if (isTRUE(stdout)) {
+           stopifnot(identical(out, truth[[fun]]$stdout))
+         } else if (is.na(stdout)) {
+         } else {
+           stopifnot(nchar(out) == 0)
+         }
+       
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ... DONE", fun, stdout))
+       } ## for (stdout ...)
+     } ## for (fun ...)
+     
+     message(sprintf("* plan('%s') ... DONE", strategy))
+   }
+   
+   message(sprintf("  - Testing with %d cores ... DONE", cores))
+ }
  - Testing with 1 cores ...
* plan('sequential') ...
[16:03:27.252] plan(): Setting new future strategy stack:
[16:03:27.252] List of future strategies:
[16:03:27.252] 1. sequential:
[16:03:27.252]    - args: function (..., envir = parent.frame())
[16:03:27.252]    - tweaked: FALSE
[16:03:27.252]    - call: plan(strategy)
[16:03:27.262] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[16:03:27.263] future_lapply() ...
[16:03:27.267] Number of chunks: 1
[16:03:27.268] getGlobalsAndPackagesXApply() ...
[16:03:27.268]  - future.globals: TRUE
[16:03:27.268] getGlobalsAndPackages() ...
[16:03:27.268] Searching for globals...
[16:03:27.271] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:03:27.271] Searching for globals ... DONE
[16:03:27.271] Resolving globals: FALSE
[16:03:27.272] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:03:27.273] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:03:27.273] - globals: [1] ‘FUN’
[16:03:27.273] 
[16:03:27.273] getGlobalsAndPackages() ... DONE
[16:03:27.273]  - globals found/used: [n=1] ‘FUN’
[16:03:27.273]  - needed namespaces: [n=0] 
[16:03:27.273] Finding globals ... DONE
[16:03:27.273]  - use_args: TRUE
[16:03:27.273]  - Getting '...' globals ...
[16:03:27.274] resolve() on list ...
[16:03:27.274]  recursive: 0
[16:03:27.275]  length: 1
[16:03:27.275]  elements: ‘...’
[16:03:27.275]  length: 0 (resolved future 1)
[16:03:27.275] resolve() on list ... DONE
[16:03:27.275]    - '...' content: [n=0] 
[16:03:27.275] List of 1
[16:03:27.275]  $ ...: list()
[16:03:27.275]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:27.275]  - attr(*, "where")=List of 1
[16:03:27.275]   ..$ ...:<environment: 0x55ed7a706ce8> 
[16:03:27.275]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:27.275]  - attr(*, "resolved")= logi TRUE
[16:03:27.275]  - attr(*, "total_size")= num NA
[16:03:27.282]  - Getting '...' globals ... DONE
[16:03:27.282] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:03:27.282] List of 2
[16:03:27.282]  $ ...future.FUN:function (x)  
[16:03:27.282]  $ ...          : list()
[16:03:27.282]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:27.282]  - attr(*, "where")=List of 2
[16:03:27.282]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:27.282]   ..$ ...          :<environment: 0x55ed7a706ce8> 
[16:03:27.282]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:27.282]  - attr(*, "resolved")= logi FALSE
[16:03:27.282]  - attr(*, "total_size")= num 4720
[16:03:27.285] Packages to be attached in all futures: [n=0] 
[16:03:27.285] getGlobalsAndPackagesXApply() ... DONE
[16:03:27.285] Number of futures (= number of chunks): 1
[16:03:27.285] Launching 1 futures (chunks) ...
[16:03:27.285] Chunk #1 of 1 ...
[16:03:27.285]  - Finding globals in 'X' for chunk #1 ...
[16:03:27.286] getGlobalsAndPackages() ...
[16:03:27.286] Searching for globals...
[16:03:27.286] 
[16:03:27.286] Searching for globals ... DONE
[16:03:27.286] - globals: [0] <none>
[16:03:27.286] getGlobalsAndPackages() ... DONE
[16:03:27.286]    + additional globals found: [n=0] 
[16:03:27.286]    + additional namespaces needed: [n=0] 
[16:03:27.286]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:27.287]  - seeds: <none>
[16:03:27.287]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:27.287] getGlobalsAndPackages() ...
[16:03:27.287] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:27.287] Resolving globals: FALSE
[16:03:27.287] Tweak future expression to call with '...' arguments ...
[16:03:27.287] {
[16:03:27.287]     do.call(function(...) {
[16:03:27.287]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:27.287]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:27.287]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:27.287]             on.exit(options(oopts), add = TRUE)
[16:03:27.287]         }
[16:03:27.287]         {
[16:03:27.287]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:27.287]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:27.287]                 ...future.FUN(...future.X_jj, ...)
[16:03:27.287]             })
[16:03:27.287]         }
[16:03:27.287]     }, args = future.call.arguments)
[16:03:27.287] }
[16:03:27.288] Tweak future expression to call with '...' arguments ... DONE
[16:03:27.288] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:27.288] 
[16:03:27.288] getGlobalsAndPackages() ... DONE
[16:03:27.289] run() for ‘Future’ ...
[16:03:27.289] - state: ‘created’
[16:03:27.289] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:03:27.289] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:27.290] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:27.290]   - Field: ‘label’
[16:03:27.290]   - Field: ‘local’
[16:03:27.290]   - Field: ‘owner’
[16:03:27.290]   - Field: ‘envir’
[16:03:27.290]   - Field: ‘packages’
[16:03:27.290]   - Field: ‘gc’
[16:03:27.290]   - Field: ‘conditions’
[16:03:27.290]   - Field: ‘expr’
[16:03:27.290]   - Field: ‘uuid’
[16:03:27.290]   - Field: ‘seed’
[16:03:27.291]   - Field: ‘version’
[16:03:27.291]   - Field: ‘result’
[16:03:27.291]   - Field: ‘asynchronous’
[16:03:27.291]   - Field: ‘calls’
[16:03:27.291]   - Field: ‘globals’
[16:03:27.291]   - Field: ‘stdout’
[16:03:27.291]   - Field: ‘earlySignal’
[16:03:27.291]   - Field: ‘lazy’
[16:03:27.291]   - Field: ‘state’
[16:03:27.291] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:27.291] - Launch lazy future ...
[16:03:27.292] Packages needed by the future expression (n = 0): <none>
[16:03:27.292] Packages needed by future strategies (n = 0): <none>
[16:03:27.293] {
[16:03:27.293]     {
[16:03:27.293]         {
[16:03:27.293]             ...future.startTime <- base::Sys.time()
[16:03:27.293]             {
[16:03:27.293]                 {
[16:03:27.293]                   {
[16:03:27.293]                     base::local({
[16:03:27.293]                       has_future <- base::requireNamespace("future", 
[16:03:27.293]                         quietly = TRUE)
[16:03:27.293]                       if (has_future) {
[16:03:27.293]                         ns <- base::getNamespace("future")
[16:03:27.293]                         version <- ns[[".package"]][["version"]]
[16:03:27.293]                         if (is.null(version)) 
[16:03:27.293]                           version <- utils::packageVersion("future")
[16:03:27.293]                       }
[16:03:27.293]                       else {
[16:03:27.293]                         version <- NULL
[16:03:27.293]                       }
[16:03:27.293]                       if (!has_future || version < "1.8.0") {
[16:03:27.293]                         info <- base::c(r_version = base::gsub("R version ", 
[16:03:27.293]                           "", base::R.version$version.string), 
[16:03:27.293]                           platform = base::sprintf("%s (%s-bit)", 
[16:03:27.293]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:27.293]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:27.293]                             "release", "version")], collapse = " "), 
[16:03:27.293]                           hostname = base::Sys.info()[["nodename"]])
[16:03:27.293]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:03:27.293]                           info)
[16:03:27.293]                         info <- base::paste(info, collapse = "; ")
[16:03:27.293]                         if (!has_future) {
[16:03:27.293]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:27.293]                             info)
[16:03:27.293]                         }
[16:03:27.293]                         else {
[16:03:27.293]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:27.293]                             info, version)
[16:03:27.293]                         }
[16:03:27.293]                         base::stop(msg)
[16:03:27.293]                       }
[16:03:27.293]                     })
[16:03:27.293]                   }
[16:03:27.293]                   options(future.plan = NULL)
[16:03:27.293]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:27.293]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:27.293]                 }
[16:03:27.293]                 ...future.workdir <- getwd()
[16:03:27.293]             }
[16:03:27.293]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:27.293]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:27.293]         }
[16:03:27.293]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:27.293]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:27.293]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:27.293]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:27.293]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:27.293]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:27.293]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:27.293]             base::names(...future.oldOptions))
[16:03:27.293]     }
[16:03:27.293]     if (FALSE) {
[16:03:27.293]     }
[16:03:27.293]     else {
[16:03:27.293]         if (FALSE) {
[16:03:27.293]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:27.293]                 open = "w")
[16:03:27.293]         }
[16:03:27.293]         else {
[16:03:27.293]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:27.293]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:27.293]         }
[16:03:27.293]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:27.293]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:27.293]             base::sink(type = "output", split = FALSE)
[16:03:27.293]             base::close(...future.stdout)
[16:03:27.293]         }, add = TRUE)
[16:03:27.293]     }
[16:03:27.293]     ...future.frame <- base::sys.nframe()
[16:03:27.293]     ...future.conditions <- base::list()
[16:03:27.293]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:27.293]     if (FALSE) {
[16:03:27.293]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:27.293]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:27.293]     }
[16:03:27.293]     ...future.result <- base::tryCatch({
[16:03:27.293]         base::withCallingHandlers({
[16:03:27.293]             ...future.value <- base::withVisible(base::local({
[16:03:27.293]                 do.call(function(...) {
[16:03:27.293]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:27.293]                   if (!identical(...future.globals.maxSize.org, 
[16:03:27.293]                     ...future.globals.maxSize)) {
[16:03:27.293]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:27.293]                     on.exit(options(oopts), add = TRUE)
[16:03:27.293]                   }
[16:03:27.293]                   {
[16:03:27.293]                     lapply(seq_along(...future.elements_ii), 
[16:03:27.293]                       FUN = function(jj) {
[16:03:27.293]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:27.293]                         ...future.FUN(...future.X_jj, ...)
[16:03:27.293]                       })
[16:03:27.293]                   }
[16:03:27.293]                 }, args = future.call.arguments)
[16:03:27.293]             }))
[16:03:27.293]             future::FutureResult(value = ...future.value$value, 
[16:03:27.293]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:27.293]                   ...future.rng), globalenv = if (FALSE) 
[16:03:27.293]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:27.293]                     ...future.globalenv.names))
[16:03:27.293]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:27.293]         }, condition = base::local({
[16:03:27.293]             c <- base::c
[16:03:27.293]             inherits <- base::inherits
[16:03:27.293]             invokeRestart <- base::invokeRestart
[16:03:27.293]             length <- base::length
[16:03:27.293]             list <- base::list
[16:03:27.293]             seq.int <- base::seq.int
[16:03:27.293]             signalCondition <- base::signalCondition
[16:03:27.293]             sys.calls <- base::sys.calls
[16:03:27.293]             `[[` <- base::`[[`
[16:03:27.293]             `+` <- base::`+`
[16:03:27.293]             `<<-` <- base::`<<-`
[16:03:27.293]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:27.293]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:27.293]                   3L)]
[16:03:27.293]             }
[16:03:27.293]             function(cond) {
[16:03:27.293]                 is_error <- inherits(cond, "error")
[16:03:27.293]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:27.293]                   NULL)
[16:03:27.293]                 if (is_error) {
[16:03:27.293]                   sessionInformation <- function() {
[16:03:27.293]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:27.293]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:27.293]                       search = base::search(), system = base::Sys.info())
[16:03:27.293]                   }
[16:03:27.293]                   ...future.conditions[[length(...future.conditions) + 
[16:03:27.293]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:27.293]                     cond$call), session = sessionInformation(), 
[16:03:27.293]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:27.293]                   signalCondition(cond)
[16:03:27.293]                 }
[16:03:27.293]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:27.293]                 "immediateCondition"))) {
[16:03:27.293]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:27.293]                   ...future.conditions[[length(...future.conditions) + 
[16:03:27.293]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:27.293]                   if (TRUE && !signal) {
[16:03:27.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:27.293]                     {
[16:03:27.293]                       inherits <- base::inherits
[16:03:27.293]                       invokeRestart <- base::invokeRestart
[16:03:27.293]                       is.null <- base::is.null
[16:03:27.293]                       muffled <- FALSE
[16:03:27.293]                       if (inherits(cond, "message")) {
[16:03:27.293]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:27.293]                         if (muffled) 
[16:03:27.293]                           invokeRestart("muffleMessage")
[16:03:27.293]                       }
[16:03:27.293]                       else if (inherits(cond, "warning")) {
[16:03:27.293]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:27.293]                         if (muffled) 
[16:03:27.293]                           invokeRestart("muffleWarning")
[16:03:27.293]                       }
[16:03:27.293]                       else if (inherits(cond, "condition")) {
[16:03:27.293]                         if (!is.null(pattern)) {
[16:03:27.293]                           computeRestarts <- base::computeRestarts
[16:03:27.293]                           grepl <- base::grepl
[16:03:27.293]                           restarts <- computeRestarts(cond)
[16:03:27.293]                           for (restart in restarts) {
[16:03:27.293]                             name <- restart$name
[16:03:27.293]                             if (is.null(name)) 
[16:03:27.293]                               next
[16:03:27.293]                             if (!grepl(pattern, name)) 
[16:03:27.293]                               next
[16:03:27.293]                             invokeRestart(restart)
[16:03:27.293]                             muffled <- TRUE
[16:03:27.293]                             break
[16:03:27.293]                           }
[16:03:27.293]                         }
[16:03:27.293]                       }
[16:03:27.293]                       invisible(muffled)
[16:03:27.293]                     }
[16:03:27.293]                     muffleCondition(cond, pattern = "^muffle")
[16:03:27.293]                   }
[16:03:27.293]                 }
[16:03:27.293]                 else {
[16:03:27.293]                   if (TRUE) {
[16:03:27.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:27.293]                     {
[16:03:27.293]                       inherits <- base::inherits
[16:03:27.293]                       invokeRestart <- base::invokeRestart
[16:03:27.293]                       is.null <- base::is.null
[16:03:27.293]                       muffled <- FALSE
[16:03:27.293]                       if (inherits(cond, "message")) {
[16:03:27.293]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:27.293]                         if (muffled) 
[16:03:27.293]                           invokeRestart("muffleMessage")
[16:03:27.293]                       }
[16:03:27.293]                       else if (inherits(cond, "warning")) {
[16:03:27.293]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:27.293]                         if (muffled) 
[16:03:27.293]                           invokeRestart("muffleWarning")
[16:03:27.293]                       }
[16:03:27.293]                       else if (inherits(cond, "condition")) {
[16:03:27.293]                         if (!is.null(pattern)) {
[16:03:27.293]                           computeRestarts <- base::computeRestarts
[16:03:27.293]                           grepl <- base::grepl
[16:03:27.293]                           restarts <- computeRestarts(cond)
[16:03:27.293]                           for (restart in restarts) {
[16:03:27.293]                             name <- restart$name
[16:03:27.293]                             if (is.null(name)) 
[16:03:27.293]                               next
[16:03:27.293]                             if (!grepl(pattern, name)) 
[16:03:27.293]                               next
[16:03:27.293]                             invokeRestart(restart)
[16:03:27.293]                             muffled <- TRUE
[16:03:27.293]                             break
[16:03:27.293]                           }
[16:03:27.293]                         }
[16:03:27.293]                       }
[16:03:27.293]                       invisible(muffled)
[16:03:27.293]                     }
[16:03:27.293]                     muffleCondition(cond, pattern = "^muffle")
[16:03:27.293]                   }
[16:03:27.293]                 }
[16:03:27.293]             }
[16:03:27.293]         }))
[16:03:27.293]     }, error = function(ex) {
[16:03:27.293]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:27.293]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:27.293]                 ...future.rng), started = ...future.startTime, 
[16:03:27.293]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:27.293]             version = "1.8"), class = "FutureResult")
[16:03:27.293]     }, finally = {
[16:03:27.293]         if (!identical(...future.workdir, getwd())) 
[16:03:27.293]             setwd(...future.workdir)
[16:03:27.293]         {
[16:03:27.293]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:27.293]                 ...future.oldOptions$nwarnings <- NULL
[16:03:27.293]             }
[16:03:27.293]             base::options(...future.oldOptions)
[16:03:27.293]             if (.Platform$OS.type == "windows") {
[16:03:27.293]                 old_names <- names(...future.oldEnvVars)
[16:03:27.293]                 envs <- base::Sys.getenv()
[16:03:27.293]                 names <- names(envs)
[16:03:27.293]                 common <- intersect(names, old_names)
[16:03:27.293]                 added <- setdiff(names, old_names)
[16:03:27.293]                 removed <- setdiff(old_names, names)
[16:03:27.293]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:27.293]                   envs[common]]
[16:03:27.293]                 NAMES <- toupper(changed)
[16:03:27.293]                 args <- list()
[16:03:27.293]                 for (kk in seq_along(NAMES)) {
[16:03:27.293]                   name <- changed[[kk]]
[16:03:27.293]                   NAME <- NAMES[[kk]]
[16:03:27.293]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:27.293]                     next
[16:03:27.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:27.293]                 }
[16:03:27.293]                 NAMES <- toupper(added)
[16:03:27.293]                 for (kk in seq_along(NAMES)) {
[16:03:27.293]                   name <- added[[kk]]
[16:03:27.293]                   NAME <- NAMES[[kk]]
[16:03:27.293]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:27.293]                     next
[16:03:27.293]                   args[[name]] <- ""
[16:03:27.293]                 }
[16:03:27.293]                 NAMES <- toupper(removed)
[16:03:27.293]                 for (kk in seq_along(NAMES)) {
[16:03:27.293]                   name <- removed[[kk]]
[16:03:27.293]                   NAME <- NAMES[[kk]]
[16:03:27.293]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:27.293]                     next
[16:03:27.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:27.293]                 }
[16:03:27.293]                 if (length(args) > 0) 
[16:03:27.293]                   base::do.call(base::Sys.setenv, args = args)
[16:03:27.293]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:27.293]             }
[16:03:27.293]             else {
[16:03:27.293]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:27.293]             }
[16:03:27.293]             {
[16:03:27.293]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:27.293]                   0L) {
[16:03:27.293]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:27.293]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:27.293]                   base::options(opts)
[16:03:27.293]                 }
[16:03:27.293]                 {
[16:03:27.293]                   {
[16:03:27.293]                     NULL
[16:03:27.293]                     RNGkind("Mersenne-Twister")
[16:03:27.293]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:27.293]                       inherits = FALSE)
[16:03:27.293]                   }
[16:03:27.293]                   options(future.plan = NULL)
[16:03:27.293]                   if (is.na(NA_character_)) 
[16:03:27.293]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:27.293]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:27.293]                   future::plan(list(function (..., envir = parent.frame()) 
[16:03:27.293]                   {
[16:03:27.293]                     future <- SequentialFuture(..., envir = envir)
[16:03:27.293]                     if (!future$lazy) 
[16:03:27.293]                       future <- run(future)
[16:03:27.293]                     invisible(future)
[16:03:27.293]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:27.293]                 }
[16:03:27.293]             }
[16:03:27.293]         }
[16:03:27.293]     })
[16:03:27.293]     if (TRUE) {
[16:03:27.293]         base::sink(type = "output", split = FALSE)
[16:03:27.293]         if (FALSE) {
[16:03:27.293]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:27.293]         }
[16:03:27.293]         else {
[16:03:27.293]             ...future.result["stdout"] <- base::list(NULL)
[16:03:27.293]         }
[16:03:27.293]         base::close(...future.stdout)
[16:03:27.293]         ...future.stdout <- NULL
[16:03:27.293]     }
[16:03:27.293]     ...future.result$conditions <- ...future.conditions
[16:03:27.293]     ...future.result$finished <- base::Sys.time()
[16:03:27.293]     ...future.result
[16:03:27.293] }
[16:03:27.295] assign_globals() ...
[16:03:27.295] List of 5
[16:03:27.295]  $ ...future.FUN            :function (x)  
[16:03:27.295]  $ future.call.arguments    : list()
[16:03:27.295]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:27.295]  $ ...future.elements_ii    :List of 2
[16:03:27.295]   ..$ : int 1
[16:03:27.295]   ..$ : int 0
[16:03:27.295]  $ ...future.seeds_ii       : NULL
[16:03:27.295]  $ ...future.globals.maxSize: NULL
[16:03:27.295]  - attr(*, "where")=List of 5
[16:03:27.295]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:27.295]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:27.295]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:27.295]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:27.295]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:27.295]  - attr(*, "resolved")= logi FALSE
[16:03:27.295]  - attr(*, "total_size")= num 4720
[16:03:27.295]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:27.295]  - attr(*, "already-done")= logi TRUE
[16:03:27.300] - reassign environment for ‘...future.FUN’
[16:03:27.300] - copied ‘...future.FUN’ to environment
[16:03:27.300] - copied ‘future.call.arguments’ to environment
[16:03:27.300] - copied ‘...future.elements_ii’ to environment
[16:03:27.300] - copied ‘...future.seeds_ii’ to environment
[16:03:27.300] - copied ‘...future.globals.maxSize’ to environment
[16:03:27.300] assign_globals() ... done
[16:03:27.301] plan(): Setting new future strategy stack:
[16:03:27.301] List of future strategies:
[16:03:27.301] 1. sequential:
[16:03:27.301]    - args: function (..., envir = parent.frame())
[16:03:27.301]    - tweaked: FALSE
[16:03:27.301]    - call: NULL
[16:03:27.301] plan(): nbrOfWorkers() = 1
[16:03:27.803] plan(): Setting new future strategy stack:
[16:03:27.804] List of future strategies:
[16:03:27.804] 1. sequential:
[16:03:27.804]    - args: function (..., envir = parent.frame())
[16:03:27.804]    - tweaked: FALSE
[16:03:27.804]    - call: plan(strategy)
[16:03:27.804] plan(): nbrOfWorkers() = 1
[16:03:27.804] SequentialFuture started (and completed)
[16:03:27.805] - Launch lazy future ... done
[16:03:27.805] run() for ‘SequentialFuture’ ... done
[16:03:27.805] Created future:
[16:03:27.805] SequentialFuture:
[16:03:27.805] Label: ‘future_lapply-1’
[16:03:27.805] Expression:
[16:03:27.805] {
[16:03:27.805]     do.call(function(...) {
[16:03:27.805]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:27.805]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:27.805]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:27.805]             on.exit(options(oopts), add = TRUE)
[16:03:27.805]         }
[16:03:27.805]         {
[16:03:27.805]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:27.805]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:27.805]                 ...future.FUN(...future.X_jj, ...)
[16:03:27.805]             })
[16:03:27.805]         }
[16:03:27.805]     }, args = future.call.arguments)
[16:03:27.805] }
[16:03:27.805] Lazy evaluation: FALSE
[16:03:27.805] Asynchronous evaluation: FALSE
[16:03:27.805] Local evaluation: TRUE
[16:03:27.805] Environment: R_GlobalEnv
[16:03:27.805] Capture standard output: FALSE
[16:03:27.805] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:27.805] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:27.805] Packages: <none>
[16:03:27.805] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:27.805] Resolved: TRUE
[16:03:27.805] Value: 112 bytes of class ‘list’
[16:03:27.805] Early signaling: FALSE
[16:03:27.805] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:27.805] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:27.807] Chunk #1 of 1 ... DONE
[16:03:27.807] Launching 1 futures (chunks) ... DONE
[16:03:27.807] Resolving 1 futures (chunks) ...
[16:03:27.807] resolve() on list ...
[16:03:27.807]  recursive: 0
[16:03:27.807]  length: 1
[16:03:27.807] 
[16:03:27.807] resolved() for ‘SequentialFuture’ ...
[16:03:27.808] - state: ‘finished’
[16:03:27.808] - run: TRUE
[16:03:27.808] - result: ‘FutureResult’
[16:03:27.808] resolved() for ‘SequentialFuture’ ... done
[16:03:27.808] Future #1
[16:03:27.808] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:27.808] - nx: 1
[16:03:27.809] - relay: TRUE
[16:03:27.809] - stdout: TRUE
[16:03:27.809] - signal: TRUE
[16:03:27.809] - resignal: FALSE
[16:03:27.809] - force: TRUE
[16:03:27.809] - relayed: [n=1] FALSE
[16:03:27.809] - queued futures: [n=1] FALSE
[16:03:27.809]  - until=1
[16:03:27.809]  - relaying element #1
[16:03:27.809] - relayed: [n=1] TRUE
[16:03:27.809] - queued futures: [n=1] TRUE
[16:03:27.810] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:27.810]  length: 0 (resolved future 1)
[16:03:27.810] Relaying remaining futures
[16:03:27.810] signalConditionsASAP(NULL, pos=0) ...
[16:03:27.812] - nx: 1
[16:03:27.812] - relay: TRUE
[16:03:27.812] - stdout: TRUE
[16:03:27.812] - signal: TRUE
[16:03:27.812] - resignal: FALSE
[16:03:27.812] - force: TRUE
[16:03:27.813] - relayed: [n=1] TRUE
[16:03:27.813] - queued futures: [n=1] TRUE
 - flush all
[16:03:27.813] - relayed: [n=1] TRUE
[16:03:27.813] - queued futures: [n=1] TRUE
[16:03:27.813] signalConditionsASAP(NULL, pos=0) ... done
[16:03:27.813] resolve() on list ... DONE
[16:03:27.813]  - Number of value chunks collected: 1
[16:03:27.813] Resolving 1 futures (chunks) ... DONE
[16:03:27.813] Reducing values from 1 chunks ...
[16:03:27.813]  - Number of values collected after concatenation: 2
[16:03:27.814]  - Number of values expected: 2
[16:03:27.814] Reducing values from 1 chunks ... DONE
[16:03:27.814] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[16:03:27.814] future_lapply() ...
[16:03:27.815] Number of chunks: 1
[16:03:27.815] getGlobalsAndPackagesXApply() ...
[16:03:27.815]  - future.globals: TRUE
[16:03:27.815] getGlobalsAndPackages() ...
[16:03:27.815] Searching for globals...
[16:03:27.817] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:03:27.817] Searching for globals ... DONE
[16:03:27.817] Resolving globals: FALSE
[16:03:27.817] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:03:27.818] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:03:27.818] - globals: [1] ‘FUN’
[16:03:27.818] 
[16:03:27.818] getGlobalsAndPackages() ... DONE
[16:03:27.818]  - globals found/used: [n=1] ‘FUN’
[16:03:27.818]  - needed namespaces: [n=0] 
[16:03:27.818] Finding globals ... DONE
[16:03:27.818]  - use_args: TRUE
[16:03:27.818]  - Getting '...' globals ...
[16:03:27.819] resolve() on list ...
[16:03:27.819]  recursive: 0
[16:03:27.819]  length: 1
[16:03:27.819]  elements: ‘...’
[16:03:27.819]  length: 0 (resolved future 1)
[16:03:27.819] resolve() on list ... DONE
[16:03:27.819]    - '...' content: [n=0] 
[16:03:27.819] List of 1
[16:03:27.819]  $ ...: list()
[16:03:27.819]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:27.819]  - attr(*, "where")=List of 1
[16:03:27.819]   ..$ ...:<environment: 0x55ed792732e0> 
[16:03:27.819]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:27.819]  - attr(*, "resolved")= logi TRUE
[16:03:27.819]  - attr(*, "total_size")= num NA
[16:03:27.822]  - Getting '...' globals ... DONE
[16:03:27.822] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:03:27.822] List of 2
[16:03:27.822]  $ ...future.FUN:function (x)  
[16:03:27.822]  $ ...          : list()
[16:03:27.822]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:27.822]  - attr(*, "where")=List of 2
[16:03:27.822]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:27.822]   ..$ ...          :<environment: 0x55ed792732e0> 
[16:03:27.822]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:27.822]  - attr(*, "resolved")= logi FALSE
[16:03:27.822]  - attr(*, "total_size")= num 4720
[16:03:27.825] Packages to be attached in all futures: [n=0] 
[16:03:27.825] getGlobalsAndPackagesXApply() ... DONE
[16:03:27.825] Number of futures (= number of chunks): 1
[16:03:27.825] Launching 1 futures (chunks) ...
[16:03:27.825] Chunk #1 of 1 ...
[16:03:27.825]  - Finding globals in 'X' for chunk #1 ...
[16:03:27.825] getGlobalsAndPackages() ...
[16:03:27.825] Searching for globals...
[16:03:27.826] 
[16:03:27.826] Searching for globals ... DONE
[16:03:27.826] - globals: [0] <none>
[16:03:27.826] getGlobalsAndPackages() ... DONE
[16:03:27.826]    + additional globals found: [n=0] 
[16:03:27.826]    + additional namespaces needed: [n=0] 
[16:03:27.826]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:27.826]  - seeds: <none>
[16:03:27.826]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:27.826] getGlobalsAndPackages() ...
[16:03:27.827] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:27.827] Resolving globals: FALSE
[16:03:27.827] Tweak future expression to call with '...' arguments ...
[16:03:27.827] {
[16:03:27.827]     do.call(function(...) {
[16:03:27.827]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:27.827]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:27.827]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:27.827]             on.exit(options(oopts), add = TRUE)
[16:03:27.827]         }
[16:03:27.827]         {
[16:03:27.827]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:27.827]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:27.827]                 ...future.FUN(...future.X_jj, ...)
[16:03:27.827]             })
[16:03:27.827]         }
[16:03:27.827]     }, args = future.call.arguments)
[16:03:27.827] }
[16:03:27.827] Tweak future expression to call with '...' arguments ... DONE
[16:03:27.827] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:27.828] 
[16:03:27.828] getGlobalsAndPackages() ... DONE
[16:03:27.828] run() for ‘Future’ ...
[16:03:27.828] - state: ‘created’
[16:03:27.828] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:03:27.828] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:27.829] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:27.829]   - Field: ‘label’
[16:03:27.829]   - Field: ‘local’
[16:03:27.829]   - Field: ‘owner’
[16:03:27.829]   - Field: ‘envir’
[16:03:27.829]   - Field: ‘packages’
[16:03:27.829]   - Field: ‘gc’
[16:03:27.829]   - Field: ‘conditions’
[16:03:27.829]   - Field: ‘expr’
[16:03:27.829]   - Field: ‘uuid’
[16:03:27.830]   - Field: ‘seed’
[16:03:27.830]   - Field: ‘version’
[16:03:27.830]   - Field: ‘result’
[16:03:27.830]   - Field: ‘asynchronous’
[16:03:27.830]   - Field: ‘calls’
[16:03:27.830]   - Field: ‘globals’
[16:03:27.830]   - Field: ‘stdout’
[16:03:27.830]   - Field: ‘earlySignal’
[16:03:27.830]   - Field: ‘lazy’
[16:03:27.830]   - Field: ‘state’
[16:03:27.830] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:27.831] - Launch lazy future ...
[16:03:27.831] Packages needed by the future expression (n = 0): <none>
[16:03:27.831] Packages needed by future strategies (n = 0): <none>
[16:03:27.831] {
[16:03:27.831]     {
[16:03:27.831]         {
[16:03:27.831]             ...future.startTime <- base::Sys.time()
[16:03:27.831]             {
[16:03:27.831]                 {
[16:03:27.831]                   {
[16:03:27.831]                     base::local({
[16:03:27.831]                       has_future <- base::requireNamespace("future", 
[16:03:27.831]                         quietly = TRUE)
[16:03:27.831]                       if (has_future) {
[16:03:27.831]                         ns <- base::getNamespace("future")
[16:03:27.831]                         version <- ns[[".package"]][["version"]]
[16:03:27.831]                         if (is.null(version)) 
[16:03:27.831]                           version <- utils::packageVersion("future")
[16:03:27.831]                       }
[16:03:27.831]                       else {
[16:03:27.831]                         version <- NULL
[16:03:27.831]                       }
[16:03:27.831]                       if (!has_future || version < "1.8.0") {
[16:03:27.831]                         info <- base::c(r_version = base::gsub("R version ", 
[16:03:27.831]                           "", base::R.version$version.string), 
[16:03:27.831]                           platform = base::sprintf("%s (%s-bit)", 
[16:03:27.831]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:27.831]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:27.831]                             "release", "version")], collapse = " "), 
[16:03:27.831]                           hostname = base::Sys.info()[["nodename"]])
[16:03:27.831]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:03:27.831]                           info)
[16:03:27.831]                         info <- base::paste(info, collapse = "; ")
[16:03:27.831]                         if (!has_future) {
[16:03:27.831]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:27.831]                             info)
[16:03:27.831]                         }
[16:03:27.831]                         else {
[16:03:27.831]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:27.831]                             info, version)
[16:03:27.831]                         }
[16:03:27.831]                         base::stop(msg)
[16:03:27.831]                       }
[16:03:27.831]                     })
[16:03:27.831]                   }
[16:03:27.831]                   options(future.plan = NULL)
[16:03:27.831]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:27.831]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:27.831]                 }
[16:03:27.831]                 ...future.workdir <- getwd()
[16:03:27.831]             }
[16:03:27.831]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:27.831]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:27.831]         }
[16:03:27.831]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:27.831]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:27.831]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:27.831]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:27.831]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:27.831]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:27.831]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:27.831]             base::names(...future.oldOptions))
[16:03:27.831]     }
[16:03:27.831]     if (FALSE) {
[16:03:27.831]     }
[16:03:27.831]     else {
[16:03:27.831]         if (TRUE) {
[16:03:27.831]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:27.831]                 open = "w")
[16:03:27.831]         }
[16:03:27.831]         else {
[16:03:27.831]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:27.831]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:27.831]         }
[16:03:27.831]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:27.831]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:27.831]             base::sink(type = "output", split = FALSE)
[16:03:27.831]             base::close(...future.stdout)
[16:03:27.831]         }, add = TRUE)
[16:03:27.831]     }
[16:03:27.831]     ...future.frame <- base::sys.nframe()
[16:03:27.831]     ...future.conditions <- base::list()
[16:03:27.831]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:27.831]     if (FALSE) {
[16:03:27.831]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:27.831]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:27.831]     }
[16:03:27.831]     ...future.result <- base::tryCatch({
[16:03:27.831]         base::withCallingHandlers({
[16:03:27.831]             ...future.value <- base::withVisible(base::local({
[16:03:27.831]                 do.call(function(...) {
[16:03:27.831]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:27.831]                   if (!identical(...future.globals.maxSize.org, 
[16:03:27.831]                     ...future.globals.maxSize)) {
[16:03:27.831]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:27.831]                     on.exit(options(oopts), add = TRUE)
[16:03:27.831]                   }
[16:03:27.831]                   {
[16:03:27.831]                     lapply(seq_along(...future.elements_ii), 
[16:03:27.831]                       FUN = function(jj) {
[16:03:27.831]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:27.831]                         ...future.FUN(...future.X_jj, ...)
[16:03:27.831]                       })
[16:03:27.831]                   }
[16:03:27.831]                 }, args = future.call.arguments)
[16:03:27.831]             }))
[16:03:27.831]             future::FutureResult(value = ...future.value$value, 
[16:03:27.831]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:27.831]                   ...future.rng), globalenv = if (FALSE) 
[16:03:27.831]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:27.831]                     ...future.globalenv.names))
[16:03:27.831]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:27.831]         }, condition = base::local({
[16:03:27.831]             c <- base::c
[16:03:27.831]             inherits <- base::inherits
[16:03:27.831]             invokeRestart <- base::invokeRestart
[16:03:27.831]             length <- base::length
[16:03:27.831]             list <- base::list
[16:03:27.831]             seq.int <- base::seq.int
[16:03:27.831]             signalCondition <- base::signalCondition
[16:03:27.831]             sys.calls <- base::sys.calls
[16:03:27.831]             `[[` <- base::`[[`
[16:03:27.831]             `+` <- base::`+`
[16:03:27.831]             `<<-` <- base::`<<-`
[16:03:27.831]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:27.831]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:27.831]                   3L)]
[16:03:27.831]             }
[16:03:27.831]             function(cond) {
[16:03:27.831]                 is_error <- inherits(cond, "error")
[16:03:27.831]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:27.831]                   NULL)
[16:03:27.831]                 if (is_error) {
[16:03:27.831]                   sessionInformation <- function() {
[16:03:27.831]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:27.831]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:27.831]                       search = base::search(), system = base::Sys.info())
[16:03:27.831]                   }
[16:03:27.831]                   ...future.conditions[[length(...future.conditions) + 
[16:03:27.831]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:27.831]                     cond$call), session = sessionInformation(), 
[16:03:27.831]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:27.831]                   signalCondition(cond)
[16:03:27.831]                 }
[16:03:27.831]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:27.831]                 "immediateCondition"))) {
[16:03:27.831]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:27.831]                   ...future.conditions[[length(...future.conditions) + 
[16:03:27.831]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:27.831]                   if (TRUE && !signal) {
[16:03:27.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:27.831]                     {
[16:03:27.831]                       inherits <- base::inherits
[16:03:27.831]                       invokeRestart <- base::invokeRestart
[16:03:27.831]                       is.null <- base::is.null
[16:03:27.831]                       muffled <- FALSE
[16:03:27.831]                       if (inherits(cond, "message")) {
[16:03:27.831]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:27.831]                         if (muffled) 
[16:03:27.831]                           invokeRestart("muffleMessage")
[16:03:27.831]                       }
[16:03:27.831]                       else if (inherits(cond, "warning")) {
[16:03:27.831]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:27.831]                         if (muffled) 
[16:03:27.831]                           invokeRestart("muffleWarning")
[16:03:27.831]                       }
[16:03:27.831]                       else if (inherits(cond, "condition")) {
[16:03:27.831]                         if (!is.null(pattern)) {
[16:03:27.831]                           computeRestarts <- base::computeRestarts
[16:03:27.831]                           grepl <- base::grepl
[16:03:27.831]                           restarts <- computeRestarts(cond)
[16:03:27.831]                           for (restart in restarts) {
[16:03:27.831]                             name <- restart$name
[16:03:27.831]                             if (is.null(name)) 
[16:03:27.831]                               next
[16:03:27.831]                             if (!grepl(pattern, name)) 
[16:03:27.831]                               next
[16:03:27.831]                             invokeRestart(restart)
[16:03:27.831]                             muffled <- TRUE
[16:03:27.831]                             break
[16:03:27.831]                           }
[16:03:27.831]                         }
[16:03:27.831]                       }
[16:03:27.831]                       invisible(muffled)
[16:03:27.831]                     }
[16:03:27.831]                     muffleCondition(cond, pattern = "^muffle")
[16:03:27.831]                   }
[16:03:27.831]                 }
[16:03:27.831]                 else {
[16:03:27.831]                   if (TRUE) {
[16:03:27.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:27.831]                     {
[16:03:27.831]                       inherits <- base::inherits
[16:03:27.831]                       invokeRestart <- base::invokeRestart
[16:03:27.831]                       is.null <- base::is.null
[16:03:27.831]                       muffled <- FALSE
[16:03:27.831]                       if (inherits(cond, "message")) {
[16:03:27.831]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:27.831]                         if (muffled) 
[16:03:27.831]                           invokeRestart("muffleMessage")
[16:03:27.831]                       }
[16:03:27.831]                       else if (inherits(cond, "warning")) {
[16:03:27.831]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:27.831]                         if (muffled) 
[16:03:27.831]                           invokeRestart("muffleWarning")
[16:03:27.831]                       }
[16:03:27.831]                       else if (inherits(cond, "condition")) {
[16:03:27.831]                         if (!is.null(pattern)) {
[16:03:27.831]                           computeRestarts <- base::computeRestarts
[16:03:27.831]                           grepl <- base::grepl
[16:03:27.831]                           restarts <- computeRestarts(cond)
[16:03:27.831]                           for (restart in restarts) {
[16:03:27.831]                             name <- restart$name
[16:03:27.831]                             if (is.null(name)) 
[16:03:27.831]                               next
[16:03:27.831]                             if (!grepl(pattern, name)) 
[16:03:27.831]                               next
[16:03:27.831]                             invokeRestart(restart)
[16:03:27.831]                             muffled <- TRUE
[16:03:27.831]                             break
[16:03:27.831]                           }
[16:03:27.831]                         }
[16:03:27.831]                       }
[16:03:27.831]                       invisible(muffled)
[16:03:27.831]                     }
[16:03:27.831]                     muffleCondition(cond, pattern = "^muffle")
[16:03:27.831]                   }
[16:03:27.831]                 }
[16:03:27.831]             }
[16:03:27.831]         }))
[16:03:27.831]     }, error = function(ex) {
[16:03:27.831]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:27.831]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:27.831]                 ...future.rng), started = ...future.startTime, 
[16:03:27.831]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:27.831]             version = "1.8"), class = "FutureResult")
[16:03:27.831]     }, finally = {
[16:03:27.831]         if (!identical(...future.workdir, getwd())) 
[16:03:27.831]             setwd(...future.workdir)
[16:03:27.831]         {
[16:03:27.831]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:27.831]                 ...future.oldOptions$nwarnings <- NULL
[16:03:27.831]             }
[16:03:27.831]             base::options(...future.oldOptions)
[16:03:27.831]             if (.Platform$OS.type == "windows") {
[16:03:27.831]                 old_names <- names(...future.oldEnvVars)
[16:03:27.831]                 envs <- base::Sys.getenv()
[16:03:27.831]                 names <- names(envs)
[16:03:27.831]                 common <- intersect(names, old_names)
[16:03:27.831]                 added <- setdiff(names, old_names)
[16:03:27.831]                 removed <- setdiff(old_names, names)
[16:03:27.831]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:27.831]                   envs[common]]
[16:03:27.831]                 NAMES <- toupper(changed)
[16:03:27.831]                 args <- list()
[16:03:27.831]                 for (kk in seq_along(NAMES)) {
[16:03:27.831]                   name <- changed[[kk]]
[16:03:27.831]                   NAME <- NAMES[[kk]]
[16:03:27.831]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:27.831]                     next
[16:03:27.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:27.831]                 }
[16:03:27.831]                 NAMES <- toupper(added)
[16:03:27.831]                 for (kk in seq_along(NAMES)) {
[16:03:27.831]                   name <- added[[kk]]
[16:03:27.831]                   NAME <- NAMES[[kk]]
[16:03:27.831]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:27.831]                     next
[16:03:27.831]                   args[[name]] <- ""
[16:03:27.831]                 }
[16:03:27.831]                 NAMES <- toupper(removed)
[16:03:27.831]                 for (kk in seq_along(NAMES)) {
[16:03:27.831]                   name <- removed[[kk]]
[16:03:27.831]                   NAME <- NAMES[[kk]]
[16:03:27.831]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:27.831]                     next
[16:03:27.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:27.831]                 }
[16:03:27.831]                 if (length(args) > 0) 
[16:03:27.831]                   base::do.call(base::Sys.setenv, args = args)
[16:03:27.831]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:27.831]             }
[16:03:27.831]             else {
[16:03:27.831]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:27.831]             }
[16:03:27.831]             {
[16:03:27.831]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:27.831]                   0L) {
[16:03:27.831]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:27.831]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:27.831]                   base::options(opts)
[16:03:27.831]                 }
[16:03:27.831]                 {
[16:03:27.831]                   {
[16:03:27.831]                     NULL
[16:03:27.831]                     RNGkind("Mersenne-Twister")
[16:03:27.831]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:27.831]                       inherits = FALSE)
[16:03:27.831]                   }
[16:03:27.831]                   options(future.plan = NULL)
[16:03:27.831]                   if (is.na(NA_character_)) 
[16:03:27.831]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:27.831]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:27.831]                   future::plan(list(function (..., envir = parent.frame()) 
[16:03:27.831]                   {
[16:03:27.831]                     future <- SequentialFuture(..., envir = envir)
[16:03:27.831]                     if (!future$lazy) 
[16:03:27.831]                       future <- run(future)
[16:03:27.831]                     invisible(future)
[16:03:27.831]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:27.831]                 }
[16:03:27.831]             }
[16:03:27.831]         }
[16:03:27.831]     })
[16:03:27.831]     if (TRUE) {
[16:03:27.831]         base::sink(type = "output", split = FALSE)
[16:03:27.831]         if (TRUE) {
[16:03:27.831]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:27.831]         }
[16:03:27.831]         else {
[16:03:27.831]             ...future.result["stdout"] <- base::list(NULL)
[16:03:27.831]         }
[16:03:27.831]         base::close(...future.stdout)
[16:03:27.831]         ...future.stdout <- NULL
[16:03:27.831]     }
[16:03:27.831]     ...future.result$conditions <- ...future.conditions
[16:03:27.831]     ...future.result$finished <- base::Sys.time()
[16:03:27.831]     ...future.result
[16:03:27.831] }
[16:03:27.833] assign_globals() ...
[16:03:27.833] List of 5
[16:03:27.833]  $ ...future.FUN            :function (x)  
[16:03:27.833]  $ future.call.arguments    : list()
[16:03:27.833]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:27.833]  $ ...future.elements_ii    :List of 2
[16:03:27.833]   ..$ : int 1
[16:03:27.833]   ..$ : int 0
[16:03:27.833]  $ ...future.seeds_ii       : NULL
[16:03:27.833]  $ ...future.globals.maxSize: NULL
[16:03:27.833]  - attr(*, "where")=List of 5
[16:03:27.833]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:27.833]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:27.833]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:27.833]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:27.833]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:27.833]  - attr(*, "resolved")= logi FALSE
[16:03:27.833]  - attr(*, "total_size")= num 4720
[16:03:27.833]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:27.833]  - attr(*, "already-done")= logi TRUE
[16:03:27.839] - reassign environment for ‘...future.FUN’
[16:03:27.839] - copied ‘...future.FUN’ to environment
[16:03:27.839] - copied ‘future.call.arguments’ to environment
[16:03:27.839] - copied ‘...future.elements_ii’ to environment
[16:03:27.839] - copied ‘...future.seeds_ii’ to environment
[16:03:27.839] - copied ‘...future.globals.maxSize’ to environment
[16:03:27.840] assign_globals() ... done
[16:03:27.840] plan(): Setting new future strategy stack:
[16:03:27.840] List of future strategies:
[16:03:27.840] 1. sequential:
[16:03:27.840]    - args: function (..., envir = parent.frame())
[16:03:27.840]    - tweaked: FALSE
[16:03:27.840]    - call: NULL
[16:03:27.840] plan(): nbrOfWorkers() = 1
[16:03:28.342] plan(): Setting new future strategy stack:
[16:03:28.342] List of future strategies:
[16:03:28.342] 1. sequential:
[16:03:28.342]    - args: function (..., envir = parent.frame())
[16:03:28.342]    - tweaked: FALSE
[16:03:28.342]    - call: plan(strategy)
[16:03:28.343] plan(): nbrOfWorkers() = 1
[16:03:28.343] SequentialFuture started (and completed)
[16:03:28.343] - Launch lazy future ... done
[16:03:28.343] run() for ‘SequentialFuture’ ... done
[16:03:28.343] Created future:
[16:03:28.343] SequentialFuture:
[16:03:28.343] Label: ‘future_lapply-1’
[16:03:28.343] Expression:
[16:03:28.343] {
[16:03:28.343]     do.call(function(...) {
[16:03:28.343]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:28.343]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:28.343]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:28.343]             on.exit(options(oopts), add = TRUE)
[16:03:28.343]         }
[16:03:28.343]         {
[16:03:28.343]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:28.343]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:28.343]                 ...future.FUN(...future.X_jj, ...)
[16:03:28.343]             })
[16:03:28.343]         }
[16:03:28.343]     }, args = future.call.arguments)
[16:03:28.343] }
[16:03:28.343] Lazy evaluation: FALSE
[16:03:28.343] Asynchronous evaluation: FALSE
[16:03:28.343] Local evaluation: TRUE
[16:03:28.343] Environment: R_GlobalEnv
[16:03:28.343] Capture standard output: TRUE
[16:03:28.343] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:28.343] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:28.343] Packages: <none>
[16:03:28.343] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:28.343] Resolved: TRUE
[16:03:28.343] Value: 112 bytes of class ‘list’
[16:03:28.343] Early signaling: FALSE
[16:03:28.343] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:28.343] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:28.344] Chunk #1 of 1 ... DONE
[16:03:28.344] Launching 1 futures (chunks) ... DONE
[16:03:28.345] Resolving 1 futures (chunks) ...
[16:03:28.345] resolve() on list ...
[16:03:28.345]  recursive: 0
[16:03:28.345]  length: 1
[16:03:28.345] 
[16:03:28.345] resolved() for ‘SequentialFuture’ ...
[16:03:28.345] - state: ‘finished’
[16:03:28.345] - run: TRUE
[16:03:28.345] - result: ‘FutureResult’
[16:03:28.345] resolved() for ‘SequentialFuture’ ... done
[16:03:28.345] Future #1
[16:03:28.346] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:28.346] - nx: 1
[16:03:28.346] - relay: TRUE
[16:03:28.346] - stdout: TRUE
[16:03:28.346] - signal: TRUE
[16:03:28.346] - resignal: FALSE
[16:03:28.346] - force: TRUE
[16:03:28.346] - relayed: [n=1] FALSE
[16:03:28.346] - queued futures: [n=1] FALSE
[16:03:28.346]  - until=1
[16:03:28.346]  - relaying element #1
[16:03:28.347] - relayed: [n=1] TRUE
[16:03:28.347] - queued futures: [n=1] TRUE
[16:03:28.347] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:28.347]  length: 0 (resolved future 1)
[16:03:28.347] Relaying remaining futures
[16:03:28.347] signalConditionsASAP(NULL, pos=0) ...
[16:03:28.347] - nx: 1
[16:03:28.347] - relay: TRUE
[16:03:28.347] - stdout: TRUE
[16:03:28.347] - signal: TRUE
[16:03:28.348] - resignal: FALSE
[16:03:28.348] - force: TRUE
[16:03:28.348] - relayed: [n=1] TRUE
[16:03:28.348] - queued futures: [n=1] TRUE
 - flush all
[16:03:28.348] - relayed: [n=1] TRUE
[16:03:28.348] - queued futures: [n=1] TRUE
[16:03:28.348] signalConditionsASAP(NULL, pos=0) ... done
[16:03:28.348] resolve() on list ... DONE
[16:03:28.348]  - Number of value chunks collected: 1
[16:03:28.348] Resolving 1 futures (chunks) ... DONE
[16:03:28.349] Reducing values from 1 chunks ...
[16:03:28.349]  - Number of values collected after concatenation: 2
[16:03:28.349]  - Number of values expected: 2
[16:03:28.349] Reducing values from 1 chunks ... DONE
[16:03:28.349] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[16:03:28.349] future_lapply() ...
[16:03:28.350] Number of chunks: 1
[16:03:28.350] getGlobalsAndPackagesXApply() ...
[16:03:28.350]  - future.globals: TRUE
[16:03:28.350] getGlobalsAndPackages() ...
[16:03:28.350] Searching for globals...
[16:03:28.352] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:03:28.352] Searching for globals ... DONE
[16:03:28.352] Resolving globals: FALSE
[16:03:28.352] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:03:28.353] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:03:28.353] - globals: [1] ‘FUN’
[16:03:28.353] 
[16:03:28.353] getGlobalsAndPackages() ... DONE
[16:03:28.353]  - globals found/used: [n=1] ‘FUN’
[16:03:28.353]  - needed namespaces: [n=0] 
[16:03:28.353] Finding globals ... DONE
[16:03:28.353]  - use_args: TRUE
[16:03:28.353]  - Getting '...' globals ...
[16:03:28.354] resolve() on list ...
[16:03:28.354]  recursive: 0
[16:03:28.354]  length: 1
[16:03:28.354]  elements: ‘...’
[16:03:28.354]  length: 0 (resolved future 1)
[16:03:28.354] resolve() on list ... DONE
[16:03:28.354]    - '...' content: [n=0] 
[16:03:28.354] List of 1
[16:03:28.354]  $ ...: list()
[16:03:28.354]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:28.354]  - attr(*, "where")=List of 1
[16:03:28.354]   ..$ ...:<environment: 0x55ed79f5bbd0> 
[16:03:28.354]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:28.354]  - attr(*, "resolved")= logi TRUE
[16:03:28.354]  - attr(*, "total_size")= num NA
[16:03:28.357]  - Getting '...' globals ... DONE
[16:03:28.357] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:03:28.357] List of 2
[16:03:28.357]  $ ...future.FUN:function (x)  
[16:03:28.357]  $ ...          : list()
[16:03:28.357]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:28.357]  - attr(*, "where")=List of 2
[16:03:28.357]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:28.357]   ..$ ...          :<environment: 0x55ed79f5bbd0> 
[16:03:28.357]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:28.357]  - attr(*, "resolved")= logi FALSE
[16:03:28.357]  - attr(*, "total_size")= num 4720
[16:03:28.360] Packages to be attached in all futures: [n=0] 
[16:03:28.360] getGlobalsAndPackagesXApply() ... DONE
[16:03:28.360] Number of futures (= number of chunks): 1
[16:03:28.360] Launching 1 futures (chunks) ...
[16:03:28.360] Chunk #1 of 1 ...
[16:03:28.360]  - Finding globals in 'X' for chunk #1 ...
[16:03:28.360] getGlobalsAndPackages() ...
[16:03:28.360] Searching for globals...
[16:03:28.361] 
[16:03:28.362] Searching for globals ... DONE
[16:03:28.362] - globals: [0] <none>
[16:03:28.362] getGlobalsAndPackages() ... DONE
[16:03:28.363]    + additional globals found: [n=0] 
[16:03:28.363]    + additional namespaces needed: [n=0] 
[16:03:28.363]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:28.363]  - seeds: <none>
[16:03:28.363]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:28.363] getGlobalsAndPackages() ...
[16:03:28.363] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:28.363] Resolving globals: FALSE
[16:03:28.363] Tweak future expression to call with '...' arguments ...
[16:03:28.363] {
[16:03:28.363]     do.call(function(...) {
[16:03:28.363]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:28.363]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:28.363]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:28.363]             on.exit(options(oopts), add = TRUE)
[16:03:28.363]         }
[16:03:28.363]         {
[16:03:28.363]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:28.363]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:28.363]                 ...future.FUN(...future.X_jj, ...)
[16:03:28.363]             })
[16:03:28.363]         }
[16:03:28.363]     }, args = future.call.arguments)
[16:03:28.363] }
[16:03:28.364] Tweak future expression to call with '...' arguments ... DONE
[16:03:28.364] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:28.364] 
[16:03:28.364] getGlobalsAndPackages() ... DONE
[16:03:28.365] run() for ‘Future’ ...
[16:03:28.365] - state: ‘created’
[16:03:28.365] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:03:28.365] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:28.365] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:28.365]   - Field: ‘label’
[16:03:28.365]   - Field: ‘local’
[16:03:28.365]   - Field: ‘owner’
[16:03:28.366]   - Field: ‘envir’
[16:03:28.366]   - Field: ‘packages’
[16:03:28.366]   - Field: ‘gc’
[16:03:28.366]   - Field: ‘conditions’
[16:03:28.366]   - Field: ‘expr’
[16:03:28.366]   - Field: ‘uuid’
[16:03:28.366]   - Field: ‘seed’
[16:03:28.366]   - Field: ‘version’
[16:03:28.366]   - Field: ‘result’
[16:03:28.366]   - Field: ‘asynchronous’
[16:03:28.366]   - Field: ‘calls’
[16:03:28.367]   - Field: ‘globals’
[16:03:28.367]   - Field: ‘stdout’
[16:03:28.367]   - Field: ‘earlySignal’
[16:03:28.367]   - Field: ‘lazy’
[16:03:28.367]   - Field: ‘state’
[16:03:28.367] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:28.367] - Launch lazy future ...
[16:03:28.367] Packages needed by the future expression (n = 0): <none>
[16:03:28.367] Packages needed by future strategies (n = 0): <none>
[16:03:28.368] {
[16:03:28.368]     {
[16:03:28.368]         {
[16:03:28.368]             ...future.startTime <- base::Sys.time()
[16:03:28.368]             {
[16:03:28.368]                 {
[16:03:28.368]                   {
[16:03:28.368]                     base::local({
[16:03:28.368]                       has_future <- base::requireNamespace("future", 
[16:03:28.368]                         quietly = TRUE)
[16:03:28.368]                       if (has_future) {
[16:03:28.368]                         ns <- base::getNamespace("future")
[16:03:28.368]                         version <- ns[[".package"]][["version"]]
[16:03:28.368]                         if (is.null(version)) 
[16:03:28.368]                           version <- utils::packageVersion("future")
[16:03:28.368]                       }
[16:03:28.368]                       else {
[16:03:28.368]                         version <- NULL
[16:03:28.368]                       }
[16:03:28.368]                       if (!has_future || version < "1.8.0") {
[16:03:28.368]                         info <- base::c(r_version = base::gsub("R version ", 
[16:03:28.368]                           "", base::R.version$version.string), 
[16:03:28.368]                           platform = base::sprintf("%s (%s-bit)", 
[16:03:28.368]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:28.368]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:28.368]                             "release", "version")], collapse = " "), 
[16:03:28.368]                           hostname = base::Sys.info()[["nodename"]])
[16:03:28.368]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:03:28.368]                           info)
[16:03:28.368]                         info <- base::paste(info, collapse = "; ")
[16:03:28.368]                         if (!has_future) {
[16:03:28.368]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:28.368]                             info)
[16:03:28.368]                         }
[16:03:28.368]                         else {
[16:03:28.368]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:28.368]                             info, version)
[16:03:28.368]                         }
[16:03:28.368]                         base::stop(msg)
[16:03:28.368]                       }
[16:03:28.368]                     })
[16:03:28.368]                   }
[16:03:28.368]                   options(future.plan = NULL)
[16:03:28.368]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:28.368]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:28.368]                 }
[16:03:28.368]                 ...future.workdir <- getwd()
[16:03:28.368]             }
[16:03:28.368]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:28.368]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:28.368]         }
[16:03:28.368]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:28.368]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:28.368]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:28.368]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:28.368]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:28.368]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:28.368]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:28.368]             base::names(...future.oldOptions))
[16:03:28.368]     }
[16:03:28.368]     if (TRUE) {
[16:03:28.368]     }
[16:03:28.368]     else {
[16:03:28.368]         if (NA) {
[16:03:28.368]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:28.368]                 open = "w")
[16:03:28.368]         }
[16:03:28.368]         else {
[16:03:28.368]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:28.368]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:28.368]         }
[16:03:28.368]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:28.368]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:28.368]             base::sink(type = "output", split = FALSE)
[16:03:28.368]             base::close(...future.stdout)
[16:03:28.368]         }, add = TRUE)
[16:03:28.368]     }
[16:03:28.368]     ...future.frame <- base::sys.nframe()
[16:03:28.368]     ...future.conditions <- base::list()
[16:03:28.368]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:28.368]     if (FALSE) {
[16:03:28.368]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:28.368]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:28.368]     }
[16:03:28.368]     ...future.result <- base::tryCatch({
[16:03:28.368]         base::withCallingHandlers({
[16:03:28.368]             ...future.value <- base::withVisible(base::local({
[16:03:28.368]                 do.call(function(...) {
[16:03:28.368]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:28.368]                   if (!identical(...future.globals.maxSize.org, 
[16:03:28.368]                     ...future.globals.maxSize)) {
[16:03:28.368]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:28.368]                     on.exit(options(oopts), add = TRUE)
[16:03:28.368]                   }
[16:03:28.368]                   {
[16:03:28.368]                     lapply(seq_along(...future.elements_ii), 
[16:03:28.368]                       FUN = function(jj) {
[16:03:28.368]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:28.368]                         ...future.FUN(...future.X_jj, ...)
[16:03:28.368]                       })
[16:03:28.368]                   }
[16:03:28.368]                 }, args = future.call.arguments)
[16:03:28.368]             }))
[16:03:28.368]             future::FutureResult(value = ...future.value$value, 
[16:03:28.368]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:28.368]                   ...future.rng), globalenv = if (FALSE) 
[16:03:28.368]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:28.368]                     ...future.globalenv.names))
[16:03:28.368]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:28.368]         }, condition = base::local({
[16:03:28.368]             c <- base::c
[16:03:28.368]             inherits <- base::inherits
[16:03:28.368]             invokeRestart <- base::invokeRestart
[16:03:28.368]             length <- base::length
[16:03:28.368]             list <- base::list
[16:03:28.368]             seq.int <- base::seq.int
[16:03:28.368]             signalCondition <- base::signalCondition
[16:03:28.368]             sys.calls <- base::sys.calls
[16:03:28.368]             `[[` <- base::`[[`
[16:03:28.368]             `+` <- base::`+`
[16:03:28.368]             `<<-` <- base::`<<-`
[16:03:28.368]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:28.368]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:28.368]                   3L)]
[16:03:28.368]             }
[16:03:28.368]             function(cond) {
[16:03:28.368]                 is_error <- inherits(cond, "error")
[16:03:28.368]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:28.368]                   NULL)
[16:03:28.368]                 if (is_error) {
[16:03:28.368]                   sessionInformation <- function() {
[16:03:28.368]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:28.368]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:28.368]                       search = base::search(), system = base::Sys.info())
[16:03:28.368]                   }
[16:03:28.368]                   ...future.conditions[[length(...future.conditions) + 
[16:03:28.368]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:28.368]                     cond$call), session = sessionInformation(), 
[16:03:28.368]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:28.368]                   signalCondition(cond)
[16:03:28.368]                 }
[16:03:28.368]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:28.368]                 "immediateCondition"))) {
[16:03:28.368]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:28.368]                   ...future.conditions[[length(...future.conditions) + 
[16:03:28.368]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:28.368]                   if (TRUE && !signal) {
[16:03:28.368]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:28.368]                     {
[16:03:28.368]                       inherits <- base::inherits
[16:03:28.368]                       invokeRestart <- base::invokeRestart
[16:03:28.368]                       is.null <- base::is.null
[16:03:28.368]                       muffled <- FALSE
[16:03:28.368]                       if (inherits(cond, "message")) {
[16:03:28.368]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:28.368]                         if (muffled) 
[16:03:28.368]                           invokeRestart("muffleMessage")
[16:03:28.368]                       }
[16:03:28.368]                       else if (inherits(cond, "warning")) {
[16:03:28.368]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:28.368]                         if (muffled) 
[16:03:28.368]                           invokeRestart("muffleWarning")
[16:03:28.368]                       }
[16:03:28.368]                       else if (inherits(cond, "condition")) {
[16:03:28.368]                         if (!is.null(pattern)) {
[16:03:28.368]                           computeRestarts <- base::computeRestarts
[16:03:28.368]                           grepl <- base::grepl
[16:03:28.368]                           restarts <- computeRestarts(cond)
[16:03:28.368]                           for (restart in restarts) {
[16:03:28.368]                             name <- restart$name
[16:03:28.368]                             if (is.null(name)) 
[16:03:28.368]                               next
[16:03:28.368]                             if (!grepl(pattern, name)) 
[16:03:28.368]                               next
[16:03:28.368]                             invokeRestart(restart)
[16:03:28.368]                             muffled <- TRUE
[16:03:28.368]                             break
[16:03:28.368]                           }
[16:03:28.368]                         }
[16:03:28.368]                       }
[16:03:28.368]                       invisible(muffled)
[16:03:28.368]                     }
[16:03:28.368]                     muffleCondition(cond, pattern = "^muffle")
[16:03:28.368]                   }
[16:03:28.368]                 }
[16:03:28.368]                 else {
[16:03:28.368]                   if (TRUE) {
[16:03:28.368]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:28.368]                     {
[16:03:28.368]                       inherits <- base::inherits
[16:03:28.368]                       invokeRestart <- base::invokeRestart
[16:03:28.368]                       is.null <- base::is.null
[16:03:28.368]                       muffled <- FALSE
[16:03:28.368]                       if (inherits(cond, "message")) {
[16:03:28.368]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:28.368]                         if (muffled) 
[16:03:28.368]                           invokeRestart("muffleMessage")
[16:03:28.368]                       }
[16:03:28.368]                       else if (inherits(cond, "warning")) {
[16:03:28.368]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:28.368]                         if (muffled) 
[16:03:28.368]                           invokeRestart("muffleWarning")
[16:03:28.368]                       }
[16:03:28.368]                       else if (inherits(cond, "condition")) {
[16:03:28.368]                         if (!is.null(pattern)) {
[16:03:28.368]                           computeRestarts <- base::computeRestarts
[16:03:28.368]                           grepl <- base::grepl
[16:03:28.368]                           restarts <- computeRestarts(cond)
[16:03:28.368]                           for (restart in restarts) {
[16:03:28.368]                             name <- restart$name
[16:03:28.368]                             if (is.null(name)) 
[16:03:28.368]                               next
[16:03:28.368]                             if (!grepl(pattern, name)) 
[16:03:28.368]                               next
[16:03:28.368]                             invokeRestart(restart)
[16:03:28.368]                             muffled <- TRUE
[16:03:28.368]                             break
[16:03:28.368]                           }
[16:03:28.368]                         }
[16:03:28.368]                       }
[16:03:28.368]                       invisible(muffled)
[16:03:28.368]                     }
[16:03:28.368]                     muffleCondition(cond, pattern = "^muffle")
[16:03:28.368]                   }
[16:03:28.368]                 }
[16:03:28.368]             }
[16:03:28.368]         }))
[16:03:28.368]     }, error = function(ex) {
[16:03:28.368]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:28.368]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:28.368]                 ...future.rng), started = ...future.startTime, 
[16:03:28.368]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:28.368]             version = "1.8"), class = "FutureResult")
[16:03:28.368]     }, finally = {
[16:03:28.368]         if (!identical(...future.workdir, getwd())) 
[16:03:28.368]             setwd(...future.workdir)
[16:03:28.368]         {
[16:03:28.368]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:28.368]                 ...future.oldOptions$nwarnings <- NULL
[16:03:28.368]             }
[16:03:28.368]             base::options(...future.oldOptions)
[16:03:28.368]             if (.Platform$OS.type == "windows") {
[16:03:28.368]                 old_names <- names(...future.oldEnvVars)
[16:03:28.368]                 envs <- base::Sys.getenv()
[16:03:28.368]                 names <- names(envs)
[16:03:28.368]                 common <- intersect(names, old_names)
[16:03:28.368]                 added <- setdiff(names, old_names)
[16:03:28.368]                 removed <- setdiff(old_names, names)
[16:03:28.368]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:28.368]                   envs[common]]
[16:03:28.368]                 NAMES <- toupper(changed)
[16:03:28.368]                 args <- list()
[16:03:28.368]                 for (kk in seq_along(NAMES)) {
[16:03:28.368]                   name <- changed[[kk]]
[16:03:28.368]                   NAME <- NAMES[[kk]]
[16:03:28.368]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:28.368]                     next
[16:03:28.368]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:28.368]                 }
[16:03:28.368]                 NAMES <- toupper(added)
[16:03:28.368]                 for (kk in seq_along(NAMES)) {
[16:03:28.368]                   name <- added[[kk]]
[16:03:28.368]                   NAME <- NAMES[[kk]]
[16:03:28.368]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:28.368]                     next
[16:03:28.368]                   args[[name]] <- ""
[16:03:28.368]                 }
[16:03:28.368]                 NAMES <- toupper(removed)
[16:03:28.368]                 for (kk in seq_along(NAMES)) {
[16:03:28.368]                   name <- removed[[kk]]
[16:03:28.368]                   NAME <- NAMES[[kk]]
[16:03:28.368]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:28.368]                     next
[16:03:28.368]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:28.368]                 }
[16:03:28.368]                 if (length(args) > 0) 
[16:03:28.368]                   base::do.call(base::Sys.setenv, args = args)
[16:03:28.368]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:28.368]             }
[16:03:28.368]             else {
[16:03:28.368]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:28.368]             }
[16:03:28.368]             {
[16:03:28.368]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:28.368]                   0L) {
[16:03:28.368]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:28.368]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:28.368]                   base::options(opts)
[16:03:28.368]                 }
[16:03:28.368]                 {
[16:03:28.368]                   {
[16:03:28.368]                     NULL
[16:03:28.368]                     RNGkind("Mersenne-Twister")
[16:03:28.368]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:28.368]                       inherits = FALSE)
[16:03:28.368]                   }
[16:03:28.368]                   options(future.plan = NULL)
[16:03:28.368]                   if (is.na(NA_character_)) 
[16:03:28.368]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:28.368]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:28.368]                   future::plan(list(function (..., envir = parent.frame()) 
[16:03:28.368]                   {
[16:03:28.368]                     future <- SequentialFuture(..., envir = envir)
[16:03:28.368]                     if (!future$lazy) 
[16:03:28.368]                       future <- run(future)
[16:03:28.368]                     invisible(future)
[16:03:28.368]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:28.368]                 }
[16:03:28.368]             }
[16:03:28.368]         }
[16:03:28.368]     })
[16:03:28.368]     if (FALSE) {
[16:03:28.368]         base::sink(type = "output", split = FALSE)
[16:03:28.368]         if (NA) {
[16:03:28.368]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:28.368]         }
[16:03:28.368]         else {
[16:03:28.368]             ...future.result["stdout"] <- base::list(NULL)
[16:03:28.368]         }
[16:03:28.368]         base::close(...future.stdout)
[16:03:28.368]         ...future.stdout <- NULL
[16:03:28.368]     }
[16:03:28.368]     ...future.result$conditions <- ...future.conditions
[16:03:28.368]     ...future.result$finished <- base::Sys.time()
[16:03:28.368]     ...future.result
[16:03:28.368] }
[16:03:28.369] assign_globals() ...
[16:03:28.370] List of 5
[16:03:28.370]  $ ...future.FUN            :function (x)  
[16:03:28.370]  $ future.call.arguments    : list()
[16:03:28.370]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:28.370]  $ ...future.elements_ii    :List of 2
[16:03:28.370]   ..$ : int 1
[16:03:28.370]   ..$ : int 0
[16:03:28.370]  $ ...future.seeds_ii       : NULL
[16:03:28.370]  $ ...future.globals.maxSize: NULL
[16:03:28.370]  - attr(*, "where")=List of 5
[16:03:28.370]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:28.370]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:28.370]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:28.370]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:28.370]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:28.370]  - attr(*, "resolved")= logi FALSE
[16:03:28.370]  - attr(*, "total_size")= num 4720
[16:03:28.370]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:28.370]  - attr(*, "already-done")= logi TRUE
[16:03:28.374] - reassign environment for ‘...future.FUN’
[16:03:28.374] - copied ‘...future.FUN’ to environment
[16:03:28.375] - copied ‘future.call.arguments’ to environment
[16:03:28.375] - copied ‘...future.elements_ii’ to environment
[16:03:28.375] - copied ‘...future.seeds_ii’ to environment
[16:03:28.375] - copied ‘...future.globals.maxSize’ to environment
[16:03:28.375] assign_globals() ... done
[16:03:28.375] plan(): Setting new future strategy stack:
[16:03:28.375] List of future strategies:
[16:03:28.375] 1. sequential:
[16:03:28.375]    - args: function (..., envir = parent.frame())
[16:03:28.375]    - tweaked: FALSE
[16:03:28.375]    - call: NULL
[16:03:28.376] plan(): nbrOfWorkers() = 1
[16:03:28.877] plan(): Setting new future strategy stack:
[16:03:28.877] List of future strategies:
[16:03:28.877] 1. sequential:
[16:03:28.877]    - args: function (..., envir = parent.frame())
[16:03:28.877]    - tweaked: FALSE
[16:03:28.877]    - call: plan(strategy)
[16:03:28.878] plan(): nbrOfWorkers() = 1
[16:03:28.878] SequentialFuture started (and completed)
[16:03:28.878] - Launch lazy future ... done
[16:03:28.878] run() for ‘SequentialFuture’ ... done
[16:03:28.878] Created future:
[16:03:28.878] SequentialFuture:
[16:03:28.878] Label: ‘future_lapply-1’
[16:03:28.878] Expression:
[16:03:28.878] {
[16:03:28.878]     do.call(function(...) {
[16:03:28.878]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:28.878]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:28.878]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:28.878]             on.exit(options(oopts), add = TRUE)
[16:03:28.878]         }
[16:03:28.878]         {
[16:03:28.878]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:28.878]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:28.878]                 ...future.FUN(...future.X_jj, ...)
[16:03:28.878]             })
[16:03:28.878]         }
[16:03:28.878]     }, args = future.call.arguments)
[16:03:28.878] }
[16:03:28.878] Lazy evaluation: FALSE
[16:03:28.878] Asynchronous evaluation: FALSE
[16:03:28.878] Local evaluation: TRUE
[16:03:28.878] Environment: R_GlobalEnv
[16:03:28.878] Capture standard output: NA
[16:03:28.878] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:28.878] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:28.878] Packages: <none>
[16:03:28.878] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:28.878] Resolved: TRUE
[16:03:28.878] Value: 112 bytes of class ‘list’
[16:03:28.878] Early signaling: FALSE
[16:03:28.878] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:28.878] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:28.880] Chunk #1 of 1 ... DONE
[16:03:28.880] Launching 1 futures (chunks) ... DONE
[16:03:28.880] Resolving 1 futures (chunks) ...
[16:03:28.880] resolve() on list ...
[16:03:28.880]  recursive: 0
[16:03:28.880]  length: 1
[16:03:28.880] 
[16:03:28.880] resolved() for ‘SequentialFuture’ ...
[16:03:28.880] - state: ‘finished’
[16:03:28.880] - run: TRUE
[16:03:28.881] - result: ‘FutureResult’
[16:03:28.881] resolved() for ‘SequentialFuture’ ... done
[16:03:28.881] Future #1
[16:03:28.881] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:28.881] - nx: 1
[16:03:28.881] - relay: TRUE
[16:03:28.881] - stdout: TRUE
[16:03:28.881] - signal: TRUE
[16:03:28.881] - resignal: FALSE
[16:03:28.881] - force: TRUE
[16:03:28.881] - relayed: [n=1] FALSE
[16:03:28.882] - queued futures: [n=1] FALSE
[16:03:28.882]  - until=1
[16:03:28.882]  - relaying element #1
[16:03:28.882] - relayed: [n=1] TRUE
[16:03:28.882] - queued futures: [n=1] TRUE
[16:03:28.882] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:28.882]  length: 0 (resolved future 1)
[16:03:28.882] Relaying remaining futures
[16:03:28.882] signalConditionsASAP(NULL, pos=0) ...
[16:03:28.882] - nx: 1
[16:03:28.883] - relay: TRUE
[16:03:28.883] - stdout: TRUE
[16:03:28.883] - signal: TRUE
[16:03:28.883] - resignal: FALSE
[16:03:28.883] - force: TRUE
[16:03:28.883] - relayed: [n=1] TRUE
[16:03:28.883] - queued futures: [n=1] TRUE
 - flush all
[16:03:28.883] - relayed: [n=1] TRUE
[16:03:28.883] - queued futures: [n=1] TRUE
[16:03:28.883] signalConditionsASAP(NULL, pos=0) ... done
[16:03:28.884] resolve() on list ... DONE
[16:03:28.884]  - Number of value chunks collected: 1
[16:03:28.884] Resolving 1 futures (chunks) ... DONE
[16:03:28.884] Reducing values from 1 chunks ...
[16:03:28.884]  - Number of values collected after concatenation: 2
[16:03:28.884]  - Number of values expected: 2
[16:03:28.884] Reducing values from 1 chunks ... DONE
[16:03:28.884] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[16:03:28.885] future_mapply() ...
[16:03:28.885] Number of chunks: 1
[16:03:28.885] getGlobalsAndPackagesXApply() ...
[16:03:28.885]  - future.globals: TRUE
[16:03:28.885] getGlobalsAndPackages() ...
[16:03:28.885] Searching for globals...
[16:03:28.887] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:03:28.887] Searching for globals ... DONE
[16:03:28.887] Resolving globals: FALSE
[16:03:28.887] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:03:28.888] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:03:28.889] - globals: [1] ‘FUN’
[16:03:28.889] 
[16:03:28.890] getGlobalsAndPackages() ... DONE
[16:03:28.890]  - globals found/used: [n=1] ‘FUN’
[16:03:28.890]  - needed namespaces: [n=0] 
[16:03:28.890] Finding globals ... DONE
[16:03:28.890] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:03:28.890] List of 2
[16:03:28.890]  $ ...future.FUN:function (x, y)  
[16:03:28.890]  $ MoreArgs     : NULL
[16:03:28.890]  - attr(*, "where")=List of 2
[16:03:28.890]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:28.890]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:03:28.890]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:28.890]  - attr(*, "resolved")= logi FALSE
[16:03:28.890]  - attr(*, "total_size")= num NA
[16:03:28.893] Packages to be attached in all futures: [n=0] 
[16:03:28.893] getGlobalsAndPackagesXApply() ... DONE
[16:03:28.893] Number of futures (= number of chunks): 1
[16:03:28.893] Launching 1 futures (chunks) ...
[16:03:28.893] Chunk #1 of 1 ...
[16:03:28.893]  - Finding globals in '...' for chunk #1 ...
[16:03:28.893] getGlobalsAndPackages() ...
[16:03:28.893] Searching for globals...
[16:03:28.894] 
[16:03:28.894] Searching for globals ... DONE
[16:03:28.894] - globals: [0] <none>
[16:03:28.894] getGlobalsAndPackages() ... DONE
[16:03:28.894]    + additional globals found: [n=0] 
[16:03:28.894]    + additional namespaces needed: [n=0] 
[16:03:28.894]  - Finding globals in '...' for chunk #1 ... DONE
[16:03:28.894]  - seeds: <none>
[16:03:28.894]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:28.895] getGlobalsAndPackages() ...
[16:03:28.895] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:28.895] Resolving globals: FALSE
[16:03:28.895] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[16:03:28.896] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:03:28.896] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:28.896] 
[16:03:28.896] getGlobalsAndPackages() ... DONE
[16:03:28.896] run() for ‘Future’ ...
[16:03:28.896] - state: ‘created’
[16:03:28.897] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:03:28.897] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:28.897] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:28.897]   - Field: ‘label’
[16:03:28.897]   - Field: ‘local’
[16:03:28.897]   - Field: ‘owner’
[16:03:28.897]   - Field: ‘envir’
[16:03:28.897]   - Field: ‘packages’
[16:03:28.897]   - Field: ‘gc’
[16:03:28.898]   - Field: ‘conditions’
[16:03:28.898]   - Field: ‘expr’
[16:03:28.898]   - Field: ‘uuid’
[16:03:28.898]   - Field: ‘seed’
[16:03:28.898]   - Field: ‘version’
[16:03:28.898]   - Field: ‘result’
[16:03:28.898]   - Field: ‘asynchronous’
[16:03:28.898]   - Field: ‘calls’
[16:03:28.898]   - Field: ‘globals’
[16:03:28.898]   - Field: ‘stdout’
[16:03:28.898]   - Field: ‘earlySignal’
[16:03:28.899]   - Field: ‘lazy’
[16:03:28.899]   - Field: ‘state’
[16:03:28.899] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:28.899] - Launch lazy future ...
[16:03:28.899] Packages needed by the future expression (n = 0): <none>
[16:03:28.899] Packages needed by future strategies (n = 0): <none>
[16:03:28.900] {
[16:03:28.900]     {
[16:03:28.900]         {
[16:03:28.900]             ...future.startTime <- base::Sys.time()
[16:03:28.900]             {
[16:03:28.900]                 {
[16:03:28.900]                   {
[16:03:28.900]                     base::local({
[16:03:28.900]                       has_future <- base::requireNamespace("future", 
[16:03:28.900]                         quietly = TRUE)
[16:03:28.900]                       if (has_future) {
[16:03:28.900]                         ns <- base::getNamespace("future")
[16:03:28.900]                         version <- ns[[".package"]][["version"]]
[16:03:28.900]                         if (is.null(version)) 
[16:03:28.900]                           version <- utils::packageVersion("future")
[16:03:28.900]                       }
[16:03:28.900]                       else {
[16:03:28.900]                         version <- NULL
[16:03:28.900]                       }
[16:03:28.900]                       if (!has_future || version < "1.8.0") {
[16:03:28.900]                         info <- base::c(r_version = base::gsub("R version ", 
[16:03:28.900]                           "", base::R.version$version.string), 
[16:03:28.900]                           platform = base::sprintf("%s (%s-bit)", 
[16:03:28.900]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:28.900]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:28.900]                             "release", "version")], collapse = " "), 
[16:03:28.900]                           hostname = base::Sys.info()[["nodename"]])
[16:03:28.900]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:03:28.900]                           info)
[16:03:28.900]                         info <- base::paste(info, collapse = "; ")
[16:03:28.900]                         if (!has_future) {
[16:03:28.900]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:28.900]                             info)
[16:03:28.900]                         }
[16:03:28.900]                         else {
[16:03:28.900]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:28.900]                             info, version)
[16:03:28.900]                         }
[16:03:28.900]                         base::stop(msg)
[16:03:28.900]                       }
[16:03:28.900]                     })
[16:03:28.900]                   }
[16:03:28.900]                   options(future.plan = NULL)
[16:03:28.900]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:28.900]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:28.900]                 }
[16:03:28.900]                 ...future.workdir <- getwd()
[16:03:28.900]             }
[16:03:28.900]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:28.900]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:28.900]         }
[16:03:28.900]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:28.900]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:28.900]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:28.900]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:28.900]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:28.900]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:28.900]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:28.900]             base::names(...future.oldOptions))
[16:03:28.900]     }
[16:03:28.900]     if (FALSE) {
[16:03:28.900]     }
[16:03:28.900]     else {
[16:03:28.900]         if (FALSE) {
[16:03:28.900]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:28.900]                 open = "w")
[16:03:28.900]         }
[16:03:28.900]         else {
[16:03:28.900]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:28.900]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:28.900]         }
[16:03:28.900]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:28.900]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:28.900]             base::sink(type = "output", split = FALSE)
[16:03:28.900]             base::close(...future.stdout)
[16:03:28.900]         }, add = TRUE)
[16:03:28.900]     }
[16:03:28.900]     ...future.frame <- base::sys.nframe()
[16:03:28.900]     ...future.conditions <- base::list()
[16:03:28.900]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:28.900]     if (FALSE) {
[16:03:28.900]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:28.900]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:28.900]     }
[16:03:28.900]     ...future.result <- base::tryCatch({
[16:03:28.900]         base::withCallingHandlers({
[16:03:28.900]             ...future.value <- base::withVisible(base::local({
[16:03:28.900]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:28.900]                 if (!identical(...future.globals.maxSize.org, 
[16:03:28.900]                   ...future.globals.maxSize)) {
[16:03:28.900]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:28.900]                   on.exit(options(oopts), add = TRUE)
[16:03:28.900]                 }
[16:03:28.900]                 {
[16:03:28.900]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:28.900]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:03:28.900]                     USE.NAMES = FALSE)
[16:03:28.900]                   do.call(mapply, args = args)
[16:03:28.900]                 }
[16:03:28.900]             }))
[16:03:28.900]             future::FutureResult(value = ...future.value$value, 
[16:03:28.900]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:28.900]                   ...future.rng), globalenv = if (FALSE) 
[16:03:28.900]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:28.900]                     ...future.globalenv.names))
[16:03:28.900]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:28.900]         }, condition = base::local({
[16:03:28.900]             c <- base::c
[16:03:28.900]             inherits <- base::inherits
[16:03:28.900]             invokeRestart <- base::invokeRestart
[16:03:28.900]             length <- base::length
[16:03:28.900]             list <- base::list
[16:03:28.900]             seq.int <- base::seq.int
[16:03:28.900]             signalCondition <- base::signalCondition
[16:03:28.900]             sys.calls <- base::sys.calls
[16:03:28.900]             `[[` <- base::`[[`
[16:03:28.900]             `+` <- base::`+`
[16:03:28.900]             `<<-` <- base::`<<-`
[16:03:28.900]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:28.900]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:28.900]                   3L)]
[16:03:28.900]             }
[16:03:28.900]             function(cond) {
[16:03:28.900]                 is_error <- inherits(cond, "error")
[16:03:28.900]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:28.900]                   NULL)
[16:03:28.900]                 if (is_error) {
[16:03:28.900]                   sessionInformation <- function() {
[16:03:28.900]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:28.900]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:28.900]                       search = base::search(), system = base::Sys.info())
[16:03:28.900]                   }
[16:03:28.900]                   ...future.conditions[[length(...future.conditions) + 
[16:03:28.900]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:28.900]                     cond$call), session = sessionInformation(), 
[16:03:28.900]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:28.900]                   signalCondition(cond)
[16:03:28.900]                 }
[16:03:28.900]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:28.900]                 "immediateCondition"))) {
[16:03:28.900]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:28.900]                   ...future.conditions[[length(...future.conditions) + 
[16:03:28.900]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:28.900]                   if (TRUE && !signal) {
[16:03:28.900]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:28.900]                     {
[16:03:28.900]                       inherits <- base::inherits
[16:03:28.900]                       invokeRestart <- base::invokeRestart
[16:03:28.900]                       is.null <- base::is.null
[16:03:28.900]                       muffled <- FALSE
[16:03:28.900]                       if (inherits(cond, "message")) {
[16:03:28.900]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:28.900]                         if (muffled) 
[16:03:28.900]                           invokeRestart("muffleMessage")
[16:03:28.900]                       }
[16:03:28.900]                       else if (inherits(cond, "warning")) {
[16:03:28.900]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:28.900]                         if (muffled) 
[16:03:28.900]                           invokeRestart("muffleWarning")
[16:03:28.900]                       }
[16:03:28.900]                       else if (inherits(cond, "condition")) {
[16:03:28.900]                         if (!is.null(pattern)) {
[16:03:28.900]                           computeRestarts <- base::computeRestarts
[16:03:28.900]                           grepl <- base::grepl
[16:03:28.900]                           restarts <- computeRestarts(cond)
[16:03:28.900]                           for (restart in restarts) {
[16:03:28.900]                             name <- restart$name
[16:03:28.900]                             if (is.null(name)) 
[16:03:28.900]                               next
[16:03:28.900]                             if (!grepl(pattern, name)) 
[16:03:28.900]                               next
[16:03:28.900]                             invokeRestart(restart)
[16:03:28.900]                             muffled <- TRUE
[16:03:28.900]                             break
[16:03:28.900]                           }
[16:03:28.900]                         }
[16:03:28.900]                       }
[16:03:28.900]                       invisible(muffled)
[16:03:28.900]                     }
[16:03:28.900]                     muffleCondition(cond, pattern = "^muffle")
[16:03:28.900]                   }
[16:03:28.900]                 }
[16:03:28.900]                 else {
[16:03:28.900]                   if (TRUE) {
[16:03:28.900]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:28.900]                     {
[16:03:28.900]                       inherits <- base::inherits
[16:03:28.900]                       invokeRestart <- base::invokeRestart
[16:03:28.900]                       is.null <- base::is.null
[16:03:28.900]                       muffled <- FALSE
[16:03:28.900]                       if (inherits(cond, "message")) {
[16:03:28.900]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:28.900]                         if (muffled) 
[16:03:28.900]                           invokeRestart("muffleMessage")
[16:03:28.900]                       }
[16:03:28.900]                       else if (inherits(cond, "warning")) {
[16:03:28.900]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:28.900]                         if (muffled) 
[16:03:28.900]                           invokeRestart("muffleWarning")
[16:03:28.900]                       }
[16:03:28.900]                       else if (inherits(cond, "condition")) {
[16:03:28.900]                         if (!is.null(pattern)) {
[16:03:28.900]                           computeRestarts <- base::computeRestarts
[16:03:28.900]                           grepl <- base::grepl
[16:03:28.900]                           restarts <- computeRestarts(cond)
[16:03:28.900]                           for (restart in restarts) {
[16:03:28.900]                             name <- restart$name
[16:03:28.900]                             if (is.null(name)) 
[16:03:28.900]                               next
[16:03:28.900]                             if (!grepl(pattern, name)) 
[16:03:28.900]                               next
[16:03:28.900]                             invokeRestart(restart)
[16:03:28.900]                             muffled <- TRUE
[16:03:28.900]                             break
[16:03:28.900]                           }
[16:03:28.900]                         }
[16:03:28.900]                       }
[16:03:28.900]                       invisible(muffled)
[16:03:28.900]                     }
[16:03:28.900]                     muffleCondition(cond, pattern = "^muffle")
[16:03:28.900]                   }
[16:03:28.900]                 }
[16:03:28.900]             }
[16:03:28.900]         }))
[16:03:28.900]     }, error = function(ex) {
[16:03:28.900]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:28.900]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:28.900]                 ...future.rng), started = ...future.startTime, 
[16:03:28.900]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:28.900]             version = "1.8"), class = "FutureResult")
[16:03:28.900]     }, finally = {
[16:03:28.900]         if (!identical(...future.workdir, getwd())) 
[16:03:28.900]             setwd(...future.workdir)
[16:03:28.900]         {
[16:03:28.900]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:28.900]                 ...future.oldOptions$nwarnings <- NULL
[16:03:28.900]             }
[16:03:28.900]             base::options(...future.oldOptions)
[16:03:28.900]             if (.Platform$OS.type == "windows") {
[16:03:28.900]                 old_names <- names(...future.oldEnvVars)
[16:03:28.900]                 envs <- base::Sys.getenv()
[16:03:28.900]                 names <- names(envs)
[16:03:28.900]                 common <- intersect(names, old_names)
[16:03:28.900]                 added <- setdiff(names, old_names)
[16:03:28.900]                 removed <- setdiff(old_names, names)
[16:03:28.900]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:28.900]                   envs[common]]
[16:03:28.900]                 NAMES <- toupper(changed)
[16:03:28.900]                 args <- list()
[16:03:28.900]                 for (kk in seq_along(NAMES)) {
[16:03:28.900]                   name <- changed[[kk]]
[16:03:28.900]                   NAME <- NAMES[[kk]]
[16:03:28.900]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:28.900]                     next
[16:03:28.900]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:28.900]                 }
[16:03:28.900]                 NAMES <- toupper(added)
[16:03:28.900]                 for (kk in seq_along(NAMES)) {
[16:03:28.900]                   name <- added[[kk]]
[16:03:28.900]                   NAME <- NAMES[[kk]]
[16:03:28.900]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:28.900]                     next
[16:03:28.900]                   args[[name]] <- ""
[16:03:28.900]                 }
[16:03:28.900]                 NAMES <- toupper(removed)
[16:03:28.900]                 for (kk in seq_along(NAMES)) {
[16:03:28.900]                   name <- removed[[kk]]
[16:03:28.900]                   NAME <- NAMES[[kk]]
[16:03:28.900]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:28.900]                     next
[16:03:28.900]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:28.900]                 }
[16:03:28.900]                 if (length(args) > 0) 
[16:03:28.900]                   base::do.call(base::Sys.setenv, args = args)
[16:03:28.900]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:28.900]             }
[16:03:28.900]             else {
[16:03:28.900]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:28.900]             }
[16:03:28.900]             {
[16:03:28.900]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:28.900]                   0L) {
[16:03:28.900]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:28.900]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:28.900]                   base::options(opts)
[16:03:28.900]                 }
[16:03:28.900]                 {
[16:03:28.900]                   {
[16:03:28.900]                     NULL
[16:03:28.900]                     RNGkind("Mersenne-Twister")
[16:03:28.900]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:28.900]                       inherits = FALSE)
[16:03:28.900]                   }
[16:03:28.900]                   options(future.plan = NULL)
[16:03:28.900]                   if (is.na(NA_character_)) 
[16:03:28.900]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:28.900]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:28.900]                   future::plan(list(function (..., envir = parent.frame()) 
[16:03:28.900]                   {
[16:03:28.900]                     future <- SequentialFuture(..., envir = envir)
[16:03:28.900]                     if (!future$lazy) 
[16:03:28.900]                       future <- run(future)
[16:03:28.900]                     invisible(future)
[16:03:28.900]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:28.900]                 }
[16:03:28.900]             }
[16:03:28.900]         }
[16:03:28.900]     })
[16:03:28.900]     if (TRUE) {
[16:03:28.900]         base::sink(type = "output", split = FALSE)
[16:03:28.900]         if (FALSE) {
[16:03:28.900]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:28.900]         }
[16:03:28.900]         else {
[16:03:28.900]             ...future.result["stdout"] <- base::list(NULL)
[16:03:28.900]         }
[16:03:28.900]         base::close(...future.stdout)
[16:03:28.900]         ...future.stdout <- NULL
[16:03:28.900]     }
[16:03:28.900]     ...future.result$conditions <- ...future.conditions
[16:03:28.900]     ...future.result$finished <- base::Sys.time()
[16:03:28.900]     ...future.result
[16:03:28.900] }
[16:03:28.901] assign_globals() ...
[16:03:28.901] List of 5
[16:03:28.901]  $ ...future.FUN            :function (x, y)  
[16:03:28.901]  $ MoreArgs                 : NULL
[16:03:28.901]  $ ...future.elements_ii    :List of 2
[16:03:28.901]   ..$ :List of 2
[16:03:28.901]   .. ..$ : int 1
[16:03:28.901]   .. ..$ : int 0
[16:03:28.901]   ..$ :List of 2
[16:03:28.901]   .. ..$ : int 0
[16:03:28.901]   .. ..$ : int 1
[16:03:28.901]  $ ...future.seeds_ii       : NULL
[16:03:28.901]  $ ...future.globals.maxSize: NULL
[16:03:28.901]  - attr(*, "where")=List of 5
[16:03:28.901]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:28.901]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:03:28.901]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:28.901]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:28.901]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:28.901]  - attr(*, "resolved")= logi FALSE
[16:03:28.901]  - attr(*, "total_size")= num 6480
[16:03:28.901]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:28.901]  - attr(*, "already-done")= logi TRUE
[16:03:28.907] - reassign environment for ‘...future.FUN’
[16:03:28.907] - copied ‘...future.FUN’ to environment
[16:03:28.907] - copied ‘MoreArgs’ to environment
[16:03:28.907] - copied ‘...future.elements_ii’ to environment
[16:03:28.907] - copied ‘...future.seeds_ii’ to environment
[16:03:28.907] - copied ‘...future.globals.maxSize’ to environment
[16:03:28.907] assign_globals() ... done
[16:03:28.907] plan(): Setting new future strategy stack:
[16:03:28.908] List of future strategies:
[16:03:28.908] 1. sequential:
[16:03:28.908]    - args: function (..., envir = parent.frame())
[16:03:28.908]    - tweaked: FALSE
[16:03:28.908]    - call: NULL
[16:03:28.908] plan(): nbrOfWorkers() = 1
[16:03:29.410] plan(): Setting new future strategy stack:
[16:03:29.410] List of future strategies:
[16:03:29.410] 1. sequential:
[16:03:29.410]    - args: function (..., envir = parent.frame())
[16:03:29.410]    - tweaked: FALSE
[16:03:29.410]    - call: plan(strategy)
[16:03:29.410] plan(): nbrOfWorkers() = 1
[16:03:29.410] SequentialFuture started (and completed)
[16:03:29.411] - Launch lazy future ... done
[16:03:29.411] run() for ‘SequentialFuture’ ... done
[16:03:29.411] Created future:
[16:03:29.411] SequentialFuture:
[16:03:29.411] Label: ‘future_mapply-1’
[16:03:29.411] Expression:
[16:03:29.411] {
[16:03:29.411]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:29.411]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:29.411]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:29.411]         on.exit(options(oopts), add = TRUE)
[16:03:29.411]     }
[16:03:29.411]     {
[16:03:29.411]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:29.411]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:03:29.411]         do.call(mapply, args = args)
[16:03:29.411]     }
[16:03:29.411] }
[16:03:29.411] Lazy evaluation: FALSE
[16:03:29.411] Asynchronous evaluation: FALSE
[16:03:29.411] Local evaluation: TRUE
[16:03:29.411] Environment: R_GlobalEnv
[16:03:29.411] Capture standard output: FALSE
[16:03:29.411] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:29.411] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:29.411] Packages: <none>
[16:03:29.411] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:29.411] Resolved: TRUE
[16:03:29.411] Value: 224 bytes of class ‘list’
[16:03:29.411] Early signaling: FALSE
[16:03:29.411] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:29.411] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:29.412] Chunk #1 of 1 ... DONE
[16:03:29.412] Launching 1 futures (chunks) ... DONE
[16:03:29.412] Resolving 1 futures (chunks) ...
[16:03:29.412] resolve() on list ...
[16:03:29.412]  recursive: 0
[16:03:29.412]  length: 1
[16:03:29.413] 
[16:03:29.413] resolved() for ‘SequentialFuture’ ...
[16:03:29.413] - state: ‘finished’
[16:03:29.413] - run: TRUE
[16:03:29.413] - result: ‘FutureResult’
[16:03:29.413] resolved() for ‘SequentialFuture’ ... done
[16:03:29.413] Future #1
[16:03:29.413] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:29.413] - nx: 1
[16:03:29.413] - relay: TRUE
[16:03:29.414] - stdout: TRUE
[16:03:29.414] - signal: TRUE
[16:03:29.414] - resignal: FALSE
[16:03:29.414] - force: TRUE
[16:03:29.414] - relayed: [n=1] FALSE
[16:03:29.414] - queued futures: [n=1] FALSE
[16:03:29.414]  - until=1
[16:03:29.414]  - relaying element #1
[16:03:29.416] - relayed: [n=1] TRUE
[16:03:29.416] - queued futures: [n=1] TRUE
[16:03:29.416] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:29.416]  length: 0 (resolved future 1)
[16:03:29.416] Relaying remaining futures
[16:03:29.416] signalConditionsASAP(NULL, pos=0) ...
[16:03:29.416] - nx: 1
[16:03:29.417] - relay: TRUE
[16:03:29.417] - stdout: TRUE
[16:03:29.417] - signal: TRUE
[16:03:29.417] - resignal: FALSE
[16:03:29.417] - force: TRUE
[16:03:29.417] - relayed: [n=1] TRUE
[16:03:29.417] - queued futures: [n=1] TRUE
 - flush all
[16:03:29.417] - relayed: [n=1] TRUE
[16:03:29.417] - queued futures: [n=1] TRUE
[16:03:29.417] signalConditionsASAP(NULL, pos=0) ... done
[16:03:29.417] resolve() on list ... DONE
[16:03:29.418]  - Number of value chunks collected: 1
[16:03:29.418] Resolving 1 futures (chunks) ... DONE
[16:03:29.418] Reducing values from 1 chunks ...
[16:03:29.418]  - Number of values collected after concatenation: 2
[16:03:29.418]  - Number of values expected: 2
[16:03:29.418] Reducing values from 1 chunks ... DONE
[16:03:29.418] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[16:03:29.419] future_mapply() ...
[16:03:29.419] Number of chunks: 1
[16:03:29.419] getGlobalsAndPackagesXApply() ...
[16:03:29.419]  - future.globals: TRUE
[16:03:29.419] getGlobalsAndPackages() ...
[16:03:29.419] Searching for globals...
[16:03:29.421] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:03:29.421] Searching for globals ... DONE
[16:03:29.421] Resolving globals: FALSE
[16:03:29.421] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:03:29.422] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:03:29.422] - globals: [1] ‘FUN’
[16:03:29.422] 
[16:03:29.422] getGlobalsAndPackages() ... DONE
[16:03:29.422]  - globals found/used: [n=1] ‘FUN’
[16:03:29.422]  - needed namespaces: [n=0] 
[16:03:29.422] Finding globals ... DONE
[16:03:29.422] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:03:29.423] List of 2
[16:03:29.423]  $ ...future.FUN:function (x, y)  
[16:03:29.423]  $ MoreArgs     : NULL
[16:03:29.423]  - attr(*, "where")=List of 2
[16:03:29.423]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:29.423]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:03:29.423]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:29.423]  - attr(*, "resolved")= logi FALSE
[16:03:29.423]  - attr(*, "total_size")= num NA
[16:03:29.425] Packages to be attached in all futures: [n=0] 
[16:03:29.425] getGlobalsAndPackagesXApply() ... DONE
[16:03:29.425] Number of futures (= number of chunks): 1
[16:03:29.425] Launching 1 futures (chunks) ...
[16:03:29.425] Chunk #1 of 1 ...
[16:03:29.426]  - Finding globals in '...' for chunk #1 ...
[16:03:29.426] getGlobalsAndPackages() ...
[16:03:29.426] Searching for globals...
[16:03:29.426] 
[16:03:29.426] Searching for globals ... DONE
[16:03:29.426] - globals: [0] <none>
[16:03:29.426] getGlobalsAndPackages() ... DONE
[16:03:29.426]    + additional globals found: [n=0] 
[16:03:29.427]    + additional namespaces needed: [n=0] 
[16:03:29.427]  - Finding globals in '...' for chunk #1 ... DONE
[16:03:29.427]  - seeds: <none>
[16:03:29.427]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:29.427] getGlobalsAndPackages() ...
[16:03:29.427] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:29.427] Resolving globals: FALSE
[16:03:29.428] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[16:03:29.428] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:03:29.428] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:29.428] 
[16:03:29.428] getGlobalsAndPackages() ... DONE
[16:03:29.429] run() for ‘Future’ ...
[16:03:29.429] - state: ‘created’
[16:03:29.429] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:03:29.429] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:29.429] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:29.429]   - Field: ‘label’
[16:03:29.429]   - Field: ‘local’
[16:03:29.430]   - Field: ‘owner’
[16:03:29.430]   - Field: ‘envir’
[16:03:29.430]   - Field: ‘packages’
[16:03:29.430]   - Field: ‘gc’
[16:03:29.430]   - Field: ‘conditions’
[16:03:29.430]   - Field: ‘expr’
[16:03:29.430]   - Field: ‘uuid’
[16:03:29.430]   - Field: ‘seed’
[16:03:29.430]   - Field: ‘version’
[16:03:29.430]   - Field: ‘result’
[16:03:29.430]   - Field: ‘asynchronous’
[16:03:29.431]   - Field: ‘calls’
[16:03:29.431]   - Field: ‘globals’
[16:03:29.431]   - Field: ‘stdout’
[16:03:29.431]   - Field: ‘earlySignal’
[16:03:29.431]   - Field: ‘lazy’
[16:03:29.431]   - Field: ‘state’
[16:03:29.431] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:29.431] - Launch lazy future ...
[16:03:29.431] Packages needed by the future expression (n = 0): <none>
[16:03:29.432] Packages needed by future strategies (n = 0): <none>
[16:03:29.432] {
[16:03:29.432]     {
[16:03:29.432]         {
[16:03:29.432]             ...future.startTime <- base::Sys.time()
[16:03:29.432]             {
[16:03:29.432]                 {
[16:03:29.432]                   {
[16:03:29.432]                     base::local({
[16:03:29.432]                       has_future <- base::requireNamespace("future", 
[16:03:29.432]                         quietly = TRUE)
[16:03:29.432]                       if (has_future) {
[16:03:29.432]                         ns <- base::getNamespace("future")
[16:03:29.432]                         version <- ns[[".package"]][["version"]]
[16:03:29.432]                         if (is.null(version)) 
[16:03:29.432]                           version <- utils::packageVersion("future")
[16:03:29.432]                       }
[16:03:29.432]                       else {
[16:03:29.432]                         version <- NULL
[16:03:29.432]                       }
[16:03:29.432]                       if (!has_future || version < "1.8.0") {
[16:03:29.432]                         info <- base::c(r_version = base::gsub("R version ", 
[16:03:29.432]                           "", base::R.version$version.string), 
[16:03:29.432]                           platform = base::sprintf("%s (%s-bit)", 
[16:03:29.432]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:29.432]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:29.432]                             "release", "version")], collapse = " "), 
[16:03:29.432]                           hostname = base::Sys.info()[["nodename"]])
[16:03:29.432]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:03:29.432]                           info)
[16:03:29.432]                         info <- base::paste(info, collapse = "; ")
[16:03:29.432]                         if (!has_future) {
[16:03:29.432]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:29.432]                             info)
[16:03:29.432]                         }
[16:03:29.432]                         else {
[16:03:29.432]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:29.432]                             info, version)
[16:03:29.432]                         }
[16:03:29.432]                         base::stop(msg)
[16:03:29.432]                       }
[16:03:29.432]                     })
[16:03:29.432]                   }
[16:03:29.432]                   options(future.plan = NULL)
[16:03:29.432]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:29.432]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:29.432]                 }
[16:03:29.432]                 ...future.workdir <- getwd()
[16:03:29.432]             }
[16:03:29.432]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:29.432]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:29.432]         }
[16:03:29.432]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:29.432]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:29.432]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:29.432]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:29.432]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:29.432]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:29.432]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:29.432]             base::names(...future.oldOptions))
[16:03:29.432]     }
[16:03:29.432]     if (FALSE) {
[16:03:29.432]     }
[16:03:29.432]     else {
[16:03:29.432]         if (TRUE) {
[16:03:29.432]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:29.432]                 open = "w")
[16:03:29.432]         }
[16:03:29.432]         else {
[16:03:29.432]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:29.432]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:29.432]         }
[16:03:29.432]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:29.432]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:29.432]             base::sink(type = "output", split = FALSE)
[16:03:29.432]             base::close(...future.stdout)
[16:03:29.432]         }, add = TRUE)
[16:03:29.432]     }
[16:03:29.432]     ...future.frame <- base::sys.nframe()
[16:03:29.432]     ...future.conditions <- base::list()
[16:03:29.432]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:29.432]     if (FALSE) {
[16:03:29.432]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:29.432]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:29.432]     }
[16:03:29.432]     ...future.result <- base::tryCatch({
[16:03:29.432]         base::withCallingHandlers({
[16:03:29.432]             ...future.value <- base::withVisible(base::local({
[16:03:29.432]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:29.432]                 if (!identical(...future.globals.maxSize.org, 
[16:03:29.432]                   ...future.globals.maxSize)) {
[16:03:29.432]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:29.432]                   on.exit(options(oopts), add = TRUE)
[16:03:29.432]                 }
[16:03:29.432]                 {
[16:03:29.432]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:29.432]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:03:29.432]                     USE.NAMES = FALSE)
[16:03:29.432]                   do.call(mapply, args = args)
[16:03:29.432]                 }
[16:03:29.432]             }))
[16:03:29.432]             future::FutureResult(value = ...future.value$value, 
[16:03:29.432]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:29.432]                   ...future.rng), globalenv = if (FALSE) 
[16:03:29.432]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:29.432]                     ...future.globalenv.names))
[16:03:29.432]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:29.432]         }, condition = base::local({
[16:03:29.432]             c <- base::c
[16:03:29.432]             inherits <- base::inherits
[16:03:29.432]             invokeRestart <- base::invokeRestart
[16:03:29.432]             length <- base::length
[16:03:29.432]             list <- base::list
[16:03:29.432]             seq.int <- base::seq.int
[16:03:29.432]             signalCondition <- base::signalCondition
[16:03:29.432]             sys.calls <- base::sys.calls
[16:03:29.432]             `[[` <- base::`[[`
[16:03:29.432]             `+` <- base::`+`
[16:03:29.432]             `<<-` <- base::`<<-`
[16:03:29.432]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:29.432]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:29.432]                   3L)]
[16:03:29.432]             }
[16:03:29.432]             function(cond) {
[16:03:29.432]                 is_error <- inherits(cond, "error")
[16:03:29.432]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:29.432]                   NULL)
[16:03:29.432]                 if (is_error) {
[16:03:29.432]                   sessionInformation <- function() {
[16:03:29.432]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:29.432]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:29.432]                       search = base::search(), system = base::Sys.info())
[16:03:29.432]                   }
[16:03:29.432]                   ...future.conditions[[length(...future.conditions) + 
[16:03:29.432]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:29.432]                     cond$call), session = sessionInformation(), 
[16:03:29.432]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:29.432]                   signalCondition(cond)
[16:03:29.432]                 }
[16:03:29.432]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:29.432]                 "immediateCondition"))) {
[16:03:29.432]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:29.432]                   ...future.conditions[[length(...future.conditions) + 
[16:03:29.432]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:29.432]                   if (TRUE && !signal) {
[16:03:29.432]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:29.432]                     {
[16:03:29.432]                       inherits <- base::inherits
[16:03:29.432]                       invokeRestart <- base::invokeRestart
[16:03:29.432]                       is.null <- base::is.null
[16:03:29.432]                       muffled <- FALSE
[16:03:29.432]                       if (inherits(cond, "message")) {
[16:03:29.432]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:29.432]                         if (muffled) 
[16:03:29.432]                           invokeRestart("muffleMessage")
[16:03:29.432]                       }
[16:03:29.432]                       else if (inherits(cond, "warning")) {
[16:03:29.432]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:29.432]                         if (muffled) 
[16:03:29.432]                           invokeRestart("muffleWarning")
[16:03:29.432]                       }
[16:03:29.432]                       else if (inherits(cond, "condition")) {
[16:03:29.432]                         if (!is.null(pattern)) {
[16:03:29.432]                           computeRestarts <- base::computeRestarts
[16:03:29.432]                           grepl <- base::grepl
[16:03:29.432]                           restarts <- computeRestarts(cond)
[16:03:29.432]                           for (restart in restarts) {
[16:03:29.432]                             name <- restart$name
[16:03:29.432]                             if (is.null(name)) 
[16:03:29.432]                               next
[16:03:29.432]                             if (!grepl(pattern, name)) 
[16:03:29.432]                               next
[16:03:29.432]                             invokeRestart(restart)
[16:03:29.432]                             muffled <- TRUE
[16:03:29.432]                             break
[16:03:29.432]                           }
[16:03:29.432]                         }
[16:03:29.432]                       }
[16:03:29.432]                       invisible(muffled)
[16:03:29.432]                     }
[16:03:29.432]                     muffleCondition(cond, pattern = "^muffle")
[16:03:29.432]                   }
[16:03:29.432]                 }
[16:03:29.432]                 else {
[16:03:29.432]                   if (TRUE) {
[16:03:29.432]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:29.432]                     {
[16:03:29.432]                       inherits <- base::inherits
[16:03:29.432]                       invokeRestart <- base::invokeRestart
[16:03:29.432]                       is.null <- base::is.null
[16:03:29.432]                       muffled <- FALSE
[16:03:29.432]                       if (inherits(cond, "message")) {
[16:03:29.432]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:29.432]                         if (muffled) 
[16:03:29.432]                           invokeRestart("muffleMessage")
[16:03:29.432]                       }
[16:03:29.432]                       else if (inherits(cond, "warning")) {
[16:03:29.432]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:29.432]                         if (muffled) 
[16:03:29.432]                           invokeRestart("muffleWarning")
[16:03:29.432]                       }
[16:03:29.432]                       else if (inherits(cond, "condition")) {
[16:03:29.432]                         if (!is.null(pattern)) {
[16:03:29.432]                           computeRestarts <- base::computeRestarts
[16:03:29.432]                           grepl <- base::grepl
[16:03:29.432]                           restarts <- computeRestarts(cond)
[16:03:29.432]                           for (restart in restarts) {
[16:03:29.432]                             name <- restart$name
[16:03:29.432]                             if (is.null(name)) 
[16:03:29.432]                               next
[16:03:29.432]                             if (!grepl(pattern, name)) 
[16:03:29.432]                               next
[16:03:29.432]                             invokeRestart(restart)
[16:03:29.432]                             muffled <- TRUE
[16:03:29.432]                             break
[16:03:29.432]                           }
[16:03:29.432]                         }
[16:03:29.432]                       }
[16:03:29.432]                       invisible(muffled)
[16:03:29.432]                     }
[16:03:29.432]                     muffleCondition(cond, pattern = "^muffle")
[16:03:29.432]                   }
[16:03:29.432]                 }
[16:03:29.432]             }
[16:03:29.432]         }))
[16:03:29.432]     }, error = function(ex) {
[16:03:29.432]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:29.432]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:29.432]                 ...future.rng), started = ...future.startTime, 
[16:03:29.432]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:29.432]             version = "1.8"), class = "FutureResult")
[16:03:29.432]     }, finally = {
[16:03:29.432]         if (!identical(...future.workdir, getwd())) 
[16:03:29.432]             setwd(...future.workdir)
[16:03:29.432]         {
[16:03:29.432]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:29.432]                 ...future.oldOptions$nwarnings <- NULL
[16:03:29.432]             }
[16:03:29.432]             base::options(...future.oldOptions)
[16:03:29.432]             if (.Platform$OS.type == "windows") {
[16:03:29.432]                 old_names <- names(...future.oldEnvVars)
[16:03:29.432]                 envs <- base::Sys.getenv()
[16:03:29.432]                 names <- names(envs)
[16:03:29.432]                 common <- intersect(names, old_names)
[16:03:29.432]                 added <- setdiff(names, old_names)
[16:03:29.432]                 removed <- setdiff(old_names, names)
[16:03:29.432]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:29.432]                   envs[common]]
[16:03:29.432]                 NAMES <- toupper(changed)
[16:03:29.432]                 args <- list()
[16:03:29.432]                 for (kk in seq_along(NAMES)) {
[16:03:29.432]                   name <- changed[[kk]]
[16:03:29.432]                   NAME <- NAMES[[kk]]
[16:03:29.432]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:29.432]                     next
[16:03:29.432]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:29.432]                 }
[16:03:29.432]                 NAMES <- toupper(added)
[16:03:29.432]                 for (kk in seq_along(NAMES)) {
[16:03:29.432]                   name <- added[[kk]]
[16:03:29.432]                   NAME <- NAMES[[kk]]
[16:03:29.432]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:29.432]                     next
[16:03:29.432]                   args[[name]] <- ""
[16:03:29.432]                 }
[16:03:29.432]                 NAMES <- toupper(removed)
[16:03:29.432]                 for (kk in seq_along(NAMES)) {
[16:03:29.432]                   name <- removed[[kk]]
[16:03:29.432]                   NAME <- NAMES[[kk]]
[16:03:29.432]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:29.432]                     next
[16:03:29.432]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:29.432]                 }
[16:03:29.432]                 if (length(args) > 0) 
[16:03:29.432]                   base::do.call(base::Sys.setenv, args = args)
[16:03:29.432]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:29.432]             }
[16:03:29.432]             else {
[16:03:29.432]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:29.432]             }
[16:03:29.432]             {
[16:03:29.432]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:29.432]                   0L) {
[16:03:29.432]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:29.432]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:29.432]                   base::options(opts)
[16:03:29.432]                 }
[16:03:29.432]                 {
[16:03:29.432]                   {
[16:03:29.432]                     NULL
[16:03:29.432]                     RNGkind("Mersenne-Twister")
[16:03:29.432]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:29.432]                       inherits = FALSE)
[16:03:29.432]                   }
[16:03:29.432]                   options(future.plan = NULL)
[16:03:29.432]                   if (is.na(NA_character_)) 
[16:03:29.432]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:29.432]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:29.432]                   future::plan(list(function (..., envir = parent.frame()) 
[16:03:29.432]                   {
[16:03:29.432]                     future <- SequentialFuture(..., envir = envir)
[16:03:29.432]                     if (!future$lazy) 
[16:03:29.432]                       future <- run(future)
[16:03:29.432]                     invisible(future)
[16:03:29.432]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:29.432]                 }
[16:03:29.432]             }
[16:03:29.432]         }
[16:03:29.432]     })
[16:03:29.432]     if (TRUE) {
[16:03:29.432]         base::sink(type = "output", split = FALSE)
[16:03:29.432]         if (TRUE) {
[16:03:29.432]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:29.432]         }
[16:03:29.432]         else {
[16:03:29.432]             ...future.result["stdout"] <- base::list(NULL)
[16:03:29.432]         }
[16:03:29.432]         base::close(...future.stdout)
[16:03:29.432]         ...future.stdout <- NULL
[16:03:29.432]     }
[16:03:29.432]     ...future.result$conditions <- ...future.conditions
[16:03:29.432]     ...future.result$finished <- base::Sys.time()
[16:03:29.432]     ...future.result
[16:03:29.432] }
[16:03:29.434] assign_globals() ...
[16:03:29.434] List of 5
[16:03:29.434]  $ ...future.FUN            :function (x, y)  
[16:03:29.434]  $ MoreArgs                 : NULL
[16:03:29.434]  $ ...future.elements_ii    :List of 2
[16:03:29.434]   ..$ :List of 2
[16:03:29.434]   .. ..$ : int 1
[16:03:29.434]   .. ..$ : int 0
[16:03:29.434]   ..$ :List of 2
[16:03:29.434]   .. ..$ : int 0
[16:03:29.434]   .. ..$ : int 1
[16:03:29.434]  $ ...future.seeds_ii       : NULL
[16:03:29.434]  $ ...future.globals.maxSize: NULL
[16:03:29.434]  - attr(*, "where")=List of 5
[16:03:29.434]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:29.434]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:03:29.434]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:29.434]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:29.434]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:29.434]  - attr(*, "resolved")= logi FALSE
[16:03:29.434]  - attr(*, "total_size")= num 6480
[16:03:29.434]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:29.434]  - attr(*, "already-done")= logi TRUE
[16:03:29.440] - reassign environment for ‘...future.FUN’
[16:03:29.440] - copied ‘...future.FUN’ to environment
[16:03:29.440] - copied ‘MoreArgs’ to environment
[16:03:29.440] - copied ‘...future.elements_ii’ to environment
[16:03:29.440] - copied ‘...future.seeds_ii’ to environment
[16:03:29.441] - copied ‘...future.globals.maxSize’ to environment
[16:03:29.441] assign_globals() ... done
[16:03:29.441] plan(): Setting new future strategy stack:
[16:03:29.441] List of future strategies:
[16:03:29.441] 1. sequential:
[16:03:29.441]    - args: function (..., envir = parent.frame())
[16:03:29.441]    - tweaked: FALSE
[16:03:29.441]    - call: NULL
[16:03:29.441] plan(): nbrOfWorkers() = 1
[16:03:29.943] plan(): Setting new future strategy stack:
[16:03:29.943] List of future strategies:
[16:03:29.943] 1. sequential:
[16:03:29.943]    - args: function (..., envir = parent.frame())
[16:03:29.943]    - tweaked: FALSE
[16:03:29.943]    - call: plan(strategy)
[16:03:29.943] plan(): nbrOfWorkers() = 1
[16:03:29.944] SequentialFuture started (and completed)
[16:03:29.944] - Launch lazy future ... done
[16:03:29.944] run() for ‘SequentialFuture’ ... done
[16:03:29.944] Created future:
[16:03:29.944] SequentialFuture:
[16:03:29.944] Label: ‘future_mapply-1’
[16:03:29.944] Expression:
[16:03:29.944] {
[16:03:29.944]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:29.944]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:29.944]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:29.944]         on.exit(options(oopts), add = TRUE)
[16:03:29.944]     }
[16:03:29.944]     {
[16:03:29.944]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:29.944]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:03:29.944]         do.call(mapply, args = args)
[16:03:29.944]     }
[16:03:29.944] }
[16:03:29.944] Lazy evaluation: FALSE
[16:03:29.944] Asynchronous evaluation: FALSE
[16:03:29.944] Local evaluation: TRUE
[16:03:29.944] Environment: R_GlobalEnv
[16:03:29.944] Capture standard output: TRUE
[16:03:29.944] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:29.944] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:29.944] Packages: <none>
[16:03:29.944] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:29.944] Resolved: TRUE
[16:03:29.944] Value: 224 bytes of class ‘list’
[16:03:29.944] Early signaling: FALSE
[16:03:29.944] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:29.944] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:29.945] Chunk #1 of 1 ... DONE
[16:03:29.945] Launching 1 futures (chunks) ... DONE
[16:03:29.945] Resolving 1 futures (chunks) ...
[16:03:29.945] resolve() on list ...
[16:03:29.945]  recursive: 0
[16:03:29.945]  length: 1
[16:03:29.945] 
[16:03:29.946] resolved() for ‘SequentialFuture’ ...
[16:03:29.946] - state: ‘finished’
[16:03:29.946] - run: TRUE
[16:03:29.946] - result: ‘FutureResult’
[16:03:29.946] resolved() for ‘SequentialFuture’ ... done
[16:03:29.946] Future #1
[16:03:29.946] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:29.946] - nx: 1
[16:03:29.946] - relay: TRUE
[16:03:29.946] - stdout: TRUE
[16:03:29.946] - signal: TRUE
[16:03:29.947] - resignal: FALSE
[16:03:29.947] - force: TRUE
[16:03:29.947] - relayed: [n=1] FALSE
[16:03:29.947] - queued futures: [n=1] FALSE
[16:03:29.947]  - until=1
[16:03:29.947]  - relaying element #1
[16:03:29.947] - relayed: [n=1] TRUE
[16:03:29.947] - queued futures: [n=1] TRUE
[16:03:29.947] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:29.947]  length: 0 (resolved future 1)
[16:03:29.948] Relaying remaining futures
[16:03:29.948] signalConditionsASAP(NULL, pos=0) ...
[16:03:29.948] - nx: 1
[16:03:29.948] - relay: TRUE
[16:03:29.948] - stdout: TRUE
[16:03:29.948] - signal: TRUE
[16:03:29.948] - resignal: FALSE
[16:03:29.948] - force: TRUE
[16:03:29.948] - relayed: [n=1] TRUE
[16:03:29.948] - queued futures: [n=1] TRUE
 - flush all
[16:03:29.948] - relayed: [n=1] TRUE
[16:03:29.949] - queued futures: [n=1] TRUE
[16:03:29.949] signalConditionsASAP(NULL, pos=0) ... done
[16:03:29.949] resolve() on list ... DONE
[16:03:29.949]  - Number of value chunks collected: 1
[16:03:29.949] Resolving 1 futures (chunks) ... DONE
[16:03:29.949] Reducing values from 1 chunks ...
[16:03:29.949]  - Number of values collected after concatenation: 2
[16:03:29.949]  - Number of values expected: 2
[16:03:29.949] Reducing values from 1 chunks ... DONE
[16:03:29.949] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[16:03:29.950] future_mapply() ...
[16:03:29.950] Number of chunks: 1
[16:03:29.950] getGlobalsAndPackagesXApply() ...
[16:03:29.950]  - future.globals: TRUE
[16:03:29.950] getGlobalsAndPackages() ...
[16:03:29.950] Searching for globals...
[16:03:29.952] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:03:29.952] Searching for globals ... DONE
[16:03:29.952] Resolving globals: FALSE
[16:03:29.952] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:03:29.953] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:03:29.953] - globals: [1] ‘FUN’
[16:03:29.953] 
[16:03:29.953] getGlobalsAndPackages() ... DONE
[16:03:29.953]  - globals found/used: [n=1] ‘FUN’
[16:03:29.953]  - needed namespaces: [n=0] 
[16:03:29.953] Finding globals ... DONE
[16:03:29.953] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:03:29.953] List of 2
[16:03:29.953]  $ ...future.FUN:function (x, y)  
[16:03:29.953]  $ MoreArgs     : NULL
[16:03:29.953]  - attr(*, "where")=List of 2
[16:03:29.953]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:29.953]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:03:29.953]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:29.953]  - attr(*, "resolved")= logi FALSE
[16:03:29.953]  - attr(*, "total_size")= num NA
[16:03:29.956] Packages to be attached in all futures: [n=0] 
[16:03:29.956] getGlobalsAndPackagesXApply() ... DONE
[16:03:29.956] Number of futures (= number of chunks): 1
[16:03:29.956] Launching 1 futures (chunks) ...
[16:03:29.956] Chunk #1 of 1 ...
[16:03:29.956]  - Finding globals in '...' for chunk #1 ...
[16:03:29.957] getGlobalsAndPackages() ...
[16:03:29.957] Searching for globals...
[16:03:29.957] 
[16:03:29.957] Searching for globals ... DONE
[16:03:29.957] - globals: [0] <none>
[16:03:29.957] getGlobalsAndPackages() ... DONE
[16:03:29.957]    + additional globals found: [n=0] 
[16:03:29.957]    + additional namespaces needed: [n=0] 
[16:03:29.957]  - Finding globals in '...' for chunk #1 ... DONE
[16:03:29.958]  - seeds: <none>
[16:03:29.958]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:29.958] getGlobalsAndPackages() ...
[16:03:29.958] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:29.958] Resolving globals: FALSE
[16:03:29.958] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[16:03:29.959] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:03:29.959] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:29.959] 
[16:03:29.959] getGlobalsAndPackages() ... DONE
[16:03:29.959] run() for ‘Future’ ...
[16:03:29.959] - state: ‘created’
[16:03:29.960] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:03:29.960] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:29.960] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:29.960]   - Field: ‘label’
[16:03:29.960]   - Field: ‘local’
[16:03:29.960]   - Field: ‘owner’
[16:03:29.960]   - Field: ‘envir’
[16:03:29.960]   - Field: ‘packages’
[16:03:29.961]   - Field: ‘gc’
[16:03:29.961]   - Field: ‘conditions’
[16:03:29.961]   - Field: ‘expr’
[16:03:29.961]   - Field: ‘uuid’
[16:03:29.961]   - Field: ‘seed’
[16:03:29.961]   - Field: ‘version’
[16:03:29.961]   - Field: ‘result’
[16:03:29.961]   - Field: ‘asynchronous’
[16:03:29.961]   - Field: ‘calls’
[16:03:29.961]   - Field: ‘globals’
[16:03:29.961]   - Field: ‘stdout’
[16:03:29.961]   - Field: ‘earlySignal’
[16:03:29.962]   - Field: ‘lazy’
[16:03:29.962]   - Field: ‘state’
[16:03:29.962] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:29.962] - Launch lazy future ...
[16:03:29.962] Packages needed by the future expression (n = 0): <none>
[16:03:29.962] Packages needed by future strategies (n = 0): <none>
[16:03:29.963] {
[16:03:29.963]     {
[16:03:29.963]         {
[16:03:29.963]             ...future.startTime <- base::Sys.time()
[16:03:29.963]             {
[16:03:29.963]                 {
[16:03:29.963]                   {
[16:03:29.963]                     base::local({
[16:03:29.963]                       has_future <- base::requireNamespace("future", 
[16:03:29.963]                         quietly = TRUE)
[16:03:29.963]                       if (has_future) {
[16:03:29.963]                         ns <- base::getNamespace("future")
[16:03:29.963]                         version <- ns[[".package"]][["version"]]
[16:03:29.963]                         if (is.null(version)) 
[16:03:29.963]                           version <- utils::packageVersion("future")
[16:03:29.963]                       }
[16:03:29.963]                       else {
[16:03:29.963]                         version <- NULL
[16:03:29.963]                       }
[16:03:29.963]                       if (!has_future || version < "1.8.0") {
[16:03:29.963]                         info <- base::c(r_version = base::gsub("R version ", 
[16:03:29.963]                           "", base::R.version$version.string), 
[16:03:29.963]                           platform = base::sprintf("%s (%s-bit)", 
[16:03:29.963]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:29.963]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:29.963]                             "release", "version")], collapse = " "), 
[16:03:29.963]                           hostname = base::Sys.info()[["nodename"]])
[16:03:29.963]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:03:29.963]                           info)
[16:03:29.963]                         info <- base::paste(info, collapse = "; ")
[16:03:29.963]                         if (!has_future) {
[16:03:29.963]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:29.963]                             info)
[16:03:29.963]                         }
[16:03:29.963]                         else {
[16:03:29.963]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:29.963]                             info, version)
[16:03:29.963]                         }
[16:03:29.963]                         base::stop(msg)
[16:03:29.963]                       }
[16:03:29.963]                     })
[16:03:29.963]                   }
[16:03:29.963]                   options(future.plan = NULL)
[16:03:29.963]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:29.963]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:29.963]                 }
[16:03:29.963]                 ...future.workdir <- getwd()
[16:03:29.963]             }
[16:03:29.963]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:29.963]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:29.963]         }
[16:03:29.963]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:29.963]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:29.963]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:29.963]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:29.963]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:29.963]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:29.963]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:29.963]             base::names(...future.oldOptions))
[16:03:29.963]     }
[16:03:29.963]     if (TRUE) {
[16:03:29.963]     }
[16:03:29.963]     else {
[16:03:29.963]         if (NA) {
[16:03:29.963]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:29.963]                 open = "w")
[16:03:29.963]         }
[16:03:29.963]         else {
[16:03:29.963]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:29.963]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:29.963]         }
[16:03:29.963]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:29.963]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:29.963]             base::sink(type = "output", split = FALSE)
[16:03:29.963]             base::close(...future.stdout)
[16:03:29.963]         }, add = TRUE)
[16:03:29.963]     }
[16:03:29.963]     ...future.frame <- base::sys.nframe()
[16:03:29.963]     ...future.conditions <- base::list()
[16:03:29.963]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:29.963]     if (FALSE) {
[16:03:29.963]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:29.963]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:29.963]     }
[16:03:29.963]     ...future.result <- base::tryCatch({
[16:03:29.963]         base::withCallingHandlers({
[16:03:29.963]             ...future.value <- base::withVisible(base::local({
[16:03:29.963]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:29.963]                 if (!identical(...future.globals.maxSize.org, 
[16:03:29.963]                   ...future.globals.maxSize)) {
[16:03:29.963]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:29.963]                   on.exit(options(oopts), add = TRUE)
[16:03:29.963]                 }
[16:03:29.963]                 {
[16:03:29.963]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:29.963]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:03:29.963]                     USE.NAMES = FALSE)
[16:03:29.963]                   do.call(mapply, args = args)
[16:03:29.963]                 }
[16:03:29.963]             }))
[16:03:29.963]             future::FutureResult(value = ...future.value$value, 
[16:03:29.963]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:29.963]                   ...future.rng), globalenv = if (FALSE) 
[16:03:29.963]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:29.963]                     ...future.globalenv.names))
[16:03:29.963]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:29.963]         }, condition = base::local({
[16:03:29.963]             c <- base::c
[16:03:29.963]             inherits <- base::inherits
[16:03:29.963]             invokeRestart <- base::invokeRestart
[16:03:29.963]             length <- base::length
[16:03:29.963]             list <- base::list
[16:03:29.963]             seq.int <- base::seq.int
[16:03:29.963]             signalCondition <- base::signalCondition
[16:03:29.963]             sys.calls <- base::sys.calls
[16:03:29.963]             `[[` <- base::`[[`
[16:03:29.963]             `+` <- base::`+`
[16:03:29.963]             `<<-` <- base::`<<-`
[16:03:29.963]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:29.963]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:29.963]                   3L)]
[16:03:29.963]             }
[16:03:29.963]             function(cond) {
[16:03:29.963]                 is_error <- inherits(cond, "error")
[16:03:29.963]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:29.963]                   NULL)
[16:03:29.963]                 if (is_error) {
[16:03:29.963]                   sessionInformation <- function() {
[16:03:29.963]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:29.963]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:29.963]                       search = base::search(), system = base::Sys.info())
[16:03:29.963]                   }
[16:03:29.963]                   ...future.conditions[[length(...future.conditions) + 
[16:03:29.963]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:29.963]                     cond$call), session = sessionInformation(), 
[16:03:29.963]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:29.963]                   signalCondition(cond)
[16:03:29.963]                 }
[16:03:29.963]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:29.963]                 "immediateCondition"))) {
[16:03:29.963]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:29.963]                   ...future.conditions[[length(...future.conditions) + 
[16:03:29.963]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:29.963]                   if (TRUE && !signal) {
[16:03:29.963]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:29.963]                     {
[16:03:29.963]                       inherits <- base::inherits
[16:03:29.963]                       invokeRestart <- base::invokeRestart
[16:03:29.963]                       is.null <- base::is.null
[16:03:29.963]                       muffled <- FALSE
[16:03:29.963]                       if (inherits(cond, "message")) {
[16:03:29.963]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:29.963]                         if (muffled) 
[16:03:29.963]                           invokeRestart("muffleMessage")
[16:03:29.963]                       }
[16:03:29.963]                       else if (inherits(cond, "warning")) {
[16:03:29.963]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:29.963]                         if (muffled) 
[16:03:29.963]                           invokeRestart("muffleWarning")
[16:03:29.963]                       }
[16:03:29.963]                       else if (inherits(cond, "condition")) {
[16:03:29.963]                         if (!is.null(pattern)) {
[16:03:29.963]                           computeRestarts <- base::computeRestarts
[16:03:29.963]                           grepl <- base::grepl
[16:03:29.963]                           restarts <- computeRestarts(cond)
[16:03:29.963]                           for (restart in restarts) {
[16:03:29.963]                             name <- restart$name
[16:03:29.963]                             if (is.null(name)) 
[16:03:29.963]                               next
[16:03:29.963]                             if (!grepl(pattern, name)) 
[16:03:29.963]                               next
[16:03:29.963]                             invokeRestart(restart)
[16:03:29.963]                             muffled <- TRUE
[16:03:29.963]                             break
[16:03:29.963]                           }
[16:03:29.963]                         }
[16:03:29.963]                       }
[16:03:29.963]                       invisible(muffled)
[16:03:29.963]                     }
[16:03:29.963]                     muffleCondition(cond, pattern = "^muffle")
[16:03:29.963]                   }
[16:03:29.963]                 }
[16:03:29.963]                 else {
[16:03:29.963]                   if (TRUE) {
[16:03:29.963]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:29.963]                     {
[16:03:29.963]                       inherits <- base::inherits
[16:03:29.963]                       invokeRestart <- base::invokeRestart
[16:03:29.963]                       is.null <- base::is.null
[16:03:29.963]                       muffled <- FALSE
[16:03:29.963]                       if (inherits(cond, "message")) {
[16:03:29.963]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:29.963]                         if (muffled) 
[16:03:29.963]                           invokeRestart("muffleMessage")
[16:03:29.963]                       }
[16:03:29.963]                       else if (inherits(cond, "warning")) {
[16:03:29.963]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:29.963]                         if (muffled) 
[16:03:29.963]                           invokeRestart("muffleWarning")
[16:03:29.963]                       }
[16:03:29.963]                       else if (inherits(cond, "condition")) {
[16:03:29.963]                         if (!is.null(pattern)) {
[16:03:29.963]                           computeRestarts <- base::computeRestarts
[16:03:29.963]                           grepl <- base::grepl
[16:03:29.963]                           restarts <- computeRestarts(cond)
[16:03:29.963]                           for (restart in restarts) {
[16:03:29.963]                             name <- restart$name
[16:03:29.963]                             if (is.null(name)) 
[16:03:29.963]                               next
[16:03:29.963]                             if (!grepl(pattern, name)) 
[16:03:29.963]                               next
[16:03:29.963]                             invokeRestart(restart)
[16:03:29.963]                             muffled <- TRUE
[16:03:29.963]                             break
[16:03:29.963]                           }
[16:03:29.963]                         }
[16:03:29.963]                       }
[16:03:29.963]                       invisible(muffled)
[16:03:29.963]                     }
[16:03:29.963]                     muffleCondition(cond, pattern = "^muffle")
[16:03:29.963]                   }
[16:03:29.963]                 }
[16:03:29.963]             }
[16:03:29.963]         }))
[16:03:29.963]     }, error = function(ex) {
[16:03:29.963]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:29.963]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:29.963]                 ...future.rng), started = ...future.startTime, 
[16:03:29.963]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:29.963]             version = "1.8"), class = "FutureResult")
[16:03:29.963]     }, finally = {
[16:03:29.963]         if (!identical(...future.workdir, getwd())) 
[16:03:29.963]             setwd(...future.workdir)
[16:03:29.963]         {
[16:03:29.963]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:29.963]                 ...future.oldOptions$nwarnings <- NULL
[16:03:29.963]             }
[16:03:29.963]             base::options(...future.oldOptions)
[16:03:29.963]             if (.Platform$OS.type == "windows") {
[16:03:29.963]                 old_names <- names(...future.oldEnvVars)
[16:03:29.963]                 envs <- base::Sys.getenv()
[16:03:29.963]                 names <- names(envs)
[16:03:29.963]                 common <- intersect(names, old_names)
[16:03:29.963]                 added <- setdiff(names, old_names)
[16:03:29.963]                 removed <- setdiff(old_names, names)
[16:03:29.963]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:29.963]                   envs[common]]
[16:03:29.963]                 NAMES <- toupper(changed)
[16:03:29.963]                 args <- list()
[16:03:29.963]                 for (kk in seq_along(NAMES)) {
[16:03:29.963]                   name <- changed[[kk]]
[16:03:29.963]                   NAME <- NAMES[[kk]]
[16:03:29.963]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:29.963]                     next
[16:03:29.963]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:29.963]                 }
[16:03:29.963]                 NAMES <- toupper(added)
[16:03:29.963]                 for (kk in seq_along(NAMES)) {
[16:03:29.963]                   name <- added[[kk]]
[16:03:29.963]                   NAME <- NAMES[[kk]]
[16:03:29.963]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:29.963]                     next
[16:03:29.963]                   args[[name]] <- ""
[16:03:29.963]                 }
[16:03:29.963]                 NAMES <- toupper(removed)
[16:03:29.963]                 for (kk in seq_along(NAMES)) {
[16:03:29.963]                   name <- removed[[kk]]
[16:03:29.963]                   NAME <- NAMES[[kk]]
[16:03:29.963]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:29.963]                     next
[16:03:29.963]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:29.963]                 }
[16:03:29.963]                 if (length(args) > 0) 
[16:03:29.963]                   base::do.call(base::Sys.setenv, args = args)
[16:03:29.963]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:29.963]             }
[16:03:29.963]             else {
[16:03:29.963]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:29.963]             }
[16:03:29.963]             {
[16:03:29.963]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:29.963]                   0L) {
[16:03:29.963]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:29.963]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:29.963]                   base::options(opts)
[16:03:29.963]                 }
[16:03:29.963]                 {
[16:03:29.963]                   {
[16:03:29.963]                     NULL
[16:03:29.963]                     RNGkind("Mersenne-Twister")
[16:03:29.963]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:29.963]                       inherits = FALSE)
[16:03:29.963]                   }
[16:03:29.963]                   options(future.plan = NULL)
[16:03:29.963]                   if (is.na(NA_character_)) 
[16:03:29.963]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:29.963]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:29.963]                   future::plan(list(function (..., envir = parent.frame()) 
[16:03:29.963]                   {
[16:03:29.963]                     future <- SequentialFuture(..., envir = envir)
[16:03:29.963]                     if (!future$lazy) 
[16:03:29.963]                       future <- run(future)
[16:03:29.963]                     invisible(future)
[16:03:29.963]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:29.963]                 }
[16:03:29.963]             }
[16:03:29.963]         }
[16:03:29.963]     })
[16:03:29.963]     if (FALSE) {
[16:03:29.963]         base::sink(type = "output", split = FALSE)
[16:03:29.963]         if (NA) {
[16:03:29.963]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:29.963]         }
[16:03:29.963]         else {
[16:03:29.963]             ...future.result["stdout"] <- base::list(NULL)
[16:03:29.963]         }
[16:03:29.963]         base::close(...future.stdout)
[16:03:29.963]         ...future.stdout <- NULL
[16:03:29.963]     }
[16:03:29.963]     ...future.result$conditions <- ...future.conditions
[16:03:29.963]     ...future.result$finished <- base::Sys.time()
[16:03:29.963]     ...future.result
[16:03:29.963] }
[16:03:29.965] assign_globals() ...
[16:03:29.966] List of 5
[16:03:29.966]  $ ...future.FUN            :function (x, y)  
[16:03:29.966]  $ MoreArgs                 : NULL
[16:03:29.966]  $ ...future.elements_ii    :List of 2
[16:03:29.966]   ..$ :List of 2
[16:03:29.966]   .. ..$ : int 1
[16:03:29.966]   .. ..$ : int 0
[16:03:29.966]   ..$ :List of 2
[16:03:29.966]   .. ..$ : int 0
[16:03:29.966]   .. ..$ : int 1
[16:03:29.966]  $ ...future.seeds_ii       : NULL
[16:03:29.966]  $ ...future.globals.maxSize: NULL
[16:03:29.966]  - attr(*, "where")=List of 5
[16:03:29.966]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:29.966]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:03:29.966]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:29.966]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:29.966]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:29.966]  - attr(*, "resolved")= logi FALSE
[16:03:29.966]  - attr(*, "total_size")= num 6480
[16:03:29.966]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:29.966]  - attr(*, "already-done")= logi TRUE
[16:03:29.971] - reassign environment for ‘...future.FUN’
[16:03:29.971] - copied ‘...future.FUN’ to environment
[16:03:29.971] - copied ‘MoreArgs’ to environment
[16:03:29.971] - copied ‘...future.elements_ii’ to environment
[16:03:29.971] - copied ‘...future.seeds_ii’ to environment
[16:03:29.971] - copied ‘...future.globals.maxSize’ to environment
[16:03:29.972] assign_globals() ... done
[16:03:29.972] plan(): Setting new future strategy stack:
[16:03:29.972] List of future strategies:
[16:03:29.972] 1. sequential:
[16:03:29.972]    - args: function (..., envir = parent.frame())
[16:03:29.972]    - tweaked: FALSE
[16:03:29.972]    - call: NULL
[16:03:29.972] plan(): nbrOfWorkers() = 1
[16:03:30.474] plan(): Setting new future strategy stack:
[16:03:30.474] List of future strategies:
[16:03:30.474] 1. sequential:
[16:03:30.474]    - args: function (..., envir = parent.frame())
[16:03:30.474]    - tweaked: FALSE
[16:03:30.474]    - call: plan(strategy)
[16:03:30.474] plan(): nbrOfWorkers() = 1
[16:03:30.474] SequentialFuture started (and completed)
[16:03:30.474] - Launch lazy future ... done
[16:03:30.475] run() for ‘SequentialFuture’ ... done
[16:03:30.475] Created future:
[16:03:30.475] SequentialFuture:
[16:03:30.475] Label: ‘future_mapply-1’
[16:03:30.475] Expression:
[16:03:30.475] {
[16:03:30.475]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:30.475]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:30.475]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:30.475]         on.exit(options(oopts), add = TRUE)
[16:03:30.475]     }
[16:03:30.475]     {
[16:03:30.475]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:30.475]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:03:30.475]         do.call(mapply, args = args)
[16:03:30.475]     }
[16:03:30.475] }
[16:03:30.475] Lazy evaluation: FALSE
[16:03:30.475] Asynchronous evaluation: FALSE
[16:03:30.475] Local evaluation: TRUE
[16:03:30.475] Environment: R_GlobalEnv
[16:03:30.475] Capture standard output: NA
[16:03:30.475] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:30.475] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:30.475] Packages: <none>
[16:03:30.475] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:30.475] Resolved: TRUE
[16:03:30.475] Value: 224 bytes of class ‘list’
[16:03:30.475] Early signaling: FALSE
[16:03:30.475] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:30.475] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:30.476] Chunk #1 of 1 ... DONE
[16:03:30.476] Launching 1 futures (chunks) ... DONE
[16:03:30.476] Resolving 1 futures (chunks) ...
[16:03:30.476] resolve() on list ...
[16:03:30.476]  recursive: 0
[16:03:30.476]  length: 1
[16:03:30.476] 
[16:03:30.476] resolved() for ‘SequentialFuture’ ...
[16:03:30.476] - state: ‘finished’
[16:03:30.477] - run: TRUE
[16:03:30.477] - result: ‘FutureResult’
[16:03:30.477] resolved() for ‘SequentialFuture’ ... done
[16:03:30.477] Future #1
[16:03:30.477] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:30.477] - nx: 1
[16:03:30.477] - relay: TRUE
[16:03:30.477] - stdout: TRUE
[16:03:30.477] - signal: TRUE
[16:03:30.477] - resignal: FALSE
[16:03:30.477] - force: TRUE
[16:03:30.478] - relayed: [n=1] FALSE
[16:03:30.478] - queued futures: [n=1] FALSE
[16:03:30.478]  - until=1
[16:03:30.478]  - relaying element #1
[16:03:30.478] - relayed: [n=1] TRUE
[16:03:30.478] - queued futures: [n=1] TRUE
[16:03:30.478] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:30.478]  length: 0 (resolved future 1)
[16:03:30.478] Relaying remaining futures
[16:03:30.478] signalConditionsASAP(NULL, pos=0) ...
[16:03:30.478] - nx: 1
[16:03:30.479] - relay: TRUE
[16:03:30.479] - stdout: TRUE
[16:03:30.479] - signal: TRUE
[16:03:30.479] - resignal: FALSE
[16:03:30.479] - force: TRUE
[16:03:30.479] - relayed: [n=1] TRUE
[16:03:30.479] - queued futures: [n=1] TRUE
 - flush all
[16:03:30.479] - relayed: [n=1] TRUE
[16:03:30.479] - queued futures: [n=1] TRUE
[16:03:30.479] signalConditionsASAP(NULL, pos=0) ... done
[16:03:30.480] resolve() on list ... DONE
[16:03:30.480]  - Number of value chunks collected: 1
[16:03:30.480] Resolving 1 futures (chunks) ... DONE
[16:03:30.480] Reducing values from 1 chunks ...
[16:03:30.480]  - Number of values collected after concatenation: 2
[16:03:30.480]  - Number of values expected: 2
[16:03:30.480] Reducing values from 1 chunks ... DONE
[16:03:30.480] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('sequential') ... DONE
* plan('multicore') ...
[16:03:30.481] plan(): Setting new future strategy stack:
[16:03:30.481] List of future strategies:
[16:03:30.481] 1. multicore:
[16:03:30.481]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:30.481]    - tweaked: FALSE
[16:03:30.481]    - call: plan(strategy)
[16:03:30.485] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[16:03:30.485] future_lapply() ...
[16:03:30.489] Number of chunks: 1
[16:03:30.489] getGlobalsAndPackagesXApply() ...
[16:03:30.489]  - future.globals: TRUE
[16:03:30.489] getGlobalsAndPackages() ...
[16:03:30.489] Searching for globals...
[16:03:30.490] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:03:30.491] Searching for globals ... DONE
[16:03:30.491] Resolving globals: FALSE
[16:03:30.491] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:03:30.491] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:03:30.492] - globals: [1] ‘FUN’
[16:03:30.492] 
[16:03:30.492] getGlobalsAndPackages() ... DONE
[16:03:30.492]  - globals found/used: [n=1] ‘FUN’
[16:03:30.492]  - needed namespaces: [n=0] 
[16:03:30.492] Finding globals ... DONE
[16:03:30.492]  - use_args: TRUE
[16:03:30.492]  - Getting '...' globals ...
[16:03:30.492] resolve() on list ...
[16:03:30.494]  recursive: 0
[16:03:30.494]  length: 1
[16:03:30.494]  elements: ‘...’
[16:03:30.494]  length: 0 (resolved future 1)
[16:03:30.494] resolve() on list ... DONE
[16:03:30.495]    - '...' content: [n=0] 
[16:03:30.495] List of 1
[16:03:30.495]  $ ...: list()
[16:03:30.495]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:30.495]  - attr(*, "where")=List of 1
[16:03:30.495]   ..$ ...:<environment: 0x55ed7a6fa4f0> 
[16:03:30.495]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:30.495]  - attr(*, "resolved")= logi TRUE
[16:03:30.495]  - attr(*, "total_size")= num NA
[16:03:30.497]  - Getting '...' globals ... DONE
[16:03:30.497] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:03:30.497] List of 2
[16:03:30.497]  $ ...future.FUN:function (x)  
[16:03:30.497]  $ ...          : list()
[16:03:30.497]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:30.497]  - attr(*, "where")=List of 2
[16:03:30.497]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:30.497]   ..$ ...          :<environment: 0x55ed7a6fa4f0> 
[16:03:30.497]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:30.497]  - attr(*, "resolved")= logi FALSE
[16:03:30.497]  - attr(*, "total_size")= num 4720
[16:03:30.500] Packages to be attached in all futures: [n=0] 
[16:03:30.500] getGlobalsAndPackagesXApply() ... DONE
[16:03:30.500] Number of futures (= number of chunks): 1
[16:03:30.500] Launching 1 futures (chunks) ...
[16:03:30.501] Chunk #1 of 1 ...
[16:03:30.501]  - Finding globals in 'X' for chunk #1 ...
[16:03:30.501] getGlobalsAndPackages() ...
[16:03:30.501] Searching for globals...
[16:03:30.501] 
[16:03:30.501] Searching for globals ... DONE
[16:03:30.501] - globals: [0] <none>
[16:03:30.501] getGlobalsAndPackages() ... DONE
[16:03:30.501]    + additional globals found: [n=0] 
[16:03:30.501]    + additional namespaces needed: [n=0] 
[16:03:30.502]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:30.502]  - seeds: <none>
[16:03:30.502]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:30.502] getGlobalsAndPackages() ...
[16:03:30.502] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:30.502] Resolving globals: FALSE
[16:03:30.502] Tweak future expression to call with '...' arguments ...
[16:03:30.502] {
[16:03:30.502]     do.call(function(...) {
[16:03:30.502]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:30.502]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:30.502]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:30.502]             on.exit(options(oopts), add = TRUE)
[16:03:30.502]         }
[16:03:30.502]         {
[16:03:30.502]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:30.502]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:30.502]                 ...future.FUN(...future.X_jj, ...)
[16:03:30.502]             })
[16:03:30.502]         }
[16:03:30.502]     }, args = future.call.arguments)
[16:03:30.502] }
[16:03:30.503] Tweak future expression to call with '...' arguments ... DONE
[16:03:30.503] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:30.503] 
[16:03:30.503] getGlobalsAndPackages() ... DONE
[16:03:30.503] run() for ‘Future’ ...
[16:03:30.503] - state: ‘created’
[16:03:30.504] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:30.507] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:30.507] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:30.507]   - Field: ‘label’
[16:03:30.507]   - Field: ‘local’
[16:03:30.507]   - Field: ‘owner’
[16:03:30.507]   - Field: ‘envir’
[16:03:30.507]   - Field: ‘packages’
[16:03:30.507]   - Field: ‘gc’
[16:03:30.508]   - Field: ‘conditions’
[16:03:30.508]   - Field: ‘expr’
[16:03:30.508]   - Field: ‘uuid’
[16:03:30.508]   - Field: ‘seed’
[16:03:30.508]   - Field: ‘version’
[16:03:30.508]   - Field: ‘result’
[16:03:30.508]   - Field: ‘asynchronous’
[16:03:30.508]   - Field: ‘calls’
[16:03:30.508]   - Field: ‘globals’
[16:03:30.508]   - Field: ‘stdout’
[16:03:30.508]   - Field: ‘earlySignal’
[16:03:30.509]   - Field: ‘lazy’
[16:03:30.509]   - Field: ‘state’
[16:03:30.509] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:30.509] - Launch lazy future ...
[16:03:30.509] Packages needed by the future expression (n = 0): <none>
[16:03:30.509] Packages needed by future strategies (n = 0): <none>
[16:03:30.510] {
[16:03:30.510]     {
[16:03:30.510]         {
[16:03:30.510]             ...future.startTime <- base::Sys.time()
[16:03:30.510]             {
[16:03:30.510]                 {
[16:03:30.510]                   {
[16:03:30.510]                     base::local({
[16:03:30.510]                       has_future <- base::requireNamespace("future", 
[16:03:30.510]                         quietly = TRUE)
[16:03:30.510]                       if (has_future) {
[16:03:30.510]                         ns <- base::getNamespace("future")
[16:03:30.510]                         version <- ns[[".package"]][["version"]]
[16:03:30.510]                         if (is.null(version)) 
[16:03:30.510]                           version <- utils::packageVersion("future")
[16:03:30.510]                       }
[16:03:30.510]                       else {
[16:03:30.510]                         version <- NULL
[16:03:30.510]                       }
[16:03:30.510]                       if (!has_future || version < "1.8.0") {
[16:03:30.510]                         info <- base::c(r_version = base::gsub("R version ", 
[16:03:30.510]                           "", base::R.version$version.string), 
[16:03:30.510]                           platform = base::sprintf("%s (%s-bit)", 
[16:03:30.510]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:30.510]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:30.510]                             "release", "version")], collapse = " "), 
[16:03:30.510]                           hostname = base::Sys.info()[["nodename"]])
[16:03:30.510]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:03:30.510]                           info)
[16:03:30.510]                         info <- base::paste(info, collapse = "; ")
[16:03:30.510]                         if (!has_future) {
[16:03:30.510]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:30.510]                             info)
[16:03:30.510]                         }
[16:03:30.510]                         else {
[16:03:30.510]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:30.510]                             info, version)
[16:03:30.510]                         }
[16:03:30.510]                         base::stop(msg)
[16:03:30.510]                       }
[16:03:30.510]                     })
[16:03:30.510]                   }
[16:03:30.510]                   options(future.plan = NULL)
[16:03:30.510]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:30.510]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:30.510]                 }
[16:03:30.510]                 ...future.workdir <- getwd()
[16:03:30.510]             }
[16:03:30.510]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:30.510]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:30.510]         }
[16:03:30.510]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:30.510]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:30.510]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:30.510]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:30.510]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:30.510]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:30.510]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:30.510]             base::names(...future.oldOptions))
[16:03:30.510]     }
[16:03:30.510]     if (FALSE) {
[16:03:30.510]     }
[16:03:30.510]     else {
[16:03:30.510]         if (FALSE) {
[16:03:30.510]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:30.510]                 open = "w")
[16:03:30.510]         }
[16:03:30.510]         else {
[16:03:30.510]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:30.510]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:30.510]         }
[16:03:30.510]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:30.510]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:30.510]             base::sink(type = "output", split = FALSE)
[16:03:30.510]             base::close(...future.stdout)
[16:03:30.510]         }, add = TRUE)
[16:03:30.510]     }
[16:03:30.510]     ...future.frame <- base::sys.nframe()
[16:03:30.510]     ...future.conditions <- base::list()
[16:03:30.510]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:30.510]     if (FALSE) {
[16:03:30.510]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:30.510]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:30.510]     }
[16:03:30.510]     ...future.result <- base::tryCatch({
[16:03:30.510]         base::withCallingHandlers({
[16:03:30.510]             ...future.value <- base::withVisible(base::local({
[16:03:30.510]                 do.call(function(...) {
[16:03:30.510]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:30.510]                   if (!identical(...future.globals.maxSize.org, 
[16:03:30.510]                     ...future.globals.maxSize)) {
[16:03:30.510]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:30.510]                     on.exit(options(oopts), add = TRUE)
[16:03:30.510]                   }
[16:03:30.510]                   {
[16:03:30.510]                     lapply(seq_along(...future.elements_ii), 
[16:03:30.510]                       FUN = function(jj) {
[16:03:30.510]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:30.510]                         ...future.FUN(...future.X_jj, ...)
[16:03:30.510]                       })
[16:03:30.510]                   }
[16:03:30.510]                 }, args = future.call.arguments)
[16:03:30.510]             }))
[16:03:30.510]             future::FutureResult(value = ...future.value$value, 
[16:03:30.510]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:30.510]                   ...future.rng), globalenv = if (FALSE) 
[16:03:30.510]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:30.510]                     ...future.globalenv.names))
[16:03:30.510]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:30.510]         }, condition = base::local({
[16:03:30.510]             c <- base::c
[16:03:30.510]             inherits <- base::inherits
[16:03:30.510]             invokeRestart <- base::invokeRestart
[16:03:30.510]             length <- base::length
[16:03:30.510]             list <- base::list
[16:03:30.510]             seq.int <- base::seq.int
[16:03:30.510]             signalCondition <- base::signalCondition
[16:03:30.510]             sys.calls <- base::sys.calls
[16:03:30.510]             `[[` <- base::`[[`
[16:03:30.510]             `+` <- base::`+`
[16:03:30.510]             `<<-` <- base::`<<-`
[16:03:30.510]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:30.510]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:30.510]                   3L)]
[16:03:30.510]             }
[16:03:30.510]             function(cond) {
[16:03:30.510]                 is_error <- inherits(cond, "error")
[16:03:30.510]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:30.510]                   NULL)
[16:03:30.510]                 if (is_error) {
[16:03:30.510]                   sessionInformation <- function() {
[16:03:30.510]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:30.510]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:30.510]                       search = base::search(), system = base::Sys.info())
[16:03:30.510]                   }
[16:03:30.510]                   ...future.conditions[[length(...future.conditions) + 
[16:03:30.510]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:30.510]                     cond$call), session = sessionInformation(), 
[16:03:30.510]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:30.510]                   signalCondition(cond)
[16:03:30.510]                 }
[16:03:30.510]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:30.510]                 "immediateCondition"))) {
[16:03:30.510]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:30.510]                   ...future.conditions[[length(...future.conditions) + 
[16:03:30.510]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:30.510]                   if (TRUE && !signal) {
[16:03:30.510]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:30.510]                     {
[16:03:30.510]                       inherits <- base::inherits
[16:03:30.510]                       invokeRestart <- base::invokeRestart
[16:03:30.510]                       is.null <- base::is.null
[16:03:30.510]                       muffled <- FALSE
[16:03:30.510]                       if (inherits(cond, "message")) {
[16:03:30.510]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:30.510]                         if (muffled) 
[16:03:30.510]                           invokeRestart("muffleMessage")
[16:03:30.510]                       }
[16:03:30.510]                       else if (inherits(cond, "warning")) {
[16:03:30.510]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:30.510]                         if (muffled) 
[16:03:30.510]                           invokeRestart("muffleWarning")
[16:03:30.510]                       }
[16:03:30.510]                       else if (inherits(cond, "condition")) {
[16:03:30.510]                         if (!is.null(pattern)) {
[16:03:30.510]                           computeRestarts <- base::computeRestarts
[16:03:30.510]                           grepl <- base::grepl
[16:03:30.510]                           restarts <- computeRestarts(cond)
[16:03:30.510]                           for (restart in restarts) {
[16:03:30.510]                             name <- restart$name
[16:03:30.510]                             if (is.null(name)) 
[16:03:30.510]                               next
[16:03:30.510]                             if (!grepl(pattern, name)) 
[16:03:30.510]                               next
[16:03:30.510]                             invokeRestart(restart)
[16:03:30.510]                             muffled <- TRUE
[16:03:30.510]                             break
[16:03:30.510]                           }
[16:03:30.510]                         }
[16:03:30.510]                       }
[16:03:30.510]                       invisible(muffled)
[16:03:30.510]                     }
[16:03:30.510]                     muffleCondition(cond, pattern = "^muffle")
[16:03:30.510]                   }
[16:03:30.510]                 }
[16:03:30.510]                 else {
[16:03:30.510]                   if (TRUE) {
[16:03:30.510]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:30.510]                     {
[16:03:30.510]                       inherits <- base::inherits
[16:03:30.510]                       invokeRestart <- base::invokeRestart
[16:03:30.510]                       is.null <- base::is.null
[16:03:30.510]                       muffled <- FALSE
[16:03:30.510]                       if (inherits(cond, "message")) {
[16:03:30.510]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:30.510]                         if (muffled) 
[16:03:30.510]                           invokeRestart("muffleMessage")
[16:03:30.510]                       }
[16:03:30.510]                       else if (inherits(cond, "warning")) {
[16:03:30.510]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:30.510]                         if (muffled) 
[16:03:30.510]                           invokeRestart("muffleWarning")
[16:03:30.510]                       }
[16:03:30.510]                       else if (inherits(cond, "condition")) {
[16:03:30.510]                         if (!is.null(pattern)) {
[16:03:30.510]                           computeRestarts <- base::computeRestarts
[16:03:30.510]                           grepl <- base::grepl
[16:03:30.510]                           restarts <- computeRestarts(cond)
[16:03:30.510]                           for (restart in restarts) {
[16:03:30.510]                             name <- restart$name
[16:03:30.510]                             if (is.null(name)) 
[16:03:30.510]                               next
[16:03:30.510]                             if (!grepl(pattern, name)) 
[16:03:30.510]                               next
[16:03:30.510]                             invokeRestart(restart)
[16:03:30.510]                             muffled <- TRUE
[16:03:30.510]                             break
[16:03:30.510]                           }
[16:03:30.510]                         }
[16:03:30.510]                       }
[16:03:30.510]                       invisible(muffled)
[16:03:30.510]                     }
[16:03:30.510]                     muffleCondition(cond, pattern = "^muffle")
[16:03:30.510]                   }
[16:03:30.510]                 }
[16:03:30.510]             }
[16:03:30.510]         }))
[16:03:30.510]     }, error = function(ex) {
[16:03:30.510]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:30.510]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:30.510]                 ...future.rng), started = ...future.startTime, 
[16:03:30.510]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:30.510]             version = "1.8"), class = "FutureResult")
[16:03:30.510]     }, finally = {
[16:03:30.510]         if (!identical(...future.workdir, getwd())) 
[16:03:30.510]             setwd(...future.workdir)
[16:03:30.510]         {
[16:03:30.510]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:30.510]                 ...future.oldOptions$nwarnings <- NULL
[16:03:30.510]             }
[16:03:30.510]             base::options(...future.oldOptions)
[16:03:30.510]             if (.Platform$OS.type == "windows") {
[16:03:30.510]                 old_names <- names(...future.oldEnvVars)
[16:03:30.510]                 envs <- base::Sys.getenv()
[16:03:30.510]                 names <- names(envs)
[16:03:30.510]                 common <- intersect(names, old_names)
[16:03:30.510]                 added <- setdiff(names, old_names)
[16:03:30.510]                 removed <- setdiff(old_names, names)
[16:03:30.510]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:30.510]                   envs[common]]
[16:03:30.510]                 NAMES <- toupper(changed)
[16:03:30.510]                 args <- list()
[16:03:30.510]                 for (kk in seq_along(NAMES)) {
[16:03:30.510]                   name <- changed[[kk]]
[16:03:30.510]                   NAME <- NAMES[[kk]]
[16:03:30.510]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:30.510]                     next
[16:03:30.510]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:30.510]                 }
[16:03:30.510]                 NAMES <- toupper(added)
[16:03:30.510]                 for (kk in seq_along(NAMES)) {
[16:03:30.510]                   name <- added[[kk]]
[16:03:30.510]                   NAME <- NAMES[[kk]]
[16:03:30.510]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:30.510]                     next
[16:03:30.510]                   args[[name]] <- ""
[16:03:30.510]                 }
[16:03:30.510]                 NAMES <- toupper(removed)
[16:03:30.510]                 for (kk in seq_along(NAMES)) {
[16:03:30.510]                   name <- removed[[kk]]
[16:03:30.510]                   NAME <- NAMES[[kk]]
[16:03:30.510]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:30.510]                     next
[16:03:30.510]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:30.510]                 }
[16:03:30.510]                 if (length(args) > 0) 
[16:03:30.510]                   base::do.call(base::Sys.setenv, args = args)
[16:03:30.510]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:30.510]             }
[16:03:30.510]             else {
[16:03:30.510]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:30.510]             }
[16:03:30.510]             {
[16:03:30.510]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:30.510]                   0L) {
[16:03:30.510]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:30.510]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:30.510]                   base::options(opts)
[16:03:30.510]                 }
[16:03:30.510]                 {
[16:03:30.510]                   {
[16:03:30.510]                     NULL
[16:03:30.510]                     RNGkind("Mersenne-Twister")
[16:03:30.510]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:30.510]                       inherits = FALSE)
[16:03:30.510]                   }
[16:03:30.510]                   options(future.plan = NULL)
[16:03:30.510]                   if (is.na(NA_character_)) 
[16:03:30.510]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:30.510]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:30.510]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:30.510]                     envir = parent.frame()) 
[16:03:30.510]                   {
[16:03:30.510]                     default_workers <- missing(workers)
[16:03:30.510]                     if (is.function(workers)) 
[16:03:30.510]                       workers <- workers()
[16:03:30.510]                     workers <- structure(as.integer(workers), 
[16:03:30.510]                       class = class(workers))
[16:03:30.510]                     stop_if_not(is.finite(workers), workers >= 
[16:03:30.510]                       1L)
[16:03:30.510]                     if ((workers == 1L && !inherits(workers, 
[16:03:30.510]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:30.510]                       if (default_workers) 
[16:03:30.510]                         supportsMulticore(warn = TRUE)
[16:03:30.510]                       return(sequential(..., envir = envir))
[16:03:30.510]                     }
[16:03:30.510]                     oopts <- options(mc.cores = workers)
[16:03:30.510]                     on.exit(options(oopts))
[16:03:30.510]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:30.510]                       envir = envir)
[16:03:30.510]                     if (!future$lazy) 
[16:03:30.510]                       future <- run(future)
[16:03:30.510]                     invisible(future)
[16:03:30.510]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:30.510]                 }
[16:03:30.510]             }
[16:03:30.510]         }
[16:03:30.510]     })
[16:03:30.510]     if (TRUE) {
[16:03:30.510]         base::sink(type = "output", split = FALSE)
[16:03:30.510]         if (FALSE) {
[16:03:30.510]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:30.510]         }
[16:03:30.510]         else {
[16:03:30.510]             ...future.result["stdout"] <- base::list(NULL)
[16:03:30.510]         }
[16:03:30.510]         base::close(...future.stdout)
[16:03:30.510]         ...future.stdout <- NULL
[16:03:30.510]     }
[16:03:30.510]     ...future.result$conditions <- ...future.conditions
[16:03:30.510]     ...future.result$finished <- base::Sys.time()
[16:03:30.510]     ...future.result
[16:03:30.510] }
[16:03:30.511] assign_globals() ...
[16:03:30.511] List of 5
[16:03:30.511]  $ ...future.FUN            :function (x)  
[16:03:30.511]  $ future.call.arguments    : list()
[16:03:30.511]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:30.511]  $ ...future.elements_ii    :List of 2
[16:03:30.511]   ..$ : int 1
[16:03:30.511]   ..$ : int 0
[16:03:30.511]  $ ...future.seeds_ii       : NULL
[16:03:30.511]  $ ...future.globals.maxSize: NULL
[16:03:30.511]  - attr(*, "where")=List of 5
[16:03:30.511]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:30.511]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:30.511]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:30.511]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:30.511]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:30.511]  - attr(*, "resolved")= logi FALSE
[16:03:30.511]  - attr(*, "total_size")= num 4720
[16:03:30.511]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:30.511]  - attr(*, "already-done")= logi TRUE
[16:03:30.516] - reassign environment for ‘...future.FUN’
[16:03:30.516] - copied ‘...future.FUN’ to environment
[16:03:30.516] - copied ‘future.call.arguments’ to environment
[16:03:30.516] - copied ‘...future.elements_ii’ to environment
[16:03:30.516] - copied ‘...future.seeds_ii’ to environment
[16:03:30.516] - copied ‘...future.globals.maxSize’ to environment
[16:03:30.517] assign_globals() ... done
[16:03:30.517] plan(): Setting new future strategy stack:
[16:03:30.517] List of future strategies:
[16:03:30.517] 1. sequential:
[16:03:30.517]    - args: function (..., envir = parent.frame())
[16:03:30.517]    - tweaked: FALSE
[16:03:30.517]    - call: NULL
[16:03:30.517] plan(): nbrOfWorkers() = 1
[16:03:31.019] plan(): Setting new future strategy stack:
[16:03:31.019] List of future strategies:
[16:03:31.019] 1. multicore:
[16:03:31.019]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:31.019]    - tweaked: FALSE
[16:03:31.019]    - call: plan(strategy)
[16:03:31.024] plan(): nbrOfWorkers() = 1
[16:03:31.024] SequentialFuture started (and completed)
[16:03:31.024] - Launch lazy future ... done
[16:03:31.025] run() for ‘SequentialFuture’ ... done
[16:03:31.025] Created future:
[16:03:31.025] SequentialFuture:
[16:03:31.025] Label: ‘future_lapply-1’
[16:03:31.025] Expression:
[16:03:31.025] {
[16:03:31.025]     do.call(function(...) {
[16:03:31.025]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:31.025]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:31.025]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:31.025]             on.exit(options(oopts), add = TRUE)
[16:03:31.025]         }
[16:03:31.025]         {
[16:03:31.025]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:31.025]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:31.025]                 ...future.FUN(...future.X_jj, ...)
[16:03:31.025]             })
[16:03:31.025]         }
[16:03:31.025]     }, args = future.call.arguments)
[16:03:31.025] }
[16:03:31.025] Lazy evaluation: FALSE
[16:03:31.025] Asynchronous evaluation: FALSE
[16:03:31.025] Local evaluation: TRUE
[16:03:31.025] Environment: R_GlobalEnv
[16:03:31.025] Capture standard output: FALSE
[16:03:31.025] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:31.025] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:31.025] Packages: <none>
[16:03:31.025] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:31.025] Resolved: TRUE
[16:03:31.025] Value: 112 bytes of class ‘list’
[16:03:31.025] Early signaling: FALSE
[16:03:31.025] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:31.025] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:31.026] Chunk #1 of 1 ... DONE
[16:03:31.026] Launching 1 futures (chunks) ... DONE
[16:03:31.026] Resolving 1 futures (chunks) ...
[16:03:31.026] resolve() on list ...
[16:03:31.026]  recursive: 0
[16:03:31.026]  length: 1
[16:03:31.026] 
[16:03:31.026] resolved() for ‘SequentialFuture’ ...
[16:03:31.027] - state: ‘finished’
[16:03:31.027] - run: TRUE
[16:03:31.027] - result: ‘FutureResult’
[16:03:31.027] resolved() for ‘SequentialFuture’ ... done
[16:03:31.027] Future #1
[16:03:31.027] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:31.027] - nx: 1
[16:03:31.027] - relay: TRUE
[16:03:31.027] - stdout: TRUE
[16:03:31.028] - signal: TRUE
[16:03:31.028] - resignal: FALSE
[16:03:31.028] - force: TRUE
[16:03:31.028] - relayed: [n=1] FALSE
[16:03:31.028] - queued futures: [n=1] FALSE
[16:03:31.028]  - until=1
[16:03:31.028]  - relaying element #1
[16:03:31.028] - relayed: [n=1] TRUE
[16:03:31.028] - queued futures: [n=1] TRUE
[16:03:31.028] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:31.029]  length: 0 (resolved future 1)
[16:03:31.029] Relaying remaining futures
[16:03:31.029] signalConditionsASAP(NULL, pos=0) ...
[16:03:31.029] - nx: 1
[16:03:31.029] - relay: TRUE
[16:03:31.029] - stdout: TRUE
[16:03:31.029] - signal: TRUE
[16:03:31.029] - resignal: FALSE
[16:03:31.029] - force: TRUE
[16:03:31.029] - relayed: [n=1] TRUE
[16:03:31.029] - queued futures: [n=1] TRUE
 - flush all
[16:03:31.029] - relayed: [n=1] TRUE
[16:03:31.030] - queued futures: [n=1] TRUE
[16:03:31.030] signalConditionsASAP(NULL, pos=0) ... done
[16:03:31.030] resolve() on list ... DONE
[16:03:31.030]  - Number of value chunks collected: 1
[16:03:31.030] Resolving 1 futures (chunks) ... DONE
[16:03:31.030] Reducing values from 1 chunks ...
[16:03:31.030]  - Number of values collected after concatenation: 2
[16:03:31.030]  - Number of values expected: 2
[16:03:31.030] Reducing values from 1 chunks ... DONE
[16:03:31.030] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[16:03:31.031] future_lapply() ...
[16:03:31.034] Number of chunks: 1
[16:03:31.034] getGlobalsAndPackagesXApply() ...
[16:03:31.035]  - future.globals: TRUE
[16:03:31.035] getGlobalsAndPackages() ...
[16:03:31.035] Searching for globals...
[16:03:31.036] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:03:31.036] Searching for globals ... DONE
[16:03:31.036] Resolving globals: FALSE
[16:03:31.037] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:03:31.037] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:03:31.037] - globals: [1] ‘FUN’
[16:03:31.037] 
[16:03:31.037] getGlobalsAndPackages() ... DONE
[16:03:31.037]  - globals found/used: [n=1] ‘FUN’
[16:03:31.038]  - needed namespaces: [n=0] 
[16:03:31.038] Finding globals ... DONE
[16:03:31.038]  - use_args: TRUE
[16:03:31.038]  - Getting '...' globals ...
[16:03:31.038] resolve() on list ...
[16:03:31.038]  recursive: 0
[16:03:31.038]  length: 1
[16:03:31.038]  elements: ‘...’
[16:03:31.038]  length: 0 (resolved future 1)
[16:03:31.039] resolve() on list ... DONE
[16:03:31.039]    - '...' content: [n=0] 
[16:03:31.039] List of 1
[16:03:31.039]  $ ...: list()
[16:03:31.039]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:31.039]  - attr(*, "where")=List of 1
[16:03:31.039]   ..$ ...:<environment: 0x55ed792850d8> 
[16:03:31.039]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:31.039]  - attr(*, "resolved")= logi TRUE
[16:03:31.039]  - attr(*, "total_size")= num NA
[16:03:31.041]  - Getting '...' globals ... DONE
[16:03:31.041] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:03:31.042] List of 2
[16:03:31.042]  $ ...future.FUN:function (x)  
[16:03:31.042]  $ ...          : list()
[16:03:31.042]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:31.042]  - attr(*, "where")=List of 2
[16:03:31.042]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:31.042]   ..$ ...          :<environment: 0x55ed792850d8> 
[16:03:31.042]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:31.042]  - attr(*, "resolved")= logi FALSE
[16:03:31.042]  - attr(*, "total_size")= num 4720
[16:03:31.044] Packages to be attached in all futures: [n=0] 
[16:03:31.044] getGlobalsAndPackagesXApply() ... DONE
[16:03:31.044] Number of futures (= number of chunks): 1
[16:03:31.045] Launching 1 futures (chunks) ...
[16:03:31.045] Chunk #1 of 1 ...
[16:03:31.045]  - Finding globals in 'X' for chunk #1 ...
[16:03:31.045] getGlobalsAndPackages() ...
[16:03:31.045] Searching for globals...
[16:03:31.045] 
[16:03:31.045] Searching for globals ... DONE
[16:03:31.045] - globals: [0] <none>
[16:03:31.045] getGlobalsAndPackages() ... DONE
[16:03:31.045]    + additional globals found: [n=0] 
[16:03:31.046]    + additional namespaces needed: [n=0] 
[16:03:31.046]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:31.046]  - seeds: <none>
[16:03:31.046]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:31.046] getGlobalsAndPackages() ...
[16:03:31.046] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:31.046] Resolving globals: FALSE
[16:03:31.046] Tweak future expression to call with '...' arguments ...
[16:03:31.046] {
[16:03:31.046]     do.call(function(...) {
[16:03:31.046]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:31.046]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:31.046]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:31.046]             on.exit(options(oopts), add = TRUE)
[16:03:31.046]         }
[16:03:31.046]         {
[16:03:31.046]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:31.046]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:31.046]                 ...future.FUN(...future.X_jj, ...)
[16:03:31.046]             })
[16:03:31.046]         }
[16:03:31.046]     }, args = future.call.arguments)
[16:03:31.046] }
[16:03:31.047] Tweak future expression to call with '...' arguments ... DONE
[16:03:31.048] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:31.048] 
[16:03:31.048] getGlobalsAndPackages() ... DONE
[16:03:31.049] run() for ‘Future’ ...
[16:03:31.049] - state: ‘created’
[16:03:31.049] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:31.052] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:31.052] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:31.053]   - Field: ‘label’
[16:03:31.053]   - Field: ‘local’
[16:03:31.053]   - Field: ‘owner’
[16:03:31.053]   - Field: ‘envir’
[16:03:31.053]   - Field: ‘packages’
[16:03:31.053]   - Field: ‘gc’
[16:03:31.053]   - Field: ‘conditions’
[16:03:31.053]   - Field: ‘expr’
[16:03:31.053]   - Field: ‘uuid’
[16:03:31.053]   - Field: ‘seed’
[16:03:31.053]   - Field: ‘version’
[16:03:31.054]   - Field: ‘result’
[16:03:31.054]   - Field: ‘asynchronous’
[16:03:31.054]   - Field: ‘calls’
[16:03:31.054]   - Field: ‘globals’
[16:03:31.054]   - Field: ‘stdout’
[16:03:31.054]   - Field: ‘earlySignal’
[16:03:31.054]   - Field: ‘lazy’
[16:03:31.054]   - Field: ‘state’
[16:03:31.054] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:31.054] - Launch lazy future ...
[16:03:31.055] Packages needed by the future expression (n = 0): <none>
[16:03:31.055] Packages needed by future strategies (n = 0): <none>
[16:03:31.055] {
[16:03:31.055]     {
[16:03:31.055]         {
[16:03:31.055]             ...future.startTime <- base::Sys.time()
[16:03:31.055]             {
[16:03:31.055]                 {
[16:03:31.055]                   {
[16:03:31.055]                     base::local({
[16:03:31.055]                       has_future <- base::requireNamespace("future", 
[16:03:31.055]                         quietly = TRUE)
[16:03:31.055]                       if (has_future) {
[16:03:31.055]                         ns <- base::getNamespace("future")
[16:03:31.055]                         version <- ns[[".package"]][["version"]]
[16:03:31.055]                         if (is.null(version)) 
[16:03:31.055]                           version <- utils::packageVersion("future")
[16:03:31.055]                       }
[16:03:31.055]                       else {
[16:03:31.055]                         version <- NULL
[16:03:31.055]                       }
[16:03:31.055]                       if (!has_future || version < "1.8.0") {
[16:03:31.055]                         info <- base::c(r_version = base::gsub("R version ", 
[16:03:31.055]                           "", base::R.version$version.string), 
[16:03:31.055]                           platform = base::sprintf("%s (%s-bit)", 
[16:03:31.055]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:31.055]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:31.055]                             "release", "version")], collapse = " "), 
[16:03:31.055]                           hostname = base::Sys.info()[["nodename"]])
[16:03:31.055]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:03:31.055]                           info)
[16:03:31.055]                         info <- base::paste(info, collapse = "; ")
[16:03:31.055]                         if (!has_future) {
[16:03:31.055]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:31.055]                             info)
[16:03:31.055]                         }
[16:03:31.055]                         else {
[16:03:31.055]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:31.055]                             info, version)
[16:03:31.055]                         }
[16:03:31.055]                         base::stop(msg)
[16:03:31.055]                       }
[16:03:31.055]                     })
[16:03:31.055]                   }
[16:03:31.055]                   options(future.plan = NULL)
[16:03:31.055]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:31.055]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:31.055]                 }
[16:03:31.055]                 ...future.workdir <- getwd()
[16:03:31.055]             }
[16:03:31.055]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:31.055]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:31.055]         }
[16:03:31.055]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:31.055]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:31.055]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:31.055]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:31.055]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:31.055]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:31.055]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:31.055]             base::names(...future.oldOptions))
[16:03:31.055]     }
[16:03:31.055]     if (FALSE) {
[16:03:31.055]     }
[16:03:31.055]     else {
[16:03:31.055]         if (TRUE) {
[16:03:31.055]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:31.055]                 open = "w")
[16:03:31.055]         }
[16:03:31.055]         else {
[16:03:31.055]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:31.055]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:31.055]         }
[16:03:31.055]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:31.055]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:31.055]             base::sink(type = "output", split = FALSE)
[16:03:31.055]             base::close(...future.stdout)
[16:03:31.055]         }, add = TRUE)
[16:03:31.055]     }
[16:03:31.055]     ...future.frame <- base::sys.nframe()
[16:03:31.055]     ...future.conditions <- base::list()
[16:03:31.055]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:31.055]     if (FALSE) {
[16:03:31.055]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:31.055]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:31.055]     }
[16:03:31.055]     ...future.result <- base::tryCatch({
[16:03:31.055]         base::withCallingHandlers({
[16:03:31.055]             ...future.value <- base::withVisible(base::local({
[16:03:31.055]                 do.call(function(...) {
[16:03:31.055]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:31.055]                   if (!identical(...future.globals.maxSize.org, 
[16:03:31.055]                     ...future.globals.maxSize)) {
[16:03:31.055]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:31.055]                     on.exit(options(oopts), add = TRUE)
[16:03:31.055]                   }
[16:03:31.055]                   {
[16:03:31.055]                     lapply(seq_along(...future.elements_ii), 
[16:03:31.055]                       FUN = function(jj) {
[16:03:31.055]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:31.055]                         ...future.FUN(...future.X_jj, ...)
[16:03:31.055]                       })
[16:03:31.055]                   }
[16:03:31.055]                 }, args = future.call.arguments)
[16:03:31.055]             }))
[16:03:31.055]             future::FutureResult(value = ...future.value$value, 
[16:03:31.055]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:31.055]                   ...future.rng), globalenv = if (FALSE) 
[16:03:31.055]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:31.055]                     ...future.globalenv.names))
[16:03:31.055]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:31.055]         }, condition = base::local({
[16:03:31.055]             c <- base::c
[16:03:31.055]             inherits <- base::inherits
[16:03:31.055]             invokeRestart <- base::invokeRestart
[16:03:31.055]             length <- base::length
[16:03:31.055]             list <- base::list
[16:03:31.055]             seq.int <- base::seq.int
[16:03:31.055]             signalCondition <- base::signalCondition
[16:03:31.055]             sys.calls <- base::sys.calls
[16:03:31.055]             `[[` <- base::`[[`
[16:03:31.055]             `+` <- base::`+`
[16:03:31.055]             `<<-` <- base::`<<-`
[16:03:31.055]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:31.055]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:31.055]                   3L)]
[16:03:31.055]             }
[16:03:31.055]             function(cond) {
[16:03:31.055]                 is_error <- inherits(cond, "error")
[16:03:31.055]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:31.055]                   NULL)
[16:03:31.055]                 if (is_error) {
[16:03:31.055]                   sessionInformation <- function() {
[16:03:31.055]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:31.055]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:31.055]                       search = base::search(), system = base::Sys.info())
[16:03:31.055]                   }
[16:03:31.055]                   ...future.conditions[[length(...future.conditions) + 
[16:03:31.055]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:31.055]                     cond$call), session = sessionInformation(), 
[16:03:31.055]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:31.055]                   signalCondition(cond)
[16:03:31.055]                 }
[16:03:31.055]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:31.055]                 "immediateCondition"))) {
[16:03:31.055]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:31.055]                   ...future.conditions[[length(...future.conditions) + 
[16:03:31.055]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:31.055]                   if (TRUE && !signal) {
[16:03:31.055]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:31.055]                     {
[16:03:31.055]                       inherits <- base::inherits
[16:03:31.055]                       invokeRestart <- base::invokeRestart
[16:03:31.055]                       is.null <- base::is.null
[16:03:31.055]                       muffled <- FALSE
[16:03:31.055]                       if (inherits(cond, "message")) {
[16:03:31.055]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:31.055]                         if (muffled) 
[16:03:31.055]                           invokeRestart("muffleMessage")
[16:03:31.055]                       }
[16:03:31.055]                       else if (inherits(cond, "warning")) {
[16:03:31.055]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:31.055]                         if (muffled) 
[16:03:31.055]                           invokeRestart("muffleWarning")
[16:03:31.055]                       }
[16:03:31.055]                       else if (inherits(cond, "condition")) {
[16:03:31.055]                         if (!is.null(pattern)) {
[16:03:31.055]                           computeRestarts <- base::computeRestarts
[16:03:31.055]                           grepl <- base::grepl
[16:03:31.055]                           restarts <- computeRestarts(cond)
[16:03:31.055]                           for (restart in restarts) {
[16:03:31.055]                             name <- restart$name
[16:03:31.055]                             if (is.null(name)) 
[16:03:31.055]                               next
[16:03:31.055]                             if (!grepl(pattern, name)) 
[16:03:31.055]                               next
[16:03:31.055]                             invokeRestart(restart)
[16:03:31.055]                             muffled <- TRUE
[16:03:31.055]                             break
[16:03:31.055]                           }
[16:03:31.055]                         }
[16:03:31.055]                       }
[16:03:31.055]                       invisible(muffled)
[16:03:31.055]                     }
[16:03:31.055]                     muffleCondition(cond, pattern = "^muffle")
[16:03:31.055]                   }
[16:03:31.055]                 }
[16:03:31.055]                 else {
[16:03:31.055]                   if (TRUE) {
[16:03:31.055]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:31.055]                     {
[16:03:31.055]                       inherits <- base::inherits
[16:03:31.055]                       invokeRestart <- base::invokeRestart
[16:03:31.055]                       is.null <- base::is.null
[16:03:31.055]                       muffled <- FALSE
[16:03:31.055]                       if (inherits(cond, "message")) {
[16:03:31.055]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:31.055]                         if (muffled) 
[16:03:31.055]                           invokeRestart("muffleMessage")
[16:03:31.055]                       }
[16:03:31.055]                       else if (inherits(cond, "warning")) {
[16:03:31.055]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:31.055]                         if (muffled) 
[16:03:31.055]                           invokeRestart("muffleWarning")
[16:03:31.055]                       }
[16:03:31.055]                       else if (inherits(cond, "condition")) {
[16:03:31.055]                         if (!is.null(pattern)) {
[16:03:31.055]                           computeRestarts <- base::computeRestarts
[16:03:31.055]                           grepl <- base::grepl
[16:03:31.055]                           restarts <- computeRestarts(cond)
[16:03:31.055]                           for (restart in restarts) {
[16:03:31.055]                             name <- restart$name
[16:03:31.055]                             if (is.null(name)) 
[16:03:31.055]                               next
[16:03:31.055]                             if (!grepl(pattern, name)) 
[16:03:31.055]                               next
[16:03:31.055]                             invokeRestart(restart)
[16:03:31.055]                             muffled <- TRUE
[16:03:31.055]                             break
[16:03:31.055]                           }
[16:03:31.055]                         }
[16:03:31.055]                       }
[16:03:31.055]                       invisible(muffled)
[16:03:31.055]                     }
[16:03:31.055]                     muffleCondition(cond, pattern = "^muffle")
[16:03:31.055]                   }
[16:03:31.055]                 }
[16:03:31.055]             }
[16:03:31.055]         }))
[16:03:31.055]     }, error = function(ex) {
[16:03:31.055]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:31.055]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:31.055]                 ...future.rng), started = ...future.startTime, 
[16:03:31.055]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:31.055]             version = "1.8"), class = "FutureResult")
[16:03:31.055]     }, finally = {
[16:03:31.055]         if (!identical(...future.workdir, getwd())) 
[16:03:31.055]             setwd(...future.workdir)
[16:03:31.055]         {
[16:03:31.055]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:31.055]                 ...future.oldOptions$nwarnings <- NULL
[16:03:31.055]             }
[16:03:31.055]             base::options(...future.oldOptions)
[16:03:31.055]             if (.Platform$OS.type == "windows") {
[16:03:31.055]                 old_names <- names(...future.oldEnvVars)
[16:03:31.055]                 envs <- base::Sys.getenv()
[16:03:31.055]                 names <- names(envs)
[16:03:31.055]                 common <- intersect(names, old_names)
[16:03:31.055]                 added <- setdiff(names, old_names)
[16:03:31.055]                 removed <- setdiff(old_names, names)
[16:03:31.055]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:31.055]                   envs[common]]
[16:03:31.055]                 NAMES <- toupper(changed)
[16:03:31.055]                 args <- list()
[16:03:31.055]                 for (kk in seq_along(NAMES)) {
[16:03:31.055]                   name <- changed[[kk]]
[16:03:31.055]                   NAME <- NAMES[[kk]]
[16:03:31.055]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:31.055]                     next
[16:03:31.055]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:31.055]                 }
[16:03:31.055]                 NAMES <- toupper(added)
[16:03:31.055]                 for (kk in seq_along(NAMES)) {
[16:03:31.055]                   name <- added[[kk]]
[16:03:31.055]                   NAME <- NAMES[[kk]]
[16:03:31.055]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:31.055]                     next
[16:03:31.055]                   args[[name]] <- ""
[16:03:31.055]                 }
[16:03:31.055]                 NAMES <- toupper(removed)
[16:03:31.055]                 for (kk in seq_along(NAMES)) {
[16:03:31.055]                   name <- removed[[kk]]
[16:03:31.055]                   NAME <- NAMES[[kk]]
[16:03:31.055]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:31.055]                     next
[16:03:31.055]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:31.055]                 }
[16:03:31.055]                 if (length(args) > 0) 
[16:03:31.055]                   base::do.call(base::Sys.setenv, args = args)
[16:03:31.055]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:31.055]             }
[16:03:31.055]             else {
[16:03:31.055]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:31.055]             }
[16:03:31.055]             {
[16:03:31.055]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:31.055]                   0L) {
[16:03:31.055]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:31.055]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:31.055]                   base::options(opts)
[16:03:31.055]                 }
[16:03:31.055]                 {
[16:03:31.055]                   {
[16:03:31.055]                     NULL
[16:03:31.055]                     RNGkind("Mersenne-Twister")
[16:03:31.055]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:31.055]                       inherits = FALSE)
[16:03:31.055]                   }
[16:03:31.055]                   options(future.plan = NULL)
[16:03:31.055]                   if (is.na(NA_character_)) 
[16:03:31.055]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:31.055]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:31.055]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:31.055]                     envir = parent.frame()) 
[16:03:31.055]                   {
[16:03:31.055]                     default_workers <- missing(workers)
[16:03:31.055]                     if (is.function(workers)) 
[16:03:31.055]                       workers <- workers()
[16:03:31.055]                     workers <- structure(as.integer(workers), 
[16:03:31.055]                       class = class(workers))
[16:03:31.055]                     stop_if_not(is.finite(workers), workers >= 
[16:03:31.055]                       1L)
[16:03:31.055]                     if ((workers == 1L && !inherits(workers, 
[16:03:31.055]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:31.055]                       if (default_workers) 
[16:03:31.055]                         supportsMulticore(warn = TRUE)
[16:03:31.055]                       return(sequential(..., envir = envir))
[16:03:31.055]                     }
[16:03:31.055]                     oopts <- options(mc.cores = workers)
[16:03:31.055]                     on.exit(options(oopts))
[16:03:31.055]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:31.055]                       envir = envir)
[16:03:31.055]                     if (!future$lazy) 
[16:03:31.055]                       future <- run(future)
[16:03:31.055]                     invisible(future)
[16:03:31.055]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:31.055]                 }
[16:03:31.055]             }
[16:03:31.055]         }
[16:03:31.055]     })
[16:03:31.055]     if (TRUE) {
[16:03:31.055]         base::sink(type = "output", split = FALSE)
[16:03:31.055]         if (TRUE) {
[16:03:31.055]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:31.055]         }
[16:03:31.055]         else {
[16:03:31.055]             ...future.result["stdout"] <- base::list(NULL)
[16:03:31.055]         }
[16:03:31.055]         base::close(...future.stdout)
[16:03:31.055]         ...future.stdout <- NULL
[16:03:31.055]     }
[16:03:31.055]     ...future.result$conditions <- ...future.conditions
[16:03:31.055]     ...future.result$finished <- base::Sys.time()
[16:03:31.055]     ...future.result
[16:03:31.055] }
[16:03:31.057] assign_globals() ...
[16:03:31.057] List of 5
[16:03:31.057]  $ ...future.FUN            :function (x)  
[16:03:31.057]  $ future.call.arguments    : list()
[16:03:31.057]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:31.057]  $ ...future.elements_ii    :List of 2
[16:03:31.057]   ..$ : int 1
[16:03:31.057]   ..$ : int 0
[16:03:31.057]  $ ...future.seeds_ii       : NULL
[16:03:31.057]  $ ...future.globals.maxSize: NULL
[16:03:31.057]  - attr(*, "where")=List of 5
[16:03:31.057]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:31.057]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:31.057]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:31.057]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:31.057]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:31.057]  - attr(*, "resolved")= logi FALSE
[16:03:31.057]  - attr(*, "total_size")= num 4720
[16:03:31.057]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:31.057]  - attr(*, "already-done")= logi TRUE
[16:03:31.061] - reassign environment for ‘...future.FUN’
[16:03:31.062] - copied ‘...future.FUN’ to environment
[16:03:31.062] - copied ‘future.call.arguments’ to environment
[16:03:31.062] - copied ‘...future.elements_ii’ to environment
[16:03:31.062] - copied ‘...future.seeds_ii’ to environment
[16:03:31.062] - copied ‘...future.globals.maxSize’ to environment
[16:03:31.062] assign_globals() ... done
[16:03:31.062] plan(): Setting new future strategy stack:
[16:03:31.062] List of future strategies:
[16:03:31.062] 1. sequential:
[16:03:31.062]    - args: function (..., envir = parent.frame())
[16:03:31.062]    - tweaked: FALSE
[16:03:31.062]    - call: NULL
[16:03:31.063] plan(): nbrOfWorkers() = 1
[16:03:31.564] plan(): Setting new future strategy stack:
[16:03:31.564] List of future strategies:
[16:03:31.564] 1. multicore:
[16:03:31.564]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:31.564]    - tweaked: FALSE
[16:03:31.564]    - call: plan(strategy)
[16:03:31.568] plan(): nbrOfWorkers() = 1
[16:03:31.568] SequentialFuture started (and completed)
[16:03:31.568] - Launch lazy future ... done
[16:03:31.568] run() for ‘SequentialFuture’ ... done
[16:03:31.568] Created future:
[16:03:31.568] SequentialFuture:
[16:03:31.568] Label: ‘future_lapply-1’
[16:03:31.568] Expression:
[16:03:31.568] {
[16:03:31.568]     do.call(function(...) {
[16:03:31.568]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:31.568]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:31.568]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:31.568]             on.exit(options(oopts), add = TRUE)
[16:03:31.568]         }
[16:03:31.568]         {
[16:03:31.568]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:31.568]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:31.568]                 ...future.FUN(...future.X_jj, ...)
[16:03:31.568]             })
[16:03:31.568]         }
[16:03:31.568]     }, args = future.call.arguments)
[16:03:31.568] }
[16:03:31.568] Lazy evaluation: FALSE
[16:03:31.568] Asynchronous evaluation: FALSE
[16:03:31.568] Local evaluation: TRUE
[16:03:31.568] Environment: R_GlobalEnv
[16:03:31.568] Capture standard output: TRUE
[16:03:31.568] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:31.568] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:31.568] Packages: <none>
[16:03:31.568] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:31.568] Resolved: TRUE
[16:03:31.568] Value: 112 bytes of class ‘list’
[16:03:31.568] Early signaling: FALSE
[16:03:31.568] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:31.568] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:31.569] Chunk #1 of 1 ... DONE
[16:03:31.569] Launching 1 futures (chunks) ... DONE
[16:03:31.570] Resolving 1 futures (chunks) ...
[16:03:31.570] resolve() on list ...
[16:03:31.570]  recursive: 0
[16:03:31.570]  length: 1
[16:03:31.570] 
[16:03:31.570] resolved() for ‘SequentialFuture’ ...
[16:03:31.570] - state: ‘finished’
[16:03:31.570] - run: TRUE
[16:03:31.570] - result: ‘FutureResult’
[16:03:31.570] resolved() for ‘SequentialFuture’ ... done
[16:03:31.571] Future #1
[16:03:31.571] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:31.571] - nx: 1
[16:03:31.571] - relay: TRUE
[16:03:31.571] - stdout: TRUE
[16:03:31.571] - signal: TRUE
[16:03:31.571] - resignal: FALSE
[16:03:31.571] - force: TRUE
[16:03:31.571] - relayed: [n=1] FALSE
[16:03:31.571] - queued futures: [n=1] FALSE
[16:03:31.571]  - until=1
[16:03:31.572]  - relaying element #1
[16:03:31.572] - relayed: [n=1] TRUE
[16:03:31.572] - queued futures: [n=1] TRUE
[16:03:31.572] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:31.572]  length: 0 (resolved future 1)
[16:03:31.572] Relaying remaining futures
[16:03:31.572] signalConditionsASAP(NULL, pos=0) ...
[16:03:31.572] - nx: 1
[16:03:31.572] - relay: TRUE
[16:03:31.572] - stdout: TRUE
[16:03:31.573] - signal: TRUE
[16:03:31.573] - resignal: FALSE
[16:03:31.573] - force: TRUE
[16:03:31.573] - relayed: [n=1] TRUE
[16:03:31.573] - queued futures: [n=1] TRUE
 - flush all
[16:03:31.573] - relayed: [n=1] TRUE
[16:03:31.573] - queued futures: [n=1] TRUE
[16:03:31.573] signalConditionsASAP(NULL, pos=0) ... done
[16:03:31.573] resolve() on list ... DONE
[16:03:31.573]  - Number of value chunks collected: 1
[16:03:31.574] Resolving 1 futures (chunks) ... DONE
[16:03:31.574] Reducing values from 1 chunks ...
[16:03:31.574]  - Number of values collected after concatenation: 2
[16:03:31.574]  - Number of values expected: 2
[16:03:31.574] Reducing values from 1 chunks ... DONE
[16:03:31.574] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[16:03:31.574] future_lapply() ...
[16:03:31.578] Number of chunks: 1
[16:03:31.579] getGlobalsAndPackagesXApply() ...
[16:03:31.579]  - future.globals: TRUE
[16:03:31.580] getGlobalsAndPackages() ...
[16:03:31.580] Searching for globals...
[16:03:31.581] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:03:31.581] Searching for globals ... DONE
[16:03:31.581] Resolving globals: FALSE
[16:03:31.582] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:03:31.582] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:03:31.582] - globals: [1] ‘FUN’
[16:03:31.582] 
[16:03:31.582] getGlobalsAndPackages() ... DONE
[16:03:31.582]  - globals found/used: [n=1] ‘FUN’
[16:03:31.582]  - needed namespaces: [n=0] 
[16:03:31.583] Finding globals ... DONE
[16:03:31.583]  - use_args: TRUE
[16:03:31.583]  - Getting '...' globals ...
[16:03:31.583] resolve() on list ...
[16:03:31.583]  recursive: 0
[16:03:31.583]  length: 1
[16:03:31.583]  elements: ‘...’
[16:03:31.583]  length: 0 (resolved future 1)
[16:03:31.584] resolve() on list ... DONE
[16:03:31.584]    - '...' content: [n=0] 
[16:03:31.584] List of 1
[16:03:31.584]  $ ...: list()
[16:03:31.584]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:31.584]  - attr(*, "where")=List of 1
[16:03:31.584]   ..$ ...:<environment: 0x55ed7aad9b60> 
[16:03:31.584]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:31.584]  - attr(*, "resolved")= logi TRUE
[16:03:31.584]  - attr(*, "total_size")= num NA
[16:03:31.586]  - Getting '...' globals ... DONE
[16:03:31.586] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:03:31.586] List of 2
[16:03:31.586]  $ ...future.FUN:function (x)  
[16:03:31.586]  $ ...          : list()
[16:03:31.586]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:31.586]  - attr(*, "where")=List of 2
[16:03:31.586]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:31.586]   ..$ ...          :<environment: 0x55ed7aad9b60> 
[16:03:31.586]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:31.586]  - attr(*, "resolved")= logi FALSE
[16:03:31.586]  - attr(*, "total_size")= num 4720
[16:03:31.589] Packages to be attached in all futures: [n=0] 
[16:03:31.589] getGlobalsAndPackagesXApply() ... DONE
[16:03:31.589] Number of futures (= number of chunks): 1
[16:03:31.589] Launching 1 futures (chunks) ...
[16:03:31.589] Chunk #1 of 1 ...
[16:03:31.590]  - Finding globals in 'X' for chunk #1 ...
[16:03:31.590] getGlobalsAndPackages() ...
[16:03:31.590] Searching for globals...
[16:03:31.590] 
[16:03:31.590] Searching for globals ... DONE
[16:03:31.590] - globals: [0] <none>
[16:03:31.590] getGlobalsAndPackages() ... DONE
[16:03:31.590]    + additional globals found: [n=0] 
[16:03:31.590]    + additional namespaces needed: [n=0] 
[16:03:31.590]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:31.591]  - seeds: <none>
[16:03:31.591]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:31.591] getGlobalsAndPackages() ...
[16:03:31.591] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:31.591] Resolving globals: FALSE
[16:03:31.591] Tweak future expression to call with '...' arguments ...
[16:03:31.591] {
[16:03:31.591]     do.call(function(...) {
[16:03:31.591]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:31.591]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:31.591]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:31.591]             on.exit(options(oopts), add = TRUE)
[16:03:31.591]         }
[16:03:31.591]         {
[16:03:31.591]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:31.591]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:31.591]                 ...future.FUN(...future.X_jj, ...)
[16:03:31.591]             })
[16:03:31.591]         }
[16:03:31.591]     }, args = future.call.arguments)
[16:03:31.591] }
[16:03:31.592] Tweak future expression to call with '...' arguments ... DONE
[16:03:31.592] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:31.592] 
[16:03:31.592] getGlobalsAndPackages() ... DONE
[16:03:31.592] run() for ‘Future’ ...
[16:03:31.592] - state: ‘created’
[16:03:31.593] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:31.596] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:31.596] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:31.596]   - Field: ‘label’
[16:03:31.596]   - Field: ‘local’
[16:03:31.596]   - Field: ‘owner’
[16:03:31.596]   - Field: ‘envir’
[16:03:31.596]   - Field: ‘packages’
[16:03:31.597]   - Field: ‘gc’
[16:03:31.597]   - Field: ‘conditions’
[16:03:31.597]   - Field: ‘expr’
[16:03:31.597]   - Field: ‘uuid’
[16:03:31.597]   - Field: ‘seed’
[16:03:31.597]   - Field: ‘version’
[16:03:31.597]   - Field: ‘result’
[16:03:31.597]   - Field: ‘asynchronous’
[16:03:31.597]   - Field: ‘calls’
[16:03:31.597]   - Field: ‘globals’
[16:03:31.597]   - Field: ‘stdout’
[16:03:31.597]   - Field: ‘earlySignal’
[16:03:31.598]   - Field: ‘lazy’
[16:03:31.598]   - Field: ‘state’
[16:03:31.598] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:31.598] - Launch lazy future ...
[16:03:31.598] Packages needed by the future expression (n = 0): <none>
[16:03:31.598] Packages needed by future strategies (n = 0): <none>
[16:03:31.599] {
[16:03:31.599]     {
[16:03:31.599]         {
[16:03:31.599]             ...future.startTime <- base::Sys.time()
[16:03:31.599]             {
[16:03:31.599]                 {
[16:03:31.599]                   {
[16:03:31.599]                     base::local({
[16:03:31.599]                       has_future <- base::requireNamespace("future", 
[16:03:31.599]                         quietly = TRUE)
[16:03:31.599]                       if (has_future) {
[16:03:31.599]                         ns <- base::getNamespace("future")
[16:03:31.599]                         version <- ns[[".package"]][["version"]]
[16:03:31.599]                         if (is.null(version)) 
[16:03:31.599]                           version <- utils::packageVersion("future")
[16:03:31.599]                       }
[16:03:31.599]                       else {
[16:03:31.599]                         version <- NULL
[16:03:31.599]                       }
[16:03:31.599]                       if (!has_future || version < "1.8.0") {
[16:03:31.599]                         info <- base::c(r_version = base::gsub("R version ", 
[16:03:31.599]                           "", base::R.version$version.string), 
[16:03:31.599]                           platform = base::sprintf("%s (%s-bit)", 
[16:03:31.599]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:31.599]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:31.599]                             "release", "version")], collapse = " "), 
[16:03:31.599]                           hostname = base::Sys.info()[["nodename"]])
[16:03:31.599]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:03:31.599]                           info)
[16:03:31.599]                         info <- base::paste(info, collapse = "; ")
[16:03:31.599]                         if (!has_future) {
[16:03:31.599]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:31.599]                             info)
[16:03:31.599]                         }
[16:03:31.599]                         else {
[16:03:31.599]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:31.599]                             info, version)
[16:03:31.599]                         }
[16:03:31.599]                         base::stop(msg)
[16:03:31.599]                       }
[16:03:31.599]                     })
[16:03:31.599]                   }
[16:03:31.599]                   options(future.plan = NULL)
[16:03:31.599]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:31.599]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:31.599]                 }
[16:03:31.599]                 ...future.workdir <- getwd()
[16:03:31.599]             }
[16:03:31.599]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:31.599]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:31.599]         }
[16:03:31.599]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:31.599]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:31.599]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:31.599]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:31.599]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:31.599]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:31.599]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:31.599]             base::names(...future.oldOptions))
[16:03:31.599]     }
[16:03:31.599]     if (TRUE) {
[16:03:31.599]     }
[16:03:31.599]     else {
[16:03:31.599]         if (NA) {
[16:03:31.599]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:31.599]                 open = "w")
[16:03:31.599]         }
[16:03:31.599]         else {
[16:03:31.599]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:31.599]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:31.599]         }
[16:03:31.599]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:31.599]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:31.599]             base::sink(type = "output", split = FALSE)
[16:03:31.599]             base::close(...future.stdout)
[16:03:31.599]         }, add = TRUE)
[16:03:31.599]     }
[16:03:31.599]     ...future.frame <- base::sys.nframe()
[16:03:31.599]     ...future.conditions <- base::list()
[16:03:31.599]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:31.599]     if (FALSE) {
[16:03:31.599]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:31.599]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:31.599]     }
[16:03:31.599]     ...future.result <- base::tryCatch({
[16:03:31.599]         base::withCallingHandlers({
[16:03:31.599]             ...future.value <- base::withVisible(base::local({
[16:03:31.599]                 do.call(function(...) {
[16:03:31.599]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:31.599]                   if (!identical(...future.globals.maxSize.org, 
[16:03:31.599]                     ...future.globals.maxSize)) {
[16:03:31.599]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:31.599]                     on.exit(options(oopts), add = TRUE)
[16:03:31.599]                   }
[16:03:31.599]                   {
[16:03:31.599]                     lapply(seq_along(...future.elements_ii), 
[16:03:31.599]                       FUN = function(jj) {
[16:03:31.599]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:31.599]                         ...future.FUN(...future.X_jj, ...)
[16:03:31.599]                       })
[16:03:31.599]                   }
[16:03:31.599]                 }, args = future.call.arguments)
[16:03:31.599]             }))
[16:03:31.599]             future::FutureResult(value = ...future.value$value, 
[16:03:31.599]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:31.599]                   ...future.rng), globalenv = if (FALSE) 
[16:03:31.599]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:31.599]                     ...future.globalenv.names))
[16:03:31.599]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:31.599]         }, condition = base::local({
[16:03:31.599]             c <- base::c
[16:03:31.599]             inherits <- base::inherits
[16:03:31.599]             invokeRestart <- base::invokeRestart
[16:03:31.599]             length <- base::length
[16:03:31.599]             list <- base::list
[16:03:31.599]             seq.int <- base::seq.int
[16:03:31.599]             signalCondition <- base::signalCondition
[16:03:31.599]             sys.calls <- base::sys.calls
[16:03:31.599]             `[[` <- base::`[[`
[16:03:31.599]             `+` <- base::`+`
[16:03:31.599]             `<<-` <- base::`<<-`
[16:03:31.599]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:31.599]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:31.599]                   3L)]
[16:03:31.599]             }
[16:03:31.599]             function(cond) {
[16:03:31.599]                 is_error <- inherits(cond, "error")
[16:03:31.599]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:31.599]                   NULL)
[16:03:31.599]                 if (is_error) {
[16:03:31.599]                   sessionInformation <- function() {
[16:03:31.599]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:31.599]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:31.599]                       search = base::search(), system = base::Sys.info())
[16:03:31.599]                   }
[16:03:31.599]                   ...future.conditions[[length(...future.conditions) + 
[16:03:31.599]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:31.599]                     cond$call), session = sessionInformation(), 
[16:03:31.599]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:31.599]                   signalCondition(cond)
[16:03:31.599]                 }
[16:03:31.599]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:31.599]                 "immediateCondition"))) {
[16:03:31.599]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:31.599]                   ...future.conditions[[length(...future.conditions) + 
[16:03:31.599]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:31.599]                   if (TRUE && !signal) {
[16:03:31.599]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:31.599]                     {
[16:03:31.599]                       inherits <- base::inherits
[16:03:31.599]                       invokeRestart <- base::invokeRestart
[16:03:31.599]                       is.null <- base::is.null
[16:03:31.599]                       muffled <- FALSE
[16:03:31.599]                       if (inherits(cond, "message")) {
[16:03:31.599]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:31.599]                         if (muffled) 
[16:03:31.599]                           invokeRestart("muffleMessage")
[16:03:31.599]                       }
[16:03:31.599]                       else if (inherits(cond, "warning")) {
[16:03:31.599]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:31.599]                         if (muffled) 
[16:03:31.599]                           invokeRestart("muffleWarning")
[16:03:31.599]                       }
[16:03:31.599]                       else if (inherits(cond, "condition")) {
[16:03:31.599]                         if (!is.null(pattern)) {
[16:03:31.599]                           computeRestarts <- base::computeRestarts
[16:03:31.599]                           grepl <- base::grepl
[16:03:31.599]                           restarts <- computeRestarts(cond)
[16:03:31.599]                           for (restart in restarts) {
[16:03:31.599]                             name <- restart$name
[16:03:31.599]                             if (is.null(name)) 
[16:03:31.599]                               next
[16:03:31.599]                             if (!grepl(pattern, name)) 
[16:03:31.599]                               next
[16:03:31.599]                             invokeRestart(restart)
[16:03:31.599]                             muffled <- TRUE
[16:03:31.599]                             break
[16:03:31.599]                           }
[16:03:31.599]                         }
[16:03:31.599]                       }
[16:03:31.599]                       invisible(muffled)
[16:03:31.599]                     }
[16:03:31.599]                     muffleCondition(cond, pattern = "^muffle")
[16:03:31.599]                   }
[16:03:31.599]                 }
[16:03:31.599]                 else {
[16:03:31.599]                   if (TRUE) {
[16:03:31.599]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:31.599]                     {
[16:03:31.599]                       inherits <- base::inherits
[16:03:31.599]                       invokeRestart <- base::invokeRestart
[16:03:31.599]                       is.null <- base::is.null
[16:03:31.599]                       muffled <- FALSE
[16:03:31.599]                       if (inherits(cond, "message")) {
[16:03:31.599]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:31.599]                         if (muffled) 
[16:03:31.599]                           invokeRestart("muffleMessage")
[16:03:31.599]                       }
[16:03:31.599]                       else if (inherits(cond, "warning")) {
[16:03:31.599]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:31.599]                         if (muffled) 
[16:03:31.599]                           invokeRestart("muffleWarning")
[16:03:31.599]                       }
[16:03:31.599]                       else if (inherits(cond, "condition")) {
[16:03:31.599]                         if (!is.null(pattern)) {
[16:03:31.599]                           computeRestarts <- base::computeRestarts
[16:03:31.599]                           grepl <- base::grepl
[16:03:31.599]                           restarts <- computeRestarts(cond)
[16:03:31.599]                           for (restart in restarts) {
[16:03:31.599]                             name <- restart$name
[16:03:31.599]                             if (is.null(name)) 
[16:03:31.599]                               next
[16:03:31.599]                             if (!grepl(pattern, name)) 
[16:03:31.599]                               next
[16:03:31.599]                             invokeRestart(restart)
[16:03:31.599]                             muffled <- TRUE
[16:03:31.599]                             break
[16:03:31.599]                           }
[16:03:31.599]                         }
[16:03:31.599]                       }
[16:03:31.599]                       invisible(muffled)
[16:03:31.599]                     }
[16:03:31.599]                     muffleCondition(cond, pattern = "^muffle")
[16:03:31.599]                   }
[16:03:31.599]                 }
[16:03:31.599]             }
[16:03:31.599]         }))
[16:03:31.599]     }, error = function(ex) {
[16:03:31.599]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:31.599]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:31.599]                 ...future.rng), started = ...future.startTime, 
[16:03:31.599]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:31.599]             version = "1.8"), class = "FutureResult")
[16:03:31.599]     }, finally = {
[16:03:31.599]         if (!identical(...future.workdir, getwd())) 
[16:03:31.599]             setwd(...future.workdir)
[16:03:31.599]         {
[16:03:31.599]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:31.599]                 ...future.oldOptions$nwarnings <- NULL
[16:03:31.599]             }
[16:03:31.599]             base::options(...future.oldOptions)
[16:03:31.599]             if (.Platform$OS.type == "windows") {
[16:03:31.599]                 old_names <- names(...future.oldEnvVars)
[16:03:31.599]                 envs <- base::Sys.getenv()
[16:03:31.599]                 names <- names(envs)
[16:03:31.599]                 common <- intersect(names, old_names)
[16:03:31.599]                 added <- setdiff(names, old_names)
[16:03:31.599]                 removed <- setdiff(old_names, names)
[16:03:31.599]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:31.599]                   envs[common]]
[16:03:31.599]                 NAMES <- toupper(changed)
[16:03:31.599]                 args <- list()
[16:03:31.599]                 for (kk in seq_along(NAMES)) {
[16:03:31.599]                   name <- changed[[kk]]
[16:03:31.599]                   NAME <- NAMES[[kk]]
[16:03:31.599]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:31.599]                     next
[16:03:31.599]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:31.599]                 }
[16:03:31.599]                 NAMES <- toupper(added)
[16:03:31.599]                 for (kk in seq_along(NAMES)) {
[16:03:31.599]                   name <- added[[kk]]
[16:03:31.599]                   NAME <- NAMES[[kk]]
[16:03:31.599]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:31.599]                     next
[16:03:31.599]                   args[[name]] <- ""
[16:03:31.599]                 }
[16:03:31.599]                 NAMES <- toupper(removed)
[16:03:31.599]                 for (kk in seq_along(NAMES)) {
[16:03:31.599]                   name <- removed[[kk]]
[16:03:31.599]                   NAME <- NAMES[[kk]]
[16:03:31.599]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:31.599]                     next
[16:03:31.599]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:31.599]                 }
[16:03:31.599]                 if (length(args) > 0) 
[16:03:31.599]                   base::do.call(base::Sys.setenv, args = args)
[16:03:31.599]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:31.599]             }
[16:03:31.599]             else {
[16:03:31.599]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:31.599]             }
[16:03:31.599]             {
[16:03:31.599]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:31.599]                   0L) {
[16:03:31.599]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:31.599]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:31.599]                   base::options(opts)
[16:03:31.599]                 }
[16:03:31.599]                 {
[16:03:31.599]                   {
[16:03:31.599]                     NULL
[16:03:31.599]                     RNGkind("Mersenne-Twister")
[16:03:31.599]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:31.599]                       inherits = FALSE)
[16:03:31.599]                   }
[16:03:31.599]                   options(future.plan = NULL)
[16:03:31.599]                   if (is.na(NA_character_)) 
[16:03:31.599]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:31.599]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:31.599]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:31.599]                     envir = parent.frame()) 
[16:03:31.599]                   {
[16:03:31.599]                     default_workers <- missing(workers)
[16:03:31.599]                     if (is.function(workers)) 
[16:03:31.599]                       workers <- workers()
[16:03:31.599]                     workers <- structure(as.integer(workers), 
[16:03:31.599]                       class = class(workers))
[16:03:31.599]                     stop_if_not(is.finite(workers), workers >= 
[16:03:31.599]                       1L)
[16:03:31.599]                     if ((workers == 1L && !inherits(workers, 
[16:03:31.599]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:31.599]                       if (default_workers) 
[16:03:31.599]                         supportsMulticore(warn = TRUE)
[16:03:31.599]                       return(sequential(..., envir = envir))
[16:03:31.599]                     }
[16:03:31.599]                     oopts <- options(mc.cores = workers)
[16:03:31.599]                     on.exit(options(oopts))
[16:03:31.599]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:31.599]                       envir = envir)
[16:03:31.599]                     if (!future$lazy) 
[16:03:31.599]                       future <- run(future)
[16:03:31.599]                     invisible(future)
[16:03:31.599]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:31.599]                 }
[16:03:31.599]             }
[16:03:31.599]         }
[16:03:31.599]     })
[16:03:31.599]     if (FALSE) {
[16:03:31.599]         base::sink(type = "output", split = FALSE)
[16:03:31.599]         if (NA) {
[16:03:31.599]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:31.599]         }
[16:03:31.599]         else {
[16:03:31.599]             ...future.result["stdout"] <- base::list(NULL)
[16:03:31.599]         }
[16:03:31.599]         base::close(...future.stdout)
[16:03:31.599]         ...future.stdout <- NULL
[16:03:31.599]     }
[16:03:31.599]     ...future.result$conditions <- ...future.conditions
[16:03:31.599]     ...future.result$finished <- base::Sys.time()
[16:03:31.599]     ...future.result
[16:03:31.599] }
[16:03:31.600] assign_globals() ...
[16:03:31.600] List of 5
[16:03:31.600]  $ ...future.FUN            :function (x)  
[16:03:31.600]  $ future.call.arguments    : list()
[16:03:31.600]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:31.600]  $ ...future.elements_ii    :List of 2
[16:03:31.600]   ..$ : int 1
[16:03:31.600]   ..$ : int 0
[16:03:31.600]  $ ...future.seeds_ii       : NULL
[16:03:31.600]  $ ...future.globals.maxSize: NULL
[16:03:31.600]  - attr(*, "where")=List of 5
[16:03:31.600]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:31.600]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:31.600]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:31.600]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:31.600]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:31.600]  - attr(*, "resolved")= logi FALSE
[16:03:31.600]  - attr(*, "total_size")= num 4720
[16:03:31.600]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:31.600]  - attr(*, "already-done")= logi TRUE
[16:03:31.606] - reassign environment for ‘...future.FUN’
[16:03:31.607] - copied ‘...future.FUN’ to environment
[16:03:31.607] - copied ‘future.call.arguments’ to environment
[16:03:31.607] - copied ‘...future.elements_ii’ to environment
[16:03:31.607] - copied ‘...future.seeds_ii’ to environment
[16:03:31.607] - copied ‘...future.globals.maxSize’ to environment
[16:03:31.607] assign_globals() ... done
[16:03:31.607] plan(): Setting new future strategy stack:
[16:03:31.607] List of future strategies:
[16:03:31.607] 1. sequential:
[16:03:31.607]    - args: function (..., envir = parent.frame())
[16:03:31.607]    - tweaked: FALSE
[16:03:31.607]    - call: NULL
[16:03:31.608] plan(): nbrOfWorkers() = 1
[16:03:32.109] plan(): Setting new future strategy stack:
[16:03:32.110] List of future strategies:
[16:03:32.110] 1. multicore:
[16:03:32.110]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:32.110]    - tweaked: FALSE
[16:03:32.110]    - call: plan(strategy)
[16:03:32.113] plan(): nbrOfWorkers() = 1
[16:03:32.114] SequentialFuture started (and completed)
[16:03:32.114] - Launch lazy future ... done
[16:03:32.114] run() for ‘SequentialFuture’ ... done
[16:03:32.114] Created future:
[16:03:32.114] SequentialFuture:
[16:03:32.114] Label: ‘future_lapply-1’
[16:03:32.114] Expression:
[16:03:32.114] {
[16:03:32.114]     do.call(function(...) {
[16:03:32.114]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:32.114]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:32.114]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:32.114]             on.exit(options(oopts), add = TRUE)
[16:03:32.114]         }
[16:03:32.114]         {
[16:03:32.114]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:32.114]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:32.114]                 ...future.FUN(...future.X_jj, ...)
[16:03:32.114]             })
[16:03:32.114]         }
[16:03:32.114]     }, args = future.call.arguments)
[16:03:32.114] }
[16:03:32.114] Lazy evaluation: FALSE
[16:03:32.114] Asynchronous evaluation: FALSE
[16:03:32.114] Local evaluation: TRUE
[16:03:32.114] Environment: R_GlobalEnv
[16:03:32.114] Capture standard output: NA
[16:03:32.114] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:32.114] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:32.114] Packages: <none>
[16:03:32.114] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:32.114] Resolved: TRUE
[16:03:32.114] Value: 112 bytes of class ‘list’
[16:03:32.114] Early signaling: FALSE
[16:03:32.114] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:32.114] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:32.115] Chunk #1 of 1 ... DONE
[16:03:32.115] Launching 1 futures (chunks) ... DONE
[16:03:32.115] Resolving 1 futures (chunks) ...
[16:03:32.115] resolve() on list ...
[16:03:32.116]  recursive: 0
[16:03:32.116]  length: 1
[16:03:32.116] 
[16:03:32.116] resolved() for ‘SequentialFuture’ ...
[16:03:32.116] - state: ‘finished’
[16:03:32.116] - run: TRUE
[16:03:32.116] - result: ‘FutureResult’
[16:03:32.116] resolved() for ‘SequentialFuture’ ... done
[16:03:32.116] Future #1
[16:03:32.116] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:32.117] - nx: 1
[16:03:32.117] - relay: TRUE
[16:03:32.117] - stdout: TRUE
[16:03:32.117] - signal: TRUE
[16:03:32.117] - resignal: FALSE
[16:03:32.117] - force: TRUE
[16:03:32.117] - relayed: [n=1] FALSE
[16:03:32.117] - queued futures: [n=1] FALSE
[16:03:32.117]  - until=1
[16:03:32.117]  - relaying element #1
[16:03:32.117] - relayed: [n=1] TRUE
[16:03:32.118] - queued futures: [n=1] TRUE
[16:03:32.118] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:32.118]  length: 0 (resolved future 1)
[16:03:32.118] Relaying remaining futures
[16:03:32.118] signalConditionsASAP(NULL, pos=0) ...
[16:03:32.118] - nx: 1
[16:03:32.118] - relay: TRUE
[16:03:32.118] - stdout: TRUE
[16:03:32.118] - signal: TRUE
[16:03:32.118] - resignal: FALSE
[16:03:32.118] - force: TRUE
[16:03:32.119] - relayed: [n=1] TRUE
[16:03:32.119] - queued futures: [n=1] TRUE
 - flush all
[16:03:32.119] - relayed: [n=1] TRUE
[16:03:32.119] - queued futures: [n=1] TRUE
[16:03:32.119] signalConditionsASAP(NULL, pos=0) ... done
[16:03:32.119] resolve() on list ... DONE
[16:03:32.119]  - Number of value chunks collected: 1
[16:03:32.119] Resolving 1 futures (chunks) ... DONE
[16:03:32.119] Reducing values from 1 chunks ...
[16:03:32.120]  - Number of values collected after concatenation: 2
[16:03:32.120]  - Number of values expected: 2
[16:03:32.120] Reducing values from 1 chunks ... DONE
[16:03:32.120] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[16:03:32.120] future_mapply() ...
[16:03:32.123] Number of chunks: 1
[16:03:32.123] getGlobalsAndPackagesXApply() ...
[16:03:32.124]  - future.globals: TRUE
[16:03:32.124] getGlobalsAndPackages() ...
[16:03:32.124] Searching for globals...
[16:03:32.125] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:03:32.125] Searching for globals ... DONE
[16:03:32.125] Resolving globals: FALSE
[16:03:32.126] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:03:32.126] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:03:32.126] - globals: [1] ‘FUN’
[16:03:32.126] 
[16:03:32.127] getGlobalsAndPackages() ... DONE
[16:03:32.127]  - globals found/used: [n=1] ‘FUN’
[16:03:32.127]  - needed namespaces: [n=0] 
[16:03:32.127] Finding globals ... DONE
[16:03:32.127] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:03:32.127] List of 2
[16:03:32.127]  $ ...future.FUN:function (x, y)  
[16:03:32.127]  $ MoreArgs     : NULL
[16:03:32.127]  - attr(*, "where")=List of 2
[16:03:32.127]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:32.127]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:03:32.127]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:32.127]  - attr(*, "resolved")= logi FALSE
[16:03:32.127]  - attr(*, "total_size")= num NA
[16:03:32.130] Packages to be attached in all futures: [n=0] 
[16:03:32.130] getGlobalsAndPackagesXApply() ... DONE
[16:03:32.130] Number of futures (= number of chunks): 1
[16:03:32.130] Launching 1 futures (chunks) ...
[16:03:32.130] Chunk #1 of 1 ...
[16:03:32.130]  - Finding globals in '...' for chunk #1 ...
[16:03:32.130] getGlobalsAndPackages() ...
[16:03:32.130] Searching for globals...
[16:03:32.131] 
[16:03:32.131] Searching for globals ... DONE
[16:03:32.131] - globals: [0] <none>
[16:03:32.131] getGlobalsAndPackages() ... DONE
[16:03:32.131]    + additional globals found: [n=0] 
[16:03:32.131]    + additional namespaces needed: [n=0] 
[16:03:32.131]  - Finding globals in '...' for chunk #1 ... DONE
[16:03:32.131]  - seeds: <none>
[16:03:32.132]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:32.132] getGlobalsAndPackages() ...
[16:03:32.132] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:32.132] Resolving globals: FALSE
[16:03:32.134] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[16:03:32.134] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:03:32.134] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:32.135] 
[16:03:32.135] getGlobalsAndPackages() ... DONE
[16:03:32.135] run() for ‘Future’ ...
[16:03:32.135] - state: ‘created’
[16:03:32.135] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:32.139] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:32.139] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:32.139]   - Field: ‘label’
[16:03:32.139]   - Field: ‘local’
[16:03:32.139]   - Field: ‘owner’
[16:03:32.139]   - Field: ‘envir’
[16:03:32.139]   - Field: ‘packages’
[16:03:32.139]   - Field: ‘gc’
[16:03:32.139]   - Field: ‘conditions’
[16:03:32.140]   - Field: ‘expr’
[16:03:32.140]   - Field: ‘uuid’
[16:03:32.140]   - Field: ‘seed’
[16:03:32.140]   - Field: ‘version’
[16:03:32.140]   - Field: ‘result’
[16:03:32.140]   - Field: ‘asynchronous’
[16:03:32.140]   - Field: ‘calls’
[16:03:32.140]   - Field: ‘globals’
[16:03:32.140]   - Field: ‘stdout’
[16:03:32.140]   - Field: ‘earlySignal’
[16:03:32.140]   - Field: ‘lazy’
[16:03:32.141]   - Field: ‘state’
[16:03:32.141] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:32.141] - Launch lazy future ...
[16:03:32.141] Packages needed by the future expression (n = 0): <none>
[16:03:32.141] Packages needed by future strategies (n = 0): <none>
[16:03:32.141] {
[16:03:32.141]     {
[16:03:32.141]         {
[16:03:32.141]             ...future.startTime <- base::Sys.time()
[16:03:32.141]             {
[16:03:32.141]                 {
[16:03:32.141]                   {
[16:03:32.141]                     base::local({
[16:03:32.141]                       has_future <- base::requireNamespace("future", 
[16:03:32.141]                         quietly = TRUE)
[16:03:32.141]                       if (has_future) {
[16:03:32.141]                         ns <- base::getNamespace("future")
[16:03:32.141]                         version <- ns[[".package"]][["version"]]
[16:03:32.141]                         if (is.null(version)) 
[16:03:32.141]                           version <- utils::packageVersion("future")
[16:03:32.141]                       }
[16:03:32.141]                       else {
[16:03:32.141]                         version <- NULL
[16:03:32.141]                       }
[16:03:32.141]                       if (!has_future || version < "1.8.0") {
[16:03:32.141]                         info <- base::c(r_version = base::gsub("R version ", 
[16:03:32.141]                           "", base::R.version$version.string), 
[16:03:32.141]                           platform = base::sprintf("%s (%s-bit)", 
[16:03:32.141]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:32.141]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:32.141]                             "release", "version")], collapse = " "), 
[16:03:32.141]                           hostname = base::Sys.info()[["nodename"]])
[16:03:32.141]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:03:32.141]                           info)
[16:03:32.141]                         info <- base::paste(info, collapse = "; ")
[16:03:32.141]                         if (!has_future) {
[16:03:32.141]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:32.141]                             info)
[16:03:32.141]                         }
[16:03:32.141]                         else {
[16:03:32.141]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:32.141]                             info, version)
[16:03:32.141]                         }
[16:03:32.141]                         base::stop(msg)
[16:03:32.141]                       }
[16:03:32.141]                     })
[16:03:32.141]                   }
[16:03:32.141]                   options(future.plan = NULL)
[16:03:32.141]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:32.141]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:32.141]                 }
[16:03:32.141]                 ...future.workdir <- getwd()
[16:03:32.141]             }
[16:03:32.141]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:32.141]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:32.141]         }
[16:03:32.141]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:32.141]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:32.141]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:32.141]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:32.141]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:32.141]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:32.141]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:32.141]             base::names(...future.oldOptions))
[16:03:32.141]     }
[16:03:32.141]     if (FALSE) {
[16:03:32.141]     }
[16:03:32.141]     else {
[16:03:32.141]         if (FALSE) {
[16:03:32.141]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:32.141]                 open = "w")
[16:03:32.141]         }
[16:03:32.141]         else {
[16:03:32.141]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:32.141]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:32.141]         }
[16:03:32.141]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:32.141]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:32.141]             base::sink(type = "output", split = FALSE)
[16:03:32.141]             base::close(...future.stdout)
[16:03:32.141]         }, add = TRUE)
[16:03:32.141]     }
[16:03:32.141]     ...future.frame <- base::sys.nframe()
[16:03:32.141]     ...future.conditions <- base::list()
[16:03:32.141]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:32.141]     if (FALSE) {
[16:03:32.141]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:32.141]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:32.141]     }
[16:03:32.141]     ...future.result <- base::tryCatch({
[16:03:32.141]         base::withCallingHandlers({
[16:03:32.141]             ...future.value <- base::withVisible(base::local({
[16:03:32.141]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:32.141]                 if (!identical(...future.globals.maxSize.org, 
[16:03:32.141]                   ...future.globals.maxSize)) {
[16:03:32.141]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:32.141]                   on.exit(options(oopts), add = TRUE)
[16:03:32.141]                 }
[16:03:32.141]                 {
[16:03:32.141]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:32.141]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:03:32.141]                     USE.NAMES = FALSE)
[16:03:32.141]                   do.call(mapply, args = args)
[16:03:32.141]                 }
[16:03:32.141]             }))
[16:03:32.141]             future::FutureResult(value = ...future.value$value, 
[16:03:32.141]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:32.141]                   ...future.rng), globalenv = if (FALSE) 
[16:03:32.141]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:32.141]                     ...future.globalenv.names))
[16:03:32.141]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:32.141]         }, condition = base::local({
[16:03:32.141]             c <- base::c
[16:03:32.141]             inherits <- base::inherits
[16:03:32.141]             invokeRestart <- base::invokeRestart
[16:03:32.141]             length <- base::length
[16:03:32.141]             list <- base::list
[16:03:32.141]             seq.int <- base::seq.int
[16:03:32.141]             signalCondition <- base::signalCondition
[16:03:32.141]             sys.calls <- base::sys.calls
[16:03:32.141]             `[[` <- base::`[[`
[16:03:32.141]             `+` <- base::`+`
[16:03:32.141]             `<<-` <- base::`<<-`
[16:03:32.141]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:32.141]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:32.141]                   3L)]
[16:03:32.141]             }
[16:03:32.141]             function(cond) {
[16:03:32.141]                 is_error <- inherits(cond, "error")
[16:03:32.141]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:32.141]                   NULL)
[16:03:32.141]                 if (is_error) {
[16:03:32.141]                   sessionInformation <- function() {
[16:03:32.141]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:32.141]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:32.141]                       search = base::search(), system = base::Sys.info())
[16:03:32.141]                   }
[16:03:32.141]                   ...future.conditions[[length(...future.conditions) + 
[16:03:32.141]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:32.141]                     cond$call), session = sessionInformation(), 
[16:03:32.141]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:32.141]                   signalCondition(cond)
[16:03:32.141]                 }
[16:03:32.141]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:32.141]                 "immediateCondition"))) {
[16:03:32.141]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:32.141]                   ...future.conditions[[length(...future.conditions) + 
[16:03:32.141]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:32.141]                   if (TRUE && !signal) {
[16:03:32.141]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:32.141]                     {
[16:03:32.141]                       inherits <- base::inherits
[16:03:32.141]                       invokeRestart <- base::invokeRestart
[16:03:32.141]                       is.null <- base::is.null
[16:03:32.141]                       muffled <- FALSE
[16:03:32.141]                       if (inherits(cond, "message")) {
[16:03:32.141]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:32.141]                         if (muffled) 
[16:03:32.141]                           invokeRestart("muffleMessage")
[16:03:32.141]                       }
[16:03:32.141]                       else if (inherits(cond, "warning")) {
[16:03:32.141]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:32.141]                         if (muffled) 
[16:03:32.141]                           invokeRestart("muffleWarning")
[16:03:32.141]                       }
[16:03:32.141]                       else if (inherits(cond, "condition")) {
[16:03:32.141]                         if (!is.null(pattern)) {
[16:03:32.141]                           computeRestarts <- base::computeRestarts
[16:03:32.141]                           grepl <- base::grepl
[16:03:32.141]                           restarts <- computeRestarts(cond)
[16:03:32.141]                           for (restart in restarts) {
[16:03:32.141]                             name <- restart$name
[16:03:32.141]                             if (is.null(name)) 
[16:03:32.141]                               next
[16:03:32.141]                             if (!grepl(pattern, name)) 
[16:03:32.141]                               next
[16:03:32.141]                             invokeRestart(restart)
[16:03:32.141]                             muffled <- TRUE
[16:03:32.141]                             break
[16:03:32.141]                           }
[16:03:32.141]                         }
[16:03:32.141]                       }
[16:03:32.141]                       invisible(muffled)
[16:03:32.141]                     }
[16:03:32.141]                     muffleCondition(cond, pattern = "^muffle")
[16:03:32.141]                   }
[16:03:32.141]                 }
[16:03:32.141]                 else {
[16:03:32.141]                   if (TRUE) {
[16:03:32.141]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:32.141]                     {
[16:03:32.141]                       inherits <- base::inherits
[16:03:32.141]                       invokeRestart <- base::invokeRestart
[16:03:32.141]                       is.null <- base::is.null
[16:03:32.141]                       muffled <- FALSE
[16:03:32.141]                       if (inherits(cond, "message")) {
[16:03:32.141]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:32.141]                         if (muffled) 
[16:03:32.141]                           invokeRestart("muffleMessage")
[16:03:32.141]                       }
[16:03:32.141]                       else if (inherits(cond, "warning")) {
[16:03:32.141]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:32.141]                         if (muffled) 
[16:03:32.141]                           invokeRestart("muffleWarning")
[16:03:32.141]                       }
[16:03:32.141]                       else if (inherits(cond, "condition")) {
[16:03:32.141]                         if (!is.null(pattern)) {
[16:03:32.141]                           computeRestarts <- base::computeRestarts
[16:03:32.141]                           grepl <- base::grepl
[16:03:32.141]                           restarts <- computeRestarts(cond)
[16:03:32.141]                           for (restart in restarts) {
[16:03:32.141]                             name <- restart$name
[16:03:32.141]                             if (is.null(name)) 
[16:03:32.141]                               next
[16:03:32.141]                             if (!grepl(pattern, name)) 
[16:03:32.141]                               next
[16:03:32.141]                             invokeRestart(restart)
[16:03:32.141]                             muffled <- TRUE
[16:03:32.141]                             break
[16:03:32.141]                           }
[16:03:32.141]                         }
[16:03:32.141]                       }
[16:03:32.141]                       invisible(muffled)
[16:03:32.141]                     }
[16:03:32.141]                     muffleCondition(cond, pattern = "^muffle")
[16:03:32.141]                   }
[16:03:32.141]                 }
[16:03:32.141]             }
[16:03:32.141]         }))
[16:03:32.141]     }, error = function(ex) {
[16:03:32.141]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:32.141]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:32.141]                 ...future.rng), started = ...future.startTime, 
[16:03:32.141]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:32.141]             version = "1.8"), class = "FutureResult")
[16:03:32.141]     }, finally = {
[16:03:32.141]         if (!identical(...future.workdir, getwd())) 
[16:03:32.141]             setwd(...future.workdir)
[16:03:32.141]         {
[16:03:32.141]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:32.141]                 ...future.oldOptions$nwarnings <- NULL
[16:03:32.141]             }
[16:03:32.141]             base::options(...future.oldOptions)
[16:03:32.141]             if (.Platform$OS.type == "windows") {
[16:03:32.141]                 old_names <- names(...future.oldEnvVars)
[16:03:32.141]                 envs <- base::Sys.getenv()
[16:03:32.141]                 names <- names(envs)
[16:03:32.141]                 common <- intersect(names, old_names)
[16:03:32.141]                 added <- setdiff(names, old_names)
[16:03:32.141]                 removed <- setdiff(old_names, names)
[16:03:32.141]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:32.141]                   envs[common]]
[16:03:32.141]                 NAMES <- toupper(changed)
[16:03:32.141]                 args <- list()
[16:03:32.141]                 for (kk in seq_along(NAMES)) {
[16:03:32.141]                   name <- changed[[kk]]
[16:03:32.141]                   NAME <- NAMES[[kk]]
[16:03:32.141]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:32.141]                     next
[16:03:32.141]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:32.141]                 }
[16:03:32.141]                 NAMES <- toupper(added)
[16:03:32.141]                 for (kk in seq_along(NAMES)) {
[16:03:32.141]                   name <- added[[kk]]
[16:03:32.141]                   NAME <- NAMES[[kk]]
[16:03:32.141]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:32.141]                     next
[16:03:32.141]                   args[[name]] <- ""
[16:03:32.141]                 }
[16:03:32.141]                 NAMES <- toupper(removed)
[16:03:32.141]                 for (kk in seq_along(NAMES)) {
[16:03:32.141]                   name <- removed[[kk]]
[16:03:32.141]                   NAME <- NAMES[[kk]]
[16:03:32.141]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:32.141]                     next
[16:03:32.141]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:32.141]                 }
[16:03:32.141]                 if (length(args) > 0) 
[16:03:32.141]                   base::do.call(base::Sys.setenv, args = args)
[16:03:32.141]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:32.141]             }
[16:03:32.141]             else {
[16:03:32.141]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:32.141]             }
[16:03:32.141]             {
[16:03:32.141]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:32.141]                   0L) {
[16:03:32.141]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:32.141]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:32.141]                   base::options(opts)
[16:03:32.141]                 }
[16:03:32.141]                 {
[16:03:32.141]                   {
[16:03:32.141]                     NULL
[16:03:32.141]                     RNGkind("Mersenne-Twister")
[16:03:32.141]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:32.141]                       inherits = FALSE)
[16:03:32.141]                   }
[16:03:32.141]                   options(future.plan = NULL)
[16:03:32.141]                   if (is.na(NA_character_)) 
[16:03:32.141]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:32.141]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:32.141]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:32.141]                     envir = parent.frame()) 
[16:03:32.141]                   {
[16:03:32.141]                     default_workers <- missing(workers)
[16:03:32.141]                     if (is.function(workers)) 
[16:03:32.141]                       workers <- workers()
[16:03:32.141]                     workers <- structure(as.integer(workers), 
[16:03:32.141]                       class = class(workers))
[16:03:32.141]                     stop_if_not(is.finite(workers), workers >= 
[16:03:32.141]                       1L)
[16:03:32.141]                     if ((workers == 1L && !inherits(workers, 
[16:03:32.141]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:32.141]                       if (default_workers) 
[16:03:32.141]                         supportsMulticore(warn = TRUE)
[16:03:32.141]                       return(sequential(..., envir = envir))
[16:03:32.141]                     }
[16:03:32.141]                     oopts <- options(mc.cores = workers)
[16:03:32.141]                     on.exit(options(oopts))
[16:03:32.141]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:32.141]                       envir = envir)
[16:03:32.141]                     if (!future$lazy) 
[16:03:32.141]                       future <- run(future)
[16:03:32.141]                     invisible(future)
[16:03:32.141]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:32.141]                 }
[16:03:32.141]             }
[16:03:32.141]         }
[16:03:32.141]     })
[16:03:32.141]     if (TRUE) {
[16:03:32.141]         base::sink(type = "output", split = FALSE)
[16:03:32.141]         if (FALSE) {
[16:03:32.141]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:32.141]         }
[16:03:32.141]         else {
[16:03:32.141]             ...future.result["stdout"] <- base::list(NULL)
[16:03:32.141]         }
[16:03:32.141]         base::close(...future.stdout)
[16:03:32.141]         ...future.stdout <- NULL
[16:03:32.141]     }
[16:03:32.141]     ...future.result$conditions <- ...future.conditions
[16:03:32.141]     ...future.result$finished <- base::Sys.time()
[16:03:32.141]     ...future.result
[16:03:32.141] }
[16:03:32.143] assign_globals() ...
[16:03:32.143] List of 5
[16:03:32.143]  $ ...future.FUN            :function (x, y)  
[16:03:32.143]  $ MoreArgs                 : NULL
[16:03:32.143]  $ ...future.elements_ii    :List of 2
[16:03:32.143]   ..$ :List of 2
[16:03:32.143]   .. ..$ : int 1
[16:03:32.143]   .. ..$ : int 0
[16:03:32.143]   ..$ :List of 2
[16:03:32.143]   .. ..$ : int 0
[16:03:32.143]   .. ..$ : int 1
[16:03:32.143]  $ ...future.seeds_ii       : NULL
[16:03:32.143]  $ ...future.globals.maxSize: NULL
[16:03:32.143]  - attr(*, "where")=List of 5
[16:03:32.143]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:32.143]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:03:32.143]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:32.143]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:32.143]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:32.143]  - attr(*, "resolved")= logi FALSE
[16:03:32.143]  - attr(*, "total_size")= num 6480
[16:03:32.143]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:32.143]  - attr(*, "already-done")= logi TRUE
[16:03:32.149] - reassign environment for ‘...future.FUN’
[16:03:32.149] - copied ‘...future.FUN’ to environment
[16:03:32.149] - copied ‘MoreArgs’ to environment
[16:03:32.149] - copied ‘...future.elements_ii’ to environment
[16:03:32.149] - copied ‘...future.seeds_ii’ to environment
[16:03:32.149] - copied ‘...future.globals.maxSize’ to environment
[16:03:32.149] assign_globals() ... done
[16:03:32.150] plan(): Setting new future strategy stack:
[16:03:32.150] List of future strategies:
[16:03:32.150] 1. sequential:
[16:03:32.150]    - args: function (..., envir = parent.frame())
[16:03:32.150]    - tweaked: FALSE
[16:03:32.150]    - call: NULL
[16:03:32.150] plan(): nbrOfWorkers() = 1
[16:03:32.651] plan(): Setting new future strategy stack:
[16:03:32.652] List of future strategies:
[16:03:32.652] 1. multicore:
[16:03:32.652]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:32.652]    - tweaked: FALSE
[16:03:32.652]    - call: plan(strategy)
[16:03:32.656] plan(): nbrOfWorkers() = 1
[16:03:32.656] SequentialFuture started (and completed)
[16:03:32.656] - Launch lazy future ... done
[16:03:32.656] run() for ‘SequentialFuture’ ... done
[16:03:32.656] Created future:
[16:03:32.656] SequentialFuture:
[16:03:32.656] Label: ‘future_mapply-1’
[16:03:32.656] Expression:
[16:03:32.656] {
[16:03:32.656]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:32.656]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:32.656]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:32.656]         on.exit(options(oopts), add = TRUE)
[16:03:32.656]     }
[16:03:32.656]     {
[16:03:32.656]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:32.656]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:03:32.656]         do.call(mapply, args = args)
[16:03:32.656]     }
[16:03:32.656] }
[16:03:32.656] Lazy evaluation: FALSE
[16:03:32.656] Asynchronous evaluation: FALSE
[16:03:32.656] Local evaluation: TRUE
[16:03:32.656] Environment: R_GlobalEnv
[16:03:32.656] Capture standard output: FALSE
[16:03:32.656] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:32.656] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:32.656] Packages: <none>
[16:03:32.656] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:32.656] Resolved: TRUE
[16:03:32.656] Value: 224 bytes of class ‘list’
[16:03:32.656] Early signaling: FALSE
[16:03:32.656] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:32.656] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:32.658] Chunk #1 of 1 ... DONE
[16:03:32.658] Launching 1 futures (chunks) ... DONE
[16:03:32.658] Resolving 1 futures (chunks) ...
[16:03:32.658] resolve() on list ...
[16:03:32.658]  recursive: 0
[16:03:32.658]  length: 1
[16:03:32.658] 
[16:03:32.658] resolved() for ‘SequentialFuture’ ...
[16:03:32.658] - state: ‘finished’
[16:03:32.658] - run: TRUE
[16:03:32.658] - result: ‘FutureResult’
[16:03:32.659] resolved() for ‘SequentialFuture’ ... done
[16:03:32.659] Future #1
[16:03:32.659] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:32.659] - nx: 1
[16:03:32.659] - relay: TRUE
[16:03:32.659] - stdout: TRUE
[16:03:32.659] - signal: TRUE
[16:03:32.659] - resignal: FALSE
[16:03:32.659] - force: TRUE
[16:03:32.659] - relayed: [n=1] FALSE
[16:03:32.660] - queued futures: [n=1] FALSE
[16:03:32.660]  - until=1
[16:03:32.660]  - relaying element #1
[16:03:32.660] - relayed: [n=1] TRUE
[16:03:32.660] - queued futures: [n=1] TRUE
[16:03:32.660] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:32.660]  length: 0 (resolved future 1)
[16:03:32.660] Relaying remaining futures
[16:03:32.660] signalConditionsASAP(NULL, pos=0) ...
[16:03:32.660] - nx: 1
[16:03:32.661] - relay: TRUE
[16:03:32.661] - stdout: TRUE
[16:03:32.661] - signal: TRUE
[16:03:32.661] - resignal: FALSE
[16:03:32.661] - force: TRUE
[16:03:32.661] - relayed: [n=1] TRUE
[16:03:32.661] - queued futures: [n=1] TRUE
 - flush all
[16:03:32.661] - relayed: [n=1] TRUE
[16:03:32.661] - queued futures: [n=1] TRUE
[16:03:32.661] signalConditionsASAP(NULL, pos=0) ... done
[16:03:32.661] resolve() on list ... DONE
[16:03:32.662]  - Number of value chunks collected: 1
[16:03:32.662] Resolving 1 futures (chunks) ... DONE
[16:03:32.662] Reducing values from 1 chunks ...
[16:03:32.662]  - Number of values collected after concatenation: 2
[16:03:32.662]  - Number of values expected: 2
[16:03:32.662] Reducing values from 1 chunks ... DONE
[16:03:32.662] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[16:03:32.663] future_mapply() ...
[16:03:32.668] Number of chunks: 1
[16:03:32.668] getGlobalsAndPackagesXApply() ...
[16:03:32.668]  - future.globals: TRUE
[16:03:32.668] getGlobalsAndPackages() ...
[16:03:32.668] Searching for globals...
[16:03:32.669] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:03:32.670] Searching for globals ... DONE
[16:03:32.670] Resolving globals: FALSE
[16:03:32.670] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:03:32.670] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:03:32.671] - globals: [1] ‘FUN’
[16:03:32.671] 
[16:03:32.671] getGlobalsAndPackages() ... DONE
[16:03:32.671]  - globals found/used: [n=1] ‘FUN’
[16:03:32.671]  - needed namespaces: [n=0] 
[16:03:32.671] Finding globals ... DONE
[16:03:32.671] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:03:32.671] List of 2
[16:03:32.671]  $ ...future.FUN:function (x, y)  
[16:03:32.671]  $ MoreArgs     : NULL
[16:03:32.671]  - attr(*, "where")=List of 2
[16:03:32.671]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:32.671]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:03:32.671]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:32.671]  - attr(*, "resolved")= logi FALSE
[16:03:32.671]  - attr(*, "total_size")= num NA
[16:03:32.674] Packages to be attached in all futures: [n=0] 
[16:03:32.674] getGlobalsAndPackagesXApply() ... DONE
[16:03:32.674] Number of futures (= number of chunks): 1
[16:03:32.674] Launching 1 futures (chunks) ...
[16:03:32.674] Chunk #1 of 1 ...
[16:03:32.675]  - Finding globals in '...' for chunk #1 ...
[16:03:32.675] getGlobalsAndPackages() ...
[16:03:32.675] Searching for globals...
[16:03:32.675] 
[16:03:32.675] Searching for globals ... DONE
[16:03:32.675] - globals: [0] <none>
[16:03:32.675] getGlobalsAndPackages() ... DONE
[16:03:32.675]    + additional globals found: [n=0] 
[16:03:32.676]    + additional namespaces needed: [n=0] 
[16:03:32.676]  - Finding globals in '...' for chunk #1 ... DONE
[16:03:32.676]  - seeds: <none>
[16:03:32.676]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:32.676] getGlobalsAndPackages() ...
[16:03:32.676] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:32.676] Resolving globals: FALSE
[16:03:32.677] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[16:03:32.677] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:03:32.677] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:32.677] 
[16:03:32.677] getGlobalsAndPackages() ... DONE
[16:03:32.678] run() for ‘Future’ ...
[16:03:32.678] - state: ‘created’
[16:03:32.678] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:32.681] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:32.681] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:32.681]   - Field: ‘label’
[16:03:32.682]   - Field: ‘local’
[16:03:32.682]   - Field: ‘owner’
[16:03:32.682]   - Field: ‘envir’
[16:03:32.682]   - Field: ‘packages’
[16:03:32.682]   - Field: ‘gc’
[16:03:32.682]   - Field: ‘conditions’
[16:03:32.682]   - Field: ‘expr’
[16:03:32.682]   - Field: ‘uuid’
[16:03:32.682]   - Field: ‘seed’
[16:03:32.682]   - Field: ‘version’
[16:03:32.682]   - Field: ‘result’
[16:03:32.683]   - Field: ‘asynchronous’
[16:03:32.683]   - Field: ‘calls’
[16:03:32.683]   - Field: ‘globals’
[16:03:32.683]   - Field: ‘stdout’
[16:03:32.683]   - Field: ‘earlySignal’
[16:03:32.683]   - Field: ‘lazy’
[16:03:32.683]   - Field: ‘state’
[16:03:32.683] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:32.683] - Launch lazy future ...
[16:03:32.684] Packages needed by the future expression (n = 0): <none>
[16:03:32.684] Packages needed by future strategies (n = 0): <none>
[16:03:32.684] {
[16:03:32.684]     {
[16:03:32.684]         {
[16:03:32.684]             ...future.startTime <- base::Sys.time()
[16:03:32.684]             {
[16:03:32.684]                 {
[16:03:32.684]                   {
[16:03:32.684]                     base::local({
[16:03:32.684]                       has_future <- base::requireNamespace("future", 
[16:03:32.684]                         quietly = TRUE)
[16:03:32.684]                       if (has_future) {
[16:03:32.684]                         ns <- base::getNamespace("future")
[16:03:32.684]                         version <- ns[[".package"]][["version"]]
[16:03:32.684]                         if (is.null(version)) 
[16:03:32.684]                           version <- utils::packageVersion("future")
[16:03:32.684]                       }
[16:03:32.684]                       else {
[16:03:32.684]                         version <- NULL
[16:03:32.684]                       }
[16:03:32.684]                       if (!has_future || version < "1.8.0") {
[16:03:32.684]                         info <- base::c(r_version = base::gsub("R version ", 
[16:03:32.684]                           "", base::R.version$version.string), 
[16:03:32.684]                           platform = base::sprintf("%s (%s-bit)", 
[16:03:32.684]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:32.684]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:32.684]                             "release", "version")], collapse = " "), 
[16:03:32.684]                           hostname = base::Sys.info()[["nodename"]])
[16:03:32.684]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:03:32.684]                           info)
[16:03:32.684]                         info <- base::paste(info, collapse = "; ")
[16:03:32.684]                         if (!has_future) {
[16:03:32.684]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:32.684]                             info)
[16:03:32.684]                         }
[16:03:32.684]                         else {
[16:03:32.684]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:32.684]                             info, version)
[16:03:32.684]                         }
[16:03:32.684]                         base::stop(msg)
[16:03:32.684]                       }
[16:03:32.684]                     })
[16:03:32.684]                   }
[16:03:32.684]                   options(future.plan = NULL)
[16:03:32.684]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:32.684]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:32.684]                 }
[16:03:32.684]                 ...future.workdir <- getwd()
[16:03:32.684]             }
[16:03:32.684]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:32.684]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:32.684]         }
[16:03:32.684]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:32.684]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:32.684]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:32.684]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:32.684]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:32.684]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:32.684]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:32.684]             base::names(...future.oldOptions))
[16:03:32.684]     }
[16:03:32.684]     if (FALSE) {
[16:03:32.684]     }
[16:03:32.684]     else {
[16:03:32.684]         if (TRUE) {
[16:03:32.684]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:32.684]                 open = "w")
[16:03:32.684]         }
[16:03:32.684]         else {
[16:03:32.684]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:32.684]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:32.684]         }
[16:03:32.684]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:32.684]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:32.684]             base::sink(type = "output", split = FALSE)
[16:03:32.684]             base::close(...future.stdout)
[16:03:32.684]         }, add = TRUE)
[16:03:32.684]     }
[16:03:32.684]     ...future.frame <- base::sys.nframe()
[16:03:32.684]     ...future.conditions <- base::list()
[16:03:32.684]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:32.684]     if (FALSE) {
[16:03:32.684]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:32.684]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:32.684]     }
[16:03:32.684]     ...future.result <- base::tryCatch({
[16:03:32.684]         base::withCallingHandlers({
[16:03:32.684]             ...future.value <- base::withVisible(base::local({
[16:03:32.684]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:32.684]                 if (!identical(...future.globals.maxSize.org, 
[16:03:32.684]                   ...future.globals.maxSize)) {
[16:03:32.684]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:32.684]                   on.exit(options(oopts), add = TRUE)
[16:03:32.684]                 }
[16:03:32.684]                 {
[16:03:32.684]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:32.684]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:03:32.684]                     USE.NAMES = FALSE)
[16:03:32.684]                   do.call(mapply, args = args)
[16:03:32.684]                 }
[16:03:32.684]             }))
[16:03:32.684]             future::FutureResult(value = ...future.value$value, 
[16:03:32.684]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:32.684]                   ...future.rng), globalenv = if (FALSE) 
[16:03:32.684]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:32.684]                     ...future.globalenv.names))
[16:03:32.684]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:32.684]         }, condition = base::local({
[16:03:32.684]             c <- base::c
[16:03:32.684]             inherits <- base::inherits
[16:03:32.684]             invokeRestart <- base::invokeRestart
[16:03:32.684]             length <- base::length
[16:03:32.684]             list <- base::list
[16:03:32.684]             seq.int <- base::seq.int
[16:03:32.684]             signalCondition <- base::signalCondition
[16:03:32.684]             sys.calls <- base::sys.calls
[16:03:32.684]             `[[` <- base::`[[`
[16:03:32.684]             `+` <- base::`+`
[16:03:32.684]             `<<-` <- base::`<<-`
[16:03:32.684]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:32.684]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:32.684]                   3L)]
[16:03:32.684]             }
[16:03:32.684]             function(cond) {
[16:03:32.684]                 is_error <- inherits(cond, "error")
[16:03:32.684]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:32.684]                   NULL)
[16:03:32.684]                 if (is_error) {
[16:03:32.684]                   sessionInformation <- function() {
[16:03:32.684]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:32.684]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:32.684]                       search = base::search(), system = base::Sys.info())
[16:03:32.684]                   }
[16:03:32.684]                   ...future.conditions[[length(...future.conditions) + 
[16:03:32.684]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:32.684]                     cond$call), session = sessionInformation(), 
[16:03:32.684]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:32.684]                   signalCondition(cond)
[16:03:32.684]                 }
[16:03:32.684]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:32.684]                 "immediateCondition"))) {
[16:03:32.684]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:32.684]                   ...future.conditions[[length(...future.conditions) + 
[16:03:32.684]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:32.684]                   if (TRUE && !signal) {
[16:03:32.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:32.684]                     {
[16:03:32.684]                       inherits <- base::inherits
[16:03:32.684]                       invokeRestart <- base::invokeRestart
[16:03:32.684]                       is.null <- base::is.null
[16:03:32.684]                       muffled <- FALSE
[16:03:32.684]                       if (inherits(cond, "message")) {
[16:03:32.684]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:32.684]                         if (muffled) 
[16:03:32.684]                           invokeRestart("muffleMessage")
[16:03:32.684]                       }
[16:03:32.684]                       else if (inherits(cond, "warning")) {
[16:03:32.684]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:32.684]                         if (muffled) 
[16:03:32.684]                           invokeRestart("muffleWarning")
[16:03:32.684]                       }
[16:03:32.684]                       else if (inherits(cond, "condition")) {
[16:03:32.684]                         if (!is.null(pattern)) {
[16:03:32.684]                           computeRestarts <- base::computeRestarts
[16:03:32.684]                           grepl <- base::grepl
[16:03:32.684]                           restarts <- computeRestarts(cond)
[16:03:32.684]                           for (restart in restarts) {
[16:03:32.684]                             name <- restart$name
[16:03:32.684]                             if (is.null(name)) 
[16:03:32.684]                               next
[16:03:32.684]                             if (!grepl(pattern, name)) 
[16:03:32.684]                               next
[16:03:32.684]                             invokeRestart(restart)
[16:03:32.684]                             muffled <- TRUE
[16:03:32.684]                             break
[16:03:32.684]                           }
[16:03:32.684]                         }
[16:03:32.684]                       }
[16:03:32.684]                       invisible(muffled)
[16:03:32.684]                     }
[16:03:32.684]                     muffleCondition(cond, pattern = "^muffle")
[16:03:32.684]                   }
[16:03:32.684]                 }
[16:03:32.684]                 else {
[16:03:32.684]                   if (TRUE) {
[16:03:32.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:32.684]                     {
[16:03:32.684]                       inherits <- base::inherits
[16:03:32.684]                       invokeRestart <- base::invokeRestart
[16:03:32.684]                       is.null <- base::is.null
[16:03:32.684]                       muffled <- FALSE
[16:03:32.684]                       if (inherits(cond, "message")) {
[16:03:32.684]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:32.684]                         if (muffled) 
[16:03:32.684]                           invokeRestart("muffleMessage")
[16:03:32.684]                       }
[16:03:32.684]                       else if (inherits(cond, "warning")) {
[16:03:32.684]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:32.684]                         if (muffled) 
[16:03:32.684]                           invokeRestart("muffleWarning")
[16:03:32.684]                       }
[16:03:32.684]                       else if (inherits(cond, "condition")) {
[16:03:32.684]                         if (!is.null(pattern)) {
[16:03:32.684]                           computeRestarts <- base::computeRestarts
[16:03:32.684]                           grepl <- base::grepl
[16:03:32.684]                           restarts <- computeRestarts(cond)
[16:03:32.684]                           for (restart in restarts) {
[16:03:32.684]                             name <- restart$name
[16:03:32.684]                             if (is.null(name)) 
[16:03:32.684]                               next
[16:03:32.684]                             if (!grepl(pattern, name)) 
[16:03:32.684]                               next
[16:03:32.684]                             invokeRestart(restart)
[16:03:32.684]                             muffled <- TRUE
[16:03:32.684]                             break
[16:03:32.684]                           }
[16:03:32.684]                         }
[16:03:32.684]                       }
[16:03:32.684]                       invisible(muffled)
[16:03:32.684]                     }
[16:03:32.684]                     muffleCondition(cond, pattern = "^muffle")
[16:03:32.684]                   }
[16:03:32.684]                 }
[16:03:32.684]             }
[16:03:32.684]         }))
[16:03:32.684]     }, error = function(ex) {
[16:03:32.684]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:32.684]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:32.684]                 ...future.rng), started = ...future.startTime, 
[16:03:32.684]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:32.684]             version = "1.8"), class = "FutureResult")
[16:03:32.684]     }, finally = {
[16:03:32.684]         if (!identical(...future.workdir, getwd())) 
[16:03:32.684]             setwd(...future.workdir)
[16:03:32.684]         {
[16:03:32.684]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:32.684]                 ...future.oldOptions$nwarnings <- NULL
[16:03:32.684]             }
[16:03:32.684]             base::options(...future.oldOptions)
[16:03:32.684]             if (.Platform$OS.type == "windows") {
[16:03:32.684]                 old_names <- names(...future.oldEnvVars)
[16:03:32.684]                 envs <- base::Sys.getenv()
[16:03:32.684]                 names <- names(envs)
[16:03:32.684]                 common <- intersect(names, old_names)
[16:03:32.684]                 added <- setdiff(names, old_names)
[16:03:32.684]                 removed <- setdiff(old_names, names)
[16:03:32.684]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:32.684]                   envs[common]]
[16:03:32.684]                 NAMES <- toupper(changed)
[16:03:32.684]                 args <- list()
[16:03:32.684]                 for (kk in seq_along(NAMES)) {
[16:03:32.684]                   name <- changed[[kk]]
[16:03:32.684]                   NAME <- NAMES[[kk]]
[16:03:32.684]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:32.684]                     next
[16:03:32.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:32.684]                 }
[16:03:32.684]                 NAMES <- toupper(added)
[16:03:32.684]                 for (kk in seq_along(NAMES)) {
[16:03:32.684]                   name <- added[[kk]]
[16:03:32.684]                   NAME <- NAMES[[kk]]
[16:03:32.684]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:32.684]                     next
[16:03:32.684]                   args[[name]] <- ""
[16:03:32.684]                 }
[16:03:32.684]                 NAMES <- toupper(removed)
[16:03:32.684]                 for (kk in seq_along(NAMES)) {
[16:03:32.684]                   name <- removed[[kk]]
[16:03:32.684]                   NAME <- NAMES[[kk]]
[16:03:32.684]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:32.684]                     next
[16:03:32.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:32.684]                 }
[16:03:32.684]                 if (length(args) > 0) 
[16:03:32.684]                   base::do.call(base::Sys.setenv, args = args)
[16:03:32.684]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:32.684]             }
[16:03:32.684]             else {
[16:03:32.684]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:32.684]             }
[16:03:32.684]             {
[16:03:32.684]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:32.684]                   0L) {
[16:03:32.684]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:32.684]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:32.684]                   base::options(opts)
[16:03:32.684]                 }
[16:03:32.684]                 {
[16:03:32.684]                   {
[16:03:32.684]                     NULL
[16:03:32.684]                     RNGkind("Mersenne-Twister")
[16:03:32.684]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:32.684]                       inherits = FALSE)
[16:03:32.684]                   }
[16:03:32.684]                   options(future.plan = NULL)
[16:03:32.684]                   if (is.na(NA_character_)) 
[16:03:32.684]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:32.684]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:32.684]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:32.684]                     envir = parent.frame()) 
[16:03:32.684]                   {
[16:03:32.684]                     default_workers <- missing(workers)
[16:03:32.684]                     if (is.function(workers)) 
[16:03:32.684]                       workers <- workers()
[16:03:32.684]                     workers <- structure(as.integer(workers), 
[16:03:32.684]                       class = class(workers))
[16:03:32.684]                     stop_if_not(is.finite(workers), workers >= 
[16:03:32.684]                       1L)
[16:03:32.684]                     if ((workers == 1L && !inherits(workers, 
[16:03:32.684]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:32.684]                       if (default_workers) 
[16:03:32.684]                         supportsMulticore(warn = TRUE)
[16:03:32.684]                       return(sequential(..., envir = envir))
[16:03:32.684]                     }
[16:03:32.684]                     oopts <- options(mc.cores = workers)
[16:03:32.684]                     on.exit(options(oopts))
[16:03:32.684]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:32.684]                       envir = envir)
[16:03:32.684]                     if (!future$lazy) 
[16:03:32.684]                       future <- run(future)
[16:03:32.684]                     invisible(future)
[16:03:32.684]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:32.684]                 }
[16:03:32.684]             }
[16:03:32.684]         }
[16:03:32.684]     })
[16:03:32.684]     if (TRUE) {
[16:03:32.684]         base::sink(type = "output", split = FALSE)
[16:03:32.684]         if (TRUE) {
[16:03:32.684]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:32.684]         }
[16:03:32.684]         else {
[16:03:32.684]             ...future.result["stdout"] <- base::list(NULL)
[16:03:32.684]         }
[16:03:32.684]         base::close(...future.stdout)
[16:03:32.684]         ...future.stdout <- NULL
[16:03:32.684]     }
[16:03:32.684]     ...future.result$conditions <- ...future.conditions
[16:03:32.684]     ...future.result$finished <- base::Sys.time()
[16:03:32.684]     ...future.result
[16:03:32.684] }
[16:03:32.686] assign_globals() ...
[16:03:32.686] List of 5
[16:03:32.686]  $ ...future.FUN            :function (x, y)  
[16:03:32.686]  $ MoreArgs                 : NULL
[16:03:32.686]  $ ...future.elements_ii    :List of 2
[16:03:32.686]   ..$ :List of 2
[16:03:32.686]   .. ..$ : int 1
[16:03:32.686]   .. ..$ : int 0
[16:03:32.686]   ..$ :List of 2
[16:03:32.686]   .. ..$ : int 0
[16:03:32.686]   .. ..$ : int 1
[16:03:32.686]  $ ...future.seeds_ii       : NULL
[16:03:32.686]  $ ...future.globals.maxSize: NULL
[16:03:32.686]  - attr(*, "where")=List of 5
[16:03:32.686]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:32.686]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:03:32.686]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:32.686]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:32.686]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:32.686]  - attr(*, "resolved")= logi FALSE
[16:03:32.686]  - attr(*, "total_size")= num 6480
[16:03:32.686]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:32.686]  - attr(*, "already-done")= logi TRUE
[16:03:32.692] - reassign environment for ‘...future.FUN’
[16:03:32.692] - copied ‘...future.FUN’ to environment
[16:03:32.693] - copied ‘MoreArgs’ to environment
[16:03:32.693] - copied ‘...future.elements_ii’ to environment
[16:03:32.693] - copied ‘...future.seeds_ii’ to environment
[16:03:32.693] - copied ‘...future.globals.maxSize’ to environment
[16:03:32.693] assign_globals() ... done
[16:03:32.693] plan(): Setting new future strategy stack:
[16:03:32.693] List of future strategies:
[16:03:32.693] 1. sequential:
[16:03:32.693]    - args: function (..., envir = parent.frame())
[16:03:32.693]    - tweaked: FALSE
[16:03:32.693]    - call: NULL
[16:03:32.694] plan(): nbrOfWorkers() = 1
[16:03:33.195] plan(): Setting new future strategy stack:
[16:03:33.195] List of future strategies:
[16:03:33.195] 1. multicore:
[16:03:33.195]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:33.195]    - tweaked: FALSE
[16:03:33.195]    - call: plan(strategy)
[16:03:33.199] plan(): nbrOfWorkers() = 1
[16:03:33.199] SequentialFuture started (and completed)
[16:03:33.199] - Launch lazy future ... done
[16:03:33.199] run() for ‘SequentialFuture’ ... done
[16:03:33.200] Created future:
[16:03:33.200] SequentialFuture:
[16:03:33.200] Label: ‘future_mapply-1’
[16:03:33.200] Expression:
[16:03:33.200] {
[16:03:33.200]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:33.200]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:33.200]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:33.200]         on.exit(options(oopts), add = TRUE)
[16:03:33.200]     }
[16:03:33.200]     {
[16:03:33.200]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:33.200]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:03:33.200]         do.call(mapply, args = args)
[16:03:33.200]     }
[16:03:33.200] }
[16:03:33.200] Lazy evaluation: FALSE
[16:03:33.200] Asynchronous evaluation: FALSE
[16:03:33.200] Local evaluation: TRUE
[16:03:33.200] Environment: R_GlobalEnv
[16:03:33.200] Capture standard output: TRUE
[16:03:33.200] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:33.200] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:33.200] Packages: <none>
[16:03:33.200] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:33.200] Resolved: TRUE
[16:03:33.200] Value: 224 bytes of class ‘list’
[16:03:33.200] Early signaling: FALSE
[16:03:33.200] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:33.200] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:33.201] Chunk #1 of 1 ... DONE
[16:03:33.201] Launching 1 futures (chunks) ... DONE
[16:03:33.201] Resolving 1 futures (chunks) ...
[16:03:33.201] resolve() on list ...
[16:03:33.201]  recursive: 0
[16:03:33.201]  length: 1
[16:03:33.201] 
[16:03:33.201] resolved() for ‘SequentialFuture’ ...
[16:03:33.201] - state: ‘finished’
[16:03:33.201] - run: TRUE
[16:03:33.201] - result: ‘FutureResult’
[16:03:33.202] resolved() for ‘SequentialFuture’ ... done
[16:03:33.202] Future #1
[16:03:33.202] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:33.202] - nx: 1
[16:03:33.202] - relay: TRUE
[16:03:33.202] - stdout: TRUE
[16:03:33.202] - signal: TRUE
[16:03:33.202] - resignal: FALSE
[16:03:33.202] - force: TRUE
[16:03:33.202] - relayed: [n=1] FALSE
[16:03:33.202] - queued futures: [n=1] FALSE
[16:03:33.203]  - until=1
[16:03:33.203]  - relaying element #1
[16:03:33.203] - relayed: [n=1] TRUE
[16:03:33.203] - queued futures: [n=1] TRUE
[16:03:33.203] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:33.203]  length: 0 (resolved future 1)
[16:03:33.203] Relaying remaining futures
[16:03:33.203] signalConditionsASAP(NULL, pos=0) ...
[16:03:33.203] - nx: 1
[16:03:33.204] - relay: TRUE
[16:03:33.204] - stdout: TRUE
[16:03:33.204] - signal: TRUE
[16:03:33.204] - resignal: FALSE
[16:03:33.204] - force: TRUE
[16:03:33.204] - relayed: [n=1] TRUE
[16:03:33.204] - queued futures: [n=1] TRUE
 - flush all
[16:03:33.204] - relayed: [n=1] TRUE
[16:03:33.204] - queued futures: [n=1] TRUE
[16:03:33.204] signalConditionsASAP(NULL, pos=0) ... done
[16:03:33.204] resolve() on list ... DONE
[16:03:33.205]  - Number of value chunks collected: 1
[16:03:33.205] Resolving 1 futures (chunks) ... DONE
[16:03:33.205] Reducing values from 1 chunks ...
[16:03:33.205]  - Number of values collected after concatenation: 2
[16:03:33.205]  - Number of values expected: 2
[16:03:33.205] Reducing values from 1 chunks ... DONE
[16:03:33.205] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[16:03:33.206] future_mapply() ...
[16:03:33.209] Number of chunks: 1
[16:03:33.209] getGlobalsAndPackagesXApply() ...
[16:03:33.209]  - future.globals: TRUE
[16:03:33.209] getGlobalsAndPackages() ...
[16:03:33.209] Searching for globals...
[16:03:33.211] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:03:33.211] Searching for globals ... DONE
[16:03:33.211] Resolving globals: FALSE
[16:03:33.211] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:03:33.212] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:03:33.212] - globals: [1] ‘FUN’
[16:03:33.212] 
[16:03:33.212] getGlobalsAndPackages() ... DONE
[16:03:33.212]  - globals found/used: [n=1] ‘FUN’
[16:03:33.212]  - needed namespaces: [n=0] 
[16:03:33.212] Finding globals ... DONE
[16:03:33.212] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:03:33.212] List of 2
[16:03:33.212]  $ ...future.FUN:function (x, y)  
[16:03:33.212]  $ MoreArgs     : NULL
[16:03:33.212]  - attr(*, "where")=List of 2
[16:03:33.212]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:33.212]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:03:33.212]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:33.212]  - attr(*, "resolved")= logi FALSE
[16:03:33.212]  - attr(*, "total_size")= num NA
[16:03:33.215] Packages to be attached in all futures: [n=0] 
[16:03:33.215] getGlobalsAndPackagesXApply() ... DONE
[16:03:33.215] Number of futures (= number of chunks): 1
[16:03:33.215] Launching 1 futures (chunks) ...
[16:03:33.215] Chunk #1 of 1 ...
[16:03:33.215]  - Finding globals in '...' for chunk #1 ...
[16:03:33.216] getGlobalsAndPackages() ...
[16:03:33.216] Searching for globals...
[16:03:33.216] 
[16:03:33.216] Searching for globals ... DONE
[16:03:33.216] - globals: [0] <none>
[16:03:33.216] getGlobalsAndPackages() ... DONE
[16:03:33.216]    + additional globals found: [n=0] 
[16:03:33.216]    + additional namespaces needed: [n=0] 
[16:03:33.216]  - Finding globals in '...' for chunk #1 ... DONE
[16:03:33.217]  - seeds: <none>
[16:03:33.217]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:33.217] getGlobalsAndPackages() ...
[16:03:33.217] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:33.217] Resolving globals: FALSE
[16:03:33.217] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[16:03:33.218] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:03:33.218] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:33.218] 
[16:03:33.218] getGlobalsAndPackages() ... DONE
[16:03:33.220] run() for ‘Future’ ...
[16:03:33.220] - state: ‘created’
[16:03:33.220] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:33.224] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:33.224] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:33.224]   - Field: ‘label’
[16:03:33.224]   - Field: ‘local’
[16:03:33.224]   - Field: ‘owner’
[16:03:33.224]   - Field: ‘envir’
[16:03:33.224]   - Field: ‘packages’
[16:03:33.224]   - Field: ‘gc’
[16:03:33.224]   - Field: ‘conditions’
[16:03:33.224]   - Field: ‘expr’
[16:03:33.225]   - Field: ‘uuid’
[16:03:33.225]   - Field: ‘seed’
[16:03:33.225]   - Field: ‘version’
[16:03:33.225]   - Field: ‘result’
[16:03:33.225]   - Field: ‘asynchronous’
[16:03:33.225]   - Field: ‘calls’
[16:03:33.225]   - Field: ‘globals’
[16:03:33.225]   - Field: ‘stdout’
[16:03:33.225]   - Field: ‘earlySignal’
[16:03:33.225]   - Field: ‘lazy’
[16:03:33.225]   - Field: ‘state’
[16:03:33.226] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:33.226] - Launch lazy future ...
[16:03:33.226] Packages needed by the future expression (n = 0): <none>
[16:03:33.226] Packages needed by future strategies (n = 0): <none>
[16:03:33.226] {
[16:03:33.226]     {
[16:03:33.226]         {
[16:03:33.226]             ...future.startTime <- base::Sys.time()
[16:03:33.226]             {
[16:03:33.226]                 {
[16:03:33.226]                   {
[16:03:33.226]                     base::local({
[16:03:33.226]                       has_future <- base::requireNamespace("future", 
[16:03:33.226]                         quietly = TRUE)
[16:03:33.226]                       if (has_future) {
[16:03:33.226]                         ns <- base::getNamespace("future")
[16:03:33.226]                         version <- ns[[".package"]][["version"]]
[16:03:33.226]                         if (is.null(version)) 
[16:03:33.226]                           version <- utils::packageVersion("future")
[16:03:33.226]                       }
[16:03:33.226]                       else {
[16:03:33.226]                         version <- NULL
[16:03:33.226]                       }
[16:03:33.226]                       if (!has_future || version < "1.8.0") {
[16:03:33.226]                         info <- base::c(r_version = base::gsub("R version ", 
[16:03:33.226]                           "", base::R.version$version.string), 
[16:03:33.226]                           platform = base::sprintf("%s (%s-bit)", 
[16:03:33.226]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:33.226]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:33.226]                             "release", "version")], collapse = " "), 
[16:03:33.226]                           hostname = base::Sys.info()[["nodename"]])
[16:03:33.226]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:03:33.226]                           info)
[16:03:33.226]                         info <- base::paste(info, collapse = "; ")
[16:03:33.226]                         if (!has_future) {
[16:03:33.226]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:33.226]                             info)
[16:03:33.226]                         }
[16:03:33.226]                         else {
[16:03:33.226]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:33.226]                             info, version)
[16:03:33.226]                         }
[16:03:33.226]                         base::stop(msg)
[16:03:33.226]                       }
[16:03:33.226]                     })
[16:03:33.226]                   }
[16:03:33.226]                   options(future.plan = NULL)
[16:03:33.226]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:33.226]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:33.226]                 }
[16:03:33.226]                 ...future.workdir <- getwd()
[16:03:33.226]             }
[16:03:33.226]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:33.226]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:33.226]         }
[16:03:33.226]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:33.226]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:33.226]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:33.226]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:33.226]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:33.226]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:33.226]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:33.226]             base::names(...future.oldOptions))
[16:03:33.226]     }
[16:03:33.226]     if (TRUE) {
[16:03:33.226]     }
[16:03:33.226]     else {
[16:03:33.226]         if (NA) {
[16:03:33.226]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:33.226]                 open = "w")
[16:03:33.226]         }
[16:03:33.226]         else {
[16:03:33.226]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:33.226]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:33.226]         }
[16:03:33.226]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:33.226]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:33.226]             base::sink(type = "output", split = FALSE)
[16:03:33.226]             base::close(...future.stdout)
[16:03:33.226]         }, add = TRUE)
[16:03:33.226]     }
[16:03:33.226]     ...future.frame <- base::sys.nframe()
[16:03:33.226]     ...future.conditions <- base::list()
[16:03:33.226]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:33.226]     if (FALSE) {
[16:03:33.226]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:33.226]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:33.226]     }
[16:03:33.226]     ...future.result <- base::tryCatch({
[16:03:33.226]         base::withCallingHandlers({
[16:03:33.226]             ...future.value <- base::withVisible(base::local({
[16:03:33.226]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:33.226]                 if (!identical(...future.globals.maxSize.org, 
[16:03:33.226]                   ...future.globals.maxSize)) {
[16:03:33.226]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:33.226]                   on.exit(options(oopts), add = TRUE)
[16:03:33.226]                 }
[16:03:33.226]                 {
[16:03:33.226]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:33.226]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:03:33.226]                     USE.NAMES = FALSE)
[16:03:33.226]                   do.call(mapply, args = args)
[16:03:33.226]                 }
[16:03:33.226]             }))
[16:03:33.226]             future::FutureResult(value = ...future.value$value, 
[16:03:33.226]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:33.226]                   ...future.rng), globalenv = if (FALSE) 
[16:03:33.226]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:33.226]                     ...future.globalenv.names))
[16:03:33.226]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:33.226]         }, condition = base::local({
[16:03:33.226]             c <- base::c
[16:03:33.226]             inherits <- base::inherits
[16:03:33.226]             invokeRestart <- base::invokeRestart
[16:03:33.226]             length <- base::length
[16:03:33.226]             list <- base::list
[16:03:33.226]             seq.int <- base::seq.int
[16:03:33.226]             signalCondition <- base::signalCondition
[16:03:33.226]             sys.calls <- base::sys.calls
[16:03:33.226]             `[[` <- base::`[[`
[16:03:33.226]             `+` <- base::`+`
[16:03:33.226]             `<<-` <- base::`<<-`
[16:03:33.226]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:33.226]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:33.226]                   3L)]
[16:03:33.226]             }
[16:03:33.226]             function(cond) {
[16:03:33.226]                 is_error <- inherits(cond, "error")
[16:03:33.226]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:33.226]                   NULL)
[16:03:33.226]                 if (is_error) {
[16:03:33.226]                   sessionInformation <- function() {
[16:03:33.226]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:33.226]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:33.226]                       search = base::search(), system = base::Sys.info())
[16:03:33.226]                   }
[16:03:33.226]                   ...future.conditions[[length(...future.conditions) + 
[16:03:33.226]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:33.226]                     cond$call), session = sessionInformation(), 
[16:03:33.226]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:33.226]                   signalCondition(cond)
[16:03:33.226]                 }
[16:03:33.226]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:33.226]                 "immediateCondition"))) {
[16:03:33.226]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:33.226]                   ...future.conditions[[length(...future.conditions) + 
[16:03:33.226]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:33.226]                   if (TRUE && !signal) {
[16:03:33.226]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:33.226]                     {
[16:03:33.226]                       inherits <- base::inherits
[16:03:33.226]                       invokeRestart <- base::invokeRestart
[16:03:33.226]                       is.null <- base::is.null
[16:03:33.226]                       muffled <- FALSE
[16:03:33.226]                       if (inherits(cond, "message")) {
[16:03:33.226]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:33.226]                         if (muffled) 
[16:03:33.226]                           invokeRestart("muffleMessage")
[16:03:33.226]                       }
[16:03:33.226]                       else if (inherits(cond, "warning")) {
[16:03:33.226]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:33.226]                         if (muffled) 
[16:03:33.226]                           invokeRestart("muffleWarning")
[16:03:33.226]                       }
[16:03:33.226]                       else if (inherits(cond, "condition")) {
[16:03:33.226]                         if (!is.null(pattern)) {
[16:03:33.226]                           computeRestarts <- base::computeRestarts
[16:03:33.226]                           grepl <- base::grepl
[16:03:33.226]                           restarts <- computeRestarts(cond)
[16:03:33.226]                           for (restart in restarts) {
[16:03:33.226]                             name <- restart$name
[16:03:33.226]                             if (is.null(name)) 
[16:03:33.226]                               next
[16:03:33.226]                             if (!grepl(pattern, name)) 
[16:03:33.226]                               next
[16:03:33.226]                             invokeRestart(restart)
[16:03:33.226]                             muffled <- TRUE
[16:03:33.226]                             break
[16:03:33.226]                           }
[16:03:33.226]                         }
[16:03:33.226]                       }
[16:03:33.226]                       invisible(muffled)
[16:03:33.226]                     }
[16:03:33.226]                     muffleCondition(cond, pattern = "^muffle")
[16:03:33.226]                   }
[16:03:33.226]                 }
[16:03:33.226]                 else {
[16:03:33.226]                   if (TRUE) {
[16:03:33.226]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:33.226]                     {
[16:03:33.226]                       inherits <- base::inherits
[16:03:33.226]                       invokeRestart <- base::invokeRestart
[16:03:33.226]                       is.null <- base::is.null
[16:03:33.226]                       muffled <- FALSE
[16:03:33.226]                       if (inherits(cond, "message")) {
[16:03:33.226]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:33.226]                         if (muffled) 
[16:03:33.226]                           invokeRestart("muffleMessage")
[16:03:33.226]                       }
[16:03:33.226]                       else if (inherits(cond, "warning")) {
[16:03:33.226]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:33.226]                         if (muffled) 
[16:03:33.226]                           invokeRestart("muffleWarning")
[16:03:33.226]                       }
[16:03:33.226]                       else if (inherits(cond, "condition")) {
[16:03:33.226]                         if (!is.null(pattern)) {
[16:03:33.226]                           computeRestarts <- base::computeRestarts
[16:03:33.226]                           grepl <- base::grepl
[16:03:33.226]                           restarts <- computeRestarts(cond)
[16:03:33.226]                           for (restart in restarts) {
[16:03:33.226]                             name <- restart$name
[16:03:33.226]                             if (is.null(name)) 
[16:03:33.226]                               next
[16:03:33.226]                             if (!grepl(pattern, name)) 
[16:03:33.226]                               next
[16:03:33.226]                             invokeRestart(restart)
[16:03:33.226]                             muffled <- TRUE
[16:03:33.226]                             break
[16:03:33.226]                           }
[16:03:33.226]                         }
[16:03:33.226]                       }
[16:03:33.226]                       invisible(muffled)
[16:03:33.226]                     }
[16:03:33.226]                     muffleCondition(cond, pattern = "^muffle")
[16:03:33.226]                   }
[16:03:33.226]                 }
[16:03:33.226]             }
[16:03:33.226]         }))
[16:03:33.226]     }, error = function(ex) {
[16:03:33.226]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:33.226]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:33.226]                 ...future.rng), started = ...future.startTime, 
[16:03:33.226]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:33.226]             version = "1.8"), class = "FutureResult")
[16:03:33.226]     }, finally = {
[16:03:33.226]         if (!identical(...future.workdir, getwd())) 
[16:03:33.226]             setwd(...future.workdir)
[16:03:33.226]         {
[16:03:33.226]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:33.226]                 ...future.oldOptions$nwarnings <- NULL
[16:03:33.226]             }
[16:03:33.226]             base::options(...future.oldOptions)
[16:03:33.226]             if (.Platform$OS.type == "windows") {
[16:03:33.226]                 old_names <- names(...future.oldEnvVars)
[16:03:33.226]                 envs <- base::Sys.getenv()
[16:03:33.226]                 names <- names(envs)
[16:03:33.226]                 common <- intersect(names, old_names)
[16:03:33.226]                 added <- setdiff(names, old_names)
[16:03:33.226]                 removed <- setdiff(old_names, names)
[16:03:33.226]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:33.226]                   envs[common]]
[16:03:33.226]                 NAMES <- toupper(changed)
[16:03:33.226]                 args <- list()
[16:03:33.226]                 for (kk in seq_along(NAMES)) {
[16:03:33.226]                   name <- changed[[kk]]
[16:03:33.226]                   NAME <- NAMES[[kk]]
[16:03:33.226]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:33.226]                     next
[16:03:33.226]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:33.226]                 }
[16:03:33.226]                 NAMES <- toupper(added)
[16:03:33.226]                 for (kk in seq_along(NAMES)) {
[16:03:33.226]                   name <- added[[kk]]
[16:03:33.226]                   NAME <- NAMES[[kk]]
[16:03:33.226]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:33.226]                     next
[16:03:33.226]                   args[[name]] <- ""
[16:03:33.226]                 }
[16:03:33.226]                 NAMES <- toupper(removed)
[16:03:33.226]                 for (kk in seq_along(NAMES)) {
[16:03:33.226]                   name <- removed[[kk]]
[16:03:33.226]                   NAME <- NAMES[[kk]]
[16:03:33.226]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:33.226]                     next
[16:03:33.226]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:33.226]                 }
[16:03:33.226]                 if (length(args) > 0) 
[16:03:33.226]                   base::do.call(base::Sys.setenv, args = args)
[16:03:33.226]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:33.226]             }
[16:03:33.226]             else {
[16:03:33.226]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:33.226]             }
[16:03:33.226]             {
[16:03:33.226]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:33.226]                   0L) {
[16:03:33.226]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:33.226]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:33.226]                   base::options(opts)
[16:03:33.226]                 }
[16:03:33.226]                 {
[16:03:33.226]                   {
[16:03:33.226]                     NULL
[16:03:33.226]                     RNGkind("Mersenne-Twister")
[16:03:33.226]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:33.226]                       inherits = FALSE)
[16:03:33.226]                   }
[16:03:33.226]                   options(future.plan = NULL)
[16:03:33.226]                   if (is.na(NA_character_)) 
[16:03:33.226]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:33.226]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:33.226]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:33.226]                     envir = parent.frame()) 
[16:03:33.226]                   {
[16:03:33.226]                     default_workers <- missing(workers)
[16:03:33.226]                     if (is.function(workers)) 
[16:03:33.226]                       workers <- workers()
[16:03:33.226]                     workers <- structure(as.integer(workers), 
[16:03:33.226]                       class = class(workers))
[16:03:33.226]                     stop_if_not(is.finite(workers), workers >= 
[16:03:33.226]                       1L)
[16:03:33.226]                     if ((workers == 1L && !inherits(workers, 
[16:03:33.226]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:33.226]                       if (default_workers) 
[16:03:33.226]                         supportsMulticore(warn = TRUE)
[16:03:33.226]                       return(sequential(..., envir = envir))
[16:03:33.226]                     }
[16:03:33.226]                     oopts <- options(mc.cores = workers)
[16:03:33.226]                     on.exit(options(oopts))
[16:03:33.226]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:33.226]                       envir = envir)
[16:03:33.226]                     if (!future$lazy) 
[16:03:33.226]                       future <- run(future)
[16:03:33.226]                     invisible(future)
[16:03:33.226]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:33.226]                 }
[16:03:33.226]             }
[16:03:33.226]         }
[16:03:33.226]     })
[16:03:33.226]     if (FALSE) {
[16:03:33.226]         base::sink(type = "output", split = FALSE)
[16:03:33.226]         if (NA) {
[16:03:33.226]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:33.226]         }
[16:03:33.226]         else {
[16:03:33.226]             ...future.result["stdout"] <- base::list(NULL)
[16:03:33.226]         }
[16:03:33.226]         base::close(...future.stdout)
[16:03:33.226]         ...future.stdout <- NULL
[16:03:33.226]     }
[16:03:33.226]     ...future.result$conditions <- ...future.conditions
[16:03:33.226]     ...future.result$finished <- base::Sys.time()
[16:03:33.226]     ...future.result
[16:03:33.226] }
[16:03:33.228] assign_globals() ...
[16:03:33.228] List of 5
[16:03:33.228]  $ ...future.FUN            :function (x, y)  
[16:03:33.228]  $ MoreArgs                 : NULL
[16:03:33.228]  $ ...future.elements_ii    :List of 2
[16:03:33.228]   ..$ :List of 2
[16:03:33.228]   .. ..$ : int 1
[16:03:33.228]   .. ..$ : int 0
[16:03:33.228]   ..$ :List of 2
[16:03:33.228]   .. ..$ : int 0
[16:03:33.228]   .. ..$ : int 1
[16:03:33.228]  $ ...future.seeds_ii       : NULL
[16:03:33.228]  $ ...future.globals.maxSize: NULL
[16:03:33.228]  - attr(*, "where")=List of 5
[16:03:33.228]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:33.228]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:03:33.228]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:33.228]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:33.228]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:33.228]  - attr(*, "resolved")= logi FALSE
[16:03:33.228]  - attr(*, "total_size")= num 6480
[16:03:33.228]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:33.228]  - attr(*, "already-done")= logi TRUE
[16:03:33.234] - reassign environment for ‘...future.FUN’
[16:03:33.234] - copied ‘...future.FUN’ to environment
[16:03:33.234] - copied ‘MoreArgs’ to environment
[16:03:33.234] - copied ‘...future.elements_ii’ to environment
[16:03:33.234] - copied ‘...future.seeds_ii’ to environment
[16:03:33.234] - copied ‘...future.globals.maxSize’ to environment
[16:03:33.234] assign_globals() ... done
[16:03:33.234] plan(): Setting new future strategy stack:
[16:03:33.234] List of future strategies:
[16:03:33.234] 1. sequential:
[16:03:33.234]    - args: function (..., envir = parent.frame())
[16:03:33.234]    - tweaked: FALSE
[16:03:33.234]    - call: NULL
[16:03:33.235] plan(): nbrOfWorkers() = 1
[16:03:33.736] plan(): Setting new future strategy stack:
[16:03:33.737] List of future strategies:
[16:03:33.737] 1. multicore:
[16:03:33.737]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:33.737]    - tweaked: FALSE
[16:03:33.737]    - call: plan(strategy)
[16:03:33.741] plan(): nbrOfWorkers() = 1
[16:03:33.741] SequentialFuture started (and completed)
[16:03:33.741] - Launch lazy future ... done
[16:03:33.741] run() for ‘SequentialFuture’ ... done
[16:03:33.741] Created future:
[16:03:33.741] SequentialFuture:
[16:03:33.741] Label: ‘future_mapply-1’
[16:03:33.741] Expression:
[16:03:33.741] {
[16:03:33.741]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:33.741]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:33.741]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:33.741]         on.exit(options(oopts), add = TRUE)
[16:03:33.741]     }
[16:03:33.741]     {
[16:03:33.741]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:33.741]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:03:33.741]         do.call(mapply, args = args)
[16:03:33.741]     }
[16:03:33.741] }
[16:03:33.741] Lazy evaluation: FALSE
[16:03:33.741] Asynchronous evaluation: FALSE
[16:03:33.741] Local evaluation: TRUE
[16:03:33.741] Environment: R_GlobalEnv
[16:03:33.741] Capture standard output: NA
[16:03:33.741] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:33.741] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:33.741] Packages: <none>
[16:03:33.741] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:33.741] Resolved: TRUE
[16:03:33.741] Value: 224 bytes of class ‘list’
[16:03:33.741] Early signaling: FALSE
[16:03:33.741] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:33.741] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:33.742] Chunk #1 of 1 ... DONE
[16:03:33.742] Launching 1 futures (chunks) ... DONE
[16:03:33.742] Resolving 1 futures (chunks) ...
[16:03:33.743] resolve() on list ...
[16:03:33.743]  recursive: 0
[16:03:33.743]  length: 1
[16:03:33.743] 
[16:03:33.743] resolved() for ‘SequentialFuture’ ...
[16:03:33.743] - state: ‘finished’
[16:03:33.743] - run: TRUE
[16:03:33.743] - result: ‘FutureResult’
[16:03:33.743] resolved() for ‘SequentialFuture’ ... done
[16:03:33.743] Future #1
[16:03:33.744] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:33.744] - nx: 1
[16:03:33.744] - relay: TRUE
[16:03:33.744] - stdout: TRUE
[16:03:33.744] - signal: TRUE
[16:03:33.744] - resignal: FALSE
[16:03:33.744] - force: TRUE
[16:03:33.744] - relayed: [n=1] FALSE
[16:03:33.744] - queued futures: [n=1] FALSE
[16:03:33.744]  - until=1
[16:03:33.744]  - relaying element #1
[16:03:33.745] - relayed: [n=1] TRUE
[16:03:33.745] - queued futures: [n=1] TRUE
[16:03:33.745] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:33.745]  length: 0 (resolved future 1)
[16:03:33.745] Relaying remaining futures
[16:03:33.745] signalConditionsASAP(NULL, pos=0) ...
[16:03:33.745] - nx: 1
[16:03:33.745] - relay: TRUE
[16:03:33.745] - stdout: TRUE
[16:03:33.745] - signal: TRUE
[16:03:33.746] - resignal: FALSE
[16:03:33.746] - force: TRUE
[16:03:33.746] - relayed: [n=1] TRUE
[16:03:33.746] - queued futures: [n=1] TRUE
 - flush all
[16:03:33.746] - relayed: [n=1] TRUE
[16:03:33.746] - queued futures: [n=1] TRUE
[16:03:33.746] signalConditionsASAP(NULL, pos=0) ... done
[16:03:33.746] resolve() on list ... DONE
[16:03:33.746]  - Number of value chunks collected: 1
[16:03:33.746] Resolving 1 futures (chunks) ... DONE
[16:03:33.746] Reducing values from 1 chunks ...
[16:03:33.747]  - Number of values collected after concatenation: 2
[16:03:33.747]  - Number of values expected: 2
[16:03:33.747] Reducing values from 1 chunks ... DONE
[16:03:33.747] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[16:03:33.747] plan(): Setting new future strategy stack:
[16:03:33.748] List of future strategies:
[16:03:33.748] 1. multisession:
[16:03:33.748]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:03:33.748]    - tweaked: FALSE
[16:03:33.748]    - call: plan(strategy)
[16:03:33.773] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:03:33.773] multisession:
[16:03:33.773] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:03:33.773] - tweaked: FALSE
[16:03:33.773] - call: plan(strategy)
[16:03:33.777] getGlobalsAndPackages() ...
[16:03:33.778] Not searching for globals
[16:03:33.778] - globals: [0] <none>
[16:03:33.778] getGlobalsAndPackages() ... DONE
[16:03:33.778] Packages needed by the future expression (n = 0): <none>
[16:03:33.778] Packages needed by future strategies (n = 0): <none>
[16:03:33.779] {
[16:03:33.779]     {
[16:03:33.779]         {
[16:03:33.779]             ...future.startTime <- base::Sys.time()
[16:03:33.779]             {
[16:03:33.779]                 {
[16:03:33.779]                   {
[16:03:33.779]                     base::local({
[16:03:33.779]                       has_future <- base::requireNamespace("future", 
[16:03:33.779]                         quietly = TRUE)
[16:03:33.779]                       if (has_future) {
[16:03:33.779]                         ns <- base::getNamespace("future")
[16:03:33.779]                         version <- ns[[".package"]][["version"]]
[16:03:33.779]                         if (is.null(version)) 
[16:03:33.779]                           version <- utils::packageVersion("future")
[16:03:33.779]                       }
[16:03:33.779]                       else {
[16:03:33.779]                         version <- NULL
[16:03:33.779]                       }
[16:03:33.779]                       if (!has_future || version < "1.8.0") {
[16:03:33.779]                         info <- base::c(r_version = base::gsub("R version ", 
[16:03:33.779]                           "", base::R.version$version.string), 
[16:03:33.779]                           platform = base::sprintf("%s (%s-bit)", 
[16:03:33.779]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:33.779]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:33.779]                             "release", "version")], collapse = " "), 
[16:03:33.779]                           hostname = base::Sys.info()[["nodename"]])
[16:03:33.779]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:03:33.779]                           info)
[16:03:33.779]                         info <- base::paste(info, collapse = "; ")
[16:03:33.779]                         if (!has_future) {
[16:03:33.779]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:33.779]                             info)
[16:03:33.779]                         }
[16:03:33.779]                         else {
[16:03:33.779]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:33.779]                             info, version)
[16:03:33.779]                         }
[16:03:33.779]                         base::stop(msg)
[16:03:33.779]                       }
[16:03:33.779]                     })
[16:03:33.779]                   }
[16:03:33.779]                   options(future.plan = NULL)
[16:03:33.779]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:33.779]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:33.779]                 }
[16:03:33.779]                 ...future.workdir <- getwd()
[16:03:33.779]             }
[16:03:33.779]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:33.779]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:33.779]         }
[16:03:33.779]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:33.779]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:33.779]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:33.779]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:33.779]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:33.779]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:33.779]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:33.779]             base::names(...future.oldOptions))
[16:03:33.779]     }
[16:03:33.779]     if (FALSE) {
[16:03:33.779]     }
[16:03:33.779]     else {
[16:03:33.779]         if (TRUE) {
[16:03:33.779]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:33.779]                 open = "w")
[16:03:33.779]         }
[16:03:33.779]         else {
[16:03:33.779]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:33.779]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:33.779]         }
[16:03:33.779]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:33.779]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:33.779]             base::sink(type = "output", split = FALSE)
[16:03:33.779]             base::close(...future.stdout)
[16:03:33.779]         }, add = TRUE)
[16:03:33.779]     }
[16:03:33.779]     ...future.frame <- base::sys.nframe()
[16:03:33.779]     ...future.conditions <- base::list()
[16:03:33.779]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:33.779]     if (FALSE) {
[16:03:33.779]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:33.779]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:33.779]     }
[16:03:33.779]     ...future.result <- base::tryCatch({
[16:03:33.779]         base::withCallingHandlers({
[16:03:33.779]             ...future.value <- base::withVisible(base::local(NA))
[16:03:33.779]             future::FutureResult(value = ...future.value$value, 
[16:03:33.779]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:33.779]                   ...future.rng), globalenv = if (FALSE) 
[16:03:33.779]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:33.779]                     ...future.globalenv.names))
[16:03:33.779]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:33.779]         }, condition = base::local({
[16:03:33.779]             c <- base::c
[16:03:33.779]             inherits <- base::inherits
[16:03:33.779]             invokeRestart <- base::invokeRestart
[16:03:33.779]             length <- base::length
[16:03:33.779]             list <- base::list
[16:03:33.779]             seq.int <- base::seq.int
[16:03:33.779]             signalCondition <- base::signalCondition
[16:03:33.779]             sys.calls <- base::sys.calls
[16:03:33.779]             `[[` <- base::`[[`
[16:03:33.779]             `+` <- base::`+`
[16:03:33.779]             `<<-` <- base::`<<-`
[16:03:33.779]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:33.779]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:33.779]                   3L)]
[16:03:33.779]             }
[16:03:33.779]             function(cond) {
[16:03:33.779]                 is_error <- inherits(cond, "error")
[16:03:33.779]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:33.779]                   NULL)
[16:03:33.779]                 if (is_error) {
[16:03:33.779]                   sessionInformation <- function() {
[16:03:33.779]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:33.779]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:33.779]                       search = base::search(), system = base::Sys.info())
[16:03:33.779]                   }
[16:03:33.779]                   ...future.conditions[[length(...future.conditions) + 
[16:03:33.779]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:33.779]                     cond$call), session = sessionInformation(), 
[16:03:33.779]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:33.779]                   signalCondition(cond)
[16:03:33.779]                 }
[16:03:33.779]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:33.779]                 "immediateCondition"))) {
[16:03:33.779]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:33.779]                   ...future.conditions[[length(...future.conditions) + 
[16:03:33.779]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:33.779]                   if (TRUE && !signal) {
[16:03:33.779]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:33.779]                     {
[16:03:33.779]                       inherits <- base::inherits
[16:03:33.779]                       invokeRestart <- base::invokeRestart
[16:03:33.779]                       is.null <- base::is.null
[16:03:33.779]                       muffled <- FALSE
[16:03:33.779]                       if (inherits(cond, "message")) {
[16:03:33.779]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:33.779]                         if (muffled) 
[16:03:33.779]                           invokeRestart("muffleMessage")
[16:03:33.779]                       }
[16:03:33.779]                       else if (inherits(cond, "warning")) {
[16:03:33.779]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:33.779]                         if (muffled) 
[16:03:33.779]                           invokeRestart("muffleWarning")
[16:03:33.779]                       }
[16:03:33.779]                       else if (inherits(cond, "condition")) {
[16:03:33.779]                         if (!is.null(pattern)) {
[16:03:33.779]                           computeRestarts <- base::computeRestarts
[16:03:33.779]                           grepl <- base::grepl
[16:03:33.779]                           restarts <- computeRestarts(cond)
[16:03:33.779]                           for (restart in restarts) {
[16:03:33.779]                             name <- restart$name
[16:03:33.779]                             if (is.null(name)) 
[16:03:33.779]                               next
[16:03:33.779]                             if (!grepl(pattern, name)) 
[16:03:33.779]                               next
[16:03:33.779]                             invokeRestart(restart)
[16:03:33.779]                             muffled <- TRUE
[16:03:33.779]                             break
[16:03:33.779]                           }
[16:03:33.779]                         }
[16:03:33.779]                       }
[16:03:33.779]                       invisible(muffled)
[16:03:33.779]                     }
[16:03:33.779]                     muffleCondition(cond, pattern = "^muffle")
[16:03:33.779]                   }
[16:03:33.779]                 }
[16:03:33.779]                 else {
[16:03:33.779]                   if (TRUE) {
[16:03:33.779]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:33.779]                     {
[16:03:33.779]                       inherits <- base::inherits
[16:03:33.779]                       invokeRestart <- base::invokeRestart
[16:03:33.779]                       is.null <- base::is.null
[16:03:33.779]                       muffled <- FALSE
[16:03:33.779]                       if (inherits(cond, "message")) {
[16:03:33.779]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:33.779]                         if (muffled) 
[16:03:33.779]                           invokeRestart("muffleMessage")
[16:03:33.779]                       }
[16:03:33.779]                       else if (inherits(cond, "warning")) {
[16:03:33.779]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:33.779]                         if (muffled) 
[16:03:33.779]                           invokeRestart("muffleWarning")
[16:03:33.779]                       }
[16:03:33.779]                       else if (inherits(cond, "condition")) {
[16:03:33.779]                         if (!is.null(pattern)) {
[16:03:33.779]                           computeRestarts <- base::computeRestarts
[16:03:33.779]                           grepl <- base::grepl
[16:03:33.779]                           restarts <- computeRestarts(cond)
[16:03:33.779]                           for (restart in restarts) {
[16:03:33.779]                             name <- restart$name
[16:03:33.779]                             if (is.null(name)) 
[16:03:33.779]                               next
[16:03:33.779]                             if (!grepl(pattern, name)) 
[16:03:33.779]                               next
[16:03:33.779]                             invokeRestart(restart)
[16:03:33.779]                             muffled <- TRUE
[16:03:33.779]                             break
[16:03:33.779]                           }
[16:03:33.779]                         }
[16:03:33.779]                       }
[16:03:33.779]                       invisible(muffled)
[16:03:33.779]                     }
[16:03:33.779]                     muffleCondition(cond, pattern = "^muffle")
[16:03:33.779]                   }
[16:03:33.779]                 }
[16:03:33.779]             }
[16:03:33.779]         }))
[16:03:33.779]     }, error = function(ex) {
[16:03:33.779]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:33.779]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:33.779]                 ...future.rng), started = ...future.startTime, 
[16:03:33.779]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:33.779]             version = "1.8"), class = "FutureResult")
[16:03:33.779]     }, finally = {
[16:03:33.779]         if (!identical(...future.workdir, getwd())) 
[16:03:33.779]             setwd(...future.workdir)
[16:03:33.779]         {
[16:03:33.779]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:33.779]                 ...future.oldOptions$nwarnings <- NULL
[16:03:33.779]             }
[16:03:33.779]             base::options(...future.oldOptions)
[16:03:33.779]             if (.Platform$OS.type == "windows") {
[16:03:33.779]                 old_names <- names(...future.oldEnvVars)
[16:03:33.779]                 envs <- base::Sys.getenv()
[16:03:33.779]                 names <- names(envs)
[16:03:33.779]                 common <- intersect(names, old_names)
[16:03:33.779]                 added <- setdiff(names, old_names)
[16:03:33.779]                 removed <- setdiff(old_names, names)
[16:03:33.779]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:33.779]                   envs[common]]
[16:03:33.779]                 NAMES <- toupper(changed)
[16:03:33.779]                 args <- list()
[16:03:33.779]                 for (kk in seq_along(NAMES)) {
[16:03:33.779]                   name <- changed[[kk]]
[16:03:33.779]                   NAME <- NAMES[[kk]]
[16:03:33.779]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:33.779]                     next
[16:03:33.779]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:33.779]                 }
[16:03:33.779]                 NAMES <- toupper(added)
[16:03:33.779]                 for (kk in seq_along(NAMES)) {
[16:03:33.779]                   name <- added[[kk]]
[16:03:33.779]                   NAME <- NAMES[[kk]]
[16:03:33.779]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:33.779]                     next
[16:03:33.779]                   args[[name]] <- ""
[16:03:33.779]                 }
[16:03:33.779]                 NAMES <- toupper(removed)
[16:03:33.779]                 for (kk in seq_along(NAMES)) {
[16:03:33.779]                   name <- removed[[kk]]
[16:03:33.779]                   NAME <- NAMES[[kk]]
[16:03:33.779]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:33.779]                     next
[16:03:33.779]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:33.779]                 }
[16:03:33.779]                 if (length(args) > 0) 
[16:03:33.779]                   base::do.call(base::Sys.setenv, args = args)
[16:03:33.779]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:33.779]             }
[16:03:33.779]             else {
[16:03:33.779]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:33.779]             }
[16:03:33.779]             {
[16:03:33.779]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:33.779]                   0L) {
[16:03:33.779]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:33.779]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:33.779]                   base::options(opts)
[16:03:33.779]                 }
[16:03:33.779]                 {
[16:03:33.779]                   {
[16:03:33.779]                     NULL
[16:03:33.779]                     RNGkind("Mersenne-Twister")
[16:03:33.779]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:33.779]                       inherits = FALSE)
[16:03:33.779]                   }
[16:03:33.779]                   options(future.plan = NULL)
[16:03:33.779]                   if (is.na(NA_character_)) 
[16:03:33.779]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:33.779]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:33.779]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:33.779]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:33.779]                     envir = parent.frame()) 
[16:03:33.779]                   {
[16:03:33.779]                     if (is.function(workers)) 
[16:03:33.779]                       workers <- workers()
[16:03:33.779]                     workers <- structure(as.integer(workers), 
[16:03:33.779]                       class = class(workers))
[16:03:33.779]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:33.779]                       workers >= 1)
[16:03:33.779]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:33.779]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:33.779]                     }
[16:03:33.779]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:33.779]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:33.779]                       envir = envir)
[16:03:33.779]                     if (!future$lazy) 
[16:03:33.779]                       future <- run(future)
[16:03:33.779]                     invisible(future)
[16:03:33.779]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:33.779]                 }
[16:03:33.779]             }
[16:03:33.779]         }
[16:03:33.779]     })
[16:03:33.779]     if (TRUE) {
[16:03:33.779]         base::sink(type = "output", split = FALSE)
[16:03:33.779]         if (TRUE) {
[16:03:33.779]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:33.779]         }
[16:03:33.779]         else {
[16:03:33.779]             ...future.result["stdout"] <- base::list(NULL)
[16:03:33.779]         }
[16:03:33.779]         base::close(...future.stdout)
[16:03:33.779]         ...future.stdout <- NULL
[16:03:33.779]     }
[16:03:33.779]     ...future.result$conditions <- ...future.conditions
[16:03:33.779]     ...future.result$finished <- base::Sys.time()
[16:03:33.779]     ...future.result
[16:03:33.779] }
[16:03:33.781] plan(): Setting new future strategy stack:
[16:03:33.781] List of future strategies:
[16:03:33.781] 1. sequential:
[16:03:33.781]    - args: function (..., envir = parent.frame())
[16:03:33.781]    - tweaked: FALSE
[16:03:33.781]    - call: NULL
[16:03:33.781] plan(): nbrOfWorkers() = 1
[16:03:33.782] plan(): Setting new future strategy stack:
[16:03:33.782] List of future strategies:
[16:03:33.782] 1. multisession:
[16:03:33.782]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:03:33.782]    - tweaked: FALSE
[16:03:33.782]    - call: plan(strategy)
[16:03:33.785] plan(): nbrOfWorkers() = 1
[16:03:33.786] SequentialFuture started (and completed)
[16:03:33.786] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:03:33.789] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[16:03:33.789] future_lapply() ...
[16:03:33.793] Number of chunks: 1
[16:03:33.793] getGlobalsAndPackagesXApply() ...
[16:03:33.793]  - future.globals: TRUE
[16:03:33.793] getGlobalsAndPackages() ...
[16:03:33.793] Searching for globals...
[16:03:33.794] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:03:33.795] Searching for globals ... DONE
[16:03:33.795] Resolving globals: FALSE
[16:03:33.795] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:03:33.796] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:03:33.796] - globals: [1] ‘FUN’
[16:03:33.796] 
[16:03:33.796] getGlobalsAndPackages() ... DONE
[16:03:33.796]  - globals found/used: [n=1] ‘FUN’
[16:03:33.796]  - needed namespaces: [n=0] 
[16:03:33.796] Finding globals ... DONE
[16:03:33.796]  - use_args: TRUE
[16:03:33.796]  - Getting '...' globals ...
[16:03:33.797] resolve() on list ...
[16:03:33.797]  recursive: 0
[16:03:33.797]  length: 1
[16:03:33.797]  elements: ‘...’
[16:03:33.797]  length: 0 (resolved future 1)
[16:03:33.797] resolve() on list ... DONE
[16:03:33.797]    - '...' content: [n=0] 
[16:03:33.797] List of 1
[16:03:33.797]  $ ...: list()
[16:03:33.797]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:33.797]  - attr(*, "where")=List of 1
[16:03:33.797]   ..$ ...:<environment: 0x55ed78d4f810> 
[16:03:33.797]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:33.797]  - attr(*, "resolved")= logi TRUE
[16:03:33.797]  - attr(*, "total_size")= num NA
[16:03:33.800]  - Getting '...' globals ... DONE
[16:03:33.800] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:03:33.800] List of 2
[16:03:33.800]  $ ...future.FUN:function (x)  
[16:03:33.800]  $ ...          : list()
[16:03:33.800]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:33.800]  - attr(*, "where")=List of 2
[16:03:33.800]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:33.800]   ..$ ...          :<environment: 0x55ed78d4f810> 
[16:03:33.800]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:33.800]  - attr(*, "resolved")= logi FALSE
[16:03:33.800]  - attr(*, "total_size")= num 4720
[16:03:33.803] Packages to be attached in all futures: [n=0] 
[16:03:33.803] getGlobalsAndPackagesXApply() ... DONE
[16:03:33.803] Number of futures (= number of chunks): 1
[16:03:33.803] Launching 1 futures (chunks) ...
[16:03:33.803] Chunk #1 of 1 ...
[16:03:33.803]  - Finding globals in 'X' for chunk #1 ...
[16:03:33.803] getGlobalsAndPackages() ...
[16:03:33.803] Searching for globals...
[16:03:33.804] 
[16:03:33.804] Searching for globals ... DONE
[16:03:33.804] - globals: [0] <none>
[16:03:33.804] getGlobalsAndPackages() ... DONE
[16:03:33.804]    + additional globals found: [n=0] 
[16:03:33.804]    + additional namespaces needed: [n=0] 
[16:03:33.804]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:33.804]  - seeds: <none>
[16:03:33.804]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:33.805] getGlobalsAndPackages() ...
[16:03:33.805] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:33.805] Resolving globals: FALSE
[16:03:33.805] Tweak future expression to call with '...' arguments ...
[16:03:33.805] {
[16:03:33.805]     do.call(function(...) {
[16:03:33.805]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:33.805]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:33.805]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:33.805]             on.exit(options(oopts), add = TRUE)
[16:03:33.805]         }
[16:03:33.805]         {
[16:03:33.805]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:33.805]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:33.805]                 ...future.FUN(...future.X_jj, ...)
[16:03:33.805]             })
[16:03:33.805]         }
[16:03:33.805]     }, args = future.call.arguments)
[16:03:33.805] }
[16:03:33.805] Tweak future expression to call with '...' arguments ... DONE
[16:03:33.806] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:33.806] 
[16:03:33.806] getGlobalsAndPackages() ... DONE
[16:03:33.806] run() for ‘Future’ ...
[16:03:33.806] - state: ‘created’
[16:03:33.806] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:33.810] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:33.810] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:33.810]   - Field: ‘label’
[16:03:33.810]   - Field: ‘local’
[16:03:33.810]   - Field: ‘owner’
[16:03:33.810]   - Field: ‘envir’
[16:03:33.810]   - Field: ‘packages’
[16:03:33.810]   - Field: ‘gc’
[16:03:33.810]   - Field: ‘conditions’
[16:03:33.811]   - Field: ‘expr’
[16:03:33.811]   - Field: ‘uuid’
[16:03:33.812]   - Field: ‘seed’
[16:03:33.812]   - Field: ‘version’
[16:03:33.812]   - Field: ‘result’
[16:03:33.812]   - Field: ‘asynchronous’
[16:03:33.813]   - Field: ‘calls’
[16:03:33.813]   - Field: ‘globals’
[16:03:33.813]   - Field: ‘stdout’
[16:03:33.813]   - Field: ‘earlySignal’
[16:03:33.813]   - Field: ‘lazy’
[16:03:33.813]   - Field: ‘state’
[16:03:33.813] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:33.813] - Launch lazy future ...
[16:03:33.813] Packages needed by the future expression (n = 0): <none>
[16:03:33.814] Packages needed by future strategies (n = 0): <none>
[16:03:33.814] {
[16:03:33.814]     {
[16:03:33.814]         {
[16:03:33.814]             ...future.startTime <- base::Sys.time()
[16:03:33.814]             {
[16:03:33.814]                 {
[16:03:33.814]                   {
[16:03:33.814]                     base::local({
[16:03:33.814]                       has_future <- base::requireNamespace("future", 
[16:03:33.814]                         quietly = TRUE)
[16:03:33.814]                       if (has_future) {
[16:03:33.814]                         ns <- base::getNamespace("future")
[16:03:33.814]                         version <- ns[[".package"]][["version"]]
[16:03:33.814]                         if (is.null(version)) 
[16:03:33.814]                           version <- utils::packageVersion("future")
[16:03:33.814]                       }
[16:03:33.814]                       else {
[16:03:33.814]                         version <- NULL
[16:03:33.814]                       }
[16:03:33.814]                       if (!has_future || version < "1.8.0") {
[16:03:33.814]                         info <- base::c(r_version = base::gsub("R version ", 
[16:03:33.814]                           "", base::R.version$version.string), 
[16:03:33.814]                           platform = base::sprintf("%s (%s-bit)", 
[16:03:33.814]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:33.814]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:33.814]                             "release", "version")], collapse = " "), 
[16:03:33.814]                           hostname = base::Sys.info()[["nodename"]])
[16:03:33.814]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:03:33.814]                           info)
[16:03:33.814]                         info <- base::paste(info, collapse = "; ")
[16:03:33.814]                         if (!has_future) {
[16:03:33.814]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:33.814]                             info)
[16:03:33.814]                         }
[16:03:33.814]                         else {
[16:03:33.814]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:33.814]                             info, version)
[16:03:33.814]                         }
[16:03:33.814]                         base::stop(msg)
[16:03:33.814]                       }
[16:03:33.814]                     })
[16:03:33.814]                   }
[16:03:33.814]                   options(future.plan = NULL)
[16:03:33.814]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:33.814]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:33.814]                 }
[16:03:33.814]                 ...future.workdir <- getwd()
[16:03:33.814]             }
[16:03:33.814]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:33.814]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:33.814]         }
[16:03:33.814]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:33.814]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:33.814]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:33.814]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:33.814]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:33.814]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:33.814]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:33.814]             base::names(...future.oldOptions))
[16:03:33.814]     }
[16:03:33.814]     if (FALSE) {
[16:03:33.814]     }
[16:03:33.814]     else {
[16:03:33.814]         if (FALSE) {
[16:03:33.814]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:33.814]                 open = "w")
[16:03:33.814]         }
[16:03:33.814]         else {
[16:03:33.814]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:33.814]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:33.814]         }
[16:03:33.814]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:33.814]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:33.814]             base::sink(type = "output", split = FALSE)
[16:03:33.814]             base::close(...future.stdout)
[16:03:33.814]         }, add = TRUE)
[16:03:33.814]     }
[16:03:33.814]     ...future.frame <- base::sys.nframe()
[16:03:33.814]     ...future.conditions <- base::list()
[16:03:33.814]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:33.814]     if (FALSE) {
[16:03:33.814]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:33.814]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:33.814]     }
[16:03:33.814]     ...future.result <- base::tryCatch({
[16:03:33.814]         base::withCallingHandlers({
[16:03:33.814]             ...future.value <- base::withVisible(base::local({
[16:03:33.814]                 do.call(function(...) {
[16:03:33.814]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:33.814]                   if (!identical(...future.globals.maxSize.org, 
[16:03:33.814]                     ...future.globals.maxSize)) {
[16:03:33.814]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:33.814]                     on.exit(options(oopts), add = TRUE)
[16:03:33.814]                   }
[16:03:33.814]                   {
[16:03:33.814]                     lapply(seq_along(...future.elements_ii), 
[16:03:33.814]                       FUN = function(jj) {
[16:03:33.814]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:33.814]                         ...future.FUN(...future.X_jj, ...)
[16:03:33.814]                       })
[16:03:33.814]                   }
[16:03:33.814]                 }, args = future.call.arguments)
[16:03:33.814]             }))
[16:03:33.814]             future::FutureResult(value = ...future.value$value, 
[16:03:33.814]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:33.814]                   ...future.rng), globalenv = if (FALSE) 
[16:03:33.814]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:33.814]                     ...future.globalenv.names))
[16:03:33.814]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:33.814]         }, condition = base::local({
[16:03:33.814]             c <- base::c
[16:03:33.814]             inherits <- base::inherits
[16:03:33.814]             invokeRestart <- base::invokeRestart
[16:03:33.814]             length <- base::length
[16:03:33.814]             list <- base::list
[16:03:33.814]             seq.int <- base::seq.int
[16:03:33.814]             signalCondition <- base::signalCondition
[16:03:33.814]             sys.calls <- base::sys.calls
[16:03:33.814]             `[[` <- base::`[[`
[16:03:33.814]             `+` <- base::`+`
[16:03:33.814]             `<<-` <- base::`<<-`
[16:03:33.814]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:33.814]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:33.814]                   3L)]
[16:03:33.814]             }
[16:03:33.814]             function(cond) {
[16:03:33.814]                 is_error <- inherits(cond, "error")
[16:03:33.814]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:33.814]                   NULL)
[16:03:33.814]                 if (is_error) {
[16:03:33.814]                   sessionInformation <- function() {
[16:03:33.814]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:33.814]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:33.814]                       search = base::search(), system = base::Sys.info())
[16:03:33.814]                   }
[16:03:33.814]                   ...future.conditions[[length(...future.conditions) + 
[16:03:33.814]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:33.814]                     cond$call), session = sessionInformation(), 
[16:03:33.814]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:33.814]                   signalCondition(cond)
[16:03:33.814]                 }
[16:03:33.814]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:33.814]                 "immediateCondition"))) {
[16:03:33.814]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:33.814]                   ...future.conditions[[length(...future.conditions) + 
[16:03:33.814]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:33.814]                   if (TRUE && !signal) {
[16:03:33.814]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:33.814]                     {
[16:03:33.814]                       inherits <- base::inherits
[16:03:33.814]                       invokeRestart <- base::invokeRestart
[16:03:33.814]                       is.null <- base::is.null
[16:03:33.814]                       muffled <- FALSE
[16:03:33.814]                       if (inherits(cond, "message")) {
[16:03:33.814]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:33.814]                         if (muffled) 
[16:03:33.814]                           invokeRestart("muffleMessage")
[16:03:33.814]                       }
[16:03:33.814]                       else if (inherits(cond, "warning")) {
[16:03:33.814]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:33.814]                         if (muffled) 
[16:03:33.814]                           invokeRestart("muffleWarning")
[16:03:33.814]                       }
[16:03:33.814]                       else if (inherits(cond, "condition")) {
[16:03:33.814]                         if (!is.null(pattern)) {
[16:03:33.814]                           computeRestarts <- base::computeRestarts
[16:03:33.814]                           grepl <- base::grepl
[16:03:33.814]                           restarts <- computeRestarts(cond)
[16:03:33.814]                           for (restart in restarts) {
[16:03:33.814]                             name <- restart$name
[16:03:33.814]                             if (is.null(name)) 
[16:03:33.814]                               next
[16:03:33.814]                             if (!grepl(pattern, name)) 
[16:03:33.814]                               next
[16:03:33.814]                             invokeRestart(restart)
[16:03:33.814]                             muffled <- TRUE
[16:03:33.814]                             break
[16:03:33.814]                           }
[16:03:33.814]                         }
[16:03:33.814]                       }
[16:03:33.814]                       invisible(muffled)
[16:03:33.814]                     }
[16:03:33.814]                     muffleCondition(cond, pattern = "^muffle")
[16:03:33.814]                   }
[16:03:33.814]                 }
[16:03:33.814]                 else {
[16:03:33.814]                   if (TRUE) {
[16:03:33.814]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:33.814]                     {
[16:03:33.814]                       inherits <- base::inherits
[16:03:33.814]                       invokeRestart <- base::invokeRestart
[16:03:33.814]                       is.null <- base::is.null
[16:03:33.814]                       muffled <- FALSE
[16:03:33.814]                       if (inherits(cond, "message")) {
[16:03:33.814]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:33.814]                         if (muffled) 
[16:03:33.814]                           invokeRestart("muffleMessage")
[16:03:33.814]                       }
[16:03:33.814]                       else if (inherits(cond, "warning")) {
[16:03:33.814]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:33.814]                         if (muffled) 
[16:03:33.814]                           invokeRestart("muffleWarning")
[16:03:33.814]                       }
[16:03:33.814]                       else if (inherits(cond, "condition")) {
[16:03:33.814]                         if (!is.null(pattern)) {
[16:03:33.814]                           computeRestarts <- base::computeRestarts
[16:03:33.814]                           grepl <- base::grepl
[16:03:33.814]                           restarts <- computeRestarts(cond)
[16:03:33.814]                           for (restart in restarts) {
[16:03:33.814]                             name <- restart$name
[16:03:33.814]                             if (is.null(name)) 
[16:03:33.814]                               next
[16:03:33.814]                             if (!grepl(pattern, name)) 
[16:03:33.814]                               next
[16:03:33.814]                             invokeRestart(restart)
[16:03:33.814]                             muffled <- TRUE
[16:03:33.814]                             break
[16:03:33.814]                           }
[16:03:33.814]                         }
[16:03:33.814]                       }
[16:03:33.814]                       invisible(muffled)
[16:03:33.814]                     }
[16:03:33.814]                     muffleCondition(cond, pattern = "^muffle")
[16:03:33.814]                   }
[16:03:33.814]                 }
[16:03:33.814]             }
[16:03:33.814]         }))
[16:03:33.814]     }, error = function(ex) {
[16:03:33.814]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:33.814]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:33.814]                 ...future.rng), started = ...future.startTime, 
[16:03:33.814]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:33.814]             version = "1.8"), class = "FutureResult")
[16:03:33.814]     }, finally = {
[16:03:33.814]         if (!identical(...future.workdir, getwd())) 
[16:03:33.814]             setwd(...future.workdir)
[16:03:33.814]         {
[16:03:33.814]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:33.814]                 ...future.oldOptions$nwarnings <- NULL
[16:03:33.814]             }
[16:03:33.814]             base::options(...future.oldOptions)
[16:03:33.814]             if (.Platform$OS.type == "windows") {
[16:03:33.814]                 old_names <- names(...future.oldEnvVars)
[16:03:33.814]                 envs <- base::Sys.getenv()
[16:03:33.814]                 names <- names(envs)
[16:03:33.814]                 common <- intersect(names, old_names)
[16:03:33.814]                 added <- setdiff(names, old_names)
[16:03:33.814]                 removed <- setdiff(old_names, names)
[16:03:33.814]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:33.814]                   envs[common]]
[16:03:33.814]                 NAMES <- toupper(changed)
[16:03:33.814]                 args <- list()
[16:03:33.814]                 for (kk in seq_along(NAMES)) {
[16:03:33.814]                   name <- changed[[kk]]
[16:03:33.814]                   NAME <- NAMES[[kk]]
[16:03:33.814]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:33.814]                     next
[16:03:33.814]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:33.814]                 }
[16:03:33.814]                 NAMES <- toupper(added)
[16:03:33.814]                 for (kk in seq_along(NAMES)) {
[16:03:33.814]                   name <- added[[kk]]
[16:03:33.814]                   NAME <- NAMES[[kk]]
[16:03:33.814]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:33.814]                     next
[16:03:33.814]                   args[[name]] <- ""
[16:03:33.814]                 }
[16:03:33.814]                 NAMES <- toupper(removed)
[16:03:33.814]                 for (kk in seq_along(NAMES)) {
[16:03:33.814]                   name <- removed[[kk]]
[16:03:33.814]                   NAME <- NAMES[[kk]]
[16:03:33.814]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:33.814]                     next
[16:03:33.814]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:33.814]                 }
[16:03:33.814]                 if (length(args) > 0) 
[16:03:33.814]                   base::do.call(base::Sys.setenv, args = args)
[16:03:33.814]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:33.814]             }
[16:03:33.814]             else {
[16:03:33.814]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:33.814]             }
[16:03:33.814]             {
[16:03:33.814]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:33.814]                   0L) {
[16:03:33.814]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:33.814]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:33.814]                   base::options(opts)
[16:03:33.814]                 }
[16:03:33.814]                 {
[16:03:33.814]                   {
[16:03:33.814]                     NULL
[16:03:33.814]                     RNGkind("Mersenne-Twister")
[16:03:33.814]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:33.814]                       inherits = FALSE)
[16:03:33.814]                   }
[16:03:33.814]                   options(future.plan = NULL)
[16:03:33.814]                   if (is.na(NA_character_)) 
[16:03:33.814]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:33.814]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:33.814]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:33.814]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:33.814]                     envir = parent.frame()) 
[16:03:33.814]                   {
[16:03:33.814]                     if (is.function(workers)) 
[16:03:33.814]                       workers <- workers()
[16:03:33.814]                     workers <- structure(as.integer(workers), 
[16:03:33.814]                       class = class(workers))
[16:03:33.814]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:33.814]                       workers >= 1)
[16:03:33.814]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:33.814]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:33.814]                     }
[16:03:33.814]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:33.814]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:33.814]                       envir = envir)
[16:03:33.814]                     if (!future$lazy) 
[16:03:33.814]                       future <- run(future)
[16:03:33.814]                     invisible(future)
[16:03:33.814]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:33.814]                 }
[16:03:33.814]             }
[16:03:33.814]         }
[16:03:33.814]     })
[16:03:33.814]     if (TRUE) {
[16:03:33.814]         base::sink(type = "output", split = FALSE)
[16:03:33.814]         if (FALSE) {
[16:03:33.814]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:33.814]         }
[16:03:33.814]         else {
[16:03:33.814]             ...future.result["stdout"] <- base::list(NULL)
[16:03:33.814]         }
[16:03:33.814]         base::close(...future.stdout)
[16:03:33.814]         ...future.stdout <- NULL
[16:03:33.814]     }
[16:03:33.814]     ...future.result$conditions <- ...future.conditions
[16:03:33.814]     ...future.result$finished <- base::Sys.time()
[16:03:33.814]     ...future.result
[16:03:33.814] }
[16:03:33.816] assign_globals() ...
[16:03:33.816] List of 5
[16:03:33.816]  $ ...future.FUN            :function (x)  
[16:03:33.816]  $ future.call.arguments    : list()
[16:03:33.816]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:33.816]  $ ...future.elements_ii    :List of 2
[16:03:33.816]   ..$ : int 1
[16:03:33.816]   ..$ : int 0
[16:03:33.816]  $ ...future.seeds_ii       : NULL
[16:03:33.816]  $ ...future.globals.maxSize: NULL
[16:03:33.816]  - attr(*, "where")=List of 5
[16:03:33.816]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:33.816]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:33.816]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:33.816]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:33.816]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:33.816]  - attr(*, "resolved")= logi FALSE
[16:03:33.816]  - attr(*, "total_size")= num 4720
[16:03:33.816]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:33.816]  - attr(*, "already-done")= logi TRUE
[16:03:33.821] - reassign environment for ‘...future.FUN’
[16:03:33.821] - copied ‘...future.FUN’ to environment
[16:03:33.821] - copied ‘future.call.arguments’ to environment
[16:03:33.821] - copied ‘...future.elements_ii’ to environment
[16:03:33.821] - copied ‘...future.seeds_ii’ to environment
[16:03:33.821] - copied ‘...future.globals.maxSize’ to environment
[16:03:33.821] assign_globals() ... done
[16:03:33.822] plan(): Setting new future strategy stack:
[16:03:33.822] List of future strategies:
[16:03:33.822] 1. sequential:
[16:03:33.822]    - args: function (..., envir = parent.frame())
[16:03:33.822]    - tweaked: FALSE
[16:03:33.822]    - call: NULL
[16:03:33.822] plan(): nbrOfWorkers() = 1
[16:03:34.324] plan(): Setting new future strategy stack:
[16:03:34.324] List of future strategies:
[16:03:34.324] 1. multisession:
[16:03:34.324]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:03:34.324]    - tweaked: FALSE
[16:03:34.324]    - call: plan(strategy)
[16:03:34.328] plan(): nbrOfWorkers() = 1
[16:03:34.328] SequentialFuture started (and completed)
[16:03:34.328] - Launch lazy future ... done
[16:03:34.328] run() for ‘SequentialFuture’ ... done
[16:03:34.328] Created future:
[16:03:34.328] SequentialFuture:
[16:03:34.328] Label: ‘future_lapply-1’
[16:03:34.328] Expression:
[16:03:34.328] {
[16:03:34.328]     do.call(function(...) {
[16:03:34.328]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:34.328]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:34.328]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:34.328]             on.exit(options(oopts), add = TRUE)
[16:03:34.328]         }
[16:03:34.328]         {
[16:03:34.328]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:34.328]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:34.328]                 ...future.FUN(...future.X_jj, ...)
[16:03:34.328]             })
[16:03:34.328]         }
[16:03:34.328]     }, args = future.call.arguments)
[16:03:34.328] }
[16:03:34.328] Lazy evaluation: FALSE
[16:03:34.328] Asynchronous evaluation: FALSE
[16:03:34.328] Local evaluation: TRUE
[16:03:34.328] Environment: R_GlobalEnv
[16:03:34.328] Capture standard output: FALSE
[16:03:34.328] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:34.328] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:34.328] Packages: <none>
[16:03:34.328] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:34.328] Resolved: TRUE
[16:03:34.328] Value: 112 bytes of class ‘list’
[16:03:34.328] Early signaling: FALSE
[16:03:34.328] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:34.328] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:34.329] Chunk #1 of 1 ... DONE
[16:03:34.329] Launching 1 futures (chunks) ... DONE
[16:03:34.330] Resolving 1 futures (chunks) ...
[16:03:34.330] resolve() on list ...
[16:03:34.330]  recursive: 0
[16:03:34.330]  length: 1
[16:03:34.330] 
[16:03:34.330] resolved() for ‘SequentialFuture’ ...
[16:03:34.330] - state: ‘finished’
[16:03:34.330] - run: TRUE
[16:03:34.330] - result: ‘FutureResult’
[16:03:34.330] resolved() for ‘SequentialFuture’ ... done
[16:03:34.331] Future #1
[16:03:34.331] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:34.331] - nx: 1
[16:03:34.331] - relay: TRUE
[16:03:34.331] - stdout: TRUE
[16:03:34.331] - signal: TRUE
[16:03:34.331] - resignal: FALSE
[16:03:34.331] - force: TRUE
[16:03:34.331] - relayed: [n=1] FALSE
[16:03:34.331] - queued futures: [n=1] FALSE
[16:03:34.331]  - until=1
[16:03:34.332]  - relaying element #1
[16:03:34.332] - relayed: [n=1] TRUE
[16:03:34.332] - queued futures: [n=1] TRUE
[16:03:34.332] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:34.332]  length: 0 (resolved future 1)
[16:03:34.332] Relaying remaining futures
[16:03:34.332] signalConditionsASAP(NULL, pos=0) ...
[16:03:34.332] - nx: 1
[16:03:34.332] - relay: TRUE
[16:03:34.332] - stdout: TRUE
[16:03:34.333] - signal: TRUE
[16:03:34.333] - resignal: FALSE
[16:03:34.333] - force: TRUE
[16:03:34.333] - relayed: [n=1] TRUE
[16:03:34.333] - queued futures: [n=1] TRUE
 - flush all
[16:03:34.333] - relayed: [n=1] TRUE
[16:03:34.333] - queued futures: [n=1] TRUE
[16:03:34.333] signalConditionsASAP(NULL, pos=0) ... done
[16:03:34.333] resolve() on list ... DONE
[16:03:34.333]  - Number of value chunks collected: 1
[16:03:34.334] Resolving 1 futures (chunks) ... DONE
[16:03:34.334] Reducing values from 1 chunks ...
[16:03:34.334]  - Number of values collected after concatenation: 2
[16:03:34.334]  - Number of values expected: 2
[16:03:34.334] Reducing values from 1 chunks ... DONE
[16:03:34.334] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[16:03:34.334] future_lapply() ...
[16:03:34.338] Number of chunks: 1
[16:03:34.338] getGlobalsAndPackagesXApply() ...
[16:03:34.338]  - future.globals: TRUE
[16:03:34.338] getGlobalsAndPackages() ...
[16:03:34.338] Searching for globals...
[16:03:34.340] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:03:34.340] Searching for globals ... DONE
[16:03:34.340] Resolving globals: FALSE
[16:03:34.340] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:03:34.341] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:03:34.341] - globals: [1] ‘FUN’
[16:03:34.341] 
[16:03:34.341] getGlobalsAndPackages() ... DONE
[16:03:34.341]  - globals found/used: [n=1] ‘FUN’
[16:03:34.341]  - needed namespaces: [n=0] 
[16:03:34.341] Finding globals ... DONE
[16:03:34.341]  - use_args: TRUE
[16:03:34.342]  - Getting '...' globals ...
[16:03:34.342] resolve() on list ...
[16:03:34.342]  recursive: 0
[16:03:34.342]  length: 1
[16:03:34.342]  elements: ‘...’
[16:03:34.342]  length: 0 (resolved future 1)
[16:03:34.342] resolve() on list ... DONE
[16:03:34.342]    - '...' content: [n=0] 
[16:03:34.343] List of 1
[16:03:34.343]  $ ...: list()
[16:03:34.343]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:34.343]  - attr(*, "where")=List of 1
[16:03:34.343]   ..$ ...:<environment: 0x55ed7a619668> 
[16:03:34.343]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:34.343]  - attr(*, "resolved")= logi TRUE
[16:03:34.343]  - attr(*, "total_size")= num NA
[16:03:34.347]  - Getting '...' globals ... DONE
[16:03:34.347] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:03:34.347] List of 2
[16:03:34.347]  $ ...future.FUN:function (x)  
[16:03:34.347]  $ ...          : list()
[16:03:34.347]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:34.347]  - attr(*, "where")=List of 2
[16:03:34.347]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:34.347]   ..$ ...          :<environment: 0x55ed7a619668> 
[16:03:34.347]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:34.347]  - attr(*, "resolved")= logi FALSE
[16:03:34.347]  - attr(*, "total_size")= num 4720
[16:03:34.350] Packages to be attached in all futures: [n=0] 
[16:03:34.350] getGlobalsAndPackagesXApply() ... DONE
[16:03:34.350] Number of futures (= number of chunks): 1
[16:03:34.350] Launching 1 futures (chunks) ...
[16:03:34.350] Chunk #1 of 1 ...
[16:03:34.350]  - Finding globals in 'X' for chunk #1 ...
[16:03:34.350] getGlobalsAndPackages() ...
[16:03:34.351] Searching for globals...
[16:03:34.351] 
[16:03:34.351] Searching for globals ... DONE
[16:03:34.351] - globals: [0] <none>
[16:03:34.351] getGlobalsAndPackages() ... DONE
[16:03:34.351]    + additional globals found: [n=0] 
[16:03:34.351]    + additional namespaces needed: [n=0] 
[16:03:34.351]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:34.351]  - seeds: <none>
[16:03:34.352]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:34.352] getGlobalsAndPackages() ...
[16:03:34.352] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:34.352] Resolving globals: FALSE
[16:03:34.352] Tweak future expression to call with '...' arguments ...
[16:03:34.352] {
[16:03:34.352]     do.call(function(...) {
[16:03:34.352]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:34.352]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:34.352]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:34.352]             on.exit(options(oopts), add = TRUE)
[16:03:34.352]         }
[16:03:34.352]         {
[16:03:34.352]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:34.352]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:34.352]                 ...future.FUN(...future.X_jj, ...)
[16:03:34.352]             })
[16:03:34.352]         }
[16:03:34.352]     }, args = future.call.arguments)
[16:03:34.352] }
[16:03:34.352] Tweak future expression to call with '...' arguments ... DONE
[16:03:34.353] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:34.353] 
[16:03:34.353] getGlobalsAndPackages() ... DONE
[16:03:34.353] run() for ‘Future’ ...
[16:03:34.353] - state: ‘created’
[16:03:34.353] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:34.357] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:34.357] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:34.357]   - Field: ‘label’
[16:03:34.357]   - Field: ‘local’
[16:03:34.357]   - Field: ‘owner’
[16:03:34.357]   - Field: ‘envir’
[16:03:34.358]   - Field: ‘packages’
[16:03:34.358]   - Field: ‘gc’
[16:03:34.358]   - Field: ‘conditions’
[16:03:34.358]   - Field: ‘expr’
[16:03:34.358]   - Field: ‘uuid’
[16:03:34.358]   - Field: ‘seed’
[16:03:34.358]   - Field: ‘version’
[16:03:34.358]   - Field: ‘result’
[16:03:34.359]   - Field: ‘asynchronous’
[16:03:34.359]   - Field: ‘calls’
[16:03:34.359]   - Field: ‘globals’
[16:03:34.359]   - Field: ‘stdout’
[16:03:34.359]   - Field: ‘earlySignal’
[16:03:34.359]   - Field: ‘lazy’
[16:03:34.359]   - Field: ‘state’
[16:03:34.359] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:34.359] - Launch lazy future ...
[16:03:34.360] Packages needed by the future expression (n = 0): <none>
[16:03:34.360] Packages needed by future strategies (n = 0): <none>
[16:03:34.360] {
[16:03:34.360]     {
[16:03:34.360]         {
[16:03:34.360]             ...future.startTime <- base::Sys.time()
[16:03:34.360]             {
[16:03:34.360]                 {
[16:03:34.360]                   {
[16:03:34.360]                     base::local({
[16:03:34.360]                       has_future <- base::requireNamespace("future", 
[16:03:34.360]                         quietly = TRUE)
[16:03:34.360]                       if (has_future) {
[16:03:34.360]                         ns <- base::getNamespace("future")
[16:03:34.360]                         version <- ns[[".package"]][["version"]]
[16:03:34.360]                         if (is.null(version)) 
[16:03:34.360]                           version <- utils::packageVersion("future")
[16:03:34.360]                       }
[16:03:34.360]                       else {
[16:03:34.360]                         version <- NULL
[16:03:34.360]                       }
[16:03:34.360]                       if (!has_future || version < "1.8.0") {
[16:03:34.360]                         info <- base::c(r_version = base::gsub("R version ", 
[16:03:34.360]                           "", base::R.version$version.string), 
[16:03:34.360]                           platform = base::sprintf("%s (%s-bit)", 
[16:03:34.360]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:34.360]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:34.360]                             "release", "version")], collapse = " "), 
[16:03:34.360]                           hostname = base::Sys.info()[["nodename"]])
[16:03:34.360]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:03:34.360]                           info)
[16:03:34.360]                         info <- base::paste(info, collapse = "; ")
[16:03:34.360]                         if (!has_future) {
[16:03:34.360]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:34.360]                             info)
[16:03:34.360]                         }
[16:03:34.360]                         else {
[16:03:34.360]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:34.360]                             info, version)
[16:03:34.360]                         }
[16:03:34.360]                         base::stop(msg)
[16:03:34.360]                       }
[16:03:34.360]                     })
[16:03:34.360]                   }
[16:03:34.360]                   options(future.plan = NULL)
[16:03:34.360]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:34.360]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:34.360]                 }
[16:03:34.360]                 ...future.workdir <- getwd()
[16:03:34.360]             }
[16:03:34.360]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:34.360]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:34.360]         }
[16:03:34.360]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:34.360]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:34.360]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:34.360]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:34.360]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:34.360]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:34.360]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:34.360]             base::names(...future.oldOptions))
[16:03:34.360]     }
[16:03:34.360]     if (FALSE) {
[16:03:34.360]     }
[16:03:34.360]     else {
[16:03:34.360]         if (TRUE) {
[16:03:34.360]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:34.360]                 open = "w")
[16:03:34.360]         }
[16:03:34.360]         else {
[16:03:34.360]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:34.360]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:34.360]         }
[16:03:34.360]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:34.360]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:34.360]             base::sink(type = "output", split = FALSE)
[16:03:34.360]             base::close(...future.stdout)
[16:03:34.360]         }, add = TRUE)
[16:03:34.360]     }
[16:03:34.360]     ...future.frame <- base::sys.nframe()
[16:03:34.360]     ...future.conditions <- base::list()
[16:03:34.360]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:34.360]     if (FALSE) {
[16:03:34.360]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:34.360]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:34.360]     }
[16:03:34.360]     ...future.result <- base::tryCatch({
[16:03:34.360]         base::withCallingHandlers({
[16:03:34.360]             ...future.value <- base::withVisible(base::local({
[16:03:34.360]                 do.call(function(...) {
[16:03:34.360]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:34.360]                   if (!identical(...future.globals.maxSize.org, 
[16:03:34.360]                     ...future.globals.maxSize)) {
[16:03:34.360]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:34.360]                     on.exit(options(oopts), add = TRUE)
[16:03:34.360]                   }
[16:03:34.360]                   {
[16:03:34.360]                     lapply(seq_along(...future.elements_ii), 
[16:03:34.360]                       FUN = function(jj) {
[16:03:34.360]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:34.360]                         ...future.FUN(...future.X_jj, ...)
[16:03:34.360]                       })
[16:03:34.360]                   }
[16:03:34.360]                 }, args = future.call.arguments)
[16:03:34.360]             }))
[16:03:34.360]             future::FutureResult(value = ...future.value$value, 
[16:03:34.360]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:34.360]                   ...future.rng), globalenv = if (FALSE) 
[16:03:34.360]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:34.360]                     ...future.globalenv.names))
[16:03:34.360]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:34.360]         }, condition = base::local({
[16:03:34.360]             c <- base::c
[16:03:34.360]             inherits <- base::inherits
[16:03:34.360]             invokeRestart <- base::invokeRestart
[16:03:34.360]             length <- base::length
[16:03:34.360]             list <- base::list
[16:03:34.360]             seq.int <- base::seq.int
[16:03:34.360]             signalCondition <- base::signalCondition
[16:03:34.360]             sys.calls <- base::sys.calls
[16:03:34.360]             `[[` <- base::`[[`
[16:03:34.360]             `+` <- base::`+`
[16:03:34.360]             `<<-` <- base::`<<-`
[16:03:34.360]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:34.360]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:34.360]                   3L)]
[16:03:34.360]             }
[16:03:34.360]             function(cond) {
[16:03:34.360]                 is_error <- inherits(cond, "error")
[16:03:34.360]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:34.360]                   NULL)
[16:03:34.360]                 if (is_error) {
[16:03:34.360]                   sessionInformation <- function() {
[16:03:34.360]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:34.360]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:34.360]                       search = base::search(), system = base::Sys.info())
[16:03:34.360]                   }
[16:03:34.360]                   ...future.conditions[[length(...future.conditions) + 
[16:03:34.360]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:34.360]                     cond$call), session = sessionInformation(), 
[16:03:34.360]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:34.360]                   signalCondition(cond)
[16:03:34.360]                 }
[16:03:34.360]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:34.360]                 "immediateCondition"))) {
[16:03:34.360]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:34.360]                   ...future.conditions[[length(...future.conditions) + 
[16:03:34.360]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:34.360]                   if (TRUE && !signal) {
[16:03:34.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:34.360]                     {
[16:03:34.360]                       inherits <- base::inherits
[16:03:34.360]                       invokeRestart <- base::invokeRestart
[16:03:34.360]                       is.null <- base::is.null
[16:03:34.360]                       muffled <- FALSE
[16:03:34.360]                       if (inherits(cond, "message")) {
[16:03:34.360]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:34.360]                         if (muffled) 
[16:03:34.360]                           invokeRestart("muffleMessage")
[16:03:34.360]                       }
[16:03:34.360]                       else if (inherits(cond, "warning")) {
[16:03:34.360]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:34.360]                         if (muffled) 
[16:03:34.360]                           invokeRestart("muffleWarning")
[16:03:34.360]                       }
[16:03:34.360]                       else if (inherits(cond, "condition")) {
[16:03:34.360]                         if (!is.null(pattern)) {
[16:03:34.360]                           computeRestarts <- base::computeRestarts
[16:03:34.360]                           grepl <- base::grepl
[16:03:34.360]                           restarts <- computeRestarts(cond)
[16:03:34.360]                           for (restart in restarts) {
[16:03:34.360]                             name <- restart$name
[16:03:34.360]                             if (is.null(name)) 
[16:03:34.360]                               next
[16:03:34.360]                             if (!grepl(pattern, name)) 
[16:03:34.360]                               next
[16:03:34.360]                             invokeRestart(restart)
[16:03:34.360]                             muffled <- TRUE
[16:03:34.360]                             break
[16:03:34.360]                           }
[16:03:34.360]                         }
[16:03:34.360]                       }
[16:03:34.360]                       invisible(muffled)
[16:03:34.360]                     }
[16:03:34.360]                     muffleCondition(cond, pattern = "^muffle")
[16:03:34.360]                   }
[16:03:34.360]                 }
[16:03:34.360]                 else {
[16:03:34.360]                   if (TRUE) {
[16:03:34.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:34.360]                     {
[16:03:34.360]                       inherits <- base::inherits
[16:03:34.360]                       invokeRestart <- base::invokeRestart
[16:03:34.360]                       is.null <- base::is.null
[16:03:34.360]                       muffled <- FALSE
[16:03:34.360]                       if (inherits(cond, "message")) {
[16:03:34.360]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:34.360]                         if (muffled) 
[16:03:34.360]                           invokeRestart("muffleMessage")
[16:03:34.360]                       }
[16:03:34.360]                       else if (inherits(cond, "warning")) {
[16:03:34.360]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:34.360]                         if (muffled) 
[16:03:34.360]                           invokeRestart("muffleWarning")
[16:03:34.360]                       }
[16:03:34.360]                       else if (inherits(cond, "condition")) {
[16:03:34.360]                         if (!is.null(pattern)) {
[16:03:34.360]                           computeRestarts <- base::computeRestarts
[16:03:34.360]                           grepl <- base::grepl
[16:03:34.360]                           restarts <- computeRestarts(cond)
[16:03:34.360]                           for (restart in restarts) {
[16:03:34.360]                             name <- restart$name
[16:03:34.360]                             if (is.null(name)) 
[16:03:34.360]                               next
[16:03:34.360]                             if (!grepl(pattern, name)) 
[16:03:34.360]                               next
[16:03:34.360]                             invokeRestart(restart)
[16:03:34.360]                             muffled <- TRUE
[16:03:34.360]                             break
[16:03:34.360]                           }
[16:03:34.360]                         }
[16:03:34.360]                       }
[16:03:34.360]                       invisible(muffled)
[16:03:34.360]                     }
[16:03:34.360]                     muffleCondition(cond, pattern = "^muffle")
[16:03:34.360]                   }
[16:03:34.360]                 }
[16:03:34.360]             }
[16:03:34.360]         }))
[16:03:34.360]     }, error = function(ex) {
[16:03:34.360]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:34.360]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:34.360]                 ...future.rng), started = ...future.startTime, 
[16:03:34.360]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:34.360]             version = "1.8"), class = "FutureResult")
[16:03:34.360]     }, finally = {
[16:03:34.360]         if (!identical(...future.workdir, getwd())) 
[16:03:34.360]             setwd(...future.workdir)
[16:03:34.360]         {
[16:03:34.360]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:34.360]                 ...future.oldOptions$nwarnings <- NULL
[16:03:34.360]             }
[16:03:34.360]             base::options(...future.oldOptions)
[16:03:34.360]             if (.Platform$OS.type == "windows") {
[16:03:34.360]                 old_names <- names(...future.oldEnvVars)
[16:03:34.360]                 envs <- base::Sys.getenv()
[16:03:34.360]                 names <- names(envs)
[16:03:34.360]                 common <- intersect(names, old_names)
[16:03:34.360]                 added <- setdiff(names, old_names)
[16:03:34.360]                 removed <- setdiff(old_names, names)
[16:03:34.360]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:34.360]                   envs[common]]
[16:03:34.360]                 NAMES <- toupper(changed)
[16:03:34.360]                 args <- list()
[16:03:34.360]                 for (kk in seq_along(NAMES)) {
[16:03:34.360]                   name <- changed[[kk]]
[16:03:34.360]                   NAME <- NAMES[[kk]]
[16:03:34.360]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:34.360]                     next
[16:03:34.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:34.360]                 }
[16:03:34.360]                 NAMES <- toupper(added)
[16:03:34.360]                 for (kk in seq_along(NAMES)) {
[16:03:34.360]                   name <- added[[kk]]
[16:03:34.360]                   NAME <- NAMES[[kk]]
[16:03:34.360]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:34.360]                     next
[16:03:34.360]                   args[[name]] <- ""
[16:03:34.360]                 }
[16:03:34.360]                 NAMES <- toupper(removed)
[16:03:34.360]                 for (kk in seq_along(NAMES)) {
[16:03:34.360]                   name <- removed[[kk]]
[16:03:34.360]                   NAME <- NAMES[[kk]]
[16:03:34.360]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:34.360]                     next
[16:03:34.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:34.360]                 }
[16:03:34.360]                 if (length(args) > 0) 
[16:03:34.360]                   base::do.call(base::Sys.setenv, args = args)
[16:03:34.360]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:34.360]             }
[16:03:34.360]             else {
[16:03:34.360]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:34.360]             }
[16:03:34.360]             {
[16:03:34.360]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:34.360]                   0L) {
[16:03:34.360]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:34.360]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:34.360]                   base::options(opts)
[16:03:34.360]                 }
[16:03:34.360]                 {
[16:03:34.360]                   {
[16:03:34.360]                     NULL
[16:03:34.360]                     RNGkind("Mersenne-Twister")
[16:03:34.360]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:34.360]                       inherits = FALSE)
[16:03:34.360]                   }
[16:03:34.360]                   options(future.plan = NULL)
[16:03:34.360]                   if (is.na(NA_character_)) 
[16:03:34.360]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:34.360]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:34.360]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:34.360]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:34.360]                     envir = parent.frame()) 
[16:03:34.360]                   {
[16:03:34.360]                     if (is.function(workers)) 
[16:03:34.360]                       workers <- workers()
[16:03:34.360]                     workers <- structure(as.integer(workers), 
[16:03:34.360]                       class = class(workers))
[16:03:34.360]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:34.360]                       workers >= 1)
[16:03:34.360]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:34.360]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:34.360]                     }
[16:03:34.360]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:34.360]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:34.360]                       envir = envir)
[16:03:34.360]                     if (!future$lazy) 
[16:03:34.360]                       future <- run(future)
[16:03:34.360]                     invisible(future)
[16:03:34.360]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:34.360]                 }
[16:03:34.360]             }
[16:03:34.360]         }
[16:03:34.360]     })
[16:03:34.360]     if (TRUE) {
[16:03:34.360]         base::sink(type = "output", split = FALSE)
[16:03:34.360]         if (TRUE) {
[16:03:34.360]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:34.360]         }
[16:03:34.360]         else {
[16:03:34.360]             ...future.result["stdout"] <- base::list(NULL)
[16:03:34.360]         }
[16:03:34.360]         base::close(...future.stdout)
[16:03:34.360]         ...future.stdout <- NULL
[16:03:34.360]     }
[16:03:34.360]     ...future.result$conditions <- ...future.conditions
[16:03:34.360]     ...future.result$finished <- base::Sys.time()
[16:03:34.360]     ...future.result
[16:03:34.360] }
[16:03:34.362] assign_globals() ...
[16:03:34.362] List of 5
[16:03:34.362]  $ ...future.FUN            :function (x)  
[16:03:34.362]  $ future.call.arguments    : list()
[16:03:34.362]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:34.362]  $ ...future.elements_ii    :List of 2
[16:03:34.362]   ..$ : int 1
[16:03:34.362]   ..$ : int 0
[16:03:34.362]  $ ...future.seeds_ii       : NULL
[16:03:34.362]  $ ...future.globals.maxSize: NULL
[16:03:34.362]  - attr(*, "where")=List of 5
[16:03:34.362]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:34.362]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:34.362]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:34.362]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:34.362]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:34.362]  - attr(*, "resolved")= logi FALSE
[16:03:34.362]  - attr(*, "total_size")= num 4720
[16:03:34.362]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:34.362]  - attr(*, "already-done")= logi TRUE
[16:03:34.367] - reassign environment for ‘...future.FUN’
[16:03:34.367] - copied ‘...future.FUN’ to environment
[16:03:34.367] - copied ‘future.call.arguments’ to environment
[16:03:34.367] - copied ‘...future.elements_ii’ to environment
[16:03:34.367] - copied ‘...future.seeds_ii’ to environment
[16:03:34.367] - copied ‘...future.globals.maxSize’ to environment
[16:03:34.367] assign_globals() ... done
[16:03:34.368] plan(): Setting new future strategy stack:
[16:03:34.368] List of future strategies:
[16:03:34.368] 1. sequential:
[16:03:34.368]    - args: function (..., envir = parent.frame())
[16:03:34.368]    - tweaked: FALSE
[16:03:34.368]    - call: NULL
[16:03:34.368] plan(): nbrOfWorkers() = 1
[16:03:34.870] plan(): Setting new future strategy stack:
[16:03:34.870] List of future strategies:
[16:03:34.870] 1. multisession:
[16:03:34.870]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:03:34.870]    - tweaked: FALSE
[16:03:34.870]    - call: plan(strategy)
[16:03:34.874] plan(): nbrOfWorkers() = 1
[16:03:34.874] SequentialFuture started (and completed)
[16:03:34.874] - Launch lazy future ... done
[16:03:34.874] run() for ‘SequentialFuture’ ... done
[16:03:34.874] Created future:
[16:03:34.874] SequentialFuture:
[16:03:34.874] Label: ‘future_lapply-1’
[16:03:34.874] Expression:
[16:03:34.874] {
[16:03:34.874]     do.call(function(...) {
[16:03:34.874]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:34.874]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:34.874]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:34.874]             on.exit(options(oopts), add = TRUE)
[16:03:34.874]         }
[16:03:34.874]         {
[16:03:34.874]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:34.874]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:34.874]                 ...future.FUN(...future.X_jj, ...)
[16:03:34.874]             })
[16:03:34.874]         }
[16:03:34.874]     }, args = future.call.arguments)
[16:03:34.874] }
[16:03:34.874] Lazy evaluation: FALSE
[16:03:34.874] Asynchronous evaluation: FALSE
[16:03:34.874] Local evaluation: TRUE
[16:03:34.874] Environment: R_GlobalEnv
[16:03:34.874] Capture standard output: TRUE
[16:03:34.874] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:34.874] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:34.874] Packages: <none>
[16:03:34.874] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:34.874] Resolved: TRUE
[16:03:34.874] Value: 112 bytes of class ‘list’
[16:03:34.874] Early signaling: FALSE
[16:03:34.874] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:34.874] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:34.876] Chunk #1 of 1 ... DONE
[16:03:34.876] Launching 1 futures (chunks) ... DONE
[16:03:34.876] Resolving 1 futures (chunks) ...
[16:03:34.876] resolve() on list ...
[16:03:34.876]  recursive: 0
[16:03:34.876]  length: 1
[16:03:34.876] 
[16:03:34.876] resolved() for ‘SequentialFuture’ ...
[16:03:34.876] - state: ‘finished’
[16:03:34.876] - run: TRUE
[16:03:34.877] - result: ‘FutureResult’
[16:03:34.877] resolved() for ‘SequentialFuture’ ... done
[16:03:34.877] Future #1
[16:03:34.878] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:34.878] - nx: 1
[16:03:34.879] - relay: TRUE
[16:03:34.879] - stdout: TRUE
[16:03:34.879] - signal: TRUE
[16:03:34.879] - resignal: FALSE
[16:03:34.879] - force: TRUE
[16:03:34.879] - relayed: [n=1] FALSE
[16:03:34.879] - queued futures: [n=1] FALSE
[16:03:34.879]  - until=1
[16:03:34.879]  - relaying element #1
[16:03:34.880] - relayed: [n=1] TRUE
[16:03:34.880] - queued futures: [n=1] TRUE
[16:03:34.880] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:34.880]  length: 0 (resolved future 1)
[16:03:34.880] Relaying remaining futures
[16:03:34.880] signalConditionsASAP(NULL, pos=0) ...
[16:03:34.880] - nx: 1
[16:03:34.880] - relay: TRUE
[16:03:34.881] - stdout: TRUE
[16:03:34.881] - signal: TRUE
[16:03:34.881] - resignal: FALSE
[16:03:34.881] - force: TRUE
[16:03:34.881] - relayed: [n=1] TRUE
[16:03:34.881] - queued futures: [n=1] TRUE
 - flush all
[16:03:34.881] - relayed: [n=1] TRUE
[16:03:34.881] - queued futures: [n=1] TRUE
[16:03:34.881] signalConditionsASAP(NULL, pos=0) ... done
[16:03:34.881] resolve() on list ... DONE
[16:03:34.882]  - Number of value chunks collected: 1
[16:03:34.882] Resolving 1 futures (chunks) ... DONE
[16:03:34.882] Reducing values from 1 chunks ...
[16:03:34.882]  - Number of values collected after concatenation: 2
[16:03:34.882]  - Number of values expected: 2
[16:03:34.882] Reducing values from 1 chunks ... DONE
[16:03:34.882] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[16:03:34.882] future_lapply() ...
[16:03:34.886] Number of chunks: 1
[16:03:34.886] getGlobalsAndPackagesXApply() ...
[16:03:34.886]  - future.globals: TRUE
[16:03:34.886] getGlobalsAndPackages() ...
[16:03:34.887] Searching for globals...
[16:03:34.888] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:03:34.888] Searching for globals ... DONE
[16:03:34.888] Resolving globals: FALSE
[16:03:34.889] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:03:34.889] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:03:34.889] - globals: [1] ‘FUN’
[16:03:34.889] 
[16:03:34.889] getGlobalsAndPackages() ... DONE
[16:03:34.889]  - globals found/used: [n=1] ‘FUN’
[16:03:34.889]  - needed namespaces: [n=0] 
[16:03:34.889] Finding globals ... DONE
[16:03:34.890]  - use_args: TRUE
[16:03:34.890]  - Getting '...' globals ...
[16:03:34.890] resolve() on list ...
[16:03:34.890]  recursive: 0
[16:03:34.890]  length: 1
[16:03:34.890]  elements: ‘...’
[16:03:34.890]  length: 0 (resolved future 1)
[16:03:34.890] resolve() on list ... DONE
[16:03:34.890]    - '...' content: [n=0] 
[16:03:34.891] List of 1
[16:03:34.891]  $ ...: list()
[16:03:34.891]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:34.891]  - attr(*, "where")=List of 1
[16:03:34.891]   ..$ ...:<environment: 0x55ed792ec540> 
[16:03:34.891]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:34.891]  - attr(*, "resolved")= logi TRUE
[16:03:34.891]  - attr(*, "total_size")= num NA
[16:03:34.893]  - Getting '...' globals ... DONE
[16:03:34.893] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:03:34.893] List of 2
[16:03:34.893]  $ ...future.FUN:function (x)  
[16:03:34.893]  $ ...          : list()
[16:03:34.893]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:34.893]  - attr(*, "where")=List of 2
[16:03:34.893]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:34.893]   ..$ ...          :<environment: 0x55ed792ec540> 
[16:03:34.893]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:34.893]  - attr(*, "resolved")= logi FALSE
[16:03:34.893]  - attr(*, "total_size")= num 4720
[16:03:34.896] Packages to be attached in all futures: [n=0] 
[16:03:34.896] getGlobalsAndPackagesXApply() ... DONE
[16:03:34.896] Number of futures (= number of chunks): 1
[16:03:34.896] Launching 1 futures (chunks) ...
[16:03:34.897] Chunk #1 of 1 ...
[16:03:34.897]  - Finding globals in 'X' for chunk #1 ...
[16:03:34.897] getGlobalsAndPackages() ...
[16:03:34.897] Searching for globals...
[16:03:34.897] 
[16:03:34.897] Searching for globals ... DONE
[16:03:34.897] - globals: [0] <none>
[16:03:34.897] getGlobalsAndPackages() ... DONE
[16:03:34.897]    + additional globals found: [n=0] 
[16:03:34.898]    + additional namespaces needed: [n=0] 
[16:03:34.898]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:34.898]  - seeds: <none>
[16:03:34.898]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:34.898] getGlobalsAndPackages() ...
[16:03:34.898] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:34.898] Resolving globals: FALSE
[16:03:34.898] Tweak future expression to call with '...' arguments ...
[16:03:34.898] {
[16:03:34.898]     do.call(function(...) {
[16:03:34.898]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:34.898]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:34.898]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:34.898]             on.exit(options(oopts), add = TRUE)
[16:03:34.898]         }
[16:03:34.898]         {
[16:03:34.898]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:34.898]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:34.898]                 ...future.FUN(...future.X_jj, ...)
[16:03:34.898]             })
[16:03:34.898]         }
[16:03:34.898]     }, args = future.call.arguments)
[16:03:34.898] }
[16:03:34.899] Tweak future expression to call with '...' arguments ... DONE
[16:03:34.899] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:34.899] 
[16:03:34.899] getGlobalsAndPackages() ... DONE
[16:03:34.899] run() for ‘Future’ ...
[16:03:34.900] - state: ‘created’
[16:03:34.900] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:34.903] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:34.903] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:34.903]   - Field: ‘label’
[16:03:34.903]   - Field: ‘local’
[16:03:34.903]   - Field: ‘owner’
[16:03:34.904]   - Field: ‘envir’
[16:03:34.904]   - Field: ‘packages’
[16:03:34.904]   - Field: ‘gc’
[16:03:34.904]   - Field: ‘conditions’
[16:03:34.904]   - Field: ‘expr’
[16:03:34.904]   - Field: ‘uuid’
[16:03:34.904]   - Field: ‘seed’
[16:03:34.904]   - Field: ‘version’
[16:03:34.904]   - Field: ‘result’
[16:03:34.904]   - Field: ‘asynchronous’
[16:03:34.904]   - Field: ‘calls’
[16:03:34.905]   - Field: ‘globals’
[16:03:34.905]   - Field: ‘stdout’
[16:03:34.905]   - Field: ‘earlySignal’
[16:03:34.905]   - Field: ‘lazy’
[16:03:34.905]   - Field: ‘state’
[16:03:34.905] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:34.905] - Launch lazy future ...
[16:03:34.905] Packages needed by the future expression (n = 0): <none>
[16:03:34.905] Packages needed by future strategies (n = 0): <none>
[16:03:34.906] {
[16:03:34.906]     {
[16:03:34.906]         {
[16:03:34.906]             ...future.startTime <- base::Sys.time()
[16:03:34.906]             {
[16:03:34.906]                 {
[16:03:34.906]                   {
[16:03:34.906]                     base::local({
[16:03:34.906]                       has_future <- base::requireNamespace("future", 
[16:03:34.906]                         quietly = TRUE)
[16:03:34.906]                       if (has_future) {
[16:03:34.906]                         ns <- base::getNamespace("future")
[16:03:34.906]                         version <- ns[[".package"]][["version"]]
[16:03:34.906]                         if (is.null(version)) 
[16:03:34.906]                           version <- utils::packageVersion("future")
[16:03:34.906]                       }
[16:03:34.906]                       else {
[16:03:34.906]                         version <- NULL
[16:03:34.906]                       }
[16:03:34.906]                       if (!has_future || version < "1.8.0") {
[16:03:34.906]                         info <- base::c(r_version = base::gsub("R version ", 
[16:03:34.906]                           "", base::R.version$version.string), 
[16:03:34.906]                           platform = base::sprintf("%s (%s-bit)", 
[16:03:34.906]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:34.906]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:34.906]                             "release", "version")], collapse = " "), 
[16:03:34.906]                           hostname = base::Sys.info()[["nodename"]])
[16:03:34.906]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:03:34.906]                           info)
[16:03:34.906]                         info <- base::paste(info, collapse = "; ")
[16:03:34.906]                         if (!has_future) {
[16:03:34.906]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:34.906]                             info)
[16:03:34.906]                         }
[16:03:34.906]                         else {
[16:03:34.906]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:34.906]                             info, version)
[16:03:34.906]                         }
[16:03:34.906]                         base::stop(msg)
[16:03:34.906]                       }
[16:03:34.906]                     })
[16:03:34.906]                   }
[16:03:34.906]                   options(future.plan = NULL)
[16:03:34.906]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:34.906]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:34.906]                 }
[16:03:34.906]                 ...future.workdir <- getwd()
[16:03:34.906]             }
[16:03:34.906]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:34.906]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:34.906]         }
[16:03:34.906]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:34.906]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:34.906]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:34.906]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:34.906]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:34.906]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:34.906]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:34.906]             base::names(...future.oldOptions))
[16:03:34.906]     }
[16:03:34.906]     if (TRUE) {
[16:03:34.906]     }
[16:03:34.906]     else {
[16:03:34.906]         if (NA) {
[16:03:34.906]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:34.906]                 open = "w")
[16:03:34.906]         }
[16:03:34.906]         else {
[16:03:34.906]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:34.906]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:34.906]         }
[16:03:34.906]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:34.906]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:34.906]             base::sink(type = "output", split = FALSE)
[16:03:34.906]             base::close(...future.stdout)
[16:03:34.906]         }, add = TRUE)
[16:03:34.906]     }
[16:03:34.906]     ...future.frame <- base::sys.nframe()
[16:03:34.906]     ...future.conditions <- base::list()
[16:03:34.906]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:34.906]     if (FALSE) {
[16:03:34.906]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:34.906]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:34.906]     }
[16:03:34.906]     ...future.result <- base::tryCatch({
[16:03:34.906]         base::withCallingHandlers({
[16:03:34.906]             ...future.value <- base::withVisible(base::local({
[16:03:34.906]                 do.call(function(...) {
[16:03:34.906]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:34.906]                   if (!identical(...future.globals.maxSize.org, 
[16:03:34.906]                     ...future.globals.maxSize)) {
[16:03:34.906]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:34.906]                     on.exit(options(oopts), add = TRUE)
[16:03:34.906]                   }
[16:03:34.906]                   {
[16:03:34.906]                     lapply(seq_along(...future.elements_ii), 
[16:03:34.906]                       FUN = function(jj) {
[16:03:34.906]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:34.906]                         ...future.FUN(...future.X_jj, ...)
[16:03:34.906]                       })
[16:03:34.906]                   }
[16:03:34.906]                 }, args = future.call.arguments)
[16:03:34.906]             }))
[16:03:34.906]             future::FutureResult(value = ...future.value$value, 
[16:03:34.906]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:34.906]                   ...future.rng), globalenv = if (FALSE) 
[16:03:34.906]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:34.906]                     ...future.globalenv.names))
[16:03:34.906]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:34.906]         }, condition = base::local({
[16:03:34.906]             c <- base::c
[16:03:34.906]             inherits <- base::inherits
[16:03:34.906]             invokeRestart <- base::invokeRestart
[16:03:34.906]             length <- base::length
[16:03:34.906]             list <- base::list
[16:03:34.906]             seq.int <- base::seq.int
[16:03:34.906]             signalCondition <- base::signalCondition
[16:03:34.906]             sys.calls <- base::sys.calls
[16:03:34.906]             `[[` <- base::`[[`
[16:03:34.906]             `+` <- base::`+`
[16:03:34.906]             `<<-` <- base::`<<-`
[16:03:34.906]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:34.906]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:34.906]                   3L)]
[16:03:34.906]             }
[16:03:34.906]             function(cond) {
[16:03:34.906]                 is_error <- inherits(cond, "error")
[16:03:34.906]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:34.906]                   NULL)
[16:03:34.906]                 if (is_error) {
[16:03:34.906]                   sessionInformation <- function() {
[16:03:34.906]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:34.906]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:34.906]                       search = base::search(), system = base::Sys.info())
[16:03:34.906]                   }
[16:03:34.906]                   ...future.conditions[[length(...future.conditions) + 
[16:03:34.906]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:34.906]                     cond$call), session = sessionInformation(), 
[16:03:34.906]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:34.906]                   signalCondition(cond)
[16:03:34.906]                 }
[16:03:34.906]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:34.906]                 "immediateCondition"))) {
[16:03:34.906]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:34.906]                   ...future.conditions[[length(...future.conditions) + 
[16:03:34.906]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:34.906]                   if (TRUE && !signal) {
[16:03:34.906]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:34.906]                     {
[16:03:34.906]                       inherits <- base::inherits
[16:03:34.906]                       invokeRestart <- base::invokeRestart
[16:03:34.906]                       is.null <- base::is.null
[16:03:34.906]                       muffled <- FALSE
[16:03:34.906]                       if (inherits(cond, "message")) {
[16:03:34.906]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:34.906]                         if (muffled) 
[16:03:34.906]                           invokeRestart("muffleMessage")
[16:03:34.906]                       }
[16:03:34.906]                       else if (inherits(cond, "warning")) {
[16:03:34.906]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:34.906]                         if (muffled) 
[16:03:34.906]                           invokeRestart("muffleWarning")
[16:03:34.906]                       }
[16:03:34.906]                       else if (inherits(cond, "condition")) {
[16:03:34.906]                         if (!is.null(pattern)) {
[16:03:34.906]                           computeRestarts <- base::computeRestarts
[16:03:34.906]                           grepl <- base::grepl
[16:03:34.906]                           restarts <- computeRestarts(cond)
[16:03:34.906]                           for (restart in restarts) {
[16:03:34.906]                             name <- restart$name
[16:03:34.906]                             if (is.null(name)) 
[16:03:34.906]                               next
[16:03:34.906]                             if (!grepl(pattern, name)) 
[16:03:34.906]                               next
[16:03:34.906]                             invokeRestart(restart)
[16:03:34.906]                             muffled <- TRUE
[16:03:34.906]                             break
[16:03:34.906]                           }
[16:03:34.906]                         }
[16:03:34.906]                       }
[16:03:34.906]                       invisible(muffled)
[16:03:34.906]                     }
[16:03:34.906]                     muffleCondition(cond, pattern = "^muffle")
[16:03:34.906]                   }
[16:03:34.906]                 }
[16:03:34.906]                 else {
[16:03:34.906]                   if (TRUE) {
[16:03:34.906]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:34.906]                     {
[16:03:34.906]                       inherits <- base::inherits
[16:03:34.906]                       invokeRestart <- base::invokeRestart
[16:03:34.906]                       is.null <- base::is.null
[16:03:34.906]                       muffled <- FALSE
[16:03:34.906]                       if (inherits(cond, "message")) {
[16:03:34.906]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:34.906]                         if (muffled) 
[16:03:34.906]                           invokeRestart("muffleMessage")
[16:03:34.906]                       }
[16:03:34.906]                       else if (inherits(cond, "warning")) {
[16:03:34.906]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:34.906]                         if (muffled) 
[16:03:34.906]                           invokeRestart("muffleWarning")
[16:03:34.906]                       }
[16:03:34.906]                       else if (inherits(cond, "condition")) {
[16:03:34.906]                         if (!is.null(pattern)) {
[16:03:34.906]                           computeRestarts <- base::computeRestarts
[16:03:34.906]                           grepl <- base::grepl
[16:03:34.906]                           restarts <- computeRestarts(cond)
[16:03:34.906]                           for (restart in restarts) {
[16:03:34.906]                             name <- restart$name
[16:03:34.906]                             if (is.null(name)) 
[16:03:34.906]                               next
[16:03:34.906]                             if (!grepl(pattern, name)) 
[16:03:34.906]                               next
[16:03:34.906]                             invokeRestart(restart)
[16:03:34.906]                             muffled <- TRUE
[16:03:34.906]                             break
[16:03:34.906]                           }
[16:03:34.906]                         }
[16:03:34.906]                       }
[16:03:34.906]                       invisible(muffled)
[16:03:34.906]                     }
[16:03:34.906]                     muffleCondition(cond, pattern = "^muffle")
[16:03:34.906]                   }
[16:03:34.906]                 }
[16:03:34.906]             }
[16:03:34.906]         }))
[16:03:34.906]     }, error = function(ex) {
[16:03:34.906]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:34.906]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:34.906]                 ...future.rng), started = ...future.startTime, 
[16:03:34.906]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:34.906]             version = "1.8"), class = "FutureResult")
[16:03:34.906]     }, finally = {
[16:03:34.906]         if (!identical(...future.workdir, getwd())) 
[16:03:34.906]             setwd(...future.workdir)
[16:03:34.906]         {
[16:03:34.906]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:34.906]                 ...future.oldOptions$nwarnings <- NULL
[16:03:34.906]             }
[16:03:34.906]             base::options(...future.oldOptions)
[16:03:34.906]             if (.Platform$OS.type == "windows") {
[16:03:34.906]                 old_names <- names(...future.oldEnvVars)
[16:03:34.906]                 envs <- base::Sys.getenv()
[16:03:34.906]                 names <- names(envs)
[16:03:34.906]                 common <- intersect(names, old_names)
[16:03:34.906]                 added <- setdiff(names, old_names)
[16:03:34.906]                 removed <- setdiff(old_names, names)
[16:03:34.906]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:34.906]                   envs[common]]
[16:03:34.906]                 NAMES <- toupper(changed)
[16:03:34.906]                 args <- list()
[16:03:34.906]                 for (kk in seq_along(NAMES)) {
[16:03:34.906]                   name <- changed[[kk]]
[16:03:34.906]                   NAME <- NAMES[[kk]]
[16:03:34.906]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:34.906]                     next
[16:03:34.906]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:34.906]                 }
[16:03:34.906]                 NAMES <- toupper(added)
[16:03:34.906]                 for (kk in seq_along(NAMES)) {
[16:03:34.906]                   name <- added[[kk]]
[16:03:34.906]                   NAME <- NAMES[[kk]]
[16:03:34.906]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:34.906]                     next
[16:03:34.906]                   args[[name]] <- ""
[16:03:34.906]                 }
[16:03:34.906]                 NAMES <- toupper(removed)
[16:03:34.906]                 for (kk in seq_along(NAMES)) {
[16:03:34.906]                   name <- removed[[kk]]
[16:03:34.906]                   NAME <- NAMES[[kk]]
[16:03:34.906]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:34.906]                     next
[16:03:34.906]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:34.906]                 }
[16:03:34.906]                 if (length(args) > 0) 
[16:03:34.906]                   base::do.call(base::Sys.setenv, args = args)
[16:03:34.906]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:34.906]             }
[16:03:34.906]             else {
[16:03:34.906]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:34.906]             }
[16:03:34.906]             {
[16:03:34.906]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:34.906]                   0L) {
[16:03:34.906]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:34.906]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:34.906]                   base::options(opts)
[16:03:34.906]                 }
[16:03:34.906]                 {
[16:03:34.906]                   {
[16:03:34.906]                     NULL
[16:03:34.906]                     RNGkind("Mersenne-Twister")
[16:03:34.906]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:34.906]                       inherits = FALSE)
[16:03:34.906]                   }
[16:03:34.906]                   options(future.plan = NULL)
[16:03:34.906]                   if (is.na(NA_character_)) 
[16:03:34.906]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:34.906]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:34.906]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:34.906]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:34.906]                     envir = parent.frame()) 
[16:03:34.906]                   {
[16:03:34.906]                     if (is.function(workers)) 
[16:03:34.906]                       workers <- workers()
[16:03:34.906]                     workers <- structure(as.integer(workers), 
[16:03:34.906]                       class = class(workers))
[16:03:34.906]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:34.906]                       workers >= 1)
[16:03:34.906]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:34.906]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:34.906]                     }
[16:03:34.906]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:34.906]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:34.906]                       envir = envir)
[16:03:34.906]                     if (!future$lazy) 
[16:03:34.906]                       future <- run(future)
[16:03:34.906]                     invisible(future)
[16:03:34.906]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:34.906]                 }
[16:03:34.906]             }
[16:03:34.906]         }
[16:03:34.906]     })
[16:03:34.906]     if (FALSE) {
[16:03:34.906]         base::sink(type = "output", split = FALSE)
[16:03:34.906]         if (NA) {
[16:03:34.906]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:34.906]         }
[16:03:34.906]         else {
[16:03:34.906]             ...future.result["stdout"] <- base::list(NULL)
[16:03:34.906]         }
[16:03:34.906]         base::close(...future.stdout)
[16:03:34.906]         ...future.stdout <- NULL
[16:03:34.906]     }
[16:03:34.906]     ...future.result$conditions <- ...future.conditions
[16:03:34.906]     ...future.result$finished <- base::Sys.time()
[16:03:34.906]     ...future.result
[16:03:34.906] }
[16:03:34.908] assign_globals() ...
[16:03:34.908] List of 5
[16:03:34.908]  $ ...future.FUN            :function (x)  
[16:03:34.908]  $ future.call.arguments    : list()
[16:03:34.908]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:34.908]  $ ...future.elements_ii    :List of 2
[16:03:34.908]   ..$ : int 1
[16:03:34.908]   ..$ : int 0
[16:03:34.908]  $ ...future.seeds_ii       : NULL
[16:03:34.908]  $ ...future.globals.maxSize: NULL
[16:03:34.908]  - attr(*, "where")=List of 5
[16:03:34.908]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:34.908]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:34.908]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:34.908]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:34.908]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:34.908]  - attr(*, "resolved")= logi FALSE
[16:03:34.908]  - attr(*, "total_size")= num 4720
[16:03:34.908]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:34.908]  - attr(*, "already-done")= logi TRUE
[16:03:34.914] - reassign environment for ‘...future.FUN’
[16:03:34.914] - copied ‘...future.FUN’ to environment
[16:03:34.914] - copied ‘future.call.arguments’ to environment
[16:03:34.914] - copied ‘...future.elements_ii’ to environment
[16:03:34.914] - copied ‘...future.seeds_ii’ to environment
[16:03:34.914] - copied ‘...future.globals.maxSize’ to environment
[16:03:34.914] assign_globals() ... done
[16:03:34.915] plan(): Setting new future strategy stack:
[16:03:34.915] List of future strategies:
[16:03:34.915] 1. sequential:
[16:03:34.915]    - args: function (..., envir = parent.frame())
[16:03:34.915]    - tweaked: FALSE
[16:03:34.915]    - call: NULL
[16:03:34.915] plan(): nbrOfWorkers() = 1
[16:03:35.417] plan(): Setting new future strategy stack:
[16:03:35.417] List of future strategies:
[16:03:35.417] 1. multisession:
[16:03:35.417]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:03:35.417]    - tweaked: FALSE
[16:03:35.417]    - call: plan(strategy)
[16:03:35.421] plan(): nbrOfWorkers() = 1
[16:03:35.421] SequentialFuture started (and completed)
[16:03:35.421] - Launch lazy future ... done
[16:03:35.421] run() for ‘SequentialFuture’ ... done
[16:03:35.421] Created future:
[16:03:35.422] SequentialFuture:
[16:03:35.422] Label: ‘future_lapply-1’
[16:03:35.422] Expression:
[16:03:35.422] {
[16:03:35.422]     do.call(function(...) {
[16:03:35.422]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:35.422]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:35.422]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:35.422]             on.exit(options(oopts), add = TRUE)
[16:03:35.422]         }
[16:03:35.422]         {
[16:03:35.422]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:35.422]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:35.422]                 ...future.FUN(...future.X_jj, ...)
[16:03:35.422]             })
[16:03:35.422]         }
[16:03:35.422]     }, args = future.call.arguments)
[16:03:35.422] }
[16:03:35.422] Lazy evaluation: FALSE
[16:03:35.422] Asynchronous evaluation: FALSE
[16:03:35.422] Local evaluation: TRUE
[16:03:35.422] Environment: R_GlobalEnv
[16:03:35.422] Capture standard output: NA
[16:03:35.422] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:35.422] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:35.422] Packages: <none>
[16:03:35.422] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:35.422] Resolved: TRUE
[16:03:35.422] Value: 112 bytes of class ‘list’
[16:03:35.422] Early signaling: FALSE
[16:03:35.422] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:35.422] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:35.423] Chunk #1 of 1 ... DONE
[16:03:35.423] Launching 1 futures (chunks) ... DONE
[16:03:35.423] Resolving 1 futures (chunks) ...
[16:03:35.423] resolve() on list ...
[16:03:35.423]  recursive: 0
[16:03:35.423]  length: 1
[16:03:35.423] 
[16:03:35.424] resolved() for ‘SequentialFuture’ ...
[16:03:35.424] - state: ‘finished’
[16:03:35.424] - run: TRUE
[16:03:35.424] - result: ‘FutureResult’
[16:03:35.424] resolved() for ‘SequentialFuture’ ... done
[16:03:35.424] Future #1
[16:03:35.424] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:35.424] - nx: 1
[16:03:35.424] - relay: TRUE
[16:03:35.424] - stdout: TRUE
[16:03:35.425] - signal: TRUE
[16:03:35.425] - resignal: FALSE
[16:03:35.425] - force: TRUE
[16:03:35.425] - relayed: [n=1] FALSE
[16:03:35.425] - queued futures: [n=1] FALSE
[16:03:35.425]  - until=1
[16:03:35.425]  - relaying element #1
[16:03:35.425] - relayed: [n=1] TRUE
[16:03:35.425] - queued futures: [n=1] TRUE
[16:03:35.426] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:35.426]  length: 0 (resolved future 1)
[16:03:35.426] Relaying remaining futures
[16:03:35.426] signalConditionsASAP(NULL, pos=0) ...
[16:03:35.426] - nx: 1
[16:03:35.426] - relay: TRUE
[16:03:35.426] - stdout: TRUE
[16:03:35.426] - signal: TRUE
[16:03:35.426] - resignal: FALSE
[16:03:35.426] - force: TRUE
[16:03:35.426] - relayed: [n=1] TRUE
[16:03:35.426] - queued futures: [n=1] TRUE
 - flush all
[16:03:35.427] - relayed: [n=1] TRUE
[16:03:35.427] - queued futures: [n=1] TRUE
[16:03:35.427] signalConditionsASAP(NULL, pos=0) ... done
[16:03:35.427] resolve() on list ... DONE
[16:03:35.427]  - Number of value chunks collected: 1
[16:03:35.427] Resolving 1 futures (chunks) ... DONE
[16:03:35.427] Reducing values from 1 chunks ...
[16:03:35.427]  - Number of values collected after concatenation: 2
[16:03:35.427]  - Number of values expected: 2
[16:03:35.428] Reducing values from 1 chunks ... DONE
[16:03:35.428] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[16:03:35.428] future_mapply() ...
[16:03:35.431] Number of chunks: 1
[16:03:35.431] getGlobalsAndPackagesXApply() ...
[16:03:35.431]  - future.globals: TRUE
[16:03:35.432] getGlobalsAndPackages() ...
[16:03:35.432] Searching for globals...
[16:03:35.433] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:03:35.433] Searching for globals ... DONE
[16:03:35.433] Resolving globals: FALSE
[16:03:35.434] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:03:35.434] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:03:35.434] - globals: [1] ‘FUN’
[16:03:35.434] 
[16:03:35.434] getGlobalsAndPackages() ... DONE
[16:03:35.435]  - globals found/used: [n=1] ‘FUN’
[16:03:35.435]  - needed namespaces: [n=0] 
[16:03:35.435] Finding globals ... DONE
[16:03:35.435] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:03:35.435] List of 2
[16:03:35.435]  $ ...future.FUN:function (x, y)  
[16:03:35.435]  $ MoreArgs     : NULL
[16:03:35.435]  - attr(*, "where")=List of 2
[16:03:35.435]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:35.435]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:03:35.435]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:35.435]  - attr(*, "resolved")= logi FALSE
[16:03:35.435]  - attr(*, "total_size")= num NA
[16:03:35.438] Packages to be attached in all futures: [n=0] 
[16:03:35.438] getGlobalsAndPackagesXApply() ... DONE
[16:03:35.438] Number of futures (= number of chunks): 1
[16:03:35.438] Launching 1 futures (chunks) ...
[16:03:35.438] Chunk #1 of 1 ...
[16:03:35.438]  - Finding globals in '...' for chunk #1 ...
[16:03:35.438] getGlobalsAndPackages() ...
[16:03:35.439] Searching for globals...
[16:03:35.439] 
[16:03:35.439] Searching for globals ... DONE
[16:03:35.439] - globals: [0] <none>
[16:03:35.441] getGlobalsAndPackages() ... DONE
[16:03:35.441]    + additional globals found: [n=0] 
[16:03:35.441]    + additional namespaces needed: [n=0] 
[16:03:35.441]  - Finding globals in '...' for chunk #1 ... DONE
[16:03:35.441]  - seeds: <none>
[16:03:35.441]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:35.441] getGlobalsAndPackages() ...
[16:03:35.441] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:35.441] Resolving globals: FALSE
[16:03:35.442] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[16:03:35.442] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:03:35.443] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:35.443] 
[16:03:35.443] getGlobalsAndPackages() ... DONE
[16:03:35.443] run() for ‘Future’ ...
[16:03:35.443] - state: ‘created’
[16:03:35.443] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:35.446] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:35.447] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:35.447]   - Field: ‘label’
[16:03:35.447]   - Field: ‘local’
[16:03:35.447]   - Field: ‘owner’
[16:03:35.447]   - Field: ‘envir’
[16:03:35.447]   - Field: ‘packages’
[16:03:35.447]   - Field: ‘gc’
[16:03:35.447]   - Field: ‘conditions’
[16:03:35.447]   - Field: ‘expr’
[16:03:35.448]   - Field: ‘uuid’
[16:03:35.448]   - Field: ‘seed’
[16:03:35.448]   - Field: ‘version’
[16:03:35.448]   - Field: ‘result’
[16:03:35.448]   - Field: ‘asynchronous’
[16:03:35.448]   - Field: ‘calls’
[16:03:35.448]   - Field: ‘globals’
[16:03:35.448]   - Field: ‘stdout’
[16:03:35.448]   - Field: ‘earlySignal’
[16:03:35.448]   - Field: ‘lazy’
[16:03:35.449]   - Field: ‘state’
[16:03:35.449] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:35.449] - Launch lazy future ...
[16:03:35.449] Packages needed by the future expression (n = 0): <none>
[16:03:35.449] Packages needed by future strategies (n = 0): <none>
[16:03:35.449] {
[16:03:35.449]     {
[16:03:35.449]         {
[16:03:35.449]             ...future.startTime <- base::Sys.time()
[16:03:35.449]             {
[16:03:35.449]                 {
[16:03:35.449]                   {
[16:03:35.449]                     base::local({
[16:03:35.449]                       has_future <- base::requireNamespace("future", 
[16:03:35.449]                         quietly = TRUE)
[16:03:35.449]                       if (has_future) {
[16:03:35.449]                         ns <- base::getNamespace("future")
[16:03:35.449]                         version <- ns[[".package"]][["version"]]
[16:03:35.449]                         if (is.null(version)) 
[16:03:35.449]                           version <- utils::packageVersion("future")
[16:03:35.449]                       }
[16:03:35.449]                       else {
[16:03:35.449]                         version <- NULL
[16:03:35.449]                       }
[16:03:35.449]                       if (!has_future || version < "1.8.0") {
[16:03:35.449]                         info <- base::c(r_version = base::gsub("R version ", 
[16:03:35.449]                           "", base::R.version$version.string), 
[16:03:35.449]                           platform = base::sprintf("%s (%s-bit)", 
[16:03:35.449]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:35.449]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:35.449]                             "release", "version")], collapse = " "), 
[16:03:35.449]                           hostname = base::Sys.info()[["nodename"]])
[16:03:35.449]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:03:35.449]                           info)
[16:03:35.449]                         info <- base::paste(info, collapse = "; ")
[16:03:35.449]                         if (!has_future) {
[16:03:35.449]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:35.449]                             info)
[16:03:35.449]                         }
[16:03:35.449]                         else {
[16:03:35.449]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:35.449]                             info, version)
[16:03:35.449]                         }
[16:03:35.449]                         base::stop(msg)
[16:03:35.449]                       }
[16:03:35.449]                     })
[16:03:35.449]                   }
[16:03:35.449]                   options(future.plan = NULL)
[16:03:35.449]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:35.449]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:35.449]                 }
[16:03:35.449]                 ...future.workdir <- getwd()
[16:03:35.449]             }
[16:03:35.449]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:35.449]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:35.449]         }
[16:03:35.449]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:35.449]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:35.449]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:35.449]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:35.449]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:35.449]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:35.449]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:35.449]             base::names(...future.oldOptions))
[16:03:35.449]     }
[16:03:35.449]     if (FALSE) {
[16:03:35.449]     }
[16:03:35.449]     else {
[16:03:35.449]         if (FALSE) {
[16:03:35.449]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:35.449]                 open = "w")
[16:03:35.449]         }
[16:03:35.449]         else {
[16:03:35.449]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:35.449]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:35.449]         }
[16:03:35.449]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:35.449]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:35.449]             base::sink(type = "output", split = FALSE)
[16:03:35.449]             base::close(...future.stdout)
[16:03:35.449]         }, add = TRUE)
[16:03:35.449]     }
[16:03:35.449]     ...future.frame <- base::sys.nframe()
[16:03:35.449]     ...future.conditions <- base::list()
[16:03:35.449]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:35.449]     if (FALSE) {
[16:03:35.449]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:35.449]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:35.449]     }
[16:03:35.449]     ...future.result <- base::tryCatch({
[16:03:35.449]         base::withCallingHandlers({
[16:03:35.449]             ...future.value <- base::withVisible(base::local({
[16:03:35.449]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:35.449]                 if (!identical(...future.globals.maxSize.org, 
[16:03:35.449]                   ...future.globals.maxSize)) {
[16:03:35.449]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:35.449]                   on.exit(options(oopts), add = TRUE)
[16:03:35.449]                 }
[16:03:35.449]                 {
[16:03:35.449]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:35.449]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:03:35.449]                     USE.NAMES = FALSE)
[16:03:35.449]                   do.call(mapply, args = args)
[16:03:35.449]                 }
[16:03:35.449]             }))
[16:03:35.449]             future::FutureResult(value = ...future.value$value, 
[16:03:35.449]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:35.449]                   ...future.rng), globalenv = if (FALSE) 
[16:03:35.449]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:35.449]                     ...future.globalenv.names))
[16:03:35.449]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:35.449]         }, condition = base::local({
[16:03:35.449]             c <- base::c
[16:03:35.449]             inherits <- base::inherits
[16:03:35.449]             invokeRestart <- base::invokeRestart
[16:03:35.449]             length <- base::length
[16:03:35.449]             list <- base::list
[16:03:35.449]             seq.int <- base::seq.int
[16:03:35.449]             signalCondition <- base::signalCondition
[16:03:35.449]             sys.calls <- base::sys.calls
[16:03:35.449]             `[[` <- base::`[[`
[16:03:35.449]             `+` <- base::`+`
[16:03:35.449]             `<<-` <- base::`<<-`
[16:03:35.449]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:35.449]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:35.449]                   3L)]
[16:03:35.449]             }
[16:03:35.449]             function(cond) {
[16:03:35.449]                 is_error <- inherits(cond, "error")
[16:03:35.449]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:35.449]                   NULL)
[16:03:35.449]                 if (is_error) {
[16:03:35.449]                   sessionInformation <- function() {
[16:03:35.449]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:35.449]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:35.449]                       search = base::search(), system = base::Sys.info())
[16:03:35.449]                   }
[16:03:35.449]                   ...future.conditions[[length(...future.conditions) + 
[16:03:35.449]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:35.449]                     cond$call), session = sessionInformation(), 
[16:03:35.449]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:35.449]                   signalCondition(cond)
[16:03:35.449]                 }
[16:03:35.449]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:35.449]                 "immediateCondition"))) {
[16:03:35.449]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:35.449]                   ...future.conditions[[length(...future.conditions) + 
[16:03:35.449]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:35.449]                   if (TRUE && !signal) {
[16:03:35.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:35.449]                     {
[16:03:35.449]                       inherits <- base::inherits
[16:03:35.449]                       invokeRestart <- base::invokeRestart
[16:03:35.449]                       is.null <- base::is.null
[16:03:35.449]                       muffled <- FALSE
[16:03:35.449]                       if (inherits(cond, "message")) {
[16:03:35.449]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:35.449]                         if (muffled) 
[16:03:35.449]                           invokeRestart("muffleMessage")
[16:03:35.449]                       }
[16:03:35.449]                       else if (inherits(cond, "warning")) {
[16:03:35.449]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:35.449]                         if (muffled) 
[16:03:35.449]                           invokeRestart("muffleWarning")
[16:03:35.449]                       }
[16:03:35.449]                       else if (inherits(cond, "condition")) {
[16:03:35.449]                         if (!is.null(pattern)) {
[16:03:35.449]                           computeRestarts <- base::computeRestarts
[16:03:35.449]                           grepl <- base::grepl
[16:03:35.449]                           restarts <- computeRestarts(cond)
[16:03:35.449]                           for (restart in restarts) {
[16:03:35.449]                             name <- restart$name
[16:03:35.449]                             if (is.null(name)) 
[16:03:35.449]                               next
[16:03:35.449]                             if (!grepl(pattern, name)) 
[16:03:35.449]                               next
[16:03:35.449]                             invokeRestart(restart)
[16:03:35.449]                             muffled <- TRUE
[16:03:35.449]                             break
[16:03:35.449]                           }
[16:03:35.449]                         }
[16:03:35.449]                       }
[16:03:35.449]                       invisible(muffled)
[16:03:35.449]                     }
[16:03:35.449]                     muffleCondition(cond, pattern = "^muffle")
[16:03:35.449]                   }
[16:03:35.449]                 }
[16:03:35.449]                 else {
[16:03:35.449]                   if (TRUE) {
[16:03:35.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:35.449]                     {
[16:03:35.449]                       inherits <- base::inherits
[16:03:35.449]                       invokeRestart <- base::invokeRestart
[16:03:35.449]                       is.null <- base::is.null
[16:03:35.449]                       muffled <- FALSE
[16:03:35.449]                       if (inherits(cond, "message")) {
[16:03:35.449]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:35.449]                         if (muffled) 
[16:03:35.449]                           invokeRestart("muffleMessage")
[16:03:35.449]                       }
[16:03:35.449]                       else if (inherits(cond, "warning")) {
[16:03:35.449]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:35.449]                         if (muffled) 
[16:03:35.449]                           invokeRestart("muffleWarning")
[16:03:35.449]                       }
[16:03:35.449]                       else if (inherits(cond, "condition")) {
[16:03:35.449]                         if (!is.null(pattern)) {
[16:03:35.449]                           computeRestarts <- base::computeRestarts
[16:03:35.449]                           grepl <- base::grepl
[16:03:35.449]                           restarts <- computeRestarts(cond)
[16:03:35.449]                           for (restart in restarts) {
[16:03:35.449]                             name <- restart$name
[16:03:35.449]                             if (is.null(name)) 
[16:03:35.449]                               next
[16:03:35.449]                             if (!grepl(pattern, name)) 
[16:03:35.449]                               next
[16:03:35.449]                             invokeRestart(restart)
[16:03:35.449]                             muffled <- TRUE
[16:03:35.449]                             break
[16:03:35.449]                           }
[16:03:35.449]                         }
[16:03:35.449]                       }
[16:03:35.449]                       invisible(muffled)
[16:03:35.449]                     }
[16:03:35.449]                     muffleCondition(cond, pattern = "^muffle")
[16:03:35.449]                   }
[16:03:35.449]                 }
[16:03:35.449]             }
[16:03:35.449]         }))
[16:03:35.449]     }, error = function(ex) {
[16:03:35.449]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:35.449]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:35.449]                 ...future.rng), started = ...future.startTime, 
[16:03:35.449]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:35.449]             version = "1.8"), class = "FutureResult")
[16:03:35.449]     }, finally = {
[16:03:35.449]         if (!identical(...future.workdir, getwd())) 
[16:03:35.449]             setwd(...future.workdir)
[16:03:35.449]         {
[16:03:35.449]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:35.449]                 ...future.oldOptions$nwarnings <- NULL
[16:03:35.449]             }
[16:03:35.449]             base::options(...future.oldOptions)
[16:03:35.449]             if (.Platform$OS.type == "windows") {
[16:03:35.449]                 old_names <- names(...future.oldEnvVars)
[16:03:35.449]                 envs <- base::Sys.getenv()
[16:03:35.449]                 names <- names(envs)
[16:03:35.449]                 common <- intersect(names, old_names)
[16:03:35.449]                 added <- setdiff(names, old_names)
[16:03:35.449]                 removed <- setdiff(old_names, names)
[16:03:35.449]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:35.449]                   envs[common]]
[16:03:35.449]                 NAMES <- toupper(changed)
[16:03:35.449]                 args <- list()
[16:03:35.449]                 for (kk in seq_along(NAMES)) {
[16:03:35.449]                   name <- changed[[kk]]
[16:03:35.449]                   NAME <- NAMES[[kk]]
[16:03:35.449]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:35.449]                     next
[16:03:35.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:35.449]                 }
[16:03:35.449]                 NAMES <- toupper(added)
[16:03:35.449]                 for (kk in seq_along(NAMES)) {
[16:03:35.449]                   name <- added[[kk]]
[16:03:35.449]                   NAME <- NAMES[[kk]]
[16:03:35.449]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:35.449]                     next
[16:03:35.449]                   args[[name]] <- ""
[16:03:35.449]                 }
[16:03:35.449]                 NAMES <- toupper(removed)
[16:03:35.449]                 for (kk in seq_along(NAMES)) {
[16:03:35.449]                   name <- removed[[kk]]
[16:03:35.449]                   NAME <- NAMES[[kk]]
[16:03:35.449]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:35.449]                     next
[16:03:35.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:35.449]                 }
[16:03:35.449]                 if (length(args) > 0) 
[16:03:35.449]                   base::do.call(base::Sys.setenv, args = args)
[16:03:35.449]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:35.449]             }
[16:03:35.449]             else {
[16:03:35.449]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:35.449]             }
[16:03:35.449]             {
[16:03:35.449]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:35.449]                   0L) {
[16:03:35.449]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:35.449]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:35.449]                   base::options(opts)
[16:03:35.449]                 }
[16:03:35.449]                 {
[16:03:35.449]                   {
[16:03:35.449]                     NULL
[16:03:35.449]                     RNGkind("Mersenne-Twister")
[16:03:35.449]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:35.449]                       inherits = FALSE)
[16:03:35.449]                   }
[16:03:35.449]                   options(future.plan = NULL)
[16:03:35.449]                   if (is.na(NA_character_)) 
[16:03:35.449]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:35.449]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:35.449]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:35.449]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:35.449]                     envir = parent.frame()) 
[16:03:35.449]                   {
[16:03:35.449]                     if (is.function(workers)) 
[16:03:35.449]                       workers <- workers()
[16:03:35.449]                     workers <- structure(as.integer(workers), 
[16:03:35.449]                       class = class(workers))
[16:03:35.449]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:35.449]                       workers >= 1)
[16:03:35.449]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:35.449]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:35.449]                     }
[16:03:35.449]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:35.449]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:35.449]                       envir = envir)
[16:03:35.449]                     if (!future$lazy) 
[16:03:35.449]                       future <- run(future)
[16:03:35.449]                     invisible(future)
[16:03:35.449]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:35.449]                 }
[16:03:35.449]             }
[16:03:35.449]         }
[16:03:35.449]     })
[16:03:35.449]     if (TRUE) {
[16:03:35.449]         base::sink(type = "output", split = FALSE)
[16:03:35.449]         if (FALSE) {
[16:03:35.449]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:35.449]         }
[16:03:35.449]         else {
[16:03:35.449]             ...future.result["stdout"] <- base::list(NULL)
[16:03:35.449]         }
[16:03:35.449]         base::close(...future.stdout)
[16:03:35.449]         ...future.stdout <- NULL
[16:03:35.449]     }
[16:03:35.449]     ...future.result$conditions <- ...future.conditions
[16:03:35.449]     ...future.result$finished <- base::Sys.time()
[16:03:35.449]     ...future.result
[16:03:35.449] }
[16:03:35.451] assign_globals() ...
[16:03:35.451] List of 5
[16:03:35.451]  $ ...future.FUN            :function (x, y)  
[16:03:35.451]  $ MoreArgs                 : NULL
[16:03:35.451]  $ ...future.elements_ii    :List of 2
[16:03:35.451]   ..$ :List of 2
[16:03:35.451]   .. ..$ : int 1
[16:03:35.451]   .. ..$ : int 0
[16:03:35.451]   ..$ :List of 2
[16:03:35.451]   .. ..$ : int 0
[16:03:35.451]   .. ..$ : int 1
[16:03:35.451]  $ ...future.seeds_ii       : NULL
[16:03:35.451]  $ ...future.globals.maxSize: NULL
[16:03:35.451]  - attr(*, "where")=List of 5
[16:03:35.451]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:35.451]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:03:35.451]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:35.451]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:35.451]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:35.451]  - attr(*, "resolved")= logi FALSE
[16:03:35.451]  - attr(*, "total_size")= num 6480
[16:03:35.451]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:35.451]  - attr(*, "already-done")= logi TRUE
[16:03:35.457] - reassign environment for ‘...future.FUN’
[16:03:35.457] - copied ‘...future.FUN’ to environment
[16:03:35.457] - copied ‘MoreArgs’ to environment
[16:03:35.457] - copied ‘...future.elements_ii’ to environment
[16:03:35.457] - copied ‘...future.seeds_ii’ to environment
[16:03:35.457] - copied ‘...future.globals.maxSize’ to environment
[16:03:35.457] assign_globals() ... done
[16:03:35.458] plan(): Setting new future strategy stack:
[16:03:35.458] List of future strategies:
[16:03:35.458] 1. sequential:
[16:03:35.458]    - args: function (..., envir = parent.frame())
[16:03:35.458]    - tweaked: FALSE
[16:03:35.458]    - call: NULL
[16:03:35.458] plan(): nbrOfWorkers() = 1
[16:03:35.960] plan(): Setting new future strategy stack:
[16:03:35.960] List of future strategies:
[16:03:35.960] 1. multisession:
[16:03:35.960]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:03:35.960]    - tweaked: FALSE
[16:03:35.960]    - call: plan(strategy)
[16:03:35.964] plan(): nbrOfWorkers() = 1
[16:03:35.964] SequentialFuture started (and completed)
[16:03:35.964] - Launch lazy future ... done
[16:03:35.964] run() for ‘SequentialFuture’ ... done
[16:03:35.964] Created future:
[16:03:35.964] SequentialFuture:
[16:03:35.964] Label: ‘future_mapply-1’
[16:03:35.964] Expression:
[16:03:35.964] {
[16:03:35.964]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:35.964]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:35.964]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:35.964]         on.exit(options(oopts), add = TRUE)
[16:03:35.964]     }
[16:03:35.964]     {
[16:03:35.964]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:35.964]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:03:35.964]         do.call(mapply, args = args)
[16:03:35.964]     }
[16:03:35.964] }
[16:03:35.964] Lazy evaluation: FALSE
[16:03:35.964] Asynchronous evaluation: FALSE
[16:03:35.964] Local evaluation: TRUE
[16:03:35.964] Environment: R_GlobalEnv
[16:03:35.964] Capture standard output: FALSE
[16:03:35.964] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:35.964] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:35.964] Packages: <none>
[16:03:35.964] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:35.964] Resolved: TRUE
[16:03:35.964] Value: 224 bytes of class ‘list’
[16:03:35.964] Early signaling: FALSE
[16:03:35.964] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:35.964] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:35.965] Chunk #1 of 1 ... DONE
[16:03:35.965] Launching 1 futures (chunks) ... DONE
[16:03:35.965] Resolving 1 futures (chunks) ...
[16:03:35.966] resolve() on list ...
[16:03:35.966]  recursive: 0
[16:03:35.966]  length: 1
[16:03:35.966] 
[16:03:35.966] resolved() for ‘SequentialFuture’ ...
[16:03:35.966] - state: ‘finished’
[16:03:35.966] - run: TRUE
[16:03:35.966] - result: ‘FutureResult’
[16:03:35.966] resolved() for ‘SequentialFuture’ ... done
[16:03:35.966] Future #1
[16:03:35.967] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:35.967] - nx: 1
[16:03:35.967] - relay: TRUE
[16:03:35.967] - stdout: TRUE
[16:03:35.967] - signal: TRUE
[16:03:35.967] - resignal: FALSE
[16:03:35.967] - force: TRUE
[16:03:35.967] - relayed: [n=1] FALSE
[16:03:35.967] - queued futures: [n=1] FALSE
[16:03:35.967]  - until=1
[16:03:35.968]  - relaying element #1
[16:03:35.968] - relayed: [n=1] TRUE
[16:03:35.968] - queued futures: [n=1] TRUE
[16:03:35.968] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:35.968]  length: 0 (resolved future 1)
[16:03:35.968] Relaying remaining futures
[16:03:35.968] signalConditionsASAP(NULL, pos=0) ...
[16:03:35.968] - nx: 1
[16:03:35.968] - relay: TRUE
[16:03:35.968] - stdout: TRUE
[16:03:35.969] - signal: TRUE
[16:03:35.969] - resignal: FALSE
[16:03:35.969] - force: TRUE
[16:03:35.969] - relayed: [n=1] TRUE
[16:03:35.969] - queued futures: [n=1] TRUE
 - flush all
[16:03:35.969] - relayed: [n=1] TRUE
[16:03:35.969] - queued futures: [n=1] TRUE
[16:03:35.969] signalConditionsASAP(NULL, pos=0) ... done
[16:03:35.969] resolve() on list ... DONE
[16:03:35.969]  - Number of value chunks collected: 1
[16:03:35.969] Resolving 1 futures (chunks) ... DONE
[16:03:35.970] Reducing values from 1 chunks ...
[16:03:35.970]  - Number of values collected after concatenation: 2
[16:03:35.970]  - Number of values expected: 2
[16:03:35.970] Reducing values from 1 chunks ... DONE
[16:03:35.970] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[16:03:35.970] future_mapply() ...
[16:03:35.975] Number of chunks: 1
[16:03:35.975] getGlobalsAndPackagesXApply() ...
[16:03:35.975]  - future.globals: TRUE
[16:03:35.975] getGlobalsAndPackages() ...
[16:03:35.976] Searching for globals...
[16:03:35.977] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:03:35.977] Searching for globals ... DONE
[16:03:35.978] Resolving globals: FALSE
[16:03:35.978] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:03:35.978] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:03:35.978] - globals: [1] ‘FUN’
[16:03:35.979] 
[16:03:35.979] getGlobalsAndPackages() ... DONE
[16:03:35.979]  - globals found/used: [n=1] ‘FUN’
[16:03:35.979]  - needed namespaces: [n=0] 
[16:03:35.979] Finding globals ... DONE
[16:03:35.979] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:03:35.979] List of 2
[16:03:35.979]  $ ...future.FUN:function (x, y)  
[16:03:35.979]  $ MoreArgs     : NULL
[16:03:35.979]  - attr(*, "where")=List of 2
[16:03:35.979]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:35.979]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:03:35.979]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:35.979]  - attr(*, "resolved")= logi FALSE
[16:03:35.979]  - attr(*, "total_size")= num NA
[16:03:35.982] Packages to be attached in all futures: [n=0] 
[16:03:35.982] getGlobalsAndPackagesXApply() ... DONE
[16:03:35.982] Number of futures (= number of chunks): 1
[16:03:35.982] Launching 1 futures (chunks) ...
[16:03:35.982] Chunk #1 of 1 ...
[16:03:35.982]  - Finding globals in '...' for chunk #1 ...
[16:03:35.982] getGlobalsAndPackages() ...
[16:03:35.983] Searching for globals...
[16:03:35.983] 
[16:03:35.983] Searching for globals ... DONE
[16:03:35.983] - globals: [0] <none>
[16:03:35.983] getGlobalsAndPackages() ... DONE
[16:03:35.983]    + additional globals found: [n=0] 
[16:03:35.983]    + additional namespaces needed: [n=0] 
[16:03:35.983]  - Finding globals in '...' for chunk #1 ... DONE
[16:03:35.984]  - seeds: <none>
[16:03:35.984]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:35.984] getGlobalsAndPackages() ...
[16:03:35.984] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:35.984] Resolving globals: FALSE
[16:03:35.984] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[16:03:35.985] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:03:35.985] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:35.985] 
[16:03:35.985] getGlobalsAndPackages() ... DONE
[16:03:35.985] run() for ‘Future’ ...
[16:03:35.985] - state: ‘created’
[16:03:35.986] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:35.989] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:35.989] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:35.989]   - Field: ‘label’
[16:03:35.989]   - Field: ‘local’
[16:03:35.989]   - Field: ‘owner’
[16:03:35.989]   - Field: ‘envir’
[16:03:35.990]   - Field: ‘packages’
[16:03:35.990]   - Field: ‘gc’
[16:03:35.990]   - Field: ‘conditions’
[16:03:35.990]   - Field: ‘expr’
[16:03:35.990]   - Field: ‘uuid’
[16:03:35.990]   - Field: ‘seed’
[16:03:35.990]   - Field: ‘version’
[16:03:35.990]   - Field: ‘result’
[16:03:35.990]   - Field: ‘asynchronous’
[16:03:35.990]   - Field: ‘calls’
[16:03:35.991]   - Field: ‘globals’
[16:03:35.991]   - Field: ‘stdout’
[16:03:35.991]   - Field: ‘earlySignal’
[16:03:35.991]   - Field: ‘lazy’
[16:03:35.991]   - Field: ‘state’
[16:03:35.991] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:35.991] - Launch lazy future ...
[16:03:35.991] Packages needed by the future expression (n = 0): <none>
[16:03:35.991] Packages needed by future strategies (n = 0): <none>
[16:03:35.992] {
[16:03:35.992]     {
[16:03:35.992]         {
[16:03:35.992]             ...future.startTime <- base::Sys.time()
[16:03:35.992]             {
[16:03:35.992]                 {
[16:03:35.992]                   {
[16:03:35.992]                     base::local({
[16:03:35.992]                       has_future <- base::requireNamespace("future", 
[16:03:35.992]                         quietly = TRUE)
[16:03:35.992]                       if (has_future) {
[16:03:35.992]                         ns <- base::getNamespace("future")
[16:03:35.992]                         version <- ns[[".package"]][["version"]]
[16:03:35.992]                         if (is.null(version)) 
[16:03:35.992]                           version <- utils::packageVersion("future")
[16:03:35.992]                       }
[16:03:35.992]                       else {
[16:03:35.992]                         version <- NULL
[16:03:35.992]                       }
[16:03:35.992]                       if (!has_future || version < "1.8.0") {
[16:03:35.992]                         info <- base::c(r_version = base::gsub("R version ", 
[16:03:35.992]                           "", base::R.version$version.string), 
[16:03:35.992]                           platform = base::sprintf("%s (%s-bit)", 
[16:03:35.992]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:35.992]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:35.992]                             "release", "version")], collapse = " "), 
[16:03:35.992]                           hostname = base::Sys.info()[["nodename"]])
[16:03:35.992]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:03:35.992]                           info)
[16:03:35.992]                         info <- base::paste(info, collapse = "; ")
[16:03:35.992]                         if (!has_future) {
[16:03:35.992]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:35.992]                             info)
[16:03:35.992]                         }
[16:03:35.992]                         else {
[16:03:35.992]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:35.992]                             info, version)
[16:03:35.992]                         }
[16:03:35.992]                         base::stop(msg)
[16:03:35.992]                       }
[16:03:35.992]                     })
[16:03:35.992]                   }
[16:03:35.992]                   options(future.plan = NULL)
[16:03:35.992]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:35.992]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:35.992]                 }
[16:03:35.992]                 ...future.workdir <- getwd()
[16:03:35.992]             }
[16:03:35.992]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:35.992]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:35.992]         }
[16:03:35.992]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:35.992]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:35.992]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:35.992]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:35.992]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:35.992]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:35.992]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:35.992]             base::names(...future.oldOptions))
[16:03:35.992]     }
[16:03:35.992]     if (FALSE) {
[16:03:35.992]     }
[16:03:35.992]     else {
[16:03:35.992]         if (TRUE) {
[16:03:35.992]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:35.992]                 open = "w")
[16:03:35.992]         }
[16:03:35.992]         else {
[16:03:35.992]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:35.992]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:35.992]         }
[16:03:35.992]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:35.992]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:35.992]             base::sink(type = "output", split = FALSE)
[16:03:35.992]             base::close(...future.stdout)
[16:03:35.992]         }, add = TRUE)
[16:03:35.992]     }
[16:03:35.992]     ...future.frame <- base::sys.nframe()
[16:03:35.992]     ...future.conditions <- base::list()
[16:03:35.992]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:35.992]     if (FALSE) {
[16:03:35.992]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:35.992]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:35.992]     }
[16:03:35.992]     ...future.result <- base::tryCatch({
[16:03:35.992]         base::withCallingHandlers({
[16:03:35.992]             ...future.value <- base::withVisible(base::local({
[16:03:35.992]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:35.992]                 if (!identical(...future.globals.maxSize.org, 
[16:03:35.992]                   ...future.globals.maxSize)) {
[16:03:35.992]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:35.992]                   on.exit(options(oopts), add = TRUE)
[16:03:35.992]                 }
[16:03:35.992]                 {
[16:03:35.992]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:35.992]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:03:35.992]                     USE.NAMES = FALSE)
[16:03:35.992]                   do.call(mapply, args = args)
[16:03:35.992]                 }
[16:03:35.992]             }))
[16:03:35.992]             future::FutureResult(value = ...future.value$value, 
[16:03:35.992]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:35.992]                   ...future.rng), globalenv = if (FALSE) 
[16:03:35.992]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:35.992]                     ...future.globalenv.names))
[16:03:35.992]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:35.992]         }, condition = base::local({
[16:03:35.992]             c <- base::c
[16:03:35.992]             inherits <- base::inherits
[16:03:35.992]             invokeRestart <- base::invokeRestart
[16:03:35.992]             length <- base::length
[16:03:35.992]             list <- base::list
[16:03:35.992]             seq.int <- base::seq.int
[16:03:35.992]             signalCondition <- base::signalCondition
[16:03:35.992]             sys.calls <- base::sys.calls
[16:03:35.992]             `[[` <- base::`[[`
[16:03:35.992]             `+` <- base::`+`
[16:03:35.992]             `<<-` <- base::`<<-`
[16:03:35.992]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:35.992]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:35.992]                   3L)]
[16:03:35.992]             }
[16:03:35.992]             function(cond) {
[16:03:35.992]                 is_error <- inherits(cond, "error")
[16:03:35.992]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:35.992]                   NULL)
[16:03:35.992]                 if (is_error) {
[16:03:35.992]                   sessionInformation <- function() {
[16:03:35.992]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:35.992]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:35.992]                       search = base::search(), system = base::Sys.info())
[16:03:35.992]                   }
[16:03:35.992]                   ...future.conditions[[length(...future.conditions) + 
[16:03:35.992]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:35.992]                     cond$call), session = sessionInformation(), 
[16:03:35.992]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:35.992]                   signalCondition(cond)
[16:03:35.992]                 }
[16:03:35.992]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:35.992]                 "immediateCondition"))) {
[16:03:35.992]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:35.992]                   ...future.conditions[[length(...future.conditions) + 
[16:03:35.992]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:35.992]                   if (TRUE && !signal) {
[16:03:35.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:35.992]                     {
[16:03:35.992]                       inherits <- base::inherits
[16:03:35.992]                       invokeRestart <- base::invokeRestart
[16:03:35.992]                       is.null <- base::is.null
[16:03:35.992]                       muffled <- FALSE
[16:03:35.992]                       if (inherits(cond, "message")) {
[16:03:35.992]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:35.992]                         if (muffled) 
[16:03:35.992]                           invokeRestart("muffleMessage")
[16:03:35.992]                       }
[16:03:35.992]                       else if (inherits(cond, "warning")) {
[16:03:35.992]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:35.992]                         if (muffled) 
[16:03:35.992]                           invokeRestart("muffleWarning")
[16:03:35.992]                       }
[16:03:35.992]                       else if (inherits(cond, "condition")) {
[16:03:35.992]                         if (!is.null(pattern)) {
[16:03:35.992]                           computeRestarts <- base::computeRestarts
[16:03:35.992]                           grepl <- base::grepl
[16:03:35.992]                           restarts <- computeRestarts(cond)
[16:03:35.992]                           for (restart in restarts) {
[16:03:35.992]                             name <- restart$name
[16:03:35.992]                             if (is.null(name)) 
[16:03:35.992]                               next
[16:03:35.992]                             if (!grepl(pattern, name)) 
[16:03:35.992]                               next
[16:03:35.992]                             invokeRestart(restart)
[16:03:35.992]                             muffled <- TRUE
[16:03:35.992]                             break
[16:03:35.992]                           }
[16:03:35.992]                         }
[16:03:35.992]                       }
[16:03:35.992]                       invisible(muffled)
[16:03:35.992]                     }
[16:03:35.992]                     muffleCondition(cond, pattern = "^muffle")
[16:03:35.992]                   }
[16:03:35.992]                 }
[16:03:35.992]                 else {
[16:03:35.992]                   if (TRUE) {
[16:03:35.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:35.992]                     {
[16:03:35.992]                       inherits <- base::inherits
[16:03:35.992]                       invokeRestart <- base::invokeRestart
[16:03:35.992]                       is.null <- base::is.null
[16:03:35.992]                       muffled <- FALSE
[16:03:35.992]                       if (inherits(cond, "message")) {
[16:03:35.992]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:35.992]                         if (muffled) 
[16:03:35.992]                           invokeRestart("muffleMessage")
[16:03:35.992]                       }
[16:03:35.992]                       else if (inherits(cond, "warning")) {
[16:03:35.992]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:35.992]                         if (muffled) 
[16:03:35.992]                           invokeRestart("muffleWarning")
[16:03:35.992]                       }
[16:03:35.992]                       else if (inherits(cond, "condition")) {
[16:03:35.992]                         if (!is.null(pattern)) {
[16:03:35.992]                           computeRestarts <- base::computeRestarts
[16:03:35.992]                           grepl <- base::grepl
[16:03:35.992]                           restarts <- computeRestarts(cond)
[16:03:35.992]                           for (restart in restarts) {
[16:03:35.992]                             name <- restart$name
[16:03:35.992]                             if (is.null(name)) 
[16:03:35.992]                               next
[16:03:35.992]                             if (!grepl(pattern, name)) 
[16:03:35.992]                               next
[16:03:35.992]                             invokeRestart(restart)
[16:03:35.992]                             muffled <- TRUE
[16:03:35.992]                             break
[16:03:35.992]                           }
[16:03:35.992]                         }
[16:03:35.992]                       }
[16:03:35.992]                       invisible(muffled)
[16:03:35.992]                     }
[16:03:35.992]                     muffleCondition(cond, pattern = "^muffle")
[16:03:35.992]                   }
[16:03:35.992]                 }
[16:03:35.992]             }
[16:03:35.992]         }))
[16:03:35.992]     }, error = function(ex) {
[16:03:35.992]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:35.992]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:35.992]                 ...future.rng), started = ...future.startTime, 
[16:03:35.992]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:35.992]             version = "1.8"), class = "FutureResult")
[16:03:35.992]     }, finally = {
[16:03:35.992]         if (!identical(...future.workdir, getwd())) 
[16:03:35.992]             setwd(...future.workdir)
[16:03:35.992]         {
[16:03:35.992]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:35.992]                 ...future.oldOptions$nwarnings <- NULL
[16:03:35.992]             }
[16:03:35.992]             base::options(...future.oldOptions)
[16:03:35.992]             if (.Platform$OS.type == "windows") {
[16:03:35.992]                 old_names <- names(...future.oldEnvVars)
[16:03:35.992]                 envs <- base::Sys.getenv()
[16:03:35.992]                 names <- names(envs)
[16:03:35.992]                 common <- intersect(names, old_names)
[16:03:35.992]                 added <- setdiff(names, old_names)
[16:03:35.992]                 removed <- setdiff(old_names, names)
[16:03:35.992]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:35.992]                   envs[common]]
[16:03:35.992]                 NAMES <- toupper(changed)
[16:03:35.992]                 args <- list()
[16:03:35.992]                 for (kk in seq_along(NAMES)) {
[16:03:35.992]                   name <- changed[[kk]]
[16:03:35.992]                   NAME <- NAMES[[kk]]
[16:03:35.992]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:35.992]                     next
[16:03:35.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:35.992]                 }
[16:03:35.992]                 NAMES <- toupper(added)
[16:03:35.992]                 for (kk in seq_along(NAMES)) {
[16:03:35.992]                   name <- added[[kk]]
[16:03:35.992]                   NAME <- NAMES[[kk]]
[16:03:35.992]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:35.992]                     next
[16:03:35.992]                   args[[name]] <- ""
[16:03:35.992]                 }
[16:03:35.992]                 NAMES <- toupper(removed)
[16:03:35.992]                 for (kk in seq_along(NAMES)) {
[16:03:35.992]                   name <- removed[[kk]]
[16:03:35.992]                   NAME <- NAMES[[kk]]
[16:03:35.992]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:35.992]                     next
[16:03:35.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:35.992]                 }
[16:03:35.992]                 if (length(args) > 0) 
[16:03:35.992]                   base::do.call(base::Sys.setenv, args = args)
[16:03:35.992]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:35.992]             }
[16:03:35.992]             else {
[16:03:35.992]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:35.992]             }
[16:03:35.992]             {
[16:03:35.992]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:35.992]                   0L) {
[16:03:35.992]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:35.992]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:35.992]                   base::options(opts)
[16:03:35.992]                 }
[16:03:35.992]                 {
[16:03:35.992]                   {
[16:03:35.992]                     NULL
[16:03:35.992]                     RNGkind("Mersenne-Twister")
[16:03:35.992]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:35.992]                       inherits = FALSE)
[16:03:35.992]                   }
[16:03:35.992]                   options(future.plan = NULL)
[16:03:35.992]                   if (is.na(NA_character_)) 
[16:03:35.992]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:35.992]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:35.992]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:35.992]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:35.992]                     envir = parent.frame()) 
[16:03:35.992]                   {
[16:03:35.992]                     if (is.function(workers)) 
[16:03:35.992]                       workers <- workers()
[16:03:35.992]                     workers <- structure(as.integer(workers), 
[16:03:35.992]                       class = class(workers))
[16:03:35.992]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:35.992]                       workers >= 1)
[16:03:35.992]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:35.992]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:35.992]                     }
[16:03:35.992]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:35.992]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:35.992]                       envir = envir)
[16:03:35.992]                     if (!future$lazy) 
[16:03:35.992]                       future <- run(future)
[16:03:35.992]                     invisible(future)
[16:03:35.992]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:35.992]                 }
[16:03:35.992]             }
[16:03:35.992]         }
[16:03:35.992]     })
[16:03:35.992]     if (TRUE) {
[16:03:35.992]         base::sink(type = "output", split = FALSE)
[16:03:35.992]         if (TRUE) {
[16:03:35.992]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:35.992]         }
[16:03:35.992]         else {
[16:03:35.992]             ...future.result["stdout"] <- base::list(NULL)
[16:03:35.992]         }
[16:03:35.992]         base::close(...future.stdout)
[16:03:35.992]         ...future.stdout <- NULL
[16:03:35.992]     }
[16:03:35.992]     ...future.result$conditions <- ...future.conditions
[16:03:35.992]     ...future.result$finished <- base::Sys.time()
[16:03:35.992]     ...future.result
[16:03:35.992] }
[16:03:35.994] assign_globals() ...
[16:03:35.994] List of 5
[16:03:35.994]  $ ...future.FUN            :function (x, y)  
[16:03:35.994]  $ MoreArgs                 : NULL
[16:03:35.994]  $ ...future.elements_ii    :List of 2
[16:03:35.994]   ..$ :List of 2
[16:03:35.994]   .. ..$ : int 1
[16:03:35.994]   .. ..$ : int 0
[16:03:35.994]   ..$ :List of 2
[16:03:35.994]   .. ..$ : int 0
[16:03:35.994]   .. ..$ : int 1
[16:03:35.994]  $ ...future.seeds_ii       : NULL
[16:03:35.994]  $ ...future.globals.maxSize: NULL
[16:03:35.994]  - attr(*, "where")=List of 5
[16:03:35.994]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:35.994]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:03:35.994]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:35.994]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:35.994]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:35.994]  - attr(*, "resolved")= logi FALSE
[16:03:35.994]  - attr(*, "total_size")= num 6480
[16:03:35.994]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:35.994]  - attr(*, "already-done")= logi TRUE
[16:03:35.999] - reassign environment for ‘...future.FUN’
[16:03:35.999] - copied ‘...future.FUN’ to environment
[16:03:35.999] - copied ‘MoreArgs’ to environment
[16:03:36.000] - copied ‘...future.elements_ii’ to environment
[16:03:36.000] - copied ‘...future.seeds_ii’ to environment
[16:03:36.000] - copied ‘...future.globals.maxSize’ to environment
[16:03:36.000] assign_globals() ... done
[16:03:36.000] plan(): Setting new future strategy stack:
[16:03:36.000] List of future strategies:
[16:03:36.000] 1. sequential:
[16:03:36.000]    - args: function (..., envir = parent.frame())
[16:03:36.000]    - tweaked: FALSE
[16:03:36.000]    - call: NULL
[16:03:36.001] plan(): nbrOfWorkers() = 1
[16:03:36.502] plan(): Setting new future strategy stack:
[16:03:36.502] List of future strategies:
[16:03:36.502] 1. multisession:
[16:03:36.502]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:03:36.502]    - tweaked: FALSE
[16:03:36.502]    - call: plan(strategy)
[16:03:36.508] plan(): nbrOfWorkers() = 1
[16:03:36.508] SequentialFuture started (and completed)
[16:03:36.508] - Launch lazy future ... done
[16:03:36.508] run() for ‘SequentialFuture’ ... done
[16:03:36.509] Created future:
[16:03:36.509] SequentialFuture:
[16:03:36.509] Label: ‘future_mapply-1’
[16:03:36.509] Expression:
[16:03:36.509] {
[16:03:36.509]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:36.509]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:36.509]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:36.509]         on.exit(options(oopts), add = TRUE)
[16:03:36.509]     }
[16:03:36.509]     {
[16:03:36.509]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:36.509]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:03:36.509]         do.call(mapply, args = args)
[16:03:36.509]     }
[16:03:36.509] }
[16:03:36.509] Lazy evaluation: FALSE
[16:03:36.509] Asynchronous evaluation: FALSE
[16:03:36.509] Local evaluation: TRUE
[16:03:36.509] Environment: R_GlobalEnv
[16:03:36.509] Capture standard output: TRUE
[16:03:36.509] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:36.509] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:36.509] Packages: <none>
[16:03:36.509] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:36.509] Resolved: TRUE
[16:03:36.509] Value: 224 bytes of class ‘list’
[16:03:36.509] Early signaling: FALSE
[16:03:36.509] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:36.509] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:36.510] Chunk #1 of 1 ... DONE
[16:03:36.510] Launching 1 futures (chunks) ... DONE
[16:03:36.510] Resolving 1 futures (chunks) ...
[16:03:36.510] resolve() on list ...
[16:03:36.510]  recursive: 0
[16:03:36.510]  length: 1
[16:03:36.510] 
[16:03:36.511] resolved() for ‘SequentialFuture’ ...
[16:03:36.511] - state: ‘finished’
[16:03:36.511] - run: TRUE
[16:03:36.511] - result: ‘FutureResult’
[16:03:36.511] resolved() for ‘SequentialFuture’ ... done
[16:03:36.511] Future #1
[16:03:36.511] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:36.511] - nx: 1
[16:03:36.511] - relay: TRUE
[16:03:36.511] - stdout: TRUE
[16:03:36.512] - signal: TRUE
[16:03:36.512] - resignal: FALSE
[16:03:36.512] - force: TRUE
[16:03:36.512] - relayed: [n=1] FALSE
[16:03:36.512] - queued futures: [n=1] FALSE
[16:03:36.512]  - until=1
[16:03:36.512]  - relaying element #1
[16:03:36.512] - relayed: [n=1] TRUE
[16:03:36.512] - queued futures: [n=1] TRUE
[16:03:36.512] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:36.513]  length: 0 (resolved future 1)
[16:03:36.513] Relaying remaining futures
[16:03:36.513] signalConditionsASAP(NULL, pos=0) ...
[16:03:36.513] - nx: 1
[16:03:36.513] - relay: TRUE
[16:03:36.513] - stdout: TRUE
[16:03:36.513] - signal: TRUE
[16:03:36.513] - resignal: FALSE
[16:03:36.513] - force: TRUE
[16:03:36.513] - relayed: [n=1] TRUE
[16:03:36.513] - queued futures: [n=1] TRUE
 - flush all
[16:03:36.514] - relayed: [n=1] TRUE
[16:03:36.514] - queued futures: [n=1] TRUE
[16:03:36.514] signalConditionsASAP(NULL, pos=0) ... done
[16:03:36.514] resolve() on list ... DONE
[16:03:36.514]  - Number of value chunks collected: 1
[16:03:36.514] Resolving 1 futures (chunks) ... DONE
[16:03:36.514] Reducing values from 1 chunks ...
[16:03:36.514]  - Number of values collected after concatenation: 2
[16:03:36.514]  - Number of values expected: 2
[16:03:36.514] Reducing values from 1 chunks ... DONE
[16:03:36.515] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[16:03:36.515] future_mapply() ...
[16:03:36.518] Number of chunks: 1
[16:03:36.518] getGlobalsAndPackagesXApply() ...
[16:03:36.518]  - future.globals: TRUE
[16:03:36.518] getGlobalsAndPackages() ...
[16:03:36.518] Searching for globals...
[16:03:36.520] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:03:36.520] Searching for globals ... DONE
[16:03:36.520] Resolving globals: FALSE
[16:03:36.521] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:03:36.521] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:03:36.521] - globals: [1] ‘FUN’
[16:03:36.521] 
[16:03:36.521] getGlobalsAndPackages() ... DONE
[16:03:36.521]  - globals found/used: [n=1] ‘FUN’
[16:03:36.521]  - needed namespaces: [n=0] 
[16:03:36.522] Finding globals ... DONE
[16:03:36.522] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:03:36.522] List of 2
[16:03:36.522]  $ ...future.FUN:function (x, y)  
[16:03:36.522]  $ MoreArgs     : NULL
[16:03:36.522]  - attr(*, "where")=List of 2
[16:03:36.522]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:36.522]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:03:36.522]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:36.522]  - attr(*, "resolved")= logi FALSE
[16:03:36.522]  - attr(*, "total_size")= num NA
[16:03:36.524] Packages to be attached in all futures: [n=0] 
[16:03:36.524] getGlobalsAndPackagesXApply() ... DONE
[16:03:36.525] Number of futures (= number of chunks): 1
[16:03:36.525] Launching 1 futures (chunks) ...
[16:03:36.525] Chunk #1 of 1 ...
[16:03:36.525]  - Finding globals in '...' for chunk #1 ...
[16:03:36.525] getGlobalsAndPackages() ...
[16:03:36.525] Searching for globals...
[16:03:36.525] 
[16:03:36.526] Searching for globals ... DONE
[16:03:36.526] - globals: [0] <none>
[16:03:36.526] getGlobalsAndPackages() ... DONE
[16:03:36.526]    + additional globals found: [n=0] 
[16:03:36.526]    + additional namespaces needed: [n=0] 
[16:03:36.526]  - Finding globals in '...' for chunk #1 ... DONE
[16:03:36.526]  - seeds: <none>
[16:03:36.526]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:36.526] getGlobalsAndPackages() ...
[16:03:36.526] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:36.527] Resolving globals: FALSE
[16:03:36.527] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[16:03:36.527] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:03:36.528] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:36.528] 
[16:03:36.528] getGlobalsAndPackages() ... DONE
[16:03:36.528] run() for ‘Future’ ...
[16:03:36.528] - state: ‘created’
[16:03:36.528] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:36.532] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:36.532] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:03:36.532]   - Field: ‘label’
[16:03:36.532]   - Field: ‘local’
[16:03:36.532]   - Field: ‘owner’
[16:03:36.532]   - Field: ‘envir’
[16:03:36.532]   - Field: ‘packages’
[16:03:36.532]   - Field: ‘gc’
[16:03:36.532]   - Field: ‘conditions’
[16:03:36.533]   - Field: ‘expr’
[16:03:36.533]   - Field: ‘uuid’
[16:03:36.533]   - Field: ‘seed’
[16:03:36.533]   - Field: ‘version’
[16:03:36.533]   - Field: ‘result’
[16:03:36.533]   - Field: ‘asynchronous’
[16:03:36.533]   - Field: ‘calls’
[16:03:36.533]   - Field: ‘globals’
[16:03:36.533]   - Field: ‘stdout’
[16:03:36.533]   - Field: ‘earlySignal’
[16:03:36.534]   - Field: ‘lazy’
[16:03:36.534]   - Field: ‘state’
[16:03:36.534] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:03:36.534] - Launch lazy future ...
[16:03:36.534] Packages needed by the future expression (n = 0): <none>
[16:03:36.534] Packages needed by future strategies (n = 0): <none>
[16:03:36.535] {
[16:03:36.535]     {
[16:03:36.535]         {
[16:03:36.535]             ...future.startTime <- base::Sys.time()
[16:03:36.535]             {
[16:03:36.535]                 {
[16:03:36.535]                   {
[16:03:36.535]                     base::local({
[16:03:36.535]                       has_future <- base::requireNamespace("future", 
[16:03:36.535]                         quietly = TRUE)
[16:03:36.535]                       if (has_future) {
[16:03:36.535]                         ns <- base::getNamespace("future")
[16:03:36.535]                         version <- ns[[".package"]][["version"]]
[16:03:36.535]                         if (is.null(version)) 
[16:03:36.535]                           version <- utils::packageVersion("future")
[16:03:36.535]                       }
[16:03:36.535]                       else {
[16:03:36.535]                         version <- NULL
[16:03:36.535]                       }
[16:03:36.535]                       if (!has_future || version < "1.8.0") {
[16:03:36.535]                         info <- base::c(r_version = base::gsub("R version ", 
[16:03:36.535]                           "", base::R.version$version.string), 
[16:03:36.535]                           platform = base::sprintf("%s (%s-bit)", 
[16:03:36.535]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:36.535]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:36.535]                             "release", "version")], collapse = " "), 
[16:03:36.535]                           hostname = base::Sys.info()[["nodename"]])
[16:03:36.535]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:03:36.535]                           info)
[16:03:36.535]                         info <- base::paste(info, collapse = "; ")
[16:03:36.535]                         if (!has_future) {
[16:03:36.535]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:36.535]                             info)
[16:03:36.535]                         }
[16:03:36.535]                         else {
[16:03:36.535]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:36.535]                             info, version)
[16:03:36.535]                         }
[16:03:36.535]                         base::stop(msg)
[16:03:36.535]                       }
[16:03:36.535]                     })
[16:03:36.535]                   }
[16:03:36.535]                   options(future.plan = NULL)
[16:03:36.535]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:36.535]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:36.535]                 }
[16:03:36.535]                 ...future.workdir <- getwd()
[16:03:36.535]             }
[16:03:36.535]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:36.535]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:36.535]         }
[16:03:36.535]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:36.535]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:36.535]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:36.535]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:36.535]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:36.535]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:36.535]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:36.535]             base::names(...future.oldOptions))
[16:03:36.535]     }
[16:03:36.535]     if (TRUE) {
[16:03:36.535]     }
[16:03:36.535]     else {
[16:03:36.535]         if (NA) {
[16:03:36.535]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:36.535]                 open = "w")
[16:03:36.535]         }
[16:03:36.535]         else {
[16:03:36.535]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:36.535]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:36.535]         }
[16:03:36.535]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:36.535]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:36.535]             base::sink(type = "output", split = FALSE)
[16:03:36.535]             base::close(...future.stdout)
[16:03:36.535]         }, add = TRUE)
[16:03:36.535]     }
[16:03:36.535]     ...future.frame <- base::sys.nframe()
[16:03:36.535]     ...future.conditions <- base::list()
[16:03:36.535]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:36.535]     if (FALSE) {
[16:03:36.535]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:36.535]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:36.535]     }
[16:03:36.535]     ...future.result <- base::tryCatch({
[16:03:36.535]         base::withCallingHandlers({
[16:03:36.535]             ...future.value <- base::withVisible(base::local({
[16:03:36.535]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:36.535]                 if (!identical(...future.globals.maxSize.org, 
[16:03:36.535]                   ...future.globals.maxSize)) {
[16:03:36.535]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:36.535]                   on.exit(options(oopts), add = TRUE)
[16:03:36.535]                 }
[16:03:36.535]                 {
[16:03:36.535]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:36.535]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:03:36.535]                     USE.NAMES = FALSE)
[16:03:36.535]                   do.call(mapply, args = args)
[16:03:36.535]                 }
[16:03:36.535]             }))
[16:03:36.535]             future::FutureResult(value = ...future.value$value, 
[16:03:36.535]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:36.535]                   ...future.rng), globalenv = if (FALSE) 
[16:03:36.535]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:36.535]                     ...future.globalenv.names))
[16:03:36.535]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:36.535]         }, condition = base::local({
[16:03:36.535]             c <- base::c
[16:03:36.535]             inherits <- base::inherits
[16:03:36.535]             invokeRestart <- base::invokeRestart
[16:03:36.535]             length <- base::length
[16:03:36.535]             list <- base::list
[16:03:36.535]             seq.int <- base::seq.int
[16:03:36.535]             signalCondition <- base::signalCondition
[16:03:36.535]             sys.calls <- base::sys.calls
[16:03:36.535]             `[[` <- base::`[[`
[16:03:36.535]             `+` <- base::`+`
[16:03:36.535]             `<<-` <- base::`<<-`
[16:03:36.535]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:36.535]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:36.535]                   3L)]
[16:03:36.535]             }
[16:03:36.535]             function(cond) {
[16:03:36.535]                 is_error <- inherits(cond, "error")
[16:03:36.535]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:36.535]                   NULL)
[16:03:36.535]                 if (is_error) {
[16:03:36.535]                   sessionInformation <- function() {
[16:03:36.535]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:36.535]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:36.535]                       search = base::search(), system = base::Sys.info())
[16:03:36.535]                   }
[16:03:36.535]                   ...future.conditions[[length(...future.conditions) + 
[16:03:36.535]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:36.535]                     cond$call), session = sessionInformation(), 
[16:03:36.535]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:36.535]                   signalCondition(cond)
[16:03:36.535]                 }
[16:03:36.535]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:36.535]                 "immediateCondition"))) {
[16:03:36.535]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:36.535]                   ...future.conditions[[length(...future.conditions) + 
[16:03:36.535]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:36.535]                   if (TRUE && !signal) {
[16:03:36.535]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:36.535]                     {
[16:03:36.535]                       inherits <- base::inherits
[16:03:36.535]                       invokeRestart <- base::invokeRestart
[16:03:36.535]                       is.null <- base::is.null
[16:03:36.535]                       muffled <- FALSE
[16:03:36.535]                       if (inherits(cond, "message")) {
[16:03:36.535]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:36.535]                         if (muffled) 
[16:03:36.535]                           invokeRestart("muffleMessage")
[16:03:36.535]                       }
[16:03:36.535]                       else if (inherits(cond, "warning")) {
[16:03:36.535]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:36.535]                         if (muffled) 
[16:03:36.535]                           invokeRestart("muffleWarning")
[16:03:36.535]                       }
[16:03:36.535]                       else if (inherits(cond, "condition")) {
[16:03:36.535]                         if (!is.null(pattern)) {
[16:03:36.535]                           computeRestarts <- base::computeRestarts
[16:03:36.535]                           grepl <- base::grepl
[16:03:36.535]                           restarts <- computeRestarts(cond)
[16:03:36.535]                           for (restart in restarts) {
[16:03:36.535]                             name <- restart$name
[16:03:36.535]                             if (is.null(name)) 
[16:03:36.535]                               next
[16:03:36.535]                             if (!grepl(pattern, name)) 
[16:03:36.535]                               next
[16:03:36.535]                             invokeRestart(restart)
[16:03:36.535]                             muffled <- TRUE
[16:03:36.535]                             break
[16:03:36.535]                           }
[16:03:36.535]                         }
[16:03:36.535]                       }
[16:03:36.535]                       invisible(muffled)
[16:03:36.535]                     }
[16:03:36.535]                     muffleCondition(cond, pattern = "^muffle")
[16:03:36.535]                   }
[16:03:36.535]                 }
[16:03:36.535]                 else {
[16:03:36.535]                   if (TRUE) {
[16:03:36.535]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:36.535]                     {
[16:03:36.535]                       inherits <- base::inherits
[16:03:36.535]                       invokeRestart <- base::invokeRestart
[16:03:36.535]                       is.null <- base::is.null
[16:03:36.535]                       muffled <- FALSE
[16:03:36.535]                       if (inherits(cond, "message")) {
[16:03:36.535]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:36.535]                         if (muffled) 
[16:03:36.535]                           invokeRestart("muffleMessage")
[16:03:36.535]                       }
[16:03:36.535]                       else if (inherits(cond, "warning")) {
[16:03:36.535]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:36.535]                         if (muffled) 
[16:03:36.535]                           invokeRestart("muffleWarning")
[16:03:36.535]                       }
[16:03:36.535]                       else if (inherits(cond, "condition")) {
[16:03:36.535]                         if (!is.null(pattern)) {
[16:03:36.535]                           computeRestarts <- base::computeRestarts
[16:03:36.535]                           grepl <- base::grepl
[16:03:36.535]                           restarts <- computeRestarts(cond)
[16:03:36.535]                           for (restart in restarts) {
[16:03:36.535]                             name <- restart$name
[16:03:36.535]                             if (is.null(name)) 
[16:03:36.535]                               next
[16:03:36.535]                             if (!grepl(pattern, name)) 
[16:03:36.535]                               next
[16:03:36.535]                             invokeRestart(restart)
[16:03:36.535]                             muffled <- TRUE
[16:03:36.535]                             break
[16:03:36.535]                           }
[16:03:36.535]                         }
[16:03:36.535]                       }
[16:03:36.535]                       invisible(muffled)
[16:03:36.535]                     }
[16:03:36.535]                     muffleCondition(cond, pattern = "^muffle")
[16:03:36.535]                   }
[16:03:36.535]                 }
[16:03:36.535]             }
[16:03:36.535]         }))
[16:03:36.535]     }, error = function(ex) {
[16:03:36.535]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:36.535]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:36.535]                 ...future.rng), started = ...future.startTime, 
[16:03:36.535]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:36.535]             version = "1.8"), class = "FutureResult")
[16:03:36.535]     }, finally = {
[16:03:36.535]         if (!identical(...future.workdir, getwd())) 
[16:03:36.535]             setwd(...future.workdir)
[16:03:36.535]         {
[16:03:36.535]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:36.535]                 ...future.oldOptions$nwarnings <- NULL
[16:03:36.535]             }
[16:03:36.535]             base::options(...future.oldOptions)
[16:03:36.535]             if (.Platform$OS.type == "windows") {
[16:03:36.535]                 old_names <- names(...future.oldEnvVars)
[16:03:36.535]                 envs <- base::Sys.getenv()
[16:03:36.535]                 names <- names(envs)
[16:03:36.535]                 common <- intersect(names, old_names)
[16:03:36.535]                 added <- setdiff(names, old_names)
[16:03:36.535]                 removed <- setdiff(old_names, names)
[16:03:36.535]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:36.535]                   envs[common]]
[16:03:36.535]                 NAMES <- toupper(changed)
[16:03:36.535]                 args <- list()
[16:03:36.535]                 for (kk in seq_along(NAMES)) {
[16:03:36.535]                   name <- changed[[kk]]
[16:03:36.535]                   NAME <- NAMES[[kk]]
[16:03:36.535]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:36.535]                     next
[16:03:36.535]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:36.535]                 }
[16:03:36.535]                 NAMES <- toupper(added)
[16:03:36.535]                 for (kk in seq_along(NAMES)) {
[16:03:36.535]                   name <- added[[kk]]
[16:03:36.535]                   NAME <- NAMES[[kk]]
[16:03:36.535]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:36.535]                     next
[16:03:36.535]                   args[[name]] <- ""
[16:03:36.535]                 }
[16:03:36.535]                 NAMES <- toupper(removed)
[16:03:36.535]                 for (kk in seq_along(NAMES)) {
[16:03:36.535]                   name <- removed[[kk]]
[16:03:36.535]                   NAME <- NAMES[[kk]]
[16:03:36.535]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:36.535]                     next
[16:03:36.535]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:36.535]                 }
[16:03:36.535]                 if (length(args) > 0) 
[16:03:36.535]                   base::do.call(base::Sys.setenv, args = args)
[16:03:36.535]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:36.535]             }
[16:03:36.535]             else {
[16:03:36.535]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:36.535]             }
[16:03:36.535]             {
[16:03:36.535]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:36.535]                   0L) {
[16:03:36.535]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:36.535]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:36.535]                   base::options(opts)
[16:03:36.535]                 }
[16:03:36.535]                 {
[16:03:36.535]                   {
[16:03:36.535]                     NULL
[16:03:36.535]                     RNGkind("Mersenne-Twister")
[16:03:36.535]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:03:36.535]                       inherits = FALSE)
[16:03:36.535]                   }
[16:03:36.535]                   options(future.plan = NULL)
[16:03:36.535]                   if (is.na(NA_character_)) 
[16:03:36.535]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:36.535]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:36.535]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:36.535]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:36.535]                     envir = parent.frame()) 
[16:03:36.535]                   {
[16:03:36.535]                     if (is.function(workers)) 
[16:03:36.535]                       workers <- workers()
[16:03:36.535]                     workers <- structure(as.integer(workers), 
[16:03:36.535]                       class = class(workers))
[16:03:36.535]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:36.535]                       workers >= 1)
[16:03:36.535]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:36.535]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:36.535]                     }
[16:03:36.535]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:36.535]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:36.535]                       envir = envir)
[16:03:36.535]                     if (!future$lazy) 
[16:03:36.535]                       future <- run(future)
[16:03:36.535]                     invisible(future)
[16:03:36.535]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:36.535]                 }
[16:03:36.535]             }
[16:03:36.535]         }
[16:03:36.535]     })
[16:03:36.535]     if (FALSE) {
[16:03:36.535]         base::sink(type = "output", split = FALSE)
[16:03:36.535]         if (NA) {
[16:03:36.535]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:36.535]         }
[16:03:36.535]         else {
[16:03:36.535]             ...future.result["stdout"] <- base::list(NULL)
[16:03:36.535]         }
[16:03:36.535]         base::close(...future.stdout)
[16:03:36.535]         ...future.stdout <- NULL
[16:03:36.535]     }
[16:03:36.535]     ...future.result$conditions <- ...future.conditions
[16:03:36.535]     ...future.result$finished <- base::Sys.time()
[16:03:36.535]     ...future.result
[16:03:36.535] }
[16:03:36.536] assign_globals() ...
[16:03:36.536] List of 5
[16:03:36.536]  $ ...future.FUN            :function (x, y)  
[16:03:36.536]  $ MoreArgs                 : NULL
[16:03:36.536]  $ ...future.elements_ii    :List of 2
[16:03:36.536]   ..$ :List of 2
[16:03:36.536]   .. ..$ : int 1
[16:03:36.536]   .. ..$ : int 0
[16:03:36.536]   ..$ :List of 2
[16:03:36.536]   .. ..$ : int 0
[16:03:36.536]   .. ..$ : int 1
[16:03:36.536]  $ ...future.seeds_ii       : NULL
[16:03:36.536]  $ ...future.globals.maxSize: NULL
[16:03:36.536]  - attr(*, "where")=List of 5
[16:03:36.536]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:36.536]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:03:36.536]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:36.536]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:36.536]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:36.536]  - attr(*, "resolved")= logi FALSE
[16:03:36.536]  - attr(*, "total_size")= num 6480
[16:03:36.536]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:36.536]  - attr(*, "already-done")= logi TRUE
[16:03:36.544] - reassign environment for ‘...future.FUN’
[16:03:36.544] - copied ‘...future.FUN’ to environment
[16:03:36.544] - copied ‘MoreArgs’ to environment
[16:03:36.544] - copied ‘...future.elements_ii’ to environment
[16:03:36.544] - copied ‘...future.seeds_ii’ to environment
[16:03:36.544] - copied ‘...future.globals.maxSize’ to environment
[16:03:36.544] assign_globals() ... done
[16:03:36.545] plan(): Setting new future strategy stack:
[16:03:36.545] List of future strategies:
[16:03:36.545] 1. sequential:
[16:03:36.545]    - args: function (..., envir = parent.frame())
[16:03:36.545]    - tweaked: FALSE
[16:03:36.545]    - call: NULL
[16:03:36.545] plan(): nbrOfWorkers() = 1
[16:03:37.047] plan(): Setting new future strategy stack:
[16:03:37.047] List of future strategies:
[16:03:37.047] 1. multisession:
[16:03:37.047]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:03:37.047]    - tweaked: FALSE
[16:03:37.047]    - call: plan(strategy)
[16:03:37.051] plan(): nbrOfWorkers() = 1
[16:03:37.051] SequentialFuture started (and completed)
[16:03:37.051] - Launch lazy future ... done
[16:03:37.051] run() for ‘SequentialFuture’ ... done
[16:03:37.051] Created future:
[16:03:37.051] SequentialFuture:
[16:03:37.051] Label: ‘future_mapply-1’
[16:03:37.051] Expression:
[16:03:37.051] {
[16:03:37.051]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:37.051]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:37.051]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:37.051]         on.exit(options(oopts), add = TRUE)
[16:03:37.051]     }
[16:03:37.051]     {
[16:03:37.051]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:37.051]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:03:37.051]         do.call(mapply, args = args)
[16:03:37.051]     }
[16:03:37.051] }
[16:03:37.051] Lazy evaluation: FALSE
[16:03:37.051] Asynchronous evaluation: FALSE
[16:03:37.051] Local evaluation: TRUE
[16:03:37.051] Environment: R_GlobalEnv
[16:03:37.051] Capture standard output: NA
[16:03:37.051] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:37.051] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:37.051] Packages: <none>
[16:03:37.051] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:37.051] Resolved: TRUE
[16:03:37.051] Value: 224 bytes of class ‘list’
[16:03:37.051] Early signaling: FALSE
[16:03:37.051] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:37.051] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:03:37.052] Chunk #1 of 1 ... DONE
[16:03:37.053] Launching 1 futures (chunks) ... DONE
[16:03:37.053] Resolving 1 futures (chunks) ...
[16:03:37.053] resolve() on list ...
[16:03:37.053]  recursive: 0
[16:03:37.053]  length: 1
[16:03:37.053] 
[16:03:37.053] resolved() for ‘SequentialFuture’ ...
[16:03:37.053] - state: ‘finished’
[16:03:37.053] - run: TRUE
[16:03:37.053] - result: ‘FutureResult’
[16:03:37.054] resolved() for ‘SequentialFuture’ ... done
[16:03:37.054] Future #1
[16:03:37.054] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:03:37.054] - nx: 1
[16:03:37.054] - relay: TRUE
[16:03:37.054] - stdout: TRUE
[16:03:37.054] - signal: TRUE
[16:03:37.054] - resignal: FALSE
[16:03:37.054] - force: TRUE
[16:03:37.054] - relayed: [n=1] FALSE
[16:03:37.054] - queued futures: [n=1] FALSE
[16:03:37.055]  - until=1
[16:03:37.055]  - relaying element #1
[16:03:37.055] - relayed: [n=1] TRUE
[16:03:37.055] - queued futures: [n=1] TRUE
[16:03:37.055] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:03:37.055]  length: 0 (resolved future 1)
[16:03:37.055] Relaying remaining futures
[16:03:37.055] signalConditionsASAP(NULL, pos=0) ...
[16:03:37.055] - nx: 1
[16:03:37.055] - relay: TRUE
[16:03:37.056] - stdout: TRUE
[16:03:37.056] - signal: TRUE
[16:03:37.056] - resignal: FALSE
[16:03:37.056] - force: TRUE
[16:03:37.056] - relayed: [n=1] TRUE
[16:03:37.056] - queued futures: [n=1] TRUE
 - flush all
[16:03:37.056] - relayed: [n=1] TRUE
[16:03:37.056] - queued futures: [n=1] TRUE
[16:03:37.056] signalConditionsASAP(NULL, pos=0) ... done
[16:03:37.056] resolve() on list ... DONE
[16:03:37.057]  - Number of value chunks collected: 1
[16:03:37.057] Resolving 1 futures (chunks) ... DONE
[16:03:37.057] Reducing values from 1 chunks ...
[16:03:37.057]  - Number of values collected after concatenation: 2
[16:03:37.057]  - Number of values expected: 2
[16:03:37.057] Reducing values from 1 chunks ... DONE
[16:03:37.057] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 1 cores ... DONE
  - Testing with 2 cores ...
* plan('multicore') ...
[16:03:37.061] plan(): Setting new future strategy stack:
[16:03:37.061] List of future strategies:
[16:03:37.061] 1. multicore:
[16:03:37.061]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:37.061]    - tweaked: FALSE
[16:03:37.061]    - call: plan(strategy)
[16:03:37.065] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[16:03:37.065] future_lapply() ...
[16:03:37.072] Number of chunks: 2
[16:03:37.072] getGlobalsAndPackagesXApply() ...
[16:03:37.072]  - future.globals: TRUE
[16:03:37.072] getGlobalsAndPackages() ...
[16:03:37.072] Searching for globals...
[16:03:37.074] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:03:37.074] Searching for globals ... DONE
[16:03:37.074] Resolving globals: FALSE
[16:03:37.075] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:03:37.075] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:03:37.075] - globals: [1] ‘FUN’
[16:03:37.075] 
[16:03:37.075] getGlobalsAndPackages() ... DONE
[16:03:37.075]  - globals found/used: [n=1] ‘FUN’
[16:03:37.076]  - needed namespaces: [n=0] 
[16:03:37.076] Finding globals ... DONE
[16:03:37.076]  - use_args: TRUE
[16:03:37.076]  - Getting '...' globals ...
[16:03:37.076] resolve() on list ...
[16:03:37.076]  recursive: 0
[16:03:37.076]  length: 1
[16:03:37.076]  elements: ‘...’
[16:03:37.077]  length: 0 (resolved future 1)
[16:03:37.077] resolve() on list ... DONE
[16:03:37.077]    - '...' content: [n=0] 
[16:03:37.077] List of 1
[16:03:37.077]  $ ...: list()
[16:03:37.077]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:37.077]  - attr(*, "where")=List of 1
[16:03:37.077]   ..$ ...:<environment: 0x55ed7aa53a58> 
[16:03:37.077]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:37.077]  - attr(*, "resolved")= logi TRUE
[16:03:37.077]  - attr(*, "total_size")= num NA
[16:03:37.079]  - Getting '...' globals ... DONE
[16:03:37.080] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:03:37.080] List of 2
[16:03:37.080]  $ ...future.FUN:function (x)  
[16:03:37.080]  $ ...          : list()
[16:03:37.080]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:37.080]  - attr(*, "where")=List of 2
[16:03:37.080]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:37.080]   ..$ ...          :<environment: 0x55ed7aa53a58> 
[16:03:37.080]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:37.080]  - attr(*, "resolved")= logi FALSE
[16:03:37.080]  - attr(*, "total_size")= num 4720
[16:03:37.082] Packages to be attached in all futures: [n=0] 
[16:03:37.082] getGlobalsAndPackagesXApply() ... DONE
[16:03:37.083] Number of futures (= number of chunks): 2
[16:03:37.083] Launching 2 futures (chunks) ...
[16:03:37.083] Chunk #1 of 2 ...
[16:03:37.083]  - Finding globals in 'X' for chunk #1 ...
[16:03:37.083] getGlobalsAndPackages() ...
[16:03:37.083] Searching for globals...
[16:03:37.083] 
[16:03:37.083] Searching for globals ... DONE
[16:03:37.084] - globals: [0] <none>
[16:03:37.084] getGlobalsAndPackages() ... DONE
[16:03:37.084]    + additional globals found: [n=0] 
[16:03:37.084]    + additional namespaces needed: [n=0] 
[16:03:37.084]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:37.084]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:37.084]  - seeds: <none>
[16:03:37.084]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:37.084] getGlobalsAndPackages() ...
[16:03:37.084] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:37.084] Resolving globals: FALSE
[16:03:37.085] Tweak future expression to call with '...' arguments ...
[16:03:37.085] {
[16:03:37.085]     do.call(function(...) {
[16:03:37.085]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:37.085]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:37.085]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:37.085]             on.exit(options(oopts), add = TRUE)
[16:03:37.085]         }
[16:03:37.085]         {
[16:03:37.085]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:37.085]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:37.085]                 ...future.FUN(...future.X_jj, ...)
[16:03:37.085]             })
[16:03:37.085]         }
[16:03:37.085]     }, args = future.call.arguments)
[16:03:37.085] }
[16:03:37.085] Tweak future expression to call with '...' arguments ... DONE
[16:03:37.085] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:37.085] 
[16:03:37.086] getGlobalsAndPackages() ... DONE
[16:03:37.086] run() for ‘Future’ ...
[16:03:37.086] - state: ‘created’
[16:03:37.086] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:37.090] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:37.090] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:37.090]   - Field: ‘label’
[16:03:37.090]   - Field: ‘local’
[16:03:37.090]   - Field: ‘owner’
[16:03:37.090]   - Field: ‘envir’
[16:03:37.090]   - Field: ‘workers’
[16:03:37.091]   - Field: ‘packages’
[16:03:37.091]   - Field: ‘gc’
[16:03:37.091]   - Field: ‘job’
[16:03:37.091]   - Field: ‘conditions’
[16:03:37.091]   - Field: ‘expr’
[16:03:37.091]   - Field: ‘uuid’
[16:03:37.091]   - Field: ‘seed’
[16:03:37.091]   - Field: ‘version’
[16:03:37.091]   - Field: ‘result’
[16:03:37.091]   - Field: ‘asynchronous’
[16:03:37.092]   - Field: ‘calls’
[16:03:37.092]   - Field: ‘globals’
[16:03:37.092]   - Field: ‘stdout’
[16:03:37.092]   - Field: ‘earlySignal’
[16:03:37.092]   - Field: ‘lazy’
[16:03:37.092]   - Field: ‘state’
[16:03:37.092] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:37.092] - Launch lazy future ...
[16:03:37.093] Packages needed by the future expression (n = 0): <none>
[16:03:37.093] Packages needed by future strategies (n = 0): <none>
[16:03:37.094] {
[16:03:37.094]     {
[16:03:37.094]         {
[16:03:37.094]             ...future.startTime <- base::Sys.time()
[16:03:37.094]             {
[16:03:37.094]                 {
[16:03:37.094]                   {
[16:03:37.094]                     {
[16:03:37.094]                       base::local({
[16:03:37.094]                         has_future <- base::requireNamespace("future", 
[16:03:37.094]                           quietly = TRUE)
[16:03:37.094]                         if (has_future) {
[16:03:37.094]                           ns <- base::getNamespace("future")
[16:03:37.094]                           version <- ns[[".package"]][["version"]]
[16:03:37.094]                           if (is.null(version)) 
[16:03:37.094]                             version <- utils::packageVersion("future")
[16:03:37.094]                         }
[16:03:37.094]                         else {
[16:03:37.094]                           version <- NULL
[16:03:37.094]                         }
[16:03:37.094]                         if (!has_future || version < "1.8.0") {
[16:03:37.094]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:37.094]                             "", base::R.version$version.string), 
[16:03:37.094]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:37.094]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:37.094]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:37.094]                               "release", "version")], collapse = " "), 
[16:03:37.094]                             hostname = base::Sys.info()[["nodename"]])
[16:03:37.094]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:37.094]                             info)
[16:03:37.094]                           info <- base::paste(info, collapse = "; ")
[16:03:37.094]                           if (!has_future) {
[16:03:37.094]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:37.094]                               info)
[16:03:37.094]                           }
[16:03:37.094]                           else {
[16:03:37.094]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:37.094]                               info, version)
[16:03:37.094]                           }
[16:03:37.094]                           base::stop(msg)
[16:03:37.094]                         }
[16:03:37.094]                       })
[16:03:37.094]                     }
[16:03:37.094]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:37.094]                     base::options(mc.cores = 1L)
[16:03:37.094]                   }
[16:03:37.094]                   options(future.plan = NULL)
[16:03:37.094]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:37.094]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:37.094]                 }
[16:03:37.094]                 ...future.workdir <- getwd()
[16:03:37.094]             }
[16:03:37.094]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:37.094]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:37.094]         }
[16:03:37.094]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:37.094]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:37.094]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:37.094]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:37.094]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:37.094]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:37.094]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:37.094]             base::names(...future.oldOptions))
[16:03:37.094]     }
[16:03:37.094]     if (FALSE) {
[16:03:37.094]     }
[16:03:37.094]     else {
[16:03:37.094]         if (FALSE) {
[16:03:37.094]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:37.094]                 open = "w")
[16:03:37.094]         }
[16:03:37.094]         else {
[16:03:37.094]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:37.094]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:37.094]         }
[16:03:37.094]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:37.094]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:37.094]             base::sink(type = "output", split = FALSE)
[16:03:37.094]             base::close(...future.stdout)
[16:03:37.094]         }, add = TRUE)
[16:03:37.094]     }
[16:03:37.094]     ...future.frame <- base::sys.nframe()
[16:03:37.094]     ...future.conditions <- base::list()
[16:03:37.094]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:37.094]     if (FALSE) {
[16:03:37.094]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:37.094]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:37.094]     }
[16:03:37.094]     ...future.result <- base::tryCatch({
[16:03:37.094]         base::withCallingHandlers({
[16:03:37.094]             ...future.value <- base::withVisible(base::local({
[16:03:37.094]                 withCallingHandlers({
[16:03:37.094]                   {
[16:03:37.094]                     do.call(function(...) {
[16:03:37.094]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:37.094]                       if (!identical(...future.globals.maxSize.org, 
[16:03:37.094]                         ...future.globals.maxSize)) {
[16:03:37.094]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:37.094]                         on.exit(options(oopts), add = TRUE)
[16:03:37.094]                       }
[16:03:37.094]                       {
[16:03:37.094]                         lapply(seq_along(...future.elements_ii), 
[16:03:37.094]                           FUN = function(jj) {
[16:03:37.094]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:37.094]                             ...future.FUN(...future.X_jj, ...)
[16:03:37.094]                           })
[16:03:37.094]                       }
[16:03:37.094]                     }, args = future.call.arguments)
[16:03:37.094]                   }
[16:03:37.094]                 }, immediateCondition = function(cond) {
[16:03:37.094]                   save_rds <- function (object, pathname, ...) 
[16:03:37.094]                   {
[16:03:37.094]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:37.094]                     if (file_test("-f", pathname_tmp)) {
[16:03:37.094]                       fi_tmp <- file.info(pathname_tmp)
[16:03:37.094]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:37.094]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:37.094]                         fi_tmp[["mtime"]])
[16:03:37.094]                     }
[16:03:37.094]                     tryCatch({
[16:03:37.094]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:37.094]                     }, error = function(ex) {
[16:03:37.094]                       msg <- conditionMessage(ex)
[16:03:37.094]                       fi_tmp <- file.info(pathname_tmp)
[16:03:37.094]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:37.094]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:37.094]                         fi_tmp[["mtime"]], msg)
[16:03:37.094]                       ex$message <- msg
[16:03:37.094]                       stop(ex)
[16:03:37.094]                     })
[16:03:37.094]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:37.094]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:37.094]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:37.094]                       fi_tmp <- file.info(pathname_tmp)
[16:03:37.094]                       fi <- file.info(pathname)
[16:03:37.094]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:37.094]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:37.094]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:37.094]                         fi[["size"]], fi[["mtime"]])
[16:03:37.094]                       stop(msg)
[16:03:37.094]                     }
[16:03:37.094]                     invisible(pathname)
[16:03:37.094]                   }
[16:03:37.094]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:37.094]                     rootPath = tempdir()) 
[16:03:37.094]                   {
[16:03:37.094]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:37.094]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:37.094]                       tmpdir = path, fileext = ".rds")
[16:03:37.094]                     save_rds(obj, file)
[16:03:37.094]                   }
[16:03:37.094]                   saveImmediateCondition(cond, path = "/tmp/Rtmpi1Xc62/.future/immediateConditions")
[16:03:37.094]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:37.094]                   {
[16:03:37.094]                     inherits <- base::inherits
[16:03:37.094]                     invokeRestart <- base::invokeRestart
[16:03:37.094]                     is.null <- base::is.null
[16:03:37.094]                     muffled <- FALSE
[16:03:37.094]                     if (inherits(cond, "message")) {
[16:03:37.094]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:37.094]                       if (muffled) 
[16:03:37.094]                         invokeRestart("muffleMessage")
[16:03:37.094]                     }
[16:03:37.094]                     else if (inherits(cond, "warning")) {
[16:03:37.094]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:37.094]                       if (muffled) 
[16:03:37.094]                         invokeRestart("muffleWarning")
[16:03:37.094]                     }
[16:03:37.094]                     else if (inherits(cond, "condition")) {
[16:03:37.094]                       if (!is.null(pattern)) {
[16:03:37.094]                         computeRestarts <- base::computeRestarts
[16:03:37.094]                         grepl <- base::grepl
[16:03:37.094]                         restarts <- computeRestarts(cond)
[16:03:37.094]                         for (restart in restarts) {
[16:03:37.094]                           name <- restart$name
[16:03:37.094]                           if (is.null(name)) 
[16:03:37.094]                             next
[16:03:37.094]                           if (!grepl(pattern, name)) 
[16:03:37.094]                             next
[16:03:37.094]                           invokeRestart(restart)
[16:03:37.094]                           muffled <- TRUE
[16:03:37.094]                           break
[16:03:37.094]                         }
[16:03:37.094]                       }
[16:03:37.094]                     }
[16:03:37.094]                     invisible(muffled)
[16:03:37.094]                   }
[16:03:37.094]                   muffleCondition(cond)
[16:03:37.094]                 })
[16:03:37.094]             }))
[16:03:37.094]             future::FutureResult(value = ...future.value$value, 
[16:03:37.094]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:37.094]                   ...future.rng), globalenv = if (FALSE) 
[16:03:37.094]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:37.094]                     ...future.globalenv.names))
[16:03:37.094]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:37.094]         }, condition = base::local({
[16:03:37.094]             c <- base::c
[16:03:37.094]             inherits <- base::inherits
[16:03:37.094]             invokeRestart <- base::invokeRestart
[16:03:37.094]             length <- base::length
[16:03:37.094]             list <- base::list
[16:03:37.094]             seq.int <- base::seq.int
[16:03:37.094]             signalCondition <- base::signalCondition
[16:03:37.094]             sys.calls <- base::sys.calls
[16:03:37.094]             `[[` <- base::`[[`
[16:03:37.094]             `+` <- base::`+`
[16:03:37.094]             `<<-` <- base::`<<-`
[16:03:37.094]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:37.094]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:37.094]                   3L)]
[16:03:37.094]             }
[16:03:37.094]             function(cond) {
[16:03:37.094]                 is_error <- inherits(cond, "error")
[16:03:37.094]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:37.094]                   NULL)
[16:03:37.094]                 if (is_error) {
[16:03:37.094]                   sessionInformation <- function() {
[16:03:37.094]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:37.094]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:37.094]                       search = base::search(), system = base::Sys.info())
[16:03:37.094]                   }
[16:03:37.094]                   ...future.conditions[[length(...future.conditions) + 
[16:03:37.094]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:37.094]                     cond$call), session = sessionInformation(), 
[16:03:37.094]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:37.094]                   signalCondition(cond)
[16:03:37.094]                 }
[16:03:37.094]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:37.094]                 "immediateCondition"))) {
[16:03:37.094]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:37.094]                   ...future.conditions[[length(...future.conditions) + 
[16:03:37.094]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:37.094]                   if (TRUE && !signal) {
[16:03:37.094]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:37.094]                     {
[16:03:37.094]                       inherits <- base::inherits
[16:03:37.094]                       invokeRestart <- base::invokeRestart
[16:03:37.094]                       is.null <- base::is.null
[16:03:37.094]                       muffled <- FALSE
[16:03:37.094]                       if (inherits(cond, "message")) {
[16:03:37.094]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:37.094]                         if (muffled) 
[16:03:37.094]                           invokeRestart("muffleMessage")
[16:03:37.094]                       }
[16:03:37.094]                       else if (inherits(cond, "warning")) {
[16:03:37.094]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:37.094]                         if (muffled) 
[16:03:37.094]                           invokeRestart("muffleWarning")
[16:03:37.094]                       }
[16:03:37.094]                       else if (inherits(cond, "condition")) {
[16:03:37.094]                         if (!is.null(pattern)) {
[16:03:37.094]                           computeRestarts <- base::computeRestarts
[16:03:37.094]                           grepl <- base::grepl
[16:03:37.094]                           restarts <- computeRestarts(cond)
[16:03:37.094]                           for (restart in restarts) {
[16:03:37.094]                             name <- restart$name
[16:03:37.094]                             if (is.null(name)) 
[16:03:37.094]                               next
[16:03:37.094]                             if (!grepl(pattern, name)) 
[16:03:37.094]                               next
[16:03:37.094]                             invokeRestart(restart)
[16:03:37.094]                             muffled <- TRUE
[16:03:37.094]                             break
[16:03:37.094]                           }
[16:03:37.094]                         }
[16:03:37.094]                       }
[16:03:37.094]                       invisible(muffled)
[16:03:37.094]                     }
[16:03:37.094]                     muffleCondition(cond, pattern = "^muffle")
[16:03:37.094]                   }
[16:03:37.094]                 }
[16:03:37.094]                 else {
[16:03:37.094]                   if (TRUE) {
[16:03:37.094]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:37.094]                     {
[16:03:37.094]                       inherits <- base::inherits
[16:03:37.094]                       invokeRestart <- base::invokeRestart
[16:03:37.094]                       is.null <- base::is.null
[16:03:37.094]                       muffled <- FALSE
[16:03:37.094]                       if (inherits(cond, "message")) {
[16:03:37.094]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:37.094]                         if (muffled) 
[16:03:37.094]                           invokeRestart("muffleMessage")
[16:03:37.094]                       }
[16:03:37.094]                       else if (inherits(cond, "warning")) {
[16:03:37.094]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:37.094]                         if (muffled) 
[16:03:37.094]                           invokeRestart("muffleWarning")
[16:03:37.094]                       }
[16:03:37.094]                       else if (inherits(cond, "condition")) {
[16:03:37.094]                         if (!is.null(pattern)) {
[16:03:37.094]                           computeRestarts <- base::computeRestarts
[16:03:37.094]                           grepl <- base::grepl
[16:03:37.094]                           restarts <- computeRestarts(cond)
[16:03:37.094]                           for (restart in restarts) {
[16:03:37.094]                             name <- restart$name
[16:03:37.094]                             if (is.null(name)) 
[16:03:37.094]                               next
[16:03:37.094]                             if (!grepl(pattern, name)) 
[16:03:37.094]                               next
[16:03:37.094]                             invokeRestart(restart)
[16:03:37.094]                             muffled <- TRUE
[16:03:37.094]                             break
[16:03:37.094]                           }
[16:03:37.094]                         }
[16:03:37.094]                       }
[16:03:37.094]                       invisible(muffled)
[16:03:37.094]                     }
[16:03:37.094]                     muffleCondition(cond, pattern = "^muffle")
[16:03:37.094]                   }
[16:03:37.094]                 }
[16:03:37.094]             }
[16:03:37.094]         }))
[16:03:37.094]     }, error = function(ex) {
[16:03:37.094]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:37.094]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:37.094]                 ...future.rng), started = ...future.startTime, 
[16:03:37.094]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:37.094]             version = "1.8"), class = "FutureResult")
[16:03:37.094]     }, finally = {
[16:03:37.094]         if (!identical(...future.workdir, getwd())) 
[16:03:37.094]             setwd(...future.workdir)
[16:03:37.094]         {
[16:03:37.094]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:37.094]                 ...future.oldOptions$nwarnings <- NULL
[16:03:37.094]             }
[16:03:37.094]             base::options(...future.oldOptions)
[16:03:37.094]             if (.Platform$OS.type == "windows") {
[16:03:37.094]                 old_names <- names(...future.oldEnvVars)
[16:03:37.094]                 envs <- base::Sys.getenv()
[16:03:37.094]                 names <- names(envs)
[16:03:37.094]                 common <- intersect(names, old_names)
[16:03:37.094]                 added <- setdiff(names, old_names)
[16:03:37.094]                 removed <- setdiff(old_names, names)
[16:03:37.094]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:37.094]                   envs[common]]
[16:03:37.094]                 NAMES <- toupper(changed)
[16:03:37.094]                 args <- list()
[16:03:37.094]                 for (kk in seq_along(NAMES)) {
[16:03:37.094]                   name <- changed[[kk]]
[16:03:37.094]                   NAME <- NAMES[[kk]]
[16:03:37.094]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:37.094]                     next
[16:03:37.094]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:37.094]                 }
[16:03:37.094]                 NAMES <- toupper(added)
[16:03:37.094]                 for (kk in seq_along(NAMES)) {
[16:03:37.094]                   name <- added[[kk]]
[16:03:37.094]                   NAME <- NAMES[[kk]]
[16:03:37.094]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:37.094]                     next
[16:03:37.094]                   args[[name]] <- ""
[16:03:37.094]                 }
[16:03:37.094]                 NAMES <- toupper(removed)
[16:03:37.094]                 for (kk in seq_along(NAMES)) {
[16:03:37.094]                   name <- removed[[kk]]
[16:03:37.094]                   NAME <- NAMES[[kk]]
[16:03:37.094]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:37.094]                     next
[16:03:37.094]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:37.094]                 }
[16:03:37.094]                 if (length(args) > 0) 
[16:03:37.094]                   base::do.call(base::Sys.setenv, args = args)
[16:03:37.094]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:37.094]             }
[16:03:37.094]             else {
[16:03:37.094]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:37.094]             }
[16:03:37.094]             {
[16:03:37.094]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:37.094]                   0L) {
[16:03:37.094]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:37.094]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:37.094]                   base::options(opts)
[16:03:37.094]                 }
[16:03:37.094]                 {
[16:03:37.094]                   {
[16:03:37.094]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:37.094]                     NULL
[16:03:37.094]                   }
[16:03:37.094]                   options(future.plan = NULL)
[16:03:37.094]                   if (is.na(NA_character_)) 
[16:03:37.094]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:37.094]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:37.094]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:37.094]                     envir = parent.frame()) 
[16:03:37.094]                   {
[16:03:37.094]                     default_workers <- missing(workers)
[16:03:37.094]                     if (is.function(workers)) 
[16:03:37.094]                       workers <- workers()
[16:03:37.094]                     workers <- structure(as.integer(workers), 
[16:03:37.094]                       class = class(workers))
[16:03:37.094]                     stop_if_not(is.finite(workers), workers >= 
[16:03:37.094]                       1L)
[16:03:37.094]                     if ((workers == 1L && !inherits(workers, 
[16:03:37.094]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:37.094]                       if (default_workers) 
[16:03:37.094]                         supportsMulticore(warn = TRUE)
[16:03:37.094]                       return(sequential(..., envir = envir))
[16:03:37.094]                     }
[16:03:37.094]                     oopts <- options(mc.cores = workers)
[16:03:37.094]                     on.exit(options(oopts))
[16:03:37.094]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:37.094]                       envir = envir)
[16:03:37.094]                     if (!future$lazy) 
[16:03:37.094]                       future <- run(future)
[16:03:37.094]                     invisible(future)
[16:03:37.094]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:37.094]                 }
[16:03:37.094]             }
[16:03:37.094]         }
[16:03:37.094]     })
[16:03:37.094]     if (TRUE) {
[16:03:37.094]         base::sink(type = "output", split = FALSE)
[16:03:37.094]         if (FALSE) {
[16:03:37.094]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:37.094]         }
[16:03:37.094]         else {
[16:03:37.094]             ...future.result["stdout"] <- base::list(NULL)
[16:03:37.094]         }
[16:03:37.094]         base::close(...future.stdout)
[16:03:37.094]         ...future.stdout <- NULL
[16:03:37.094]     }
[16:03:37.094]     ...future.result$conditions <- ...future.conditions
[16:03:37.094]     ...future.result$finished <- base::Sys.time()
[16:03:37.094]     ...future.result
[16:03:37.094] }
[16:03:37.096] assign_globals() ...
[16:03:37.097] List of 5
[16:03:37.097]  $ ...future.FUN            :function (x)  
[16:03:37.097]  $ future.call.arguments    : list()
[16:03:37.097]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:37.097]  $ ...future.elements_ii    :List of 1
[16:03:37.097]   ..$ : int 1
[16:03:37.097]  $ ...future.seeds_ii       : NULL
[16:03:37.097]  $ ...future.globals.maxSize: NULL
[16:03:37.097]  - attr(*, "where")=List of 5
[16:03:37.097]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:37.097]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:37.097]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:37.097]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:37.097]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:37.097]  - attr(*, "resolved")= logi FALSE
[16:03:37.097]  - attr(*, "total_size")= num 4720
[16:03:37.097]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:37.097]  - attr(*, "already-done")= logi TRUE
[16:03:37.103] - reassign environment for ‘...future.FUN’
[16:03:37.103] - copied ‘...future.FUN’ to environment
[16:03:37.103] - copied ‘future.call.arguments’ to environment
[16:03:37.104] - copied ‘...future.elements_ii’ to environment
[16:03:37.104] - copied ‘...future.seeds_ii’ to environment
[16:03:37.104] - copied ‘...future.globals.maxSize’ to environment
[16:03:37.104] assign_globals() ... done
[16:03:37.104] requestCore(): workers = 2
[16:03:37.107] MulticoreFuture started
[16:03:37.108] - Launch lazy future ... done
[16:03:37.108] run() for ‘MulticoreFuture’ ... done
[16:03:37.108] plan(): Setting new future strategy stack:
[16:03:37.108] Created future:
[16:03:37.108] List of future strategies:
[16:03:37.108] 1. sequential:
[16:03:37.108]    - args: function (..., envir = parent.frame())
[16:03:37.108]    - tweaked: FALSE
[16:03:37.108]    - call: NULL
[16:03:37.109] plan(): nbrOfWorkers() = 1
[16:03:37.109] MulticoreFuture:
[16:03:37.109] Label: ‘future_lapply-1’
[16:03:37.109] Expression:
[16:03:37.109] {
[16:03:37.109]     do.call(function(...) {
[16:03:37.109]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:37.109]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:37.109]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:37.109]             on.exit(options(oopts), add = TRUE)
[16:03:37.109]         }
[16:03:37.109]         {
[16:03:37.109]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:37.109]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:37.109]                 ...future.FUN(...future.X_jj, ...)
[16:03:37.109]             })
[16:03:37.109]         }
[16:03:37.109]     }, args = future.call.arguments)
[16:03:37.109] }
[16:03:37.109] Lazy evaluation: FALSE
[16:03:37.109] Asynchronous evaluation: TRUE
[16:03:37.109] Local evaluation: TRUE
[16:03:37.109] Environment: R_GlobalEnv
[16:03:37.109] Capture standard output: FALSE
[16:03:37.109] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:37.109] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:37.109] Packages: <none>
[16:03:37.109] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:37.109] Resolved: FALSE
[16:03:37.109] Value: <not collected>
[16:03:37.109] Conditions captured: <none>
[16:03:37.109] Early signaling: FALSE
[16:03:37.109] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:37.109] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:37.124] Chunk #1 of 2 ... DONE
[16:03:37.124] Chunk #2 of 2 ...
[16:03:37.124]  - Finding globals in 'X' for chunk #2 ...
[16:03:37.125] getGlobalsAndPackages() ...
[16:03:37.125] Searching for globals...
[16:03:37.125] 
[16:03:37.126] Searching for globals ... DONE
[16:03:37.126] - globals: [0] <none>
[16:03:37.126] getGlobalsAndPackages() ... DONE
[16:03:37.126]    + additional globals found: [n=0] 
[16:03:37.126]    + additional namespaces needed: [n=0] 
[16:03:37.127]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:37.127]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:37.127]  - seeds: <none>
[16:03:37.127]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:37.127] getGlobalsAndPackages() ...
[16:03:37.127] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:37.128] Resolving globals: FALSE
[16:03:37.128] Tweak future expression to call with '...' arguments ...
[16:03:37.128] {
[16:03:37.128]     do.call(function(...) {
[16:03:37.128]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:37.128]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:37.128]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:37.128]             on.exit(options(oopts), add = TRUE)
[16:03:37.128]         }
[16:03:37.128]         {
[16:03:37.128]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:37.128]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:37.128]                 ...future.FUN(...future.X_jj, ...)
[16:03:37.128]             })
[16:03:37.128]         }
[16:03:37.128]     }, args = future.call.arguments)
[16:03:37.128] }
[16:03:37.128] Tweak future expression to call with '...' arguments ... DONE
[16:03:37.129] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:37.129] 
[16:03:37.129] getGlobalsAndPackages() ... DONE
[16:03:37.130] run() for ‘Future’ ...
[16:03:37.130] - state: ‘created’
[16:03:37.130] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:37.136] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:37.136] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:37.136]   - Field: ‘label’
[16:03:37.136]   - Field: ‘local’
[16:03:37.136]   - Field: ‘owner’
[16:03:37.136]   - Field: ‘envir’
[16:03:37.137]   - Field: ‘workers’
[16:03:37.137]   - Field: ‘packages’
[16:03:37.137]   - Field: ‘gc’
[16:03:37.137]   - Field: ‘job’
[16:03:37.137]   - Field: ‘conditions’
[16:03:37.137]   - Field: ‘expr’
[16:03:37.137]   - Field: ‘uuid’
[16:03:37.138]   - Field: ‘seed’
[16:03:37.138]   - Field: ‘version’
[16:03:37.138]   - Field: ‘result’
[16:03:37.138]   - Field: ‘asynchronous’
[16:03:37.138]   - Field: ‘calls’
[16:03:37.138]   - Field: ‘globals’
[16:03:37.138]   - Field: ‘stdout’
[16:03:37.139]   - Field: ‘earlySignal’
[16:03:37.139]   - Field: ‘lazy’
[16:03:37.139]   - Field: ‘state’
[16:03:37.139] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:37.139] - Launch lazy future ...
[16:03:37.140] Packages needed by the future expression (n = 0): <none>
[16:03:37.140] Packages needed by future strategies (n = 0): <none>
[16:03:37.141] {
[16:03:37.141]     {
[16:03:37.141]         {
[16:03:37.141]             ...future.startTime <- base::Sys.time()
[16:03:37.141]             {
[16:03:37.141]                 {
[16:03:37.141]                   {
[16:03:37.141]                     {
[16:03:37.141]                       base::local({
[16:03:37.141]                         has_future <- base::requireNamespace("future", 
[16:03:37.141]                           quietly = TRUE)
[16:03:37.141]                         if (has_future) {
[16:03:37.141]                           ns <- base::getNamespace("future")
[16:03:37.141]                           version <- ns[[".package"]][["version"]]
[16:03:37.141]                           if (is.null(version)) 
[16:03:37.141]                             version <- utils::packageVersion("future")
[16:03:37.141]                         }
[16:03:37.141]                         else {
[16:03:37.141]                           version <- NULL
[16:03:37.141]                         }
[16:03:37.141]                         if (!has_future || version < "1.8.0") {
[16:03:37.141]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:37.141]                             "", base::R.version$version.string), 
[16:03:37.141]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:37.141]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:37.141]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:37.141]                               "release", "version")], collapse = " "), 
[16:03:37.141]                             hostname = base::Sys.info()[["nodename"]])
[16:03:37.141]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:37.141]                             info)
[16:03:37.141]                           info <- base::paste(info, collapse = "; ")
[16:03:37.141]                           if (!has_future) {
[16:03:37.141]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:37.141]                               info)
[16:03:37.141]                           }
[16:03:37.141]                           else {
[16:03:37.141]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:37.141]                               info, version)
[16:03:37.141]                           }
[16:03:37.141]                           base::stop(msg)
[16:03:37.141]                         }
[16:03:37.141]                       })
[16:03:37.141]                     }
[16:03:37.141]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:37.141]                     base::options(mc.cores = 1L)
[16:03:37.141]                   }
[16:03:37.141]                   options(future.plan = NULL)
[16:03:37.141]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:37.141]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:37.141]                 }
[16:03:37.141]                 ...future.workdir <- getwd()
[16:03:37.141]             }
[16:03:37.141]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:37.141]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:37.141]         }
[16:03:37.141]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:37.141]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:37.141]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:37.141]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:37.141]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:37.141]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:37.141]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:37.141]             base::names(...future.oldOptions))
[16:03:37.141]     }
[16:03:37.141]     if (FALSE) {
[16:03:37.141]     }
[16:03:37.141]     else {
[16:03:37.141]         if (FALSE) {
[16:03:37.141]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:37.141]                 open = "w")
[16:03:37.141]         }
[16:03:37.141]         else {
[16:03:37.141]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:37.141]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:37.141]         }
[16:03:37.141]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:37.141]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:37.141]             base::sink(type = "output", split = FALSE)
[16:03:37.141]             base::close(...future.stdout)
[16:03:37.141]         }, add = TRUE)
[16:03:37.141]     }
[16:03:37.141]     ...future.frame <- base::sys.nframe()
[16:03:37.141]     ...future.conditions <- base::list()
[16:03:37.141]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:37.141]     if (FALSE) {
[16:03:37.141]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:37.141]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:37.141]     }
[16:03:37.141]     ...future.result <- base::tryCatch({
[16:03:37.141]         base::withCallingHandlers({
[16:03:37.141]             ...future.value <- base::withVisible(base::local({
[16:03:37.141]                 withCallingHandlers({
[16:03:37.141]                   {
[16:03:37.141]                     do.call(function(...) {
[16:03:37.141]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:37.141]                       if (!identical(...future.globals.maxSize.org, 
[16:03:37.141]                         ...future.globals.maxSize)) {
[16:03:37.141]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:37.141]                         on.exit(options(oopts), add = TRUE)
[16:03:37.141]                       }
[16:03:37.141]                       {
[16:03:37.141]                         lapply(seq_along(...future.elements_ii), 
[16:03:37.141]                           FUN = function(jj) {
[16:03:37.141]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:37.141]                             ...future.FUN(...future.X_jj, ...)
[16:03:37.141]                           })
[16:03:37.141]                       }
[16:03:37.141]                     }, args = future.call.arguments)
[16:03:37.141]                   }
[16:03:37.141]                 }, immediateCondition = function(cond) {
[16:03:37.141]                   save_rds <- function (object, pathname, ...) 
[16:03:37.141]                   {
[16:03:37.141]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:37.141]                     if (file_test("-f", pathname_tmp)) {
[16:03:37.141]                       fi_tmp <- file.info(pathname_tmp)
[16:03:37.141]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:37.141]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:37.141]                         fi_tmp[["mtime"]])
[16:03:37.141]                     }
[16:03:37.141]                     tryCatch({
[16:03:37.141]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:37.141]                     }, error = function(ex) {
[16:03:37.141]                       msg <- conditionMessage(ex)
[16:03:37.141]                       fi_tmp <- file.info(pathname_tmp)
[16:03:37.141]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:37.141]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:37.141]                         fi_tmp[["mtime"]], msg)
[16:03:37.141]                       ex$message <- msg
[16:03:37.141]                       stop(ex)
[16:03:37.141]                     })
[16:03:37.141]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:37.141]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:37.141]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:37.141]                       fi_tmp <- file.info(pathname_tmp)
[16:03:37.141]                       fi <- file.info(pathname)
[16:03:37.141]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:37.141]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:37.141]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:37.141]                         fi[["size"]], fi[["mtime"]])
[16:03:37.141]                       stop(msg)
[16:03:37.141]                     }
[16:03:37.141]                     invisible(pathname)
[16:03:37.141]                   }
[16:03:37.141]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:37.141]                     rootPath = tempdir()) 
[16:03:37.141]                   {
[16:03:37.141]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:37.141]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:37.141]                       tmpdir = path, fileext = ".rds")
[16:03:37.141]                     save_rds(obj, file)
[16:03:37.141]                   }
[16:03:37.141]                   saveImmediateCondition(cond, path = "/tmp/Rtmpi1Xc62/.future/immediateConditions")
[16:03:37.141]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:37.141]                   {
[16:03:37.141]                     inherits <- base::inherits
[16:03:37.141]                     invokeRestart <- base::invokeRestart
[16:03:37.141]                     is.null <- base::is.null
[16:03:37.141]                     muffled <- FALSE
[16:03:37.141]                     if (inherits(cond, "message")) {
[16:03:37.141]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:37.141]                       if (muffled) 
[16:03:37.141]                         invokeRestart("muffleMessage")
[16:03:37.141]                     }
[16:03:37.141]                     else if (inherits(cond, "warning")) {
[16:03:37.141]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:37.141]                       if (muffled) 
[16:03:37.141]                         invokeRestart("muffleWarning")
[16:03:37.141]                     }
[16:03:37.141]                     else if (inherits(cond, "condition")) {
[16:03:37.141]                       if (!is.null(pattern)) {
[16:03:37.141]                         computeRestarts <- base::computeRestarts
[16:03:37.141]                         grepl <- base::grepl
[16:03:37.141]                         restarts <- computeRestarts(cond)
[16:03:37.141]                         for (restart in restarts) {
[16:03:37.141]                           name <- restart$name
[16:03:37.141]                           if (is.null(name)) 
[16:03:37.141]                             next
[16:03:37.141]                           if (!grepl(pattern, name)) 
[16:03:37.141]                             next
[16:03:37.141]                           invokeRestart(restart)
[16:03:37.141]                           muffled <- TRUE
[16:03:37.141]                           break
[16:03:37.141]                         }
[16:03:37.141]                       }
[16:03:37.141]                     }
[16:03:37.141]                     invisible(muffled)
[16:03:37.141]                   }
[16:03:37.141]                   muffleCondition(cond)
[16:03:37.141]                 })
[16:03:37.141]             }))
[16:03:37.141]             future::FutureResult(value = ...future.value$value, 
[16:03:37.141]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:37.141]                   ...future.rng), globalenv = if (FALSE) 
[16:03:37.141]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:37.141]                     ...future.globalenv.names))
[16:03:37.141]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:37.141]         }, condition = base::local({
[16:03:37.141]             c <- base::c
[16:03:37.141]             inherits <- base::inherits
[16:03:37.141]             invokeRestart <- base::invokeRestart
[16:03:37.141]             length <- base::length
[16:03:37.141]             list <- base::list
[16:03:37.141]             seq.int <- base::seq.int
[16:03:37.141]             signalCondition <- base::signalCondition
[16:03:37.141]             sys.calls <- base::sys.calls
[16:03:37.141]             `[[` <- base::`[[`
[16:03:37.141]             `+` <- base::`+`
[16:03:37.141]             `<<-` <- base::`<<-`
[16:03:37.141]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:37.141]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:37.141]                   3L)]
[16:03:37.141]             }
[16:03:37.141]             function(cond) {
[16:03:37.141]                 is_error <- inherits(cond, "error")
[16:03:37.141]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:37.141]                   NULL)
[16:03:37.141]                 if (is_error) {
[16:03:37.141]                   sessionInformation <- function() {
[16:03:37.141]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:37.141]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:37.141]                       search = base::search(), system = base::Sys.info())
[16:03:37.141]                   }
[16:03:37.141]                   ...future.conditions[[length(...future.conditions) + 
[16:03:37.141]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:37.141]                     cond$call), session = sessionInformation(), 
[16:03:37.141]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:37.141]                   signalCondition(cond)
[16:03:37.141]                 }
[16:03:37.141]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:37.141]                 "immediateCondition"))) {
[16:03:37.141]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:37.141]                   ...future.conditions[[length(...future.conditions) + 
[16:03:37.141]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:37.141]                   if (TRUE && !signal) {
[16:03:37.141]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:37.141]                     {
[16:03:37.141]                       inherits <- base::inherits
[16:03:37.141]                       invokeRestart <- base::invokeRestart
[16:03:37.141]                       is.null <- base::is.null
[16:03:37.141]                       muffled <- FALSE
[16:03:37.141]                       if (inherits(cond, "message")) {
[16:03:37.141]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:37.141]                         if (muffled) 
[16:03:37.141]                           invokeRestart("muffleMessage")
[16:03:37.141]                       }
[16:03:37.141]                       else if (inherits(cond, "warning")) {
[16:03:37.141]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:37.141]                         if (muffled) 
[16:03:37.141]                           invokeRestart("muffleWarning")
[16:03:37.141]                       }
[16:03:37.141]                       else if (inherits(cond, "condition")) {
[16:03:37.141]                         if (!is.null(pattern)) {
[16:03:37.141]                           computeRestarts <- base::computeRestarts
[16:03:37.141]                           grepl <- base::grepl
[16:03:37.141]                           restarts <- computeRestarts(cond)
[16:03:37.141]                           for (restart in restarts) {
[16:03:37.141]                             name <- restart$name
[16:03:37.141]                             if (is.null(name)) 
[16:03:37.141]                               next
[16:03:37.141]                             if (!grepl(pattern, name)) 
[16:03:37.141]                               next
[16:03:37.141]                             invokeRestart(restart)
[16:03:37.141]                             muffled <- TRUE
[16:03:37.141]                             break
[16:03:37.141]                           }
[16:03:37.141]                         }
[16:03:37.141]                       }
[16:03:37.141]                       invisible(muffled)
[16:03:37.141]                     }
[16:03:37.141]                     muffleCondition(cond, pattern = "^muffle")
[16:03:37.141]                   }
[16:03:37.141]                 }
[16:03:37.141]                 else {
[16:03:37.141]                   if (TRUE) {
[16:03:37.141]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:37.141]                     {
[16:03:37.141]                       inherits <- base::inherits
[16:03:37.141]                       invokeRestart <- base::invokeRestart
[16:03:37.141]                       is.null <- base::is.null
[16:03:37.141]                       muffled <- FALSE
[16:03:37.141]                       if (inherits(cond, "message")) {
[16:03:37.141]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:37.141]                         if (muffled) 
[16:03:37.141]                           invokeRestart("muffleMessage")
[16:03:37.141]                       }
[16:03:37.141]                       else if (inherits(cond, "warning")) {
[16:03:37.141]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:37.141]                         if (muffled) 
[16:03:37.141]                           invokeRestart("muffleWarning")
[16:03:37.141]                       }
[16:03:37.141]                       else if (inherits(cond, "condition")) {
[16:03:37.141]                         if (!is.null(pattern)) {
[16:03:37.141]                           computeRestarts <- base::computeRestarts
[16:03:37.141]                           grepl <- base::grepl
[16:03:37.141]                           restarts <- computeRestarts(cond)
[16:03:37.141]                           for (restart in restarts) {
[16:03:37.141]                             name <- restart$name
[16:03:37.141]                             if (is.null(name)) 
[16:03:37.141]                               next
[16:03:37.141]                             if (!grepl(pattern, name)) 
[16:03:37.141]                               next
[16:03:37.141]                             invokeRestart(restart)
[16:03:37.141]                             muffled <- TRUE
[16:03:37.141]                             break
[16:03:37.141]                           }
[16:03:37.141]                         }
[16:03:37.141]                       }
[16:03:37.141]                       invisible(muffled)
[16:03:37.141]                     }
[16:03:37.141]                     muffleCondition(cond, pattern = "^muffle")
[16:03:37.141]                   }
[16:03:37.141]                 }
[16:03:37.141]             }
[16:03:37.141]         }))
[16:03:37.141]     }, error = function(ex) {
[16:03:37.141]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:37.141]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:37.141]                 ...future.rng), started = ...future.startTime, 
[16:03:37.141]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:37.141]             version = "1.8"), class = "FutureResult")
[16:03:37.141]     }, finally = {
[16:03:37.141]         if (!identical(...future.workdir, getwd())) 
[16:03:37.141]             setwd(...future.workdir)
[16:03:37.141]         {
[16:03:37.141]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:37.141]                 ...future.oldOptions$nwarnings <- NULL
[16:03:37.141]             }
[16:03:37.141]             base::options(...future.oldOptions)
[16:03:37.141]             if (.Platform$OS.type == "windows") {
[16:03:37.141]                 old_names <- names(...future.oldEnvVars)
[16:03:37.141]                 envs <- base::Sys.getenv()
[16:03:37.141]                 names <- names(envs)
[16:03:37.141]                 common <- intersect(names, old_names)
[16:03:37.141]                 added <- setdiff(names, old_names)
[16:03:37.141]                 removed <- setdiff(old_names, names)
[16:03:37.141]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:37.141]                   envs[common]]
[16:03:37.141]                 NAMES <- toupper(changed)
[16:03:37.141]                 args <- list()
[16:03:37.141]                 for (kk in seq_along(NAMES)) {
[16:03:37.141]                   name <- changed[[kk]]
[16:03:37.141]                   NAME <- NAMES[[kk]]
[16:03:37.141]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:37.141]                     next
[16:03:37.141]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:37.141]                 }
[16:03:37.141]                 NAMES <- toupper(added)
[16:03:37.141]                 for (kk in seq_along(NAMES)) {
[16:03:37.141]                   name <- added[[kk]]
[16:03:37.141]                   NAME <- NAMES[[kk]]
[16:03:37.141]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:37.141]                     next
[16:03:37.141]                   args[[name]] <- ""
[16:03:37.141]                 }
[16:03:37.141]                 NAMES <- toupper(removed)
[16:03:37.141]                 for (kk in seq_along(NAMES)) {
[16:03:37.141]                   name <- removed[[kk]]
[16:03:37.141]                   NAME <- NAMES[[kk]]
[16:03:37.141]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:37.141]                     next
[16:03:37.141]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:37.141]                 }
[16:03:37.141]                 if (length(args) > 0) 
[16:03:37.141]                   base::do.call(base::Sys.setenv, args = args)
[16:03:37.141]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:37.141]             }
[16:03:37.141]             else {
[16:03:37.141]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:37.141]             }
[16:03:37.141]             {
[16:03:37.141]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:37.141]                   0L) {
[16:03:37.141]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:37.141]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:37.141]                   base::options(opts)
[16:03:37.141]                 }
[16:03:37.141]                 {
[16:03:37.141]                   {
[16:03:37.141]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:37.141]                     NULL
[16:03:37.141]                   }
[16:03:37.141]                   options(future.plan = NULL)
[16:03:37.141]                   if (is.na(NA_character_)) 
[16:03:37.141]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:37.141]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:37.141]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:37.141]                     envir = parent.frame()) 
[16:03:37.141]                   {
[16:03:37.141]                     default_workers <- missing(workers)
[16:03:37.141]                     if (is.function(workers)) 
[16:03:37.141]                       workers <- workers()
[16:03:37.141]                     workers <- structure(as.integer(workers), 
[16:03:37.141]                       class = class(workers))
[16:03:37.141]                     stop_if_not(is.finite(workers), workers >= 
[16:03:37.141]                       1L)
[16:03:37.141]                     if ((workers == 1L && !inherits(workers, 
[16:03:37.141]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:37.141]                       if (default_workers) 
[16:03:37.141]                         supportsMulticore(warn = TRUE)
[16:03:37.141]                       return(sequential(..., envir = envir))
[16:03:37.141]                     }
[16:03:37.141]                     oopts <- options(mc.cores = workers)
[16:03:37.141]                     on.exit(options(oopts))
[16:03:37.141]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:37.141]                       envir = envir)
[16:03:37.141]                     if (!future$lazy) 
[16:03:37.141]                       future <- run(future)
[16:03:37.141]                     invisible(future)
[16:03:37.141]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:37.141]                 }
[16:03:37.141]             }
[16:03:37.141]         }
[16:03:37.141]     })
[16:03:37.141]     if (TRUE) {
[16:03:37.141]         base::sink(type = "output", split = FALSE)
[16:03:37.141]         if (FALSE) {
[16:03:37.141]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:37.141]         }
[16:03:37.141]         else {
[16:03:37.141]             ...future.result["stdout"] <- base::list(NULL)
[16:03:37.141]         }
[16:03:37.141]         base::close(...future.stdout)
[16:03:37.141]         ...future.stdout <- NULL
[16:03:37.141]     }
[16:03:37.141]     ...future.result$conditions <- ...future.conditions
[16:03:37.141]     ...future.result$finished <- base::Sys.time()
[16:03:37.141]     ...future.result
[16:03:37.141] }
[16:03:37.144] assign_globals() ...
[16:03:37.144] List of 5
[16:03:37.144]  $ ...future.FUN            :function (x)  
[16:03:37.144]  $ future.call.arguments    : list()
[16:03:37.144]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:37.144]  $ ...future.elements_ii    :List of 1
[16:03:37.144]   ..$ : int 0
[16:03:37.144]  $ ...future.seeds_ii       : NULL
[16:03:37.144]  $ ...future.globals.maxSize: NULL
[16:03:37.144]  - attr(*, "where")=List of 5
[16:03:37.144]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:37.144]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:37.144]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:37.144]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:37.144]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:37.144]  - attr(*, "resolved")= logi FALSE
[16:03:37.144]  - attr(*, "total_size")= num 4720
[16:03:37.144]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:37.144]  - attr(*, "already-done")= logi TRUE
[16:03:37.151] - reassign environment for ‘...future.FUN’
[16:03:37.151] - copied ‘...future.FUN’ to environment
[16:03:37.152] - copied ‘future.call.arguments’ to environment
[16:03:37.152] - copied ‘...future.elements_ii’ to environment
[16:03:37.152] - copied ‘...future.seeds_ii’ to environment
[16:03:37.152] - copied ‘...future.globals.maxSize’ to environment
[16:03:37.152] assign_globals() ... done
[16:03:37.152] requestCore(): workers = 2
[16:03:37.160] MulticoreFuture started
[16:03:37.161] - Launch lazy future ... done
[16:03:37.162] plan(): Setting new future strategy stack:
[16:03:37.161] run() for ‘MulticoreFuture’ ... done
[16:03:37.162] Created future:
[16:03:37.162] List of future strategies:
[16:03:37.162] 1. sequential:
[16:03:37.162]    - args: function (..., envir = parent.frame())
[16:03:37.162]    - tweaked: FALSE
[16:03:37.162]    - call: NULL
[16:03:37.163] plan(): nbrOfWorkers() = 1
[16:03:37.166] plan(): Setting new future strategy stack:
[16:03:37.166] List of future strategies:
[16:03:37.166] 1. multicore:
[16:03:37.166]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:37.166]    - tweaked: FALSE
[16:03:37.166]    - call: plan(strategy)
[16:03:37.172] plan(): nbrOfWorkers() = 2
[16:03:37.162] MulticoreFuture:
[16:03:37.162] Label: ‘future_lapply-2’
[16:03:37.162] Expression:
[16:03:37.162] {
[16:03:37.162]     do.call(function(...) {
[16:03:37.162]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:37.162]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:37.162]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:37.162]             on.exit(options(oopts), add = TRUE)
[16:03:37.162]         }
[16:03:37.162]         {
[16:03:37.162]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:37.162]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:37.162]                 ...future.FUN(...future.X_jj, ...)
[16:03:37.162]             })
[16:03:37.162]         }
[16:03:37.162]     }, args = future.call.arguments)
[16:03:37.162] }
[16:03:37.162] Lazy evaluation: FALSE
[16:03:37.162] Asynchronous evaluation: TRUE
[16:03:37.162] Local evaluation: TRUE
[16:03:37.162] Environment: R_GlobalEnv
[16:03:37.162] Capture standard output: FALSE
[16:03:37.162] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:37.162] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:37.162] Packages: <none>
[16:03:37.162] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:37.162] Resolved: TRUE
[16:03:37.162] Value: <not collected>
[16:03:37.162] Conditions captured: <none>
[16:03:37.162] Early signaling: FALSE
[16:03:37.162] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:37.162] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:37.173] Chunk #2 of 2 ... DONE
[16:03:37.173] Launching 2 futures (chunks) ... DONE
[16:03:37.173] Resolving 2 futures (chunks) ...
[16:03:37.173] resolve() on list ...
[16:03:37.174]  recursive: 0
[16:03:37.174]  length: 2
[16:03:37.174] 
[16:03:37.184] Future #2
[16:03:37.185] result() for MulticoreFuture ...
[16:03:37.187] result() for MulticoreFuture ...
[16:03:37.188] result() for MulticoreFuture ... done
[16:03:37.188] result() for MulticoreFuture ... done
[16:03:37.188] result() for MulticoreFuture ...
[16:03:37.188] result() for MulticoreFuture ... done
[16:03:37.188] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:03:37.189] - nx: 2
[16:03:37.189] - relay: TRUE
[16:03:37.189] - stdout: TRUE
[16:03:37.189] - signal: TRUE
[16:03:37.189] - resignal: FALSE
[16:03:37.189] - force: TRUE
[16:03:37.189] - relayed: [n=2] FALSE, FALSE
[16:03:37.189] - queued futures: [n=2] FALSE, FALSE
[16:03:37.190]  - until=1
[16:03:37.190]  - relaying element #1
[16:03:37.190] - relayed: [n=2] FALSE, FALSE
[16:03:37.190] - queued futures: [n=2] FALSE, TRUE
[16:03:37.190] signalConditionsASAP(NULL, pos=2) ... done
[16:03:37.190]  length: 1 (resolved future 2)
[16:03:37.613] plan(): Setting new future strategy stack:
[16:03:37.613] List of future strategies:
[16:03:37.613] 1. multicore:
[16:03:37.613]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:37.613]    - tweaked: FALSE
[16:03:37.613]    - call: plan(strategy)
[16:03:37.617] plan(): nbrOfWorkers() = 2
[16:03:37.628] Future #1
[16:03:37.628] result() for MulticoreFuture ...
[16:03:37.628] result() for MulticoreFuture ...
[16:03:37.629] result() for MulticoreFuture ... done
[16:03:37.629] result() for MulticoreFuture ... done
[16:03:37.629] result() for MulticoreFuture ...
[16:03:37.629] result() for MulticoreFuture ... done
[16:03:37.629] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:03:37.629] - nx: 2
[16:03:37.629] - relay: TRUE
[16:03:37.630] - stdout: TRUE
[16:03:37.630] - signal: TRUE
[16:03:37.630] - resignal: FALSE
[16:03:37.630] - force: TRUE
[16:03:37.630] - relayed: [n=2] FALSE, FALSE
[16:03:37.630] - queued futures: [n=2] FALSE, TRUE
[16:03:37.630]  - until=1
[16:03:37.630]  - relaying element #1
[16:03:37.630] result() for MulticoreFuture ...
[16:03:37.630] result() for MulticoreFuture ... done
[16:03:37.631] result() for MulticoreFuture ...
[16:03:37.631] result() for MulticoreFuture ... done
[16:03:37.631] result() for MulticoreFuture ...
[16:03:37.631] result() for MulticoreFuture ... done
[16:03:37.631] result() for MulticoreFuture ...
[16:03:37.631] result() for MulticoreFuture ... done
[16:03:37.631] - relayed: [n=2] TRUE, FALSE
[16:03:37.631] - queued futures: [n=2] TRUE, TRUE
[16:03:37.632] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:03:37.632]  length: 0 (resolved future 1)
[16:03:37.632] Relaying remaining futures
[16:03:37.632] signalConditionsASAP(NULL, pos=0) ...
[16:03:37.632] - nx: 2
[16:03:37.632] - relay: TRUE
[16:03:37.632] - stdout: TRUE
[16:03:37.632] - signal: TRUE
[16:03:37.632] - resignal: FALSE
[16:03:37.632] - force: TRUE
[16:03:37.633] - relayed: [n=2] TRUE, FALSE
[16:03:37.633] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:37.633]  - relaying element #2
[16:03:37.633] result() for MulticoreFuture ...
[16:03:37.633] result() for MulticoreFuture ... done
[16:03:37.633] result() for MulticoreFuture ...
[16:03:37.633] result() for MulticoreFuture ... done
[16:03:37.634] result() for MulticoreFuture ...
[16:03:37.634] result() for MulticoreFuture ... done
[16:03:37.634] result() for MulticoreFuture ...
[16:03:37.634] result() for MulticoreFuture ... done
[16:03:37.634] - relayed: [n=2] TRUE, TRUE
[16:03:37.634] - queued futures: [n=2] TRUE, TRUE
[16:03:37.634] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[16:03:37.634] resolve() on list ... DONE
[16:03:37.634] result() for MulticoreFuture ...
[16:03:37.635] result() for MulticoreFuture ... done
[16:03:37.635] result() for MulticoreFuture ...
[16:03:37.635] result() for MulticoreFuture ... done
[16:03:37.635] result() for MulticoreFuture ...
[16:03:37.635] result() for MulticoreFuture ... done
[16:03:37.635] result() for MulticoreFuture ...
[16:03:37.635] result() for MulticoreFuture ... done
[16:03:37.635]  - Number of value chunks collected: 2
[16:03:37.635] Resolving 2 futures (chunks) ... DONE
[16:03:37.636] Reducing values from 2 chunks ...
[16:03:37.636]  - Number of values collected after concatenation: 2
[16:03:37.636]  - Number of values expected: 2
[16:03:37.636] Reducing values from 2 chunks ... DONE
[16:03:37.636] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[16:03:37.636] future_lapply() ...
[16:03:37.642] Number of chunks: 2
[16:03:37.642] getGlobalsAndPackagesXApply() ...
[16:03:37.642]  - future.globals: TRUE
[16:03:37.642] getGlobalsAndPackages() ...
[16:03:37.642] Searching for globals...
[16:03:37.644] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:03:37.644] Searching for globals ... DONE
[16:03:37.644] Resolving globals: FALSE
[16:03:37.645] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:03:37.645] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:03:37.645] - globals: [1] ‘FUN’
[16:03:37.645] 
[16:03:37.645] getGlobalsAndPackages() ... DONE
[16:03:37.646]  - globals found/used: [n=1] ‘FUN’
[16:03:37.646]  - needed namespaces: [n=0] 
[16:03:37.646] Finding globals ... DONE
[16:03:37.646]  - use_args: TRUE
[16:03:37.646]  - Getting '...' globals ...
[16:03:37.646] resolve() on list ...
[16:03:37.646]  recursive: 0
[16:03:37.646]  length: 1
[16:03:37.647]  elements: ‘...’
[16:03:37.647]  length: 0 (resolved future 1)
[16:03:37.647] resolve() on list ... DONE
[16:03:37.647]    - '...' content: [n=0] 
[16:03:37.647] List of 1
[16:03:37.647]  $ ...: list()
[16:03:37.647]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:37.647]  - attr(*, "where")=List of 1
[16:03:37.647]   ..$ ...:<environment: 0x55ed7a03ec68> 
[16:03:37.647]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:37.647]  - attr(*, "resolved")= logi TRUE
[16:03:37.647]  - attr(*, "total_size")= num NA
[16:03:37.652]  - Getting '...' globals ... DONE
[16:03:37.652] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:03:37.652] List of 2
[16:03:37.652]  $ ...future.FUN:function (x)  
[16:03:37.652]  $ ...          : list()
[16:03:37.652]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:37.652]  - attr(*, "where")=List of 2
[16:03:37.652]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:37.652]   ..$ ...          :<environment: 0x55ed7a03ec68> 
[16:03:37.652]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:37.652]  - attr(*, "resolved")= logi FALSE
[16:03:37.652]  - attr(*, "total_size")= num 4720
[16:03:37.655] Packages to be attached in all futures: [n=0] 
[16:03:37.655] getGlobalsAndPackagesXApply() ... DONE
[16:03:37.655] Number of futures (= number of chunks): 2
[16:03:37.655] Launching 2 futures (chunks) ...
[16:03:37.656] Chunk #1 of 2 ...
[16:03:37.656]  - Finding globals in 'X' for chunk #1 ...
[16:03:37.656] getGlobalsAndPackages() ...
[16:03:37.656] Searching for globals...
[16:03:37.656] 
[16:03:37.656] Searching for globals ... DONE
[16:03:37.656] - globals: [0] <none>
[16:03:37.656] getGlobalsAndPackages() ... DONE
[16:03:37.656]    + additional globals found: [n=0] 
[16:03:37.657]    + additional namespaces needed: [n=0] 
[16:03:37.657]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:37.657]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:37.657]  - seeds: <none>
[16:03:37.657]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:37.657] getGlobalsAndPackages() ...
[16:03:37.657] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:37.657] Resolving globals: FALSE
[16:03:37.657] Tweak future expression to call with '...' arguments ...
[16:03:37.658] {
[16:03:37.658]     do.call(function(...) {
[16:03:37.658]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:37.658]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:37.658]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:37.658]             on.exit(options(oopts), add = TRUE)
[16:03:37.658]         }
[16:03:37.658]         {
[16:03:37.658]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:37.658]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:37.658]                 ...future.FUN(...future.X_jj, ...)
[16:03:37.658]             })
[16:03:37.658]         }
[16:03:37.658]     }, args = future.call.arguments)
[16:03:37.658] }
[16:03:37.658] Tweak future expression to call with '...' arguments ... DONE
[16:03:37.658] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:37.658] 
[16:03:37.658] getGlobalsAndPackages() ... DONE
[16:03:37.659] run() for ‘Future’ ...
[16:03:37.659] - state: ‘created’
[16:03:37.659] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:37.662] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:37.663] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:37.663]   - Field: ‘label’
[16:03:37.663]   - Field: ‘local’
[16:03:37.663]   - Field: ‘owner’
[16:03:37.663]   - Field: ‘envir’
[16:03:37.663]   - Field: ‘workers’
[16:03:37.663]   - Field: ‘packages’
[16:03:37.663]   - Field: ‘gc’
[16:03:37.663]   - Field: ‘job’
[16:03:37.664]   - Field: ‘conditions’
[16:03:37.664]   - Field: ‘expr’
[16:03:37.664]   - Field: ‘uuid’
[16:03:37.664]   - Field: ‘seed’
[16:03:37.664]   - Field: ‘version’
[16:03:37.664]   - Field: ‘result’
[16:03:37.664]   - Field: ‘asynchronous’
[16:03:37.664]   - Field: ‘calls’
[16:03:37.664]   - Field: ‘globals’
[16:03:37.664]   - Field: ‘stdout’
[16:03:37.665]   - Field: ‘earlySignal’
[16:03:37.665]   - Field: ‘lazy’
[16:03:37.665]   - Field: ‘state’
[16:03:37.665] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:37.665] - Launch lazy future ...
[16:03:37.665] Packages needed by the future expression (n = 0): <none>
[16:03:37.665] Packages needed by future strategies (n = 0): <none>
[16:03:37.666] {
[16:03:37.666]     {
[16:03:37.666]         {
[16:03:37.666]             ...future.startTime <- base::Sys.time()
[16:03:37.666]             {
[16:03:37.666]                 {
[16:03:37.666]                   {
[16:03:37.666]                     {
[16:03:37.666]                       base::local({
[16:03:37.666]                         has_future <- base::requireNamespace("future", 
[16:03:37.666]                           quietly = TRUE)
[16:03:37.666]                         if (has_future) {
[16:03:37.666]                           ns <- base::getNamespace("future")
[16:03:37.666]                           version <- ns[[".package"]][["version"]]
[16:03:37.666]                           if (is.null(version)) 
[16:03:37.666]                             version <- utils::packageVersion("future")
[16:03:37.666]                         }
[16:03:37.666]                         else {
[16:03:37.666]                           version <- NULL
[16:03:37.666]                         }
[16:03:37.666]                         if (!has_future || version < "1.8.0") {
[16:03:37.666]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:37.666]                             "", base::R.version$version.string), 
[16:03:37.666]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:37.666]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:37.666]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:37.666]                               "release", "version")], collapse = " "), 
[16:03:37.666]                             hostname = base::Sys.info()[["nodename"]])
[16:03:37.666]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:37.666]                             info)
[16:03:37.666]                           info <- base::paste(info, collapse = "; ")
[16:03:37.666]                           if (!has_future) {
[16:03:37.666]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:37.666]                               info)
[16:03:37.666]                           }
[16:03:37.666]                           else {
[16:03:37.666]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:37.666]                               info, version)
[16:03:37.666]                           }
[16:03:37.666]                           base::stop(msg)
[16:03:37.666]                         }
[16:03:37.666]                       })
[16:03:37.666]                     }
[16:03:37.666]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:37.666]                     base::options(mc.cores = 1L)
[16:03:37.666]                   }
[16:03:37.666]                   options(future.plan = NULL)
[16:03:37.666]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:37.666]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:37.666]                 }
[16:03:37.666]                 ...future.workdir <- getwd()
[16:03:37.666]             }
[16:03:37.666]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:37.666]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:37.666]         }
[16:03:37.666]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:37.666]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:37.666]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:37.666]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:37.666]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:37.666]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:37.666]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:37.666]             base::names(...future.oldOptions))
[16:03:37.666]     }
[16:03:37.666]     if (FALSE) {
[16:03:37.666]     }
[16:03:37.666]     else {
[16:03:37.666]         if (TRUE) {
[16:03:37.666]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:37.666]                 open = "w")
[16:03:37.666]         }
[16:03:37.666]         else {
[16:03:37.666]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:37.666]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:37.666]         }
[16:03:37.666]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:37.666]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:37.666]             base::sink(type = "output", split = FALSE)
[16:03:37.666]             base::close(...future.stdout)
[16:03:37.666]         }, add = TRUE)
[16:03:37.666]     }
[16:03:37.666]     ...future.frame <- base::sys.nframe()
[16:03:37.666]     ...future.conditions <- base::list()
[16:03:37.666]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:37.666]     if (FALSE) {
[16:03:37.666]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:37.666]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:37.666]     }
[16:03:37.666]     ...future.result <- base::tryCatch({
[16:03:37.666]         base::withCallingHandlers({
[16:03:37.666]             ...future.value <- base::withVisible(base::local({
[16:03:37.666]                 withCallingHandlers({
[16:03:37.666]                   {
[16:03:37.666]                     do.call(function(...) {
[16:03:37.666]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:37.666]                       if (!identical(...future.globals.maxSize.org, 
[16:03:37.666]                         ...future.globals.maxSize)) {
[16:03:37.666]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:37.666]                         on.exit(options(oopts), add = TRUE)
[16:03:37.666]                       }
[16:03:37.666]                       {
[16:03:37.666]                         lapply(seq_along(...future.elements_ii), 
[16:03:37.666]                           FUN = function(jj) {
[16:03:37.666]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:37.666]                             ...future.FUN(...future.X_jj, ...)
[16:03:37.666]                           })
[16:03:37.666]                       }
[16:03:37.666]                     }, args = future.call.arguments)
[16:03:37.666]                   }
[16:03:37.666]                 }, immediateCondition = function(cond) {
[16:03:37.666]                   save_rds <- function (object, pathname, ...) 
[16:03:37.666]                   {
[16:03:37.666]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:37.666]                     if (file_test("-f", pathname_tmp)) {
[16:03:37.666]                       fi_tmp <- file.info(pathname_tmp)
[16:03:37.666]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:37.666]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:37.666]                         fi_tmp[["mtime"]])
[16:03:37.666]                     }
[16:03:37.666]                     tryCatch({
[16:03:37.666]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:37.666]                     }, error = function(ex) {
[16:03:37.666]                       msg <- conditionMessage(ex)
[16:03:37.666]                       fi_tmp <- file.info(pathname_tmp)
[16:03:37.666]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:37.666]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:37.666]                         fi_tmp[["mtime"]], msg)
[16:03:37.666]                       ex$message <- msg
[16:03:37.666]                       stop(ex)
[16:03:37.666]                     })
[16:03:37.666]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:37.666]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:37.666]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:37.666]                       fi_tmp <- file.info(pathname_tmp)
[16:03:37.666]                       fi <- file.info(pathname)
[16:03:37.666]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:37.666]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:37.666]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:37.666]                         fi[["size"]], fi[["mtime"]])
[16:03:37.666]                       stop(msg)
[16:03:37.666]                     }
[16:03:37.666]                     invisible(pathname)
[16:03:37.666]                   }
[16:03:37.666]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:37.666]                     rootPath = tempdir()) 
[16:03:37.666]                   {
[16:03:37.666]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:37.666]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:37.666]                       tmpdir = path, fileext = ".rds")
[16:03:37.666]                     save_rds(obj, file)
[16:03:37.666]                   }
[16:03:37.666]                   saveImmediateCondition(cond, path = "/tmp/Rtmpi1Xc62/.future/immediateConditions")
[16:03:37.666]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:37.666]                   {
[16:03:37.666]                     inherits <- base::inherits
[16:03:37.666]                     invokeRestart <- base::invokeRestart
[16:03:37.666]                     is.null <- base::is.null
[16:03:37.666]                     muffled <- FALSE
[16:03:37.666]                     if (inherits(cond, "message")) {
[16:03:37.666]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:37.666]                       if (muffled) 
[16:03:37.666]                         invokeRestart("muffleMessage")
[16:03:37.666]                     }
[16:03:37.666]                     else if (inherits(cond, "warning")) {
[16:03:37.666]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:37.666]                       if (muffled) 
[16:03:37.666]                         invokeRestart("muffleWarning")
[16:03:37.666]                     }
[16:03:37.666]                     else if (inherits(cond, "condition")) {
[16:03:37.666]                       if (!is.null(pattern)) {
[16:03:37.666]                         computeRestarts <- base::computeRestarts
[16:03:37.666]                         grepl <- base::grepl
[16:03:37.666]                         restarts <- computeRestarts(cond)
[16:03:37.666]                         for (restart in restarts) {
[16:03:37.666]                           name <- restart$name
[16:03:37.666]                           if (is.null(name)) 
[16:03:37.666]                             next
[16:03:37.666]                           if (!grepl(pattern, name)) 
[16:03:37.666]                             next
[16:03:37.666]                           invokeRestart(restart)
[16:03:37.666]                           muffled <- TRUE
[16:03:37.666]                           break
[16:03:37.666]                         }
[16:03:37.666]                       }
[16:03:37.666]                     }
[16:03:37.666]                     invisible(muffled)
[16:03:37.666]                   }
[16:03:37.666]                   muffleCondition(cond)
[16:03:37.666]                 })
[16:03:37.666]             }))
[16:03:37.666]             future::FutureResult(value = ...future.value$value, 
[16:03:37.666]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:37.666]                   ...future.rng), globalenv = if (FALSE) 
[16:03:37.666]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:37.666]                     ...future.globalenv.names))
[16:03:37.666]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:37.666]         }, condition = base::local({
[16:03:37.666]             c <- base::c
[16:03:37.666]             inherits <- base::inherits
[16:03:37.666]             invokeRestart <- base::invokeRestart
[16:03:37.666]             length <- base::length
[16:03:37.666]             list <- base::list
[16:03:37.666]             seq.int <- base::seq.int
[16:03:37.666]             signalCondition <- base::signalCondition
[16:03:37.666]             sys.calls <- base::sys.calls
[16:03:37.666]             `[[` <- base::`[[`
[16:03:37.666]             `+` <- base::`+`
[16:03:37.666]             `<<-` <- base::`<<-`
[16:03:37.666]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:37.666]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:37.666]                   3L)]
[16:03:37.666]             }
[16:03:37.666]             function(cond) {
[16:03:37.666]                 is_error <- inherits(cond, "error")
[16:03:37.666]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:37.666]                   NULL)
[16:03:37.666]                 if (is_error) {
[16:03:37.666]                   sessionInformation <- function() {
[16:03:37.666]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:37.666]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:37.666]                       search = base::search(), system = base::Sys.info())
[16:03:37.666]                   }
[16:03:37.666]                   ...future.conditions[[length(...future.conditions) + 
[16:03:37.666]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:37.666]                     cond$call), session = sessionInformation(), 
[16:03:37.666]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:37.666]                   signalCondition(cond)
[16:03:37.666]                 }
[16:03:37.666]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:37.666]                 "immediateCondition"))) {
[16:03:37.666]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:37.666]                   ...future.conditions[[length(...future.conditions) + 
[16:03:37.666]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:37.666]                   if (TRUE && !signal) {
[16:03:37.666]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:37.666]                     {
[16:03:37.666]                       inherits <- base::inherits
[16:03:37.666]                       invokeRestart <- base::invokeRestart
[16:03:37.666]                       is.null <- base::is.null
[16:03:37.666]                       muffled <- FALSE
[16:03:37.666]                       if (inherits(cond, "message")) {
[16:03:37.666]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:37.666]                         if (muffled) 
[16:03:37.666]                           invokeRestart("muffleMessage")
[16:03:37.666]                       }
[16:03:37.666]                       else if (inherits(cond, "warning")) {
[16:03:37.666]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:37.666]                         if (muffled) 
[16:03:37.666]                           invokeRestart("muffleWarning")
[16:03:37.666]                       }
[16:03:37.666]                       else if (inherits(cond, "condition")) {
[16:03:37.666]                         if (!is.null(pattern)) {
[16:03:37.666]                           computeRestarts <- base::computeRestarts
[16:03:37.666]                           grepl <- base::grepl
[16:03:37.666]                           restarts <- computeRestarts(cond)
[16:03:37.666]                           for (restart in restarts) {
[16:03:37.666]                             name <- restart$name
[16:03:37.666]                             if (is.null(name)) 
[16:03:37.666]                               next
[16:03:37.666]                             if (!grepl(pattern, name)) 
[16:03:37.666]                               next
[16:03:37.666]                             invokeRestart(restart)
[16:03:37.666]                             muffled <- TRUE
[16:03:37.666]                             break
[16:03:37.666]                           }
[16:03:37.666]                         }
[16:03:37.666]                       }
[16:03:37.666]                       invisible(muffled)
[16:03:37.666]                     }
[16:03:37.666]                     muffleCondition(cond, pattern = "^muffle")
[16:03:37.666]                   }
[16:03:37.666]                 }
[16:03:37.666]                 else {
[16:03:37.666]                   if (TRUE) {
[16:03:37.666]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:37.666]                     {
[16:03:37.666]                       inherits <- base::inherits
[16:03:37.666]                       invokeRestart <- base::invokeRestart
[16:03:37.666]                       is.null <- base::is.null
[16:03:37.666]                       muffled <- FALSE
[16:03:37.666]                       if (inherits(cond, "message")) {
[16:03:37.666]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:37.666]                         if (muffled) 
[16:03:37.666]                           invokeRestart("muffleMessage")
[16:03:37.666]                       }
[16:03:37.666]                       else if (inherits(cond, "warning")) {
[16:03:37.666]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:37.666]                         if (muffled) 
[16:03:37.666]                           invokeRestart("muffleWarning")
[16:03:37.666]                       }
[16:03:37.666]                       else if (inherits(cond, "condition")) {
[16:03:37.666]                         if (!is.null(pattern)) {
[16:03:37.666]                           computeRestarts <- base::computeRestarts
[16:03:37.666]                           grepl <- base::grepl
[16:03:37.666]                           restarts <- computeRestarts(cond)
[16:03:37.666]                           for (restart in restarts) {
[16:03:37.666]                             name <- restart$name
[16:03:37.666]                             if (is.null(name)) 
[16:03:37.666]                               next
[16:03:37.666]                             if (!grepl(pattern, name)) 
[16:03:37.666]                               next
[16:03:37.666]                             invokeRestart(restart)
[16:03:37.666]                             muffled <- TRUE
[16:03:37.666]                             break
[16:03:37.666]                           }
[16:03:37.666]                         }
[16:03:37.666]                       }
[16:03:37.666]                       invisible(muffled)
[16:03:37.666]                     }
[16:03:37.666]                     muffleCondition(cond, pattern = "^muffle")
[16:03:37.666]                   }
[16:03:37.666]                 }
[16:03:37.666]             }
[16:03:37.666]         }))
[16:03:37.666]     }, error = function(ex) {
[16:03:37.666]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:37.666]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:37.666]                 ...future.rng), started = ...future.startTime, 
[16:03:37.666]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:37.666]             version = "1.8"), class = "FutureResult")
[16:03:37.666]     }, finally = {
[16:03:37.666]         if (!identical(...future.workdir, getwd())) 
[16:03:37.666]             setwd(...future.workdir)
[16:03:37.666]         {
[16:03:37.666]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:37.666]                 ...future.oldOptions$nwarnings <- NULL
[16:03:37.666]             }
[16:03:37.666]             base::options(...future.oldOptions)
[16:03:37.666]             if (.Platform$OS.type == "windows") {
[16:03:37.666]                 old_names <- names(...future.oldEnvVars)
[16:03:37.666]                 envs <- base::Sys.getenv()
[16:03:37.666]                 names <- names(envs)
[16:03:37.666]                 common <- intersect(names, old_names)
[16:03:37.666]                 added <- setdiff(names, old_names)
[16:03:37.666]                 removed <- setdiff(old_names, names)
[16:03:37.666]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:37.666]                   envs[common]]
[16:03:37.666]                 NAMES <- toupper(changed)
[16:03:37.666]                 args <- list()
[16:03:37.666]                 for (kk in seq_along(NAMES)) {
[16:03:37.666]                   name <- changed[[kk]]
[16:03:37.666]                   NAME <- NAMES[[kk]]
[16:03:37.666]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:37.666]                     next
[16:03:37.666]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:37.666]                 }
[16:03:37.666]                 NAMES <- toupper(added)
[16:03:37.666]                 for (kk in seq_along(NAMES)) {
[16:03:37.666]                   name <- added[[kk]]
[16:03:37.666]                   NAME <- NAMES[[kk]]
[16:03:37.666]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:37.666]                     next
[16:03:37.666]                   args[[name]] <- ""
[16:03:37.666]                 }
[16:03:37.666]                 NAMES <- toupper(removed)
[16:03:37.666]                 for (kk in seq_along(NAMES)) {
[16:03:37.666]                   name <- removed[[kk]]
[16:03:37.666]                   NAME <- NAMES[[kk]]
[16:03:37.666]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:37.666]                     next
[16:03:37.666]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:37.666]                 }
[16:03:37.666]                 if (length(args) > 0) 
[16:03:37.666]                   base::do.call(base::Sys.setenv, args = args)
[16:03:37.666]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:37.666]             }
[16:03:37.666]             else {
[16:03:37.666]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:37.666]             }
[16:03:37.666]             {
[16:03:37.666]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:37.666]                   0L) {
[16:03:37.666]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:37.666]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:37.666]                   base::options(opts)
[16:03:37.666]                 }
[16:03:37.666]                 {
[16:03:37.666]                   {
[16:03:37.666]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:37.666]                     NULL
[16:03:37.666]                   }
[16:03:37.666]                   options(future.plan = NULL)
[16:03:37.666]                   if (is.na(NA_character_)) 
[16:03:37.666]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:37.666]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:37.666]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:37.666]                     envir = parent.frame()) 
[16:03:37.666]                   {
[16:03:37.666]                     default_workers <- missing(workers)
[16:03:37.666]                     if (is.function(workers)) 
[16:03:37.666]                       workers <- workers()
[16:03:37.666]                     workers <- structure(as.integer(workers), 
[16:03:37.666]                       class = class(workers))
[16:03:37.666]                     stop_if_not(is.finite(workers), workers >= 
[16:03:37.666]                       1L)
[16:03:37.666]                     if ((workers == 1L && !inherits(workers, 
[16:03:37.666]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:37.666]                       if (default_workers) 
[16:03:37.666]                         supportsMulticore(warn = TRUE)
[16:03:37.666]                       return(sequential(..., envir = envir))
[16:03:37.666]                     }
[16:03:37.666]                     oopts <- options(mc.cores = workers)
[16:03:37.666]                     on.exit(options(oopts))
[16:03:37.666]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:37.666]                       envir = envir)
[16:03:37.666]                     if (!future$lazy) 
[16:03:37.666]                       future <- run(future)
[16:03:37.666]                     invisible(future)
[16:03:37.666]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:37.666]                 }
[16:03:37.666]             }
[16:03:37.666]         }
[16:03:37.666]     })
[16:03:37.666]     if (TRUE) {
[16:03:37.666]         base::sink(type = "output", split = FALSE)
[16:03:37.666]         if (TRUE) {
[16:03:37.666]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:37.666]         }
[16:03:37.666]         else {
[16:03:37.666]             ...future.result["stdout"] <- base::list(NULL)
[16:03:37.666]         }
[16:03:37.666]         base::close(...future.stdout)
[16:03:37.666]         ...future.stdout <- NULL
[16:03:37.666]     }
[16:03:37.666]     ...future.result$conditions <- ...future.conditions
[16:03:37.666]     ...future.result$finished <- base::Sys.time()
[16:03:37.666]     ...future.result
[16:03:37.666] }
[16:03:37.668] assign_globals() ...
[16:03:37.668] List of 5
[16:03:37.668]  $ ...future.FUN            :function (x)  
[16:03:37.668]  $ future.call.arguments    : list()
[16:03:37.668]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:37.668]  $ ...future.elements_ii    :List of 1
[16:03:37.668]   ..$ : int 1
[16:03:37.668]  $ ...future.seeds_ii       : NULL
[16:03:37.668]  $ ...future.globals.maxSize: NULL
[16:03:37.668]  - attr(*, "where")=List of 5
[16:03:37.668]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:37.668]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:37.668]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:37.668]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:37.668]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:37.668]  - attr(*, "resolved")= logi FALSE
[16:03:37.668]  - attr(*, "total_size")= num 4720
[16:03:37.668]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:37.668]  - attr(*, "already-done")= logi TRUE
[16:03:37.673] - reassign environment for ‘...future.FUN’
[16:03:37.673] - copied ‘...future.FUN’ to environment
[16:03:37.673] - copied ‘future.call.arguments’ to environment
[16:03:37.674] - copied ‘...future.elements_ii’ to environment
[16:03:37.674] - copied ‘...future.seeds_ii’ to environment
[16:03:37.674] - copied ‘...future.globals.maxSize’ to environment
[16:03:37.674] assign_globals() ... done
[16:03:37.674] requestCore(): workers = 2
[16:03:37.676] MulticoreFuture started
[16:03:37.677] - Launch lazy future ... done
[16:03:37.677] run() for ‘MulticoreFuture’ ... done
[16:03:37.677] plan(): Setting new future strategy stack:
[16:03:37.678] Created future:
[16:03:37.678] List of future strategies:
[16:03:37.678] 1. sequential:
[16:03:37.678]    - args: function (..., envir = parent.frame())
[16:03:37.678]    - tweaked: FALSE
[16:03:37.678]    - call: NULL
[16:03:37.678] plan(): nbrOfWorkers() = 1
[16:03:37.678] MulticoreFuture:
[16:03:37.678] Label: ‘future_lapply-1’
[16:03:37.678] Expression:
[16:03:37.678] {
[16:03:37.678]     do.call(function(...) {
[16:03:37.678]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:37.678]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:37.678]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:37.678]             on.exit(options(oopts), add = TRUE)
[16:03:37.678]         }
[16:03:37.678]         {
[16:03:37.678]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:37.678]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:37.678]                 ...future.FUN(...future.X_jj, ...)
[16:03:37.678]             })
[16:03:37.678]         }
[16:03:37.678]     }, args = future.call.arguments)
[16:03:37.678] }
[16:03:37.678] Lazy evaluation: FALSE
[16:03:37.678] Asynchronous evaluation: TRUE
[16:03:37.678] Local evaluation: TRUE
[16:03:37.678] Environment: R_GlobalEnv
[16:03:37.678] Capture standard output: TRUE
[16:03:37.678] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:37.678] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:37.678] Packages: <none>
[16:03:37.678] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:37.678] Resolved: FALSE
[16:03:37.678] Value: <not collected>
[16:03:37.678] Conditions captured: <none>
[16:03:37.678] Early signaling: FALSE
[16:03:37.678] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:37.678] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:37.691] Chunk #1 of 2 ... DONE
[16:03:37.697] Chunk #2 of 2 ...
[16:03:37.698]  - Finding globals in 'X' for chunk #2 ...
[16:03:37.698] getGlobalsAndPackages() ...
[16:03:37.699] Searching for globals...
[16:03:37.700] 
[16:03:37.701] Searching for globals ... DONE
[16:03:37.701] - globals: [0] <none>
[16:03:37.702] getGlobalsAndPackages() ... DONE
[16:03:37.702]    + additional globals found: [n=0] 
[16:03:37.703]    + additional namespaces needed: [n=0] 
[16:03:37.703]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:37.703]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:37.704]  - seeds: <none>
[16:03:37.704]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:37.705] getGlobalsAndPackages() ...
[16:03:37.705] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:37.705] Resolving globals: FALSE
[16:03:37.706] Tweak future expression to call with '...' arguments ...
[16:03:37.706] {
[16:03:37.706]     do.call(function(...) {
[16:03:37.706]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:37.706]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:37.706]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:37.706]             on.exit(options(oopts), add = TRUE)
[16:03:37.706]         }
[16:03:37.706]         {
[16:03:37.706]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:37.706]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:37.706]                 ...future.FUN(...future.X_jj, ...)
[16:03:37.706]             })
[16:03:37.706]         }
[16:03:37.706]     }, args = future.call.arguments)
[16:03:37.706] }
[16:03:37.706] Tweak future expression to call with '...' arguments ... DONE
[16:03:37.707] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:37.707] 
[16:03:37.708] getGlobalsAndPackages() ... DONE
[16:03:37.709] run() for ‘Future’ ...
[16:03:37.709] - state: ‘created’
[16:03:37.710] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:37.715] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:37.715] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:37.715]   - Field: ‘label’
[16:03:37.716]   - Field: ‘local’
[16:03:37.716]   - Field: ‘owner’
[16:03:37.716]   - Field: ‘envir’
[16:03:37.716]   - Field: ‘workers’
[16:03:37.716]   - Field: ‘packages’
[16:03:37.716]   - Field: ‘gc’
[16:03:37.717]   - Field: ‘job’
[16:03:37.717]   - Field: ‘conditions’
[16:03:37.717]   - Field: ‘expr’
[16:03:37.717]   - Field: ‘uuid’
[16:03:37.717]   - Field: ‘seed’
[16:03:37.717]   - Field: ‘version’
[16:03:37.717]   - Field: ‘result’
[16:03:37.718]   - Field: ‘asynchronous’
[16:03:37.718]   - Field: ‘calls’
[16:03:37.718]   - Field: ‘globals’
[16:03:37.718]   - Field: ‘stdout’
[16:03:37.718]   - Field: ‘earlySignal’
[16:03:37.718]   - Field: ‘lazy’
[16:03:37.718]   - Field: ‘state’
[16:03:37.719] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:37.719] - Launch lazy future ...
[16:03:37.719] Packages needed by the future expression (n = 0): <none>
[16:03:37.719] Packages needed by future strategies (n = 0): <none>
[16:03:37.720] {
[16:03:37.720]     {
[16:03:37.720]         {
[16:03:37.720]             ...future.startTime <- base::Sys.time()
[16:03:37.720]             {
[16:03:37.720]                 {
[16:03:37.720]                   {
[16:03:37.720]                     {
[16:03:37.720]                       base::local({
[16:03:37.720]                         has_future <- base::requireNamespace("future", 
[16:03:37.720]                           quietly = TRUE)
[16:03:37.720]                         if (has_future) {
[16:03:37.720]                           ns <- base::getNamespace("future")
[16:03:37.720]                           version <- ns[[".package"]][["version"]]
[16:03:37.720]                           if (is.null(version)) 
[16:03:37.720]                             version <- utils::packageVersion("future")
[16:03:37.720]                         }
[16:03:37.720]                         else {
[16:03:37.720]                           version <- NULL
[16:03:37.720]                         }
[16:03:37.720]                         if (!has_future || version < "1.8.0") {
[16:03:37.720]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:37.720]                             "", base::R.version$version.string), 
[16:03:37.720]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:37.720]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:37.720]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:37.720]                               "release", "version")], collapse = " "), 
[16:03:37.720]                             hostname = base::Sys.info()[["nodename"]])
[16:03:37.720]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:37.720]                             info)
[16:03:37.720]                           info <- base::paste(info, collapse = "; ")
[16:03:37.720]                           if (!has_future) {
[16:03:37.720]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:37.720]                               info)
[16:03:37.720]                           }
[16:03:37.720]                           else {
[16:03:37.720]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:37.720]                               info, version)
[16:03:37.720]                           }
[16:03:37.720]                           base::stop(msg)
[16:03:37.720]                         }
[16:03:37.720]                       })
[16:03:37.720]                     }
[16:03:37.720]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:37.720]                     base::options(mc.cores = 1L)
[16:03:37.720]                   }
[16:03:37.720]                   options(future.plan = NULL)
[16:03:37.720]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:37.720]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:37.720]                 }
[16:03:37.720]                 ...future.workdir <- getwd()
[16:03:37.720]             }
[16:03:37.720]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:37.720]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:37.720]         }
[16:03:37.720]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:37.720]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:37.720]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:37.720]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:37.720]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:37.720]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:37.720]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:37.720]             base::names(...future.oldOptions))
[16:03:37.720]     }
[16:03:37.720]     if (FALSE) {
[16:03:37.720]     }
[16:03:37.720]     else {
[16:03:37.720]         if (TRUE) {
[16:03:37.720]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:37.720]                 open = "w")
[16:03:37.720]         }
[16:03:37.720]         else {
[16:03:37.720]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:37.720]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:37.720]         }
[16:03:37.720]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:37.720]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:37.720]             base::sink(type = "output", split = FALSE)
[16:03:37.720]             base::close(...future.stdout)
[16:03:37.720]         }, add = TRUE)
[16:03:37.720]     }
[16:03:37.720]     ...future.frame <- base::sys.nframe()
[16:03:37.720]     ...future.conditions <- base::list()
[16:03:37.720]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:37.720]     if (FALSE) {
[16:03:37.720]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:37.720]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:37.720]     }
[16:03:37.720]     ...future.result <- base::tryCatch({
[16:03:37.720]         base::withCallingHandlers({
[16:03:37.720]             ...future.value <- base::withVisible(base::local({
[16:03:37.720]                 withCallingHandlers({
[16:03:37.720]                   {
[16:03:37.720]                     do.call(function(...) {
[16:03:37.720]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:37.720]                       if (!identical(...future.globals.maxSize.org, 
[16:03:37.720]                         ...future.globals.maxSize)) {
[16:03:37.720]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:37.720]                         on.exit(options(oopts), add = TRUE)
[16:03:37.720]                       }
[16:03:37.720]                       {
[16:03:37.720]                         lapply(seq_along(...future.elements_ii), 
[16:03:37.720]                           FUN = function(jj) {
[16:03:37.720]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:37.720]                             ...future.FUN(...future.X_jj, ...)
[16:03:37.720]                           })
[16:03:37.720]                       }
[16:03:37.720]                     }, args = future.call.arguments)
[16:03:37.720]                   }
[16:03:37.720]                 }, immediateCondition = function(cond) {
[16:03:37.720]                   save_rds <- function (object, pathname, ...) 
[16:03:37.720]                   {
[16:03:37.720]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:37.720]                     if (file_test("-f", pathname_tmp)) {
[16:03:37.720]                       fi_tmp <- file.info(pathname_tmp)
[16:03:37.720]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:37.720]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:37.720]                         fi_tmp[["mtime"]])
[16:03:37.720]                     }
[16:03:37.720]                     tryCatch({
[16:03:37.720]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:37.720]                     }, error = function(ex) {
[16:03:37.720]                       msg <- conditionMessage(ex)
[16:03:37.720]                       fi_tmp <- file.info(pathname_tmp)
[16:03:37.720]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:37.720]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:37.720]                         fi_tmp[["mtime"]], msg)
[16:03:37.720]                       ex$message <- msg
[16:03:37.720]                       stop(ex)
[16:03:37.720]                     })
[16:03:37.720]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:37.720]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:37.720]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:37.720]                       fi_tmp <- file.info(pathname_tmp)
[16:03:37.720]                       fi <- file.info(pathname)
[16:03:37.720]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:37.720]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:37.720]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:37.720]                         fi[["size"]], fi[["mtime"]])
[16:03:37.720]                       stop(msg)
[16:03:37.720]                     }
[16:03:37.720]                     invisible(pathname)
[16:03:37.720]                   }
[16:03:37.720]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:37.720]                     rootPath = tempdir()) 
[16:03:37.720]                   {
[16:03:37.720]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:37.720]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:37.720]                       tmpdir = path, fileext = ".rds")
[16:03:37.720]                     save_rds(obj, file)
[16:03:37.720]                   }
[16:03:37.720]                   saveImmediateCondition(cond, path = "/tmp/Rtmpi1Xc62/.future/immediateConditions")
[16:03:37.720]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:37.720]                   {
[16:03:37.720]                     inherits <- base::inherits
[16:03:37.720]                     invokeRestart <- base::invokeRestart
[16:03:37.720]                     is.null <- base::is.null
[16:03:37.720]                     muffled <- FALSE
[16:03:37.720]                     if (inherits(cond, "message")) {
[16:03:37.720]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:37.720]                       if (muffled) 
[16:03:37.720]                         invokeRestart("muffleMessage")
[16:03:37.720]                     }
[16:03:37.720]                     else if (inherits(cond, "warning")) {
[16:03:37.720]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:37.720]                       if (muffled) 
[16:03:37.720]                         invokeRestart("muffleWarning")
[16:03:37.720]                     }
[16:03:37.720]                     else if (inherits(cond, "condition")) {
[16:03:37.720]                       if (!is.null(pattern)) {
[16:03:37.720]                         computeRestarts <- base::computeRestarts
[16:03:37.720]                         grepl <- base::grepl
[16:03:37.720]                         restarts <- computeRestarts(cond)
[16:03:37.720]                         for (restart in restarts) {
[16:03:37.720]                           name <- restart$name
[16:03:37.720]                           if (is.null(name)) 
[16:03:37.720]                             next
[16:03:37.720]                           if (!grepl(pattern, name)) 
[16:03:37.720]                             next
[16:03:37.720]                           invokeRestart(restart)
[16:03:37.720]                           muffled <- TRUE
[16:03:37.720]                           break
[16:03:37.720]                         }
[16:03:37.720]                       }
[16:03:37.720]                     }
[16:03:37.720]                     invisible(muffled)
[16:03:37.720]                   }
[16:03:37.720]                   muffleCondition(cond)
[16:03:37.720]                 })
[16:03:37.720]             }))
[16:03:37.720]             future::FutureResult(value = ...future.value$value, 
[16:03:37.720]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:37.720]                   ...future.rng), globalenv = if (FALSE) 
[16:03:37.720]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:37.720]                     ...future.globalenv.names))
[16:03:37.720]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:37.720]         }, condition = base::local({
[16:03:37.720]             c <- base::c
[16:03:37.720]             inherits <- base::inherits
[16:03:37.720]             invokeRestart <- base::invokeRestart
[16:03:37.720]             length <- base::length
[16:03:37.720]             list <- base::list
[16:03:37.720]             seq.int <- base::seq.int
[16:03:37.720]             signalCondition <- base::signalCondition
[16:03:37.720]             sys.calls <- base::sys.calls
[16:03:37.720]             `[[` <- base::`[[`
[16:03:37.720]             `+` <- base::`+`
[16:03:37.720]             `<<-` <- base::`<<-`
[16:03:37.720]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:37.720]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:37.720]                   3L)]
[16:03:37.720]             }
[16:03:37.720]             function(cond) {
[16:03:37.720]                 is_error <- inherits(cond, "error")
[16:03:37.720]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:37.720]                   NULL)
[16:03:37.720]                 if (is_error) {
[16:03:37.720]                   sessionInformation <- function() {
[16:03:37.720]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:37.720]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:37.720]                       search = base::search(), system = base::Sys.info())
[16:03:37.720]                   }
[16:03:37.720]                   ...future.conditions[[length(...future.conditions) + 
[16:03:37.720]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:37.720]                     cond$call), session = sessionInformation(), 
[16:03:37.720]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:37.720]                   signalCondition(cond)
[16:03:37.720]                 }
[16:03:37.720]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:37.720]                 "immediateCondition"))) {
[16:03:37.720]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:37.720]                   ...future.conditions[[length(...future.conditions) + 
[16:03:37.720]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:37.720]                   if (TRUE && !signal) {
[16:03:37.720]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:37.720]                     {
[16:03:37.720]                       inherits <- base::inherits
[16:03:37.720]                       invokeRestart <- base::invokeRestart
[16:03:37.720]                       is.null <- base::is.null
[16:03:37.720]                       muffled <- FALSE
[16:03:37.720]                       if (inherits(cond, "message")) {
[16:03:37.720]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:37.720]                         if (muffled) 
[16:03:37.720]                           invokeRestart("muffleMessage")
[16:03:37.720]                       }
[16:03:37.720]                       else if (inherits(cond, "warning")) {
[16:03:37.720]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:37.720]                         if (muffled) 
[16:03:37.720]                           invokeRestart("muffleWarning")
[16:03:37.720]                       }
[16:03:37.720]                       else if (inherits(cond, "condition")) {
[16:03:37.720]                         if (!is.null(pattern)) {
[16:03:37.720]                           computeRestarts <- base::computeRestarts
[16:03:37.720]                           grepl <- base::grepl
[16:03:37.720]                           restarts <- computeRestarts(cond)
[16:03:37.720]                           for (restart in restarts) {
[16:03:37.720]                             name <- restart$name
[16:03:37.720]                             if (is.null(name)) 
[16:03:37.720]                               next
[16:03:37.720]                             if (!grepl(pattern, name)) 
[16:03:37.720]                               next
[16:03:37.720]                             invokeRestart(restart)
[16:03:37.720]                             muffled <- TRUE
[16:03:37.720]                             break
[16:03:37.720]                           }
[16:03:37.720]                         }
[16:03:37.720]                       }
[16:03:37.720]                       invisible(muffled)
[16:03:37.720]                     }
[16:03:37.720]                     muffleCondition(cond, pattern = "^muffle")
[16:03:37.720]                   }
[16:03:37.720]                 }
[16:03:37.720]                 else {
[16:03:37.720]                   if (TRUE) {
[16:03:37.720]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:37.720]                     {
[16:03:37.720]                       inherits <- base::inherits
[16:03:37.720]                       invokeRestart <- base::invokeRestart
[16:03:37.720]                       is.null <- base::is.null
[16:03:37.720]                       muffled <- FALSE
[16:03:37.720]                       if (inherits(cond, "message")) {
[16:03:37.720]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:37.720]                         if (muffled) 
[16:03:37.720]                           invokeRestart("muffleMessage")
[16:03:37.720]                       }
[16:03:37.720]                       else if (inherits(cond, "warning")) {
[16:03:37.720]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:37.720]                         if (muffled) 
[16:03:37.720]                           invokeRestart("muffleWarning")
[16:03:37.720]                       }
[16:03:37.720]                       else if (inherits(cond, "condition")) {
[16:03:37.720]                         if (!is.null(pattern)) {
[16:03:37.720]                           computeRestarts <- base::computeRestarts
[16:03:37.720]                           grepl <- base::grepl
[16:03:37.720]                           restarts <- computeRestarts(cond)
[16:03:37.720]                           for (restart in restarts) {
[16:03:37.720]                             name <- restart$name
[16:03:37.720]                             if (is.null(name)) 
[16:03:37.720]                               next
[16:03:37.720]                             if (!grepl(pattern, name)) 
[16:03:37.720]                               next
[16:03:37.720]                             invokeRestart(restart)
[16:03:37.720]                             muffled <- TRUE
[16:03:37.720]                             break
[16:03:37.720]                           }
[16:03:37.720]                         }
[16:03:37.720]                       }
[16:03:37.720]                       invisible(muffled)
[16:03:37.720]                     }
[16:03:37.720]                     muffleCondition(cond, pattern = "^muffle")
[16:03:37.720]                   }
[16:03:37.720]                 }
[16:03:37.720]             }
[16:03:37.720]         }))
[16:03:37.720]     }, error = function(ex) {
[16:03:37.720]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:37.720]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:37.720]                 ...future.rng), started = ...future.startTime, 
[16:03:37.720]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:37.720]             version = "1.8"), class = "FutureResult")
[16:03:37.720]     }, finally = {
[16:03:37.720]         if (!identical(...future.workdir, getwd())) 
[16:03:37.720]             setwd(...future.workdir)
[16:03:37.720]         {
[16:03:37.720]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:37.720]                 ...future.oldOptions$nwarnings <- NULL
[16:03:37.720]             }
[16:03:37.720]             base::options(...future.oldOptions)
[16:03:37.720]             if (.Platform$OS.type == "windows") {
[16:03:37.720]                 old_names <- names(...future.oldEnvVars)
[16:03:37.720]                 envs <- base::Sys.getenv()
[16:03:37.720]                 names <- names(envs)
[16:03:37.720]                 common <- intersect(names, old_names)
[16:03:37.720]                 added <- setdiff(names, old_names)
[16:03:37.720]                 removed <- setdiff(old_names, names)
[16:03:37.720]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:37.720]                   envs[common]]
[16:03:37.720]                 NAMES <- toupper(changed)
[16:03:37.720]                 args <- list()
[16:03:37.720]                 for (kk in seq_along(NAMES)) {
[16:03:37.720]                   name <- changed[[kk]]
[16:03:37.720]                   NAME <- NAMES[[kk]]
[16:03:37.720]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:37.720]                     next
[16:03:37.720]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:37.720]                 }
[16:03:37.720]                 NAMES <- toupper(added)
[16:03:37.720]                 for (kk in seq_along(NAMES)) {
[16:03:37.720]                   name <- added[[kk]]
[16:03:37.720]                   NAME <- NAMES[[kk]]
[16:03:37.720]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:37.720]                     next
[16:03:37.720]                   args[[name]] <- ""
[16:03:37.720]                 }
[16:03:37.720]                 NAMES <- toupper(removed)
[16:03:37.720]                 for (kk in seq_along(NAMES)) {
[16:03:37.720]                   name <- removed[[kk]]
[16:03:37.720]                   NAME <- NAMES[[kk]]
[16:03:37.720]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:37.720]                     next
[16:03:37.720]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:37.720]                 }
[16:03:37.720]                 if (length(args) > 0) 
[16:03:37.720]                   base::do.call(base::Sys.setenv, args = args)
[16:03:37.720]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:37.720]             }
[16:03:37.720]             else {
[16:03:37.720]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:37.720]             }
[16:03:37.720]             {
[16:03:37.720]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:37.720]                   0L) {
[16:03:37.720]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:37.720]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:37.720]                   base::options(opts)
[16:03:37.720]                 }
[16:03:37.720]                 {
[16:03:37.720]                   {
[16:03:37.720]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:37.720]                     NULL
[16:03:37.720]                   }
[16:03:37.720]                   options(future.plan = NULL)
[16:03:37.720]                   if (is.na(NA_character_)) 
[16:03:37.720]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:37.720]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:37.720]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:37.720]                     envir = parent.frame()) 
[16:03:37.720]                   {
[16:03:37.720]                     default_workers <- missing(workers)
[16:03:37.720]                     if (is.function(workers)) 
[16:03:37.720]                       workers <- workers()
[16:03:37.720]                     workers <- structure(as.integer(workers), 
[16:03:37.720]                       class = class(workers))
[16:03:37.720]                     stop_if_not(is.finite(workers), workers >= 
[16:03:37.720]                       1L)
[16:03:37.720]                     if ((workers == 1L && !inherits(workers, 
[16:03:37.720]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:37.720]                       if (default_workers) 
[16:03:37.720]                         supportsMulticore(warn = TRUE)
[16:03:37.720]                       return(sequential(..., envir = envir))
[16:03:37.720]                     }
[16:03:37.720]                     oopts <- options(mc.cores = workers)
[16:03:37.720]                     on.exit(options(oopts))
[16:03:37.720]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:37.720]                       envir = envir)
[16:03:37.720]                     if (!future$lazy) 
[16:03:37.720]                       future <- run(future)
[16:03:37.720]                     invisible(future)
[16:03:37.720]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:37.720]                 }
[16:03:37.720]             }
[16:03:37.720]         }
[16:03:37.720]     })
[16:03:37.720]     if (TRUE) {
[16:03:37.720]         base::sink(type = "output", split = FALSE)
[16:03:37.720]         if (TRUE) {
[16:03:37.720]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:37.720]         }
[16:03:37.720]         else {
[16:03:37.720]             ...future.result["stdout"] <- base::list(NULL)
[16:03:37.720]         }
[16:03:37.720]         base::close(...future.stdout)
[16:03:37.720]         ...future.stdout <- NULL
[16:03:37.720]     }
[16:03:37.720]     ...future.result$conditions <- ...future.conditions
[16:03:37.720]     ...future.result$finished <- base::Sys.time()
[16:03:37.720]     ...future.result
[16:03:37.720] }
[16:03:37.723] assign_globals() ...
[16:03:37.723] List of 5
[16:03:37.723]  $ ...future.FUN            :function (x)  
[16:03:37.723]  $ future.call.arguments    : list()
[16:03:37.723]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:37.723]  $ ...future.elements_ii    :List of 1
[16:03:37.723]   ..$ : int 0
[16:03:37.723]  $ ...future.seeds_ii       : NULL
[16:03:37.723]  $ ...future.globals.maxSize: NULL
[16:03:37.723]  - attr(*, "where")=List of 5
[16:03:37.723]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:37.723]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:37.723]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:37.723]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:37.723]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:37.723]  - attr(*, "resolved")= logi FALSE
[16:03:37.723]  - attr(*, "total_size")= num 4720
[16:03:37.723]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:37.723]  - attr(*, "already-done")= logi TRUE
[16:03:37.729] - reassign environment for ‘...future.FUN’
[16:03:37.729] - copied ‘...future.FUN’ to environment
[16:03:37.729] - copied ‘future.call.arguments’ to environment
[16:03:37.730] - copied ‘...future.elements_ii’ to environment
[16:03:37.730] - copied ‘...future.seeds_ii’ to environment
[16:03:37.730] - copied ‘...future.globals.maxSize’ to environment
[16:03:37.730] assign_globals() ... done
[16:03:37.730] requestCore(): workers = 2
[16:03:37.732] MulticoreFuture started
[16:03:37.733] - Launch lazy future ... done
[16:03:37.733] run() for ‘MulticoreFuture’ ... done
[16:03:37.733] Created future:
[16:03:37.733] plan(): Setting new future strategy stack:
[16:03:37.734] List of future strategies:
[16:03:37.734] 1. sequential:
[16:03:37.734]    - args: function (..., envir = parent.frame())
[16:03:37.734]    - tweaked: FALSE
[16:03:37.734]    - call: NULL
[16:03:37.734] plan(): nbrOfWorkers() = 1
[16:03:37.737] plan(): Setting new future strategy stack:
[16:03:37.737] List of future strategies:
[16:03:37.737] 1. multicore:
[16:03:37.737]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:37.737]    - tweaked: FALSE
[16:03:37.737]    - call: plan(strategy)
[16:03:37.742] plan(): nbrOfWorkers() = 2
[16:03:37.733] MulticoreFuture:
[16:03:37.733] Label: ‘future_lapply-2’
[16:03:37.733] Expression:
[16:03:37.733] {
[16:03:37.733]     do.call(function(...) {
[16:03:37.733]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:37.733]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:37.733]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:37.733]             on.exit(options(oopts), add = TRUE)
[16:03:37.733]         }
[16:03:37.733]         {
[16:03:37.733]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:37.733]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:37.733]                 ...future.FUN(...future.X_jj, ...)
[16:03:37.733]             })
[16:03:37.733]         }
[16:03:37.733]     }, args = future.call.arguments)
[16:03:37.733] }
[16:03:37.733] Lazy evaluation: FALSE
[16:03:37.733] Asynchronous evaluation: TRUE
[16:03:37.733] Local evaluation: TRUE
[16:03:37.733] Environment: R_GlobalEnv
[16:03:37.733] Capture standard output: TRUE
[16:03:37.733] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:37.733] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:37.733] Packages: <none>
[16:03:37.733] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:37.733] Resolved: TRUE
[16:03:37.733] Value: <not collected>
[16:03:37.733] Conditions captured: <none>
[16:03:37.733] Early signaling: FALSE
[16:03:37.733] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:37.733] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:37.743] Chunk #2 of 2 ... DONE
[16:03:37.743] Launching 2 futures (chunks) ... DONE
[16:03:37.743] Resolving 2 futures (chunks) ...
[16:03:37.744] resolve() on list ...
[16:03:37.744]  recursive: 0
[16:03:37.744]  length: 2
[16:03:37.744] 
[16:03:37.754] Future #2
[16:03:37.755] result() for MulticoreFuture ...
[16:03:37.756] result() for MulticoreFuture ...
[16:03:37.756] result() for MulticoreFuture ... done
[16:03:37.756] result() for MulticoreFuture ... done
[16:03:37.756] result() for MulticoreFuture ...
[16:03:37.756] result() for MulticoreFuture ... done
[16:03:37.756] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:03:37.756] - nx: 2
[16:03:37.757] - relay: TRUE
[16:03:37.757] - stdout: TRUE
[16:03:37.757] - signal: TRUE
[16:03:37.757] - resignal: FALSE
[16:03:37.757] - force: TRUE
[16:03:37.757] - relayed: [n=2] FALSE, FALSE
[16:03:37.757] - queued futures: [n=2] FALSE, FALSE
[16:03:37.758]  - until=1
[16:03:37.758]  - relaying element #1
[16:03:37.758] - relayed: [n=2] FALSE, FALSE
[16:03:37.758] - queued futures: [n=2] FALSE, TRUE
[16:03:37.758] signalConditionsASAP(NULL, pos=2) ... done
[16:03:37.758]  length: 1 (resolved future 2)
[16:03:38.181] plan(): Setting new future strategy stack:
[16:03:38.181] List of future strategies:
[16:03:38.181] 1. multicore:
[16:03:38.181]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:38.181]    - tweaked: FALSE
[16:03:38.181]    - call: plan(strategy)
[16:03:38.190] plan(): nbrOfWorkers() = 2
[16:03:38.196] Future #1
[16:03:38.196] result() for MulticoreFuture ...
[16:03:38.197] result() for MulticoreFuture ...
[16:03:38.197] result() for MulticoreFuture ... done
[16:03:38.197] result() for MulticoreFuture ... done
[16:03:38.200] result() for MulticoreFuture ...
[16:03:38.200] result() for MulticoreFuture ... done
[16:03:38.200] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:03:38.200] - nx: 2
[16:03:38.201] - relay: TRUE
[16:03:38.201] - stdout: TRUE
[16:03:38.201] - signal: TRUE
[16:03:38.201] - resignal: FALSE
[16:03:38.201] - force: TRUE
[16:03:38.201] - relayed: [n=2] FALSE, FALSE
[16:03:38.202] - queued futures: [n=2] FALSE, TRUE
[16:03:38.202]  - until=1
[16:03:38.202]  - relaying element #1
[16:03:38.202] result() for MulticoreFuture ...
[16:03:38.202] result() for MulticoreFuture ... done
[16:03:38.202] result() for MulticoreFuture ...
[16:03:38.203] result() for MulticoreFuture ... done
[16:03:38.203] result() for MulticoreFuture ...
[16:03:38.203] result() for MulticoreFuture ... done
[16:03:38.203] result() for MulticoreFuture ...
[16:03:38.203] result() for MulticoreFuture ... done
[16:03:38.203] - relayed: [n=2] TRUE, FALSE
[16:03:38.203] - queued futures: [n=2] TRUE, TRUE
[16:03:38.204] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:03:38.204]  length: 0 (resolved future 1)
[16:03:38.204] Relaying remaining futures
[16:03:38.204] signalConditionsASAP(NULL, pos=0) ...
[16:03:38.204] - nx: 2
[16:03:38.204] - relay: TRUE
[16:03:38.204] - stdout: TRUE
[16:03:38.204] - signal: TRUE
[16:03:38.205] - resignal: FALSE
[16:03:38.205] - force: TRUE
[16:03:38.205] - relayed: [n=2] TRUE, FALSE
[16:03:38.205] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:38.205]  - relaying element #2
[16:03:38.205] result() for MulticoreFuture ...
[16:03:38.205] result() for MulticoreFuture ... done
[16:03:38.206] result() for MulticoreFuture ...
[16:03:38.206] result() for MulticoreFuture ... done
[16:03:38.206] result() for MulticoreFuture ...
[16:03:38.206] result() for MulticoreFuture ... done
[16:03:38.206] result() for MulticoreFuture ...
[16:03:38.206] result() for MulticoreFuture ... done
[16:03:38.206] - relayed: [n=2] TRUE, TRUE
[16:03:38.206] - queued futures: [n=2] TRUE, TRUE
[16:03:38.206] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[16:03:38.207] resolve() on list ... DONE
[16:03:38.207] result() for MulticoreFuture ...
[16:03:38.207] result() for MulticoreFuture ... done
[16:03:38.207] result() for MulticoreFuture ...
[16:03:38.207] result() for MulticoreFuture ... done
[16:03:38.207] result() for MulticoreFuture ...
[16:03:38.207] result() for MulticoreFuture ... done
[16:03:38.207] result() for MulticoreFuture ...
[16:03:38.208] result() for MulticoreFuture ... done
[16:03:38.208]  - Number of value chunks collected: 2
[16:03:38.208] Resolving 2 futures (chunks) ... DONE
[16:03:38.208] Reducing values from 2 chunks ...
[16:03:38.208]  - Number of values collected after concatenation: 2
[16:03:38.208]  - Number of values expected: 2
[16:03:38.208] Reducing values from 2 chunks ... DONE
[16:03:38.208] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[16:03:38.209] future_lapply() ...
[16:03:38.214] Number of chunks: 2
[16:03:38.214] getGlobalsAndPackagesXApply() ...
[16:03:38.214]  - future.globals: TRUE
[16:03:38.214] getGlobalsAndPackages() ...
[16:03:38.214] Searching for globals...
[16:03:38.216] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:03:38.216] Searching for globals ... DONE
[16:03:38.216] Resolving globals: FALSE
[16:03:38.216] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:03:38.217] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:03:38.217] - globals: [1] ‘FUN’
[16:03:38.217] 
[16:03:38.217] getGlobalsAndPackages() ... DONE
[16:03:38.217]  - globals found/used: [n=1] ‘FUN’
[16:03:38.217]  - needed namespaces: [n=0] 
[16:03:38.217] Finding globals ... DONE
[16:03:38.218]  - use_args: TRUE
[16:03:38.218]  - Getting '...' globals ...
[16:03:38.218] resolve() on list ...
[16:03:38.218]  recursive: 0
[16:03:38.218]  length: 1
[16:03:38.218]  elements: ‘...’
[16:03:38.218]  length: 0 (resolved future 1)
[16:03:38.218] resolve() on list ... DONE
[16:03:38.219]    - '...' content: [n=0] 
[16:03:38.219] List of 1
[16:03:38.219]  $ ...: list()
[16:03:38.219]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:38.219]  - attr(*, "where")=List of 1
[16:03:38.219]   ..$ ...:<environment: 0x55ed7851d628> 
[16:03:38.219]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:38.219]  - attr(*, "resolved")= logi TRUE
[16:03:38.219]  - attr(*, "total_size")= num NA
[16:03:38.221]  - Getting '...' globals ... DONE
[16:03:38.222] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:03:38.222] List of 2
[16:03:38.222]  $ ...future.FUN:function (x)  
[16:03:38.222]  $ ...          : list()
[16:03:38.222]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:38.222]  - attr(*, "where")=List of 2
[16:03:38.222]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:38.222]   ..$ ...          :<environment: 0x55ed7851d628> 
[16:03:38.222]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:38.222]  - attr(*, "resolved")= logi FALSE
[16:03:38.222]  - attr(*, "total_size")= num 4720
[16:03:38.224] Packages to be attached in all futures: [n=0] 
[16:03:38.225] getGlobalsAndPackagesXApply() ... DONE
[16:03:38.225] Number of futures (= number of chunks): 2
[16:03:38.225] Launching 2 futures (chunks) ...
[16:03:38.225] Chunk #1 of 2 ...
[16:03:38.225]  - Finding globals in 'X' for chunk #1 ...
[16:03:38.225] getGlobalsAndPackages() ...
[16:03:38.225] Searching for globals...
[16:03:38.226] 
[16:03:38.226] Searching for globals ... DONE
[16:03:38.226] - globals: [0] <none>
[16:03:38.226] getGlobalsAndPackages() ... DONE
[16:03:38.226]    + additional globals found: [n=0] 
[16:03:38.226]    + additional namespaces needed: [n=0] 
[16:03:38.227]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:38.228]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:38.228]  - seeds: <none>
[16:03:38.228]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:38.228] getGlobalsAndPackages() ...
[16:03:38.228] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:38.228] Resolving globals: FALSE
[16:03:38.228] Tweak future expression to call with '...' arguments ...
[16:03:38.228] {
[16:03:38.228]     do.call(function(...) {
[16:03:38.228]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:38.228]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:38.228]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:38.228]             on.exit(options(oopts), add = TRUE)
[16:03:38.228]         }
[16:03:38.228]         {
[16:03:38.228]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:38.228]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:38.228]                 ...future.FUN(...future.X_jj, ...)
[16:03:38.228]             })
[16:03:38.228]         }
[16:03:38.228]     }, args = future.call.arguments)
[16:03:38.228] }
[16:03:38.229] Tweak future expression to call with '...' arguments ... DONE
[16:03:38.229] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:38.229] 
[16:03:38.229] getGlobalsAndPackages() ... DONE
[16:03:38.230] run() for ‘Future’ ...
[16:03:38.230] - state: ‘created’
[16:03:38.230] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:38.233] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:38.234] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:38.234]   - Field: ‘label’
[16:03:38.234]   - Field: ‘local’
[16:03:38.234]   - Field: ‘owner’
[16:03:38.234]   - Field: ‘envir’
[16:03:38.234]   - Field: ‘workers’
[16:03:38.234]   - Field: ‘packages’
[16:03:38.234]   - Field: ‘gc’
[16:03:38.234]   - Field: ‘job’
[16:03:38.234]   - Field: ‘conditions’
[16:03:38.235]   - Field: ‘expr’
[16:03:38.235]   - Field: ‘uuid’
[16:03:38.235]   - Field: ‘seed’
[16:03:38.235]   - Field: ‘version’
[16:03:38.235]   - Field: ‘result’
[16:03:38.235]   - Field: ‘asynchronous’
[16:03:38.235]   - Field: ‘calls’
[16:03:38.235]   - Field: ‘globals’
[16:03:38.235]   - Field: ‘stdout’
[16:03:38.235]   - Field: ‘earlySignal’
[16:03:38.236]   - Field: ‘lazy’
[16:03:38.236]   - Field: ‘state’
[16:03:38.236] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:38.236] - Launch lazy future ...
[16:03:38.236] Packages needed by the future expression (n = 0): <none>
[16:03:38.236] Packages needed by future strategies (n = 0): <none>
[16:03:38.237] {
[16:03:38.237]     {
[16:03:38.237]         {
[16:03:38.237]             ...future.startTime <- base::Sys.time()
[16:03:38.237]             {
[16:03:38.237]                 {
[16:03:38.237]                   {
[16:03:38.237]                     {
[16:03:38.237]                       base::local({
[16:03:38.237]                         has_future <- base::requireNamespace("future", 
[16:03:38.237]                           quietly = TRUE)
[16:03:38.237]                         if (has_future) {
[16:03:38.237]                           ns <- base::getNamespace("future")
[16:03:38.237]                           version <- ns[[".package"]][["version"]]
[16:03:38.237]                           if (is.null(version)) 
[16:03:38.237]                             version <- utils::packageVersion("future")
[16:03:38.237]                         }
[16:03:38.237]                         else {
[16:03:38.237]                           version <- NULL
[16:03:38.237]                         }
[16:03:38.237]                         if (!has_future || version < "1.8.0") {
[16:03:38.237]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:38.237]                             "", base::R.version$version.string), 
[16:03:38.237]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:38.237]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:38.237]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:38.237]                               "release", "version")], collapse = " "), 
[16:03:38.237]                             hostname = base::Sys.info()[["nodename"]])
[16:03:38.237]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:38.237]                             info)
[16:03:38.237]                           info <- base::paste(info, collapse = "; ")
[16:03:38.237]                           if (!has_future) {
[16:03:38.237]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:38.237]                               info)
[16:03:38.237]                           }
[16:03:38.237]                           else {
[16:03:38.237]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:38.237]                               info, version)
[16:03:38.237]                           }
[16:03:38.237]                           base::stop(msg)
[16:03:38.237]                         }
[16:03:38.237]                       })
[16:03:38.237]                     }
[16:03:38.237]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:38.237]                     base::options(mc.cores = 1L)
[16:03:38.237]                   }
[16:03:38.237]                   options(future.plan = NULL)
[16:03:38.237]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:38.237]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:38.237]                 }
[16:03:38.237]                 ...future.workdir <- getwd()
[16:03:38.237]             }
[16:03:38.237]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:38.237]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:38.237]         }
[16:03:38.237]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:38.237]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:38.237]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:38.237]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:38.237]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:38.237]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:38.237]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:38.237]             base::names(...future.oldOptions))
[16:03:38.237]     }
[16:03:38.237]     if (TRUE) {
[16:03:38.237]     }
[16:03:38.237]     else {
[16:03:38.237]         if (NA) {
[16:03:38.237]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:38.237]                 open = "w")
[16:03:38.237]         }
[16:03:38.237]         else {
[16:03:38.237]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:38.237]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:38.237]         }
[16:03:38.237]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:38.237]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:38.237]             base::sink(type = "output", split = FALSE)
[16:03:38.237]             base::close(...future.stdout)
[16:03:38.237]         }, add = TRUE)
[16:03:38.237]     }
[16:03:38.237]     ...future.frame <- base::sys.nframe()
[16:03:38.237]     ...future.conditions <- base::list()
[16:03:38.237]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:38.237]     if (FALSE) {
[16:03:38.237]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:38.237]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:38.237]     }
[16:03:38.237]     ...future.result <- base::tryCatch({
[16:03:38.237]         base::withCallingHandlers({
[16:03:38.237]             ...future.value <- base::withVisible(base::local({
[16:03:38.237]                 withCallingHandlers({
[16:03:38.237]                   {
[16:03:38.237]                     do.call(function(...) {
[16:03:38.237]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:38.237]                       if (!identical(...future.globals.maxSize.org, 
[16:03:38.237]                         ...future.globals.maxSize)) {
[16:03:38.237]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:38.237]                         on.exit(options(oopts), add = TRUE)
[16:03:38.237]                       }
[16:03:38.237]                       {
[16:03:38.237]                         lapply(seq_along(...future.elements_ii), 
[16:03:38.237]                           FUN = function(jj) {
[16:03:38.237]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:38.237]                             ...future.FUN(...future.X_jj, ...)
[16:03:38.237]                           })
[16:03:38.237]                       }
[16:03:38.237]                     }, args = future.call.arguments)
[16:03:38.237]                   }
[16:03:38.237]                 }, immediateCondition = function(cond) {
[16:03:38.237]                   save_rds <- function (object, pathname, ...) 
[16:03:38.237]                   {
[16:03:38.237]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:38.237]                     if (file_test("-f", pathname_tmp)) {
[16:03:38.237]                       fi_tmp <- file.info(pathname_tmp)
[16:03:38.237]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:38.237]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:38.237]                         fi_tmp[["mtime"]])
[16:03:38.237]                     }
[16:03:38.237]                     tryCatch({
[16:03:38.237]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:38.237]                     }, error = function(ex) {
[16:03:38.237]                       msg <- conditionMessage(ex)
[16:03:38.237]                       fi_tmp <- file.info(pathname_tmp)
[16:03:38.237]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:38.237]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:38.237]                         fi_tmp[["mtime"]], msg)
[16:03:38.237]                       ex$message <- msg
[16:03:38.237]                       stop(ex)
[16:03:38.237]                     })
[16:03:38.237]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:38.237]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:38.237]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:38.237]                       fi_tmp <- file.info(pathname_tmp)
[16:03:38.237]                       fi <- file.info(pathname)
[16:03:38.237]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:38.237]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:38.237]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:38.237]                         fi[["size"]], fi[["mtime"]])
[16:03:38.237]                       stop(msg)
[16:03:38.237]                     }
[16:03:38.237]                     invisible(pathname)
[16:03:38.237]                   }
[16:03:38.237]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:38.237]                     rootPath = tempdir()) 
[16:03:38.237]                   {
[16:03:38.237]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:38.237]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:38.237]                       tmpdir = path, fileext = ".rds")
[16:03:38.237]                     save_rds(obj, file)
[16:03:38.237]                   }
[16:03:38.237]                   saveImmediateCondition(cond, path = "/tmp/Rtmpi1Xc62/.future/immediateConditions")
[16:03:38.237]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:38.237]                   {
[16:03:38.237]                     inherits <- base::inherits
[16:03:38.237]                     invokeRestart <- base::invokeRestart
[16:03:38.237]                     is.null <- base::is.null
[16:03:38.237]                     muffled <- FALSE
[16:03:38.237]                     if (inherits(cond, "message")) {
[16:03:38.237]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:38.237]                       if (muffled) 
[16:03:38.237]                         invokeRestart("muffleMessage")
[16:03:38.237]                     }
[16:03:38.237]                     else if (inherits(cond, "warning")) {
[16:03:38.237]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:38.237]                       if (muffled) 
[16:03:38.237]                         invokeRestart("muffleWarning")
[16:03:38.237]                     }
[16:03:38.237]                     else if (inherits(cond, "condition")) {
[16:03:38.237]                       if (!is.null(pattern)) {
[16:03:38.237]                         computeRestarts <- base::computeRestarts
[16:03:38.237]                         grepl <- base::grepl
[16:03:38.237]                         restarts <- computeRestarts(cond)
[16:03:38.237]                         for (restart in restarts) {
[16:03:38.237]                           name <- restart$name
[16:03:38.237]                           if (is.null(name)) 
[16:03:38.237]                             next
[16:03:38.237]                           if (!grepl(pattern, name)) 
[16:03:38.237]                             next
[16:03:38.237]                           invokeRestart(restart)
[16:03:38.237]                           muffled <- TRUE
[16:03:38.237]                           break
[16:03:38.237]                         }
[16:03:38.237]                       }
[16:03:38.237]                     }
[16:03:38.237]                     invisible(muffled)
[16:03:38.237]                   }
[16:03:38.237]                   muffleCondition(cond)
[16:03:38.237]                 })
[16:03:38.237]             }))
[16:03:38.237]             future::FutureResult(value = ...future.value$value, 
[16:03:38.237]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:38.237]                   ...future.rng), globalenv = if (FALSE) 
[16:03:38.237]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:38.237]                     ...future.globalenv.names))
[16:03:38.237]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:38.237]         }, condition = base::local({
[16:03:38.237]             c <- base::c
[16:03:38.237]             inherits <- base::inherits
[16:03:38.237]             invokeRestart <- base::invokeRestart
[16:03:38.237]             length <- base::length
[16:03:38.237]             list <- base::list
[16:03:38.237]             seq.int <- base::seq.int
[16:03:38.237]             signalCondition <- base::signalCondition
[16:03:38.237]             sys.calls <- base::sys.calls
[16:03:38.237]             `[[` <- base::`[[`
[16:03:38.237]             `+` <- base::`+`
[16:03:38.237]             `<<-` <- base::`<<-`
[16:03:38.237]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:38.237]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:38.237]                   3L)]
[16:03:38.237]             }
[16:03:38.237]             function(cond) {
[16:03:38.237]                 is_error <- inherits(cond, "error")
[16:03:38.237]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:38.237]                   NULL)
[16:03:38.237]                 if (is_error) {
[16:03:38.237]                   sessionInformation <- function() {
[16:03:38.237]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:38.237]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:38.237]                       search = base::search(), system = base::Sys.info())
[16:03:38.237]                   }
[16:03:38.237]                   ...future.conditions[[length(...future.conditions) + 
[16:03:38.237]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:38.237]                     cond$call), session = sessionInformation(), 
[16:03:38.237]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:38.237]                   signalCondition(cond)
[16:03:38.237]                 }
[16:03:38.237]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:38.237]                 "immediateCondition"))) {
[16:03:38.237]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:38.237]                   ...future.conditions[[length(...future.conditions) + 
[16:03:38.237]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:38.237]                   if (TRUE && !signal) {
[16:03:38.237]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:38.237]                     {
[16:03:38.237]                       inherits <- base::inherits
[16:03:38.237]                       invokeRestart <- base::invokeRestart
[16:03:38.237]                       is.null <- base::is.null
[16:03:38.237]                       muffled <- FALSE
[16:03:38.237]                       if (inherits(cond, "message")) {
[16:03:38.237]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:38.237]                         if (muffled) 
[16:03:38.237]                           invokeRestart("muffleMessage")
[16:03:38.237]                       }
[16:03:38.237]                       else if (inherits(cond, "warning")) {
[16:03:38.237]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:38.237]                         if (muffled) 
[16:03:38.237]                           invokeRestart("muffleWarning")
[16:03:38.237]                       }
[16:03:38.237]                       else if (inherits(cond, "condition")) {
[16:03:38.237]                         if (!is.null(pattern)) {
[16:03:38.237]                           computeRestarts <- base::computeRestarts
[16:03:38.237]                           grepl <- base::grepl
[16:03:38.237]                           restarts <- computeRestarts(cond)
[16:03:38.237]                           for (restart in restarts) {
[16:03:38.237]                             name <- restart$name
[16:03:38.237]                             if (is.null(name)) 
[16:03:38.237]                               next
[16:03:38.237]                             if (!grepl(pattern, name)) 
[16:03:38.237]                               next
[16:03:38.237]                             invokeRestart(restart)
[16:03:38.237]                             muffled <- TRUE
[16:03:38.237]                             break
[16:03:38.237]                           }
[16:03:38.237]                         }
[16:03:38.237]                       }
[16:03:38.237]                       invisible(muffled)
[16:03:38.237]                     }
[16:03:38.237]                     muffleCondition(cond, pattern = "^muffle")
[16:03:38.237]                   }
[16:03:38.237]                 }
[16:03:38.237]                 else {
[16:03:38.237]                   if (TRUE) {
[16:03:38.237]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:38.237]                     {
[16:03:38.237]                       inherits <- base::inherits
[16:03:38.237]                       invokeRestart <- base::invokeRestart
[16:03:38.237]                       is.null <- base::is.null
[16:03:38.237]                       muffled <- FALSE
[16:03:38.237]                       if (inherits(cond, "message")) {
[16:03:38.237]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:38.237]                         if (muffled) 
[16:03:38.237]                           invokeRestart("muffleMessage")
[16:03:38.237]                       }
[16:03:38.237]                       else if (inherits(cond, "warning")) {
[16:03:38.237]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:38.237]                         if (muffled) 
[16:03:38.237]                           invokeRestart("muffleWarning")
[16:03:38.237]                       }
[16:03:38.237]                       else if (inherits(cond, "condition")) {
[16:03:38.237]                         if (!is.null(pattern)) {
[16:03:38.237]                           computeRestarts <- base::computeRestarts
[16:03:38.237]                           grepl <- base::grepl
[16:03:38.237]                           restarts <- computeRestarts(cond)
[16:03:38.237]                           for (restart in restarts) {
[16:03:38.237]                             name <- restart$name
[16:03:38.237]                             if (is.null(name)) 
[16:03:38.237]                               next
[16:03:38.237]                             if (!grepl(pattern, name)) 
[16:03:38.237]                               next
[16:03:38.237]                             invokeRestart(restart)
[16:03:38.237]                             muffled <- TRUE
[16:03:38.237]                             break
[16:03:38.237]                           }
[16:03:38.237]                         }
[16:03:38.237]                       }
[16:03:38.237]                       invisible(muffled)
[16:03:38.237]                     }
[16:03:38.237]                     muffleCondition(cond, pattern = "^muffle")
[16:03:38.237]                   }
[16:03:38.237]                 }
[16:03:38.237]             }
[16:03:38.237]         }))
[16:03:38.237]     }, error = function(ex) {
[16:03:38.237]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:38.237]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:38.237]                 ...future.rng), started = ...future.startTime, 
[16:03:38.237]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:38.237]             version = "1.8"), class = "FutureResult")
[16:03:38.237]     }, finally = {
[16:03:38.237]         if (!identical(...future.workdir, getwd())) 
[16:03:38.237]             setwd(...future.workdir)
[16:03:38.237]         {
[16:03:38.237]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:38.237]                 ...future.oldOptions$nwarnings <- NULL
[16:03:38.237]             }
[16:03:38.237]             base::options(...future.oldOptions)
[16:03:38.237]             if (.Platform$OS.type == "windows") {
[16:03:38.237]                 old_names <- names(...future.oldEnvVars)
[16:03:38.237]                 envs <- base::Sys.getenv()
[16:03:38.237]                 names <- names(envs)
[16:03:38.237]                 common <- intersect(names, old_names)
[16:03:38.237]                 added <- setdiff(names, old_names)
[16:03:38.237]                 removed <- setdiff(old_names, names)
[16:03:38.237]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:38.237]                   envs[common]]
[16:03:38.237]                 NAMES <- toupper(changed)
[16:03:38.237]                 args <- list()
[16:03:38.237]                 for (kk in seq_along(NAMES)) {
[16:03:38.237]                   name <- changed[[kk]]
[16:03:38.237]                   NAME <- NAMES[[kk]]
[16:03:38.237]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:38.237]                     next
[16:03:38.237]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:38.237]                 }
[16:03:38.237]                 NAMES <- toupper(added)
[16:03:38.237]                 for (kk in seq_along(NAMES)) {
[16:03:38.237]                   name <- added[[kk]]
[16:03:38.237]                   NAME <- NAMES[[kk]]
[16:03:38.237]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:38.237]                     next
[16:03:38.237]                   args[[name]] <- ""
[16:03:38.237]                 }
[16:03:38.237]                 NAMES <- toupper(removed)
[16:03:38.237]                 for (kk in seq_along(NAMES)) {
[16:03:38.237]                   name <- removed[[kk]]
[16:03:38.237]                   NAME <- NAMES[[kk]]
[16:03:38.237]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:38.237]                     next
[16:03:38.237]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:38.237]                 }
[16:03:38.237]                 if (length(args) > 0) 
[16:03:38.237]                   base::do.call(base::Sys.setenv, args = args)
[16:03:38.237]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:38.237]             }
[16:03:38.237]             else {
[16:03:38.237]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:38.237]             }
[16:03:38.237]             {
[16:03:38.237]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:38.237]                   0L) {
[16:03:38.237]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:38.237]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:38.237]                   base::options(opts)
[16:03:38.237]                 }
[16:03:38.237]                 {
[16:03:38.237]                   {
[16:03:38.237]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:38.237]                     NULL
[16:03:38.237]                   }
[16:03:38.237]                   options(future.plan = NULL)
[16:03:38.237]                   if (is.na(NA_character_)) 
[16:03:38.237]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:38.237]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:38.237]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:38.237]                     envir = parent.frame()) 
[16:03:38.237]                   {
[16:03:38.237]                     default_workers <- missing(workers)
[16:03:38.237]                     if (is.function(workers)) 
[16:03:38.237]                       workers <- workers()
[16:03:38.237]                     workers <- structure(as.integer(workers), 
[16:03:38.237]                       class = class(workers))
[16:03:38.237]                     stop_if_not(is.finite(workers), workers >= 
[16:03:38.237]                       1L)
[16:03:38.237]                     if ((workers == 1L && !inherits(workers, 
[16:03:38.237]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:38.237]                       if (default_workers) 
[16:03:38.237]                         supportsMulticore(warn = TRUE)
[16:03:38.237]                       return(sequential(..., envir = envir))
[16:03:38.237]                     }
[16:03:38.237]                     oopts <- options(mc.cores = workers)
[16:03:38.237]                     on.exit(options(oopts))
[16:03:38.237]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:38.237]                       envir = envir)
[16:03:38.237]                     if (!future$lazy) 
[16:03:38.237]                       future <- run(future)
[16:03:38.237]                     invisible(future)
[16:03:38.237]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:38.237]                 }
[16:03:38.237]             }
[16:03:38.237]         }
[16:03:38.237]     })
[16:03:38.237]     if (FALSE) {
[16:03:38.237]         base::sink(type = "output", split = FALSE)
[16:03:38.237]         if (NA) {
[16:03:38.237]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:38.237]         }
[16:03:38.237]         else {
[16:03:38.237]             ...future.result["stdout"] <- base::list(NULL)
[16:03:38.237]         }
[16:03:38.237]         base::close(...future.stdout)
[16:03:38.237]         ...future.stdout <- NULL
[16:03:38.237]     }
[16:03:38.237]     ...future.result$conditions <- ...future.conditions
[16:03:38.237]     ...future.result$finished <- base::Sys.time()
[16:03:38.237]     ...future.result
[16:03:38.237] }
[16:03:38.239] assign_globals() ...
[16:03:38.239] List of 5
[16:03:38.239]  $ ...future.FUN            :function (x)  
[16:03:38.239]  $ future.call.arguments    : list()
[16:03:38.239]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:38.239]  $ ...future.elements_ii    :List of 1
[16:03:38.239]   ..$ : int 1
[16:03:38.239]  $ ...future.seeds_ii       : NULL
[16:03:38.239]  $ ...future.globals.maxSize: NULL
[16:03:38.239]  - attr(*, "where")=List of 5
[16:03:38.239]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:38.239]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:38.239]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:38.239]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:38.239]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:38.239]  - attr(*, "resolved")= logi FALSE
[16:03:38.239]  - attr(*, "total_size")= num 4720
[16:03:38.239]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:38.239]  - attr(*, "already-done")= logi TRUE
[16:03:38.244] - reassign environment for ‘...future.FUN’
[16:03:38.244] - copied ‘...future.FUN’ to environment
[16:03:38.244] - copied ‘future.call.arguments’ to environment
[16:03:38.244] - copied ‘...future.elements_ii’ to environment
[16:03:38.244] - copied ‘...future.seeds_ii’ to environment
[16:03:38.244] - copied ‘...future.globals.maxSize’ to environment
[16:03:38.244] assign_globals() ... done
[16:03:38.244] requestCore(): workers = 2
[16:03:38.246] MulticoreFuture started
[16:03:38.247] - Launch lazy future ... done
[16:03:38.247] run() for ‘MulticoreFuture’ ... done
[16:03:38.247] Created future:
[16:03:38.247] plan(): Setting new future strategy stack:
[16:03:38.248] List of future strategies:
[16:03:38.248] 1. sequential:
[16:03:38.248]    - args: function (..., envir = parent.frame())
[16:03:38.248]    - tweaked: FALSE
[16:03:38.248]    - call: NULL
[16:03:38.248] plan(): nbrOfWorkers() = 1
[16:03:38.247] MulticoreFuture:
[16:03:38.247] Label: ‘future_lapply-1’
[16:03:38.247] Expression:
[16:03:38.247] {
[16:03:38.247]     do.call(function(...) {
[16:03:38.247]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:38.247]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:38.247]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:38.247]             on.exit(options(oopts), add = TRUE)
[16:03:38.247]         }
[16:03:38.247]         {
[16:03:38.247]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:38.247]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:38.247]                 ...future.FUN(...future.X_jj, ...)
[16:03:38.247]             })
[16:03:38.247]         }
[16:03:38.247]     }, args = future.call.arguments)
[16:03:38.247] }
[16:03:38.247] Lazy evaluation: FALSE
[16:03:38.247] Asynchronous evaluation: TRUE
[16:03:38.247] Local evaluation: TRUE
[16:03:38.247] Environment: R_GlobalEnv
[16:03:38.247] Capture standard output: NA
[16:03:38.247] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:38.247] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:38.247] Packages: <none>
[16:03:38.247] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:38.247] Resolved: FALSE
[16:03:38.247] Value: <not collected>
[16:03:38.247] Conditions captured: <none>
[16:03:38.247] Early signaling: FALSE
[16:03:38.247] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:38.247] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:38.260] Chunk #1 of 2 ... DONE
[16:03:38.260] Chunk #2 of 2 ...
[16:03:38.261]  - Finding globals in 'X' for chunk #2 ...
[16:03:38.261] getGlobalsAndPackages() ...
[16:03:38.261] Searching for globals...
[16:03:38.262] 
[16:03:38.262] Searching for globals ... DONE
[16:03:38.262] - globals: [0] <none>
[16:03:38.262] getGlobalsAndPackages() ... DONE
[16:03:38.262]    + additional globals found: [n=0] 
[16:03:38.262]    + additional namespaces needed: [n=0] 
[16:03:38.262]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:38.263]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:38.263]  - seeds: <none>
[16:03:38.263]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:38.263] getGlobalsAndPackages() ...
[16:03:38.263] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:38.263] Resolving globals: FALSE
[16:03:38.264] Tweak future expression to call with '...' arguments ...
[16:03:38.264] {
[16:03:38.264]     do.call(function(...) {
[16:03:38.264]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:38.264]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:38.264]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:38.264]             on.exit(options(oopts), add = TRUE)
[16:03:38.264]         }
[16:03:38.264]         {
[16:03:38.264]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:38.264]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:38.264]                 ...future.FUN(...future.X_jj, ...)
[16:03:38.264]             })
[16:03:38.264]         }
[16:03:38.264]     }, args = future.call.arguments)
[16:03:38.264] }
[16:03:38.264] Tweak future expression to call with '...' arguments ... DONE
[16:03:38.265] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:38.265] 
[16:03:38.265] getGlobalsAndPackages() ... DONE
[16:03:38.266] run() for ‘Future’ ...
[16:03:38.266] - state: ‘created’
[16:03:38.266] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:38.271] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:38.272] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:38.272]   - Field: ‘label’
[16:03:38.272]   - Field: ‘local’
[16:03:38.272]   - Field: ‘owner’
[16:03:38.272]   - Field: ‘envir’
[16:03:38.272]   - Field: ‘workers’
[16:03:38.272]   - Field: ‘packages’
[16:03:38.273]   - Field: ‘gc’
[16:03:38.273]   - Field: ‘job’
[16:03:38.273]   - Field: ‘conditions’
[16:03:38.273]   - Field: ‘expr’
[16:03:38.273]   - Field: ‘uuid’
[16:03:38.273]   - Field: ‘seed’
[16:03:38.273]   - Field: ‘version’
[16:03:38.274]   - Field: ‘result’
[16:03:38.274]   - Field: ‘asynchronous’
[16:03:38.274]   - Field: ‘calls’
[16:03:38.277]   - Field: ‘globals’
[16:03:38.278]   - Field: ‘stdout’
[16:03:38.278]   - Field: ‘earlySignal’
[16:03:38.278]   - Field: ‘lazy’
[16:03:38.278]   - Field: ‘state’
[16:03:38.279] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:38.279] - Launch lazy future ...
[16:03:38.280] Packages needed by the future expression (n = 0): <none>
[16:03:38.280] Packages needed by future strategies (n = 0): <none>
[16:03:38.281] {
[16:03:38.281]     {
[16:03:38.281]         {
[16:03:38.281]             ...future.startTime <- base::Sys.time()
[16:03:38.281]             {
[16:03:38.281]                 {
[16:03:38.281]                   {
[16:03:38.281]                     {
[16:03:38.281]                       base::local({
[16:03:38.281]                         has_future <- base::requireNamespace("future", 
[16:03:38.281]                           quietly = TRUE)
[16:03:38.281]                         if (has_future) {
[16:03:38.281]                           ns <- base::getNamespace("future")
[16:03:38.281]                           version <- ns[[".package"]][["version"]]
[16:03:38.281]                           if (is.null(version)) 
[16:03:38.281]                             version <- utils::packageVersion("future")
[16:03:38.281]                         }
[16:03:38.281]                         else {
[16:03:38.281]                           version <- NULL
[16:03:38.281]                         }
[16:03:38.281]                         if (!has_future || version < "1.8.0") {
[16:03:38.281]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:38.281]                             "", base::R.version$version.string), 
[16:03:38.281]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:38.281]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:38.281]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:38.281]                               "release", "version")], collapse = " "), 
[16:03:38.281]                             hostname = base::Sys.info()[["nodename"]])
[16:03:38.281]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:38.281]                             info)
[16:03:38.281]                           info <- base::paste(info, collapse = "; ")
[16:03:38.281]                           if (!has_future) {
[16:03:38.281]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:38.281]                               info)
[16:03:38.281]                           }
[16:03:38.281]                           else {
[16:03:38.281]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:38.281]                               info, version)
[16:03:38.281]                           }
[16:03:38.281]                           base::stop(msg)
[16:03:38.281]                         }
[16:03:38.281]                       })
[16:03:38.281]                     }
[16:03:38.281]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:38.281]                     base::options(mc.cores = 1L)
[16:03:38.281]                   }
[16:03:38.281]                   options(future.plan = NULL)
[16:03:38.281]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:38.281]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:38.281]                 }
[16:03:38.281]                 ...future.workdir <- getwd()
[16:03:38.281]             }
[16:03:38.281]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:38.281]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:38.281]         }
[16:03:38.281]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:38.281]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:38.281]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:38.281]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:38.281]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:38.281]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:38.281]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:38.281]             base::names(...future.oldOptions))
[16:03:38.281]     }
[16:03:38.281]     if (TRUE) {
[16:03:38.281]     }
[16:03:38.281]     else {
[16:03:38.281]         if (NA) {
[16:03:38.281]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:38.281]                 open = "w")
[16:03:38.281]         }
[16:03:38.281]         else {
[16:03:38.281]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:38.281]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:38.281]         }
[16:03:38.281]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:38.281]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:38.281]             base::sink(type = "output", split = FALSE)
[16:03:38.281]             base::close(...future.stdout)
[16:03:38.281]         }, add = TRUE)
[16:03:38.281]     }
[16:03:38.281]     ...future.frame <- base::sys.nframe()
[16:03:38.281]     ...future.conditions <- base::list()
[16:03:38.281]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:38.281]     if (FALSE) {
[16:03:38.281]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:38.281]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:38.281]     }
[16:03:38.281]     ...future.result <- base::tryCatch({
[16:03:38.281]         base::withCallingHandlers({
[16:03:38.281]             ...future.value <- base::withVisible(base::local({
[16:03:38.281]                 withCallingHandlers({
[16:03:38.281]                   {
[16:03:38.281]                     do.call(function(...) {
[16:03:38.281]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:38.281]                       if (!identical(...future.globals.maxSize.org, 
[16:03:38.281]                         ...future.globals.maxSize)) {
[16:03:38.281]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:38.281]                         on.exit(options(oopts), add = TRUE)
[16:03:38.281]                       }
[16:03:38.281]                       {
[16:03:38.281]                         lapply(seq_along(...future.elements_ii), 
[16:03:38.281]                           FUN = function(jj) {
[16:03:38.281]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:38.281]                             ...future.FUN(...future.X_jj, ...)
[16:03:38.281]                           })
[16:03:38.281]                       }
[16:03:38.281]                     }, args = future.call.arguments)
[16:03:38.281]                   }
[16:03:38.281]                 }, immediateCondition = function(cond) {
[16:03:38.281]                   save_rds <- function (object, pathname, ...) 
[16:03:38.281]                   {
[16:03:38.281]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:38.281]                     if (file_test("-f", pathname_tmp)) {
[16:03:38.281]                       fi_tmp <- file.info(pathname_tmp)
[16:03:38.281]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:38.281]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:38.281]                         fi_tmp[["mtime"]])
[16:03:38.281]                     }
[16:03:38.281]                     tryCatch({
[16:03:38.281]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:38.281]                     }, error = function(ex) {
[16:03:38.281]                       msg <- conditionMessage(ex)
[16:03:38.281]                       fi_tmp <- file.info(pathname_tmp)
[16:03:38.281]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:38.281]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:38.281]                         fi_tmp[["mtime"]], msg)
[16:03:38.281]                       ex$message <- msg
[16:03:38.281]                       stop(ex)
[16:03:38.281]                     })
[16:03:38.281]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:38.281]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:38.281]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:38.281]                       fi_tmp <- file.info(pathname_tmp)
[16:03:38.281]                       fi <- file.info(pathname)
[16:03:38.281]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:38.281]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:38.281]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:38.281]                         fi[["size"]], fi[["mtime"]])
[16:03:38.281]                       stop(msg)
[16:03:38.281]                     }
[16:03:38.281]                     invisible(pathname)
[16:03:38.281]                   }
[16:03:38.281]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:38.281]                     rootPath = tempdir()) 
[16:03:38.281]                   {
[16:03:38.281]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:38.281]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:38.281]                       tmpdir = path, fileext = ".rds")
[16:03:38.281]                     save_rds(obj, file)
[16:03:38.281]                   }
[16:03:38.281]                   saveImmediateCondition(cond, path = "/tmp/Rtmpi1Xc62/.future/immediateConditions")
[16:03:38.281]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:38.281]                   {
[16:03:38.281]                     inherits <- base::inherits
[16:03:38.281]                     invokeRestart <- base::invokeRestart
[16:03:38.281]                     is.null <- base::is.null
[16:03:38.281]                     muffled <- FALSE
[16:03:38.281]                     if (inherits(cond, "message")) {
[16:03:38.281]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:38.281]                       if (muffled) 
[16:03:38.281]                         invokeRestart("muffleMessage")
[16:03:38.281]                     }
[16:03:38.281]                     else if (inherits(cond, "warning")) {
[16:03:38.281]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:38.281]                       if (muffled) 
[16:03:38.281]                         invokeRestart("muffleWarning")
[16:03:38.281]                     }
[16:03:38.281]                     else if (inherits(cond, "condition")) {
[16:03:38.281]                       if (!is.null(pattern)) {
[16:03:38.281]                         computeRestarts <- base::computeRestarts
[16:03:38.281]                         grepl <- base::grepl
[16:03:38.281]                         restarts <- computeRestarts(cond)
[16:03:38.281]                         for (restart in restarts) {
[16:03:38.281]                           name <- restart$name
[16:03:38.281]                           if (is.null(name)) 
[16:03:38.281]                             next
[16:03:38.281]                           if (!grepl(pattern, name)) 
[16:03:38.281]                             next
[16:03:38.281]                           invokeRestart(restart)
[16:03:38.281]                           muffled <- TRUE
[16:03:38.281]                           break
[16:03:38.281]                         }
[16:03:38.281]                       }
[16:03:38.281]                     }
[16:03:38.281]                     invisible(muffled)
[16:03:38.281]                   }
[16:03:38.281]                   muffleCondition(cond)
[16:03:38.281]                 })
[16:03:38.281]             }))
[16:03:38.281]             future::FutureResult(value = ...future.value$value, 
[16:03:38.281]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:38.281]                   ...future.rng), globalenv = if (FALSE) 
[16:03:38.281]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:38.281]                     ...future.globalenv.names))
[16:03:38.281]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:38.281]         }, condition = base::local({
[16:03:38.281]             c <- base::c
[16:03:38.281]             inherits <- base::inherits
[16:03:38.281]             invokeRestart <- base::invokeRestart
[16:03:38.281]             length <- base::length
[16:03:38.281]             list <- base::list
[16:03:38.281]             seq.int <- base::seq.int
[16:03:38.281]             signalCondition <- base::signalCondition
[16:03:38.281]             sys.calls <- base::sys.calls
[16:03:38.281]             `[[` <- base::`[[`
[16:03:38.281]             `+` <- base::`+`
[16:03:38.281]             `<<-` <- base::`<<-`
[16:03:38.281]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:38.281]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:38.281]                   3L)]
[16:03:38.281]             }
[16:03:38.281]             function(cond) {
[16:03:38.281]                 is_error <- inherits(cond, "error")
[16:03:38.281]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:38.281]                   NULL)
[16:03:38.281]                 if (is_error) {
[16:03:38.281]                   sessionInformation <- function() {
[16:03:38.281]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:38.281]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:38.281]                       search = base::search(), system = base::Sys.info())
[16:03:38.281]                   }
[16:03:38.281]                   ...future.conditions[[length(...future.conditions) + 
[16:03:38.281]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:38.281]                     cond$call), session = sessionInformation(), 
[16:03:38.281]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:38.281]                   signalCondition(cond)
[16:03:38.281]                 }
[16:03:38.281]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:38.281]                 "immediateCondition"))) {
[16:03:38.281]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:38.281]                   ...future.conditions[[length(...future.conditions) + 
[16:03:38.281]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:38.281]                   if (TRUE && !signal) {
[16:03:38.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:38.281]                     {
[16:03:38.281]                       inherits <- base::inherits
[16:03:38.281]                       invokeRestart <- base::invokeRestart
[16:03:38.281]                       is.null <- base::is.null
[16:03:38.281]                       muffled <- FALSE
[16:03:38.281]                       if (inherits(cond, "message")) {
[16:03:38.281]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:38.281]                         if (muffled) 
[16:03:38.281]                           invokeRestart("muffleMessage")
[16:03:38.281]                       }
[16:03:38.281]                       else if (inherits(cond, "warning")) {
[16:03:38.281]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:38.281]                         if (muffled) 
[16:03:38.281]                           invokeRestart("muffleWarning")
[16:03:38.281]                       }
[16:03:38.281]                       else if (inherits(cond, "condition")) {
[16:03:38.281]                         if (!is.null(pattern)) {
[16:03:38.281]                           computeRestarts <- base::computeRestarts
[16:03:38.281]                           grepl <- base::grepl
[16:03:38.281]                           restarts <- computeRestarts(cond)
[16:03:38.281]                           for (restart in restarts) {
[16:03:38.281]                             name <- restart$name
[16:03:38.281]                             if (is.null(name)) 
[16:03:38.281]                               next
[16:03:38.281]                             if (!grepl(pattern, name)) 
[16:03:38.281]                               next
[16:03:38.281]                             invokeRestart(restart)
[16:03:38.281]                             muffled <- TRUE
[16:03:38.281]                             break
[16:03:38.281]                           }
[16:03:38.281]                         }
[16:03:38.281]                       }
[16:03:38.281]                       invisible(muffled)
[16:03:38.281]                     }
[16:03:38.281]                     muffleCondition(cond, pattern = "^muffle")
[16:03:38.281]                   }
[16:03:38.281]                 }
[16:03:38.281]                 else {
[16:03:38.281]                   if (TRUE) {
[16:03:38.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:38.281]                     {
[16:03:38.281]                       inherits <- base::inherits
[16:03:38.281]                       invokeRestart <- base::invokeRestart
[16:03:38.281]                       is.null <- base::is.null
[16:03:38.281]                       muffled <- FALSE
[16:03:38.281]                       if (inherits(cond, "message")) {
[16:03:38.281]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:38.281]                         if (muffled) 
[16:03:38.281]                           invokeRestart("muffleMessage")
[16:03:38.281]                       }
[16:03:38.281]                       else if (inherits(cond, "warning")) {
[16:03:38.281]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:38.281]                         if (muffled) 
[16:03:38.281]                           invokeRestart("muffleWarning")
[16:03:38.281]                       }
[16:03:38.281]                       else if (inherits(cond, "condition")) {
[16:03:38.281]                         if (!is.null(pattern)) {
[16:03:38.281]                           computeRestarts <- base::computeRestarts
[16:03:38.281]                           grepl <- base::grepl
[16:03:38.281]                           restarts <- computeRestarts(cond)
[16:03:38.281]                           for (restart in restarts) {
[16:03:38.281]                             name <- restart$name
[16:03:38.281]                             if (is.null(name)) 
[16:03:38.281]                               next
[16:03:38.281]                             if (!grepl(pattern, name)) 
[16:03:38.281]                               next
[16:03:38.281]                             invokeRestart(restart)
[16:03:38.281]                             muffled <- TRUE
[16:03:38.281]                             break
[16:03:38.281]                           }
[16:03:38.281]                         }
[16:03:38.281]                       }
[16:03:38.281]                       invisible(muffled)
[16:03:38.281]                     }
[16:03:38.281]                     muffleCondition(cond, pattern = "^muffle")
[16:03:38.281]                   }
[16:03:38.281]                 }
[16:03:38.281]             }
[16:03:38.281]         }))
[16:03:38.281]     }, error = function(ex) {
[16:03:38.281]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:38.281]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:38.281]                 ...future.rng), started = ...future.startTime, 
[16:03:38.281]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:38.281]             version = "1.8"), class = "FutureResult")
[16:03:38.281]     }, finally = {
[16:03:38.281]         if (!identical(...future.workdir, getwd())) 
[16:03:38.281]             setwd(...future.workdir)
[16:03:38.281]         {
[16:03:38.281]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:38.281]                 ...future.oldOptions$nwarnings <- NULL
[16:03:38.281]             }
[16:03:38.281]             base::options(...future.oldOptions)
[16:03:38.281]             if (.Platform$OS.type == "windows") {
[16:03:38.281]                 old_names <- names(...future.oldEnvVars)
[16:03:38.281]                 envs <- base::Sys.getenv()
[16:03:38.281]                 names <- names(envs)
[16:03:38.281]                 common <- intersect(names, old_names)
[16:03:38.281]                 added <- setdiff(names, old_names)
[16:03:38.281]                 removed <- setdiff(old_names, names)
[16:03:38.281]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:38.281]                   envs[common]]
[16:03:38.281]                 NAMES <- toupper(changed)
[16:03:38.281]                 args <- list()
[16:03:38.281]                 for (kk in seq_along(NAMES)) {
[16:03:38.281]                   name <- changed[[kk]]
[16:03:38.281]                   NAME <- NAMES[[kk]]
[16:03:38.281]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:38.281]                     next
[16:03:38.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:38.281]                 }
[16:03:38.281]                 NAMES <- toupper(added)
[16:03:38.281]                 for (kk in seq_along(NAMES)) {
[16:03:38.281]                   name <- added[[kk]]
[16:03:38.281]                   NAME <- NAMES[[kk]]
[16:03:38.281]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:38.281]                     next
[16:03:38.281]                   args[[name]] <- ""
[16:03:38.281]                 }
[16:03:38.281]                 NAMES <- toupper(removed)
[16:03:38.281]                 for (kk in seq_along(NAMES)) {
[16:03:38.281]                   name <- removed[[kk]]
[16:03:38.281]                   NAME <- NAMES[[kk]]
[16:03:38.281]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:38.281]                     next
[16:03:38.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:38.281]                 }
[16:03:38.281]                 if (length(args) > 0) 
[16:03:38.281]                   base::do.call(base::Sys.setenv, args = args)
[16:03:38.281]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:38.281]             }
[16:03:38.281]             else {
[16:03:38.281]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:38.281]             }
[16:03:38.281]             {
[16:03:38.281]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:38.281]                   0L) {
[16:03:38.281]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:38.281]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:38.281]                   base::options(opts)
[16:03:38.281]                 }
[16:03:38.281]                 {
[16:03:38.281]                   {
[16:03:38.281]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:38.281]                     NULL
[16:03:38.281]                   }
[16:03:38.281]                   options(future.plan = NULL)
[16:03:38.281]                   if (is.na(NA_character_)) 
[16:03:38.281]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:38.281]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:38.281]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:38.281]                     envir = parent.frame()) 
[16:03:38.281]                   {
[16:03:38.281]                     default_workers <- missing(workers)
[16:03:38.281]                     if (is.function(workers)) 
[16:03:38.281]                       workers <- workers()
[16:03:38.281]                     workers <- structure(as.integer(workers), 
[16:03:38.281]                       class = class(workers))
[16:03:38.281]                     stop_if_not(is.finite(workers), workers >= 
[16:03:38.281]                       1L)
[16:03:38.281]                     if ((workers == 1L && !inherits(workers, 
[16:03:38.281]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:38.281]                       if (default_workers) 
[16:03:38.281]                         supportsMulticore(warn = TRUE)
[16:03:38.281]                       return(sequential(..., envir = envir))
[16:03:38.281]                     }
[16:03:38.281]                     oopts <- options(mc.cores = workers)
[16:03:38.281]                     on.exit(options(oopts))
[16:03:38.281]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:38.281]                       envir = envir)
[16:03:38.281]                     if (!future$lazy) 
[16:03:38.281]                       future <- run(future)
[16:03:38.281]                     invisible(future)
[16:03:38.281]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:38.281]                 }
[16:03:38.281]             }
[16:03:38.281]         }
[16:03:38.281]     })
[16:03:38.281]     if (FALSE) {
[16:03:38.281]         base::sink(type = "output", split = FALSE)
[16:03:38.281]         if (NA) {
[16:03:38.281]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:38.281]         }
[16:03:38.281]         else {
[16:03:38.281]             ...future.result["stdout"] <- base::list(NULL)
[16:03:38.281]         }
[16:03:38.281]         base::close(...future.stdout)
[16:03:38.281]         ...future.stdout <- NULL
[16:03:38.281]     }
[16:03:38.281]     ...future.result$conditions <- ...future.conditions
[16:03:38.281]     ...future.result$finished <- base::Sys.time()
[16:03:38.281]     ...future.result
[16:03:38.281] }
[16:03:38.284] assign_globals() ...
[16:03:38.284] List of 5
[16:03:38.284]  $ ...future.FUN            :function (x)  
[16:03:38.284]  $ future.call.arguments    : list()
[16:03:38.284]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:38.284]  $ ...future.elements_ii    :List of 1
[16:03:38.284]   ..$ : int 0
[16:03:38.284]  $ ...future.seeds_ii       : NULL
[16:03:38.284]  $ ...future.globals.maxSize: NULL
[16:03:38.284]  - attr(*, "where")=List of 5
[16:03:38.284]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:38.284]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:03:38.284]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:38.284]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:38.284]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:38.284]  - attr(*, "resolved")= logi FALSE
[16:03:38.284]  - attr(*, "total_size")= num 4720
[16:03:38.284]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:38.284]  - attr(*, "already-done")= logi TRUE
[16:03:38.292] - reassign environment for ‘...future.FUN’
[16:03:38.293] - copied ‘...future.FUN’ to environment
[16:03:38.293] - copied ‘future.call.arguments’ to environment
[16:03:38.293] - copied ‘...future.elements_ii’ to environment
[16:03:38.293] - copied ‘...future.seeds_ii’ to environment
[16:03:38.293] - copied ‘...future.globals.maxSize’ to environment
[16:03:38.293] assign_globals() ... done
[16:03:38.293] requestCore(): workers = 2
[16:03:38.296] MulticoreFuture started
[16:03:38.296] - Launch lazy future ... done
[16:03:38.296] run() for ‘MulticoreFuture’ ... done
[16:03:38.297] Created future:
[16:03:38.297] plan(): Setting new future strategy stack:
[16:03:38.297] List of future strategies:
[16:03:38.297] 1. sequential:
[16:03:38.297]    - args: function (..., envir = parent.frame())
[16:03:38.297]    - tweaked: FALSE
[16:03:38.297]    - call: NULL
[16:03:38.298] plan(): nbrOfWorkers() = 1
[16:03:38.300] plan(): Setting new future strategy stack:
[16:03:38.300] List of future strategies:
[16:03:38.300] 1. multicore:
[16:03:38.300]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:38.300]    - tweaked: FALSE
[16:03:38.300]    - call: plan(strategy)
[16:03:38.306] plan(): nbrOfWorkers() = 2
[16:03:38.297] MulticoreFuture:
[16:03:38.297] Label: ‘future_lapply-2’
[16:03:38.297] Expression:
[16:03:38.297] {
[16:03:38.297]     do.call(function(...) {
[16:03:38.297]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:38.297]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:38.297]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:38.297]             on.exit(options(oopts), add = TRUE)
[16:03:38.297]         }
[16:03:38.297]         {
[16:03:38.297]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:38.297]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:38.297]                 ...future.FUN(...future.X_jj, ...)
[16:03:38.297]             })
[16:03:38.297]         }
[16:03:38.297]     }, args = future.call.arguments)
[16:03:38.297] }
[16:03:38.297] Lazy evaluation: FALSE
[16:03:38.297] Asynchronous evaluation: TRUE
[16:03:38.297] Local evaluation: TRUE
[16:03:38.297] Environment: R_GlobalEnv
[16:03:38.297] Capture standard output: NA
[16:03:38.297] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:38.297] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:38.297] Packages: <none>
[16:03:38.297] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:38.297] Resolved: TRUE
[16:03:38.297] Value: <not collected>
[16:03:38.297] Conditions captured: <none>
[16:03:38.297] Early signaling: FALSE
[16:03:38.297] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:38.297] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:38.307] Chunk #2 of 2 ... DONE
[16:03:38.307] Launching 2 futures (chunks) ... DONE
[16:03:38.307] Resolving 2 futures (chunks) ...
[16:03:38.307] resolve() on list ...
[16:03:38.308]  recursive: 0
[16:03:38.308]  length: 2
[16:03:38.308] 
[16:03:38.318] Future #2
[16:03:38.319] result() for MulticoreFuture ...
[16:03:38.320] result() for MulticoreFuture ...
[16:03:38.320] result() for MulticoreFuture ... done
[16:03:38.320] result() for MulticoreFuture ... done
[16:03:38.320] result() for MulticoreFuture ...
[16:03:38.320] result() for MulticoreFuture ... done
[16:03:38.321] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:03:38.321] - nx: 2
[16:03:38.321] - relay: TRUE
[16:03:38.321] - stdout: TRUE
[16:03:38.321] - signal: TRUE
[16:03:38.321] - resignal: FALSE
[16:03:38.321] - force: TRUE
[16:03:38.321] - relayed: [n=2] FALSE, FALSE
[16:03:38.322] - queued futures: [n=2] FALSE, FALSE
[16:03:38.322]  - until=1
[16:03:38.322]  - relaying element #1
[16:03:38.322] - relayed: [n=2] FALSE, FALSE
[16:03:38.322] - queued futures: [n=2] FALSE, TRUE
[16:03:38.322] signalConditionsASAP(NULL, pos=2) ... done
[16:03:38.322]  length: 1 (resolved future 2)
[16:03:38.751] plan(): Setting new future strategy stack:
[16:03:38.751] List of future strategies:
[16:03:38.751] 1. multicore:
[16:03:38.751]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:38.751]    - tweaked: FALSE
[16:03:38.751]    - call: plan(strategy)
[16:03:38.756] plan(): nbrOfWorkers() = 2
[16:03:38.761] Future #1
[16:03:38.761] result() for MulticoreFuture ...
[16:03:38.762] result() for MulticoreFuture ...
[16:03:38.762] result() for MulticoreFuture ... done
[16:03:38.762] result() for MulticoreFuture ... done
[16:03:38.762] result() for MulticoreFuture ...
[16:03:38.762] result() for MulticoreFuture ... done
[16:03:38.762] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:03:38.762] - nx: 2
[16:03:38.763] - relay: TRUE
[16:03:38.763] - stdout: TRUE
[16:03:38.763] - signal: TRUE
[16:03:38.763] - resignal: FALSE
[16:03:38.763] - force: TRUE
[16:03:38.763] - relayed: [n=2] FALSE, FALSE
[16:03:38.763] - queued futures: [n=2] FALSE, TRUE
[16:03:38.763]  - until=1
[16:03:38.763]  - relaying element #1
[16:03:38.764] result() for MulticoreFuture ...
[16:03:38.764] result() for MulticoreFuture ... done
[16:03:38.764] result() for MulticoreFuture ...
[16:03:38.764] result() for MulticoreFuture ... done
[16:03:38.764] result() for MulticoreFuture ...
[16:03:38.764] result() for MulticoreFuture ... done
[16:03:38.764] result() for MulticoreFuture ...
[16:03:38.764] result() for MulticoreFuture ... done
[16:03:38.765] - relayed: [n=2] TRUE, FALSE
[16:03:38.765] - queued futures: [n=2] TRUE, TRUE
[16:03:38.765] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:03:38.765]  length: 0 (resolved future 1)
[16:03:38.765] Relaying remaining futures
[16:03:38.765] signalConditionsASAP(NULL, pos=0) ...
[16:03:38.765] - nx: 2
[16:03:38.765] - relay: TRUE
[16:03:38.765] - stdout: TRUE
[16:03:38.766] - signal: TRUE
[16:03:38.766] - resignal: FALSE
[16:03:38.766] - force: TRUE
[16:03:38.766] - relayed: [n=2] TRUE, FALSE
[16:03:38.766] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:38.766]  - relaying element #2
[16:03:38.766] result() for MulticoreFuture ...
[16:03:38.766] result() for MulticoreFuture ... done
[16:03:38.767] result() for MulticoreFuture ...
[16:03:38.767] result() for MulticoreFuture ... done
[16:03:38.767] result() for MulticoreFuture ...
[16:03:38.767] result() for MulticoreFuture ... done
[16:03:38.767] result() for MulticoreFuture ...
[16:03:38.767] result() for MulticoreFuture ... done
[16:03:38.767] - relayed: [n=2] TRUE, TRUE
[16:03:38.767] - queued futures: [n=2] TRUE, TRUE
[16:03:38.767] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[16:03:38.768] resolve() on list ... DONE
[16:03:38.768] result() for MulticoreFuture ...
[16:03:38.768] result() for MulticoreFuture ... done
[16:03:38.768] result() for MulticoreFuture ...
[16:03:38.768] result() for MulticoreFuture ... done
[16:03:38.768] result() for MulticoreFuture ...
[16:03:38.768] result() for MulticoreFuture ... done
[16:03:38.768] result() for MulticoreFuture ...
[16:03:38.769] result() for MulticoreFuture ... done
[16:03:38.769]  - Number of value chunks collected: 2
[16:03:38.769] Resolving 2 futures (chunks) ... DONE
[16:03:38.771] Reducing values from 2 chunks ...
[16:03:38.771]  - Number of values collected after concatenation: 2
[16:03:38.772]  - Number of values expected: 2
[16:03:38.772] Reducing values from 2 chunks ... DONE
[16:03:38.772] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[16:03:38.773] future_mapply() ...
[16:03:38.777] Number of chunks: 2
[16:03:38.777] getGlobalsAndPackagesXApply() ...
[16:03:38.777]  - future.globals: TRUE
[16:03:38.777] getGlobalsAndPackages() ...
[16:03:38.777] Searching for globals...
[16:03:38.780] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:03:38.780] Searching for globals ... DONE
[16:03:38.780] Resolving globals: FALSE
[16:03:38.780] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:03:38.781] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:03:38.781] - globals: [1] ‘FUN’
[16:03:38.781] 
[16:03:38.781] getGlobalsAndPackages() ... DONE
[16:03:38.781]  - globals found/used: [n=1] ‘FUN’
[16:03:38.781]  - needed namespaces: [n=0] 
[16:03:38.782] Finding globals ... DONE
[16:03:38.782] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:03:38.782] List of 2
[16:03:38.782]  $ ...future.FUN:function (x, y)  
[16:03:38.782]  $ MoreArgs     : NULL
[16:03:38.782]  - attr(*, "where")=List of 2
[16:03:38.782]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:38.782]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:03:38.782]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:38.782]  - attr(*, "resolved")= logi FALSE
[16:03:38.782]  - attr(*, "total_size")= num NA
[16:03:38.785] Packages to be attached in all futures: [n=0] 
[16:03:38.785] getGlobalsAndPackagesXApply() ... DONE
[16:03:38.785] Number of futures (= number of chunks): 2
[16:03:38.785] Launching 2 futures (chunks) ...
[16:03:38.785] Chunk #1 of 2 ...
[16:03:38.785]  - Finding globals in '...' for chunk #1 ...
[16:03:38.786] getGlobalsAndPackages() ...
[16:03:38.786] Searching for globals...
[16:03:38.786] 
[16:03:38.786] Searching for globals ... DONE
[16:03:38.786] - globals: [0] <none>
[16:03:38.786] getGlobalsAndPackages() ... DONE
[16:03:38.786]    + additional globals found: [n=0] 
[16:03:38.786]    + additional namespaces needed: [n=0] 
[16:03:38.786]  - Finding globals in '...' for chunk #1 ... DONE
[16:03:38.787]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:38.787]  - seeds: <none>
[16:03:38.787]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:38.787] getGlobalsAndPackages() ...
[16:03:38.787] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:38.787] Resolving globals: FALSE
[16:03:38.788] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:03:38.788] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:03:38.788] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:38.788] 
[16:03:38.788] getGlobalsAndPackages() ... DONE
[16:03:38.789] run() for ‘Future’ ...
[16:03:38.789] - state: ‘created’
[16:03:38.789] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:38.792] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:38.793] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:38.793]   - Field: ‘label’
[16:03:38.793]   - Field: ‘local’
[16:03:38.793]   - Field: ‘owner’
[16:03:38.793]   - Field: ‘envir’
[16:03:38.793]   - Field: ‘workers’
[16:03:38.793]   - Field: ‘packages’
[16:03:38.793]   - Field: ‘gc’
[16:03:38.793]   - Field: ‘job’
[16:03:38.793]   - Field: ‘conditions’
[16:03:38.794]   - Field: ‘expr’
[16:03:38.794]   - Field: ‘uuid’
[16:03:38.794]   - Field: ‘seed’
[16:03:38.794]   - Field: ‘version’
[16:03:38.794]   - Field: ‘result’
[16:03:38.794]   - Field: ‘asynchronous’
[16:03:38.794]   - Field: ‘calls’
[16:03:38.794]   - Field: ‘globals’
[16:03:38.794]   - Field: ‘stdout’
[16:03:38.794]   - Field: ‘earlySignal’
[16:03:38.795]   - Field: ‘lazy’
[16:03:38.795]   - Field: ‘state’
[16:03:38.795] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:38.795] - Launch lazy future ...
[16:03:38.795] Packages needed by the future expression (n = 0): <none>
[16:03:38.795] Packages needed by future strategies (n = 0): <none>
[16:03:38.796] {
[16:03:38.796]     {
[16:03:38.796]         {
[16:03:38.796]             ...future.startTime <- base::Sys.time()
[16:03:38.796]             {
[16:03:38.796]                 {
[16:03:38.796]                   {
[16:03:38.796]                     {
[16:03:38.796]                       base::local({
[16:03:38.796]                         has_future <- base::requireNamespace("future", 
[16:03:38.796]                           quietly = TRUE)
[16:03:38.796]                         if (has_future) {
[16:03:38.796]                           ns <- base::getNamespace("future")
[16:03:38.796]                           version <- ns[[".package"]][["version"]]
[16:03:38.796]                           if (is.null(version)) 
[16:03:38.796]                             version <- utils::packageVersion("future")
[16:03:38.796]                         }
[16:03:38.796]                         else {
[16:03:38.796]                           version <- NULL
[16:03:38.796]                         }
[16:03:38.796]                         if (!has_future || version < "1.8.0") {
[16:03:38.796]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:38.796]                             "", base::R.version$version.string), 
[16:03:38.796]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:38.796]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:38.796]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:38.796]                               "release", "version")], collapse = " "), 
[16:03:38.796]                             hostname = base::Sys.info()[["nodename"]])
[16:03:38.796]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:38.796]                             info)
[16:03:38.796]                           info <- base::paste(info, collapse = "; ")
[16:03:38.796]                           if (!has_future) {
[16:03:38.796]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:38.796]                               info)
[16:03:38.796]                           }
[16:03:38.796]                           else {
[16:03:38.796]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:38.796]                               info, version)
[16:03:38.796]                           }
[16:03:38.796]                           base::stop(msg)
[16:03:38.796]                         }
[16:03:38.796]                       })
[16:03:38.796]                     }
[16:03:38.796]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:38.796]                     base::options(mc.cores = 1L)
[16:03:38.796]                   }
[16:03:38.796]                   options(future.plan = NULL)
[16:03:38.796]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:38.796]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:38.796]                 }
[16:03:38.796]                 ...future.workdir <- getwd()
[16:03:38.796]             }
[16:03:38.796]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:38.796]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:38.796]         }
[16:03:38.796]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:38.796]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:38.796]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:38.796]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:38.796]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:38.796]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:38.796]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:38.796]             base::names(...future.oldOptions))
[16:03:38.796]     }
[16:03:38.796]     if (FALSE) {
[16:03:38.796]     }
[16:03:38.796]     else {
[16:03:38.796]         if (FALSE) {
[16:03:38.796]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:38.796]                 open = "w")
[16:03:38.796]         }
[16:03:38.796]         else {
[16:03:38.796]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:38.796]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:38.796]         }
[16:03:38.796]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:38.796]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:38.796]             base::sink(type = "output", split = FALSE)
[16:03:38.796]             base::close(...future.stdout)
[16:03:38.796]         }, add = TRUE)
[16:03:38.796]     }
[16:03:38.796]     ...future.frame <- base::sys.nframe()
[16:03:38.796]     ...future.conditions <- base::list()
[16:03:38.796]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:38.796]     if (FALSE) {
[16:03:38.796]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:38.796]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:38.796]     }
[16:03:38.796]     ...future.result <- base::tryCatch({
[16:03:38.796]         base::withCallingHandlers({
[16:03:38.796]             ...future.value <- base::withVisible(base::local({
[16:03:38.796]                 withCallingHandlers({
[16:03:38.796]                   {
[16:03:38.796]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:38.796]                     if (!identical(...future.globals.maxSize.org, 
[16:03:38.796]                       ...future.globals.maxSize)) {
[16:03:38.796]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:38.796]                       on.exit(options(oopts), add = TRUE)
[16:03:38.796]                     }
[16:03:38.796]                     {
[16:03:38.796]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:38.796]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:03:38.796]                         USE.NAMES = FALSE)
[16:03:38.796]                       do.call(mapply, args = args)
[16:03:38.796]                     }
[16:03:38.796]                   }
[16:03:38.796]                 }, immediateCondition = function(cond) {
[16:03:38.796]                   save_rds <- function (object, pathname, ...) 
[16:03:38.796]                   {
[16:03:38.796]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:38.796]                     if (file_test("-f", pathname_tmp)) {
[16:03:38.796]                       fi_tmp <- file.info(pathname_tmp)
[16:03:38.796]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:38.796]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:38.796]                         fi_tmp[["mtime"]])
[16:03:38.796]                     }
[16:03:38.796]                     tryCatch({
[16:03:38.796]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:38.796]                     }, error = function(ex) {
[16:03:38.796]                       msg <- conditionMessage(ex)
[16:03:38.796]                       fi_tmp <- file.info(pathname_tmp)
[16:03:38.796]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:38.796]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:38.796]                         fi_tmp[["mtime"]], msg)
[16:03:38.796]                       ex$message <- msg
[16:03:38.796]                       stop(ex)
[16:03:38.796]                     })
[16:03:38.796]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:38.796]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:38.796]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:38.796]                       fi_tmp <- file.info(pathname_tmp)
[16:03:38.796]                       fi <- file.info(pathname)
[16:03:38.796]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:38.796]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:38.796]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:38.796]                         fi[["size"]], fi[["mtime"]])
[16:03:38.796]                       stop(msg)
[16:03:38.796]                     }
[16:03:38.796]                     invisible(pathname)
[16:03:38.796]                   }
[16:03:38.796]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:38.796]                     rootPath = tempdir()) 
[16:03:38.796]                   {
[16:03:38.796]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:38.796]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:38.796]                       tmpdir = path, fileext = ".rds")
[16:03:38.796]                     save_rds(obj, file)
[16:03:38.796]                   }
[16:03:38.796]                   saveImmediateCondition(cond, path = "/tmp/Rtmpi1Xc62/.future/immediateConditions")
[16:03:38.796]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:38.796]                   {
[16:03:38.796]                     inherits <- base::inherits
[16:03:38.796]                     invokeRestart <- base::invokeRestart
[16:03:38.796]                     is.null <- base::is.null
[16:03:38.796]                     muffled <- FALSE
[16:03:38.796]                     if (inherits(cond, "message")) {
[16:03:38.796]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:38.796]                       if (muffled) 
[16:03:38.796]                         invokeRestart("muffleMessage")
[16:03:38.796]                     }
[16:03:38.796]                     else if (inherits(cond, "warning")) {
[16:03:38.796]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:38.796]                       if (muffled) 
[16:03:38.796]                         invokeRestart("muffleWarning")
[16:03:38.796]                     }
[16:03:38.796]                     else if (inherits(cond, "condition")) {
[16:03:38.796]                       if (!is.null(pattern)) {
[16:03:38.796]                         computeRestarts <- base::computeRestarts
[16:03:38.796]                         grepl <- base::grepl
[16:03:38.796]                         restarts <- computeRestarts(cond)
[16:03:38.796]                         for (restart in restarts) {
[16:03:38.796]                           name <- restart$name
[16:03:38.796]                           if (is.null(name)) 
[16:03:38.796]                             next
[16:03:38.796]                           if (!grepl(pattern, name)) 
[16:03:38.796]                             next
[16:03:38.796]                           invokeRestart(restart)
[16:03:38.796]                           muffled <- TRUE
[16:03:38.796]                           break
[16:03:38.796]                         }
[16:03:38.796]                       }
[16:03:38.796]                     }
[16:03:38.796]                     invisible(muffled)
[16:03:38.796]                   }
[16:03:38.796]                   muffleCondition(cond)
[16:03:38.796]                 })
[16:03:38.796]             }))
[16:03:38.796]             future::FutureResult(value = ...future.value$value, 
[16:03:38.796]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:38.796]                   ...future.rng), globalenv = if (FALSE) 
[16:03:38.796]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:38.796]                     ...future.globalenv.names))
[16:03:38.796]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:38.796]         }, condition = base::local({
[16:03:38.796]             c <- base::c
[16:03:38.796]             inherits <- base::inherits
[16:03:38.796]             invokeRestart <- base::invokeRestart
[16:03:38.796]             length <- base::length
[16:03:38.796]             list <- base::list
[16:03:38.796]             seq.int <- base::seq.int
[16:03:38.796]             signalCondition <- base::signalCondition
[16:03:38.796]             sys.calls <- base::sys.calls
[16:03:38.796]             `[[` <- base::`[[`
[16:03:38.796]             `+` <- base::`+`
[16:03:38.796]             `<<-` <- base::`<<-`
[16:03:38.796]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:38.796]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:38.796]                   3L)]
[16:03:38.796]             }
[16:03:38.796]             function(cond) {
[16:03:38.796]                 is_error <- inherits(cond, "error")
[16:03:38.796]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:38.796]                   NULL)
[16:03:38.796]                 if (is_error) {
[16:03:38.796]                   sessionInformation <- function() {
[16:03:38.796]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:38.796]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:38.796]                       search = base::search(), system = base::Sys.info())
[16:03:38.796]                   }
[16:03:38.796]                   ...future.conditions[[length(...future.conditions) + 
[16:03:38.796]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:38.796]                     cond$call), session = sessionInformation(), 
[16:03:38.796]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:38.796]                   signalCondition(cond)
[16:03:38.796]                 }
[16:03:38.796]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:38.796]                 "immediateCondition"))) {
[16:03:38.796]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:38.796]                   ...future.conditions[[length(...future.conditions) + 
[16:03:38.796]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:38.796]                   if (TRUE && !signal) {
[16:03:38.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:38.796]                     {
[16:03:38.796]                       inherits <- base::inherits
[16:03:38.796]                       invokeRestart <- base::invokeRestart
[16:03:38.796]                       is.null <- base::is.null
[16:03:38.796]                       muffled <- FALSE
[16:03:38.796]                       if (inherits(cond, "message")) {
[16:03:38.796]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:38.796]                         if (muffled) 
[16:03:38.796]                           invokeRestart("muffleMessage")
[16:03:38.796]                       }
[16:03:38.796]                       else if (inherits(cond, "warning")) {
[16:03:38.796]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:38.796]                         if (muffled) 
[16:03:38.796]                           invokeRestart("muffleWarning")
[16:03:38.796]                       }
[16:03:38.796]                       else if (inherits(cond, "condition")) {
[16:03:38.796]                         if (!is.null(pattern)) {
[16:03:38.796]                           computeRestarts <- base::computeRestarts
[16:03:38.796]                           grepl <- base::grepl
[16:03:38.796]                           restarts <- computeRestarts(cond)
[16:03:38.796]                           for (restart in restarts) {
[16:03:38.796]                             name <- restart$name
[16:03:38.796]                             if (is.null(name)) 
[16:03:38.796]                               next
[16:03:38.796]                             if (!grepl(pattern, name)) 
[16:03:38.796]                               next
[16:03:38.796]                             invokeRestart(restart)
[16:03:38.796]                             muffled <- TRUE
[16:03:38.796]                             break
[16:03:38.796]                           }
[16:03:38.796]                         }
[16:03:38.796]                       }
[16:03:38.796]                       invisible(muffled)
[16:03:38.796]                     }
[16:03:38.796]                     muffleCondition(cond, pattern = "^muffle")
[16:03:38.796]                   }
[16:03:38.796]                 }
[16:03:38.796]                 else {
[16:03:38.796]                   if (TRUE) {
[16:03:38.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:38.796]                     {
[16:03:38.796]                       inherits <- base::inherits
[16:03:38.796]                       invokeRestart <- base::invokeRestart
[16:03:38.796]                       is.null <- base::is.null
[16:03:38.796]                       muffled <- FALSE
[16:03:38.796]                       if (inherits(cond, "message")) {
[16:03:38.796]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:38.796]                         if (muffled) 
[16:03:38.796]                           invokeRestart("muffleMessage")
[16:03:38.796]                       }
[16:03:38.796]                       else if (inherits(cond, "warning")) {
[16:03:38.796]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:38.796]                         if (muffled) 
[16:03:38.796]                           invokeRestart("muffleWarning")
[16:03:38.796]                       }
[16:03:38.796]                       else if (inherits(cond, "condition")) {
[16:03:38.796]                         if (!is.null(pattern)) {
[16:03:38.796]                           computeRestarts <- base::computeRestarts
[16:03:38.796]                           grepl <- base::grepl
[16:03:38.796]                           restarts <- computeRestarts(cond)
[16:03:38.796]                           for (restart in restarts) {
[16:03:38.796]                             name <- restart$name
[16:03:38.796]                             if (is.null(name)) 
[16:03:38.796]                               next
[16:03:38.796]                             if (!grepl(pattern, name)) 
[16:03:38.796]                               next
[16:03:38.796]                             invokeRestart(restart)
[16:03:38.796]                             muffled <- TRUE
[16:03:38.796]                             break
[16:03:38.796]                           }
[16:03:38.796]                         }
[16:03:38.796]                       }
[16:03:38.796]                       invisible(muffled)
[16:03:38.796]                     }
[16:03:38.796]                     muffleCondition(cond, pattern = "^muffle")
[16:03:38.796]                   }
[16:03:38.796]                 }
[16:03:38.796]             }
[16:03:38.796]         }))
[16:03:38.796]     }, error = function(ex) {
[16:03:38.796]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:38.796]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:38.796]                 ...future.rng), started = ...future.startTime, 
[16:03:38.796]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:38.796]             version = "1.8"), class = "FutureResult")
[16:03:38.796]     }, finally = {
[16:03:38.796]         if (!identical(...future.workdir, getwd())) 
[16:03:38.796]             setwd(...future.workdir)
[16:03:38.796]         {
[16:03:38.796]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:38.796]                 ...future.oldOptions$nwarnings <- NULL
[16:03:38.796]             }
[16:03:38.796]             base::options(...future.oldOptions)
[16:03:38.796]             if (.Platform$OS.type == "windows") {
[16:03:38.796]                 old_names <- names(...future.oldEnvVars)
[16:03:38.796]                 envs <- base::Sys.getenv()
[16:03:38.796]                 names <- names(envs)
[16:03:38.796]                 common <- intersect(names, old_names)
[16:03:38.796]                 added <- setdiff(names, old_names)
[16:03:38.796]                 removed <- setdiff(old_names, names)
[16:03:38.796]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:38.796]                   envs[common]]
[16:03:38.796]                 NAMES <- toupper(changed)
[16:03:38.796]                 args <- list()
[16:03:38.796]                 for (kk in seq_along(NAMES)) {
[16:03:38.796]                   name <- changed[[kk]]
[16:03:38.796]                   NAME <- NAMES[[kk]]
[16:03:38.796]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:38.796]                     next
[16:03:38.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:38.796]                 }
[16:03:38.796]                 NAMES <- toupper(added)
[16:03:38.796]                 for (kk in seq_along(NAMES)) {
[16:03:38.796]                   name <- added[[kk]]
[16:03:38.796]                   NAME <- NAMES[[kk]]
[16:03:38.796]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:38.796]                     next
[16:03:38.796]                   args[[name]] <- ""
[16:03:38.796]                 }
[16:03:38.796]                 NAMES <- toupper(removed)
[16:03:38.796]                 for (kk in seq_along(NAMES)) {
[16:03:38.796]                   name <- removed[[kk]]
[16:03:38.796]                   NAME <- NAMES[[kk]]
[16:03:38.796]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:38.796]                     next
[16:03:38.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:38.796]                 }
[16:03:38.796]                 if (length(args) > 0) 
[16:03:38.796]                   base::do.call(base::Sys.setenv, args = args)
[16:03:38.796]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:38.796]             }
[16:03:38.796]             else {
[16:03:38.796]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:38.796]             }
[16:03:38.796]             {
[16:03:38.796]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:38.796]                   0L) {
[16:03:38.796]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:38.796]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:38.796]                   base::options(opts)
[16:03:38.796]                 }
[16:03:38.796]                 {
[16:03:38.796]                   {
[16:03:38.796]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:38.796]                     NULL
[16:03:38.796]                   }
[16:03:38.796]                   options(future.plan = NULL)
[16:03:38.796]                   if (is.na(NA_character_)) 
[16:03:38.796]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:38.796]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:38.796]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:38.796]                     envir = parent.frame()) 
[16:03:38.796]                   {
[16:03:38.796]                     default_workers <- missing(workers)
[16:03:38.796]                     if (is.function(workers)) 
[16:03:38.796]                       workers <- workers()
[16:03:38.796]                     workers <- structure(as.integer(workers), 
[16:03:38.796]                       class = class(workers))
[16:03:38.796]                     stop_if_not(is.finite(workers), workers >= 
[16:03:38.796]                       1L)
[16:03:38.796]                     if ((workers == 1L && !inherits(workers, 
[16:03:38.796]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:38.796]                       if (default_workers) 
[16:03:38.796]                         supportsMulticore(warn = TRUE)
[16:03:38.796]                       return(sequential(..., envir = envir))
[16:03:38.796]                     }
[16:03:38.796]                     oopts <- options(mc.cores = workers)
[16:03:38.796]                     on.exit(options(oopts))
[16:03:38.796]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:38.796]                       envir = envir)
[16:03:38.796]                     if (!future$lazy) 
[16:03:38.796]                       future <- run(future)
[16:03:38.796]                     invisible(future)
[16:03:38.796]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:38.796]                 }
[16:03:38.796]             }
[16:03:38.796]         }
[16:03:38.796]     })
[16:03:38.796]     if (TRUE) {
[16:03:38.796]         base::sink(type = "output", split = FALSE)
[16:03:38.796]         if (FALSE) {
[16:03:38.796]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:38.796]         }
[16:03:38.796]         else {
[16:03:38.796]             ...future.result["stdout"] <- base::list(NULL)
[16:03:38.796]         }
[16:03:38.796]         base::close(...future.stdout)
[16:03:38.796]         ...future.stdout <- NULL
[16:03:38.796]     }
[16:03:38.796]     ...future.result$conditions <- ...future.conditions
[16:03:38.796]     ...future.result$finished <- base::Sys.time()
[16:03:38.796]     ...future.result
[16:03:38.796] }
[16:03:38.798] assign_globals() ...
[16:03:38.798] List of 5
[16:03:38.798]  $ ...future.FUN            :function (x, y)  
[16:03:38.798]  $ MoreArgs                 : NULL
[16:03:38.798]  $ ...future.elements_ii    :List of 2
[16:03:38.798]   ..$ :List of 1
[16:03:38.798]   .. ..$ : int 1
[16:03:38.798]   ..$ :List of 1
[16:03:38.798]   .. ..$ : int 0
[16:03:38.798]  $ ...future.seeds_ii       : NULL
[16:03:38.798]  $ ...future.globals.maxSize: NULL
[16:03:38.798]  - attr(*, "where")=List of 5
[16:03:38.798]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:38.798]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:03:38.798]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:38.798]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:38.798]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:38.798]  - attr(*, "resolved")= logi FALSE
[16:03:38.798]  - attr(*, "total_size")= num 6368
[16:03:38.798]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:38.798]  - attr(*, "already-done")= logi TRUE
[16:03:38.805] - reassign environment for ‘...future.FUN’
[16:03:38.805] - copied ‘...future.FUN’ to environment
[16:03:38.805] - copied ‘MoreArgs’ to environment
[16:03:38.805] - copied ‘...future.elements_ii’ to environment
[16:03:38.806] - copied ‘...future.seeds_ii’ to environment
[16:03:38.806] - copied ‘...future.globals.maxSize’ to environment
[16:03:38.806] assign_globals() ... done
[16:03:38.806] requestCore(): workers = 2
[16:03:38.808] MulticoreFuture started
[16:03:38.809] - Launch lazy future ... done
[16:03:38.809] run() for ‘MulticoreFuture’ ... done
[16:03:38.809] plan(): Setting new future strategy stack:
[16:03:38.810] Created future:
[16:03:38.810] List of future strategies:
[16:03:38.810] 1. sequential:
[16:03:38.810]    - args: function (..., envir = parent.frame())
[16:03:38.810]    - tweaked: FALSE
[16:03:38.810]    - call: NULL
[16:03:38.811] plan(): nbrOfWorkers() = 1
[16:03:38.810] MulticoreFuture:
[16:03:38.810] Label: ‘future_mapply-1’
[16:03:38.810] Expression:
[16:03:38.810] {
[16:03:38.810]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:38.810]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:38.810]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:38.810]         on.exit(options(oopts), add = TRUE)
[16:03:38.810]     }
[16:03:38.810]     {
[16:03:38.810]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:38.810]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:03:38.810]         do.call(mapply, args = args)
[16:03:38.810]     }
[16:03:38.810] }
[16:03:38.810] Lazy evaluation: FALSE
[16:03:38.810] Asynchronous evaluation: TRUE
[16:03:38.810] Local evaluation: TRUE
[16:03:38.810] Environment: R_GlobalEnv
[16:03:38.810] Capture standard output: FALSE
[16:03:38.810] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:38.810] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:38.810] Packages: <none>
[16:03:38.810] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:38.810] Resolved: FALSE
[16:03:38.810] Value: <not collected>
[16:03:38.810] Conditions captured: <none>
[16:03:38.810] Early signaling: FALSE
[16:03:38.810] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:38.810] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:38.823] Chunk #1 of 2 ... DONE
[16:03:38.823] Chunk #2 of 2 ...
[16:03:38.823]  - Finding globals in '...' for chunk #2 ...
[16:03:38.824] getGlobalsAndPackages() ...
[16:03:38.824] Searching for globals...
[16:03:38.825] 
[16:03:38.825] Searching for globals ... DONE
[16:03:38.825] - globals: [0] <none>
[16:03:38.825] getGlobalsAndPackages() ... DONE
[16:03:38.825]    + additional globals found: [n=0] 
[16:03:38.825]    + additional namespaces needed: [n=0] 
[16:03:38.826]  - Finding globals in '...' for chunk #2 ... DONE
[16:03:38.826]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:38.826]  - seeds: <none>
[16:03:38.826]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:38.826] getGlobalsAndPackages() ...
[16:03:38.826] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:38.827] Resolving globals: FALSE
[16:03:38.828] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:03:38.828] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:03:38.829] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:38.829] 
[16:03:38.829] getGlobalsAndPackages() ... DONE
[16:03:38.829] run() for ‘Future’ ...
[16:03:38.830] - state: ‘created’
[16:03:38.830] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:38.835] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:38.835] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:38.835]   - Field: ‘label’
[16:03:38.835]   - Field: ‘local’
[16:03:38.835]   - Field: ‘owner’
[16:03:38.836]   - Field: ‘envir’
[16:03:38.836]   - Field: ‘workers’
[16:03:38.836]   - Field: ‘packages’
[16:03:38.836]   - Field: ‘gc’
[16:03:38.836]   - Field: ‘job’
[16:03:38.836]   - Field: ‘conditions’
[16:03:38.836]   - Field: ‘expr’
[16:03:38.837]   - Field: ‘uuid’
[16:03:38.837]   - Field: ‘seed’
[16:03:38.837]   - Field: ‘version’
[16:03:38.837]   - Field: ‘result’
[16:03:38.837]   - Field: ‘asynchronous’
[16:03:38.837]   - Field: ‘calls’
[16:03:38.837]   - Field: ‘globals’
[16:03:38.838]   - Field: ‘stdout’
[16:03:38.838]   - Field: ‘earlySignal’
[16:03:38.838]   - Field: ‘lazy’
[16:03:38.838]   - Field: ‘state’
[16:03:38.838] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:38.838] - Launch lazy future ...
[16:03:38.839] Packages needed by the future expression (n = 0): <none>
[16:03:38.839] Packages needed by future strategies (n = 0): <none>
[16:03:38.840] {
[16:03:38.840]     {
[16:03:38.840]         {
[16:03:38.840]             ...future.startTime <- base::Sys.time()
[16:03:38.840]             {
[16:03:38.840]                 {
[16:03:38.840]                   {
[16:03:38.840]                     {
[16:03:38.840]                       base::local({
[16:03:38.840]                         has_future <- base::requireNamespace("future", 
[16:03:38.840]                           quietly = TRUE)
[16:03:38.840]                         if (has_future) {
[16:03:38.840]                           ns <- base::getNamespace("future")
[16:03:38.840]                           version <- ns[[".package"]][["version"]]
[16:03:38.840]                           if (is.null(version)) 
[16:03:38.840]                             version <- utils::packageVersion("future")
[16:03:38.840]                         }
[16:03:38.840]                         else {
[16:03:38.840]                           version <- NULL
[16:03:38.840]                         }
[16:03:38.840]                         if (!has_future || version < "1.8.0") {
[16:03:38.840]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:38.840]                             "", base::R.version$version.string), 
[16:03:38.840]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:38.840]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:38.840]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:38.840]                               "release", "version")], collapse = " "), 
[16:03:38.840]                             hostname = base::Sys.info()[["nodename"]])
[16:03:38.840]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:38.840]                             info)
[16:03:38.840]                           info <- base::paste(info, collapse = "; ")
[16:03:38.840]                           if (!has_future) {
[16:03:38.840]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:38.840]                               info)
[16:03:38.840]                           }
[16:03:38.840]                           else {
[16:03:38.840]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:38.840]                               info, version)
[16:03:38.840]                           }
[16:03:38.840]                           base::stop(msg)
[16:03:38.840]                         }
[16:03:38.840]                       })
[16:03:38.840]                     }
[16:03:38.840]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:38.840]                     base::options(mc.cores = 1L)
[16:03:38.840]                   }
[16:03:38.840]                   options(future.plan = NULL)
[16:03:38.840]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:38.840]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:38.840]                 }
[16:03:38.840]                 ...future.workdir <- getwd()
[16:03:38.840]             }
[16:03:38.840]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:38.840]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:38.840]         }
[16:03:38.840]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:38.840]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:38.840]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:38.840]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:38.840]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:38.840]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:38.840]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:38.840]             base::names(...future.oldOptions))
[16:03:38.840]     }
[16:03:38.840]     if (FALSE) {
[16:03:38.840]     }
[16:03:38.840]     else {
[16:03:38.840]         if (FALSE) {
[16:03:38.840]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:38.840]                 open = "w")
[16:03:38.840]         }
[16:03:38.840]         else {
[16:03:38.840]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:38.840]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:38.840]         }
[16:03:38.840]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:38.840]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:38.840]             base::sink(type = "output", split = FALSE)
[16:03:38.840]             base::close(...future.stdout)
[16:03:38.840]         }, add = TRUE)
[16:03:38.840]     }
[16:03:38.840]     ...future.frame <- base::sys.nframe()
[16:03:38.840]     ...future.conditions <- base::list()
[16:03:38.840]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:38.840]     if (FALSE) {
[16:03:38.840]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:38.840]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:38.840]     }
[16:03:38.840]     ...future.result <- base::tryCatch({
[16:03:38.840]         base::withCallingHandlers({
[16:03:38.840]             ...future.value <- base::withVisible(base::local({
[16:03:38.840]                 withCallingHandlers({
[16:03:38.840]                   {
[16:03:38.840]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:38.840]                     if (!identical(...future.globals.maxSize.org, 
[16:03:38.840]                       ...future.globals.maxSize)) {
[16:03:38.840]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:38.840]                       on.exit(options(oopts), add = TRUE)
[16:03:38.840]                     }
[16:03:38.840]                     {
[16:03:38.840]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:38.840]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:03:38.840]                         USE.NAMES = FALSE)
[16:03:38.840]                       do.call(mapply, args = args)
[16:03:38.840]                     }
[16:03:38.840]                   }
[16:03:38.840]                 }, immediateCondition = function(cond) {
[16:03:38.840]                   save_rds <- function (object, pathname, ...) 
[16:03:38.840]                   {
[16:03:38.840]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:38.840]                     if (file_test("-f", pathname_tmp)) {
[16:03:38.840]                       fi_tmp <- file.info(pathname_tmp)
[16:03:38.840]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:38.840]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:38.840]                         fi_tmp[["mtime"]])
[16:03:38.840]                     }
[16:03:38.840]                     tryCatch({
[16:03:38.840]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:38.840]                     }, error = function(ex) {
[16:03:38.840]                       msg <- conditionMessage(ex)
[16:03:38.840]                       fi_tmp <- file.info(pathname_tmp)
[16:03:38.840]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:38.840]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:38.840]                         fi_tmp[["mtime"]], msg)
[16:03:38.840]                       ex$message <- msg
[16:03:38.840]                       stop(ex)
[16:03:38.840]                     })
[16:03:38.840]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:38.840]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:38.840]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:38.840]                       fi_tmp <- file.info(pathname_tmp)
[16:03:38.840]                       fi <- file.info(pathname)
[16:03:38.840]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:38.840]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:38.840]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:38.840]                         fi[["size"]], fi[["mtime"]])
[16:03:38.840]                       stop(msg)
[16:03:38.840]                     }
[16:03:38.840]                     invisible(pathname)
[16:03:38.840]                   }
[16:03:38.840]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:38.840]                     rootPath = tempdir()) 
[16:03:38.840]                   {
[16:03:38.840]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:38.840]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:38.840]                       tmpdir = path, fileext = ".rds")
[16:03:38.840]                     save_rds(obj, file)
[16:03:38.840]                   }
[16:03:38.840]                   saveImmediateCondition(cond, path = "/tmp/Rtmpi1Xc62/.future/immediateConditions")
[16:03:38.840]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:38.840]                   {
[16:03:38.840]                     inherits <- base::inherits
[16:03:38.840]                     invokeRestart <- base::invokeRestart
[16:03:38.840]                     is.null <- base::is.null
[16:03:38.840]                     muffled <- FALSE
[16:03:38.840]                     if (inherits(cond, "message")) {
[16:03:38.840]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:38.840]                       if (muffled) 
[16:03:38.840]                         invokeRestart("muffleMessage")
[16:03:38.840]                     }
[16:03:38.840]                     else if (inherits(cond, "warning")) {
[16:03:38.840]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:38.840]                       if (muffled) 
[16:03:38.840]                         invokeRestart("muffleWarning")
[16:03:38.840]                     }
[16:03:38.840]                     else if (inherits(cond, "condition")) {
[16:03:38.840]                       if (!is.null(pattern)) {
[16:03:38.840]                         computeRestarts <- base::computeRestarts
[16:03:38.840]                         grepl <- base::grepl
[16:03:38.840]                         restarts <- computeRestarts(cond)
[16:03:38.840]                         for (restart in restarts) {
[16:03:38.840]                           name <- restart$name
[16:03:38.840]                           if (is.null(name)) 
[16:03:38.840]                             next
[16:03:38.840]                           if (!grepl(pattern, name)) 
[16:03:38.840]                             next
[16:03:38.840]                           invokeRestart(restart)
[16:03:38.840]                           muffled <- TRUE
[16:03:38.840]                           break
[16:03:38.840]                         }
[16:03:38.840]                       }
[16:03:38.840]                     }
[16:03:38.840]                     invisible(muffled)
[16:03:38.840]                   }
[16:03:38.840]                   muffleCondition(cond)
[16:03:38.840]                 })
[16:03:38.840]             }))
[16:03:38.840]             future::FutureResult(value = ...future.value$value, 
[16:03:38.840]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:38.840]                   ...future.rng), globalenv = if (FALSE) 
[16:03:38.840]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:38.840]                     ...future.globalenv.names))
[16:03:38.840]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:38.840]         }, condition = base::local({
[16:03:38.840]             c <- base::c
[16:03:38.840]             inherits <- base::inherits
[16:03:38.840]             invokeRestart <- base::invokeRestart
[16:03:38.840]             length <- base::length
[16:03:38.840]             list <- base::list
[16:03:38.840]             seq.int <- base::seq.int
[16:03:38.840]             signalCondition <- base::signalCondition
[16:03:38.840]             sys.calls <- base::sys.calls
[16:03:38.840]             `[[` <- base::`[[`
[16:03:38.840]             `+` <- base::`+`
[16:03:38.840]             `<<-` <- base::`<<-`
[16:03:38.840]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:38.840]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:38.840]                   3L)]
[16:03:38.840]             }
[16:03:38.840]             function(cond) {
[16:03:38.840]                 is_error <- inherits(cond, "error")
[16:03:38.840]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:38.840]                   NULL)
[16:03:38.840]                 if (is_error) {
[16:03:38.840]                   sessionInformation <- function() {
[16:03:38.840]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:38.840]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:38.840]                       search = base::search(), system = base::Sys.info())
[16:03:38.840]                   }
[16:03:38.840]                   ...future.conditions[[length(...future.conditions) + 
[16:03:38.840]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:38.840]                     cond$call), session = sessionInformation(), 
[16:03:38.840]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:38.840]                   signalCondition(cond)
[16:03:38.840]                 }
[16:03:38.840]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:38.840]                 "immediateCondition"))) {
[16:03:38.840]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:38.840]                   ...future.conditions[[length(...future.conditions) + 
[16:03:38.840]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:38.840]                   if (TRUE && !signal) {
[16:03:38.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:38.840]                     {
[16:03:38.840]                       inherits <- base::inherits
[16:03:38.840]                       invokeRestart <- base::invokeRestart
[16:03:38.840]                       is.null <- base::is.null
[16:03:38.840]                       muffled <- FALSE
[16:03:38.840]                       if (inherits(cond, "message")) {
[16:03:38.840]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:38.840]                         if (muffled) 
[16:03:38.840]                           invokeRestart("muffleMessage")
[16:03:38.840]                       }
[16:03:38.840]                       else if (inherits(cond, "warning")) {
[16:03:38.840]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:38.840]                         if (muffled) 
[16:03:38.840]                           invokeRestart("muffleWarning")
[16:03:38.840]                       }
[16:03:38.840]                       else if (inherits(cond, "condition")) {
[16:03:38.840]                         if (!is.null(pattern)) {
[16:03:38.840]                           computeRestarts <- base::computeRestarts
[16:03:38.840]                           grepl <- base::grepl
[16:03:38.840]                           restarts <- computeRestarts(cond)
[16:03:38.840]                           for (restart in restarts) {
[16:03:38.840]                             name <- restart$name
[16:03:38.840]                             if (is.null(name)) 
[16:03:38.840]                               next
[16:03:38.840]                             if (!grepl(pattern, name)) 
[16:03:38.840]                               next
[16:03:38.840]                             invokeRestart(restart)
[16:03:38.840]                             muffled <- TRUE
[16:03:38.840]                             break
[16:03:38.840]                           }
[16:03:38.840]                         }
[16:03:38.840]                       }
[16:03:38.840]                       invisible(muffled)
[16:03:38.840]                     }
[16:03:38.840]                     muffleCondition(cond, pattern = "^muffle")
[16:03:38.840]                   }
[16:03:38.840]                 }
[16:03:38.840]                 else {
[16:03:38.840]                   if (TRUE) {
[16:03:38.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:38.840]                     {
[16:03:38.840]                       inherits <- base::inherits
[16:03:38.840]                       invokeRestart <- base::invokeRestart
[16:03:38.840]                       is.null <- base::is.null
[16:03:38.840]                       muffled <- FALSE
[16:03:38.840]                       if (inherits(cond, "message")) {
[16:03:38.840]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:38.840]                         if (muffled) 
[16:03:38.840]                           invokeRestart("muffleMessage")
[16:03:38.840]                       }
[16:03:38.840]                       else if (inherits(cond, "warning")) {
[16:03:38.840]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:38.840]                         if (muffled) 
[16:03:38.840]                           invokeRestart("muffleWarning")
[16:03:38.840]                       }
[16:03:38.840]                       else if (inherits(cond, "condition")) {
[16:03:38.840]                         if (!is.null(pattern)) {
[16:03:38.840]                           computeRestarts <- base::computeRestarts
[16:03:38.840]                           grepl <- base::grepl
[16:03:38.840]                           restarts <- computeRestarts(cond)
[16:03:38.840]                           for (restart in restarts) {
[16:03:38.840]                             name <- restart$name
[16:03:38.840]                             if (is.null(name)) 
[16:03:38.840]                               next
[16:03:38.840]                             if (!grepl(pattern, name)) 
[16:03:38.840]                               next
[16:03:38.840]                             invokeRestart(restart)
[16:03:38.840]                             muffled <- TRUE
[16:03:38.840]                             break
[16:03:38.840]                           }
[16:03:38.840]                         }
[16:03:38.840]                       }
[16:03:38.840]                       invisible(muffled)
[16:03:38.840]                     }
[16:03:38.840]                     muffleCondition(cond, pattern = "^muffle")
[16:03:38.840]                   }
[16:03:38.840]                 }
[16:03:38.840]             }
[16:03:38.840]         }))
[16:03:38.840]     }, error = function(ex) {
[16:03:38.840]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:38.840]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:38.840]                 ...future.rng), started = ...future.startTime, 
[16:03:38.840]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:38.840]             version = "1.8"), class = "FutureResult")
[16:03:38.840]     }, finally = {
[16:03:38.840]         if (!identical(...future.workdir, getwd())) 
[16:03:38.840]             setwd(...future.workdir)
[16:03:38.840]         {
[16:03:38.840]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:38.840]                 ...future.oldOptions$nwarnings <- NULL
[16:03:38.840]             }
[16:03:38.840]             base::options(...future.oldOptions)
[16:03:38.840]             if (.Platform$OS.type == "windows") {
[16:03:38.840]                 old_names <- names(...future.oldEnvVars)
[16:03:38.840]                 envs <- base::Sys.getenv()
[16:03:38.840]                 names <- names(envs)
[16:03:38.840]                 common <- intersect(names, old_names)
[16:03:38.840]                 added <- setdiff(names, old_names)
[16:03:38.840]                 removed <- setdiff(old_names, names)
[16:03:38.840]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:38.840]                   envs[common]]
[16:03:38.840]                 NAMES <- toupper(changed)
[16:03:38.840]                 args <- list()
[16:03:38.840]                 for (kk in seq_along(NAMES)) {
[16:03:38.840]                   name <- changed[[kk]]
[16:03:38.840]                   NAME <- NAMES[[kk]]
[16:03:38.840]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:38.840]                     next
[16:03:38.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:38.840]                 }
[16:03:38.840]                 NAMES <- toupper(added)
[16:03:38.840]                 for (kk in seq_along(NAMES)) {
[16:03:38.840]                   name <- added[[kk]]
[16:03:38.840]                   NAME <- NAMES[[kk]]
[16:03:38.840]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:38.840]                     next
[16:03:38.840]                   args[[name]] <- ""
[16:03:38.840]                 }
[16:03:38.840]                 NAMES <- toupper(removed)
[16:03:38.840]                 for (kk in seq_along(NAMES)) {
[16:03:38.840]                   name <- removed[[kk]]
[16:03:38.840]                   NAME <- NAMES[[kk]]
[16:03:38.840]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:38.840]                     next
[16:03:38.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:38.840]                 }
[16:03:38.840]                 if (length(args) > 0) 
[16:03:38.840]                   base::do.call(base::Sys.setenv, args = args)
[16:03:38.840]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:38.840]             }
[16:03:38.840]             else {
[16:03:38.840]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:38.840]             }
[16:03:38.840]             {
[16:03:38.840]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:38.840]                   0L) {
[16:03:38.840]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:38.840]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:38.840]                   base::options(opts)
[16:03:38.840]                 }
[16:03:38.840]                 {
[16:03:38.840]                   {
[16:03:38.840]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:38.840]                     NULL
[16:03:38.840]                   }
[16:03:38.840]                   options(future.plan = NULL)
[16:03:38.840]                   if (is.na(NA_character_)) 
[16:03:38.840]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:38.840]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:38.840]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:38.840]                     envir = parent.frame()) 
[16:03:38.840]                   {
[16:03:38.840]                     default_workers <- missing(workers)
[16:03:38.840]                     if (is.function(workers)) 
[16:03:38.840]                       workers <- workers()
[16:03:38.840]                     workers <- structure(as.integer(workers), 
[16:03:38.840]                       class = class(workers))
[16:03:38.840]                     stop_if_not(is.finite(workers), workers >= 
[16:03:38.840]                       1L)
[16:03:38.840]                     if ((workers == 1L && !inherits(workers, 
[16:03:38.840]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:38.840]                       if (default_workers) 
[16:03:38.840]                         supportsMulticore(warn = TRUE)
[16:03:38.840]                       return(sequential(..., envir = envir))
[16:03:38.840]                     }
[16:03:38.840]                     oopts <- options(mc.cores = workers)
[16:03:38.840]                     on.exit(options(oopts))
[16:03:38.840]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:38.840]                       envir = envir)
[16:03:38.840]                     if (!future$lazy) 
[16:03:38.840]                       future <- run(future)
[16:03:38.840]                     invisible(future)
[16:03:38.840]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:38.840]                 }
[16:03:38.840]             }
[16:03:38.840]         }
[16:03:38.840]     })
[16:03:38.840]     if (TRUE) {
[16:03:38.840]         base::sink(type = "output", split = FALSE)
[16:03:38.840]         if (FALSE) {
[16:03:38.840]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:38.840]         }
[16:03:38.840]         else {
[16:03:38.840]             ...future.result["stdout"] <- base::list(NULL)
[16:03:38.840]         }
[16:03:38.840]         base::close(...future.stdout)
[16:03:38.840]         ...future.stdout <- NULL
[16:03:38.840]     }
[16:03:38.840]     ...future.result$conditions <- ...future.conditions
[16:03:38.840]     ...future.result$finished <- base::Sys.time()
[16:03:38.840]     ...future.result
[16:03:38.840] }
[16:03:38.843] assign_globals() ...
[16:03:38.843] List of 5
[16:03:38.843]  $ ...future.FUN            :function (x, y)  
[16:03:38.843]  $ MoreArgs                 : NULL
[16:03:38.843]  $ ...future.elements_ii    :List of 2
[16:03:38.843]   ..$ :List of 1
[16:03:38.843]   .. ..$ : int 0
[16:03:38.843]   ..$ :List of 1
[16:03:38.843]   .. ..$ : int 1
[16:03:38.843]  $ ...future.seeds_ii       : NULL
[16:03:38.843]  $ ...future.globals.maxSize: NULL
[16:03:38.843]  - attr(*, "where")=List of 5
[16:03:38.843]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:38.843]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:03:38.843]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:38.843]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:38.843]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:38.843]  - attr(*, "resolved")= logi FALSE
[16:03:38.843]  - attr(*, "total_size")= num 6368
[16:03:38.843]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:38.843]  - attr(*, "already-done")= logi TRUE
[16:03:38.851] - reassign environment for ‘...future.FUN’
[16:03:38.851] - copied ‘...future.FUN’ to environment
[16:03:38.852] - copied ‘MoreArgs’ to environment
[16:03:38.852] - copied ‘...future.elements_ii’ to environment
[16:03:38.852] - copied ‘...future.seeds_ii’ to environment
[16:03:38.852] - copied ‘...future.globals.maxSize’ to environment
[16:03:38.852] assign_globals() ... done
[16:03:38.852] requestCore(): workers = 2
[16:03:38.855] MulticoreFuture started
[16:03:38.855] - Launch lazy future ... done
[16:03:38.859] plan(): Setting new future strategy stack:
[16:03:38.859] run() for ‘MulticoreFuture’ ... done
[16:03:38.860] Created future:
[16:03:38.860] List of future strategies:
[16:03:38.860] 1. sequential:
[16:03:38.860]    - args: function (..., envir = parent.frame())
[16:03:38.860]    - tweaked: FALSE
[16:03:38.860]    - call: NULL
[16:03:38.861] plan(): nbrOfWorkers() = 1
[16:03:38.864] plan(): Setting new future strategy stack:
[16:03:38.864] List of future strategies:
[16:03:38.864] 1. multicore:
[16:03:38.864]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:38.864]    - tweaked: FALSE
[16:03:38.864]    - call: plan(strategy)
[16:03:38.870] plan(): nbrOfWorkers() = 2
[16:03:38.860] MulticoreFuture:
[16:03:38.860] Label: ‘future_mapply-2’
[16:03:38.860] Expression:
[16:03:38.860] {
[16:03:38.860]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:38.860]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:38.860]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:38.860]         on.exit(options(oopts), add = TRUE)
[16:03:38.860]     }
[16:03:38.860]     {
[16:03:38.860]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:38.860]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:03:38.860]         do.call(mapply, args = args)
[16:03:38.860]     }
[16:03:38.860] }
[16:03:38.860] Lazy evaluation: FALSE
[16:03:38.860] Asynchronous evaluation: TRUE
[16:03:38.860] Local evaluation: TRUE
[16:03:38.860] Environment: R_GlobalEnv
[16:03:38.860] Capture standard output: FALSE
[16:03:38.860] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:38.860] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:38.860] Packages: <none>
[16:03:38.860] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:38.860] Resolved: TRUE
[16:03:38.860] Value: <not collected>
[16:03:38.860] Conditions captured: <none>
[16:03:38.860] Early signaling: FALSE
[16:03:38.860] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:38.860] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:38.872] Chunk #2 of 2 ... DONE
[16:03:38.872] Launching 2 futures (chunks) ... DONE
[16:03:38.872] Resolving 2 futures (chunks) ...
[16:03:38.873] resolve() on list ...
[16:03:38.873]  recursive: 0
[16:03:38.873]  length: 2
[16:03:38.873] 
[16:03:38.884] Future #2
[16:03:38.884] result() for MulticoreFuture ...
[16:03:38.885] result() for MulticoreFuture ...
[16:03:38.885] result() for MulticoreFuture ... done
[16:03:38.885] result() for MulticoreFuture ... done
[16:03:38.885] result() for MulticoreFuture ...
[16:03:38.886] result() for MulticoreFuture ... done
[16:03:38.886] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:03:38.886] - nx: 2
[16:03:38.886] - relay: TRUE
[16:03:38.887] - stdout: TRUE
[16:03:38.887] - signal: TRUE
[16:03:38.887] - resignal: FALSE
[16:03:38.887] - force: TRUE
[16:03:38.887] - relayed: [n=2] FALSE, FALSE
[16:03:38.887] - queued futures: [n=2] FALSE, FALSE
[16:03:38.887]  - until=1
[16:03:38.888]  - relaying element #1
[16:03:38.888] - relayed: [n=2] FALSE, FALSE
[16:03:38.888] - queued futures: [n=2] FALSE, TRUE
[16:03:38.888] signalConditionsASAP(NULL, pos=2) ... done
[16:03:38.888]  length: 1 (resolved future 2)
[16:03:39.313] plan(): Setting new future strategy stack:
[16:03:39.314] List of future strategies:
[16:03:39.314] 1. multicore:
[16:03:39.314]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:39.314]    - tweaked: FALSE
[16:03:39.314]    - call: plan(strategy)
[16:03:39.318] plan(): nbrOfWorkers() = 2
[16:03:39.326] Future #1
[16:03:39.326] result() for MulticoreFuture ...
[16:03:39.327] result() for MulticoreFuture ...
[16:03:39.327] result() for MulticoreFuture ... done
[16:03:39.327] result() for MulticoreFuture ... done
[16:03:39.327] result() for MulticoreFuture ...
[16:03:39.328] result() for MulticoreFuture ... done
[16:03:39.328] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:03:39.328] - nx: 2
[16:03:39.328] - relay: TRUE
[16:03:39.328] - stdout: TRUE
[16:03:39.328] - signal: TRUE
[16:03:39.328] - resignal: FALSE
[16:03:39.328] - force: TRUE
[16:03:39.328] - relayed: [n=2] FALSE, FALSE
[16:03:39.329] - queued futures: [n=2] FALSE, TRUE
[16:03:39.329]  - until=1
[16:03:39.329]  - relaying element #1
[16:03:39.329] result() for MulticoreFuture ...
[16:03:39.329] result() for MulticoreFuture ... done
[16:03:39.329] result() for MulticoreFuture ...
[16:03:39.329] result() for MulticoreFuture ... done
[16:03:39.329] result() for MulticoreFuture ...
[16:03:39.329] result() for MulticoreFuture ... done
[16:03:39.330] result() for MulticoreFuture ...
[16:03:39.330] result() for MulticoreFuture ... done
[16:03:39.330] - relayed: [n=2] TRUE, FALSE
[16:03:39.330] - queued futures: [n=2] TRUE, TRUE
[16:03:39.330] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:03:39.330]  length: 0 (resolved future 1)
[16:03:39.330] Relaying remaining futures
[16:03:39.330] signalConditionsASAP(NULL, pos=0) ...
[16:03:39.330] - nx: 2
[16:03:39.331] - relay: TRUE
[16:03:39.331] - stdout: TRUE
[16:03:39.331] - signal: TRUE
[16:03:39.331] - resignal: FALSE
[16:03:39.331] - force: TRUE
[16:03:39.331] - relayed: [n=2] TRUE, FALSE
[16:03:39.331] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:39.331]  - relaying element #2
[16:03:39.331] result() for MulticoreFuture ...
[16:03:39.332] result() for MulticoreFuture ... done
[16:03:39.332] result() for MulticoreFuture ...
[16:03:39.332] result() for MulticoreFuture ... done
[16:03:39.332] result() for MulticoreFuture ...
[16:03:39.332] result() for MulticoreFuture ... done
[16:03:39.332] result() for MulticoreFuture ...
[16:03:39.332] result() for MulticoreFuture ... done
[16:03:39.332] - relayed: [n=2] TRUE, TRUE
[16:03:39.332] - queued futures: [n=2] TRUE, TRUE
[16:03:39.333] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[16:03:39.333] resolve() on list ... DONE
[16:03:39.333] result() for MulticoreFuture ...
[16:03:39.333] result() for MulticoreFuture ... done
[16:03:39.333] result() for MulticoreFuture ...
[16:03:39.333] result() for MulticoreFuture ... done
[16:03:39.333] result() for MulticoreFuture ...
[16:03:39.333] result() for MulticoreFuture ... done
[16:03:39.333] result() for MulticoreFuture ...
[16:03:39.334] result() for MulticoreFuture ... done
[16:03:39.334]  - Number of value chunks collected: 2
[16:03:39.334] Resolving 2 futures (chunks) ... DONE
[16:03:39.334] Reducing values from 2 chunks ...
[16:03:39.334]  - Number of values collected after concatenation: 2
[16:03:39.334]  - Number of values expected: 2
[16:03:39.334] Reducing values from 2 chunks ... DONE
[16:03:39.334] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[16:03:39.335] future_mapply() ...
[16:03:39.339] Number of chunks: 2
[16:03:39.339] getGlobalsAndPackagesXApply() ...
[16:03:39.339]  - future.globals: TRUE
[16:03:39.339] getGlobalsAndPackages() ...
[16:03:39.339] Searching for globals...
[16:03:39.341] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:03:39.341] Searching for globals ... DONE
[16:03:39.341] Resolving globals: FALSE
[16:03:39.342] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:03:39.342] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:03:39.342] - globals: [1] ‘FUN’
[16:03:39.342] 
[16:03:39.343] getGlobalsAndPackages() ... DONE
[16:03:39.343]  - globals found/used: [n=1] ‘FUN’
[16:03:39.343]  - needed namespaces: [n=0] 
[16:03:39.343] Finding globals ... DONE
[16:03:39.343] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:03:39.343] List of 2
[16:03:39.343]  $ ...future.FUN:function (x, y)  
[16:03:39.343]  $ MoreArgs     : NULL
[16:03:39.343]  - attr(*, "where")=List of 2
[16:03:39.343]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:39.343]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:03:39.343]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:39.343]  - attr(*, "resolved")= logi FALSE
[16:03:39.343]  - attr(*, "total_size")= num NA
[16:03:39.348] Packages to be attached in all futures: [n=0] 
[16:03:39.348] getGlobalsAndPackagesXApply() ... DONE
[16:03:39.348] Number of futures (= number of chunks): 2
[16:03:39.348] Launching 2 futures (chunks) ...
[16:03:39.348] Chunk #1 of 2 ...
[16:03:39.349]  - Finding globals in '...' for chunk #1 ...
[16:03:39.349] getGlobalsAndPackages() ...
[16:03:39.349] Searching for globals...
[16:03:39.349] 
[16:03:39.349] Searching for globals ... DONE
[16:03:39.349] - globals: [0] <none>
[16:03:39.349] getGlobalsAndPackages() ... DONE
[16:03:39.349]    + additional globals found: [n=0] 
[16:03:39.350]    + additional namespaces needed: [n=0] 
[16:03:39.350]  - Finding globals in '...' for chunk #1 ... DONE
[16:03:39.350]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:39.350]  - seeds: <none>
[16:03:39.350]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:39.350] getGlobalsAndPackages() ...
[16:03:39.350] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:39.350] Resolving globals: FALSE
[16:03:39.351] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:03:39.351] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:03:39.351] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:39.351] 
[16:03:39.352] getGlobalsAndPackages() ... DONE
[16:03:39.352] run() for ‘Future’ ...
[16:03:39.352] - state: ‘created’
[16:03:39.352] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:39.356] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:39.356] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:39.356]   - Field: ‘label’
[16:03:39.356]   - Field: ‘local’
[16:03:39.357]   - Field: ‘owner’
[16:03:39.357]   - Field: ‘envir’
[16:03:39.357]   - Field: ‘workers’
[16:03:39.357]   - Field: ‘packages’
[16:03:39.357]   - Field: ‘gc’
[16:03:39.357]   - Field: ‘job’
[16:03:39.357]   - Field: ‘conditions’
[16:03:39.357]   - Field: ‘expr’
[16:03:39.357]   - Field: ‘uuid’
[16:03:39.358]   - Field: ‘seed’
[16:03:39.358]   - Field: ‘version’
[16:03:39.358]   - Field: ‘result’
[16:03:39.358]   - Field: ‘asynchronous’
[16:03:39.358]   - Field: ‘calls’
[16:03:39.358]   - Field: ‘globals’
[16:03:39.358]   - Field: ‘stdout’
[16:03:39.358]   - Field: ‘earlySignal’
[16:03:39.358]   - Field: ‘lazy’
[16:03:39.358]   - Field: ‘state’
[16:03:39.359] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:39.359] - Launch lazy future ...
[16:03:39.359] Packages needed by the future expression (n = 0): <none>
[16:03:39.359] Packages needed by future strategies (n = 0): <none>
[16:03:39.360] {
[16:03:39.360]     {
[16:03:39.360]         {
[16:03:39.360]             ...future.startTime <- base::Sys.time()
[16:03:39.360]             {
[16:03:39.360]                 {
[16:03:39.360]                   {
[16:03:39.360]                     {
[16:03:39.360]                       base::local({
[16:03:39.360]                         has_future <- base::requireNamespace("future", 
[16:03:39.360]                           quietly = TRUE)
[16:03:39.360]                         if (has_future) {
[16:03:39.360]                           ns <- base::getNamespace("future")
[16:03:39.360]                           version <- ns[[".package"]][["version"]]
[16:03:39.360]                           if (is.null(version)) 
[16:03:39.360]                             version <- utils::packageVersion("future")
[16:03:39.360]                         }
[16:03:39.360]                         else {
[16:03:39.360]                           version <- NULL
[16:03:39.360]                         }
[16:03:39.360]                         if (!has_future || version < "1.8.0") {
[16:03:39.360]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:39.360]                             "", base::R.version$version.string), 
[16:03:39.360]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:39.360]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:39.360]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:39.360]                               "release", "version")], collapse = " "), 
[16:03:39.360]                             hostname = base::Sys.info()[["nodename"]])
[16:03:39.360]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:39.360]                             info)
[16:03:39.360]                           info <- base::paste(info, collapse = "; ")
[16:03:39.360]                           if (!has_future) {
[16:03:39.360]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:39.360]                               info)
[16:03:39.360]                           }
[16:03:39.360]                           else {
[16:03:39.360]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:39.360]                               info, version)
[16:03:39.360]                           }
[16:03:39.360]                           base::stop(msg)
[16:03:39.360]                         }
[16:03:39.360]                       })
[16:03:39.360]                     }
[16:03:39.360]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:39.360]                     base::options(mc.cores = 1L)
[16:03:39.360]                   }
[16:03:39.360]                   options(future.plan = NULL)
[16:03:39.360]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:39.360]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:39.360]                 }
[16:03:39.360]                 ...future.workdir <- getwd()
[16:03:39.360]             }
[16:03:39.360]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:39.360]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:39.360]         }
[16:03:39.360]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:39.360]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:39.360]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:39.360]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:39.360]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:39.360]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:39.360]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:39.360]             base::names(...future.oldOptions))
[16:03:39.360]     }
[16:03:39.360]     if (FALSE) {
[16:03:39.360]     }
[16:03:39.360]     else {
[16:03:39.360]         if (TRUE) {
[16:03:39.360]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:39.360]                 open = "w")
[16:03:39.360]         }
[16:03:39.360]         else {
[16:03:39.360]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:39.360]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:39.360]         }
[16:03:39.360]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:39.360]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:39.360]             base::sink(type = "output", split = FALSE)
[16:03:39.360]             base::close(...future.stdout)
[16:03:39.360]         }, add = TRUE)
[16:03:39.360]     }
[16:03:39.360]     ...future.frame <- base::sys.nframe()
[16:03:39.360]     ...future.conditions <- base::list()
[16:03:39.360]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:39.360]     if (FALSE) {
[16:03:39.360]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:39.360]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:39.360]     }
[16:03:39.360]     ...future.result <- base::tryCatch({
[16:03:39.360]         base::withCallingHandlers({
[16:03:39.360]             ...future.value <- base::withVisible(base::local({
[16:03:39.360]                 withCallingHandlers({
[16:03:39.360]                   {
[16:03:39.360]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:39.360]                     if (!identical(...future.globals.maxSize.org, 
[16:03:39.360]                       ...future.globals.maxSize)) {
[16:03:39.360]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:39.360]                       on.exit(options(oopts), add = TRUE)
[16:03:39.360]                     }
[16:03:39.360]                     {
[16:03:39.360]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:39.360]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:03:39.360]                         USE.NAMES = FALSE)
[16:03:39.360]                       do.call(mapply, args = args)
[16:03:39.360]                     }
[16:03:39.360]                   }
[16:03:39.360]                 }, immediateCondition = function(cond) {
[16:03:39.360]                   save_rds <- function (object, pathname, ...) 
[16:03:39.360]                   {
[16:03:39.360]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:39.360]                     if (file_test("-f", pathname_tmp)) {
[16:03:39.360]                       fi_tmp <- file.info(pathname_tmp)
[16:03:39.360]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:39.360]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:39.360]                         fi_tmp[["mtime"]])
[16:03:39.360]                     }
[16:03:39.360]                     tryCatch({
[16:03:39.360]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:39.360]                     }, error = function(ex) {
[16:03:39.360]                       msg <- conditionMessage(ex)
[16:03:39.360]                       fi_tmp <- file.info(pathname_tmp)
[16:03:39.360]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:39.360]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:39.360]                         fi_tmp[["mtime"]], msg)
[16:03:39.360]                       ex$message <- msg
[16:03:39.360]                       stop(ex)
[16:03:39.360]                     })
[16:03:39.360]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:39.360]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:39.360]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:39.360]                       fi_tmp <- file.info(pathname_tmp)
[16:03:39.360]                       fi <- file.info(pathname)
[16:03:39.360]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:39.360]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:39.360]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:39.360]                         fi[["size"]], fi[["mtime"]])
[16:03:39.360]                       stop(msg)
[16:03:39.360]                     }
[16:03:39.360]                     invisible(pathname)
[16:03:39.360]                   }
[16:03:39.360]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:39.360]                     rootPath = tempdir()) 
[16:03:39.360]                   {
[16:03:39.360]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:39.360]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:39.360]                       tmpdir = path, fileext = ".rds")
[16:03:39.360]                     save_rds(obj, file)
[16:03:39.360]                   }
[16:03:39.360]                   saveImmediateCondition(cond, path = "/tmp/Rtmpi1Xc62/.future/immediateConditions")
[16:03:39.360]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:39.360]                   {
[16:03:39.360]                     inherits <- base::inherits
[16:03:39.360]                     invokeRestart <- base::invokeRestart
[16:03:39.360]                     is.null <- base::is.null
[16:03:39.360]                     muffled <- FALSE
[16:03:39.360]                     if (inherits(cond, "message")) {
[16:03:39.360]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:39.360]                       if (muffled) 
[16:03:39.360]                         invokeRestart("muffleMessage")
[16:03:39.360]                     }
[16:03:39.360]                     else if (inherits(cond, "warning")) {
[16:03:39.360]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:39.360]                       if (muffled) 
[16:03:39.360]                         invokeRestart("muffleWarning")
[16:03:39.360]                     }
[16:03:39.360]                     else if (inherits(cond, "condition")) {
[16:03:39.360]                       if (!is.null(pattern)) {
[16:03:39.360]                         computeRestarts <- base::computeRestarts
[16:03:39.360]                         grepl <- base::grepl
[16:03:39.360]                         restarts <- computeRestarts(cond)
[16:03:39.360]                         for (restart in restarts) {
[16:03:39.360]                           name <- restart$name
[16:03:39.360]                           if (is.null(name)) 
[16:03:39.360]                             next
[16:03:39.360]                           if (!grepl(pattern, name)) 
[16:03:39.360]                             next
[16:03:39.360]                           invokeRestart(restart)
[16:03:39.360]                           muffled <- TRUE
[16:03:39.360]                           break
[16:03:39.360]                         }
[16:03:39.360]                       }
[16:03:39.360]                     }
[16:03:39.360]                     invisible(muffled)
[16:03:39.360]                   }
[16:03:39.360]                   muffleCondition(cond)
[16:03:39.360]                 })
[16:03:39.360]             }))
[16:03:39.360]             future::FutureResult(value = ...future.value$value, 
[16:03:39.360]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:39.360]                   ...future.rng), globalenv = if (FALSE) 
[16:03:39.360]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:39.360]                     ...future.globalenv.names))
[16:03:39.360]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:39.360]         }, condition = base::local({
[16:03:39.360]             c <- base::c
[16:03:39.360]             inherits <- base::inherits
[16:03:39.360]             invokeRestart <- base::invokeRestart
[16:03:39.360]             length <- base::length
[16:03:39.360]             list <- base::list
[16:03:39.360]             seq.int <- base::seq.int
[16:03:39.360]             signalCondition <- base::signalCondition
[16:03:39.360]             sys.calls <- base::sys.calls
[16:03:39.360]             `[[` <- base::`[[`
[16:03:39.360]             `+` <- base::`+`
[16:03:39.360]             `<<-` <- base::`<<-`
[16:03:39.360]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:39.360]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:39.360]                   3L)]
[16:03:39.360]             }
[16:03:39.360]             function(cond) {
[16:03:39.360]                 is_error <- inherits(cond, "error")
[16:03:39.360]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:39.360]                   NULL)
[16:03:39.360]                 if (is_error) {
[16:03:39.360]                   sessionInformation <- function() {
[16:03:39.360]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:39.360]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:39.360]                       search = base::search(), system = base::Sys.info())
[16:03:39.360]                   }
[16:03:39.360]                   ...future.conditions[[length(...future.conditions) + 
[16:03:39.360]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:39.360]                     cond$call), session = sessionInformation(), 
[16:03:39.360]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:39.360]                   signalCondition(cond)
[16:03:39.360]                 }
[16:03:39.360]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:39.360]                 "immediateCondition"))) {
[16:03:39.360]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:39.360]                   ...future.conditions[[length(...future.conditions) + 
[16:03:39.360]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:39.360]                   if (TRUE && !signal) {
[16:03:39.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:39.360]                     {
[16:03:39.360]                       inherits <- base::inherits
[16:03:39.360]                       invokeRestart <- base::invokeRestart
[16:03:39.360]                       is.null <- base::is.null
[16:03:39.360]                       muffled <- FALSE
[16:03:39.360]                       if (inherits(cond, "message")) {
[16:03:39.360]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:39.360]                         if (muffled) 
[16:03:39.360]                           invokeRestart("muffleMessage")
[16:03:39.360]                       }
[16:03:39.360]                       else if (inherits(cond, "warning")) {
[16:03:39.360]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:39.360]                         if (muffled) 
[16:03:39.360]                           invokeRestart("muffleWarning")
[16:03:39.360]                       }
[16:03:39.360]                       else if (inherits(cond, "condition")) {
[16:03:39.360]                         if (!is.null(pattern)) {
[16:03:39.360]                           computeRestarts <- base::computeRestarts
[16:03:39.360]                           grepl <- base::grepl
[16:03:39.360]                           restarts <- computeRestarts(cond)
[16:03:39.360]                           for (restart in restarts) {
[16:03:39.360]                             name <- restart$name
[16:03:39.360]                             if (is.null(name)) 
[16:03:39.360]                               next
[16:03:39.360]                             if (!grepl(pattern, name)) 
[16:03:39.360]                               next
[16:03:39.360]                             invokeRestart(restart)
[16:03:39.360]                             muffled <- TRUE
[16:03:39.360]                             break
[16:03:39.360]                           }
[16:03:39.360]                         }
[16:03:39.360]                       }
[16:03:39.360]                       invisible(muffled)
[16:03:39.360]                     }
[16:03:39.360]                     muffleCondition(cond, pattern = "^muffle")
[16:03:39.360]                   }
[16:03:39.360]                 }
[16:03:39.360]                 else {
[16:03:39.360]                   if (TRUE) {
[16:03:39.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:39.360]                     {
[16:03:39.360]                       inherits <- base::inherits
[16:03:39.360]                       invokeRestart <- base::invokeRestart
[16:03:39.360]                       is.null <- base::is.null
[16:03:39.360]                       muffled <- FALSE
[16:03:39.360]                       if (inherits(cond, "message")) {
[16:03:39.360]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:39.360]                         if (muffled) 
[16:03:39.360]                           invokeRestart("muffleMessage")
[16:03:39.360]                       }
[16:03:39.360]                       else if (inherits(cond, "warning")) {
[16:03:39.360]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:39.360]                         if (muffled) 
[16:03:39.360]                           invokeRestart("muffleWarning")
[16:03:39.360]                       }
[16:03:39.360]                       else if (inherits(cond, "condition")) {
[16:03:39.360]                         if (!is.null(pattern)) {
[16:03:39.360]                           computeRestarts <- base::computeRestarts
[16:03:39.360]                           grepl <- base::grepl
[16:03:39.360]                           restarts <- computeRestarts(cond)
[16:03:39.360]                           for (restart in restarts) {
[16:03:39.360]                             name <- restart$name
[16:03:39.360]                             if (is.null(name)) 
[16:03:39.360]                               next
[16:03:39.360]                             if (!grepl(pattern, name)) 
[16:03:39.360]                               next
[16:03:39.360]                             invokeRestart(restart)
[16:03:39.360]                             muffled <- TRUE
[16:03:39.360]                             break
[16:03:39.360]                           }
[16:03:39.360]                         }
[16:03:39.360]                       }
[16:03:39.360]                       invisible(muffled)
[16:03:39.360]                     }
[16:03:39.360]                     muffleCondition(cond, pattern = "^muffle")
[16:03:39.360]                   }
[16:03:39.360]                 }
[16:03:39.360]             }
[16:03:39.360]         }))
[16:03:39.360]     }, error = function(ex) {
[16:03:39.360]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:39.360]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:39.360]                 ...future.rng), started = ...future.startTime, 
[16:03:39.360]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:39.360]             version = "1.8"), class = "FutureResult")
[16:03:39.360]     }, finally = {
[16:03:39.360]         if (!identical(...future.workdir, getwd())) 
[16:03:39.360]             setwd(...future.workdir)
[16:03:39.360]         {
[16:03:39.360]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:39.360]                 ...future.oldOptions$nwarnings <- NULL
[16:03:39.360]             }
[16:03:39.360]             base::options(...future.oldOptions)
[16:03:39.360]             if (.Platform$OS.type == "windows") {
[16:03:39.360]                 old_names <- names(...future.oldEnvVars)
[16:03:39.360]                 envs <- base::Sys.getenv()
[16:03:39.360]                 names <- names(envs)
[16:03:39.360]                 common <- intersect(names, old_names)
[16:03:39.360]                 added <- setdiff(names, old_names)
[16:03:39.360]                 removed <- setdiff(old_names, names)
[16:03:39.360]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:39.360]                   envs[common]]
[16:03:39.360]                 NAMES <- toupper(changed)
[16:03:39.360]                 args <- list()
[16:03:39.360]                 for (kk in seq_along(NAMES)) {
[16:03:39.360]                   name <- changed[[kk]]
[16:03:39.360]                   NAME <- NAMES[[kk]]
[16:03:39.360]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:39.360]                     next
[16:03:39.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:39.360]                 }
[16:03:39.360]                 NAMES <- toupper(added)
[16:03:39.360]                 for (kk in seq_along(NAMES)) {
[16:03:39.360]                   name <- added[[kk]]
[16:03:39.360]                   NAME <- NAMES[[kk]]
[16:03:39.360]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:39.360]                     next
[16:03:39.360]                   args[[name]] <- ""
[16:03:39.360]                 }
[16:03:39.360]                 NAMES <- toupper(removed)
[16:03:39.360]                 for (kk in seq_along(NAMES)) {
[16:03:39.360]                   name <- removed[[kk]]
[16:03:39.360]                   NAME <- NAMES[[kk]]
[16:03:39.360]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:39.360]                     next
[16:03:39.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:39.360]                 }
[16:03:39.360]                 if (length(args) > 0) 
[16:03:39.360]                   base::do.call(base::Sys.setenv, args = args)
[16:03:39.360]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:39.360]             }
[16:03:39.360]             else {
[16:03:39.360]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:39.360]             }
[16:03:39.360]             {
[16:03:39.360]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:39.360]                   0L) {
[16:03:39.360]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:39.360]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:39.360]                   base::options(opts)
[16:03:39.360]                 }
[16:03:39.360]                 {
[16:03:39.360]                   {
[16:03:39.360]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:39.360]                     NULL
[16:03:39.360]                   }
[16:03:39.360]                   options(future.plan = NULL)
[16:03:39.360]                   if (is.na(NA_character_)) 
[16:03:39.360]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:39.360]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:39.360]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:39.360]                     envir = parent.frame()) 
[16:03:39.360]                   {
[16:03:39.360]                     default_workers <- missing(workers)
[16:03:39.360]                     if (is.function(workers)) 
[16:03:39.360]                       workers <- workers()
[16:03:39.360]                     workers <- structure(as.integer(workers), 
[16:03:39.360]                       class = class(workers))
[16:03:39.360]                     stop_if_not(is.finite(workers), workers >= 
[16:03:39.360]                       1L)
[16:03:39.360]                     if ((workers == 1L && !inherits(workers, 
[16:03:39.360]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:39.360]                       if (default_workers) 
[16:03:39.360]                         supportsMulticore(warn = TRUE)
[16:03:39.360]                       return(sequential(..., envir = envir))
[16:03:39.360]                     }
[16:03:39.360]                     oopts <- options(mc.cores = workers)
[16:03:39.360]                     on.exit(options(oopts))
[16:03:39.360]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:39.360]                       envir = envir)
[16:03:39.360]                     if (!future$lazy) 
[16:03:39.360]                       future <- run(future)
[16:03:39.360]                     invisible(future)
[16:03:39.360]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:39.360]                 }
[16:03:39.360]             }
[16:03:39.360]         }
[16:03:39.360]     })
[16:03:39.360]     if (TRUE) {
[16:03:39.360]         base::sink(type = "output", split = FALSE)
[16:03:39.360]         if (TRUE) {
[16:03:39.360]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:39.360]         }
[16:03:39.360]         else {
[16:03:39.360]             ...future.result["stdout"] <- base::list(NULL)
[16:03:39.360]         }
[16:03:39.360]         base::close(...future.stdout)
[16:03:39.360]         ...future.stdout <- NULL
[16:03:39.360]     }
[16:03:39.360]     ...future.result$conditions <- ...future.conditions
[16:03:39.360]     ...future.result$finished <- base::Sys.time()
[16:03:39.360]     ...future.result
[16:03:39.360] }
[16:03:39.362] assign_globals() ...
[16:03:39.362] List of 5
[16:03:39.362]  $ ...future.FUN            :function (x, y)  
[16:03:39.362]  $ MoreArgs                 : NULL
[16:03:39.362]  $ ...future.elements_ii    :List of 2
[16:03:39.362]   ..$ :List of 1
[16:03:39.362]   .. ..$ : int 1
[16:03:39.362]   ..$ :List of 1
[16:03:39.362]   .. ..$ : int 0
[16:03:39.362]  $ ...future.seeds_ii       : NULL
[16:03:39.362]  $ ...future.globals.maxSize: NULL
[16:03:39.362]  - attr(*, "where")=List of 5
[16:03:39.362]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:39.362]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:03:39.362]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:39.362]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:39.362]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:39.362]  - attr(*, "resolved")= logi FALSE
[16:03:39.362]  - attr(*, "total_size")= num 6368
[16:03:39.362]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:39.362]  - attr(*, "already-done")= logi TRUE
[16:03:39.367] - reassign environment for ‘...future.FUN’
[16:03:39.367] - copied ‘...future.FUN’ to environment
[16:03:39.367] - copied ‘MoreArgs’ to environment
[16:03:39.367] - copied ‘...future.elements_ii’ to environment
[16:03:39.368] - copied ‘...future.seeds_ii’ to environment
[16:03:39.368] - copied ‘...future.globals.maxSize’ to environment
[16:03:39.368] assign_globals() ... done
[16:03:39.368] requestCore(): workers = 2
[16:03:39.370] MulticoreFuture started
[16:03:39.370] - Launch lazy future ... done
[16:03:39.371] run() for ‘MulticoreFuture’ ... done
[16:03:39.371] Created future:
[16:03:39.371] plan(): Setting new future strategy stack:
[16:03:39.372] List of future strategies:
[16:03:39.372] 1. sequential:
[16:03:39.372]    - args: function (..., envir = parent.frame())
[16:03:39.372]    - tweaked: FALSE
[16:03:39.372]    - call: NULL
[16:03:39.372] plan(): nbrOfWorkers() = 1
[16:03:39.371] MulticoreFuture:
[16:03:39.371] Label: ‘future_mapply-1’
[16:03:39.371] Expression:
[16:03:39.371] {
[16:03:39.371]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:39.371]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:39.371]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:39.371]         on.exit(options(oopts), add = TRUE)
[16:03:39.371]     }
[16:03:39.371]     {
[16:03:39.371]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:39.371]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:03:39.371]         do.call(mapply, args = args)
[16:03:39.371]     }
[16:03:39.371] }
[16:03:39.371] Lazy evaluation: FALSE
[16:03:39.371] Asynchronous evaluation: TRUE
[16:03:39.371] Local evaluation: TRUE
[16:03:39.371] Environment: R_GlobalEnv
[16:03:39.371] Capture standard output: TRUE
[16:03:39.371] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:39.371] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:39.371] Packages: <none>
[16:03:39.371] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:39.371] Resolved: FALSE
[16:03:39.371] Value: <not collected>
[16:03:39.371] Conditions captured: <none>
[16:03:39.371] Early signaling: FALSE
[16:03:39.371] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:39.371] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:39.384] Chunk #1 of 2 ... DONE
[16:03:39.384] Chunk #2 of 2 ...
[16:03:39.384]  - Finding globals in '...' for chunk #2 ...
[16:03:39.384] getGlobalsAndPackages() ...
[16:03:39.385] Searching for globals...
[16:03:39.385] 
[16:03:39.385] Searching for globals ... DONE
[16:03:39.386] - globals: [0] <none>
[16:03:39.386] getGlobalsAndPackages() ... DONE
[16:03:39.386]    + additional globals found: [n=0] 
[16:03:39.386]    + additional namespaces needed: [n=0] 
[16:03:39.386]  - Finding globals in '...' for chunk #2 ... DONE
[16:03:39.386]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:39.386]  - seeds: <none>
[16:03:39.387]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:39.387] getGlobalsAndPackages() ...
[16:03:39.387] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:39.387] Resolving globals: FALSE
[16:03:39.388] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:03:39.400] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:03:39.400] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:39.400] 
[16:03:39.400] getGlobalsAndPackages() ... DONE
[16:03:39.401] run() for ‘Future’ ...
[16:03:39.401] - state: ‘created’
[16:03:39.401] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:39.406] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:39.406] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:39.407]   - Field: ‘label’
[16:03:39.407]   - Field: ‘local’
[16:03:39.407]   - Field: ‘owner’
[16:03:39.407]   - Field: ‘envir’
[16:03:39.407]   - Field: ‘workers’
[16:03:39.408]   - Field: ‘packages’
[16:03:39.408]   - Field: ‘gc’
[16:03:39.408]   - Field: ‘job’
[16:03:39.408]   - Field: ‘conditions’
[16:03:39.408]   - Field: ‘expr’
[16:03:39.408]   - Field: ‘uuid’
[16:03:39.408]   - Field: ‘seed’
[16:03:39.409]   - Field: ‘version’
[16:03:39.409]   - Field: ‘result’
[16:03:39.409]   - Field: ‘asynchronous’
[16:03:39.409]   - Field: ‘calls’
[16:03:39.409]   - Field: ‘globals’
[16:03:39.409]   - Field: ‘stdout’
[16:03:39.409]   - Field: ‘earlySignal’
[16:03:39.410]   - Field: ‘lazy’
[16:03:39.410]   - Field: ‘state’
[16:03:39.410] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:39.410] - Launch lazy future ...
[16:03:39.411] Packages needed by the future expression (n = 0): <none>
[16:03:39.411] Packages needed by future strategies (n = 0): <none>
[16:03:39.412] {
[16:03:39.412]     {
[16:03:39.412]         {
[16:03:39.412]             ...future.startTime <- base::Sys.time()
[16:03:39.412]             {
[16:03:39.412]                 {
[16:03:39.412]                   {
[16:03:39.412]                     {
[16:03:39.412]                       base::local({
[16:03:39.412]                         has_future <- base::requireNamespace("future", 
[16:03:39.412]                           quietly = TRUE)
[16:03:39.412]                         if (has_future) {
[16:03:39.412]                           ns <- base::getNamespace("future")
[16:03:39.412]                           version <- ns[[".package"]][["version"]]
[16:03:39.412]                           if (is.null(version)) 
[16:03:39.412]                             version <- utils::packageVersion("future")
[16:03:39.412]                         }
[16:03:39.412]                         else {
[16:03:39.412]                           version <- NULL
[16:03:39.412]                         }
[16:03:39.412]                         if (!has_future || version < "1.8.0") {
[16:03:39.412]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:39.412]                             "", base::R.version$version.string), 
[16:03:39.412]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:39.412]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:39.412]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:39.412]                               "release", "version")], collapse = " "), 
[16:03:39.412]                             hostname = base::Sys.info()[["nodename"]])
[16:03:39.412]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:39.412]                             info)
[16:03:39.412]                           info <- base::paste(info, collapse = "; ")
[16:03:39.412]                           if (!has_future) {
[16:03:39.412]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:39.412]                               info)
[16:03:39.412]                           }
[16:03:39.412]                           else {
[16:03:39.412]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:39.412]                               info, version)
[16:03:39.412]                           }
[16:03:39.412]                           base::stop(msg)
[16:03:39.412]                         }
[16:03:39.412]                       })
[16:03:39.412]                     }
[16:03:39.412]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:39.412]                     base::options(mc.cores = 1L)
[16:03:39.412]                   }
[16:03:39.412]                   options(future.plan = NULL)
[16:03:39.412]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:39.412]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:39.412]                 }
[16:03:39.412]                 ...future.workdir <- getwd()
[16:03:39.412]             }
[16:03:39.412]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:39.412]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:39.412]         }
[16:03:39.412]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:39.412]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:39.412]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:39.412]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:39.412]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:39.412]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:39.412]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:39.412]             base::names(...future.oldOptions))
[16:03:39.412]     }
[16:03:39.412]     if (FALSE) {
[16:03:39.412]     }
[16:03:39.412]     else {
[16:03:39.412]         if (TRUE) {
[16:03:39.412]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:39.412]                 open = "w")
[16:03:39.412]         }
[16:03:39.412]         else {
[16:03:39.412]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:39.412]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:39.412]         }
[16:03:39.412]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:39.412]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:39.412]             base::sink(type = "output", split = FALSE)
[16:03:39.412]             base::close(...future.stdout)
[16:03:39.412]         }, add = TRUE)
[16:03:39.412]     }
[16:03:39.412]     ...future.frame <- base::sys.nframe()
[16:03:39.412]     ...future.conditions <- base::list()
[16:03:39.412]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:39.412]     if (FALSE) {
[16:03:39.412]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:39.412]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:39.412]     }
[16:03:39.412]     ...future.result <- base::tryCatch({
[16:03:39.412]         base::withCallingHandlers({
[16:03:39.412]             ...future.value <- base::withVisible(base::local({
[16:03:39.412]                 withCallingHandlers({
[16:03:39.412]                   {
[16:03:39.412]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:39.412]                     if (!identical(...future.globals.maxSize.org, 
[16:03:39.412]                       ...future.globals.maxSize)) {
[16:03:39.412]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:39.412]                       on.exit(options(oopts), add = TRUE)
[16:03:39.412]                     }
[16:03:39.412]                     {
[16:03:39.412]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:39.412]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:03:39.412]                         USE.NAMES = FALSE)
[16:03:39.412]                       do.call(mapply, args = args)
[16:03:39.412]                     }
[16:03:39.412]                   }
[16:03:39.412]                 }, immediateCondition = function(cond) {
[16:03:39.412]                   save_rds <- function (object, pathname, ...) 
[16:03:39.412]                   {
[16:03:39.412]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:39.412]                     if (file_test("-f", pathname_tmp)) {
[16:03:39.412]                       fi_tmp <- file.info(pathname_tmp)
[16:03:39.412]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:39.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:39.412]                         fi_tmp[["mtime"]])
[16:03:39.412]                     }
[16:03:39.412]                     tryCatch({
[16:03:39.412]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:39.412]                     }, error = function(ex) {
[16:03:39.412]                       msg <- conditionMessage(ex)
[16:03:39.412]                       fi_tmp <- file.info(pathname_tmp)
[16:03:39.412]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:39.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:39.412]                         fi_tmp[["mtime"]], msg)
[16:03:39.412]                       ex$message <- msg
[16:03:39.412]                       stop(ex)
[16:03:39.412]                     })
[16:03:39.412]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:39.412]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:39.412]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:39.412]                       fi_tmp <- file.info(pathname_tmp)
[16:03:39.412]                       fi <- file.info(pathname)
[16:03:39.412]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:39.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:39.412]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:39.412]                         fi[["size"]], fi[["mtime"]])
[16:03:39.412]                       stop(msg)
[16:03:39.412]                     }
[16:03:39.412]                     invisible(pathname)
[16:03:39.412]                   }
[16:03:39.412]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:39.412]                     rootPath = tempdir()) 
[16:03:39.412]                   {
[16:03:39.412]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:39.412]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:39.412]                       tmpdir = path, fileext = ".rds")
[16:03:39.412]                     save_rds(obj, file)
[16:03:39.412]                   }
[16:03:39.412]                   saveImmediateCondition(cond, path = "/tmp/Rtmpi1Xc62/.future/immediateConditions")
[16:03:39.412]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:39.412]                   {
[16:03:39.412]                     inherits <- base::inherits
[16:03:39.412]                     invokeRestart <- base::invokeRestart
[16:03:39.412]                     is.null <- base::is.null
[16:03:39.412]                     muffled <- FALSE
[16:03:39.412]                     if (inherits(cond, "message")) {
[16:03:39.412]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:39.412]                       if (muffled) 
[16:03:39.412]                         invokeRestart("muffleMessage")
[16:03:39.412]                     }
[16:03:39.412]                     else if (inherits(cond, "warning")) {
[16:03:39.412]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:39.412]                       if (muffled) 
[16:03:39.412]                         invokeRestart("muffleWarning")
[16:03:39.412]                     }
[16:03:39.412]                     else if (inherits(cond, "condition")) {
[16:03:39.412]                       if (!is.null(pattern)) {
[16:03:39.412]                         computeRestarts <- base::computeRestarts
[16:03:39.412]                         grepl <- base::grepl
[16:03:39.412]                         restarts <- computeRestarts(cond)
[16:03:39.412]                         for (restart in restarts) {
[16:03:39.412]                           name <- restart$name
[16:03:39.412]                           if (is.null(name)) 
[16:03:39.412]                             next
[16:03:39.412]                           if (!grepl(pattern, name)) 
[16:03:39.412]                             next
[16:03:39.412]                           invokeRestart(restart)
[16:03:39.412]                           muffled <- TRUE
[16:03:39.412]                           break
[16:03:39.412]                         }
[16:03:39.412]                       }
[16:03:39.412]                     }
[16:03:39.412]                     invisible(muffled)
[16:03:39.412]                   }
[16:03:39.412]                   muffleCondition(cond)
[16:03:39.412]                 })
[16:03:39.412]             }))
[16:03:39.412]             future::FutureResult(value = ...future.value$value, 
[16:03:39.412]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:39.412]                   ...future.rng), globalenv = if (FALSE) 
[16:03:39.412]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:39.412]                     ...future.globalenv.names))
[16:03:39.412]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:39.412]         }, condition = base::local({
[16:03:39.412]             c <- base::c
[16:03:39.412]             inherits <- base::inherits
[16:03:39.412]             invokeRestart <- base::invokeRestart
[16:03:39.412]             length <- base::length
[16:03:39.412]             list <- base::list
[16:03:39.412]             seq.int <- base::seq.int
[16:03:39.412]             signalCondition <- base::signalCondition
[16:03:39.412]             sys.calls <- base::sys.calls
[16:03:39.412]             `[[` <- base::`[[`
[16:03:39.412]             `+` <- base::`+`
[16:03:39.412]             `<<-` <- base::`<<-`
[16:03:39.412]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:39.412]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:39.412]                   3L)]
[16:03:39.412]             }
[16:03:39.412]             function(cond) {
[16:03:39.412]                 is_error <- inherits(cond, "error")
[16:03:39.412]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:39.412]                   NULL)
[16:03:39.412]                 if (is_error) {
[16:03:39.412]                   sessionInformation <- function() {
[16:03:39.412]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:39.412]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:39.412]                       search = base::search(), system = base::Sys.info())
[16:03:39.412]                   }
[16:03:39.412]                   ...future.conditions[[length(...future.conditions) + 
[16:03:39.412]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:39.412]                     cond$call), session = sessionInformation(), 
[16:03:39.412]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:39.412]                   signalCondition(cond)
[16:03:39.412]                 }
[16:03:39.412]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:39.412]                 "immediateCondition"))) {
[16:03:39.412]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:39.412]                   ...future.conditions[[length(...future.conditions) + 
[16:03:39.412]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:39.412]                   if (TRUE && !signal) {
[16:03:39.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:39.412]                     {
[16:03:39.412]                       inherits <- base::inherits
[16:03:39.412]                       invokeRestart <- base::invokeRestart
[16:03:39.412]                       is.null <- base::is.null
[16:03:39.412]                       muffled <- FALSE
[16:03:39.412]                       if (inherits(cond, "message")) {
[16:03:39.412]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:39.412]                         if (muffled) 
[16:03:39.412]                           invokeRestart("muffleMessage")
[16:03:39.412]                       }
[16:03:39.412]                       else if (inherits(cond, "warning")) {
[16:03:39.412]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:39.412]                         if (muffled) 
[16:03:39.412]                           invokeRestart("muffleWarning")
[16:03:39.412]                       }
[16:03:39.412]                       else if (inherits(cond, "condition")) {
[16:03:39.412]                         if (!is.null(pattern)) {
[16:03:39.412]                           computeRestarts <- base::computeRestarts
[16:03:39.412]                           grepl <- base::grepl
[16:03:39.412]                           restarts <- computeRestarts(cond)
[16:03:39.412]                           for (restart in restarts) {
[16:03:39.412]                             name <- restart$name
[16:03:39.412]                             if (is.null(name)) 
[16:03:39.412]                               next
[16:03:39.412]                             if (!grepl(pattern, name)) 
[16:03:39.412]                               next
[16:03:39.412]                             invokeRestart(restart)
[16:03:39.412]                             muffled <- TRUE
[16:03:39.412]                             break
[16:03:39.412]                           }
[16:03:39.412]                         }
[16:03:39.412]                       }
[16:03:39.412]                       invisible(muffled)
[16:03:39.412]                     }
[16:03:39.412]                     muffleCondition(cond, pattern = "^muffle")
[16:03:39.412]                   }
[16:03:39.412]                 }
[16:03:39.412]                 else {
[16:03:39.412]                   if (TRUE) {
[16:03:39.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:39.412]                     {
[16:03:39.412]                       inherits <- base::inherits
[16:03:39.412]                       invokeRestart <- base::invokeRestart
[16:03:39.412]                       is.null <- base::is.null
[16:03:39.412]                       muffled <- FALSE
[16:03:39.412]                       if (inherits(cond, "message")) {
[16:03:39.412]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:39.412]                         if (muffled) 
[16:03:39.412]                           invokeRestart("muffleMessage")
[16:03:39.412]                       }
[16:03:39.412]                       else if (inherits(cond, "warning")) {
[16:03:39.412]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:39.412]                         if (muffled) 
[16:03:39.412]                           invokeRestart("muffleWarning")
[16:03:39.412]                       }
[16:03:39.412]                       else if (inherits(cond, "condition")) {
[16:03:39.412]                         if (!is.null(pattern)) {
[16:03:39.412]                           computeRestarts <- base::computeRestarts
[16:03:39.412]                           grepl <- base::grepl
[16:03:39.412]                           restarts <- computeRestarts(cond)
[16:03:39.412]                           for (restart in restarts) {
[16:03:39.412]                             name <- restart$name
[16:03:39.412]                             if (is.null(name)) 
[16:03:39.412]                               next
[16:03:39.412]                             if (!grepl(pattern, name)) 
[16:03:39.412]                               next
[16:03:39.412]                             invokeRestart(restart)
[16:03:39.412]                             muffled <- TRUE
[16:03:39.412]                             break
[16:03:39.412]                           }
[16:03:39.412]                         }
[16:03:39.412]                       }
[16:03:39.412]                       invisible(muffled)
[16:03:39.412]                     }
[16:03:39.412]                     muffleCondition(cond, pattern = "^muffle")
[16:03:39.412]                   }
[16:03:39.412]                 }
[16:03:39.412]             }
[16:03:39.412]         }))
[16:03:39.412]     }, error = function(ex) {
[16:03:39.412]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:39.412]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:39.412]                 ...future.rng), started = ...future.startTime, 
[16:03:39.412]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:39.412]             version = "1.8"), class = "FutureResult")
[16:03:39.412]     }, finally = {
[16:03:39.412]         if (!identical(...future.workdir, getwd())) 
[16:03:39.412]             setwd(...future.workdir)
[16:03:39.412]         {
[16:03:39.412]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:39.412]                 ...future.oldOptions$nwarnings <- NULL
[16:03:39.412]             }
[16:03:39.412]             base::options(...future.oldOptions)
[16:03:39.412]             if (.Platform$OS.type == "windows") {
[16:03:39.412]                 old_names <- names(...future.oldEnvVars)
[16:03:39.412]                 envs <- base::Sys.getenv()
[16:03:39.412]                 names <- names(envs)
[16:03:39.412]                 common <- intersect(names, old_names)
[16:03:39.412]                 added <- setdiff(names, old_names)
[16:03:39.412]                 removed <- setdiff(old_names, names)
[16:03:39.412]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:39.412]                   envs[common]]
[16:03:39.412]                 NAMES <- toupper(changed)
[16:03:39.412]                 args <- list()
[16:03:39.412]                 for (kk in seq_along(NAMES)) {
[16:03:39.412]                   name <- changed[[kk]]
[16:03:39.412]                   NAME <- NAMES[[kk]]
[16:03:39.412]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:39.412]                     next
[16:03:39.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:39.412]                 }
[16:03:39.412]                 NAMES <- toupper(added)
[16:03:39.412]                 for (kk in seq_along(NAMES)) {
[16:03:39.412]                   name <- added[[kk]]
[16:03:39.412]                   NAME <- NAMES[[kk]]
[16:03:39.412]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:39.412]                     next
[16:03:39.412]                   args[[name]] <- ""
[16:03:39.412]                 }
[16:03:39.412]                 NAMES <- toupper(removed)
[16:03:39.412]                 for (kk in seq_along(NAMES)) {
[16:03:39.412]                   name <- removed[[kk]]
[16:03:39.412]                   NAME <- NAMES[[kk]]
[16:03:39.412]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:39.412]                     next
[16:03:39.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:39.412]                 }
[16:03:39.412]                 if (length(args) > 0) 
[16:03:39.412]                   base::do.call(base::Sys.setenv, args = args)
[16:03:39.412]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:39.412]             }
[16:03:39.412]             else {
[16:03:39.412]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:39.412]             }
[16:03:39.412]             {
[16:03:39.412]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:39.412]                   0L) {
[16:03:39.412]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:39.412]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:39.412]                   base::options(opts)
[16:03:39.412]                 }
[16:03:39.412]                 {
[16:03:39.412]                   {
[16:03:39.412]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:39.412]                     NULL
[16:03:39.412]                   }
[16:03:39.412]                   options(future.plan = NULL)
[16:03:39.412]                   if (is.na(NA_character_)) 
[16:03:39.412]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:39.412]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:39.412]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:39.412]                     envir = parent.frame()) 
[16:03:39.412]                   {
[16:03:39.412]                     default_workers <- missing(workers)
[16:03:39.412]                     if (is.function(workers)) 
[16:03:39.412]                       workers <- workers()
[16:03:39.412]                     workers <- structure(as.integer(workers), 
[16:03:39.412]                       class = class(workers))
[16:03:39.412]                     stop_if_not(is.finite(workers), workers >= 
[16:03:39.412]                       1L)
[16:03:39.412]                     if ((workers == 1L && !inherits(workers, 
[16:03:39.412]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:39.412]                       if (default_workers) 
[16:03:39.412]                         supportsMulticore(warn = TRUE)
[16:03:39.412]                       return(sequential(..., envir = envir))
[16:03:39.412]                     }
[16:03:39.412]                     oopts <- options(mc.cores = workers)
[16:03:39.412]                     on.exit(options(oopts))
[16:03:39.412]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:39.412]                       envir = envir)
[16:03:39.412]                     if (!future$lazy) 
[16:03:39.412]                       future <- run(future)
[16:03:39.412]                     invisible(future)
[16:03:39.412]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:39.412]                 }
[16:03:39.412]             }
[16:03:39.412]         }
[16:03:39.412]     })
[16:03:39.412]     if (TRUE) {
[16:03:39.412]         base::sink(type = "output", split = FALSE)
[16:03:39.412]         if (TRUE) {
[16:03:39.412]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:39.412]         }
[16:03:39.412]         else {
[16:03:39.412]             ...future.result["stdout"] <- base::list(NULL)
[16:03:39.412]         }
[16:03:39.412]         base::close(...future.stdout)
[16:03:39.412]         ...future.stdout <- NULL
[16:03:39.412]     }
[16:03:39.412]     ...future.result$conditions <- ...future.conditions
[16:03:39.412]     ...future.result$finished <- base::Sys.time()
[16:03:39.412]     ...future.result
[16:03:39.412] }
[16:03:39.414] assign_globals() ...
[16:03:39.414] List of 5
[16:03:39.414]  $ ...future.FUN            :function (x, y)  
[16:03:39.414]  $ MoreArgs                 : NULL
[16:03:39.414]  $ ...future.elements_ii    :List of 2
[16:03:39.414]   ..$ :List of 1
[16:03:39.414]   .. ..$ : int 0
[16:03:39.414]   ..$ :List of 1
[16:03:39.414]   .. ..$ : int 1
[16:03:39.414]  $ ...future.seeds_ii       : NULL
[16:03:39.414]  $ ...future.globals.maxSize: NULL
[16:03:39.414]  - attr(*, "where")=List of 5
[16:03:39.414]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:39.414]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:03:39.414]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:39.414]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:39.414]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:39.414]  - attr(*, "resolved")= logi FALSE
[16:03:39.414]  - attr(*, "total_size")= num 6368
[16:03:39.414]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:39.414]  - attr(*, "already-done")= logi TRUE
[16:03:39.421] - reassign environment for ‘...future.FUN’
[16:03:39.421] - copied ‘...future.FUN’ to environment
[16:03:39.421] - copied ‘MoreArgs’ to environment
[16:03:39.421] - copied ‘...future.elements_ii’ to environment
[16:03:39.421] - copied ‘...future.seeds_ii’ to environment
[16:03:39.422] - copied ‘...future.globals.maxSize’ to environment
[16:03:39.422] assign_globals() ... done
[16:03:39.422] requestCore(): workers = 2
[16:03:39.424] MulticoreFuture started
[16:03:39.424] - Launch lazy future ... done
[16:03:39.425] run() for ‘MulticoreFuture’ ... done
[16:03:39.425] Created future:
[16:03:39.425] plan(): Setting new future strategy stack:
[16:03:39.425] List of future strategies:
[16:03:39.425] 1. sequential:
[16:03:39.425]    - args: function (..., envir = parent.frame())
[16:03:39.425]    - tweaked: FALSE
[16:03:39.425]    - call: NULL
[16:03:39.426] plan(): nbrOfWorkers() = 1
[16:03:39.428] plan(): Setting new future strategy stack:
[16:03:39.428] List of future strategies:
[16:03:39.428] 1. multicore:
[16:03:39.428]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:39.428]    - tweaked: FALSE
[16:03:39.428]    - call: plan(strategy)
[16:03:39.434] plan(): nbrOfWorkers() = 2
[16:03:39.425] MulticoreFuture:
[16:03:39.425] Label: ‘future_mapply-2’
[16:03:39.425] Expression:
[16:03:39.425] {
[16:03:39.425]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:39.425]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:39.425]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:39.425]         on.exit(options(oopts), add = TRUE)
[16:03:39.425]     }
[16:03:39.425]     {
[16:03:39.425]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:39.425]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:03:39.425]         do.call(mapply, args = args)
[16:03:39.425]     }
[16:03:39.425] }
[16:03:39.425] Lazy evaluation: FALSE
[16:03:39.425] Asynchronous evaluation: TRUE
[16:03:39.425] Local evaluation: TRUE
[16:03:39.425] Environment: R_GlobalEnv
[16:03:39.425] Capture standard output: TRUE
[16:03:39.425] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:39.425] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:39.425] Packages: <none>
[16:03:39.425] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:39.425] Resolved: TRUE
[16:03:39.425] Value: <not collected>
[16:03:39.425] Conditions captured: <none>
[16:03:39.425] Early signaling: FALSE
[16:03:39.425] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:39.425] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:39.434] Chunk #2 of 2 ... DONE
[16:03:39.435] Launching 2 futures (chunks) ... DONE
[16:03:39.435] Resolving 2 futures (chunks) ...
[16:03:39.435] resolve() on list ...
[16:03:39.435]  recursive: 0
[16:03:39.435]  length: 2
[16:03:39.435] 
[16:03:39.446] Future #2
[16:03:39.446] result() for MulticoreFuture ...
[16:03:39.447] result() for MulticoreFuture ...
[16:03:39.447] result() for MulticoreFuture ... done
[16:03:39.448] result() for MulticoreFuture ... done
[16:03:39.448] result() for MulticoreFuture ...
[16:03:39.448] result() for MulticoreFuture ... done
[16:03:39.448] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:03:39.448] - nx: 2
[16:03:39.448] - relay: TRUE
[16:03:39.449] - stdout: TRUE
[16:03:39.449] - signal: TRUE
[16:03:39.449] - resignal: FALSE
[16:03:39.449] - force: TRUE
[16:03:39.449] - relayed: [n=2] FALSE, FALSE
[16:03:39.449] - queued futures: [n=2] FALSE, FALSE
[16:03:39.449]  - until=1
[16:03:39.449]  - relaying element #1
[16:03:39.450] - relayed: [n=2] FALSE, FALSE
[16:03:39.450] - queued futures: [n=2] FALSE, TRUE
[16:03:39.450] signalConditionsASAP(NULL, pos=2) ... done
[16:03:39.450]  length: 1 (resolved future 2)
[16:03:39.875] plan(): Setting new future strategy stack:
[16:03:39.875] List of future strategies:
[16:03:39.875] 1. multicore:
[16:03:39.875]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:39.875]    - tweaked: FALSE
[16:03:39.875]    - call: plan(strategy)
[16:03:39.880] plan(): nbrOfWorkers() = 2
[16:03:39.888] Future #1
[16:03:39.888] result() for MulticoreFuture ...
[16:03:39.889] result() for MulticoreFuture ...
[16:03:39.889] result() for MulticoreFuture ... done
[16:03:39.889] result() for MulticoreFuture ... done
[16:03:39.889] result() for MulticoreFuture ...
[16:03:39.889] result() for MulticoreFuture ... done
[16:03:39.890] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:03:39.890] - nx: 2
[16:03:39.890] - relay: TRUE
[16:03:39.890] - stdout: TRUE
[16:03:39.890] - signal: TRUE
[16:03:39.890] - resignal: FALSE
[16:03:39.890] - force: TRUE
[16:03:39.890] - relayed: [n=2] FALSE, FALSE
[16:03:39.890] - queued futures: [n=2] FALSE, TRUE
[16:03:39.891]  - until=1
[16:03:39.891]  - relaying element #1
[16:03:39.891] result() for MulticoreFuture ...
[16:03:39.891] result() for MulticoreFuture ... done
[16:03:39.891] result() for MulticoreFuture ...
[16:03:39.891] result() for MulticoreFuture ... done
[16:03:39.891] result() for MulticoreFuture ...
[16:03:39.891] result() for MulticoreFuture ... done
[16:03:39.892] result() for MulticoreFuture ...
[16:03:39.892] result() for MulticoreFuture ... done
[16:03:39.892] - relayed: [n=2] TRUE, FALSE
[16:03:39.892] - queued futures: [n=2] TRUE, TRUE
[16:03:39.892] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:03:39.892]  length: 0 (resolved future 1)
[16:03:39.895] Relaying remaining futures
[16:03:39.895] signalConditionsASAP(NULL, pos=0) ...
[16:03:39.895] - nx: 2
[16:03:39.895] - relay: TRUE
[16:03:39.896] - stdout: TRUE
[16:03:39.896] - signal: TRUE
[16:03:39.896] - resignal: FALSE
[16:03:39.896] - force: TRUE
[16:03:39.896] - relayed: [n=2] TRUE, FALSE
[16:03:39.896] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:39.896]  - relaying element #2
[16:03:39.897] result() for MulticoreFuture ...
[16:03:39.897] result() for MulticoreFuture ... done
[16:03:39.897] result() for MulticoreFuture ...
[16:03:39.897] result() for MulticoreFuture ... done
[16:03:39.897] result() for MulticoreFuture ...
[16:03:39.898] result() for MulticoreFuture ... done
[16:03:39.898] result() for MulticoreFuture ...
[16:03:39.898] result() for MulticoreFuture ... done
[16:03:39.898] - relayed: [n=2] TRUE, TRUE
[16:03:39.898] - queued futures: [n=2] TRUE, TRUE
[16:03:39.898] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[16:03:39.898] resolve() on list ... DONE
[16:03:39.899] result() for MulticoreFuture ...
[16:03:39.899] result() for MulticoreFuture ... done
[16:03:39.899] result() for MulticoreFuture ...
[16:03:39.899] result() for MulticoreFuture ... done
[16:03:39.899] result() for MulticoreFuture ...
[16:03:39.899] result() for MulticoreFuture ... done
[16:03:39.899] result() for MulticoreFuture ...
[16:03:39.900] result() for MulticoreFuture ... done
[16:03:39.900]  - Number of value chunks collected: 2
[16:03:39.900] Resolving 2 futures (chunks) ... DONE
[16:03:39.900] Reducing values from 2 chunks ...
[16:03:39.900]  - Number of values collected after concatenation: 2
[16:03:39.900]  - Number of values expected: 2
[16:03:39.900] Reducing values from 2 chunks ... DONE
[16:03:39.900] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[16:03:39.901] future_mapply() ...
[16:03:39.906] Number of chunks: 2
[16:03:39.906] getGlobalsAndPackagesXApply() ...
[16:03:39.906]  - future.globals: TRUE
[16:03:39.906] getGlobalsAndPackages() ...
[16:03:39.906] Searching for globals...
[16:03:39.908] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:03:39.908] Searching for globals ... DONE
[16:03:39.909] Resolving globals: FALSE
[16:03:39.909] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:03:39.909] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:03:39.910] - globals: [1] ‘FUN’
[16:03:39.910] 
[16:03:39.910] getGlobalsAndPackages() ... DONE
[16:03:39.910]  - globals found/used: [n=1] ‘FUN’
[16:03:39.910]  - needed namespaces: [n=0] 
[16:03:39.910] Finding globals ... DONE
[16:03:39.910] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:03:39.911] List of 2
[16:03:39.911]  $ ...future.FUN:function (x, y)  
[16:03:39.911]  $ MoreArgs     : NULL
[16:03:39.911]  - attr(*, "where")=List of 2
[16:03:39.911]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:39.911]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:03:39.911]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:39.911]  - attr(*, "resolved")= logi FALSE
[16:03:39.911]  - attr(*, "total_size")= num NA
[16:03:39.913] Packages to be attached in all futures: [n=0] 
[16:03:39.913] getGlobalsAndPackagesXApply() ... DONE
[16:03:39.914] Number of futures (= number of chunks): 2
[16:03:39.914] Launching 2 futures (chunks) ...
[16:03:39.914] Chunk #1 of 2 ...
[16:03:39.914]  - Finding globals in '...' for chunk #1 ...
[16:03:39.914] getGlobalsAndPackages() ...
[16:03:39.914] Searching for globals...
[16:03:39.915] 
[16:03:39.915] Searching for globals ... DONE
[16:03:39.915] - globals: [0] <none>
[16:03:39.915] getGlobalsAndPackages() ... DONE
[16:03:39.915]    + additional globals found: [n=0] 
[16:03:39.915]    + additional namespaces needed: [n=0] 
[16:03:39.915]  - Finding globals in '...' for chunk #1 ... DONE
[16:03:39.915]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:39.915]  - seeds: <none>
[16:03:39.915]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:39.916] getGlobalsAndPackages() ...
[16:03:39.916] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:39.916] Resolving globals: FALSE
[16:03:39.916] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:03:39.917] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:03:39.917] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:39.917] 
[16:03:39.917] getGlobalsAndPackages() ... DONE
[16:03:39.917] run() for ‘Future’ ...
[16:03:39.917] - state: ‘created’
[16:03:39.918] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:39.921] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:39.921] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:39.922]   - Field: ‘label’
[16:03:39.922]   - Field: ‘local’
[16:03:39.922]   - Field: ‘owner’
[16:03:39.922]   - Field: ‘envir’
[16:03:39.922]   - Field: ‘workers’
[16:03:39.922]   - Field: ‘packages’
[16:03:39.922]   - Field: ‘gc’
[16:03:39.922]   - Field: ‘job’
[16:03:39.922]   - Field: ‘conditions’
[16:03:39.922]   - Field: ‘expr’
[16:03:39.922]   - Field: ‘uuid’
[16:03:39.923]   - Field: ‘seed’
[16:03:39.923]   - Field: ‘version’
[16:03:39.923]   - Field: ‘result’
[16:03:39.923]   - Field: ‘asynchronous’
[16:03:39.923]   - Field: ‘calls’
[16:03:39.923]   - Field: ‘globals’
[16:03:39.923]   - Field: ‘stdout’
[16:03:39.923]   - Field: ‘earlySignal’
[16:03:39.923]   - Field: ‘lazy’
[16:03:39.923]   - Field: ‘state’
[16:03:39.924] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:39.924] - Launch lazy future ...
[16:03:39.924] Packages needed by the future expression (n = 0): <none>
[16:03:39.924] Packages needed by future strategies (n = 0): <none>
[16:03:39.925] {
[16:03:39.925]     {
[16:03:39.925]         {
[16:03:39.925]             ...future.startTime <- base::Sys.time()
[16:03:39.925]             {
[16:03:39.925]                 {
[16:03:39.925]                   {
[16:03:39.925]                     {
[16:03:39.925]                       base::local({
[16:03:39.925]                         has_future <- base::requireNamespace("future", 
[16:03:39.925]                           quietly = TRUE)
[16:03:39.925]                         if (has_future) {
[16:03:39.925]                           ns <- base::getNamespace("future")
[16:03:39.925]                           version <- ns[[".package"]][["version"]]
[16:03:39.925]                           if (is.null(version)) 
[16:03:39.925]                             version <- utils::packageVersion("future")
[16:03:39.925]                         }
[16:03:39.925]                         else {
[16:03:39.925]                           version <- NULL
[16:03:39.925]                         }
[16:03:39.925]                         if (!has_future || version < "1.8.0") {
[16:03:39.925]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:39.925]                             "", base::R.version$version.string), 
[16:03:39.925]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:39.925]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:39.925]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:39.925]                               "release", "version")], collapse = " "), 
[16:03:39.925]                             hostname = base::Sys.info()[["nodename"]])
[16:03:39.925]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:39.925]                             info)
[16:03:39.925]                           info <- base::paste(info, collapse = "; ")
[16:03:39.925]                           if (!has_future) {
[16:03:39.925]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:39.925]                               info)
[16:03:39.925]                           }
[16:03:39.925]                           else {
[16:03:39.925]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:39.925]                               info, version)
[16:03:39.925]                           }
[16:03:39.925]                           base::stop(msg)
[16:03:39.925]                         }
[16:03:39.925]                       })
[16:03:39.925]                     }
[16:03:39.925]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:39.925]                     base::options(mc.cores = 1L)
[16:03:39.925]                   }
[16:03:39.925]                   options(future.plan = NULL)
[16:03:39.925]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:39.925]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:39.925]                 }
[16:03:39.925]                 ...future.workdir <- getwd()
[16:03:39.925]             }
[16:03:39.925]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:39.925]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:39.925]         }
[16:03:39.925]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:39.925]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:39.925]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:39.925]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:39.925]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:39.925]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:39.925]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:39.925]             base::names(...future.oldOptions))
[16:03:39.925]     }
[16:03:39.925]     if (TRUE) {
[16:03:39.925]     }
[16:03:39.925]     else {
[16:03:39.925]         if (NA) {
[16:03:39.925]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:39.925]                 open = "w")
[16:03:39.925]         }
[16:03:39.925]         else {
[16:03:39.925]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:39.925]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:39.925]         }
[16:03:39.925]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:39.925]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:39.925]             base::sink(type = "output", split = FALSE)
[16:03:39.925]             base::close(...future.stdout)
[16:03:39.925]         }, add = TRUE)
[16:03:39.925]     }
[16:03:39.925]     ...future.frame <- base::sys.nframe()
[16:03:39.925]     ...future.conditions <- base::list()
[16:03:39.925]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:39.925]     if (FALSE) {
[16:03:39.925]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:39.925]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:39.925]     }
[16:03:39.925]     ...future.result <- base::tryCatch({
[16:03:39.925]         base::withCallingHandlers({
[16:03:39.925]             ...future.value <- base::withVisible(base::local({
[16:03:39.925]                 withCallingHandlers({
[16:03:39.925]                   {
[16:03:39.925]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:39.925]                     if (!identical(...future.globals.maxSize.org, 
[16:03:39.925]                       ...future.globals.maxSize)) {
[16:03:39.925]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:39.925]                       on.exit(options(oopts), add = TRUE)
[16:03:39.925]                     }
[16:03:39.925]                     {
[16:03:39.925]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:39.925]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:03:39.925]                         USE.NAMES = FALSE)
[16:03:39.925]                       do.call(mapply, args = args)
[16:03:39.925]                     }
[16:03:39.925]                   }
[16:03:39.925]                 }, immediateCondition = function(cond) {
[16:03:39.925]                   save_rds <- function (object, pathname, ...) 
[16:03:39.925]                   {
[16:03:39.925]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:39.925]                     if (file_test("-f", pathname_tmp)) {
[16:03:39.925]                       fi_tmp <- file.info(pathname_tmp)
[16:03:39.925]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:39.925]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:39.925]                         fi_tmp[["mtime"]])
[16:03:39.925]                     }
[16:03:39.925]                     tryCatch({
[16:03:39.925]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:39.925]                     }, error = function(ex) {
[16:03:39.925]                       msg <- conditionMessage(ex)
[16:03:39.925]                       fi_tmp <- file.info(pathname_tmp)
[16:03:39.925]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:39.925]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:39.925]                         fi_tmp[["mtime"]], msg)
[16:03:39.925]                       ex$message <- msg
[16:03:39.925]                       stop(ex)
[16:03:39.925]                     })
[16:03:39.925]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:39.925]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:39.925]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:39.925]                       fi_tmp <- file.info(pathname_tmp)
[16:03:39.925]                       fi <- file.info(pathname)
[16:03:39.925]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:39.925]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:39.925]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:39.925]                         fi[["size"]], fi[["mtime"]])
[16:03:39.925]                       stop(msg)
[16:03:39.925]                     }
[16:03:39.925]                     invisible(pathname)
[16:03:39.925]                   }
[16:03:39.925]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:39.925]                     rootPath = tempdir()) 
[16:03:39.925]                   {
[16:03:39.925]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:39.925]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:39.925]                       tmpdir = path, fileext = ".rds")
[16:03:39.925]                     save_rds(obj, file)
[16:03:39.925]                   }
[16:03:39.925]                   saveImmediateCondition(cond, path = "/tmp/Rtmpi1Xc62/.future/immediateConditions")
[16:03:39.925]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:39.925]                   {
[16:03:39.925]                     inherits <- base::inherits
[16:03:39.925]                     invokeRestart <- base::invokeRestart
[16:03:39.925]                     is.null <- base::is.null
[16:03:39.925]                     muffled <- FALSE
[16:03:39.925]                     if (inherits(cond, "message")) {
[16:03:39.925]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:39.925]                       if (muffled) 
[16:03:39.925]                         invokeRestart("muffleMessage")
[16:03:39.925]                     }
[16:03:39.925]                     else if (inherits(cond, "warning")) {
[16:03:39.925]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:39.925]                       if (muffled) 
[16:03:39.925]                         invokeRestart("muffleWarning")
[16:03:39.925]                     }
[16:03:39.925]                     else if (inherits(cond, "condition")) {
[16:03:39.925]                       if (!is.null(pattern)) {
[16:03:39.925]                         computeRestarts <- base::computeRestarts
[16:03:39.925]                         grepl <- base::grepl
[16:03:39.925]                         restarts <- computeRestarts(cond)
[16:03:39.925]                         for (restart in restarts) {
[16:03:39.925]                           name <- restart$name
[16:03:39.925]                           if (is.null(name)) 
[16:03:39.925]                             next
[16:03:39.925]                           if (!grepl(pattern, name)) 
[16:03:39.925]                             next
[16:03:39.925]                           invokeRestart(restart)
[16:03:39.925]                           muffled <- TRUE
[16:03:39.925]                           break
[16:03:39.925]                         }
[16:03:39.925]                       }
[16:03:39.925]                     }
[16:03:39.925]                     invisible(muffled)
[16:03:39.925]                   }
[16:03:39.925]                   muffleCondition(cond)
[16:03:39.925]                 })
[16:03:39.925]             }))
[16:03:39.925]             future::FutureResult(value = ...future.value$value, 
[16:03:39.925]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:39.925]                   ...future.rng), globalenv = if (FALSE) 
[16:03:39.925]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:39.925]                     ...future.globalenv.names))
[16:03:39.925]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:39.925]         }, condition = base::local({
[16:03:39.925]             c <- base::c
[16:03:39.925]             inherits <- base::inherits
[16:03:39.925]             invokeRestart <- base::invokeRestart
[16:03:39.925]             length <- base::length
[16:03:39.925]             list <- base::list
[16:03:39.925]             seq.int <- base::seq.int
[16:03:39.925]             signalCondition <- base::signalCondition
[16:03:39.925]             sys.calls <- base::sys.calls
[16:03:39.925]             `[[` <- base::`[[`
[16:03:39.925]             `+` <- base::`+`
[16:03:39.925]             `<<-` <- base::`<<-`
[16:03:39.925]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:39.925]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:39.925]                   3L)]
[16:03:39.925]             }
[16:03:39.925]             function(cond) {
[16:03:39.925]                 is_error <- inherits(cond, "error")
[16:03:39.925]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:39.925]                   NULL)
[16:03:39.925]                 if (is_error) {
[16:03:39.925]                   sessionInformation <- function() {
[16:03:39.925]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:39.925]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:39.925]                       search = base::search(), system = base::Sys.info())
[16:03:39.925]                   }
[16:03:39.925]                   ...future.conditions[[length(...future.conditions) + 
[16:03:39.925]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:39.925]                     cond$call), session = sessionInformation(), 
[16:03:39.925]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:39.925]                   signalCondition(cond)
[16:03:39.925]                 }
[16:03:39.925]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:39.925]                 "immediateCondition"))) {
[16:03:39.925]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:39.925]                   ...future.conditions[[length(...future.conditions) + 
[16:03:39.925]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:39.925]                   if (TRUE && !signal) {
[16:03:39.925]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:39.925]                     {
[16:03:39.925]                       inherits <- base::inherits
[16:03:39.925]                       invokeRestart <- base::invokeRestart
[16:03:39.925]                       is.null <- base::is.null
[16:03:39.925]                       muffled <- FALSE
[16:03:39.925]                       if (inherits(cond, "message")) {
[16:03:39.925]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:39.925]                         if (muffled) 
[16:03:39.925]                           invokeRestart("muffleMessage")
[16:03:39.925]                       }
[16:03:39.925]                       else if (inherits(cond, "warning")) {
[16:03:39.925]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:39.925]                         if (muffled) 
[16:03:39.925]                           invokeRestart("muffleWarning")
[16:03:39.925]                       }
[16:03:39.925]                       else if (inherits(cond, "condition")) {
[16:03:39.925]                         if (!is.null(pattern)) {
[16:03:39.925]                           computeRestarts <- base::computeRestarts
[16:03:39.925]                           grepl <- base::grepl
[16:03:39.925]                           restarts <- computeRestarts(cond)
[16:03:39.925]                           for (restart in restarts) {
[16:03:39.925]                             name <- restart$name
[16:03:39.925]                             if (is.null(name)) 
[16:03:39.925]                               next
[16:03:39.925]                             if (!grepl(pattern, name)) 
[16:03:39.925]                               next
[16:03:39.925]                             invokeRestart(restart)
[16:03:39.925]                             muffled <- TRUE
[16:03:39.925]                             break
[16:03:39.925]                           }
[16:03:39.925]                         }
[16:03:39.925]                       }
[16:03:39.925]                       invisible(muffled)
[16:03:39.925]                     }
[16:03:39.925]                     muffleCondition(cond, pattern = "^muffle")
[16:03:39.925]                   }
[16:03:39.925]                 }
[16:03:39.925]                 else {
[16:03:39.925]                   if (TRUE) {
[16:03:39.925]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:39.925]                     {
[16:03:39.925]                       inherits <- base::inherits
[16:03:39.925]                       invokeRestart <- base::invokeRestart
[16:03:39.925]                       is.null <- base::is.null
[16:03:39.925]                       muffled <- FALSE
[16:03:39.925]                       if (inherits(cond, "message")) {
[16:03:39.925]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:39.925]                         if (muffled) 
[16:03:39.925]                           invokeRestart("muffleMessage")
[16:03:39.925]                       }
[16:03:39.925]                       else if (inherits(cond, "warning")) {
[16:03:39.925]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:39.925]                         if (muffled) 
[16:03:39.925]                           invokeRestart("muffleWarning")
[16:03:39.925]                       }
[16:03:39.925]                       else if (inherits(cond, "condition")) {
[16:03:39.925]                         if (!is.null(pattern)) {
[16:03:39.925]                           computeRestarts <- base::computeRestarts
[16:03:39.925]                           grepl <- base::grepl
[16:03:39.925]                           restarts <- computeRestarts(cond)
[16:03:39.925]                           for (restart in restarts) {
[16:03:39.925]                             name <- restart$name
[16:03:39.925]                             if (is.null(name)) 
[16:03:39.925]                               next
[16:03:39.925]                             if (!grepl(pattern, name)) 
[16:03:39.925]                               next
[16:03:39.925]                             invokeRestart(restart)
[16:03:39.925]                             muffled <- TRUE
[16:03:39.925]                             break
[16:03:39.925]                           }
[16:03:39.925]                         }
[16:03:39.925]                       }
[16:03:39.925]                       invisible(muffled)
[16:03:39.925]                     }
[16:03:39.925]                     muffleCondition(cond, pattern = "^muffle")
[16:03:39.925]                   }
[16:03:39.925]                 }
[16:03:39.925]             }
[16:03:39.925]         }))
[16:03:39.925]     }, error = function(ex) {
[16:03:39.925]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:39.925]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:39.925]                 ...future.rng), started = ...future.startTime, 
[16:03:39.925]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:39.925]             version = "1.8"), class = "FutureResult")
[16:03:39.925]     }, finally = {
[16:03:39.925]         if (!identical(...future.workdir, getwd())) 
[16:03:39.925]             setwd(...future.workdir)
[16:03:39.925]         {
[16:03:39.925]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:39.925]                 ...future.oldOptions$nwarnings <- NULL
[16:03:39.925]             }
[16:03:39.925]             base::options(...future.oldOptions)
[16:03:39.925]             if (.Platform$OS.type == "windows") {
[16:03:39.925]                 old_names <- names(...future.oldEnvVars)
[16:03:39.925]                 envs <- base::Sys.getenv()
[16:03:39.925]                 names <- names(envs)
[16:03:39.925]                 common <- intersect(names, old_names)
[16:03:39.925]                 added <- setdiff(names, old_names)
[16:03:39.925]                 removed <- setdiff(old_names, names)
[16:03:39.925]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:39.925]                   envs[common]]
[16:03:39.925]                 NAMES <- toupper(changed)
[16:03:39.925]                 args <- list()
[16:03:39.925]                 for (kk in seq_along(NAMES)) {
[16:03:39.925]                   name <- changed[[kk]]
[16:03:39.925]                   NAME <- NAMES[[kk]]
[16:03:39.925]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:39.925]                     next
[16:03:39.925]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:39.925]                 }
[16:03:39.925]                 NAMES <- toupper(added)
[16:03:39.925]                 for (kk in seq_along(NAMES)) {
[16:03:39.925]                   name <- added[[kk]]
[16:03:39.925]                   NAME <- NAMES[[kk]]
[16:03:39.925]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:39.925]                     next
[16:03:39.925]                   args[[name]] <- ""
[16:03:39.925]                 }
[16:03:39.925]                 NAMES <- toupper(removed)
[16:03:39.925]                 for (kk in seq_along(NAMES)) {
[16:03:39.925]                   name <- removed[[kk]]
[16:03:39.925]                   NAME <- NAMES[[kk]]
[16:03:39.925]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:39.925]                     next
[16:03:39.925]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:39.925]                 }
[16:03:39.925]                 if (length(args) > 0) 
[16:03:39.925]                   base::do.call(base::Sys.setenv, args = args)
[16:03:39.925]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:39.925]             }
[16:03:39.925]             else {
[16:03:39.925]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:39.925]             }
[16:03:39.925]             {
[16:03:39.925]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:39.925]                   0L) {
[16:03:39.925]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:39.925]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:39.925]                   base::options(opts)
[16:03:39.925]                 }
[16:03:39.925]                 {
[16:03:39.925]                   {
[16:03:39.925]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:39.925]                     NULL
[16:03:39.925]                   }
[16:03:39.925]                   options(future.plan = NULL)
[16:03:39.925]                   if (is.na(NA_character_)) 
[16:03:39.925]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:39.925]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:39.925]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:39.925]                     envir = parent.frame()) 
[16:03:39.925]                   {
[16:03:39.925]                     default_workers <- missing(workers)
[16:03:39.925]                     if (is.function(workers)) 
[16:03:39.925]                       workers <- workers()
[16:03:39.925]                     workers <- structure(as.integer(workers), 
[16:03:39.925]                       class = class(workers))
[16:03:39.925]                     stop_if_not(is.finite(workers), workers >= 
[16:03:39.925]                       1L)
[16:03:39.925]                     if ((workers == 1L && !inherits(workers, 
[16:03:39.925]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:39.925]                       if (default_workers) 
[16:03:39.925]                         supportsMulticore(warn = TRUE)
[16:03:39.925]                       return(sequential(..., envir = envir))
[16:03:39.925]                     }
[16:03:39.925]                     oopts <- options(mc.cores = workers)
[16:03:39.925]                     on.exit(options(oopts))
[16:03:39.925]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:39.925]                       envir = envir)
[16:03:39.925]                     if (!future$lazy) 
[16:03:39.925]                       future <- run(future)
[16:03:39.925]                     invisible(future)
[16:03:39.925]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:39.925]                 }
[16:03:39.925]             }
[16:03:39.925]         }
[16:03:39.925]     })
[16:03:39.925]     if (FALSE) {
[16:03:39.925]         base::sink(type = "output", split = FALSE)
[16:03:39.925]         if (NA) {
[16:03:39.925]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:39.925]         }
[16:03:39.925]         else {
[16:03:39.925]             ...future.result["stdout"] <- base::list(NULL)
[16:03:39.925]         }
[16:03:39.925]         base::close(...future.stdout)
[16:03:39.925]         ...future.stdout <- NULL
[16:03:39.925]     }
[16:03:39.925]     ...future.result$conditions <- ...future.conditions
[16:03:39.925]     ...future.result$finished <- base::Sys.time()
[16:03:39.925]     ...future.result
[16:03:39.925] }
[16:03:39.927] assign_globals() ...
[16:03:39.927] List of 5
[16:03:39.927]  $ ...future.FUN            :function (x, y)  
[16:03:39.927]  $ MoreArgs                 : NULL
[16:03:39.927]  $ ...future.elements_ii    :List of 2
[16:03:39.927]   ..$ :List of 1
[16:03:39.927]   .. ..$ : int 1
[16:03:39.927]   ..$ :List of 1
[16:03:39.927]   .. ..$ : int 0
[16:03:39.927]  $ ...future.seeds_ii       : NULL
[16:03:39.927]  $ ...future.globals.maxSize: NULL
[16:03:39.927]  - attr(*, "where")=List of 5
[16:03:39.927]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:39.927]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:03:39.927]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:39.927]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:39.927]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:39.927]  - attr(*, "resolved")= logi FALSE
[16:03:39.927]  - attr(*, "total_size")= num 6368
[16:03:39.927]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:39.927]  - attr(*, "already-done")= logi TRUE
[16:03:39.934] - reassign environment for ‘...future.FUN’
[16:03:39.935] - copied ‘...future.FUN’ to environment
[16:03:39.935] - copied ‘MoreArgs’ to environment
[16:03:39.935] - copied ‘...future.elements_ii’ to environment
[16:03:39.935] - copied ‘...future.seeds_ii’ to environment
[16:03:39.935] - copied ‘...future.globals.maxSize’ to environment
[16:03:39.935] assign_globals() ... done
[16:03:39.935] requestCore(): workers = 2
[16:03:39.938] MulticoreFuture started
[16:03:39.938] - Launch lazy future ... done
[16:03:39.938] run() for ‘MulticoreFuture’ ... done
[16:03:39.939] plan(): Setting new future strategy stack:
[16:03:39.939] Created future:
[16:03:39.939] List of future strategies:
[16:03:39.939] 1. sequential:
[16:03:39.939]    - args: function (..., envir = parent.frame())
[16:03:39.939]    - tweaked: FALSE
[16:03:39.939]    - call: NULL
[16:03:39.940] plan(): nbrOfWorkers() = 1
[16:03:39.939] MulticoreFuture:
[16:03:39.939] Label: ‘future_mapply-1’
[16:03:39.939] Expression:
[16:03:39.939] {
[16:03:39.939]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:39.939]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:39.939]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:39.939]         on.exit(options(oopts), add = TRUE)
[16:03:39.939]     }
[16:03:39.939]     {
[16:03:39.939]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:39.939]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:03:39.939]         do.call(mapply, args = args)
[16:03:39.939]     }
[16:03:39.939] }
[16:03:39.939] Lazy evaluation: FALSE
[16:03:39.939] Asynchronous evaluation: TRUE
[16:03:39.939] Local evaluation: TRUE
[16:03:39.939] Environment: R_GlobalEnv
[16:03:39.939] Capture standard output: NA
[16:03:39.939] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:39.939] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:39.939] Packages: <none>
[16:03:39.939] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:39.939] Resolved: FALSE
[16:03:39.939] Value: <not collected>
[16:03:39.939] Conditions captured: <none>
[16:03:39.939] Early signaling: FALSE
[16:03:39.939] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:39.939] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:39.952] Chunk #1 of 2 ... DONE
[16:03:39.952] Chunk #2 of 2 ...
[16:03:39.953]  - Finding globals in '...' for chunk #2 ...
[16:03:39.953] getGlobalsAndPackages() ...
[16:03:39.953] Searching for globals...
[16:03:39.954] 
[16:03:39.954] Searching for globals ... DONE
[16:03:39.954] - globals: [0] <none>
[16:03:39.954] getGlobalsAndPackages() ... DONE
[16:03:39.954]    + additional globals found: [n=0] 
[16:03:39.955]    + additional namespaces needed: [n=0] 
[16:03:39.955]  - Finding globals in '...' for chunk #2 ... DONE
[16:03:39.955]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:39.955]  - seeds: <none>
[16:03:39.955]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:39.956] getGlobalsAndPackages() ...
[16:03:39.956] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:39.956] Resolving globals: FALSE
[16:03:39.957] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:03:39.958] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:03:39.958] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:39.958] 
[16:03:39.958] getGlobalsAndPackages() ... DONE
[16:03:39.959] run() for ‘Future’ ...
[16:03:39.959] - state: ‘created’
[16:03:39.959] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:03:39.964] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:39.964] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:03:39.964]   - Field: ‘label’
[16:03:39.965]   - Field: ‘local’
[16:03:39.965]   - Field: ‘owner’
[16:03:39.965]   - Field: ‘envir’
[16:03:39.965]   - Field: ‘workers’
[16:03:39.965]   - Field: ‘packages’
[16:03:39.965]   - Field: ‘gc’
[16:03:39.966]   - Field: ‘job’
[16:03:39.966]   - Field: ‘conditions’
[16:03:39.966]   - Field: ‘expr’
[16:03:39.966]   - Field: ‘uuid’
[16:03:39.966]   - Field: ‘seed’
[16:03:39.966]   - Field: ‘version’
[16:03:39.966]   - Field: ‘result’
[16:03:39.967]   - Field: ‘asynchronous’
[16:03:39.967]   - Field: ‘calls’
[16:03:39.967]   - Field: ‘globals’
[16:03:39.967]   - Field: ‘stdout’
[16:03:39.967]   - Field: ‘earlySignal’
[16:03:39.967]   - Field: ‘lazy’
[16:03:39.967]   - Field: ‘state’
[16:03:39.968] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:03:39.968] - Launch lazy future ...
[16:03:39.968] Packages needed by the future expression (n = 0): <none>
[16:03:39.968] Packages needed by future strategies (n = 0): <none>
[16:03:39.969] {
[16:03:39.969]     {
[16:03:39.969]         {
[16:03:39.969]             ...future.startTime <- base::Sys.time()
[16:03:39.969]             {
[16:03:39.969]                 {
[16:03:39.969]                   {
[16:03:39.969]                     {
[16:03:39.969]                       base::local({
[16:03:39.969]                         has_future <- base::requireNamespace("future", 
[16:03:39.969]                           quietly = TRUE)
[16:03:39.969]                         if (has_future) {
[16:03:39.969]                           ns <- base::getNamespace("future")
[16:03:39.969]                           version <- ns[[".package"]][["version"]]
[16:03:39.969]                           if (is.null(version)) 
[16:03:39.969]                             version <- utils::packageVersion("future")
[16:03:39.969]                         }
[16:03:39.969]                         else {
[16:03:39.969]                           version <- NULL
[16:03:39.969]                         }
[16:03:39.969]                         if (!has_future || version < "1.8.0") {
[16:03:39.969]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:39.969]                             "", base::R.version$version.string), 
[16:03:39.969]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:39.969]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:39.969]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:39.969]                               "release", "version")], collapse = " "), 
[16:03:39.969]                             hostname = base::Sys.info()[["nodename"]])
[16:03:39.969]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:39.969]                             info)
[16:03:39.969]                           info <- base::paste(info, collapse = "; ")
[16:03:39.969]                           if (!has_future) {
[16:03:39.969]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:39.969]                               info)
[16:03:39.969]                           }
[16:03:39.969]                           else {
[16:03:39.969]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:39.969]                               info, version)
[16:03:39.969]                           }
[16:03:39.969]                           base::stop(msg)
[16:03:39.969]                         }
[16:03:39.969]                       })
[16:03:39.969]                     }
[16:03:39.969]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:39.969]                     base::options(mc.cores = 1L)
[16:03:39.969]                   }
[16:03:39.969]                   options(future.plan = NULL)
[16:03:39.969]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:39.969]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:39.969]                 }
[16:03:39.969]                 ...future.workdir <- getwd()
[16:03:39.969]             }
[16:03:39.969]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:39.969]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:39.969]         }
[16:03:39.969]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:39.969]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:39.969]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:39.969]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:39.969]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:39.969]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:39.969]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:39.969]             base::names(...future.oldOptions))
[16:03:39.969]     }
[16:03:39.969]     if (TRUE) {
[16:03:39.969]     }
[16:03:39.969]     else {
[16:03:39.969]         if (NA) {
[16:03:39.969]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:39.969]                 open = "w")
[16:03:39.969]         }
[16:03:39.969]         else {
[16:03:39.969]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:39.969]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:39.969]         }
[16:03:39.969]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:39.969]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:39.969]             base::sink(type = "output", split = FALSE)
[16:03:39.969]             base::close(...future.stdout)
[16:03:39.969]         }, add = TRUE)
[16:03:39.969]     }
[16:03:39.969]     ...future.frame <- base::sys.nframe()
[16:03:39.969]     ...future.conditions <- base::list()
[16:03:39.969]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:39.969]     if (FALSE) {
[16:03:39.969]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:39.969]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:39.969]     }
[16:03:39.969]     ...future.result <- base::tryCatch({
[16:03:39.969]         base::withCallingHandlers({
[16:03:39.969]             ...future.value <- base::withVisible(base::local({
[16:03:39.969]                 withCallingHandlers({
[16:03:39.969]                   {
[16:03:39.969]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:39.969]                     if (!identical(...future.globals.maxSize.org, 
[16:03:39.969]                       ...future.globals.maxSize)) {
[16:03:39.969]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:39.969]                       on.exit(options(oopts), add = TRUE)
[16:03:39.969]                     }
[16:03:39.969]                     {
[16:03:39.969]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:39.969]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:03:39.969]                         USE.NAMES = FALSE)
[16:03:39.969]                       do.call(mapply, args = args)
[16:03:39.969]                     }
[16:03:39.969]                   }
[16:03:39.969]                 }, immediateCondition = function(cond) {
[16:03:39.969]                   save_rds <- function (object, pathname, ...) 
[16:03:39.969]                   {
[16:03:39.969]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:03:39.969]                     if (file_test("-f", pathname_tmp)) {
[16:03:39.969]                       fi_tmp <- file.info(pathname_tmp)
[16:03:39.969]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:03:39.969]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:39.969]                         fi_tmp[["mtime"]])
[16:03:39.969]                     }
[16:03:39.969]                     tryCatch({
[16:03:39.969]                       saveRDS(object, file = pathname_tmp, ...)
[16:03:39.969]                     }, error = function(ex) {
[16:03:39.969]                       msg <- conditionMessage(ex)
[16:03:39.969]                       fi_tmp <- file.info(pathname_tmp)
[16:03:39.969]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:03:39.969]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:39.969]                         fi_tmp[["mtime"]], msg)
[16:03:39.969]                       ex$message <- msg
[16:03:39.969]                       stop(ex)
[16:03:39.969]                     })
[16:03:39.969]                     stopifnot(file_test("-f", pathname_tmp))
[16:03:39.969]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:03:39.969]                     if (!res || file_test("-f", pathname_tmp)) {
[16:03:39.969]                       fi_tmp <- file.info(pathname_tmp)
[16:03:39.969]                       fi <- file.info(pathname)
[16:03:39.969]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:03:39.969]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:03:39.969]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:03:39.969]                         fi[["size"]], fi[["mtime"]])
[16:03:39.969]                       stop(msg)
[16:03:39.969]                     }
[16:03:39.969]                     invisible(pathname)
[16:03:39.969]                   }
[16:03:39.969]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:03:39.969]                     rootPath = tempdir()) 
[16:03:39.969]                   {
[16:03:39.969]                     obj <- list(time = Sys.time(), condition = cond)
[16:03:39.969]                     file <- tempfile(pattern = class(cond)[1], 
[16:03:39.969]                       tmpdir = path, fileext = ".rds")
[16:03:39.969]                     save_rds(obj, file)
[16:03:39.969]                   }
[16:03:39.969]                   saveImmediateCondition(cond, path = "/tmp/Rtmpi1Xc62/.future/immediateConditions")
[16:03:39.969]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:39.969]                   {
[16:03:39.969]                     inherits <- base::inherits
[16:03:39.969]                     invokeRestart <- base::invokeRestart
[16:03:39.969]                     is.null <- base::is.null
[16:03:39.969]                     muffled <- FALSE
[16:03:39.969]                     if (inherits(cond, "message")) {
[16:03:39.969]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:39.969]                       if (muffled) 
[16:03:39.969]                         invokeRestart("muffleMessage")
[16:03:39.969]                     }
[16:03:39.969]                     else if (inherits(cond, "warning")) {
[16:03:39.969]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:39.969]                       if (muffled) 
[16:03:39.969]                         invokeRestart("muffleWarning")
[16:03:39.969]                     }
[16:03:39.969]                     else if (inherits(cond, "condition")) {
[16:03:39.969]                       if (!is.null(pattern)) {
[16:03:39.969]                         computeRestarts <- base::computeRestarts
[16:03:39.969]                         grepl <- base::grepl
[16:03:39.969]                         restarts <- computeRestarts(cond)
[16:03:39.969]                         for (restart in restarts) {
[16:03:39.969]                           name <- restart$name
[16:03:39.969]                           if (is.null(name)) 
[16:03:39.969]                             next
[16:03:39.969]                           if (!grepl(pattern, name)) 
[16:03:39.969]                             next
[16:03:39.969]                           invokeRestart(restart)
[16:03:39.969]                           muffled <- TRUE
[16:03:39.969]                           break
[16:03:39.969]                         }
[16:03:39.969]                       }
[16:03:39.969]                     }
[16:03:39.969]                     invisible(muffled)
[16:03:39.969]                   }
[16:03:39.969]                   muffleCondition(cond)
[16:03:39.969]                 })
[16:03:39.969]             }))
[16:03:39.969]             future::FutureResult(value = ...future.value$value, 
[16:03:39.969]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:39.969]                   ...future.rng), globalenv = if (FALSE) 
[16:03:39.969]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:39.969]                     ...future.globalenv.names))
[16:03:39.969]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:39.969]         }, condition = base::local({
[16:03:39.969]             c <- base::c
[16:03:39.969]             inherits <- base::inherits
[16:03:39.969]             invokeRestart <- base::invokeRestart
[16:03:39.969]             length <- base::length
[16:03:39.969]             list <- base::list
[16:03:39.969]             seq.int <- base::seq.int
[16:03:39.969]             signalCondition <- base::signalCondition
[16:03:39.969]             sys.calls <- base::sys.calls
[16:03:39.969]             `[[` <- base::`[[`
[16:03:39.969]             `+` <- base::`+`
[16:03:39.969]             `<<-` <- base::`<<-`
[16:03:39.969]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:39.969]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:39.969]                   3L)]
[16:03:39.969]             }
[16:03:39.969]             function(cond) {
[16:03:39.969]                 is_error <- inherits(cond, "error")
[16:03:39.969]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:39.969]                   NULL)
[16:03:39.969]                 if (is_error) {
[16:03:39.969]                   sessionInformation <- function() {
[16:03:39.969]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:39.969]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:39.969]                       search = base::search(), system = base::Sys.info())
[16:03:39.969]                   }
[16:03:39.969]                   ...future.conditions[[length(...future.conditions) + 
[16:03:39.969]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:39.969]                     cond$call), session = sessionInformation(), 
[16:03:39.969]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:39.969]                   signalCondition(cond)
[16:03:39.969]                 }
[16:03:39.969]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:39.969]                 "immediateCondition"))) {
[16:03:39.969]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:39.969]                   ...future.conditions[[length(...future.conditions) + 
[16:03:39.969]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:39.969]                   if (TRUE && !signal) {
[16:03:39.969]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:39.969]                     {
[16:03:39.969]                       inherits <- base::inherits
[16:03:39.969]                       invokeRestart <- base::invokeRestart
[16:03:39.969]                       is.null <- base::is.null
[16:03:39.969]                       muffled <- FALSE
[16:03:39.969]                       if (inherits(cond, "message")) {
[16:03:39.969]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:39.969]                         if (muffled) 
[16:03:39.969]                           invokeRestart("muffleMessage")
[16:03:39.969]                       }
[16:03:39.969]                       else if (inherits(cond, "warning")) {
[16:03:39.969]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:39.969]                         if (muffled) 
[16:03:39.969]                           invokeRestart("muffleWarning")
[16:03:39.969]                       }
[16:03:39.969]                       else if (inherits(cond, "condition")) {
[16:03:39.969]                         if (!is.null(pattern)) {
[16:03:39.969]                           computeRestarts <- base::computeRestarts
[16:03:39.969]                           grepl <- base::grepl
[16:03:39.969]                           restarts <- computeRestarts(cond)
[16:03:39.969]                           for (restart in restarts) {
[16:03:39.969]                             name <- restart$name
[16:03:39.969]                             if (is.null(name)) 
[16:03:39.969]                               next
[16:03:39.969]                             if (!grepl(pattern, name)) 
[16:03:39.969]                               next
[16:03:39.969]                             invokeRestart(restart)
[16:03:39.969]                             muffled <- TRUE
[16:03:39.969]                             break
[16:03:39.969]                           }
[16:03:39.969]                         }
[16:03:39.969]                       }
[16:03:39.969]                       invisible(muffled)
[16:03:39.969]                     }
[16:03:39.969]                     muffleCondition(cond, pattern = "^muffle")
[16:03:39.969]                   }
[16:03:39.969]                 }
[16:03:39.969]                 else {
[16:03:39.969]                   if (TRUE) {
[16:03:39.969]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:39.969]                     {
[16:03:39.969]                       inherits <- base::inherits
[16:03:39.969]                       invokeRestart <- base::invokeRestart
[16:03:39.969]                       is.null <- base::is.null
[16:03:39.969]                       muffled <- FALSE
[16:03:39.969]                       if (inherits(cond, "message")) {
[16:03:39.969]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:39.969]                         if (muffled) 
[16:03:39.969]                           invokeRestart("muffleMessage")
[16:03:39.969]                       }
[16:03:39.969]                       else if (inherits(cond, "warning")) {
[16:03:39.969]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:39.969]                         if (muffled) 
[16:03:39.969]                           invokeRestart("muffleWarning")
[16:03:39.969]                       }
[16:03:39.969]                       else if (inherits(cond, "condition")) {
[16:03:39.969]                         if (!is.null(pattern)) {
[16:03:39.969]                           computeRestarts <- base::computeRestarts
[16:03:39.969]                           grepl <- base::grepl
[16:03:39.969]                           restarts <- computeRestarts(cond)
[16:03:39.969]                           for (restart in restarts) {
[16:03:39.969]                             name <- restart$name
[16:03:39.969]                             if (is.null(name)) 
[16:03:39.969]                               next
[16:03:39.969]                             if (!grepl(pattern, name)) 
[16:03:39.969]                               next
[16:03:39.969]                             invokeRestart(restart)
[16:03:39.969]                             muffled <- TRUE
[16:03:39.969]                             break
[16:03:39.969]                           }
[16:03:39.969]                         }
[16:03:39.969]                       }
[16:03:39.969]                       invisible(muffled)
[16:03:39.969]                     }
[16:03:39.969]                     muffleCondition(cond, pattern = "^muffle")
[16:03:39.969]                   }
[16:03:39.969]                 }
[16:03:39.969]             }
[16:03:39.969]         }))
[16:03:39.969]     }, error = function(ex) {
[16:03:39.969]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:39.969]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:39.969]                 ...future.rng), started = ...future.startTime, 
[16:03:39.969]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:39.969]             version = "1.8"), class = "FutureResult")
[16:03:39.969]     }, finally = {
[16:03:39.969]         if (!identical(...future.workdir, getwd())) 
[16:03:39.969]             setwd(...future.workdir)
[16:03:39.969]         {
[16:03:39.969]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:39.969]                 ...future.oldOptions$nwarnings <- NULL
[16:03:39.969]             }
[16:03:39.969]             base::options(...future.oldOptions)
[16:03:39.969]             if (.Platform$OS.type == "windows") {
[16:03:39.969]                 old_names <- names(...future.oldEnvVars)
[16:03:39.969]                 envs <- base::Sys.getenv()
[16:03:39.969]                 names <- names(envs)
[16:03:39.969]                 common <- intersect(names, old_names)
[16:03:39.969]                 added <- setdiff(names, old_names)
[16:03:39.969]                 removed <- setdiff(old_names, names)
[16:03:39.969]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:39.969]                   envs[common]]
[16:03:39.969]                 NAMES <- toupper(changed)
[16:03:39.969]                 args <- list()
[16:03:39.969]                 for (kk in seq_along(NAMES)) {
[16:03:39.969]                   name <- changed[[kk]]
[16:03:39.969]                   NAME <- NAMES[[kk]]
[16:03:39.969]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:39.969]                     next
[16:03:39.969]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:39.969]                 }
[16:03:39.969]                 NAMES <- toupper(added)
[16:03:39.969]                 for (kk in seq_along(NAMES)) {
[16:03:39.969]                   name <- added[[kk]]
[16:03:39.969]                   NAME <- NAMES[[kk]]
[16:03:39.969]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:39.969]                     next
[16:03:39.969]                   args[[name]] <- ""
[16:03:39.969]                 }
[16:03:39.969]                 NAMES <- toupper(removed)
[16:03:39.969]                 for (kk in seq_along(NAMES)) {
[16:03:39.969]                   name <- removed[[kk]]
[16:03:39.969]                   NAME <- NAMES[[kk]]
[16:03:39.969]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:39.969]                     next
[16:03:39.969]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:39.969]                 }
[16:03:39.969]                 if (length(args) > 0) 
[16:03:39.969]                   base::do.call(base::Sys.setenv, args = args)
[16:03:39.969]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:39.969]             }
[16:03:39.969]             else {
[16:03:39.969]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:39.969]             }
[16:03:39.969]             {
[16:03:39.969]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:39.969]                   0L) {
[16:03:39.969]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:39.969]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:39.969]                   base::options(opts)
[16:03:39.969]                 }
[16:03:39.969]                 {
[16:03:39.969]                   {
[16:03:39.969]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:39.969]                     NULL
[16:03:39.969]                   }
[16:03:39.969]                   options(future.plan = NULL)
[16:03:39.969]                   if (is.na(NA_character_)) 
[16:03:39.969]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:39.969]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:39.969]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:03:39.969]                     envir = parent.frame()) 
[16:03:39.969]                   {
[16:03:39.969]                     default_workers <- missing(workers)
[16:03:39.969]                     if (is.function(workers)) 
[16:03:39.969]                       workers <- workers()
[16:03:39.969]                     workers <- structure(as.integer(workers), 
[16:03:39.969]                       class = class(workers))
[16:03:39.969]                     stop_if_not(is.finite(workers), workers >= 
[16:03:39.969]                       1L)
[16:03:39.969]                     if ((workers == 1L && !inherits(workers, 
[16:03:39.969]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:03:39.969]                       if (default_workers) 
[16:03:39.969]                         supportsMulticore(warn = TRUE)
[16:03:39.969]                       return(sequential(..., envir = envir))
[16:03:39.969]                     }
[16:03:39.969]                     oopts <- options(mc.cores = workers)
[16:03:39.969]                     on.exit(options(oopts))
[16:03:39.969]                     future <- MulticoreFuture(..., workers = workers, 
[16:03:39.969]                       envir = envir)
[16:03:39.969]                     if (!future$lazy) 
[16:03:39.969]                       future <- run(future)
[16:03:39.969]                     invisible(future)
[16:03:39.969]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:39.969]                 }
[16:03:39.969]             }
[16:03:39.969]         }
[16:03:39.969]     })
[16:03:39.969]     if (FALSE) {
[16:03:39.969]         base::sink(type = "output", split = FALSE)
[16:03:39.969]         if (NA) {
[16:03:39.969]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:39.969]         }
[16:03:39.969]         else {
[16:03:39.969]             ...future.result["stdout"] <- base::list(NULL)
[16:03:39.969]         }
[16:03:39.969]         base::close(...future.stdout)
[16:03:39.969]         ...future.stdout <- NULL
[16:03:39.969]     }
[16:03:39.969]     ...future.result$conditions <- ...future.conditions
[16:03:39.969]     ...future.result$finished <- base::Sys.time()
[16:03:39.969]     ...future.result
[16:03:39.969] }
[16:03:39.973] assign_globals() ...
[16:03:39.973] List of 5
[16:03:39.973]  $ ...future.FUN            :function (x, y)  
[16:03:39.973]  $ MoreArgs                 : NULL
[16:03:39.973]  $ ...future.elements_ii    :List of 2
[16:03:39.973]   ..$ :List of 1
[16:03:39.973]   .. ..$ : int 0
[16:03:39.973]   ..$ :List of 1
[16:03:39.973]   .. ..$ : int 1
[16:03:39.973]  $ ...future.seeds_ii       : NULL
[16:03:39.973]  $ ...future.globals.maxSize: NULL
[16:03:39.973]  - attr(*, "where")=List of 5
[16:03:39.973]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:03:39.973]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:03:39.973]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:03:39.973]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:03:39.973]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:03:39.973]  - attr(*, "resolved")= logi FALSE
[16:03:39.973]  - attr(*, "total_size")= num 6368
[16:03:39.973]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:39.973]  - attr(*, "already-done")= logi TRUE
[16:03:39.981] - reassign environment for ‘...future.FUN’
[16:03:39.983] - copied ‘...future.FUN’ to environment
[16:03:39.983] - copied ‘MoreArgs’ to environment
[16:03:39.984] - copied ‘...future.elements_ii’ to environment
[16:03:39.984] - copied ‘...future.seeds_ii’ to environment
[16:03:39.984] - copied ‘...future.globals.maxSize’ to environment
[16:03:39.984] assign_globals() ... done
[16:03:39.985] requestCore(): workers = 2
[16:03:39.987] MulticoreFuture started
[16:03:39.988] - Launch lazy future ... done
[16:03:39.988] plan(): Setting new future strategy stack:
[16:03:39.988] run() for ‘MulticoreFuture’ ... done
[16:03:39.989] Created future:
[16:03:39.989] List of future strategies:
[16:03:39.989] 1. sequential:
[16:03:39.989]    - args: function (..., envir = parent.frame())
[16:03:39.989]    - tweaked: FALSE
[16:03:39.989]    - call: NULL
[16:03:39.990] plan(): nbrOfWorkers() = 1
[16:03:39.993] plan(): Setting new future strategy stack:
[16:03:39.993] List of future strategies:
[16:03:39.993] 1. multicore:
[16:03:39.993]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:39.993]    - tweaked: FALSE
[16:03:39.993]    - call: plan(strategy)
[16:03:40.000] plan(): nbrOfWorkers() = 2
[16:03:39.990] MulticoreFuture:
[16:03:39.990] Label: ‘future_mapply-2’
[16:03:39.990] Expression:
[16:03:39.990] {
[16:03:39.990]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:39.990]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:39.990]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:39.990]         on.exit(options(oopts), add = TRUE)
[16:03:39.990]     }
[16:03:39.990]     {
[16:03:39.990]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:39.990]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:03:39.990]         do.call(mapply, args = args)
[16:03:39.990]     }
[16:03:39.990] }
[16:03:39.990] Lazy evaluation: FALSE
[16:03:39.990] Asynchronous evaluation: TRUE
[16:03:39.990] Local evaluation: TRUE
[16:03:39.990] Environment: R_GlobalEnv
[16:03:39.990] Capture standard output: NA
[16:03:39.990] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:39.990] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:39.990] Packages: <none>
[16:03:39.990] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:39.990] Resolved: TRUE
[16:03:39.990] Value: <not collected>
[16:03:39.990] Conditions captured: <none>
[16:03:39.990] Early signaling: FALSE
[16:03:39.990] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:39.990] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:40.001] Chunk #2 of 2 ... DONE
[16:03:40.001] Launching 2 futures (chunks) ... DONE
[16:03:40.002] Resolving 2 futures (chunks) ...
[16:03:40.002] resolve() on list ...
[16:03:40.002]  recursive: 0
[16:03:40.002]  length: 2
[16:03:40.002] 
[16:03:40.013] Future #2
[16:03:40.013] result() for MulticoreFuture ...
[16:03:40.015] result() for MulticoreFuture ...
[16:03:40.015] result() for MulticoreFuture ... done
[16:03:40.015] result() for MulticoreFuture ... done
[16:03:40.015] result() for MulticoreFuture ...
[16:03:40.015] result() for MulticoreFuture ... done
[16:03:40.016] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:03:40.016] - nx: 2
[16:03:40.016] - relay: TRUE
[16:03:40.016] - stdout: TRUE
[16:03:40.016] - signal: TRUE
[16:03:40.016] - resignal: FALSE
[16:03:40.017] - force: TRUE
[16:03:40.017] - relayed: [n=2] FALSE, FALSE
[16:03:40.017] - queued futures: [n=2] FALSE, FALSE
[16:03:40.017]  - until=1
[16:03:40.017]  - relaying element #1
[16:03:40.017] - relayed: [n=2] FALSE, FALSE
[16:03:40.017] - queued futures: [n=2] FALSE, TRUE
[16:03:40.018] signalConditionsASAP(NULL, pos=2) ... done
[16:03:40.018]  length: 1 (resolved future 2)
[16:03:40.443] plan(): Setting new future strategy stack:
[16:03:40.443] List of future strategies:
[16:03:40.443] 1. multicore:
[16:03:40.443]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:03:40.443]    - tweaked: FALSE
[16:03:40.443]    - call: plan(strategy)
[16:03:40.448] plan(): nbrOfWorkers() = 2
[16:03:40.456] Future #1
[16:03:40.456] result() for MulticoreFuture ...
[16:03:40.457] result() for MulticoreFuture ...
[16:03:40.457] result() for MulticoreFuture ... done
[16:03:40.457] result() for MulticoreFuture ... done
[16:03:40.457] result() for MulticoreFuture ...
[16:03:40.457] result() for MulticoreFuture ... done
[16:03:40.458] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:03:40.458] - nx: 2
[16:03:40.458] - relay: TRUE
[16:03:40.458] - stdout: TRUE
[16:03:40.458] - signal: TRUE
[16:03:40.458] - resignal: FALSE
[16:03:40.458] - force: TRUE
[16:03:40.458] - relayed: [n=2] FALSE, FALSE
[16:03:40.458] - queued futures: [n=2] FALSE, TRUE
[16:03:40.459]  - until=1
[16:03:40.459]  - relaying element #1
[16:03:40.459] result() for MulticoreFuture ...
[16:03:40.459] result() for MulticoreFuture ... done
[16:03:40.459] result() for MulticoreFuture ...
[16:03:40.459] result() for MulticoreFuture ... done
[16:03:40.459] result() for MulticoreFuture ...
[16:03:40.459] result() for MulticoreFuture ... done
[16:03:40.460] result() for MulticoreFuture ...
[16:03:40.460] result() for MulticoreFuture ... done
[16:03:40.460] - relayed: [n=2] TRUE, FALSE
[16:03:40.460] - queued futures: [n=2] TRUE, TRUE
[16:03:40.460] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:03:40.460]  length: 0 (resolved future 1)
[16:03:40.460] Relaying remaining futures
[16:03:40.460] signalConditionsASAP(NULL, pos=0) ...
[16:03:40.460] - nx: 2
[16:03:40.461] - relay: TRUE
[16:03:40.461] - stdout: TRUE
[16:03:40.461] - signal: TRUE
[16:03:40.461] - resignal: FALSE
[16:03:40.461] - force: TRUE
[16:03:40.461] - relayed: [n=2] TRUE, FALSE
[16:03:40.461] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:40.461]  - relaying element #2
[16:03:40.461] result() for MulticoreFuture ...
[16:03:40.461] result() for MulticoreFuture ... done
[16:03:40.462] result() for MulticoreFuture ...
[16:03:40.462] result() for MulticoreFuture ... done
[16:03:40.462] result() for MulticoreFuture ...
[16:03:40.462] result() for MulticoreFuture ... done
[16:03:40.462] result() for MulticoreFuture ...
[16:03:40.462] result() for MulticoreFuture ... done
[16:03:40.462] - relayed: [n=2] TRUE, TRUE
[16:03:40.462] - queued futures: [n=2] TRUE, TRUE
[16:03:40.462] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[16:03:40.463] resolve() on list ... DONE
[16:03:40.463] result() for MulticoreFuture ...
[16:03:40.463] result() for MulticoreFuture ... done
[16:03:40.463] result() for MulticoreFuture ...
[16:03:40.463] result() for MulticoreFuture ... done
[16:03:40.463] result() for MulticoreFuture ...
[16:03:40.463] result() for MulticoreFuture ... done
[16:03:40.463] result() for MulticoreFuture ...
[16:03:40.463] result() for MulticoreFuture ... done
[16:03:40.464]  - Number of value chunks collected: 2
[16:03:40.464] Resolving 2 futures (chunks) ... DONE
[16:03:40.464] Reducing values from 2 chunks ...
[16:03:40.464]  - Number of values collected after concatenation: 2
[16:03:40.464]  - Number of values expected: 2
[16:03:40.464] Reducing values from 2 chunks ... DONE
[16:03:40.464] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[16:03:40.465] plan(): Setting new future strategy stack:
[16:03:40.465] List of future strategies:
[16:03:40.465] 1. multisession:
[16:03:40.465]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:03:40.465]    - tweaked: FALSE
[16:03:40.465]    - call: plan(strategy)
[16:03:40.465] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:03:40.465] multisession:
[16:03:40.465] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:03:40.465] - tweaked: FALSE
[16:03:40.465] - call: plan(strategy)
[16:03:40.472] getGlobalsAndPackages() ...
[16:03:40.472] Not searching for globals
[16:03:40.472] - globals: [0] <none>
[16:03:40.472] getGlobalsAndPackages() ... DONE
[16:03:40.473] [local output] makeClusterPSOCK() ...
[16:03:40.513] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:03:40.514] [local output] Base port: 11206
[16:03:40.514] [local output] Getting setup options for 2 cluster nodes ...
[16:03:40.514] [local output]  - Node 1 of 2 ...
[16:03:40.515] [local output] localMachine=TRUE => revtunnel=FALSE

[16:03:40.516] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpi1Xc62/worker.rank=1.parallelly.parent=78891.1342b37eb5d4b.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmpi1Xc62/worker.rank=1.parallelly.parent=78891.1342b37eb5d4b.pid")'’
[16:03:40.703] - Possible to infer worker's PID: TRUE
[16:03:40.703] [local output] Rscript port: 11206

[16:03:40.704] [local output]  - Node 2 of 2 ...
[16:03:40.704] [local output] localMachine=TRUE => revtunnel=FALSE

[16:03:40.705] [local output] Rscript port: 11206

[16:03:40.705] [local output] Getting setup options for 2 cluster nodes ... done
[16:03:40.705] [local output]  - Parallel setup requested for some PSOCK nodes
[16:03:40.706] [local output] Setting up PSOCK nodes in parallel
[16:03:40.706] List of 36
[16:03:40.706]  $ worker          : chr "localhost"
[16:03:40.706]   ..- attr(*, "localhost")= logi TRUE
[16:03:40.706]  $ master          : chr "localhost"
[16:03:40.706]  $ port            : int 11206
[16:03:40.706]  $ connectTimeout  : num 120
[16:03:40.706]  $ timeout         : num 2592000
[16:03:40.706]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:03:40.706]  $ homogeneous     : logi TRUE
[16:03:40.706]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:03:40.706]  $ rscript_envs    : NULL
[16:03:40.706]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:03:40.706]  $ rscript_startup : NULL
[16:03:40.706]  $ rscript_sh      : chr "sh"
[16:03:40.706]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:03:40.706]  $ methods         : logi TRUE
[16:03:40.706]  $ socketOptions   : chr "no-delay"
[16:03:40.706]  $ useXDR          : logi FALSE
[16:03:40.706]  $ outfile         : chr "/dev/null"
[16:03:40.706]  $ renice          : int NA
[16:03:40.706]  $ rshcmd          : NULL
[16:03:40.706]  $ user            : chr(0) 
[16:03:40.706]  $ revtunnel       : logi FALSE
[16:03:40.706]  $ rshlogfile      : NULL
[16:03:40.706]  $ rshopts         : chr(0) 
[16:03:40.706]  $ rank            : int 1
[16:03:40.706]  $ manual          : logi FALSE
[16:03:40.706]  $ dryrun          : logi FALSE
[16:03:40.706]  $ quiet           : logi FALSE
[16:03:40.706]  $ setup_strategy  : chr "parallel"
[16:03:40.706]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:03:40.706]  $ pidfile         : chr "/tmp/Rtmpi1Xc62/worker.rank=1.parallelly.parent=78891.1342b37eb5d4b.pid"
[16:03:40.706]  $ rshcmd_label    : NULL
[16:03:40.706]  $ rsh_call        : NULL
[16:03:40.706]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:03:40.706]  $ localMachine    : logi TRUE
[16:03:40.706]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:03:40.706]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:03:40.706]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:03:40.706]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:03:40.706]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:03:40.706]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:03:40.706]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:03:40.706]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:03:40.706]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:03:40.706]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:03:40.706]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:03:40.706]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:03:40.706]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:03:40.706]  $ arguments       :List of 28
[16:03:40.706]   ..$ worker          : chr "localhost"
[16:03:40.706]   ..$ master          : NULL
[16:03:40.706]   ..$ port            : int 11206
[16:03:40.706]   ..$ connectTimeout  : num 120
[16:03:40.706]   ..$ timeout         : num 2592000
[16:03:40.706]   ..$ rscript         : NULL
[16:03:40.706]   ..$ homogeneous     : NULL
[16:03:40.706]   ..$ rscript_args    : NULL
[16:03:40.706]   ..$ rscript_envs    : NULL
[16:03:40.706]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:03:40.706]   ..$ rscript_startup : NULL
[16:03:40.706]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:03:40.706]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:03:40.706]   ..$ methods         : logi TRUE
[16:03:40.706]   ..$ socketOptions   : chr "no-delay"
[16:03:40.706]   ..$ useXDR          : logi FALSE
[16:03:40.706]   ..$ outfile         : chr "/dev/null"
[16:03:40.706]   ..$ renice          : int NA
[16:03:40.706]   ..$ rshcmd          : NULL
[16:03:40.706]   ..$ user            : NULL
[16:03:40.706]   ..$ revtunnel       : logi NA
[16:03:40.706]   ..$ rshlogfile      : NULL
[16:03:40.706]   ..$ rshopts         : NULL
[16:03:40.706]   ..$ rank            : int 1
[16:03:40.706]   ..$ manual          : logi FALSE
[16:03:40.706]   ..$ dryrun          : logi FALSE
[16:03:40.706]   ..$ quiet           : logi FALSE
[16:03:40.706]   ..$ setup_strategy  : chr "parallel"
[16:03:40.706]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:03:40.723] [local output] System call to launch all workers:
[16:03:40.723] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpi1Xc62/worker.rank=1.parallelly.parent=78891.1342b37eb5d4b.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11206 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:03:40.723] [local output] Starting PSOCK main server
[16:03:40.729] [local output] Workers launched
[16:03:40.729] [local output] Waiting for workers to connect back
[16:03:40.729]  - [local output] 0 workers out of 2 ready
[16:03:40.975]  - [local output] 0 workers out of 2 ready
[16:03:40.975]  - [local output] 1 workers out of 2 ready
[16:03:40.976]  - [local output] 2 workers out of 2 ready
[16:03:40.976] [local output] Launching of workers completed
[16:03:40.976] [local output] Collecting session information from workers
[16:03:40.977] [local output]  - Worker #1 of 2
[16:03:40.977] [local output]  - Worker #2 of 2
[16:03:40.978] [local output] makeClusterPSOCK() ... done
[16:03:40.989] Packages needed by the future expression (n = 0): <none>
[16:03:40.989] Packages needed by future strategies (n = 0): <none>
[16:03:40.990] {
[16:03:40.990]     {
[16:03:40.990]         {
[16:03:40.990]             ...future.startTime <- base::Sys.time()
[16:03:40.990]             {
[16:03:40.990]                 {
[16:03:40.990]                   {
[16:03:40.990]                     {
[16:03:40.990]                       base::local({
[16:03:40.990]                         has_future <- base::requireNamespace("future", 
[16:03:40.990]                           quietly = TRUE)
[16:03:40.990]                         if (has_future) {
[16:03:40.990]                           ns <- base::getNamespace("future")
[16:03:40.990]                           version <- ns[[".package"]][["version"]]
[16:03:40.990]                           if (is.null(version)) 
[16:03:40.990]                             version <- utils::packageVersion("future")
[16:03:40.990]                         }
[16:03:40.990]                         else {
[16:03:40.990]                           version <- NULL
[16:03:40.990]                         }
[16:03:40.990]                         if (!has_future || version < "1.8.0") {
[16:03:40.990]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:40.990]                             "", base::R.version$version.string), 
[16:03:40.990]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:40.990]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:40.990]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:40.990]                               "release", "version")], collapse = " "), 
[16:03:40.990]                             hostname = base::Sys.info()[["nodename"]])
[16:03:40.990]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:40.990]                             info)
[16:03:40.990]                           info <- base::paste(info, collapse = "; ")
[16:03:40.990]                           if (!has_future) {
[16:03:40.990]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:40.990]                               info)
[16:03:40.990]                           }
[16:03:40.990]                           else {
[16:03:40.990]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:40.990]                               info, version)
[16:03:40.990]                           }
[16:03:40.990]                           base::stop(msg)
[16:03:40.990]                         }
[16:03:40.990]                       })
[16:03:40.990]                     }
[16:03:40.990]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:40.990]                     base::options(mc.cores = 1L)
[16:03:40.990]                   }
[16:03:40.990]                   options(future.plan = NULL)
[16:03:40.990]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:40.990]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:40.990]                 }
[16:03:40.990]                 ...future.workdir <- getwd()
[16:03:40.990]             }
[16:03:40.990]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:40.990]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:40.990]         }
[16:03:40.990]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:40.990]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:03:40.990]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:40.990]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:40.990]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:40.990]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:40.990]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:40.990]             base::names(...future.oldOptions))
[16:03:40.990]     }
[16:03:40.990]     if (FALSE) {
[16:03:40.990]     }
[16:03:40.990]     else {
[16:03:40.990]         if (TRUE) {
[16:03:40.990]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:40.990]                 open = "w")
[16:03:40.990]         }
[16:03:40.990]         else {
[16:03:40.990]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:40.990]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:40.990]         }
[16:03:40.990]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:40.990]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:40.990]             base::sink(type = "output", split = FALSE)
[16:03:40.990]             base::close(...future.stdout)
[16:03:40.990]         }, add = TRUE)
[16:03:40.990]     }
[16:03:40.990]     ...future.frame <- base::sys.nframe()
[16:03:40.990]     ...future.conditions <- base::list()
[16:03:40.990]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:40.990]     if (FALSE) {
[16:03:40.990]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:40.990]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:40.990]     }
[16:03:40.990]     ...future.result <- base::tryCatch({
[16:03:40.990]         base::withCallingHandlers({
[16:03:40.990]             ...future.value <- base::withVisible(base::local({
[16:03:40.990]                 ...future.makeSendCondition <- base::local({
[16:03:40.990]                   sendCondition <- NULL
[16:03:40.990]                   function(frame = 1L) {
[16:03:40.990]                     if (is.function(sendCondition)) 
[16:03:40.990]                       return(sendCondition)
[16:03:40.990]                     ns <- getNamespace("parallel")
[16:03:40.990]                     if (exists("sendData", mode = "function", 
[16:03:40.990]                       envir = ns)) {
[16:03:40.990]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:40.990]                         envir = ns)
[16:03:40.990]                       envir <- sys.frame(frame)
[16:03:40.990]                       master <- NULL
[16:03:40.990]                       while (!identical(envir, .GlobalEnv) && 
[16:03:40.990]                         !identical(envir, emptyenv())) {
[16:03:40.990]                         if (exists("master", mode = "list", envir = envir, 
[16:03:40.990]                           inherits = FALSE)) {
[16:03:40.990]                           master <- get("master", mode = "list", 
[16:03:40.990]                             envir = envir, inherits = FALSE)
[16:03:40.990]                           if (inherits(master, c("SOCKnode", 
[16:03:40.990]                             "SOCK0node"))) {
[16:03:40.990]                             sendCondition <<- function(cond) {
[16:03:40.990]                               data <- list(type = "VALUE", value = cond, 
[16:03:40.990]                                 success = TRUE)
[16:03:40.990]                               parallel_sendData(master, data)
[16:03:40.990]                             }
[16:03:40.990]                             return(sendCondition)
[16:03:40.990]                           }
[16:03:40.990]                         }
[16:03:40.990]                         frame <- frame + 1L
[16:03:40.990]                         envir <- sys.frame(frame)
[16:03:40.990]                       }
[16:03:40.990]                     }
[16:03:40.990]                     sendCondition <<- function(cond) NULL
[16:03:40.990]                   }
[16:03:40.990]                 })
[16:03:40.990]                 withCallingHandlers({
[16:03:40.990]                   NA
[16:03:40.990]                 }, immediateCondition = function(cond) {
[16:03:40.990]                   sendCondition <- ...future.makeSendCondition()
[16:03:40.990]                   sendCondition(cond)
[16:03:40.990]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:40.990]                   {
[16:03:40.990]                     inherits <- base::inherits
[16:03:40.990]                     invokeRestart <- base::invokeRestart
[16:03:40.990]                     is.null <- base::is.null
[16:03:40.990]                     muffled <- FALSE
[16:03:40.990]                     if (inherits(cond, "message")) {
[16:03:40.990]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:40.990]                       if (muffled) 
[16:03:40.990]                         invokeRestart("muffleMessage")
[16:03:40.990]                     }
[16:03:40.990]                     else if (inherits(cond, "warning")) {
[16:03:40.990]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:40.990]                       if (muffled) 
[16:03:40.990]                         invokeRestart("muffleWarning")
[16:03:40.990]                     }
[16:03:40.990]                     else if (inherits(cond, "condition")) {
[16:03:40.990]                       if (!is.null(pattern)) {
[16:03:40.990]                         computeRestarts <- base::computeRestarts
[16:03:40.990]                         grepl <- base::grepl
[16:03:40.990]                         restarts <- computeRestarts(cond)
[16:03:40.990]                         for (restart in restarts) {
[16:03:40.990]                           name <- restart$name
[16:03:40.990]                           if (is.null(name)) 
[16:03:40.990]                             next
[16:03:40.990]                           if (!grepl(pattern, name)) 
[16:03:40.990]                             next
[16:03:40.990]                           invokeRestart(restart)
[16:03:40.990]                           muffled <- TRUE
[16:03:40.990]                           break
[16:03:40.990]                         }
[16:03:40.990]                       }
[16:03:40.990]                     }
[16:03:40.990]                     invisible(muffled)
[16:03:40.990]                   }
[16:03:40.990]                   muffleCondition(cond)
[16:03:40.990]                 })
[16:03:40.990]             }))
[16:03:40.990]             future::FutureResult(value = ...future.value$value, 
[16:03:40.990]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:40.990]                   ...future.rng), globalenv = if (FALSE) 
[16:03:40.990]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:40.990]                     ...future.globalenv.names))
[16:03:40.990]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:40.990]         }, condition = base::local({
[16:03:40.990]             c <- base::c
[16:03:40.990]             inherits <- base::inherits
[16:03:40.990]             invokeRestart <- base::invokeRestart
[16:03:40.990]             length <- base::length
[16:03:40.990]             list <- base::list
[16:03:40.990]             seq.int <- base::seq.int
[16:03:40.990]             signalCondition <- base::signalCondition
[16:03:40.990]             sys.calls <- base::sys.calls
[16:03:40.990]             `[[` <- base::`[[`
[16:03:40.990]             `+` <- base::`+`
[16:03:40.990]             `<<-` <- base::`<<-`
[16:03:40.990]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:40.990]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:40.990]                   3L)]
[16:03:40.990]             }
[16:03:40.990]             function(cond) {
[16:03:40.990]                 is_error <- inherits(cond, "error")
[16:03:40.990]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:40.990]                   NULL)
[16:03:40.990]                 if (is_error) {
[16:03:40.990]                   sessionInformation <- function() {
[16:03:40.990]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:40.990]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:40.990]                       search = base::search(), system = base::Sys.info())
[16:03:40.990]                   }
[16:03:40.990]                   ...future.conditions[[length(...future.conditions) + 
[16:03:40.990]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:40.990]                     cond$call), session = sessionInformation(), 
[16:03:40.990]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:40.990]                   signalCondition(cond)
[16:03:40.990]                 }
[16:03:40.990]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:40.990]                 "immediateCondition"))) {
[16:03:40.990]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:40.990]                   ...future.conditions[[length(...future.conditions) + 
[16:03:40.990]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:40.990]                   if (TRUE && !signal) {
[16:03:40.990]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:40.990]                     {
[16:03:40.990]                       inherits <- base::inherits
[16:03:40.990]                       invokeRestart <- base::invokeRestart
[16:03:40.990]                       is.null <- base::is.null
[16:03:40.990]                       muffled <- FALSE
[16:03:40.990]                       if (inherits(cond, "message")) {
[16:03:40.990]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:40.990]                         if (muffled) 
[16:03:40.990]                           invokeRestart("muffleMessage")
[16:03:40.990]                       }
[16:03:40.990]                       else if (inherits(cond, "warning")) {
[16:03:40.990]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:40.990]                         if (muffled) 
[16:03:40.990]                           invokeRestart("muffleWarning")
[16:03:40.990]                       }
[16:03:40.990]                       else if (inherits(cond, "condition")) {
[16:03:40.990]                         if (!is.null(pattern)) {
[16:03:40.990]                           computeRestarts <- base::computeRestarts
[16:03:40.990]                           grepl <- base::grepl
[16:03:40.990]                           restarts <- computeRestarts(cond)
[16:03:40.990]                           for (restart in restarts) {
[16:03:40.990]                             name <- restart$name
[16:03:40.990]                             if (is.null(name)) 
[16:03:40.990]                               next
[16:03:40.990]                             if (!grepl(pattern, name)) 
[16:03:40.990]                               next
[16:03:40.990]                             invokeRestart(restart)
[16:03:40.990]                             muffled <- TRUE
[16:03:40.990]                             break
[16:03:40.990]                           }
[16:03:40.990]                         }
[16:03:40.990]                       }
[16:03:40.990]                       invisible(muffled)
[16:03:40.990]                     }
[16:03:40.990]                     muffleCondition(cond, pattern = "^muffle")
[16:03:40.990]                   }
[16:03:40.990]                 }
[16:03:40.990]                 else {
[16:03:40.990]                   if (TRUE) {
[16:03:40.990]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:40.990]                     {
[16:03:40.990]                       inherits <- base::inherits
[16:03:40.990]                       invokeRestart <- base::invokeRestart
[16:03:40.990]                       is.null <- base::is.null
[16:03:40.990]                       muffled <- FALSE
[16:03:40.990]                       if (inherits(cond, "message")) {
[16:03:40.990]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:40.990]                         if (muffled) 
[16:03:40.990]                           invokeRestart("muffleMessage")
[16:03:40.990]                       }
[16:03:40.990]                       else if (inherits(cond, "warning")) {
[16:03:40.990]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:40.990]                         if (muffled) 
[16:03:40.990]                           invokeRestart("muffleWarning")
[16:03:40.990]                       }
[16:03:40.990]                       else if (inherits(cond, "condition")) {
[16:03:40.990]                         if (!is.null(pattern)) {
[16:03:40.990]                           computeRestarts <- base::computeRestarts
[16:03:40.990]                           grepl <- base::grepl
[16:03:40.990]                           restarts <- computeRestarts(cond)
[16:03:40.990]                           for (restart in restarts) {
[16:03:40.990]                             name <- restart$name
[16:03:40.990]                             if (is.null(name)) 
[16:03:40.990]                               next
[16:03:40.990]                             if (!grepl(pattern, name)) 
[16:03:40.990]                               next
[16:03:40.990]                             invokeRestart(restart)
[16:03:40.990]                             muffled <- TRUE
[16:03:40.990]                             break
[16:03:40.990]                           }
[16:03:40.990]                         }
[16:03:40.990]                       }
[16:03:40.990]                       invisible(muffled)
[16:03:40.990]                     }
[16:03:40.990]                     muffleCondition(cond, pattern = "^muffle")
[16:03:40.990]                   }
[16:03:40.990]                 }
[16:03:40.990]             }
[16:03:40.990]         }))
[16:03:40.990]     }, error = function(ex) {
[16:03:40.990]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:40.990]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:40.990]                 ...future.rng), started = ...future.startTime, 
[16:03:40.990]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:40.990]             version = "1.8"), class = "FutureResult")
[16:03:40.990]     }, finally = {
[16:03:40.990]         if (!identical(...future.workdir, getwd())) 
[16:03:40.990]             setwd(...future.workdir)
[16:03:40.990]         {
[16:03:40.990]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:40.990]                 ...future.oldOptions$nwarnings <- NULL
[16:03:40.990]             }
[16:03:40.990]             base::options(...future.oldOptions)
[16:03:40.990]             if (.Platform$OS.type == "windows") {
[16:03:40.990]                 old_names <- names(...future.oldEnvVars)
[16:03:40.990]                 envs <- base::Sys.getenv()
[16:03:40.990]                 names <- names(envs)
[16:03:40.990]                 common <- intersect(names, old_names)
[16:03:40.990]                 added <- setdiff(names, old_names)
[16:03:40.990]                 removed <- setdiff(old_names, names)
[16:03:40.990]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:40.990]                   envs[common]]
[16:03:40.990]                 NAMES <- toupper(changed)
[16:03:40.990]                 args <- list()
[16:03:40.990]                 for (kk in seq_along(NAMES)) {
[16:03:40.990]                   name <- changed[[kk]]
[16:03:40.990]                   NAME <- NAMES[[kk]]
[16:03:40.990]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:40.990]                     next
[16:03:40.990]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:40.990]                 }
[16:03:40.990]                 NAMES <- toupper(added)
[16:03:40.990]                 for (kk in seq_along(NAMES)) {
[16:03:40.990]                   name <- added[[kk]]
[16:03:40.990]                   NAME <- NAMES[[kk]]
[16:03:40.990]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:40.990]                     next
[16:03:40.990]                   args[[name]] <- ""
[16:03:40.990]                 }
[16:03:40.990]                 NAMES <- toupper(removed)
[16:03:40.990]                 for (kk in seq_along(NAMES)) {
[16:03:40.990]                   name <- removed[[kk]]
[16:03:40.990]                   NAME <- NAMES[[kk]]
[16:03:40.990]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:40.990]                     next
[16:03:40.990]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:40.990]                 }
[16:03:40.990]                 if (length(args) > 0) 
[16:03:40.990]                   base::do.call(base::Sys.setenv, args = args)
[16:03:40.990]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:40.990]             }
[16:03:40.990]             else {
[16:03:40.990]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:40.990]             }
[16:03:40.990]             {
[16:03:40.990]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:40.990]                   0L) {
[16:03:40.990]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:40.990]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:40.990]                   base::options(opts)
[16:03:40.990]                 }
[16:03:40.990]                 {
[16:03:40.990]                   {
[16:03:40.990]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:40.990]                     NULL
[16:03:40.990]                   }
[16:03:40.990]                   options(future.plan = NULL)
[16:03:40.990]                   if (is.na(NA_character_)) 
[16:03:40.990]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:40.990]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:40.990]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:40.990]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:40.990]                     envir = parent.frame()) 
[16:03:40.990]                   {
[16:03:40.990]                     if (is.function(workers)) 
[16:03:40.990]                       workers <- workers()
[16:03:40.990]                     workers <- structure(as.integer(workers), 
[16:03:40.990]                       class = class(workers))
[16:03:40.990]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:40.990]                       workers >= 1)
[16:03:40.990]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:40.990]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:40.990]                     }
[16:03:40.990]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:40.990]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:40.990]                       envir = envir)
[16:03:40.990]                     if (!future$lazy) 
[16:03:40.990]                       future <- run(future)
[16:03:40.990]                     invisible(future)
[16:03:40.990]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:40.990]                 }
[16:03:40.990]             }
[16:03:40.990]         }
[16:03:40.990]     })
[16:03:40.990]     if (TRUE) {
[16:03:40.990]         base::sink(type = "output", split = FALSE)
[16:03:40.990]         if (TRUE) {
[16:03:40.990]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:40.990]         }
[16:03:40.990]         else {
[16:03:40.990]             ...future.result["stdout"] <- base::list(NULL)
[16:03:40.990]         }
[16:03:40.990]         base::close(...future.stdout)
[16:03:40.990]         ...future.stdout <- NULL
[16:03:40.990]     }
[16:03:40.990]     ...future.result$conditions <- ...future.conditions
[16:03:40.990]     ...future.result$finished <- base::Sys.time()
[16:03:40.990]     ...future.result
[16:03:40.990] }
[16:03:41.043] MultisessionFuture started
[16:03:41.043] result() for ClusterFuture ...
[16:03:41.044] receiveMessageFromWorker() for ClusterFuture ...
[16:03:41.044] - Validating connection of MultisessionFuture
[16:03:41.087] - received message: FutureResult
[16:03:41.087] - Received FutureResult
[16:03:41.087] - Erased future from FutureRegistry
[16:03:41.087] result() for ClusterFuture ...
[16:03:41.087] - result already collected: FutureResult
[16:03:41.087] result() for ClusterFuture ... done
[16:03:41.088] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:41.088] result() for ClusterFuture ... done
[16:03:41.088] result() for ClusterFuture ...
[16:03:41.088] - result already collected: FutureResult
[16:03:41.088] result() for ClusterFuture ... done
[16:03:41.088] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:03:41.092] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[16:03:41.092] future_lapply() ...
[16:03:41.097] Number of chunks: 2
[16:03:41.097] getGlobalsAndPackagesXApply() ...
[16:03:41.097]  - future.globals: TRUE
[16:03:41.097] getGlobalsAndPackages() ...
[16:03:41.097] Searching for globals...
[16:03:41.099] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:03:41.099] Searching for globals ... DONE
[16:03:41.099] Resolving globals: FALSE
[16:03:41.100] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:03:41.100] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:03:41.100] - globals: [1] ‘FUN’
[16:03:41.100] 
[16:03:41.101] getGlobalsAndPackages() ... DONE
[16:03:41.101]  - globals found/used: [n=1] ‘FUN’
[16:03:41.101]  - needed namespaces: [n=0] 
[16:03:41.101] Finding globals ... DONE
[16:03:41.101]  - use_args: TRUE
[16:03:41.101]  - Getting '...' globals ...
[16:03:41.102] resolve() on list ...
[16:03:41.102]  recursive: 0
[16:03:41.102]  length: 1
[16:03:41.102]  elements: ‘...’
[16:03:41.102]  length: 0 (resolved future 1)
[16:03:41.102] resolve() on list ... DONE
[16:03:41.102]    - '...' content: [n=0] 
[16:03:41.102] List of 1
[16:03:41.102]  $ ...: list()
[16:03:41.102]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:41.102]  - attr(*, "where")=List of 1
[16:03:41.102]   ..$ ...:<environment: 0x55ed7b8b8e50> 
[16:03:41.102]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:41.102]  - attr(*, "resolved")= logi TRUE
[16:03:41.102]  - attr(*, "total_size")= num NA
[16:03:41.106]  - Getting '...' globals ... DONE
[16:03:41.106] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:03:41.106] List of 2
[16:03:41.106]  $ ...future.FUN:function (x)  
[16:03:41.106]  $ ...          : list()
[16:03:41.106]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:41.106]  - attr(*, "where")=List of 2
[16:03:41.106]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:41.106]   ..$ ...          :<environment: 0x55ed7b8b8e50> 
[16:03:41.106]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:41.106]  - attr(*, "resolved")= logi FALSE
[16:03:41.106]  - attr(*, "total_size")= num 4720
[16:03:41.109] Packages to be attached in all futures: [n=0] 
[16:03:41.109] getGlobalsAndPackagesXApply() ... DONE
[16:03:41.110] Number of futures (= number of chunks): 2
[16:03:41.110] Launching 2 futures (chunks) ...
[16:03:41.110] Chunk #1 of 2 ...
[16:03:41.110]  - Finding globals in 'X' for chunk #1 ...
[16:03:41.110] getGlobalsAndPackages() ...
[16:03:41.110] Searching for globals...
[16:03:41.111] 
[16:03:41.111] Searching for globals ... DONE
[16:03:41.111] - globals: [0] <none>
[16:03:41.111] getGlobalsAndPackages() ... DONE
[16:03:41.111]    + additional globals found: [n=0] 
[16:03:41.111]    + additional namespaces needed: [n=0] 
[16:03:41.111]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:41.111]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:41.112]  - seeds: <none>
[16:03:41.112]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:41.112] getGlobalsAndPackages() ...
[16:03:41.112] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:41.112] Resolving globals: FALSE
[16:03:41.112] Tweak future expression to call with '...' arguments ...
[16:03:41.112] {
[16:03:41.112]     do.call(function(...) {
[16:03:41.112]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:41.112]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:41.112]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:41.112]             on.exit(options(oopts), add = TRUE)
[16:03:41.112]         }
[16:03:41.112]         {
[16:03:41.112]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:41.112]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:41.112]                 ...future.FUN(...future.X_jj, ...)
[16:03:41.112]             })
[16:03:41.112]         }
[16:03:41.112]     }, args = future.call.arguments)
[16:03:41.112] }
[16:03:41.113] Tweak future expression to call with '...' arguments ... DONE
[16:03:41.113] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:41.113] 
[16:03:41.113] getGlobalsAndPackages() ... DONE
[16:03:41.114] run() for ‘Future’ ...
[16:03:41.114] - state: ‘created’
[16:03:41.114] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:41.128] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:41.128] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:41.128]   - Field: ‘node’
[16:03:41.128]   - Field: ‘label’
[16:03:41.129]   - Field: ‘local’
[16:03:41.129]   - Field: ‘owner’
[16:03:41.129]   - Field: ‘envir’
[16:03:41.129]   - Field: ‘workers’
[16:03:41.129]   - Field: ‘packages’
[16:03:41.129]   - Field: ‘gc’
[16:03:41.129]   - Field: ‘conditions’
[16:03:41.129]   - Field: ‘persistent’
[16:03:41.129]   - Field: ‘expr’
[16:03:41.130]   - Field: ‘uuid’
[16:03:41.130]   - Field: ‘seed’
[16:03:41.130]   - Field: ‘version’
[16:03:41.130]   - Field: ‘result’
[16:03:41.130]   - Field: ‘asynchronous’
[16:03:41.130]   - Field: ‘calls’
[16:03:41.130]   - Field: ‘globals’
[16:03:41.130]   - Field: ‘stdout’
[16:03:41.130]   - Field: ‘earlySignal’
[16:03:41.131]   - Field: ‘lazy’
[16:03:41.131]   - Field: ‘state’
[16:03:41.131] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:41.131] - Launch lazy future ...
[16:03:41.131] Packages needed by the future expression (n = 0): <none>
[16:03:41.131] Packages needed by future strategies (n = 0): <none>
[16:03:41.132] {
[16:03:41.132]     {
[16:03:41.132]         {
[16:03:41.132]             ...future.startTime <- base::Sys.time()
[16:03:41.132]             {
[16:03:41.132]                 {
[16:03:41.132]                   {
[16:03:41.132]                     {
[16:03:41.132]                       base::local({
[16:03:41.132]                         has_future <- base::requireNamespace("future", 
[16:03:41.132]                           quietly = TRUE)
[16:03:41.132]                         if (has_future) {
[16:03:41.132]                           ns <- base::getNamespace("future")
[16:03:41.132]                           version <- ns[[".package"]][["version"]]
[16:03:41.132]                           if (is.null(version)) 
[16:03:41.132]                             version <- utils::packageVersion("future")
[16:03:41.132]                         }
[16:03:41.132]                         else {
[16:03:41.132]                           version <- NULL
[16:03:41.132]                         }
[16:03:41.132]                         if (!has_future || version < "1.8.0") {
[16:03:41.132]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:41.132]                             "", base::R.version$version.string), 
[16:03:41.132]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:41.132]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:41.132]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:41.132]                               "release", "version")], collapse = " "), 
[16:03:41.132]                             hostname = base::Sys.info()[["nodename"]])
[16:03:41.132]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:41.132]                             info)
[16:03:41.132]                           info <- base::paste(info, collapse = "; ")
[16:03:41.132]                           if (!has_future) {
[16:03:41.132]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:41.132]                               info)
[16:03:41.132]                           }
[16:03:41.132]                           else {
[16:03:41.132]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:41.132]                               info, version)
[16:03:41.132]                           }
[16:03:41.132]                           base::stop(msg)
[16:03:41.132]                         }
[16:03:41.132]                       })
[16:03:41.132]                     }
[16:03:41.132]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:41.132]                     base::options(mc.cores = 1L)
[16:03:41.132]                   }
[16:03:41.132]                   options(future.plan = NULL)
[16:03:41.132]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:41.132]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:41.132]                 }
[16:03:41.132]                 ...future.workdir <- getwd()
[16:03:41.132]             }
[16:03:41.132]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:41.132]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:41.132]         }
[16:03:41.132]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:41.132]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:41.132]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:41.132]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:41.132]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:41.132]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:41.132]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:41.132]             base::names(...future.oldOptions))
[16:03:41.132]     }
[16:03:41.132]     if (FALSE) {
[16:03:41.132]     }
[16:03:41.132]     else {
[16:03:41.132]         if (FALSE) {
[16:03:41.132]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:41.132]                 open = "w")
[16:03:41.132]         }
[16:03:41.132]         else {
[16:03:41.132]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:41.132]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:41.132]         }
[16:03:41.132]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:41.132]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:41.132]             base::sink(type = "output", split = FALSE)
[16:03:41.132]             base::close(...future.stdout)
[16:03:41.132]         }, add = TRUE)
[16:03:41.132]     }
[16:03:41.132]     ...future.frame <- base::sys.nframe()
[16:03:41.132]     ...future.conditions <- base::list()
[16:03:41.132]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:41.132]     if (FALSE) {
[16:03:41.132]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:41.132]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:41.132]     }
[16:03:41.132]     ...future.result <- base::tryCatch({
[16:03:41.132]         base::withCallingHandlers({
[16:03:41.132]             ...future.value <- base::withVisible(base::local({
[16:03:41.132]                 ...future.makeSendCondition <- base::local({
[16:03:41.132]                   sendCondition <- NULL
[16:03:41.132]                   function(frame = 1L) {
[16:03:41.132]                     if (is.function(sendCondition)) 
[16:03:41.132]                       return(sendCondition)
[16:03:41.132]                     ns <- getNamespace("parallel")
[16:03:41.132]                     if (exists("sendData", mode = "function", 
[16:03:41.132]                       envir = ns)) {
[16:03:41.132]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:41.132]                         envir = ns)
[16:03:41.132]                       envir <- sys.frame(frame)
[16:03:41.132]                       master <- NULL
[16:03:41.132]                       while (!identical(envir, .GlobalEnv) && 
[16:03:41.132]                         !identical(envir, emptyenv())) {
[16:03:41.132]                         if (exists("master", mode = "list", envir = envir, 
[16:03:41.132]                           inherits = FALSE)) {
[16:03:41.132]                           master <- get("master", mode = "list", 
[16:03:41.132]                             envir = envir, inherits = FALSE)
[16:03:41.132]                           if (inherits(master, c("SOCKnode", 
[16:03:41.132]                             "SOCK0node"))) {
[16:03:41.132]                             sendCondition <<- function(cond) {
[16:03:41.132]                               data <- list(type = "VALUE", value = cond, 
[16:03:41.132]                                 success = TRUE)
[16:03:41.132]                               parallel_sendData(master, data)
[16:03:41.132]                             }
[16:03:41.132]                             return(sendCondition)
[16:03:41.132]                           }
[16:03:41.132]                         }
[16:03:41.132]                         frame <- frame + 1L
[16:03:41.132]                         envir <- sys.frame(frame)
[16:03:41.132]                       }
[16:03:41.132]                     }
[16:03:41.132]                     sendCondition <<- function(cond) NULL
[16:03:41.132]                   }
[16:03:41.132]                 })
[16:03:41.132]                 withCallingHandlers({
[16:03:41.132]                   {
[16:03:41.132]                     do.call(function(...) {
[16:03:41.132]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:41.132]                       if (!identical(...future.globals.maxSize.org, 
[16:03:41.132]                         ...future.globals.maxSize)) {
[16:03:41.132]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:41.132]                         on.exit(options(oopts), add = TRUE)
[16:03:41.132]                       }
[16:03:41.132]                       {
[16:03:41.132]                         lapply(seq_along(...future.elements_ii), 
[16:03:41.132]                           FUN = function(jj) {
[16:03:41.132]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:41.132]                             ...future.FUN(...future.X_jj, ...)
[16:03:41.132]                           })
[16:03:41.132]                       }
[16:03:41.132]                     }, args = future.call.arguments)
[16:03:41.132]                   }
[16:03:41.132]                 }, immediateCondition = function(cond) {
[16:03:41.132]                   sendCondition <- ...future.makeSendCondition()
[16:03:41.132]                   sendCondition(cond)
[16:03:41.132]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:41.132]                   {
[16:03:41.132]                     inherits <- base::inherits
[16:03:41.132]                     invokeRestart <- base::invokeRestart
[16:03:41.132]                     is.null <- base::is.null
[16:03:41.132]                     muffled <- FALSE
[16:03:41.132]                     if (inherits(cond, "message")) {
[16:03:41.132]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:41.132]                       if (muffled) 
[16:03:41.132]                         invokeRestart("muffleMessage")
[16:03:41.132]                     }
[16:03:41.132]                     else if (inherits(cond, "warning")) {
[16:03:41.132]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:41.132]                       if (muffled) 
[16:03:41.132]                         invokeRestart("muffleWarning")
[16:03:41.132]                     }
[16:03:41.132]                     else if (inherits(cond, "condition")) {
[16:03:41.132]                       if (!is.null(pattern)) {
[16:03:41.132]                         computeRestarts <- base::computeRestarts
[16:03:41.132]                         grepl <- base::grepl
[16:03:41.132]                         restarts <- computeRestarts(cond)
[16:03:41.132]                         for (restart in restarts) {
[16:03:41.132]                           name <- restart$name
[16:03:41.132]                           if (is.null(name)) 
[16:03:41.132]                             next
[16:03:41.132]                           if (!grepl(pattern, name)) 
[16:03:41.132]                             next
[16:03:41.132]                           invokeRestart(restart)
[16:03:41.132]                           muffled <- TRUE
[16:03:41.132]                           break
[16:03:41.132]                         }
[16:03:41.132]                       }
[16:03:41.132]                     }
[16:03:41.132]                     invisible(muffled)
[16:03:41.132]                   }
[16:03:41.132]                   muffleCondition(cond)
[16:03:41.132]                 })
[16:03:41.132]             }))
[16:03:41.132]             future::FutureResult(value = ...future.value$value, 
[16:03:41.132]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:41.132]                   ...future.rng), globalenv = if (FALSE) 
[16:03:41.132]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:41.132]                     ...future.globalenv.names))
[16:03:41.132]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:41.132]         }, condition = base::local({
[16:03:41.132]             c <- base::c
[16:03:41.132]             inherits <- base::inherits
[16:03:41.132]             invokeRestart <- base::invokeRestart
[16:03:41.132]             length <- base::length
[16:03:41.132]             list <- base::list
[16:03:41.132]             seq.int <- base::seq.int
[16:03:41.132]             signalCondition <- base::signalCondition
[16:03:41.132]             sys.calls <- base::sys.calls
[16:03:41.132]             `[[` <- base::`[[`
[16:03:41.132]             `+` <- base::`+`
[16:03:41.132]             `<<-` <- base::`<<-`
[16:03:41.132]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:41.132]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:41.132]                   3L)]
[16:03:41.132]             }
[16:03:41.132]             function(cond) {
[16:03:41.132]                 is_error <- inherits(cond, "error")
[16:03:41.132]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:41.132]                   NULL)
[16:03:41.132]                 if (is_error) {
[16:03:41.132]                   sessionInformation <- function() {
[16:03:41.132]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:41.132]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:41.132]                       search = base::search(), system = base::Sys.info())
[16:03:41.132]                   }
[16:03:41.132]                   ...future.conditions[[length(...future.conditions) + 
[16:03:41.132]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:41.132]                     cond$call), session = sessionInformation(), 
[16:03:41.132]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:41.132]                   signalCondition(cond)
[16:03:41.132]                 }
[16:03:41.132]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:41.132]                 "immediateCondition"))) {
[16:03:41.132]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:41.132]                   ...future.conditions[[length(...future.conditions) + 
[16:03:41.132]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:41.132]                   if (TRUE && !signal) {
[16:03:41.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:41.132]                     {
[16:03:41.132]                       inherits <- base::inherits
[16:03:41.132]                       invokeRestart <- base::invokeRestart
[16:03:41.132]                       is.null <- base::is.null
[16:03:41.132]                       muffled <- FALSE
[16:03:41.132]                       if (inherits(cond, "message")) {
[16:03:41.132]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:41.132]                         if (muffled) 
[16:03:41.132]                           invokeRestart("muffleMessage")
[16:03:41.132]                       }
[16:03:41.132]                       else if (inherits(cond, "warning")) {
[16:03:41.132]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:41.132]                         if (muffled) 
[16:03:41.132]                           invokeRestart("muffleWarning")
[16:03:41.132]                       }
[16:03:41.132]                       else if (inherits(cond, "condition")) {
[16:03:41.132]                         if (!is.null(pattern)) {
[16:03:41.132]                           computeRestarts <- base::computeRestarts
[16:03:41.132]                           grepl <- base::grepl
[16:03:41.132]                           restarts <- computeRestarts(cond)
[16:03:41.132]                           for (restart in restarts) {
[16:03:41.132]                             name <- restart$name
[16:03:41.132]                             if (is.null(name)) 
[16:03:41.132]                               next
[16:03:41.132]                             if (!grepl(pattern, name)) 
[16:03:41.132]                               next
[16:03:41.132]                             invokeRestart(restart)
[16:03:41.132]                             muffled <- TRUE
[16:03:41.132]                             break
[16:03:41.132]                           }
[16:03:41.132]                         }
[16:03:41.132]                       }
[16:03:41.132]                       invisible(muffled)
[16:03:41.132]                     }
[16:03:41.132]                     muffleCondition(cond, pattern = "^muffle")
[16:03:41.132]                   }
[16:03:41.132]                 }
[16:03:41.132]                 else {
[16:03:41.132]                   if (TRUE) {
[16:03:41.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:41.132]                     {
[16:03:41.132]                       inherits <- base::inherits
[16:03:41.132]                       invokeRestart <- base::invokeRestart
[16:03:41.132]                       is.null <- base::is.null
[16:03:41.132]                       muffled <- FALSE
[16:03:41.132]                       if (inherits(cond, "message")) {
[16:03:41.132]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:41.132]                         if (muffled) 
[16:03:41.132]                           invokeRestart("muffleMessage")
[16:03:41.132]                       }
[16:03:41.132]                       else if (inherits(cond, "warning")) {
[16:03:41.132]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:41.132]                         if (muffled) 
[16:03:41.132]                           invokeRestart("muffleWarning")
[16:03:41.132]                       }
[16:03:41.132]                       else if (inherits(cond, "condition")) {
[16:03:41.132]                         if (!is.null(pattern)) {
[16:03:41.132]                           computeRestarts <- base::computeRestarts
[16:03:41.132]                           grepl <- base::grepl
[16:03:41.132]                           restarts <- computeRestarts(cond)
[16:03:41.132]                           for (restart in restarts) {
[16:03:41.132]                             name <- restart$name
[16:03:41.132]                             if (is.null(name)) 
[16:03:41.132]                               next
[16:03:41.132]                             if (!grepl(pattern, name)) 
[16:03:41.132]                               next
[16:03:41.132]                             invokeRestart(restart)
[16:03:41.132]                             muffled <- TRUE
[16:03:41.132]                             break
[16:03:41.132]                           }
[16:03:41.132]                         }
[16:03:41.132]                       }
[16:03:41.132]                       invisible(muffled)
[16:03:41.132]                     }
[16:03:41.132]                     muffleCondition(cond, pattern = "^muffle")
[16:03:41.132]                   }
[16:03:41.132]                 }
[16:03:41.132]             }
[16:03:41.132]         }))
[16:03:41.132]     }, error = function(ex) {
[16:03:41.132]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:41.132]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:41.132]                 ...future.rng), started = ...future.startTime, 
[16:03:41.132]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:41.132]             version = "1.8"), class = "FutureResult")
[16:03:41.132]     }, finally = {
[16:03:41.132]         if (!identical(...future.workdir, getwd())) 
[16:03:41.132]             setwd(...future.workdir)
[16:03:41.132]         {
[16:03:41.132]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:41.132]                 ...future.oldOptions$nwarnings <- NULL
[16:03:41.132]             }
[16:03:41.132]             base::options(...future.oldOptions)
[16:03:41.132]             if (.Platform$OS.type == "windows") {
[16:03:41.132]                 old_names <- names(...future.oldEnvVars)
[16:03:41.132]                 envs <- base::Sys.getenv()
[16:03:41.132]                 names <- names(envs)
[16:03:41.132]                 common <- intersect(names, old_names)
[16:03:41.132]                 added <- setdiff(names, old_names)
[16:03:41.132]                 removed <- setdiff(old_names, names)
[16:03:41.132]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:41.132]                   envs[common]]
[16:03:41.132]                 NAMES <- toupper(changed)
[16:03:41.132]                 args <- list()
[16:03:41.132]                 for (kk in seq_along(NAMES)) {
[16:03:41.132]                   name <- changed[[kk]]
[16:03:41.132]                   NAME <- NAMES[[kk]]
[16:03:41.132]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:41.132]                     next
[16:03:41.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:41.132]                 }
[16:03:41.132]                 NAMES <- toupper(added)
[16:03:41.132]                 for (kk in seq_along(NAMES)) {
[16:03:41.132]                   name <- added[[kk]]
[16:03:41.132]                   NAME <- NAMES[[kk]]
[16:03:41.132]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:41.132]                     next
[16:03:41.132]                   args[[name]] <- ""
[16:03:41.132]                 }
[16:03:41.132]                 NAMES <- toupper(removed)
[16:03:41.132]                 for (kk in seq_along(NAMES)) {
[16:03:41.132]                   name <- removed[[kk]]
[16:03:41.132]                   NAME <- NAMES[[kk]]
[16:03:41.132]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:41.132]                     next
[16:03:41.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:41.132]                 }
[16:03:41.132]                 if (length(args) > 0) 
[16:03:41.132]                   base::do.call(base::Sys.setenv, args = args)
[16:03:41.132]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:41.132]             }
[16:03:41.132]             else {
[16:03:41.132]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:41.132]             }
[16:03:41.132]             {
[16:03:41.132]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:41.132]                   0L) {
[16:03:41.132]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:41.132]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:41.132]                   base::options(opts)
[16:03:41.132]                 }
[16:03:41.132]                 {
[16:03:41.132]                   {
[16:03:41.132]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:41.132]                     NULL
[16:03:41.132]                   }
[16:03:41.132]                   options(future.plan = NULL)
[16:03:41.132]                   if (is.na(NA_character_)) 
[16:03:41.132]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:41.132]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:41.132]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:41.132]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:41.132]                     envir = parent.frame()) 
[16:03:41.132]                   {
[16:03:41.132]                     if (is.function(workers)) 
[16:03:41.132]                       workers <- workers()
[16:03:41.132]                     workers <- structure(as.integer(workers), 
[16:03:41.132]                       class = class(workers))
[16:03:41.132]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:41.132]                       workers >= 1)
[16:03:41.132]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:41.132]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:41.132]                     }
[16:03:41.132]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:41.132]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:41.132]                       envir = envir)
[16:03:41.132]                     if (!future$lazy) 
[16:03:41.132]                       future <- run(future)
[16:03:41.132]                     invisible(future)
[16:03:41.132]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:41.132]                 }
[16:03:41.132]             }
[16:03:41.132]         }
[16:03:41.132]     })
[16:03:41.132]     if (TRUE) {
[16:03:41.132]         base::sink(type = "output", split = FALSE)
[16:03:41.132]         if (FALSE) {
[16:03:41.132]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:41.132]         }
[16:03:41.132]         else {
[16:03:41.132]             ...future.result["stdout"] <- base::list(NULL)
[16:03:41.132]         }
[16:03:41.132]         base::close(...future.stdout)
[16:03:41.132]         ...future.stdout <- NULL
[16:03:41.132]     }
[16:03:41.132]     ...future.result$conditions <- ...future.conditions
[16:03:41.132]     ...future.result$finished <- base::Sys.time()
[16:03:41.132]     ...future.result
[16:03:41.132] }
[16:03:41.135] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[16:03:41.135] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[16:03:41.136] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[16:03:41.136] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:03:41.136] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:03:41.137] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[16:03:41.137] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[16:03:41.137] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:03:41.138] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:03:41.138] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:03:41.138] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:03:41.138] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[16:03:41.139] MultisessionFuture started
[16:03:41.139] - Launch lazy future ... done
[16:03:41.139] run() for ‘MultisessionFuture’ ... done
[16:03:41.140] Created future:
[16:03:41.140] MultisessionFuture:
[16:03:41.140] Label: ‘future_lapply-1’
[16:03:41.140] Expression:
[16:03:41.140] {
[16:03:41.140]     do.call(function(...) {
[16:03:41.140]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:41.140]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:41.140]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:41.140]             on.exit(options(oopts), add = TRUE)
[16:03:41.140]         }
[16:03:41.140]         {
[16:03:41.140]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:41.140]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:41.140]                 ...future.FUN(...future.X_jj, ...)
[16:03:41.140]             })
[16:03:41.140]         }
[16:03:41.140]     }, args = future.call.arguments)
[16:03:41.140] }
[16:03:41.140] Lazy evaluation: FALSE
[16:03:41.140] Asynchronous evaluation: TRUE
[16:03:41.140] Local evaluation: TRUE
[16:03:41.140] Environment: R_GlobalEnv
[16:03:41.140] Capture standard output: FALSE
[16:03:41.140] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:41.140] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:41.140] Packages: <none>
[16:03:41.140] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:41.140] Resolved: FALSE
[16:03:41.140] Value: <not collected>
[16:03:41.140] Conditions captured: <none>
[16:03:41.140] Early signaling: FALSE
[16:03:41.140] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:41.140] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:41.152] Chunk #1 of 2 ... DONE
[16:03:41.152] Chunk #2 of 2 ...
[16:03:41.152]  - Finding globals in 'X' for chunk #2 ...
[16:03:41.152] getGlobalsAndPackages() ...
[16:03:41.152] Searching for globals...
[16:03:41.152] 
[16:03:41.153] Searching for globals ... DONE
[16:03:41.153] - globals: [0] <none>
[16:03:41.153] getGlobalsAndPackages() ... DONE
[16:03:41.153]    + additional globals found: [n=0] 
[16:03:41.153]    + additional namespaces needed: [n=0] 
[16:03:41.153]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:41.153]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:41.153]  - seeds: <none>
[16:03:41.154]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:41.154] getGlobalsAndPackages() ...
[16:03:41.154] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:41.154] Resolving globals: FALSE
[16:03:41.154] Tweak future expression to call with '...' arguments ...
[16:03:41.154] {
[16:03:41.154]     do.call(function(...) {
[16:03:41.154]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:41.154]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:41.154]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:41.154]             on.exit(options(oopts), add = TRUE)
[16:03:41.154]         }
[16:03:41.154]         {
[16:03:41.154]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:41.154]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:41.154]                 ...future.FUN(...future.X_jj, ...)
[16:03:41.154]             })
[16:03:41.154]         }
[16:03:41.154]     }, args = future.call.arguments)
[16:03:41.154] }
[16:03:41.154] Tweak future expression to call with '...' arguments ... DONE
[16:03:41.155] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:41.155] 
[16:03:41.155] getGlobalsAndPackages() ... DONE
[16:03:41.155] run() for ‘Future’ ...
[16:03:41.156] - state: ‘created’
[16:03:41.156] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:41.170] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:41.170] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:41.170]   - Field: ‘node’
[16:03:41.170]   - Field: ‘label’
[16:03:41.170]   - Field: ‘local’
[16:03:41.170]   - Field: ‘owner’
[16:03:41.171]   - Field: ‘envir’
[16:03:41.171]   - Field: ‘workers’
[16:03:41.171]   - Field: ‘packages’
[16:03:41.171]   - Field: ‘gc’
[16:03:41.171]   - Field: ‘conditions’
[16:03:41.171]   - Field: ‘persistent’
[16:03:41.171]   - Field: ‘expr’
[16:03:41.171]   - Field: ‘uuid’
[16:03:41.172]   - Field: ‘seed’
[16:03:41.172]   - Field: ‘version’
[16:03:41.172]   - Field: ‘result’
[16:03:41.172]   - Field: ‘asynchronous’
[16:03:41.172]   - Field: ‘calls’
[16:03:41.172]   - Field: ‘globals’
[16:03:41.172]   - Field: ‘stdout’
[16:03:41.172]   - Field: ‘earlySignal’
[16:03:41.172]   - Field: ‘lazy’
[16:03:41.173]   - Field: ‘state’
[16:03:41.173] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:41.173] - Launch lazy future ...
[16:03:41.173] Packages needed by the future expression (n = 0): <none>
[16:03:41.173] Packages needed by future strategies (n = 0): <none>
[16:03:41.174] {
[16:03:41.174]     {
[16:03:41.174]         {
[16:03:41.174]             ...future.startTime <- base::Sys.time()
[16:03:41.174]             {
[16:03:41.174]                 {
[16:03:41.174]                   {
[16:03:41.174]                     {
[16:03:41.174]                       base::local({
[16:03:41.174]                         has_future <- base::requireNamespace("future", 
[16:03:41.174]                           quietly = TRUE)
[16:03:41.174]                         if (has_future) {
[16:03:41.174]                           ns <- base::getNamespace("future")
[16:03:41.174]                           version <- ns[[".package"]][["version"]]
[16:03:41.174]                           if (is.null(version)) 
[16:03:41.174]                             version <- utils::packageVersion("future")
[16:03:41.174]                         }
[16:03:41.174]                         else {
[16:03:41.174]                           version <- NULL
[16:03:41.174]                         }
[16:03:41.174]                         if (!has_future || version < "1.8.0") {
[16:03:41.174]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:41.174]                             "", base::R.version$version.string), 
[16:03:41.174]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:41.174]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:41.174]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:41.174]                               "release", "version")], collapse = " "), 
[16:03:41.174]                             hostname = base::Sys.info()[["nodename"]])
[16:03:41.174]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:41.174]                             info)
[16:03:41.174]                           info <- base::paste(info, collapse = "; ")
[16:03:41.174]                           if (!has_future) {
[16:03:41.174]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:41.174]                               info)
[16:03:41.174]                           }
[16:03:41.174]                           else {
[16:03:41.174]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:41.174]                               info, version)
[16:03:41.174]                           }
[16:03:41.174]                           base::stop(msg)
[16:03:41.174]                         }
[16:03:41.174]                       })
[16:03:41.174]                     }
[16:03:41.174]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:41.174]                     base::options(mc.cores = 1L)
[16:03:41.174]                   }
[16:03:41.174]                   options(future.plan = NULL)
[16:03:41.174]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:41.174]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:41.174]                 }
[16:03:41.174]                 ...future.workdir <- getwd()
[16:03:41.174]             }
[16:03:41.174]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:41.174]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:41.174]         }
[16:03:41.174]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:41.174]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:41.174]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:41.174]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:41.174]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:41.174]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:41.174]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:41.174]             base::names(...future.oldOptions))
[16:03:41.174]     }
[16:03:41.174]     if (FALSE) {
[16:03:41.174]     }
[16:03:41.174]     else {
[16:03:41.174]         if (FALSE) {
[16:03:41.174]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:41.174]                 open = "w")
[16:03:41.174]         }
[16:03:41.174]         else {
[16:03:41.174]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:41.174]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:41.174]         }
[16:03:41.174]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:41.174]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:41.174]             base::sink(type = "output", split = FALSE)
[16:03:41.174]             base::close(...future.stdout)
[16:03:41.174]         }, add = TRUE)
[16:03:41.174]     }
[16:03:41.174]     ...future.frame <- base::sys.nframe()
[16:03:41.174]     ...future.conditions <- base::list()
[16:03:41.174]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:41.174]     if (FALSE) {
[16:03:41.174]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:41.174]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:41.174]     }
[16:03:41.174]     ...future.result <- base::tryCatch({
[16:03:41.174]         base::withCallingHandlers({
[16:03:41.174]             ...future.value <- base::withVisible(base::local({
[16:03:41.174]                 ...future.makeSendCondition <- base::local({
[16:03:41.174]                   sendCondition <- NULL
[16:03:41.174]                   function(frame = 1L) {
[16:03:41.174]                     if (is.function(sendCondition)) 
[16:03:41.174]                       return(sendCondition)
[16:03:41.174]                     ns <- getNamespace("parallel")
[16:03:41.174]                     if (exists("sendData", mode = "function", 
[16:03:41.174]                       envir = ns)) {
[16:03:41.174]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:41.174]                         envir = ns)
[16:03:41.174]                       envir <- sys.frame(frame)
[16:03:41.174]                       master <- NULL
[16:03:41.174]                       while (!identical(envir, .GlobalEnv) && 
[16:03:41.174]                         !identical(envir, emptyenv())) {
[16:03:41.174]                         if (exists("master", mode = "list", envir = envir, 
[16:03:41.174]                           inherits = FALSE)) {
[16:03:41.174]                           master <- get("master", mode = "list", 
[16:03:41.174]                             envir = envir, inherits = FALSE)
[16:03:41.174]                           if (inherits(master, c("SOCKnode", 
[16:03:41.174]                             "SOCK0node"))) {
[16:03:41.174]                             sendCondition <<- function(cond) {
[16:03:41.174]                               data <- list(type = "VALUE", value = cond, 
[16:03:41.174]                                 success = TRUE)
[16:03:41.174]                               parallel_sendData(master, data)
[16:03:41.174]                             }
[16:03:41.174]                             return(sendCondition)
[16:03:41.174]                           }
[16:03:41.174]                         }
[16:03:41.174]                         frame <- frame + 1L
[16:03:41.174]                         envir <- sys.frame(frame)
[16:03:41.174]                       }
[16:03:41.174]                     }
[16:03:41.174]                     sendCondition <<- function(cond) NULL
[16:03:41.174]                   }
[16:03:41.174]                 })
[16:03:41.174]                 withCallingHandlers({
[16:03:41.174]                   {
[16:03:41.174]                     do.call(function(...) {
[16:03:41.174]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:41.174]                       if (!identical(...future.globals.maxSize.org, 
[16:03:41.174]                         ...future.globals.maxSize)) {
[16:03:41.174]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:41.174]                         on.exit(options(oopts), add = TRUE)
[16:03:41.174]                       }
[16:03:41.174]                       {
[16:03:41.174]                         lapply(seq_along(...future.elements_ii), 
[16:03:41.174]                           FUN = function(jj) {
[16:03:41.174]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:41.174]                             ...future.FUN(...future.X_jj, ...)
[16:03:41.174]                           })
[16:03:41.174]                       }
[16:03:41.174]                     }, args = future.call.arguments)
[16:03:41.174]                   }
[16:03:41.174]                 }, immediateCondition = function(cond) {
[16:03:41.174]                   sendCondition <- ...future.makeSendCondition()
[16:03:41.174]                   sendCondition(cond)
[16:03:41.174]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:41.174]                   {
[16:03:41.174]                     inherits <- base::inherits
[16:03:41.174]                     invokeRestart <- base::invokeRestart
[16:03:41.174]                     is.null <- base::is.null
[16:03:41.174]                     muffled <- FALSE
[16:03:41.174]                     if (inherits(cond, "message")) {
[16:03:41.174]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:41.174]                       if (muffled) 
[16:03:41.174]                         invokeRestart("muffleMessage")
[16:03:41.174]                     }
[16:03:41.174]                     else if (inherits(cond, "warning")) {
[16:03:41.174]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:41.174]                       if (muffled) 
[16:03:41.174]                         invokeRestart("muffleWarning")
[16:03:41.174]                     }
[16:03:41.174]                     else if (inherits(cond, "condition")) {
[16:03:41.174]                       if (!is.null(pattern)) {
[16:03:41.174]                         computeRestarts <- base::computeRestarts
[16:03:41.174]                         grepl <- base::grepl
[16:03:41.174]                         restarts <- computeRestarts(cond)
[16:03:41.174]                         for (restart in restarts) {
[16:03:41.174]                           name <- restart$name
[16:03:41.174]                           if (is.null(name)) 
[16:03:41.174]                             next
[16:03:41.174]                           if (!grepl(pattern, name)) 
[16:03:41.174]                             next
[16:03:41.174]                           invokeRestart(restart)
[16:03:41.174]                           muffled <- TRUE
[16:03:41.174]                           break
[16:03:41.174]                         }
[16:03:41.174]                       }
[16:03:41.174]                     }
[16:03:41.174]                     invisible(muffled)
[16:03:41.174]                   }
[16:03:41.174]                   muffleCondition(cond)
[16:03:41.174]                 })
[16:03:41.174]             }))
[16:03:41.174]             future::FutureResult(value = ...future.value$value, 
[16:03:41.174]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:41.174]                   ...future.rng), globalenv = if (FALSE) 
[16:03:41.174]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:41.174]                     ...future.globalenv.names))
[16:03:41.174]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:41.174]         }, condition = base::local({
[16:03:41.174]             c <- base::c
[16:03:41.174]             inherits <- base::inherits
[16:03:41.174]             invokeRestart <- base::invokeRestart
[16:03:41.174]             length <- base::length
[16:03:41.174]             list <- base::list
[16:03:41.174]             seq.int <- base::seq.int
[16:03:41.174]             signalCondition <- base::signalCondition
[16:03:41.174]             sys.calls <- base::sys.calls
[16:03:41.174]             `[[` <- base::`[[`
[16:03:41.174]             `+` <- base::`+`
[16:03:41.174]             `<<-` <- base::`<<-`
[16:03:41.174]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:41.174]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:41.174]                   3L)]
[16:03:41.174]             }
[16:03:41.174]             function(cond) {
[16:03:41.174]                 is_error <- inherits(cond, "error")
[16:03:41.174]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:41.174]                   NULL)
[16:03:41.174]                 if (is_error) {
[16:03:41.174]                   sessionInformation <- function() {
[16:03:41.174]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:41.174]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:41.174]                       search = base::search(), system = base::Sys.info())
[16:03:41.174]                   }
[16:03:41.174]                   ...future.conditions[[length(...future.conditions) + 
[16:03:41.174]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:41.174]                     cond$call), session = sessionInformation(), 
[16:03:41.174]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:41.174]                   signalCondition(cond)
[16:03:41.174]                 }
[16:03:41.174]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:41.174]                 "immediateCondition"))) {
[16:03:41.174]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:41.174]                   ...future.conditions[[length(...future.conditions) + 
[16:03:41.174]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:41.174]                   if (TRUE && !signal) {
[16:03:41.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:41.174]                     {
[16:03:41.174]                       inherits <- base::inherits
[16:03:41.174]                       invokeRestart <- base::invokeRestart
[16:03:41.174]                       is.null <- base::is.null
[16:03:41.174]                       muffled <- FALSE
[16:03:41.174]                       if (inherits(cond, "message")) {
[16:03:41.174]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:41.174]                         if (muffled) 
[16:03:41.174]                           invokeRestart("muffleMessage")
[16:03:41.174]                       }
[16:03:41.174]                       else if (inherits(cond, "warning")) {
[16:03:41.174]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:41.174]                         if (muffled) 
[16:03:41.174]                           invokeRestart("muffleWarning")
[16:03:41.174]                       }
[16:03:41.174]                       else if (inherits(cond, "condition")) {
[16:03:41.174]                         if (!is.null(pattern)) {
[16:03:41.174]                           computeRestarts <- base::computeRestarts
[16:03:41.174]                           grepl <- base::grepl
[16:03:41.174]                           restarts <- computeRestarts(cond)
[16:03:41.174]                           for (restart in restarts) {
[16:03:41.174]                             name <- restart$name
[16:03:41.174]                             if (is.null(name)) 
[16:03:41.174]                               next
[16:03:41.174]                             if (!grepl(pattern, name)) 
[16:03:41.174]                               next
[16:03:41.174]                             invokeRestart(restart)
[16:03:41.174]                             muffled <- TRUE
[16:03:41.174]                             break
[16:03:41.174]                           }
[16:03:41.174]                         }
[16:03:41.174]                       }
[16:03:41.174]                       invisible(muffled)
[16:03:41.174]                     }
[16:03:41.174]                     muffleCondition(cond, pattern = "^muffle")
[16:03:41.174]                   }
[16:03:41.174]                 }
[16:03:41.174]                 else {
[16:03:41.174]                   if (TRUE) {
[16:03:41.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:41.174]                     {
[16:03:41.174]                       inherits <- base::inherits
[16:03:41.174]                       invokeRestart <- base::invokeRestart
[16:03:41.174]                       is.null <- base::is.null
[16:03:41.174]                       muffled <- FALSE
[16:03:41.174]                       if (inherits(cond, "message")) {
[16:03:41.174]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:41.174]                         if (muffled) 
[16:03:41.174]                           invokeRestart("muffleMessage")
[16:03:41.174]                       }
[16:03:41.174]                       else if (inherits(cond, "warning")) {
[16:03:41.174]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:41.174]                         if (muffled) 
[16:03:41.174]                           invokeRestart("muffleWarning")
[16:03:41.174]                       }
[16:03:41.174]                       else if (inherits(cond, "condition")) {
[16:03:41.174]                         if (!is.null(pattern)) {
[16:03:41.174]                           computeRestarts <- base::computeRestarts
[16:03:41.174]                           grepl <- base::grepl
[16:03:41.174]                           restarts <- computeRestarts(cond)
[16:03:41.174]                           for (restart in restarts) {
[16:03:41.174]                             name <- restart$name
[16:03:41.174]                             if (is.null(name)) 
[16:03:41.174]                               next
[16:03:41.174]                             if (!grepl(pattern, name)) 
[16:03:41.174]                               next
[16:03:41.174]                             invokeRestart(restart)
[16:03:41.174]                             muffled <- TRUE
[16:03:41.174]                             break
[16:03:41.174]                           }
[16:03:41.174]                         }
[16:03:41.174]                       }
[16:03:41.174]                       invisible(muffled)
[16:03:41.174]                     }
[16:03:41.174]                     muffleCondition(cond, pattern = "^muffle")
[16:03:41.174]                   }
[16:03:41.174]                 }
[16:03:41.174]             }
[16:03:41.174]         }))
[16:03:41.174]     }, error = function(ex) {
[16:03:41.174]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:41.174]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:41.174]                 ...future.rng), started = ...future.startTime, 
[16:03:41.174]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:41.174]             version = "1.8"), class = "FutureResult")
[16:03:41.174]     }, finally = {
[16:03:41.174]         if (!identical(...future.workdir, getwd())) 
[16:03:41.174]             setwd(...future.workdir)
[16:03:41.174]         {
[16:03:41.174]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:41.174]                 ...future.oldOptions$nwarnings <- NULL
[16:03:41.174]             }
[16:03:41.174]             base::options(...future.oldOptions)
[16:03:41.174]             if (.Platform$OS.type == "windows") {
[16:03:41.174]                 old_names <- names(...future.oldEnvVars)
[16:03:41.174]                 envs <- base::Sys.getenv()
[16:03:41.174]                 names <- names(envs)
[16:03:41.174]                 common <- intersect(names, old_names)
[16:03:41.174]                 added <- setdiff(names, old_names)
[16:03:41.174]                 removed <- setdiff(old_names, names)
[16:03:41.174]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:41.174]                   envs[common]]
[16:03:41.174]                 NAMES <- toupper(changed)
[16:03:41.174]                 args <- list()
[16:03:41.174]                 for (kk in seq_along(NAMES)) {
[16:03:41.174]                   name <- changed[[kk]]
[16:03:41.174]                   NAME <- NAMES[[kk]]
[16:03:41.174]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:41.174]                     next
[16:03:41.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:41.174]                 }
[16:03:41.174]                 NAMES <- toupper(added)
[16:03:41.174]                 for (kk in seq_along(NAMES)) {
[16:03:41.174]                   name <- added[[kk]]
[16:03:41.174]                   NAME <- NAMES[[kk]]
[16:03:41.174]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:41.174]                     next
[16:03:41.174]                   args[[name]] <- ""
[16:03:41.174]                 }
[16:03:41.174]                 NAMES <- toupper(removed)
[16:03:41.174]                 for (kk in seq_along(NAMES)) {
[16:03:41.174]                   name <- removed[[kk]]
[16:03:41.174]                   NAME <- NAMES[[kk]]
[16:03:41.174]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:41.174]                     next
[16:03:41.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:41.174]                 }
[16:03:41.174]                 if (length(args) > 0) 
[16:03:41.174]                   base::do.call(base::Sys.setenv, args = args)
[16:03:41.174]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:41.174]             }
[16:03:41.174]             else {
[16:03:41.174]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:41.174]             }
[16:03:41.174]             {
[16:03:41.174]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:41.174]                   0L) {
[16:03:41.174]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:41.174]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:41.174]                   base::options(opts)
[16:03:41.174]                 }
[16:03:41.174]                 {
[16:03:41.174]                   {
[16:03:41.174]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:41.174]                     NULL
[16:03:41.174]                   }
[16:03:41.174]                   options(future.plan = NULL)
[16:03:41.174]                   if (is.na(NA_character_)) 
[16:03:41.174]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:41.174]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:41.174]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:41.174]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:41.174]                     envir = parent.frame()) 
[16:03:41.174]                   {
[16:03:41.174]                     if (is.function(workers)) 
[16:03:41.174]                       workers <- workers()
[16:03:41.174]                     workers <- structure(as.integer(workers), 
[16:03:41.174]                       class = class(workers))
[16:03:41.174]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:41.174]                       workers >= 1)
[16:03:41.174]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:41.174]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:41.174]                     }
[16:03:41.174]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:41.174]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:41.174]                       envir = envir)
[16:03:41.174]                     if (!future$lazy) 
[16:03:41.174]                       future <- run(future)
[16:03:41.174]                     invisible(future)
[16:03:41.174]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:41.174]                 }
[16:03:41.174]             }
[16:03:41.174]         }
[16:03:41.174]     })
[16:03:41.174]     if (TRUE) {
[16:03:41.174]         base::sink(type = "output", split = FALSE)
[16:03:41.174]         if (FALSE) {
[16:03:41.174]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:41.174]         }
[16:03:41.174]         else {
[16:03:41.174]             ...future.result["stdout"] <- base::list(NULL)
[16:03:41.174]         }
[16:03:41.174]         base::close(...future.stdout)
[16:03:41.174]         ...future.stdout <- NULL
[16:03:41.174]     }
[16:03:41.174]     ...future.result$conditions <- ...future.conditions
[16:03:41.174]     ...future.result$finished <- base::Sys.time()
[16:03:41.174]     ...future.result
[16:03:41.174] }
[16:03:41.227] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[16:03:41.227] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[16:03:41.228] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[16:03:41.228] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:03:41.228] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:03:41.229] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[16:03:41.229] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[16:03:41.229] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:03:41.230] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:03:41.230] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:03:41.230] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:03:41.230] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[16:03:41.231] MultisessionFuture started
[16:03:41.231] - Launch lazy future ... done
[16:03:41.231] run() for ‘MultisessionFuture’ ... done
[16:03:41.232] Created future:
[16:03:41.232] MultisessionFuture:
[16:03:41.232] Label: ‘future_lapply-2’
[16:03:41.232] Expression:
[16:03:41.232] {
[16:03:41.232]     do.call(function(...) {
[16:03:41.232]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:41.232]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:41.232]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:41.232]             on.exit(options(oopts), add = TRUE)
[16:03:41.232]         }
[16:03:41.232]         {
[16:03:41.232]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:41.232]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:41.232]                 ...future.FUN(...future.X_jj, ...)
[16:03:41.232]             })
[16:03:41.232]         }
[16:03:41.232]     }, args = future.call.arguments)
[16:03:41.232] }
[16:03:41.232] Lazy evaluation: FALSE
[16:03:41.232] Asynchronous evaluation: TRUE
[16:03:41.232] Local evaluation: TRUE
[16:03:41.232] Environment: R_GlobalEnv
[16:03:41.232] Capture standard output: FALSE
[16:03:41.232] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:41.232] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:41.232] Packages: <none>
[16:03:41.232] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:41.232] Resolved: FALSE
[16:03:41.232] Value: <not collected>
[16:03:41.232] Conditions captured: <none>
[16:03:41.232] Early signaling: FALSE
[16:03:41.232] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:41.232] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:41.244] Chunk #2 of 2 ... DONE
[16:03:41.244] Launching 2 futures (chunks) ... DONE
[16:03:41.244] Resolving 2 futures (chunks) ...
[16:03:41.244] resolve() on list ...
[16:03:41.244]  recursive: 0
[16:03:41.244]  length: 2
[16:03:41.247] 
[16:03:41.320] receiveMessageFromWorker() for ClusterFuture ...
[16:03:41.320] - Validating connection of MultisessionFuture
[16:03:41.320] - received message: FutureResult
[16:03:41.321] - Received FutureResult
[16:03:41.321] - Erased future from FutureRegistry
[16:03:41.321] result() for ClusterFuture ...
[16:03:41.321] - result already collected: FutureResult
[16:03:41.321] result() for ClusterFuture ... done
[16:03:41.321] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:41.321] Future #2
[16:03:41.321] result() for ClusterFuture ...
[16:03:41.321] - result already collected: FutureResult
[16:03:41.321] result() for ClusterFuture ... done
[16:03:41.321] result() for ClusterFuture ...
[16:03:41.322] - result already collected: FutureResult
[16:03:41.322] result() for ClusterFuture ... done
[16:03:41.322] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:03:41.322] - nx: 2
[16:03:41.322] - relay: TRUE
[16:03:41.322] - stdout: TRUE
[16:03:41.322] - signal: TRUE
[16:03:41.322] - resignal: FALSE
[16:03:41.322] - force: TRUE
[16:03:41.322] - relayed: [n=2] FALSE, FALSE
[16:03:41.322] - queued futures: [n=2] FALSE, FALSE
[16:03:41.323]  - until=1
[16:03:41.323]  - relaying element #1
[16:03:41.323] - relayed: [n=2] FALSE, FALSE
[16:03:41.323] - queued futures: [n=2] FALSE, TRUE
[16:03:41.323] signalConditionsASAP(NULL, pos=2) ... done
[16:03:41.323]  length: 1 (resolved future 2)
[16:03:41.689] receiveMessageFromWorker() for ClusterFuture ...
[16:03:41.689] - Validating connection of MultisessionFuture
[16:03:41.689] - received message: FutureResult
[16:03:41.689] - Received FutureResult
[16:03:41.689] - Erased future from FutureRegistry
[16:03:41.689] result() for ClusterFuture ...
[16:03:41.689] - result already collected: FutureResult
[16:03:41.689] result() for ClusterFuture ... done
[16:03:41.690] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:41.690] Future #1
[16:03:41.690] result() for ClusterFuture ...
[16:03:41.690] - result already collected: FutureResult
[16:03:41.690] result() for ClusterFuture ... done
[16:03:41.690] result() for ClusterFuture ...
[16:03:41.690] - result already collected: FutureResult
[16:03:41.690] result() for ClusterFuture ... done
[16:03:41.690] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:03:41.690] - nx: 2
[16:03:41.690] - relay: TRUE
[16:03:41.691] - stdout: TRUE
[16:03:41.691] - signal: TRUE
[16:03:41.691] - resignal: FALSE
[16:03:41.691] - force: TRUE
[16:03:41.691] - relayed: [n=2] FALSE, FALSE
[16:03:41.691] - queued futures: [n=2] FALSE, TRUE
[16:03:41.691]  - until=1
[16:03:41.691]  - relaying element #1
[16:03:41.691] result() for ClusterFuture ...
[16:03:41.691] - result already collected: FutureResult
[16:03:41.691] result() for ClusterFuture ... done
[16:03:41.692] result() for ClusterFuture ...
[16:03:41.692] - result already collected: FutureResult
[16:03:41.692] result() for ClusterFuture ... done
[16:03:41.692] result() for ClusterFuture ...
[16:03:41.692] - result already collected: FutureResult
[16:03:41.692] result() for ClusterFuture ... done
[16:03:41.692] result() for ClusterFuture ...
[16:03:41.692] - result already collected: FutureResult
[16:03:41.692] result() for ClusterFuture ... done
[16:03:41.692] - relayed: [n=2] TRUE, FALSE
[16:03:41.692] - queued futures: [n=2] TRUE, TRUE
[16:03:41.692] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:03:41.693]  length: 0 (resolved future 1)
[16:03:41.693] Relaying remaining futures
[16:03:41.693] signalConditionsASAP(NULL, pos=0) ...
[16:03:41.693] - nx: 2
[16:03:41.693] - relay: TRUE
[16:03:41.693] - stdout: TRUE
[16:03:41.693] - signal: TRUE
[16:03:41.693] - resignal: FALSE
[16:03:41.693] - force: TRUE
[16:03:41.693] - relayed: [n=2] TRUE, FALSE
[16:03:41.693] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:41.694]  - relaying element #2
[16:03:41.694] result() for ClusterFuture ...
[16:03:41.694] - result already collected: FutureResult
[16:03:41.694] result() for ClusterFuture ... done
[16:03:41.694] result() for ClusterFuture ...
[16:03:41.694] - result already collected: FutureResult
[16:03:41.694] result() for ClusterFuture ... done
[16:03:41.694] result() for ClusterFuture ...
[16:03:41.694] - result already collected: FutureResult
[16:03:41.694] result() for ClusterFuture ... done
[16:03:41.694] result() for ClusterFuture ...
[16:03:41.694] - result already collected: FutureResult
[16:03:41.695] result() for ClusterFuture ... done
[16:03:41.695] - relayed: [n=2] TRUE, TRUE
[16:03:41.695] - queued futures: [n=2] TRUE, TRUE
[16:03:41.695] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[16:03:41.695] resolve() on list ... DONE
[16:03:41.695] result() for ClusterFuture ...
[16:03:41.695] - result already collected: FutureResult
[16:03:41.695] result() for ClusterFuture ... done
[16:03:41.695] result() for ClusterFuture ...
[16:03:41.695] - result already collected: FutureResult
[16:03:41.695] result() for ClusterFuture ... done
[16:03:41.696] result() for ClusterFuture ...
[16:03:41.696] - result already collected: FutureResult
[16:03:41.696] result() for ClusterFuture ... done
[16:03:41.696] result() for ClusterFuture ...
[16:03:41.696] - result already collected: FutureResult
[16:03:41.696] result() for ClusterFuture ... done
[16:03:41.696]  - Number of value chunks collected: 2
[16:03:41.696] Resolving 2 futures (chunks) ... DONE
[16:03:41.696] Reducing values from 2 chunks ...
[16:03:41.696]  - Number of values collected after concatenation: 2
[16:03:41.696]  - Number of values expected: 2
[16:03:41.697] Reducing values from 2 chunks ... DONE
[16:03:41.697] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[16:03:41.697] future_lapply() ...
[16:03:41.701] Number of chunks: 2
[16:03:41.701] getGlobalsAndPackagesXApply() ...
[16:03:41.701]  - future.globals: TRUE
[16:03:41.701] getGlobalsAndPackages() ...
[16:03:41.702] Searching for globals...
[16:03:41.703] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:03:41.703] Searching for globals ... DONE
[16:03:41.703] Resolving globals: FALSE
[16:03:41.704] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:03:41.704] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:03:41.704] - globals: [1] ‘FUN’
[16:03:41.704] 
[16:03:41.704] getGlobalsAndPackages() ... DONE
[16:03:41.704]  - globals found/used: [n=1] ‘FUN’
[16:03:41.704]  - needed namespaces: [n=0] 
[16:03:41.705] Finding globals ... DONE
[16:03:41.705]  - use_args: TRUE
[16:03:41.705]  - Getting '...' globals ...
[16:03:41.705] resolve() on list ...
[16:03:41.705]  recursive: 0
[16:03:41.705]  length: 1
[16:03:41.705]  elements: ‘...’
[16:03:41.705]  length: 0 (resolved future 1)
[16:03:41.705] resolve() on list ... DONE
[16:03:41.706]    - '...' content: [n=0] 
[16:03:41.706] List of 1
[16:03:41.706]  $ ...: list()
[16:03:41.706]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:41.706]  - attr(*, "where")=List of 1
[16:03:41.706]   ..$ ...:<environment: 0x55ed79cc23f8> 
[16:03:41.706]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:41.706]  - attr(*, "resolved")= logi TRUE
[16:03:41.706]  - attr(*, "total_size")= num NA
[16:03:41.708]  - Getting '...' globals ... DONE
[16:03:41.708] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:03:41.708] List of 2
[16:03:41.708]  $ ...future.FUN:function (x)  
[16:03:41.708]  $ ...          : list()
[16:03:41.708]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:41.708]  - attr(*, "where")=List of 2
[16:03:41.708]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:41.708]   ..$ ...          :<environment: 0x55ed79cc23f8> 
[16:03:41.708]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:41.708]  - attr(*, "resolved")= logi FALSE
[16:03:41.708]  - attr(*, "total_size")= num 4720
[16:03:41.711] Packages to be attached in all futures: [n=0] 
[16:03:41.711] getGlobalsAndPackagesXApply() ... DONE
[16:03:41.711] Number of futures (= number of chunks): 2
[16:03:41.711] Launching 2 futures (chunks) ...
[16:03:41.711] Chunk #1 of 2 ...
[16:03:41.712]  - Finding globals in 'X' for chunk #1 ...
[16:03:41.712] getGlobalsAndPackages() ...
[16:03:41.712] Searching for globals...
[16:03:41.712] 
[16:03:41.712] Searching for globals ... DONE
[16:03:41.712] - globals: [0] <none>
[16:03:41.712] getGlobalsAndPackages() ... DONE
[16:03:41.712]    + additional globals found: [n=0] 
[16:03:41.712]    + additional namespaces needed: [n=0] 
[16:03:41.713]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:41.713]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:41.713]  - seeds: <none>
[16:03:41.713]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:41.713] getGlobalsAndPackages() ...
[16:03:41.713] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:41.713] Resolving globals: FALSE
[16:03:41.713] Tweak future expression to call with '...' arguments ...
[16:03:41.713] {
[16:03:41.713]     do.call(function(...) {
[16:03:41.713]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:41.713]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:41.713]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:41.713]             on.exit(options(oopts), add = TRUE)
[16:03:41.713]         }
[16:03:41.713]         {
[16:03:41.713]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:41.713]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:41.713]                 ...future.FUN(...future.X_jj, ...)
[16:03:41.713]             })
[16:03:41.713]         }
[16:03:41.713]     }, args = future.call.arguments)
[16:03:41.713] }
[16:03:41.714] Tweak future expression to call with '...' arguments ... DONE
[16:03:41.714] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:41.714] 
[16:03:41.714] getGlobalsAndPackages() ... DONE
[16:03:41.714] run() for ‘Future’ ...
[16:03:41.714] - state: ‘created’
[16:03:41.715] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:41.728] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:41.728] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:41.728]   - Field: ‘node’
[16:03:41.728]   - Field: ‘label’
[16:03:41.728]   - Field: ‘local’
[16:03:41.729]   - Field: ‘owner’
[16:03:41.729]   - Field: ‘envir’
[16:03:41.729]   - Field: ‘workers’
[16:03:41.729]   - Field: ‘packages’
[16:03:41.729]   - Field: ‘gc’
[16:03:41.729]   - Field: ‘conditions’
[16:03:41.729]   - Field: ‘persistent’
[16:03:41.729]   - Field: ‘expr’
[16:03:41.729]   - Field: ‘uuid’
[16:03:41.729]   - Field: ‘seed’
[16:03:41.729]   - Field: ‘version’
[16:03:41.730]   - Field: ‘result’
[16:03:41.730]   - Field: ‘asynchronous’
[16:03:41.730]   - Field: ‘calls’
[16:03:41.730]   - Field: ‘globals’
[16:03:41.730]   - Field: ‘stdout’
[16:03:41.730]   - Field: ‘earlySignal’
[16:03:41.730]   - Field: ‘lazy’
[16:03:41.730]   - Field: ‘state’
[16:03:41.730] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:41.730] - Launch lazy future ...
[16:03:41.731] Packages needed by the future expression (n = 0): <none>
[16:03:41.731] Packages needed by future strategies (n = 0): <none>
[16:03:41.731] {
[16:03:41.731]     {
[16:03:41.731]         {
[16:03:41.731]             ...future.startTime <- base::Sys.time()
[16:03:41.731]             {
[16:03:41.731]                 {
[16:03:41.731]                   {
[16:03:41.731]                     {
[16:03:41.731]                       base::local({
[16:03:41.731]                         has_future <- base::requireNamespace("future", 
[16:03:41.731]                           quietly = TRUE)
[16:03:41.731]                         if (has_future) {
[16:03:41.731]                           ns <- base::getNamespace("future")
[16:03:41.731]                           version <- ns[[".package"]][["version"]]
[16:03:41.731]                           if (is.null(version)) 
[16:03:41.731]                             version <- utils::packageVersion("future")
[16:03:41.731]                         }
[16:03:41.731]                         else {
[16:03:41.731]                           version <- NULL
[16:03:41.731]                         }
[16:03:41.731]                         if (!has_future || version < "1.8.0") {
[16:03:41.731]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:41.731]                             "", base::R.version$version.string), 
[16:03:41.731]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:41.731]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:41.731]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:41.731]                               "release", "version")], collapse = " "), 
[16:03:41.731]                             hostname = base::Sys.info()[["nodename"]])
[16:03:41.731]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:41.731]                             info)
[16:03:41.731]                           info <- base::paste(info, collapse = "; ")
[16:03:41.731]                           if (!has_future) {
[16:03:41.731]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:41.731]                               info)
[16:03:41.731]                           }
[16:03:41.731]                           else {
[16:03:41.731]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:41.731]                               info, version)
[16:03:41.731]                           }
[16:03:41.731]                           base::stop(msg)
[16:03:41.731]                         }
[16:03:41.731]                       })
[16:03:41.731]                     }
[16:03:41.731]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:41.731]                     base::options(mc.cores = 1L)
[16:03:41.731]                   }
[16:03:41.731]                   options(future.plan = NULL)
[16:03:41.731]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:41.731]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:41.731]                 }
[16:03:41.731]                 ...future.workdir <- getwd()
[16:03:41.731]             }
[16:03:41.731]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:41.731]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:41.731]         }
[16:03:41.731]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:41.731]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:41.731]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:41.731]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:41.731]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:41.731]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:41.731]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:41.731]             base::names(...future.oldOptions))
[16:03:41.731]     }
[16:03:41.731]     if (FALSE) {
[16:03:41.731]     }
[16:03:41.731]     else {
[16:03:41.731]         if (TRUE) {
[16:03:41.731]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:41.731]                 open = "w")
[16:03:41.731]         }
[16:03:41.731]         else {
[16:03:41.731]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:41.731]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:41.731]         }
[16:03:41.731]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:41.731]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:41.731]             base::sink(type = "output", split = FALSE)
[16:03:41.731]             base::close(...future.stdout)
[16:03:41.731]         }, add = TRUE)
[16:03:41.731]     }
[16:03:41.731]     ...future.frame <- base::sys.nframe()
[16:03:41.731]     ...future.conditions <- base::list()
[16:03:41.731]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:41.731]     if (FALSE) {
[16:03:41.731]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:41.731]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:41.731]     }
[16:03:41.731]     ...future.result <- base::tryCatch({
[16:03:41.731]         base::withCallingHandlers({
[16:03:41.731]             ...future.value <- base::withVisible(base::local({
[16:03:41.731]                 ...future.makeSendCondition <- base::local({
[16:03:41.731]                   sendCondition <- NULL
[16:03:41.731]                   function(frame = 1L) {
[16:03:41.731]                     if (is.function(sendCondition)) 
[16:03:41.731]                       return(sendCondition)
[16:03:41.731]                     ns <- getNamespace("parallel")
[16:03:41.731]                     if (exists("sendData", mode = "function", 
[16:03:41.731]                       envir = ns)) {
[16:03:41.731]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:41.731]                         envir = ns)
[16:03:41.731]                       envir <- sys.frame(frame)
[16:03:41.731]                       master <- NULL
[16:03:41.731]                       while (!identical(envir, .GlobalEnv) && 
[16:03:41.731]                         !identical(envir, emptyenv())) {
[16:03:41.731]                         if (exists("master", mode = "list", envir = envir, 
[16:03:41.731]                           inherits = FALSE)) {
[16:03:41.731]                           master <- get("master", mode = "list", 
[16:03:41.731]                             envir = envir, inherits = FALSE)
[16:03:41.731]                           if (inherits(master, c("SOCKnode", 
[16:03:41.731]                             "SOCK0node"))) {
[16:03:41.731]                             sendCondition <<- function(cond) {
[16:03:41.731]                               data <- list(type = "VALUE", value = cond, 
[16:03:41.731]                                 success = TRUE)
[16:03:41.731]                               parallel_sendData(master, data)
[16:03:41.731]                             }
[16:03:41.731]                             return(sendCondition)
[16:03:41.731]                           }
[16:03:41.731]                         }
[16:03:41.731]                         frame <- frame + 1L
[16:03:41.731]                         envir <- sys.frame(frame)
[16:03:41.731]                       }
[16:03:41.731]                     }
[16:03:41.731]                     sendCondition <<- function(cond) NULL
[16:03:41.731]                   }
[16:03:41.731]                 })
[16:03:41.731]                 withCallingHandlers({
[16:03:41.731]                   {
[16:03:41.731]                     do.call(function(...) {
[16:03:41.731]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:41.731]                       if (!identical(...future.globals.maxSize.org, 
[16:03:41.731]                         ...future.globals.maxSize)) {
[16:03:41.731]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:41.731]                         on.exit(options(oopts), add = TRUE)
[16:03:41.731]                       }
[16:03:41.731]                       {
[16:03:41.731]                         lapply(seq_along(...future.elements_ii), 
[16:03:41.731]                           FUN = function(jj) {
[16:03:41.731]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:41.731]                             ...future.FUN(...future.X_jj, ...)
[16:03:41.731]                           })
[16:03:41.731]                       }
[16:03:41.731]                     }, args = future.call.arguments)
[16:03:41.731]                   }
[16:03:41.731]                 }, immediateCondition = function(cond) {
[16:03:41.731]                   sendCondition <- ...future.makeSendCondition()
[16:03:41.731]                   sendCondition(cond)
[16:03:41.731]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:41.731]                   {
[16:03:41.731]                     inherits <- base::inherits
[16:03:41.731]                     invokeRestart <- base::invokeRestart
[16:03:41.731]                     is.null <- base::is.null
[16:03:41.731]                     muffled <- FALSE
[16:03:41.731]                     if (inherits(cond, "message")) {
[16:03:41.731]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:41.731]                       if (muffled) 
[16:03:41.731]                         invokeRestart("muffleMessage")
[16:03:41.731]                     }
[16:03:41.731]                     else if (inherits(cond, "warning")) {
[16:03:41.731]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:41.731]                       if (muffled) 
[16:03:41.731]                         invokeRestart("muffleWarning")
[16:03:41.731]                     }
[16:03:41.731]                     else if (inherits(cond, "condition")) {
[16:03:41.731]                       if (!is.null(pattern)) {
[16:03:41.731]                         computeRestarts <- base::computeRestarts
[16:03:41.731]                         grepl <- base::grepl
[16:03:41.731]                         restarts <- computeRestarts(cond)
[16:03:41.731]                         for (restart in restarts) {
[16:03:41.731]                           name <- restart$name
[16:03:41.731]                           if (is.null(name)) 
[16:03:41.731]                             next
[16:03:41.731]                           if (!grepl(pattern, name)) 
[16:03:41.731]                             next
[16:03:41.731]                           invokeRestart(restart)
[16:03:41.731]                           muffled <- TRUE
[16:03:41.731]                           break
[16:03:41.731]                         }
[16:03:41.731]                       }
[16:03:41.731]                     }
[16:03:41.731]                     invisible(muffled)
[16:03:41.731]                   }
[16:03:41.731]                   muffleCondition(cond)
[16:03:41.731]                 })
[16:03:41.731]             }))
[16:03:41.731]             future::FutureResult(value = ...future.value$value, 
[16:03:41.731]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:41.731]                   ...future.rng), globalenv = if (FALSE) 
[16:03:41.731]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:41.731]                     ...future.globalenv.names))
[16:03:41.731]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:41.731]         }, condition = base::local({
[16:03:41.731]             c <- base::c
[16:03:41.731]             inherits <- base::inherits
[16:03:41.731]             invokeRestart <- base::invokeRestart
[16:03:41.731]             length <- base::length
[16:03:41.731]             list <- base::list
[16:03:41.731]             seq.int <- base::seq.int
[16:03:41.731]             signalCondition <- base::signalCondition
[16:03:41.731]             sys.calls <- base::sys.calls
[16:03:41.731]             `[[` <- base::`[[`
[16:03:41.731]             `+` <- base::`+`
[16:03:41.731]             `<<-` <- base::`<<-`
[16:03:41.731]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:41.731]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:41.731]                   3L)]
[16:03:41.731]             }
[16:03:41.731]             function(cond) {
[16:03:41.731]                 is_error <- inherits(cond, "error")
[16:03:41.731]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:41.731]                   NULL)
[16:03:41.731]                 if (is_error) {
[16:03:41.731]                   sessionInformation <- function() {
[16:03:41.731]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:41.731]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:41.731]                       search = base::search(), system = base::Sys.info())
[16:03:41.731]                   }
[16:03:41.731]                   ...future.conditions[[length(...future.conditions) + 
[16:03:41.731]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:41.731]                     cond$call), session = sessionInformation(), 
[16:03:41.731]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:41.731]                   signalCondition(cond)
[16:03:41.731]                 }
[16:03:41.731]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:41.731]                 "immediateCondition"))) {
[16:03:41.731]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:41.731]                   ...future.conditions[[length(...future.conditions) + 
[16:03:41.731]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:41.731]                   if (TRUE && !signal) {
[16:03:41.731]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:41.731]                     {
[16:03:41.731]                       inherits <- base::inherits
[16:03:41.731]                       invokeRestart <- base::invokeRestart
[16:03:41.731]                       is.null <- base::is.null
[16:03:41.731]                       muffled <- FALSE
[16:03:41.731]                       if (inherits(cond, "message")) {
[16:03:41.731]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:41.731]                         if (muffled) 
[16:03:41.731]                           invokeRestart("muffleMessage")
[16:03:41.731]                       }
[16:03:41.731]                       else if (inherits(cond, "warning")) {
[16:03:41.731]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:41.731]                         if (muffled) 
[16:03:41.731]                           invokeRestart("muffleWarning")
[16:03:41.731]                       }
[16:03:41.731]                       else if (inherits(cond, "condition")) {
[16:03:41.731]                         if (!is.null(pattern)) {
[16:03:41.731]                           computeRestarts <- base::computeRestarts
[16:03:41.731]                           grepl <- base::grepl
[16:03:41.731]                           restarts <- computeRestarts(cond)
[16:03:41.731]                           for (restart in restarts) {
[16:03:41.731]                             name <- restart$name
[16:03:41.731]                             if (is.null(name)) 
[16:03:41.731]                               next
[16:03:41.731]                             if (!grepl(pattern, name)) 
[16:03:41.731]                               next
[16:03:41.731]                             invokeRestart(restart)
[16:03:41.731]                             muffled <- TRUE
[16:03:41.731]                             break
[16:03:41.731]                           }
[16:03:41.731]                         }
[16:03:41.731]                       }
[16:03:41.731]                       invisible(muffled)
[16:03:41.731]                     }
[16:03:41.731]                     muffleCondition(cond, pattern = "^muffle")
[16:03:41.731]                   }
[16:03:41.731]                 }
[16:03:41.731]                 else {
[16:03:41.731]                   if (TRUE) {
[16:03:41.731]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:41.731]                     {
[16:03:41.731]                       inherits <- base::inherits
[16:03:41.731]                       invokeRestart <- base::invokeRestart
[16:03:41.731]                       is.null <- base::is.null
[16:03:41.731]                       muffled <- FALSE
[16:03:41.731]                       if (inherits(cond, "message")) {
[16:03:41.731]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:41.731]                         if (muffled) 
[16:03:41.731]                           invokeRestart("muffleMessage")
[16:03:41.731]                       }
[16:03:41.731]                       else if (inherits(cond, "warning")) {
[16:03:41.731]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:41.731]                         if (muffled) 
[16:03:41.731]                           invokeRestart("muffleWarning")
[16:03:41.731]                       }
[16:03:41.731]                       else if (inherits(cond, "condition")) {
[16:03:41.731]                         if (!is.null(pattern)) {
[16:03:41.731]                           computeRestarts <- base::computeRestarts
[16:03:41.731]                           grepl <- base::grepl
[16:03:41.731]                           restarts <- computeRestarts(cond)
[16:03:41.731]                           for (restart in restarts) {
[16:03:41.731]                             name <- restart$name
[16:03:41.731]                             if (is.null(name)) 
[16:03:41.731]                               next
[16:03:41.731]                             if (!grepl(pattern, name)) 
[16:03:41.731]                               next
[16:03:41.731]                             invokeRestart(restart)
[16:03:41.731]                             muffled <- TRUE
[16:03:41.731]                             break
[16:03:41.731]                           }
[16:03:41.731]                         }
[16:03:41.731]                       }
[16:03:41.731]                       invisible(muffled)
[16:03:41.731]                     }
[16:03:41.731]                     muffleCondition(cond, pattern = "^muffle")
[16:03:41.731]                   }
[16:03:41.731]                 }
[16:03:41.731]             }
[16:03:41.731]         }))
[16:03:41.731]     }, error = function(ex) {
[16:03:41.731]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:41.731]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:41.731]                 ...future.rng), started = ...future.startTime, 
[16:03:41.731]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:41.731]             version = "1.8"), class = "FutureResult")
[16:03:41.731]     }, finally = {
[16:03:41.731]         if (!identical(...future.workdir, getwd())) 
[16:03:41.731]             setwd(...future.workdir)
[16:03:41.731]         {
[16:03:41.731]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:41.731]                 ...future.oldOptions$nwarnings <- NULL
[16:03:41.731]             }
[16:03:41.731]             base::options(...future.oldOptions)
[16:03:41.731]             if (.Platform$OS.type == "windows") {
[16:03:41.731]                 old_names <- names(...future.oldEnvVars)
[16:03:41.731]                 envs <- base::Sys.getenv()
[16:03:41.731]                 names <- names(envs)
[16:03:41.731]                 common <- intersect(names, old_names)
[16:03:41.731]                 added <- setdiff(names, old_names)
[16:03:41.731]                 removed <- setdiff(old_names, names)
[16:03:41.731]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:41.731]                   envs[common]]
[16:03:41.731]                 NAMES <- toupper(changed)
[16:03:41.731]                 args <- list()
[16:03:41.731]                 for (kk in seq_along(NAMES)) {
[16:03:41.731]                   name <- changed[[kk]]
[16:03:41.731]                   NAME <- NAMES[[kk]]
[16:03:41.731]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:41.731]                     next
[16:03:41.731]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:41.731]                 }
[16:03:41.731]                 NAMES <- toupper(added)
[16:03:41.731]                 for (kk in seq_along(NAMES)) {
[16:03:41.731]                   name <- added[[kk]]
[16:03:41.731]                   NAME <- NAMES[[kk]]
[16:03:41.731]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:41.731]                     next
[16:03:41.731]                   args[[name]] <- ""
[16:03:41.731]                 }
[16:03:41.731]                 NAMES <- toupper(removed)
[16:03:41.731]                 for (kk in seq_along(NAMES)) {
[16:03:41.731]                   name <- removed[[kk]]
[16:03:41.731]                   NAME <- NAMES[[kk]]
[16:03:41.731]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:41.731]                     next
[16:03:41.731]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:41.731]                 }
[16:03:41.731]                 if (length(args) > 0) 
[16:03:41.731]                   base::do.call(base::Sys.setenv, args = args)
[16:03:41.731]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:41.731]             }
[16:03:41.731]             else {
[16:03:41.731]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:41.731]             }
[16:03:41.731]             {
[16:03:41.731]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:41.731]                   0L) {
[16:03:41.731]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:41.731]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:41.731]                   base::options(opts)
[16:03:41.731]                 }
[16:03:41.731]                 {
[16:03:41.731]                   {
[16:03:41.731]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:41.731]                     NULL
[16:03:41.731]                   }
[16:03:41.731]                   options(future.plan = NULL)
[16:03:41.731]                   if (is.na(NA_character_)) 
[16:03:41.731]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:41.731]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:41.731]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:41.731]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:41.731]                     envir = parent.frame()) 
[16:03:41.731]                   {
[16:03:41.731]                     if (is.function(workers)) 
[16:03:41.731]                       workers <- workers()
[16:03:41.731]                     workers <- structure(as.integer(workers), 
[16:03:41.731]                       class = class(workers))
[16:03:41.731]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:41.731]                       workers >= 1)
[16:03:41.731]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:41.731]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:41.731]                     }
[16:03:41.731]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:41.731]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:41.731]                       envir = envir)
[16:03:41.731]                     if (!future$lazy) 
[16:03:41.731]                       future <- run(future)
[16:03:41.731]                     invisible(future)
[16:03:41.731]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:41.731]                 }
[16:03:41.731]             }
[16:03:41.731]         }
[16:03:41.731]     })
[16:03:41.731]     if (TRUE) {
[16:03:41.731]         base::sink(type = "output", split = FALSE)
[16:03:41.731]         if (TRUE) {
[16:03:41.731]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:41.731]         }
[16:03:41.731]         else {
[16:03:41.731]             ...future.result["stdout"] <- base::list(NULL)
[16:03:41.731]         }
[16:03:41.731]         base::close(...future.stdout)
[16:03:41.731]         ...future.stdout <- NULL
[16:03:41.731]     }
[16:03:41.731]     ...future.result$conditions <- ...future.conditions
[16:03:41.731]     ...future.result$finished <- base::Sys.time()
[16:03:41.731]     ...future.result
[16:03:41.731] }
[16:03:41.734] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[16:03:41.734] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[16:03:41.734] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[16:03:41.735] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:03:41.735] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:03:41.735] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[16:03:41.735] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[16:03:41.735] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:03:41.736] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:03:41.736] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:03:41.736] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:03:41.736] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[16:03:41.737] MultisessionFuture started
[16:03:41.737] - Launch lazy future ... done
[16:03:41.737] run() for ‘MultisessionFuture’ ... done
[16:03:41.737] Created future:
[16:03:41.737] MultisessionFuture:
[16:03:41.737] Label: ‘future_lapply-1’
[16:03:41.737] Expression:
[16:03:41.737] {
[16:03:41.737]     do.call(function(...) {
[16:03:41.737]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:41.737]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:41.737]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:41.737]             on.exit(options(oopts), add = TRUE)
[16:03:41.737]         }
[16:03:41.737]         {
[16:03:41.737]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:41.737]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:41.737]                 ...future.FUN(...future.X_jj, ...)
[16:03:41.737]             })
[16:03:41.737]         }
[16:03:41.737]     }, args = future.call.arguments)
[16:03:41.737] }
[16:03:41.737] Lazy evaluation: FALSE
[16:03:41.737] Asynchronous evaluation: TRUE
[16:03:41.737] Local evaluation: TRUE
[16:03:41.737] Environment: R_GlobalEnv
[16:03:41.737] Capture standard output: TRUE
[16:03:41.737] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:41.737] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:41.737] Packages: <none>
[16:03:41.737] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:41.737] Resolved: FALSE
[16:03:41.737] Value: <not collected>
[16:03:41.737] Conditions captured: <none>
[16:03:41.737] Early signaling: FALSE
[16:03:41.737] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:41.737] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:41.749] Chunk #1 of 2 ... DONE
[16:03:41.749] Chunk #2 of 2 ...
[16:03:41.749]  - Finding globals in 'X' for chunk #2 ...
[16:03:41.749] getGlobalsAndPackages() ...
[16:03:41.749] Searching for globals...
[16:03:41.749] 
[16:03:41.749] Searching for globals ... DONE
[16:03:41.749] - globals: [0] <none>
[16:03:41.749] getGlobalsAndPackages() ... DONE
[16:03:41.750]    + additional globals found: [n=0] 
[16:03:41.750]    + additional namespaces needed: [n=0] 
[16:03:41.750]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:41.750]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:41.750]  - seeds: <none>
[16:03:41.750]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:41.750] getGlobalsAndPackages() ...
[16:03:41.750] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:41.750] Resolving globals: FALSE
[16:03:41.750] Tweak future expression to call with '...' arguments ...
[16:03:41.751] {
[16:03:41.751]     do.call(function(...) {
[16:03:41.751]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:41.751]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:41.751]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:41.751]             on.exit(options(oopts), add = TRUE)
[16:03:41.751]         }
[16:03:41.751]         {
[16:03:41.751]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:41.751]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:41.751]                 ...future.FUN(...future.X_jj, ...)
[16:03:41.751]             })
[16:03:41.751]         }
[16:03:41.751]     }, args = future.call.arguments)
[16:03:41.751] }
[16:03:41.751] Tweak future expression to call with '...' arguments ... DONE
[16:03:41.751] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:41.751] 
[16:03:41.751] getGlobalsAndPackages() ... DONE
[16:03:41.752] run() for ‘Future’ ...
[16:03:41.752] - state: ‘created’
[16:03:41.752] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:41.765] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:41.765] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:41.766]   - Field: ‘node’
[16:03:41.766]   - Field: ‘label’
[16:03:41.766]   - Field: ‘local’
[16:03:41.766]   - Field: ‘owner’
[16:03:41.766]   - Field: ‘envir’
[16:03:41.766]   - Field: ‘workers’
[16:03:41.766]   - Field: ‘packages’
[16:03:41.766]   - Field: ‘gc’
[16:03:41.766]   - Field: ‘conditions’
[16:03:41.766]   - Field: ‘persistent’
[16:03:41.767]   - Field: ‘expr’
[16:03:41.767]   - Field: ‘uuid’
[16:03:41.767]   - Field: ‘seed’
[16:03:41.767]   - Field: ‘version’
[16:03:41.767]   - Field: ‘result’
[16:03:41.767]   - Field: ‘asynchronous’
[16:03:41.767]   - Field: ‘calls’
[16:03:41.767]   - Field: ‘globals’
[16:03:41.767]   - Field: ‘stdout’
[16:03:41.767]   - Field: ‘earlySignal’
[16:03:41.768]   - Field: ‘lazy’
[16:03:41.768]   - Field: ‘state’
[16:03:41.768] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:41.768] - Launch lazy future ...
[16:03:41.768] Packages needed by the future expression (n = 0): <none>
[16:03:41.768] Packages needed by future strategies (n = 0): <none>
[16:03:41.769] {
[16:03:41.769]     {
[16:03:41.769]         {
[16:03:41.769]             ...future.startTime <- base::Sys.time()
[16:03:41.769]             {
[16:03:41.769]                 {
[16:03:41.769]                   {
[16:03:41.769]                     {
[16:03:41.769]                       base::local({
[16:03:41.769]                         has_future <- base::requireNamespace("future", 
[16:03:41.769]                           quietly = TRUE)
[16:03:41.769]                         if (has_future) {
[16:03:41.769]                           ns <- base::getNamespace("future")
[16:03:41.769]                           version <- ns[[".package"]][["version"]]
[16:03:41.769]                           if (is.null(version)) 
[16:03:41.769]                             version <- utils::packageVersion("future")
[16:03:41.769]                         }
[16:03:41.769]                         else {
[16:03:41.769]                           version <- NULL
[16:03:41.769]                         }
[16:03:41.769]                         if (!has_future || version < "1.8.0") {
[16:03:41.769]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:41.769]                             "", base::R.version$version.string), 
[16:03:41.769]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:41.769]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:41.769]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:41.769]                               "release", "version")], collapse = " "), 
[16:03:41.769]                             hostname = base::Sys.info()[["nodename"]])
[16:03:41.769]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:41.769]                             info)
[16:03:41.769]                           info <- base::paste(info, collapse = "; ")
[16:03:41.769]                           if (!has_future) {
[16:03:41.769]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:41.769]                               info)
[16:03:41.769]                           }
[16:03:41.769]                           else {
[16:03:41.769]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:41.769]                               info, version)
[16:03:41.769]                           }
[16:03:41.769]                           base::stop(msg)
[16:03:41.769]                         }
[16:03:41.769]                       })
[16:03:41.769]                     }
[16:03:41.769]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:41.769]                     base::options(mc.cores = 1L)
[16:03:41.769]                   }
[16:03:41.769]                   options(future.plan = NULL)
[16:03:41.769]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:41.769]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:41.769]                 }
[16:03:41.769]                 ...future.workdir <- getwd()
[16:03:41.769]             }
[16:03:41.769]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:41.769]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:41.769]         }
[16:03:41.769]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:41.769]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:41.769]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:41.769]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:41.769]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:41.769]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:41.769]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:41.769]             base::names(...future.oldOptions))
[16:03:41.769]     }
[16:03:41.769]     if (FALSE) {
[16:03:41.769]     }
[16:03:41.769]     else {
[16:03:41.769]         if (TRUE) {
[16:03:41.769]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:41.769]                 open = "w")
[16:03:41.769]         }
[16:03:41.769]         else {
[16:03:41.769]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:41.769]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:41.769]         }
[16:03:41.769]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:41.769]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:41.769]             base::sink(type = "output", split = FALSE)
[16:03:41.769]             base::close(...future.stdout)
[16:03:41.769]         }, add = TRUE)
[16:03:41.769]     }
[16:03:41.769]     ...future.frame <- base::sys.nframe()
[16:03:41.769]     ...future.conditions <- base::list()
[16:03:41.769]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:41.769]     if (FALSE) {
[16:03:41.769]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:41.769]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:41.769]     }
[16:03:41.769]     ...future.result <- base::tryCatch({
[16:03:41.769]         base::withCallingHandlers({
[16:03:41.769]             ...future.value <- base::withVisible(base::local({
[16:03:41.769]                 ...future.makeSendCondition <- base::local({
[16:03:41.769]                   sendCondition <- NULL
[16:03:41.769]                   function(frame = 1L) {
[16:03:41.769]                     if (is.function(sendCondition)) 
[16:03:41.769]                       return(sendCondition)
[16:03:41.769]                     ns <- getNamespace("parallel")
[16:03:41.769]                     if (exists("sendData", mode = "function", 
[16:03:41.769]                       envir = ns)) {
[16:03:41.769]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:41.769]                         envir = ns)
[16:03:41.769]                       envir <- sys.frame(frame)
[16:03:41.769]                       master <- NULL
[16:03:41.769]                       while (!identical(envir, .GlobalEnv) && 
[16:03:41.769]                         !identical(envir, emptyenv())) {
[16:03:41.769]                         if (exists("master", mode = "list", envir = envir, 
[16:03:41.769]                           inherits = FALSE)) {
[16:03:41.769]                           master <- get("master", mode = "list", 
[16:03:41.769]                             envir = envir, inherits = FALSE)
[16:03:41.769]                           if (inherits(master, c("SOCKnode", 
[16:03:41.769]                             "SOCK0node"))) {
[16:03:41.769]                             sendCondition <<- function(cond) {
[16:03:41.769]                               data <- list(type = "VALUE", value = cond, 
[16:03:41.769]                                 success = TRUE)
[16:03:41.769]                               parallel_sendData(master, data)
[16:03:41.769]                             }
[16:03:41.769]                             return(sendCondition)
[16:03:41.769]                           }
[16:03:41.769]                         }
[16:03:41.769]                         frame <- frame + 1L
[16:03:41.769]                         envir <- sys.frame(frame)
[16:03:41.769]                       }
[16:03:41.769]                     }
[16:03:41.769]                     sendCondition <<- function(cond) NULL
[16:03:41.769]                   }
[16:03:41.769]                 })
[16:03:41.769]                 withCallingHandlers({
[16:03:41.769]                   {
[16:03:41.769]                     do.call(function(...) {
[16:03:41.769]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:41.769]                       if (!identical(...future.globals.maxSize.org, 
[16:03:41.769]                         ...future.globals.maxSize)) {
[16:03:41.769]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:41.769]                         on.exit(options(oopts), add = TRUE)
[16:03:41.769]                       }
[16:03:41.769]                       {
[16:03:41.769]                         lapply(seq_along(...future.elements_ii), 
[16:03:41.769]                           FUN = function(jj) {
[16:03:41.769]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:41.769]                             ...future.FUN(...future.X_jj, ...)
[16:03:41.769]                           })
[16:03:41.769]                       }
[16:03:41.769]                     }, args = future.call.arguments)
[16:03:41.769]                   }
[16:03:41.769]                 }, immediateCondition = function(cond) {
[16:03:41.769]                   sendCondition <- ...future.makeSendCondition()
[16:03:41.769]                   sendCondition(cond)
[16:03:41.769]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:41.769]                   {
[16:03:41.769]                     inherits <- base::inherits
[16:03:41.769]                     invokeRestart <- base::invokeRestart
[16:03:41.769]                     is.null <- base::is.null
[16:03:41.769]                     muffled <- FALSE
[16:03:41.769]                     if (inherits(cond, "message")) {
[16:03:41.769]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:41.769]                       if (muffled) 
[16:03:41.769]                         invokeRestart("muffleMessage")
[16:03:41.769]                     }
[16:03:41.769]                     else if (inherits(cond, "warning")) {
[16:03:41.769]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:41.769]                       if (muffled) 
[16:03:41.769]                         invokeRestart("muffleWarning")
[16:03:41.769]                     }
[16:03:41.769]                     else if (inherits(cond, "condition")) {
[16:03:41.769]                       if (!is.null(pattern)) {
[16:03:41.769]                         computeRestarts <- base::computeRestarts
[16:03:41.769]                         grepl <- base::grepl
[16:03:41.769]                         restarts <- computeRestarts(cond)
[16:03:41.769]                         for (restart in restarts) {
[16:03:41.769]                           name <- restart$name
[16:03:41.769]                           if (is.null(name)) 
[16:03:41.769]                             next
[16:03:41.769]                           if (!grepl(pattern, name)) 
[16:03:41.769]                             next
[16:03:41.769]                           invokeRestart(restart)
[16:03:41.769]                           muffled <- TRUE
[16:03:41.769]                           break
[16:03:41.769]                         }
[16:03:41.769]                       }
[16:03:41.769]                     }
[16:03:41.769]                     invisible(muffled)
[16:03:41.769]                   }
[16:03:41.769]                   muffleCondition(cond)
[16:03:41.769]                 })
[16:03:41.769]             }))
[16:03:41.769]             future::FutureResult(value = ...future.value$value, 
[16:03:41.769]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:41.769]                   ...future.rng), globalenv = if (FALSE) 
[16:03:41.769]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:41.769]                     ...future.globalenv.names))
[16:03:41.769]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:41.769]         }, condition = base::local({
[16:03:41.769]             c <- base::c
[16:03:41.769]             inherits <- base::inherits
[16:03:41.769]             invokeRestart <- base::invokeRestart
[16:03:41.769]             length <- base::length
[16:03:41.769]             list <- base::list
[16:03:41.769]             seq.int <- base::seq.int
[16:03:41.769]             signalCondition <- base::signalCondition
[16:03:41.769]             sys.calls <- base::sys.calls
[16:03:41.769]             `[[` <- base::`[[`
[16:03:41.769]             `+` <- base::`+`
[16:03:41.769]             `<<-` <- base::`<<-`
[16:03:41.769]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:41.769]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:41.769]                   3L)]
[16:03:41.769]             }
[16:03:41.769]             function(cond) {
[16:03:41.769]                 is_error <- inherits(cond, "error")
[16:03:41.769]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:41.769]                   NULL)
[16:03:41.769]                 if (is_error) {
[16:03:41.769]                   sessionInformation <- function() {
[16:03:41.769]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:41.769]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:41.769]                       search = base::search(), system = base::Sys.info())
[16:03:41.769]                   }
[16:03:41.769]                   ...future.conditions[[length(...future.conditions) + 
[16:03:41.769]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:41.769]                     cond$call), session = sessionInformation(), 
[16:03:41.769]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:41.769]                   signalCondition(cond)
[16:03:41.769]                 }
[16:03:41.769]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:41.769]                 "immediateCondition"))) {
[16:03:41.769]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:41.769]                   ...future.conditions[[length(...future.conditions) + 
[16:03:41.769]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:41.769]                   if (TRUE && !signal) {
[16:03:41.769]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:41.769]                     {
[16:03:41.769]                       inherits <- base::inherits
[16:03:41.769]                       invokeRestart <- base::invokeRestart
[16:03:41.769]                       is.null <- base::is.null
[16:03:41.769]                       muffled <- FALSE
[16:03:41.769]                       if (inherits(cond, "message")) {
[16:03:41.769]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:41.769]                         if (muffled) 
[16:03:41.769]                           invokeRestart("muffleMessage")
[16:03:41.769]                       }
[16:03:41.769]                       else if (inherits(cond, "warning")) {
[16:03:41.769]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:41.769]                         if (muffled) 
[16:03:41.769]                           invokeRestart("muffleWarning")
[16:03:41.769]                       }
[16:03:41.769]                       else if (inherits(cond, "condition")) {
[16:03:41.769]                         if (!is.null(pattern)) {
[16:03:41.769]                           computeRestarts <- base::computeRestarts
[16:03:41.769]                           grepl <- base::grepl
[16:03:41.769]                           restarts <- computeRestarts(cond)
[16:03:41.769]                           for (restart in restarts) {
[16:03:41.769]                             name <- restart$name
[16:03:41.769]                             if (is.null(name)) 
[16:03:41.769]                               next
[16:03:41.769]                             if (!grepl(pattern, name)) 
[16:03:41.769]                               next
[16:03:41.769]                             invokeRestart(restart)
[16:03:41.769]                             muffled <- TRUE
[16:03:41.769]                             break
[16:03:41.769]                           }
[16:03:41.769]                         }
[16:03:41.769]                       }
[16:03:41.769]                       invisible(muffled)
[16:03:41.769]                     }
[16:03:41.769]                     muffleCondition(cond, pattern = "^muffle")
[16:03:41.769]                   }
[16:03:41.769]                 }
[16:03:41.769]                 else {
[16:03:41.769]                   if (TRUE) {
[16:03:41.769]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:41.769]                     {
[16:03:41.769]                       inherits <- base::inherits
[16:03:41.769]                       invokeRestart <- base::invokeRestart
[16:03:41.769]                       is.null <- base::is.null
[16:03:41.769]                       muffled <- FALSE
[16:03:41.769]                       if (inherits(cond, "message")) {
[16:03:41.769]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:41.769]                         if (muffled) 
[16:03:41.769]                           invokeRestart("muffleMessage")
[16:03:41.769]                       }
[16:03:41.769]                       else if (inherits(cond, "warning")) {
[16:03:41.769]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:41.769]                         if (muffled) 
[16:03:41.769]                           invokeRestart("muffleWarning")
[16:03:41.769]                       }
[16:03:41.769]                       else if (inherits(cond, "condition")) {
[16:03:41.769]                         if (!is.null(pattern)) {
[16:03:41.769]                           computeRestarts <- base::computeRestarts
[16:03:41.769]                           grepl <- base::grepl
[16:03:41.769]                           restarts <- computeRestarts(cond)
[16:03:41.769]                           for (restart in restarts) {
[16:03:41.769]                             name <- restart$name
[16:03:41.769]                             if (is.null(name)) 
[16:03:41.769]                               next
[16:03:41.769]                             if (!grepl(pattern, name)) 
[16:03:41.769]                               next
[16:03:41.769]                             invokeRestart(restart)
[16:03:41.769]                             muffled <- TRUE
[16:03:41.769]                             break
[16:03:41.769]                           }
[16:03:41.769]                         }
[16:03:41.769]                       }
[16:03:41.769]                       invisible(muffled)
[16:03:41.769]                     }
[16:03:41.769]                     muffleCondition(cond, pattern = "^muffle")
[16:03:41.769]                   }
[16:03:41.769]                 }
[16:03:41.769]             }
[16:03:41.769]         }))
[16:03:41.769]     }, error = function(ex) {
[16:03:41.769]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:41.769]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:41.769]                 ...future.rng), started = ...future.startTime, 
[16:03:41.769]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:41.769]             version = "1.8"), class = "FutureResult")
[16:03:41.769]     }, finally = {
[16:03:41.769]         if (!identical(...future.workdir, getwd())) 
[16:03:41.769]             setwd(...future.workdir)
[16:03:41.769]         {
[16:03:41.769]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:41.769]                 ...future.oldOptions$nwarnings <- NULL
[16:03:41.769]             }
[16:03:41.769]             base::options(...future.oldOptions)
[16:03:41.769]             if (.Platform$OS.type == "windows") {
[16:03:41.769]                 old_names <- names(...future.oldEnvVars)
[16:03:41.769]                 envs <- base::Sys.getenv()
[16:03:41.769]                 names <- names(envs)
[16:03:41.769]                 common <- intersect(names, old_names)
[16:03:41.769]                 added <- setdiff(names, old_names)
[16:03:41.769]                 removed <- setdiff(old_names, names)
[16:03:41.769]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:41.769]                   envs[common]]
[16:03:41.769]                 NAMES <- toupper(changed)
[16:03:41.769]                 args <- list()
[16:03:41.769]                 for (kk in seq_along(NAMES)) {
[16:03:41.769]                   name <- changed[[kk]]
[16:03:41.769]                   NAME <- NAMES[[kk]]
[16:03:41.769]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:41.769]                     next
[16:03:41.769]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:41.769]                 }
[16:03:41.769]                 NAMES <- toupper(added)
[16:03:41.769]                 for (kk in seq_along(NAMES)) {
[16:03:41.769]                   name <- added[[kk]]
[16:03:41.769]                   NAME <- NAMES[[kk]]
[16:03:41.769]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:41.769]                     next
[16:03:41.769]                   args[[name]] <- ""
[16:03:41.769]                 }
[16:03:41.769]                 NAMES <- toupper(removed)
[16:03:41.769]                 for (kk in seq_along(NAMES)) {
[16:03:41.769]                   name <- removed[[kk]]
[16:03:41.769]                   NAME <- NAMES[[kk]]
[16:03:41.769]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:41.769]                     next
[16:03:41.769]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:41.769]                 }
[16:03:41.769]                 if (length(args) > 0) 
[16:03:41.769]                   base::do.call(base::Sys.setenv, args = args)
[16:03:41.769]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:41.769]             }
[16:03:41.769]             else {
[16:03:41.769]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:41.769]             }
[16:03:41.769]             {
[16:03:41.769]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:41.769]                   0L) {
[16:03:41.769]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:41.769]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:41.769]                   base::options(opts)
[16:03:41.769]                 }
[16:03:41.769]                 {
[16:03:41.769]                   {
[16:03:41.769]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:41.769]                     NULL
[16:03:41.769]                   }
[16:03:41.769]                   options(future.plan = NULL)
[16:03:41.769]                   if (is.na(NA_character_)) 
[16:03:41.769]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:41.769]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:41.769]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:41.769]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:41.769]                     envir = parent.frame()) 
[16:03:41.769]                   {
[16:03:41.769]                     if (is.function(workers)) 
[16:03:41.769]                       workers <- workers()
[16:03:41.769]                     workers <- structure(as.integer(workers), 
[16:03:41.769]                       class = class(workers))
[16:03:41.769]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:41.769]                       workers >= 1)
[16:03:41.769]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:41.769]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:41.769]                     }
[16:03:41.769]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:41.769]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:41.769]                       envir = envir)
[16:03:41.769]                     if (!future$lazy) 
[16:03:41.769]                       future <- run(future)
[16:03:41.769]                     invisible(future)
[16:03:41.769]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:41.769]                 }
[16:03:41.769]             }
[16:03:41.769]         }
[16:03:41.769]     })
[16:03:41.769]     if (TRUE) {
[16:03:41.769]         base::sink(type = "output", split = FALSE)
[16:03:41.769]         if (TRUE) {
[16:03:41.769]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:41.769]         }
[16:03:41.769]         else {
[16:03:41.769]             ...future.result["stdout"] <- base::list(NULL)
[16:03:41.769]         }
[16:03:41.769]         base::close(...future.stdout)
[16:03:41.769]         ...future.stdout <- NULL
[16:03:41.769]     }
[16:03:41.769]     ...future.result$conditions <- ...future.conditions
[16:03:41.769]     ...future.result$finished <- base::Sys.time()
[16:03:41.769]     ...future.result
[16:03:41.769] }
[16:03:41.771] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[16:03:41.771] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[16:03:41.772] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[16:03:41.772] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:03:41.772] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:03:41.773] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[16:03:41.773] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[16:03:41.773] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:03:41.773] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:03:41.774] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:03:41.774] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:03:41.774] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[16:03:41.775] MultisessionFuture started
[16:03:41.775] - Launch lazy future ... done
[16:03:41.775] run() for ‘MultisessionFuture’ ... done
[16:03:41.775] Created future:
[16:03:41.775] MultisessionFuture:
[16:03:41.775] Label: ‘future_lapply-2’
[16:03:41.775] Expression:
[16:03:41.775] {
[16:03:41.775]     do.call(function(...) {
[16:03:41.775]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:41.775]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:41.775]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:41.775]             on.exit(options(oopts), add = TRUE)
[16:03:41.775]         }
[16:03:41.775]         {
[16:03:41.775]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:41.775]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:41.775]                 ...future.FUN(...future.X_jj, ...)
[16:03:41.775]             })
[16:03:41.775]         }
[16:03:41.775]     }, args = future.call.arguments)
[16:03:41.775] }
[16:03:41.775] Lazy evaluation: FALSE
[16:03:41.775] Asynchronous evaluation: TRUE
[16:03:41.775] Local evaluation: TRUE
[16:03:41.775] Environment: R_GlobalEnv
[16:03:41.775] Capture standard output: TRUE
[16:03:41.775] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:41.775] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:41.775] Packages: <none>
[16:03:41.775] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:41.775] Resolved: FALSE
[16:03:41.775] Value: <not collected>
[16:03:41.775] Conditions captured: <none>
[16:03:41.775] Early signaling: FALSE
[16:03:41.775] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:41.775] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:41.787] Chunk #2 of 2 ... DONE
[16:03:41.787] Launching 2 futures (chunks) ... DONE
[16:03:41.787] Resolving 2 futures (chunks) ...
[16:03:41.787] resolve() on list ...
[16:03:41.787]  recursive: 0
[16:03:41.787]  length: 2
[16:03:41.787] 
[16:03:41.830] receiveMessageFromWorker() for ClusterFuture ...
[16:03:41.830] - Validating connection of MultisessionFuture
[16:03:41.830] - received message: FutureResult
[16:03:41.830] - Received FutureResult
[16:03:41.830] - Erased future from FutureRegistry
[16:03:41.830] result() for ClusterFuture ...
[16:03:41.830] - result already collected: FutureResult
[16:03:41.830] result() for ClusterFuture ... done
[16:03:41.830] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:41.831] Future #2
[16:03:41.831] result() for ClusterFuture ...
[16:03:41.831] - result already collected: FutureResult
[16:03:41.831] result() for ClusterFuture ... done
[16:03:41.831] result() for ClusterFuture ...
[16:03:41.831] - result already collected: FutureResult
[16:03:41.831] result() for ClusterFuture ... done
[16:03:41.831] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:03:41.831] - nx: 2
[16:03:41.831] - relay: TRUE
[16:03:41.832] - stdout: TRUE
[16:03:41.832] - signal: TRUE
[16:03:41.832] - resignal: FALSE
[16:03:41.832] - force: TRUE
[16:03:41.832] - relayed: [n=2] FALSE, FALSE
[16:03:41.832] - queued futures: [n=2] FALSE, FALSE
[16:03:41.832]  - until=1
[16:03:41.832]  - relaying element #1
[16:03:41.832] - relayed: [n=2] FALSE, FALSE
[16:03:41.832] - queued futures: [n=2] FALSE, TRUE
[16:03:41.832] signalConditionsASAP(NULL, pos=2) ... done
[16:03:41.833]  length: 1 (resolved future 2)
[16:03:42.285] receiveMessageFromWorker() for ClusterFuture ...
[16:03:42.285] - Validating connection of MultisessionFuture
[16:03:42.285] - received message: FutureResult
[16:03:42.285] - Received FutureResult
[16:03:42.285] - Erased future from FutureRegistry
[16:03:42.285] result() for ClusterFuture ...
[16:03:42.285] - result already collected: FutureResult
[16:03:42.285] result() for ClusterFuture ... done
[16:03:42.286] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:42.286] Future #1
[16:03:42.286] result() for ClusterFuture ...
[16:03:42.286] - result already collected: FutureResult
[16:03:42.286] result() for ClusterFuture ... done
[16:03:42.286] result() for ClusterFuture ...
[16:03:42.286] - result already collected: FutureResult
[16:03:42.286] result() for ClusterFuture ... done
[16:03:42.286] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:03:42.286] - nx: 2
[16:03:42.286] - relay: TRUE
[16:03:42.286] - stdout: TRUE
[16:03:42.287] - signal: TRUE
[16:03:42.287] - resignal: FALSE
[16:03:42.287] - force: TRUE
[16:03:42.287] - relayed: [n=2] FALSE, FALSE
[16:03:42.287] - queued futures: [n=2] FALSE, TRUE
[16:03:42.287]  - until=1
[16:03:42.287]  - relaying element #1
[16:03:42.287] result() for ClusterFuture ...
[16:03:42.287] - result already collected: FutureResult
[16:03:42.287] result() for ClusterFuture ... done
[16:03:42.287] result() for ClusterFuture ...
[16:03:42.288] - result already collected: FutureResult
[16:03:42.288] result() for ClusterFuture ... done
[16:03:42.288] result() for ClusterFuture ...
[16:03:42.288] - result already collected: FutureResult
[16:03:42.288] result() for ClusterFuture ... done
[16:03:42.288] result() for ClusterFuture ...
[16:03:42.288] - result already collected: FutureResult
[16:03:42.288] result() for ClusterFuture ... done
[16:03:42.288] - relayed: [n=2] TRUE, FALSE
[16:03:42.288] - queued futures: [n=2] TRUE, TRUE
[16:03:42.288] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:03:42.289]  length: 0 (resolved future 1)
[16:03:42.289] Relaying remaining futures
[16:03:42.289] signalConditionsASAP(NULL, pos=0) ...
[16:03:42.289] - nx: 2
[16:03:42.289] - relay: TRUE
[16:03:42.289] - stdout: TRUE
[16:03:42.291] - signal: TRUE
[16:03:42.291] - resignal: FALSE
[16:03:42.291] - force: TRUE
[16:03:42.291] - relayed: [n=2] TRUE, FALSE
[16:03:42.291] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:42.291]  - relaying element #2
[16:03:42.291] result() for ClusterFuture ...
[16:03:42.291] - result already collected: FutureResult
[16:03:42.292] result() for ClusterFuture ... done
[16:03:42.292] result() for ClusterFuture ...
[16:03:42.292] - result already collected: FutureResult
[16:03:42.292] result() for ClusterFuture ... done
[16:03:42.292] result() for ClusterFuture ...
[16:03:42.292] - result already collected: FutureResult
[16:03:42.292] result() for ClusterFuture ... done
[16:03:42.292] result() for ClusterFuture ...
[16:03:42.292] - result already collected: FutureResult
[16:03:42.292] result() for ClusterFuture ... done
[16:03:42.292] - relayed: [n=2] TRUE, TRUE
[16:03:42.293] - queued futures: [n=2] TRUE, TRUE
[16:03:42.293] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[16:03:42.293] resolve() on list ... DONE
[16:03:42.293] result() for ClusterFuture ...
[16:03:42.293] - result already collected: FutureResult
[16:03:42.293] result() for ClusterFuture ... done
[16:03:42.293] result() for ClusterFuture ...
[16:03:42.293] - result already collected: FutureResult
[16:03:42.293] result() for ClusterFuture ... done
[16:03:42.293] result() for ClusterFuture ...
[16:03:42.293] - result already collected: FutureResult
[16:03:42.293] result() for ClusterFuture ... done
[16:03:42.294] result() for ClusterFuture ...
[16:03:42.294] - result already collected: FutureResult
[16:03:42.294] result() for ClusterFuture ... done
[16:03:42.294]  - Number of value chunks collected: 2
[16:03:42.294] Resolving 2 futures (chunks) ... DONE
[16:03:42.294] Reducing values from 2 chunks ...
[16:03:42.294]  - Number of values collected after concatenation: 2
[16:03:42.294]  - Number of values expected: 2
[16:03:42.294] Reducing values from 2 chunks ... DONE
[16:03:42.294] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[16:03:42.295] future_lapply() ...
[16:03:42.299] Number of chunks: 2
[16:03:42.299] getGlobalsAndPackagesXApply() ...
[16:03:42.299]  - future.globals: TRUE
[16:03:42.299] getGlobalsAndPackages() ...
[16:03:42.299] Searching for globals...
[16:03:42.300] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:03:42.301] Searching for globals ... DONE
[16:03:42.301] Resolving globals: FALSE
[16:03:42.301] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:03:42.301] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:03:42.301] - globals: [1] ‘FUN’
[16:03:42.302] 
[16:03:42.302] getGlobalsAndPackages() ... DONE
[16:03:42.302]  - globals found/used: [n=1] ‘FUN’
[16:03:42.302]  - needed namespaces: [n=0] 
[16:03:42.302] Finding globals ... DONE
[16:03:42.302]  - use_args: TRUE
[16:03:42.302]  - Getting '...' globals ...
[16:03:42.302] resolve() on list ...
[16:03:42.302]  recursive: 0
[16:03:42.303]  length: 1
[16:03:42.303]  elements: ‘...’
[16:03:42.303]  length: 0 (resolved future 1)
[16:03:42.303] resolve() on list ... DONE
[16:03:42.303]    - '...' content: [n=0] 
[16:03:42.303] List of 1
[16:03:42.303]  $ ...: list()
[16:03:42.303]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:42.303]  - attr(*, "where")=List of 1
[16:03:42.303]   ..$ ...:<environment: 0x55ed7ab72e80> 
[16:03:42.303]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:42.303]  - attr(*, "resolved")= logi TRUE
[16:03:42.303]  - attr(*, "total_size")= num NA
[16:03:42.306]  - Getting '...' globals ... DONE
[16:03:42.306] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:03:42.306] List of 2
[16:03:42.306]  $ ...future.FUN:function (x)  
[16:03:42.306]  $ ...          : list()
[16:03:42.306]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:03:42.306]  - attr(*, "where")=List of 2
[16:03:42.306]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:42.306]   ..$ ...          :<environment: 0x55ed7ab72e80> 
[16:03:42.306]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:42.306]  - attr(*, "resolved")= logi FALSE
[16:03:42.306]  - attr(*, "total_size")= num 4720
[16:03:42.308] Packages to be attached in all futures: [n=0] 
[16:03:42.309] getGlobalsAndPackagesXApply() ... DONE
[16:03:42.309] Number of futures (= number of chunks): 2
[16:03:42.309] Launching 2 futures (chunks) ...
[16:03:42.309] Chunk #1 of 2 ...
[16:03:42.309]  - Finding globals in 'X' for chunk #1 ...
[16:03:42.309] getGlobalsAndPackages() ...
[16:03:42.309] Searching for globals...
[16:03:42.309] 
[16:03:42.310] Searching for globals ... DONE
[16:03:42.310] - globals: [0] <none>
[16:03:42.310] getGlobalsAndPackages() ... DONE
[16:03:42.310]    + additional globals found: [n=0] 
[16:03:42.310]    + additional namespaces needed: [n=0] 
[16:03:42.310]  - Finding globals in 'X' for chunk #1 ... DONE
[16:03:42.310]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:42.310]  - seeds: <none>
[16:03:42.310]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:42.310] getGlobalsAndPackages() ...
[16:03:42.310] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:42.311] Resolving globals: FALSE
[16:03:42.311] Tweak future expression to call with '...' arguments ...
[16:03:42.311] {
[16:03:42.311]     do.call(function(...) {
[16:03:42.311]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:42.311]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:42.311]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:42.311]             on.exit(options(oopts), add = TRUE)
[16:03:42.311]         }
[16:03:42.311]         {
[16:03:42.311]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:42.311]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:42.311]                 ...future.FUN(...future.X_jj, ...)
[16:03:42.311]             })
[16:03:42.311]         }
[16:03:42.311]     }, args = future.call.arguments)
[16:03:42.311] }
[16:03:42.311] Tweak future expression to call with '...' arguments ... DONE
[16:03:42.311] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:42.312] 
[16:03:42.312] getGlobalsAndPackages() ... DONE
[16:03:42.312] run() for ‘Future’ ...
[16:03:42.312] - state: ‘created’
[16:03:42.312] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:42.328] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:42.328] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:42.328]   - Field: ‘node’
[16:03:42.328]   - Field: ‘label’
[16:03:42.328]   - Field: ‘local’
[16:03:42.328]   - Field: ‘owner’
[16:03:42.328]   - Field: ‘envir’
[16:03:42.328]   - Field: ‘workers’
[16:03:42.328]   - Field: ‘packages’
[16:03:42.328]   - Field: ‘gc’
[16:03:42.329]   - Field: ‘conditions’
[16:03:42.329]   - Field: ‘persistent’
[16:03:42.329]   - Field: ‘expr’
[16:03:42.329]   - Field: ‘uuid’
[16:03:42.329]   - Field: ‘seed’
[16:03:42.329]   - Field: ‘version’
[16:03:42.329]   - Field: ‘result’
[16:03:42.329]   - Field: ‘asynchronous’
[16:03:42.329]   - Field: ‘calls’
[16:03:42.329]   - Field: ‘globals’
[16:03:42.330]   - Field: ‘stdout’
[16:03:42.330]   - Field: ‘earlySignal’
[16:03:42.330]   - Field: ‘lazy’
[16:03:42.330]   - Field: ‘state’
[16:03:42.330] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:42.330] - Launch lazy future ...
[16:03:42.330] Packages needed by the future expression (n = 0): <none>
[16:03:42.330] Packages needed by future strategies (n = 0): <none>
[16:03:42.331] {
[16:03:42.331]     {
[16:03:42.331]         {
[16:03:42.331]             ...future.startTime <- base::Sys.time()
[16:03:42.331]             {
[16:03:42.331]                 {
[16:03:42.331]                   {
[16:03:42.331]                     {
[16:03:42.331]                       base::local({
[16:03:42.331]                         has_future <- base::requireNamespace("future", 
[16:03:42.331]                           quietly = TRUE)
[16:03:42.331]                         if (has_future) {
[16:03:42.331]                           ns <- base::getNamespace("future")
[16:03:42.331]                           version <- ns[[".package"]][["version"]]
[16:03:42.331]                           if (is.null(version)) 
[16:03:42.331]                             version <- utils::packageVersion("future")
[16:03:42.331]                         }
[16:03:42.331]                         else {
[16:03:42.331]                           version <- NULL
[16:03:42.331]                         }
[16:03:42.331]                         if (!has_future || version < "1.8.0") {
[16:03:42.331]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:42.331]                             "", base::R.version$version.string), 
[16:03:42.331]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:42.331]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:42.331]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:42.331]                               "release", "version")], collapse = " "), 
[16:03:42.331]                             hostname = base::Sys.info()[["nodename"]])
[16:03:42.331]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:42.331]                             info)
[16:03:42.331]                           info <- base::paste(info, collapse = "; ")
[16:03:42.331]                           if (!has_future) {
[16:03:42.331]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:42.331]                               info)
[16:03:42.331]                           }
[16:03:42.331]                           else {
[16:03:42.331]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:42.331]                               info, version)
[16:03:42.331]                           }
[16:03:42.331]                           base::stop(msg)
[16:03:42.331]                         }
[16:03:42.331]                       })
[16:03:42.331]                     }
[16:03:42.331]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:42.331]                     base::options(mc.cores = 1L)
[16:03:42.331]                   }
[16:03:42.331]                   options(future.plan = NULL)
[16:03:42.331]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:42.331]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:42.331]                 }
[16:03:42.331]                 ...future.workdir <- getwd()
[16:03:42.331]             }
[16:03:42.331]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:42.331]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:42.331]         }
[16:03:42.331]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:42.331]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:42.331]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:42.331]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:42.331]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:42.331]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:42.331]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:42.331]             base::names(...future.oldOptions))
[16:03:42.331]     }
[16:03:42.331]     if (TRUE) {
[16:03:42.331]     }
[16:03:42.331]     else {
[16:03:42.331]         if (NA) {
[16:03:42.331]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:42.331]                 open = "w")
[16:03:42.331]         }
[16:03:42.331]         else {
[16:03:42.331]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:42.331]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:42.331]         }
[16:03:42.331]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:42.331]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:42.331]             base::sink(type = "output", split = FALSE)
[16:03:42.331]             base::close(...future.stdout)
[16:03:42.331]         }, add = TRUE)
[16:03:42.331]     }
[16:03:42.331]     ...future.frame <- base::sys.nframe()
[16:03:42.331]     ...future.conditions <- base::list()
[16:03:42.331]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:42.331]     if (FALSE) {
[16:03:42.331]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:42.331]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:42.331]     }
[16:03:42.331]     ...future.result <- base::tryCatch({
[16:03:42.331]         base::withCallingHandlers({
[16:03:42.331]             ...future.value <- base::withVisible(base::local({
[16:03:42.331]                 ...future.makeSendCondition <- base::local({
[16:03:42.331]                   sendCondition <- NULL
[16:03:42.331]                   function(frame = 1L) {
[16:03:42.331]                     if (is.function(sendCondition)) 
[16:03:42.331]                       return(sendCondition)
[16:03:42.331]                     ns <- getNamespace("parallel")
[16:03:42.331]                     if (exists("sendData", mode = "function", 
[16:03:42.331]                       envir = ns)) {
[16:03:42.331]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:42.331]                         envir = ns)
[16:03:42.331]                       envir <- sys.frame(frame)
[16:03:42.331]                       master <- NULL
[16:03:42.331]                       while (!identical(envir, .GlobalEnv) && 
[16:03:42.331]                         !identical(envir, emptyenv())) {
[16:03:42.331]                         if (exists("master", mode = "list", envir = envir, 
[16:03:42.331]                           inherits = FALSE)) {
[16:03:42.331]                           master <- get("master", mode = "list", 
[16:03:42.331]                             envir = envir, inherits = FALSE)
[16:03:42.331]                           if (inherits(master, c("SOCKnode", 
[16:03:42.331]                             "SOCK0node"))) {
[16:03:42.331]                             sendCondition <<- function(cond) {
[16:03:42.331]                               data <- list(type = "VALUE", value = cond, 
[16:03:42.331]                                 success = TRUE)
[16:03:42.331]                               parallel_sendData(master, data)
[16:03:42.331]                             }
[16:03:42.331]                             return(sendCondition)
[16:03:42.331]                           }
[16:03:42.331]                         }
[16:03:42.331]                         frame <- frame + 1L
[16:03:42.331]                         envir <- sys.frame(frame)
[16:03:42.331]                       }
[16:03:42.331]                     }
[16:03:42.331]                     sendCondition <<- function(cond) NULL
[16:03:42.331]                   }
[16:03:42.331]                 })
[16:03:42.331]                 withCallingHandlers({
[16:03:42.331]                   {
[16:03:42.331]                     do.call(function(...) {
[16:03:42.331]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:42.331]                       if (!identical(...future.globals.maxSize.org, 
[16:03:42.331]                         ...future.globals.maxSize)) {
[16:03:42.331]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:42.331]                         on.exit(options(oopts), add = TRUE)
[16:03:42.331]                       }
[16:03:42.331]                       {
[16:03:42.331]                         lapply(seq_along(...future.elements_ii), 
[16:03:42.331]                           FUN = function(jj) {
[16:03:42.331]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:42.331]                             ...future.FUN(...future.X_jj, ...)
[16:03:42.331]                           })
[16:03:42.331]                       }
[16:03:42.331]                     }, args = future.call.arguments)
[16:03:42.331]                   }
[16:03:42.331]                 }, immediateCondition = function(cond) {
[16:03:42.331]                   sendCondition <- ...future.makeSendCondition()
[16:03:42.331]                   sendCondition(cond)
[16:03:42.331]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:42.331]                   {
[16:03:42.331]                     inherits <- base::inherits
[16:03:42.331]                     invokeRestart <- base::invokeRestart
[16:03:42.331]                     is.null <- base::is.null
[16:03:42.331]                     muffled <- FALSE
[16:03:42.331]                     if (inherits(cond, "message")) {
[16:03:42.331]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:42.331]                       if (muffled) 
[16:03:42.331]                         invokeRestart("muffleMessage")
[16:03:42.331]                     }
[16:03:42.331]                     else if (inherits(cond, "warning")) {
[16:03:42.331]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:42.331]                       if (muffled) 
[16:03:42.331]                         invokeRestart("muffleWarning")
[16:03:42.331]                     }
[16:03:42.331]                     else if (inherits(cond, "condition")) {
[16:03:42.331]                       if (!is.null(pattern)) {
[16:03:42.331]                         computeRestarts <- base::computeRestarts
[16:03:42.331]                         grepl <- base::grepl
[16:03:42.331]                         restarts <- computeRestarts(cond)
[16:03:42.331]                         for (restart in restarts) {
[16:03:42.331]                           name <- restart$name
[16:03:42.331]                           if (is.null(name)) 
[16:03:42.331]                             next
[16:03:42.331]                           if (!grepl(pattern, name)) 
[16:03:42.331]                             next
[16:03:42.331]                           invokeRestart(restart)
[16:03:42.331]                           muffled <- TRUE
[16:03:42.331]                           break
[16:03:42.331]                         }
[16:03:42.331]                       }
[16:03:42.331]                     }
[16:03:42.331]                     invisible(muffled)
[16:03:42.331]                   }
[16:03:42.331]                   muffleCondition(cond)
[16:03:42.331]                 })
[16:03:42.331]             }))
[16:03:42.331]             future::FutureResult(value = ...future.value$value, 
[16:03:42.331]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:42.331]                   ...future.rng), globalenv = if (FALSE) 
[16:03:42.331]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:42.331]                     ...future.globalenv.names))
[16:03:42.331]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:42.331]         }, condition = base::local({
[16:03:42.331]             c <- base::c
[16:03:42.331]             inherits <- base::inherits
[16:03:42.331]             invokeRestart <- base::invokeRestart
[16:03:42.331]             length <- base::length
[16:03:42.331]             list <- base::list
[16:03:42.331]             seq.int <- base::seq.int
[16:03:42.331]             signalCondition <- base::signalCondition
[16:03:42.331]             sys.calls <- base::sys.calls
[16:03:42.331]             `[[` <- base::`[[`
[16:03:42.331]             `+` <- base::`+`
[16:03:42.331]             `<<-` <- base::`<<-`
[16:03:42.331]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:42.331]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:42.331]                   3L)]
[16:03:42.331]             }
[16:03:42.331]             function(cond) {
[16:03:42.331]                 is_error <- inherits(cond, "error")
[16:03:42.331]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:42.331]                   NULL)
[16:03:42.331]                 if (is_error) {
[16:03:42.331]                   sessionInformation <- function() {
[16:03:42.331]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:42.331]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:42.331]                       search = base::search(), system = base::Sys.info())
[16:03:42.331]                   }
[16:03:42.331]                   ...future.conditions[[length(...future.conditions) + 
[16:03:42.331]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:42.331]                     cond$call), session = sessionInformation(), 
[16:03:42.331]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:42.331]                   signalCondition(cond)
[16:03:42.331]                 }
[16:03:42.331]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:42.331]                 "immediateCondition"))) {
[16:03:42.331]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:42.331]                   ...future.conditions[[length(...future.conditions) + 
[16:03:42.331]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:42.331]                   if (TRUE && !signal) {
[16:03:42.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:42.331]                     {
[16:03:42.331]                       inherits <- base::inherits
[16:03:42.331]                       invokeRestart <- base::invokeRestart
[16:03:42.331]                       is.null <- base::is.null
[16:03:42.331]                       muffled <- FALSE
[16:03:42.331]                       if (inherits(cond, "message")) {
[16:03:42.331]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:42.331]                         if (muffled) 
[16:03:42.331]                           invokeRestart("muffleMessage")
[16:03:42.331]                       }
[16:03:42.331]                       else if (inherits(cond, "warning")) {
[16:03:42.331]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:42.331]                         if (muffled) 
[16:03:42.331]                           invokeRestart("muffleWarning")
[16:03:42.331]                       }
[16:03:42.331]                       else if (inherits(cond, "condition")) {
[16:03:42.331]                         if (!is.null(pattern)) {
[16:03:42.331]                           computeRestarts <- base::computeRestarts
[16:03:42.331]                           grepl <- base::grepl
[16:03:42.331]                           restarts <- computeRestarts(cond)
[16:03:42.331]                           for (restart in restarts) {
[16:03:42.331]                             name <- restart$name
[16:03:42.331]                             if (is.null(name)) 
[16:03:42.331]                               next
[16:03:42.331]                             if (!grepl(pattern, name)) 
[16:03:42.331]                               next
[16:03:42.331]                             invokeRestart(restart)
[16:03:42.331]                             muffled <- TRUE
[16:03:42.331]                             break
[16:03:42.331]                           }
[16:03:42.331]                         }
[16:03:42.331]                       }
[16:03:42.331]                       invisible(muffled)
[16:03:42.331]                     }
[16:03:42.331]                     muffleCondition(cond, pattern = "^muffle")
[16:03:42.331]                   }
[16:03:42.331]                 }
[16:03:42.331]                 else {
[16:03:42.331]                   if (TRUE) {
[16:03:42.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:42.331]                     {
[16:03:42.331]                       inherits <- base::inherits
[16:03:42.331]                       invokeRestart <- base::invokeRestart
[16:03:42.331]                       is.null <- base::is.null
[16:03:42.331]                       muffled <- FALSE
[16:03:42.331]                       if (inherits(cond, "message")) {
[16:03:42.331]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:42.331]                         if (muffled) 
[16:03:42.331]                           invokeRestart("muffleMessage")
[16:03:42.331]                       }
[16:03:42.331]                       else if (inherits(cond, "warning")) {
[16:03:42.331]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:42.331]                         if (muffled) 
[16:03:42.331]                           invokeRestart("muffleWarning")
[16:03:42.331]                       }
[16:03:42.331]                       else if (inherits(cond, "condition")) {
[16:03:42.331]                         if (!is.null(pattern)) {
[16:03:42.331]                           computeRestarts <- base::computeRestarts
[16:03:42.331]                           grepl <- base::grepl
[16:03:42.331]                           restarts <- computeRestarts(cond)
[16:03:42.331]                           for (restart in restarts) {
[16:03:42.331]                             name <- restart$name
[16:03:42.331]                             if (is.null(name)) 
[16:03:42.331]                               next
[16:03:42.331]                             if (!grepl(pattern, name)) 
[16:03:42.331]                               next
[16:03:42.331]                             invokeRestart(restart)
[16:03:42.331]                             muffled <- TRUE
[16:03:42.331]                             break
[16:03:42.331]                           }
[16:03:42.331]                         }
[16:03:42.331]                       }
[16:03:42.331]                       invisible(muffled)
[16:03:42.331]                     }
[16:03:42.331]                     muffleCondition(cond, pattern = "^muffle")
[16:03:42.331]                   }
[16:03:42.331]                 }
[16:03:42.331]             }
[16:03:42.331]         }))
[16:03:42.331]     }, error = function(ex) {
[16:03:42.331]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:42.331]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:42.331]                 ...future.rng), started = ...future.startTime, 
[16:03:42.331]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:42.331]             version = "1.8"), class = "FutureResult")
[16:03:42.331]     }, finally = {
[16:03:42.331]         if (!identical(...future.workdir, getwd())) 
[16:03:42.331]             setwd(...future.workdir)
[16:03:42.331]         {
[16:03:42.331]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:42.331]                 ...future.oldOptions$nwarnings <- NULL
[16:03:42.331]             }
[16:03:42.331]             base::options(...future.oldOptions)
[16:03:42.331]             if (.Platform$OS.type == "windows") {
[16:03:42.331]                 old_names <- names(...future.oldEnvVars)
[16:03:42.331]                 envs <- base::Sys.getenv()
[16:03:42.331]                 names <- names(envs)
[16:03:42.331]                 common <- intersect(names, old_names)
[16:03:42.331]                 added <- setdiff(names, old_names)
[16:03:42.331]                 removed <- setdiff(old_names, names)
[16:03:42.331]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:42.331]                   envs[common]]
[16:03:42.331]                 NAMES <- toupper(changed)
[16:03:42.331]                 args <- list()
[16:03:42.331]                 for (kk in seq_along(NAMES)) {
[16:03:42.331]                   name <- changed[[kk]]
[16:03:42.331]                   NAME <- NAMES[[kk]]
[16:03:42.331]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:42.331]                     next
[16:03:42.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:42.331]                 }
[16:03:42.331]                 NAMES <- toupper(added)
[16:03:42.331]                 for (kk in seq_along(NAMES)) {
[16:03:42.331]                   name <- added[[kk]]
[16:03:42.331]                   NAME <- NAMES[[kk]]
[16:03:42.331]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:42.331]                     next
[16:03:42.331]                   args[[name]] <- ""
[16:03:42.331]                 }
[16:03:42.331]                 NAMES <- toupper(removed)
[16:03:42.331]                 for (kk in seq_along(NAMES)) {
[16:03:42.331]                   name <- removed[[kk]]
[16:03:42.331]                   NAME <- NAMES[[kk]]
[16:03:42.331]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:42.331]                     next
[16:03:42.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:42.331]                 }
[16:03:42.331]                 if (length(args) > 0) 
[16:03:42.331]                   base::do.call(base::Sys.setenv, args = args)
[16:03:42.331]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:42.331]             }
[16:03:42.331]             else {
[16:03:42.331]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:42.331]             }
[16:03:42.331]             {
[16:03:42.331]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:42.331]                   0L) {
[16:03:42.331]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:42.331]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:42.331]                   base::options(opts)
[16:03:42.331]                 }
[16:03:42.331]                 {
[16:03:42.331]                   {
[16:03:42.331]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:42.331]                     NULL
[16:03:42.331]                   }
[16:03:42.331]                   options(future.plan = NULL)
[16:03:42.331]                   if (is.na(NA_character_)) 
[16:03:42.331]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:42.331]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:42.331]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:42.331]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:42.331]                     envir = parent.frame()) 
[16:03:42.331]                   {
[16:03:42.331]                     if (is.function(workers)) 
[16:03:42.331]                       workers <- workers()
[16:03:42.331]                     workers <- structure(as.integer(workers), 
[16:03:42.331]                       class = class(workers))
[16:03:42.331]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:42.331]                       workers >= 1)
[16:03:42.331]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:42.331]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:42.331]                     }
[16:03:42.331]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:42.331]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:42.331]                       envir = envir)
[16:03:42.331]                     if (!future$lazy) 
[16:03:42.331]                       future <- run(future)
[16:03:42.331]                     invisible(future)
[16:03:42.331]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:42.331]                 }
[16:03:42.331]             }
[16:03:42.331]         }
[16:03:42.331]     })
[16:03:42.331]     if (FALSE) {
[16:03:42.331]         base::sink(type = "output", split = FALSE)
[16:03:42.331]         if (NA) {
[16:03:42.331]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:42.331]         }
[16:03:42.331]         else {
[16:03:42.331]             ...future.result["stdout"] <- base::list(NULL)
[16:03:42.331]         }
[16:03:42.331]         base::close(...future.stdout)
[16:03:42.331]         ...future.stdout <- NULL
[16:03:42.331]     }
[16:03:42.331]     ...future.result$conditions <- ...future.conditions
[16:03:42.331]     ...future.result$finished <- base::Sys.time()
[16:03:42.331]     ...future.result
[16:03:42.331] }
[16:03:42.333] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[16:03:42.334] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[16:03:42.334] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[16:03:42.334] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:03:42.335] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:03:42.335] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[16:03:42.335] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[16:03:42.335] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:03:42.336] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:03:42.336] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:03:42.336] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:03:42.336] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[16:03:42.337] MultisessionFuture started
[16:03:42.337] - Launch lazy future ... done
[16:03:42.337] run() for ‘MultisessionFuture’ ... done
[16:03:42.337] Created future:
[16:03:42.337] MultisessionFuture:
[16:03:42.337] Label: ‘future_lapply-1’
[16:03:42.337] Expression:
[16:03:42.337] {
[16:03:42.337]     do.call(function(...) {
[16:03:42.337]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:42.337]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:42.337]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:42.337]             on.exit(options(oopts), add = TRUE)
[16:03:42.337]         }
[16:03:42.337]         {
[16:03:42.337]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:42.337]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:42.337]                 ...future.FUN(...future.X_jj, ...)
[16:03:42.337]             })
[16:03:42.337]         }
[16:03:42.337]     }, args = future.call.arguments)
[16:03:42.337] }
[16:03:42.337] Lazy evaluation: FALSE
[16:03:42.337] Asynchronous evaluation: TRUE
[16:03:42.337] Local evaluation: TRUE
[16:03:42.337] Environment: R_GlobalEnv
[16:03:42.337] Capture standard output: NA
[16:03:42.337] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:42.337] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:42.337] Packages: <none>
[16:03:42.337] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:42.337] Resolved: FALSE
[16:03:42.337] Value: <not collected>
[16:03:42.337] Conditions captured: <none>
[16:03:42.337] Early signaling: FALSE
[16:03:42.337] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:42.337] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:42.349] Chunk #1 of 2 ... DONE
[16:03:42.349] Chunk #2 of 2 ...
[16:03:42.349]  - Finding globals in 'X' for chunk #2 ...
[16:03:42.349] getGlobalsAndPackages() ...
[16:03:42.349] Searching for globals...
[16:03:42.350] 
[16:03:42.350] Searching for globals ... DONE
[16:03:42.350] - globals: [0] <none>
[16:03:42.350] getGlobalsAndPackages() ... DONE
[16:03:42.350]    + additional globals found: [n=0] 
[16:03:42.350]    + additional namespaces needed: [n=0] 
[16:03:42.350]  - Finding globals in 'X' for chunk #2 ... DONE
[16:03:42.350]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:42.350]  - seeds: <none>
[16:03:42.350]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:42.351] getGlobalsAndPackages() ...
[16:03:42.351] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:42.351] Resolving globals: FALSE
[16:03:42.351] Tweak future expression to call with '...' arguments ...
[16:03:42.351] {
[16:03:42.351]     do.call(function(...) {
[16:03:42.351]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:42.351]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:42.351]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:42.351]             on.exit(options(oopts), add = TRUE)
[16:03:42.351]         }
[16:03:42.351]         {
[16:03:42.351]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:42.351]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:42.351]                 ...future.FUN(...future.X_jj, ...)
[16:03:42.351]             })
[16:03:42.351]         }
[16:03:42.351]     }, args = future.call.arguments)
[16:03:42.351] }
[16:03:42.351] Tweak future expression to call with '...' arguments ... DONE
[16:03:42.352] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:42.352] 
[16:03:42.352] getGlobalsAndPackages() ... DONE
[16:03:42.352] run() for ‘Future’ ...
[16:03:42.352] - state: ‘created’
[16:03:42.352] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:42.365] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:42.365] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:42.366]   - Field: ‘node’
[16:03:42.366]   - Field: ‘label’
[16:03:42.366]   - Field: ‘local’
[16:03:42.366]   - Field: ‘owner’
[16:03:42.366]   - Field: ‘envir’
[16:03:42.366]   - Field: ‘workers’
[16:03:42.366]   - Field: ‘packages’
[16:03:42.366]   - Field: ‘gc’
[16:03:42.366]   - Field: ‘conditions’
[16:03:42.366]   - Field: ‘persistent’
[16:03:42.367]   - Field: ‘expr’
[16:03:42.367]   - Field: ‘uuid’
[16:03:42.367]   - Field: ‘seed’
[16:03:42.367]   - Field: ‘version’
[16:03:42.367]   - Field: ‘result’
[16:03:42.367]   - Field: ‘asynchronous’
[16:03:42.367]   - Field: ‘calls’
[16:03:42.367]   - Field: ‘globals’
[16:03:42.367]   - Field: ‘stdout’
[16:03:42.367]   - Field: ‘earlySignal’
[16:03:42.367]   - Field: ‘lazy’
[16:03:42.368]   - Field: ‘state’
[16:03:42.368] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:42.368] - Launch lazy future ...
[16:03:42.368] Packages needed by the future expression (n = 0): <none>
[16:03:42.368] Packages needed by future strategies (n = 0): <none>
[16:03:42.369] {
[16:03:42.369]     {
[16:03:42.369]         {
[16:03:42.369]             ...future.startTime <- base::Sys.time()
[16:03:42.369]             {
[16:03:42.369]                 {
[16:03:42.369]                   {
[16:03:42.369]                     {
[16:03:42.369]                       base::local({
[16:03:42.369]                         has_future <- base::requireNamespace("future", 
[16:03:42.369]                           quietly = TRUE)
[16:03:42.369]                         if (has_future) {
[16:03:42.369]                           ns <- base::getNamespace("future")
[16:03:42.369]                           version <- ns[[".package"]][["version"]]
[16:03:42.369]                           if (is.null(version)) 
[16:03:42.369]                             version <- utils::packageVersion("future")
[16:03:42.369]                         }
[16:03:42.369]                         else {
[16:03:42.369]                           version <- NULL
[16:03:42.369]                         }
[16:03:42.369]                         if (!has_future || version < "1.8.0") {
[16:03:42.369]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:42.369]                             "", base::R.version$version.string), 
[16:03:42.369]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:42.369]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:42.369]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:42.369]                               "release", "version")], collapse = " "), 
[16:03:42.369]                             hostname = base::Sys.info()[["nodename"]])
[16:03:42.369]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:42.369]                             info)
[16:03:42.369]                           info <- base::paste(info, collapse = "; ")
[16:03:42.369]                           if (!has_future) {
[16:03:42.369]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:42.369]                               info)
[16:03:42.369]                           }
[16:03:42.369]                           else {
[16:03:42.369]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:42.369]                               info, version)
[16:03:42.369]                           }
[16:03:42.369]                           base::stop(msg)
[16:03:42.369]                         }
[16:03:42.369]                       })
[16:03:42.369]                     }
[16:03:42.369]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:42.369]                     base::options(mc.cores = 1L)
[16:03:42.369]                   }
[16:03:42.369]                   options(future.plan = NULL)
[16:03:42.369]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:42.369]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:42.369]                 }
[16:03:42.369]                 ...future.workdir <- getwd()
[16:03:42.369]             }
[16:03:42.369]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:42.369]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:42.369]         }
[16:03:42.369]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:42.369]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:42.369]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:42.369]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:42.369]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:42.369]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:42.369]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:42.369]             base::names(...future.oldOptions))
[16:03:42.369]     }
[16:03:42.369]     if (TRUE) {
[16:03:42.369]     }
[16:03:42.369]     else {
[16:03:42.369]         if (NA) {
[16:03:42.369]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:42.369]                 open = "w")
[16:03:42.369]         }
[16:03:42.369]         else {
[16:03:42.369]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:42.369]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:42.369]         }
[16:03:42.369]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:42.369]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:42.369]             base::sink(type = "output", split = FALSE)
[16:03:42.369]             base::close(...future.stdout)
[16:03:42.369]         }, add = TRUE)
[16:03:42.369]     }
[16:03:42.369]     ...future.frame <- base::sys.nframe()
[16:03:42.369]     ...future.conditions <- base::list()
[16:03:42.369]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:42.369]     if (FALSE) {
[16:03:42.369]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:42.369]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:42.369]     }
[16:03:42.369]     ...future.result <- base::tryCatch({
[16:03:42.369]         base::withCallingHandlers({
[16:03:42.369]             ...future.value <- base::withVisible(base::local({
[16:03:42.369]                 ...future.makeSendCondition <- base::local({
[16:03:42.369]                   sendCondition <- NULL
[16:03:42.369]                   function(frame = 1L) {
[16:03:42.369]                     if (is.function(sendCondition)) 
[16:03:42.369]                       return(sendCondition)
[16:03:42.369]                     ns <- getNamespace("parallel")
[16:03:42.369]                     if (exists("sendData", mode = "function", 
[16:03:42.369]                       envir = ns)) {
[16:03:42.369]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:42.369]                         envir = ns)
[16:03:42.369]                       envir <- sys.frame(frame)
[16:03:42.369]                       master <- NULL
[16:03:42.369]                       while (!identical(envir, .GlobalEnv) && 
[16:03:42.369]                         !identical(envir, emptyenv())) {
[16:03:42.369]                         if (exists("master", mode = "list", envir = envir, 
[16:03:42.369]                           inherits = FALSE)) {
[16:03:42.369]                           master <- get("master", mode = "list", 
[16:03:42.369]                             envir = envir, inherits = FALSE)
[16:03:42.369]                           if (inherits(master, c("SOCKnode", 
[16:03:42.369]                             "SOCK0node"))) {
[16:03:42.369]                             sendCondition <<- function(cond) {
[16:03:42.369]                               data <- list(type = "VALUE", value = cond, 
[16:03:42.369]                                 success = TRUE)
[16:03:42.369]                               parallel_sendData(master, data)
[16:03:42.369]                             }
[16:03:42.369]                             return(sendCondition)
[16:03:42.369]                           }
[16:03:42.369]                         }
[16:03:42.369]                         frame <- frame + 1L
[16:03:42.369]                         envir <- sys.frame(frame)
[16:03:42.369]                       }
[16:03:42.369]                     }
[16:03:42.369]                     sendCondition <<- function(cond) NULL
[16:03:42.369]                   }
[16:03:42.369]                 })
[16:03:42.369]                 withCallingHandlers({
[16:03:42.369]                   {
[16:03:42.369]                     do.call(function(...) {
[16:03:42.369]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:42.369]                       if (!identical(...future.globals.maxSize.org, 
[16:03:42.369]                         ...future.globals.maxSize)) {
[16:03:42.369]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:42.369]                         on.exit(options(oopts), add = TRUE)
[16:03:42.369]                       }
[16:03:42.369]                       {
[16:03:42.369]                         lapply(seq_along(...future.elements_ii), 
[16:03:42.369]                           FUN = function(jj) {
[16:03:42.369]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:42.369]                             ...future.FUN(...future.X_jj, ...)
[16:03:42.369]                           })
[16:03:42.369]                       }
[16:03:42.369]                     }, args = future.call.arguments)
[16:03:42.369]                   }
[16:03:42.369]                 }, immediateCondition = function(cond) {
[16:03:42.369]                   sendCondition <- ...future.makeSendCondition()
[16:03:42.369]                   sendCondition(cond)
[16:03:42.369]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:42.369]                   {
[16:03:42.369]                     inherits <- base::inherits
[16:03:42.369]                     invokeRestart <- base::invokeRestart
[16:03:42.369]                     is.null <- base::is.null
[16:03:42.369]                     muffled <- FALSE
[16:03:42.369]                     if (inherits(cond, "message")) {
[16:03:42.369]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:42.369]                       if (muffled) 
[16:03:42.369]                         invokeRestart("muffleMessage")
[16:03:42.369]                     }
[16:03:42.369]                     else if (inherits(cond, "warning")) {
[16:03:42.369]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:42.369]                       if (muffled) 
[16:03:42.369]                         invokeRestart("muffleWarning")
[16:03:42.369]                     }
[16:03:42.369]                     else if (inherits(cond, "condition")) {
[16:03:42.369]                       if (!is.null(pattern)) {
[16:03:42.369]                         computeRestarts <- base::computeRestarts
[16:03:42.369]                         grepl <- base::grepl
[16:03:42.369]                         restarts <- computeRestarts(cond)
[16:03:42.369]                         for (restart in restarts) {
[16:03:42.369]                           name <- restart$name
[16:03:42.369]                           if (is.null(name)) 
[16:03:42.369]                             next
[16:03:42.369]                           if (!grepl(pattern, name)) 
[16:03:42.369]                             next
[16:03:42.369]                           invokeRestart(restart)
[16:03:42.369]                           muffled <- TRUE
[16:03:42.369]                           break
[16:03:42.369]                         }
[16:03:42.369]                       }
[16:03:42.369]                     }
[16:03:42.369]                     invisible(muffled)
[16:03:42.369]                   }
[16:03:42.369]                   muffleCondition(cond)
[16:03:42.369]                 })
[16:03:42.369]             }))
[16:03:42.369]             future::FutureResult(value = ...future.value$value, 
[16:03:42.369]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:42.369]                   ...future.rng), globalenv = if (FALSE) 
[16:03:42.369]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:42.369]                     ...future.globalenv.names))
[16:03:42.369]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:42.369]         }, condition = base::local({
[16:03:42.369]             c <- base::c
[16:03:42.369]             inherits <- base::inherits
[16:03:42.369]             invokeRestart <- base::invokeRestart
[16:03:42.369]             length <- base::length
[16:03:42.369]             list <- base::list
[16:03:42.369]             seq.int <- base::seq.int
[16:03:42.369]             signalCondition <- base::signalCondition
[16:03:42.369]             sys.calls <- base::sys.calls
[16:03:42.369]             `[[` <- base::`[[`
[16:03:42.369]             `+` <- base::`+`
[16:03:42.369]             `<<-` <- base::`<<-`
[16:03:42.369]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:42.369]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:42.369]                   3L)]
[16:03:42.369]             }
[16:03:42.369]             function(cond) {
[16:03:42.369]                 is_error <- inherits(cond, "error")
[16:03:42.369]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:42.369]                   NULL)
[16:03:42.369]                 if (is_error) {
[16:03:42.369]                   sessionInformation <- function() {
[16:03:42.369]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:42.369]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:42.369]                       search = base::search(), system = base::Sys.info())
[16:03:42.369]                   }
[16:03:42.369]                   ...future.conditions[[length(...future.conditions) + 
[16:03:42.369]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:42.369]                     cond$call), session = sessionInformation(), 
[16:03:42.369]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:42.369]                   signalCondition(cond)
[16:03:42.369]                 }
[16:03:42.369]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:42.369]                 "immediateCondition"))) {
[16:03:42.369]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:42.369]                   ...future.conditions[[length(...future.conditions) + 
[16:03:42.369]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:42.369]                   if (TRUE && !signal) {
[16:03:42.369]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:42.369]                     {
[16:03:42.369]                       inherits <- base::inherits
[16:03:42.369]                       invokeRestart <- base::invokeRestart
[16:03:42.369]                       is.null <- base::is.null
[16:03:42.369]                       muffled <- FALSE
[16:03:42.369]                       if (inherits(cond, "message")) {
[16:03:42.369]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:42.369]                         if (muffled) 
[16:03:42.369]                           invokeRestart("muffleMessage")
[16:03:42.369]                       }
[16:03:42.369]                       else if (inherits(cond, "warning")) {
[16:03:42.369]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:42.369]                         if (muffled) 
[16:03:42.369]                           invokeRestart("muffleWarning")
[16:03:42.369]                       }
[16:03:42.369]                       else if (inherits(cond, "condition")) {
[16:03:42.369]                         if (!is.null(pattern)) {
[16:03:42.369]                           computeRestarts <- base::computeRestarts
[16:03:42.369]                           grepl <- base::grepl
[16:03:42.369]                           restarts <- computeRestarts(cond)
[16:03:42.369]                           for (restart in restarts) {
[16:03:42.369]                             name <- restart$name
[16:03:42.369]                             if (is.null(name)) 
[16:03:42.369]                               next
[16:03:42.369]                             if (!grepl(pattern, name)) 
[16:03:42.369]                               next
[16:03:42.369]                             invokeRestart(restart)
[16:03:42.369]                             muffled <- TRUE
[16:03:42.369]                             break
[16:03:42.369]                           }
[16:03:42.369]                         }
[16:03:42.369]                       }
[16:03:42.369]                       invisible(muffled)
[16:03:42.369]                     }
[16:03:42.369]                     muffleCondition(cond, pattern = "^muffle")
[16:03:42.369]                   }
[16:03:42.369]                 }
[16:03:42.369]                 else {
[16:03:42.369]                   if (TRUE) {
[16:03:42.369]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:42.369]                     {
[16:03:42.369]                       inherits <- base::inherits
[16:03:42.369]                       invokeRestart <- base::invokeRestart
[16:03:42.369]                       is.null <- base::is.null
[16:03:42.369]                       muffled <- FALSE
[16:03:42.369]                       if (inherits(cond, "message")) {
[16:03:42.369]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:42.369]                         if (muffled) 
[16:03:42.369]                           invokeRestart("muffleMessage")
[16:03:42.369]                       }
[16:03:42.369]                       else if (inherits(cond, "warning")) {
[16:03:42.369]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:42.369]                         if (muffled) 
[16:03:42.369]                           invokeRestart("muffleWarning")
[16:03:42.369]                       }
[16:03:42.369]                       else if (inherits(cond, "condition")) {
[16:03:42.369]                         if (!is.null(pattern)) {
[16:03:42.369]                           computeRestarts <- base::computeRestarts
[16:03:42.369]                           grepl <- base::grepl
[16:03:42.369]                           restarts <- computeRestarts(cond)
[16:03:42.369]                           for (restart in restarts) {
[16:03:42.369]                             name <- restart$name
[16:03:42.369]                             if (is.null(name)) 
[16:03:42.369]                               next
[16:03:42.369]                             if (!grepl(pattern, name)) 
[16:03:42.369]                               next
[16:03:42.369]                             invokeRestart(restart)
[16:03:42.369]                             muffled <- TRUE
[16:03:42.369]                             break
[16:03:42.369]                           }
[16:03:42.369]                         }
[16:03:42.369]                       }
[16:03:42.369]                       invisible(muffled)
[16:03:42.369]                     }
[16:03:42.369]                     muffleCondition(cond, pattern = "^muffle")
[16:03:42.369]                   }
[16:03:42.369]                 }
[16:03:42.369]             }
[16:03:42.369]         }))
[16:03:42.369]     }, error = function(ex) {
[16:03:42.369]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:42.369]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:42.369]                 ...future.rng), started = ...future.startTime, 
[16:03:42.369]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:42.369]             version = "1.8"), class = "FutureResult")
[16:03:42.369]     }, finally = {
[16:03:42.369]         if (!identical(...future.workdir, getwd())) 
[16:03:42.369]             setwd(...future.workdir)
[16:03:42.369]         {
[16:03:42.369]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:42.369]                 ...future.oldOptions$nwarnings <- NULL
[16:03:42.369]             }
[16:03:42.369]             base::options(...future.oldOptions)
[16:03:42.369]             if (.Platform$OS.type == "windows") {
[16:03:42.369]                 old_names <- names(...future.oldEnvVars)
[16:03:42.369]                 envs <- base::Sys.getenv()
[16:03:42.369]                 names <- names(envs)
[16:03:42.369]                 common <- intersect(names, old_names)
[16:03:42.369]                 added <- setdiff(names, old_names)
[16:03:42.369]                 removed <- setdiff(old_names, names)
[16:03:42.369]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:42.369]                   envs[common]]
[16:03:42.369]                 NAMES <- toupper(changed)
[16:03:42.369]                 args <- list()
[16:03:42.369]                 for (kk in seq_along(NAMES)) {
[16:03:42.369]                   name <- changed[[kk]]
[16:03:42.369]                   NAME <- NAMES[[kk]]
[16:03:42.369]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:42.369]                     next
[16:03:42.369]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:42.369]                 }
[16:03:42.369]                 NAMES <- toupper(added)
[16:03:42.369]                 for (kk in seq_along(NAMES)) {
[16:03:42.369]                   name <- added[[kk]]
[16:03:42.369]                   NAME <- NAMES[[kk]]
[16:03:42.369]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:42.369]                     next
[16:03:42.369]                   args[[name]] <- ""
[16:03:42.369]                 }
[16:03:42.369]                 NAMES <- toupper(removed)
[16:03:42.369]                 for (kk in seq_along(NAMES)) {
[16:03:42.369]                   name <- removed[[kk]]
[16:03:42.369]                   NAME <- NAMES[[kk]]
[16:03:42.369]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:42.369]                     next
[16:03:42.369]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:42.369]                 }
[16:03:42.369]                 if (length(args) > 0) 
[16:03:42.369]                   base::do.call(base::Sys.setenv, args = args)
[16:03:42.369]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:42.369]             }
[16:03:42.369]             else {
[16:03:42.369]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:42.369]             }
[16:03:42.369]             {
[16:03:42.369]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:42.369]                   0L) {
[16:03:42.369]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:42.369]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:42.369]                   base::options(opts)
[16:03:42.369]                 }
[16:03:42.369]                 {
[16:03:42.369]                   {
[16:03:42.369]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:42.369]                     NULL
[16:03:42.369]                   }
[16:03:42.369]                   options(future.plan = NULL)
[16:03:42.369]                   if (is.na(NA_character_)) 
[16:03:42.369]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:42.369]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:42.369]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:42.369]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:42.369]                     envir = parent.frame()) 
[16:03:42.369]                   {
[16:03:42.369]                     if (is.function(workers)) 
[16:03:42.369]                       workers <- workers()
[16:03:42.369]                     workers <- structure(as.integer(workers), 
[16:03:42.369]                       class = class(workers))
[16:03:42.369]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:42.369]                       workers >= 1)
[16:03:42.369]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:42.369]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:42.369]                     }
[16:03:42.369]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:42.369]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:42.369]                       envir = envir)
[16:03:42.369]                     if (!future$lazy) 
[16:03:42.369]                       future <- run(future)
[16:03:42.369]                     invisible(future)
[16:03:42.369]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:42.369]                 }
[16:03:42.369]             }
[16:03:42.369]         }
[16:03:42.369]     })
[16:03:42.369]     if (FALSE) {
[16:03:42.369]         base::sink(type = "output", split = FALSE)
[16:03:42.369]         if (NA) {
[16:03:42.369]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:42.369]         }
[16:03:42.369]         else {
[16:03:42.369]             ...future.result["stdout"] <- base::list(NULL)
[16:03:42.369]         }
[16:03:42.369]         base::close(...future.stdout)
[16:03:42.369]         ...future.stdout <- NULL
[16:03:42.369]     }
[16:03:42.369]     ...future.result$conditions <- ...future.conditions
[16:03:42.369]     ...future.result$finished <- base::Sys.time()
[16:03:42.369]     ...future.result
[16:03:42.369] }
[16:03:42.371] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[16:03:42.371] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[16:03:42.372] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[16:03:42.372] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:03:42.372] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:03:42.372] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[16:03:42.373] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[16:03:42.373] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:03:42.373] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:03:42.373] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:03:42.373] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:03:42.374] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[16:03:42.374] MultisessionFuture started
[16:03:42.374] - Launch lazy future ... done
[16:03:42.374] run() for ‘MultisessionFuture’ ... done
[16:03:42.374] Created future:
[16:03:42.374] MultisessionFuture:
[16:03:42.374] Label: ‘future_lapply-2’
[16:03:42.374] Expression:
[16:03:42.374] {
[16:03:42.374]     do.call(function(...) {
[16:03:42.374]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:42.374]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:42.374]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:42.374]             on.exit(options(oopts), add = TRUE)
[16:03:42.374]         }
[16:03:42.374]         {
[16:03:42.374]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:03:42.374]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:03:42.374]                 ...future.FUN(...future.X_jj, ...)
[16:03:42.374]             })
[16:03:42.374]         }
[16:03:42.374]     }, args = future.call.arguments)
[16:03:42.374] }
[16:03:42.374] Lazy evaluation: FALSE
[16:03:42.374] Asynchronous evaluation: TRUE
[16:03:42.374] Local evaluation: TRUE
[16:03:42.374] Environment: R_GlobalEnv
[16:03:42.374] Capture standard output: NA
[16:03:42.374] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:42.374] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:42.374] Packages: <none>
[16:03:42.374] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:42.374] Resolved: FALSE
[16:03:42.374] Value: <not collected>
[16:03:42.374] Conditions captured: <none>
[16:03:42.374] Early signaling: FALSE
[16:03:42.374] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:42.374] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:42.386] Chunk #2 of 2 ... DONE
[16:03:42.386] Launching 2 futures (chunks) ... DONE
[16:03:42.386] Resolving 2 futures (chunks) ...
[16:03:42.386] resolve() on list ...
[16:03:42.386]  recursive: 0
[16:03:42.387]  length: 2
[16:03:42.387] 
[16:03:42.429] receiveMessageFromWorker() for ClusterFuture ...
[16:03:42.429] - Validating connection of MultisessionFuture
[16:03:42.429] - received message: FutureResult
[16:03:42.429] - Received FutureResult
[16:03:42.429] - Erased future from FutureRegistry
[16:03:42.429] result() for ClusterFuture ...
[16:03:42.429] - result already collected: FutureResult
[16:03:42.429] result() for ClusterFuture ... done
[16:03:42.430] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:42.430] Future #2
[16:03:42.430] result() for ClusterFuture ...
[16:03:42.430] - result already collected: FutureResult
[16:03:42.430] result() for ClusterFuture ... done
[16:03:42.430] result() for ClusterFuture ...
[16:03:42.430] - result already collected: FutureResult
[16:03:42.430] result() for ClusterFuture ... done
[16:03:42.430] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:03:42.430] - nx: 2
[16:03:42.430] - relay: TRUE
[16:03:42.430] - stdout: TRUE
[16:03:42.431] - signal: TRUE
[16:03:42.431] - resignal: FALSE
[16:03:42.431] - force: TRUE
[16:03:42.431] - relayed: [n=2] FALSE, FALSE
[16:03:42.431] - queued futures: [n=2] FALSE, FALSE
[16:03:42.431]  - until=1
[16:03:42.431]  - relaying element #1
[16:03:42.431] - relayed: [n=2] FALSE, FALSE
[16:03:42.431] - queued futures: [n=2] FALSE, TRUE
[16:03:42.431] signalConditionsASAP(NULL, pos=2) ... done
[16:03:42.432]  length: 1 (resolved future 2)
[16:03:42.884] receiveMessageFromWorker() for ClusterFuture ...
[16:03:42.884] - Validating connection of MultisessionFuture
[16:03:42.885] - received message: FutureResult
[16:03:42.885] - Received FutureResult
[16:03:42.885] - Erased future from FutureRegistry
[16:03:42.885] result() for ClusterFuture ...
[16:03:42.885] - result already collected: FutureResult
[16:03:42.885] result() for ClusterFuture ... done
[16:03:42.885] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:42.885] Future #1
[16:03:42.885] result() for ClusterFuture ...
[16:03:42.885] - result already collected: FutureResult
[16:03:42.886] result() for ClusterFuture ... done
[16:03:42.886] result() for ClusterFuture ...
[16:03:42.886] - result already collected: FutureResult
[16:03:42.886] result() for ClusterFuture ... done
[16:03:42.886] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:03:42.886] - nx: 2
[16:03:42.886] - relay: TRUE
[16:03:42.886] - stdout: TRUE
[16:03:42.886] - signal: TRUE
[16:03:42.886] - resignal: FALSE
[16:03:42.886] - force: TRUE
[16:03:42.887] - relayed: [n=2] FALSE, FALSE
[16:03:42.887] - queued futures: [n=2] FALSE, TRUE
[16:03:42.887]  - until=1
[16:03:42.887]  - relaying element #1
[16:03:42.887] result() for ClusterFuture ...
[16:03:42.887] - result already collected: FutureResult
[16:03:42.887] result() for ClusterFuture ... done
[16:03:42.887] result() for ClusterFuture ...
[16:03:42.887] - result already collected: FutureResult
[16:03:42.887] result() for ClusterFuture ... done
[16:03:42.887] result() for ClusterFuture ...
[16:03:42.888] - result already collected: FutureResult
[16:03:42.888] result() for ClusterFuture ... done
[16:03:42.888] result() for ClusterFuture ...
[16:03:42.888] - result already collected: FutureResult
[16:03:42.888] result() for ClusterFuture ... done
[16:03:42.888] - relayed: [n=2] TRUE, FALSE
[16:03:42.888] - queued futures: [n=2] TRUE, TRUE
[16:03:42.888] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:03:42.888]  length: 0 (resolved future 1)
[16:03:42.888] Relaying remaining futures
[16:03:42.888] signalConditionsASAP(NULL, pos=0) ...
[16:03:42.888] - nx: 2
[16:03:42.889] - relay: TRUE
[16:03:42.889] - stdout: TRUE
[16:03:42.889] - signal: TRUE
[16:03:42.889] - resignal: FALSE
[16:03:42.889] - force: TRUE
[16:03:42.889] - relayed: [n=2] TRUE, FALSE
[16:03:42.889] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:42.889]  - relaying element #2
[16:03:42.889] result() for ClusterFuture ...
[16:03:42.889] - result already collected: FutureResult
[16:03:42.889] result() for ClusterFuture ... done
[16:03:42.890] result() for ClusterFuture ...
[16:03:42.890] - result already collected: FutureResult
[16:03:42.890] result() for ClusterFuture ... done
[16:03:42.890] result() for ClusterFuture ...
[16:03:42.890] - result already collected: FutureResult
[16:03:42.890] result() for ClusterFuture ... done
[16:03:42.890] result() for ClusterFuture ...
[16:03:42.890] - result already collected: FutureResult
[16:03:42.890] result() for ClusterFuture ... done
[16:03:42.890] - relayed: [n=2] TRUE, TRUE
[16:03:42.890] - queued futures: [n=2] TRUE, TRUE
[16:03:42.890] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[16:03:42.891] resolve() on list ... DONE
[16:03:42.891] result() for ClusterFuture ...
[16:03:42.891] - result already collected: FutureResult
[16:03:42.891] result() for ClusterFuture ... done
[16:03:42.891] result() for ClusterFuture ...
[16:03:42.891] - result already collected: FutureResult
[16:03:42.891] result() for ClusterFuture ... done
[16:03:42.891] result() for ClusterFuture ...
[16:03:42.891] - result already collected: FutureResult
[16:03:42.891] result() for ClusterFuture ... done
[16:03:42.892] result() for ClusterFuture ...
[16:03:42.892] - result already collected: FutureResult
[16:03:42.892] result() for ClusterFuture ... done
[16:03:42.892]  - Number of value chunks collected: 2
[16:03:42.892] Resolving 2 futures (chunks) ... DONE
[16:03:42.892] Reducing values from 2 chunks ...
[16:03:42.892]  - Number of values collected after concatenation: 2
[16:03:42.892]  - Number of values expected: 2
[16:03:42.892] Reducing values from 2 chunks ... DONE
[16:03:42.892] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[16:03:42.893] future_mapply() ...
[16:03:42.896] Number of chunks: 2
[16:03:42.896] getGlobalsAndPackagesXApply() ...
[16:03:42.896]  - future.globals: TRUE
[16:03:42.897] getGlobalsAndPackages() ...
[16:03:42.897] Searching for globals...
[16:03:42.898] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:03:42.898] Searching for globals ... DONE
[16:03:42.898] Resolving globals: FALSE
[16:03:42.899] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:03:42.899] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:03:42.899] - globals: [1] ‘FUN’
[16:03:42.899] 
[16:03:42.899] getGlobalsAndPackages() ... DONE
[16:03:42.900]  - globals found/used: [n=1] ‘FUN’
[16:03:42.900]  - needed namespaces: [n=0] 
[16:03:42.900] Finding globals ... DONE
[16:03:42.900] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:03:42.900] List of 2
[16:03:42.900]  $ ...future.FUN:function (x, y)  
[16:03:42.900]  $ MoreArgs     : NULL
[16:03:42.900]  - attr(*, "where")=List of 2
[16:03:42.900]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:42.900]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:03:42.900]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:42.900]  - attr(*, "resolved")= logi FALSE
[16:03:42.900]  - attr(*, "total_size")= num NA
[16:03:42.902] Packages to be attached in all futures: [n=0] 
[16:03:42.903] getGlobalsAndPackagesXApply() ... DONE
[16:03:42.903] Number of futures (= number of chunks): 2
[16:03:42.903] Launching 2 futures (chunks) ...
[16:03:42.903] Chunk #1 of 2 ...
[16:03:42.903]  - Finding globals in '...' for chunk #1 ...
[16:03:42.903] getGlobalsAndPackages() ...
[16:03:42.903] Searching for globals...
[16:03:42.904] 
[16:03:42.904] Searching for globals ... DONE
[16:03:42.904] - globals: [0] <none>
[16:03:42.906] getGlobalsAndPackages() ... DONE
[16:03:42.906]    + additional globals found: [n=0] 
[16:03:42.906]    + additional namespaces needed: [n=0] 
[16:03:42.906]  - Finding globals in '...' for chunk #1 ... DONE
[16:03:42.906]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:42.906]  - seeds: <none>
[16:03:42.906]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:42.906] getGlobalsAndPackages() ...
[16:03:42.906] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:42.906] Resolving globals: FALSE
[16:03:42.907] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:03:42.907] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:03:42.907] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:42.908] 
[16:03:42.908] getGlobalsAndPackages() ... DONE
[16:03:42.908] run() for ‘Future’ ...
[16:03:42.908] - state: ‘created’
[16:03:42.908] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:42.921] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:42.922] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:42.922]   - Field: ‘node’
[16:03:42.922]   - Field: ‘label’
[16:03:42.922]   - Field: ‘local’
[16:03:42.922]   - Field: ‘owner’
[16:03:42.922]   - Field: ‘envir’
[16:03:42.922]   - Field: ‘workers’
[16:03:42.922]   - Field: ‘packages’
[16:03:42.922]   - Field: ‘gc’
[16:03:42.922]   - Field: ‘conditions’
[16:03:42.923]   - Field: ‘persistent’
[16:03:42.923]   - Field: ‘expr’
[16:03:42.923]   - Field: ‘uuid’
[16:03:42.923]   - Field: ‘seed’
[16:03:42.923]   - Field: ‘version’
[16:03:42.923]   - Field: ‘result’
[16:03:42.923]   - Field: ‘asynchronous’
[16:03:42.923]   - Field: ‘calls’
[16:03:42.923]   - Field: ‘globals’
[16:03:42.923]   - Field: ‘stdout’
[16:03:42.923]   - Field: ‘earlySignal’
[16:03:42.924]   - Field: ‘lazy’
[16:03:42.924]   - Field: ‘state’
[16:03:42.924] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:42.924] - Launch lazy future ...
[16:03:42.924] Packages needed by the future expression (n = 0): <none>
[16:03:42.924] Packages needed by future strategies (n = 0): <none>
[16:03:42.925] {
[16:03:42.925]     {
[16:03:42.925]         {
[16:03:42.925]             ...future.startTime <- base::Sys.time()
[16:03:42.925]             {
[16:03:42.925]                 {
[16:03:42.925]                   {
[16:03:42.925]                     {
[16:03:42.925]                       base::local({
[16:03:42.925]                         has_future <- base::requireNamespace("future", 
[16:03:42.925]                           quietly = TRUE)
[16:03:42.925]                         if (has_future) {
[16:03:42.925]                           ns <- base::getNamespace("future")
[16:03:42.925]                           version <- ns[[".package"]][["version"]]
[16:03:42.925]                           if (is.null(version)) 
[16:03:42.925]                             version <- utils::packageVersion("future")
[16:03:42.925]                         }
[16:03:42.925]                         else {
[16:03:42.925]                           version <- NULL
[16:03:42.925]                         }
[16:03:42.925]                         if (!has_future || version < "1.8.0") {
[16:03:42.925]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:42.925]                             "", base::R.version$version.string), 
[16:03:42.925]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:42.925]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:42.925]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:42.925]                               "release", "version")], collapse = " "), 
[16:03:42.925]                             hostname = base::Sys.info()[["nodename"]])
[16:03:42.925]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:42.925]                             info)
[16:03:42.925]                           info <- base::paste(info, collapse = "; ")
[16:03:42.925]                           if (!has_future) {
[16:03:42.925]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:42.925]                               info)
[16:03:42.925]                           }
[16:03:42.925]                           else {
[16:03:42.925]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:42.925]                               info, version)
[16:03:42.925]                           }
[16:03:42.925]                           base::stop(msg)
[16:03:42.925]                         }
[16:03:42.925]                       })
[16:03:42.925]                     }
[16:03:42.925]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:42.925]                     base::options(mc.cores = 1L)
[16:03:42.925]                   }
[16:03:42.925]                   options(future.plan = NULL)
[16:03:42.925]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:42.925]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:42.925]                 }
[16:03:42.925]                 ...future.workdir <- getwd()
[16:03:42.925]             }
[16:03:42.925]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:42.925]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:42.925]         }
[16:03:42.925]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:42.925]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:42.925]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:42.925]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:42.925]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:42.925]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:42.925]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:42.925]             base::names(...future.oldOptions))
[16:03:42.925]     }
[16:03:42.925]     if (FALSE) {
[16:03:42.925]     }
[16:03:42.925]     else {
[16:03:42.925]         if (FALSE) {
[16:03:42.925]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:42.925]                 open = "w")
[16:03:42.925]         }
[16:03:42.925]         else {
[16:03:42.925]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:42.925]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:42.925]         }
[16:03:42.925]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:42.925]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:42.925]             base::sink(type = "output", split = FALSE)
[16:03:42.925]             base::close(...future.stdout)
[16:03:42.925]         }, add = TRUE)
[16:03:42.925]     }
[16:03:42.925]     ...future.frame <- base::sys.nframe()
[16:03:42.925]     ...future.conditions <- base::list()
[16:03:42.925]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:42.925]     if (FALSE) {
[16:03:42.925]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:42.925]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:42.925]     }
[16:03:42.925]     ...future.result <- base::tryCatch({
[16:03:42.925]         base::withCallingHandlers({
[16:03:42.925]             ...future.value <- base::withVisible(base::local({
[16:03:42.925]                 ...future.makeSendCondition <- base::local({
[16:03:42.925]                   sendCondition <- NULL
[16:03:42.925]                   function(frame = 1L) {
[16:03:42.925]                     if (is.function(sendCondition)) 
[16:03:42.925]                       return(sendCondition)
[16:03:42.925]                     ns <- getNamespace("parallel")
[16:03:42.925]                     if (exists("sendData", mode = "function", 
[16:03:42.925]                       envir = ns)) {
[16:03:42.925]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:42.925]                         envir = ns)
[16:03:42.925]                       envir <- sys.frame(frame)
[16:03:42.925]                       master <- NULL
[16:03:42.925]                       while (!identical(envir, .GlobalEnv) && 
[16:03:42.925]                         !identical(envir, emptyenv())) {
[16:03:42.925]                         if (exists("master", mode = "list", envir = envir, 
[16:03:42.925]                           inherits = FALSE)) {
[16:03:42.925]                           master <- get("master", mode = "list", 
[16:03:42.925]                             envir = envir, inherits = FALSE)
[16:03:42.925]                           if (inherits(master, c("SOCKnode", 
[16:03:42.925]                             "SOCK0node"))) {
[16:03:42.925]                             sendCondition <<- function(cond) {
[16:03:42.925]                               data <- list(type = "VALUE", value = cond, 
[16:03:42.925]                                 success = TRUE)
[16:03:42.925]                               parallel_sendData(master, data)
[16:03:42.925]                             }
[16:03:42.925]                             return(sendCondition)
[16:03:42.925]                           }
[16:03:42.925]                         }
[16:03:42.925]                         frame <- frame + 1L
[16:03:42.925]                         envir <- sys.frame(frame)
[16:03:42.925]                       }
[16:03:42.925]                     }
[16:03:42.925]                     sendCondition <<- function(cond) NULL
[16:03:42.925]                   }
[16:03:42.925]                 })
[16:03:42.925]                 withCallingHandlers({
[16:03:42.925]                   {
[16:03:42.925]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:42.925]                     if (!identical(...future.globals.maxSize.org, 
[16:03:42.925]                       ...future.globals.maxSize)) {
[16:03:42.925]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:42.925]                       on.exit(options(oopts), add = TRUE)
[16:03:42.925]                     }
[16:03:42.925]                     {
[16:03:42.925]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:42.925]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:03:42.925]                         USE.NAMES = FALSE)
[16:03:42.925]                       do.call(mapply, args = args)
[16:03:42.925]                     }
[16:03:42.925]                   }
[16:03:42.925]                 }, immediateCondition = function(cond) {
[16:03:42.925]                   sendCondition <- ...future.makeSendCondition()
[16:03:42.925]                   sendCondition(cond)
[16:03:42.925]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:42.925]                   {
[16:03:42.925]                     inherits <- base::inherits
[16:03:42.925]                     invokeRestart <- base::invokeRestart
[16:03:42.925]                     is.null <- base::is.null
[16:03:42.925]                     muffled <- FALSE
[16:03:42.925]                     if (inherits(cond, "message")) {
[16:03:42.925]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:42.925]                       if (muffled) 
[16:03:42.925]                         invokeRestart("muffleMessage")
[16:03:42.925]                     }
[16:03:42.925]                     else if (inherits(cond, "warning")) {
[16:03:42.925]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:42.925]                       if (muffled) 
[16:03:42.925]                         invokeRestart("muffleWarning")
[16:03:42.925]                     }
[16:03:42.925]                     else if (inherits(cond, "condition")) {
[16:03:42.925]                       if (!is.null(pattern)) {
[16:03:42.925]                         computeRestarts <- base::computeRestarts
[16:03:42.925]                         grepl <- base::grepl
[16:03:42.925]                         restarts <- computeRestarts(cond)
[16:03:42.925]                         for (restart in restarts) {
[16:03:42.925]                           name <- restart$name
[16:03:42.925]                           if (is.null(name)) 
[16:03:42.925]                             next
[16:03:42.925]                           if (!grepl(pattern, name)) 
[16:03:42.925]                             next
[16:03:42.925]                           invokeRestart(restart)
[16:03:42.925]                           muffled <- TRUE
[16:03:42.925]                           break
[16:03:42.925]                         }
[16:03:42.925]                       }
[16:03:42.925]                     }
[16:03:42.925]                     invisible(muffled)
[16:03:42.925]                   }
[16:03:42.925]                   muffleCondition(cond)
[16:03:42.925]                 })
[16:03:42.925]             }))
[16:03:42.925]             future::FutureResult(value = ...future.value$value, 
[16:03:42.925]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:42.925]                   ...future.rng), globalenv = if (FALSE) 
[16:03:42.925]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:42.925]                     ...future.globalenv.names))
[16:03:42.925]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:42.925]         }, condition = base::local({
[16:03:42.925]             c <- base::c
[16:03:42.925]             inherits <- base::inherits
[16:03:42.925]             invokeRestart <- base::invokeRestart
[16:03:42.925]             length <- base::length
[16:03:42.925]             list <- base::list
[16:03:42.925]             seq.int <- base::seq.int
[16:03:42.925]             signalCondition <- base::signalCondition
[16:03:42.925]             sys.calls <- base::sys.calls
[16:03:42.925]             `[[` <- base::`[[`
[16:03:42.925]             `+` <- base::`+`
[16:03:42.925]             `<<-` <- base::`<<-`
[16:03:42.925]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:42.925]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:42.925]                   3L)]
[16:03:42.925]             }
[16:03:42.925]             function(cond) {
[16:03:42.925]                 is_error <- inherits(cond, "error")
[16:03:42.925]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:42.925]                   NULL)
[16:03:42.925]                 if (is_error) {
[16:03:42.925]                   sessionInformation <- function() {
[16:03:42.925]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:42.925]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:42.925]                       search = base::search(), system = base::Sys.info())
[16:03:42.925]                   }
[16:03:42.925]                   ...future.conditions[[length(...future.conditions) + 
[16:03:42.925]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:42.925]                     cond$call), session = sessionInformation(), 
[16:03:42.925]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:42.925]                   signalCondition(cond)
[16:03:42.925]                 }
[16:03:42.925]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:42.925]                 "immediateCondition"))) {
[16:03:42.925]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:42.925]                   ...future.conditions[[length(...future.conditions) + 
[16:03:42.925]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:42.925]                   if (TRUE && !signal) {
[16:03:42.925]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:42.925]                     {
[16:03:42.925]                       inherits <- base::inherits
[16:03:42.925]                       invokeRestart <- base::invokeRestart
[16:03:42.925]                       is.null <- base::is.null
[16:03:42.925]                       muffled <- FALSE
[16:03:42.925]                       if (inherits(cond, "message")) {
[16:03:42.925]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:42.925]                         if (muffled) 
[16:03:42.925]                           invokeRestart("muffleMessage")
[16:03:42.925]                       }
[16:03:42.925]                       else if (inherits(cond, "warning")) {
[16:03:42.925]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:42.925]                         if (muffled) 
[16:03:42.925]                           invokeRestart("muffleWarning")
[16:03:42.925]                       }
[16:03:42.925]                       else if (inherits(cond, "condition")) {
[16:03:42.925]                         if (!is.null(pattern)) {
[16:03:42.925]                           computeRestarts <- base::computeRestarts
[16:03:42.925]                           grepl <- base::grepl
[16:03:42.925]                           restarts <- computeRestarts(cond)
[16:03:42.925]                           for (restart in restarts) {
[16:03:42.925]                             name <- restart$name
[16:03:42.925]                             if (is.null(name)) 
[16:03:42.925]                               next
[16:03:42.925]                             if (!grepl(pattern, name)) 
[16:03:42.925]                               next
[16:03:42.925]                             invokeRestart(restart)
[16:03:42.925]                             muffled <- TRUE
[16:03:42.925]                             break
[16:03:42.925]                           }
[16:03:42.925]                         }
[16:03:42.925]                       }
[16:03:42.925]                       invisible(muffled)
[16:03:42.925]                     }
[16:03:42.925]                     muffleCondition(cond, pattern = "^muffle")
[16:03:42.925]                   }
[16:03:42.925]                 }
[16:03:42.925]                 else {
[16:03:42.925]                   if (TRUE) {
[16:03:42.925]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:42.925]                     {
[16:03:42.925]                       inherits <- base::inherits
[16:03:42.925]                       invokeRestart <- base::invokeRestart
[16:03:42.925]                       is.null <- base::is.null
[16:03:42.925]                       muffled <- FALSE
[16:03:42.925]                       if (inherits(cond, "message")) {
[16:03:42.925]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:42.925]                         if (muffled) 
[16:03:42.925]                           invokeRestart("muffleMessage")
[16:03:42.925]                       }
[16:03:42.925]                       else if (inherits(cond, "warning")) {
[16:03:42.925]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:42.925]                         if (muffled) 
[16:03:42.925]                           invokeRestart("muffleWarning")
[16:03:42.925]                       }
[16:03:42.925]                       else if (inherits(cond, "condition")) {
[16:03:42.925]                         if (!is.null(pattern)) {
[16:03:42.925]                           computeRestarts <- base::computeRestarts
[16:03:42.925]                           grepl <- base::grepl
[16:03:42.925]                           restarts <- computeRestarts(cond)
[16:03:42.925]                           for (restart in restarts) {
[16:03:42.925]                             name <- restart$name
[16:03:42.925]                             if (is.null(name)) 
[16:03:42.925]                               next
[16:03:42.925]                             if (!grepl(pattern, name)) 
[16:03:42.925]                               next
[16:03:42.925]                             invokeRestart(restart)
[16:03:42.925]                             muffled <- TRUE
[16:03:42.925]                             break
[16:03:42.925]                           }
[16:03:42.925]                         }
[16:03:42.925]                       }
[16:03:42.925]                       invisible(muffled)
[16:03:42.925]                     }
[16:03:42.925]                     muffleCondition(cond, pattern = "^muffle")
[16:03:42.925]                   }
[16:03:42.925]                 }
[16:03:42.925]             }
[16:03:42.925]         }))
[16:03:42.925]     }, error = function(ex) {
[16:03:42.925]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:42.925]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:42.925]                 ...future.rng), started = ...future.startTime, 
[16:03:42.925]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:42.925]             version = "1.8"), class = "FutureResult")
[16:03:42.925]     }, finally = {
[16:03:42.925]         if (!identical(...future.workdir, getwd())) 
[16:03:42.925]             setwd(...future.workdir)
[16:03:42.925]         {
[16:03:42.925]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:42.925]                 ...future.oldOptions$nwarnings <- NULL
[16:03:42.925]             }
[16:03:42.925]             base::options(...future.oldOptions)
[16:03:42.925]             if (.Platform$OS.type == "windows") {
[16:03:42.925]                 old_names <- names(...future.oldEnvVars)
[16:03:42.925]                 envs <- base::Sys.getenv()
[16:03:42.925]                 names <- names(envs)
[16:03:42.925]                 common <- intersect(names, old_names)
[16:03:42.925]                 added <- setdiff(names, old_names)
[16:03:42.925]                 removed <- setdiff(old_names, names)
[16:03:42.925]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:42.925]                   envs[common]]
[16:03:42.925]                 NAMES <- toupper(changed)
[16:03:42.925]                 args <- list()
[16:03:42.925]                 for (kk in seq_along(NAMES)) {
[16:03:42.925]                   name <- changed[[kk]]
[16:03:42.925]                   NAME <- NAMES[[kk]]
[16:03:42.925]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:42.925]                     next
[16:03:42.925]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:42.925]                 }
[16:03:42.925]                 NAMES <- toupper(added)
[16:03:42.925]                 for (kk in seq_along(NAMES)) {
[16:03:42.925]                   name <- added[[kk]]
[16:03:42.925]                   NAME <- NAMES[[kk]]
[16:03:42.925]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:42.925]                     next
[16:03:42.925]                   args[[name]] <- ""
[16:03:42.925]                 }
[16:03:42.925]                 NAMES <- toupper(removed)
[16:03:42.925]                 for (kk in seq_along(NAMES)) {
[16:03:42.925]                   name <- removed[[kk]]
[16:03:42.925]                   NAME <- NAMES[[kk]]
[16:03:42.925]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:42.925]                     next
[16:03:42.925]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:42.925]                 }
[16:03:42.925]                 if (length(args) > 0) 
[16:03:42.925]                   base::do.call(base::Sys.setenv, args = args)
[16:03:42.925]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:42.925]             }
[16:03:42.925]             else {
[16:03:42.925]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:42.925]             }
[16:03:42.925]             {
[16:03:42.925]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:42.925]                   0L) {
[16:03:42.925]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:42.925]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:42.925]                   base::options(opts)
[16:03:42.925]                 }
[16:03:42.925]                 {
[16:03:42.925]                   {
[16:03:42.925]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:42.925]                     NULL
[16:03:42.925]                   }
[16:03:42.925]                   options(future.plan = NULL)
[16:03:42.925]                   if (is.na(NA_character_)) 
[16:03:42.925]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:42.925]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:42.925]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:42.925]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:42.925]                     envir = parent.frame()) 
[16:03:42.925]                   {
[16:03:42.925]                     if (is.function(workers)) 
[16:03:42.925]                       workers <- workers()
[16:03:42.925]                     workers <- structure(as.integer(workers), 
[16:03:42.925]                       class = class(workers))
[16:03:42.925]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:42.925]                       workers >= 1)
[16:03:42.925]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:42.925]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:42.925]                     }
[16:03:42.925]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:42.925]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:42.925]                       envir = envir)
[16:03:42.925]                     if (!future$lazy) 
[16:03:42.925]                       future <- run(future)
[16:03:42.925]                     invisible(future)
[16:03:42.925]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:42.925]                 }
[16:03:42.925]             }
[16:03:42.925]         }
[16:03:42.925]     })
[16:03:42.925]     if (TRUE) {
[16:03:42.925]         base::sink(type = "output", split = FALSE)
[16:03:42.925]         if (FALSE) {
[16:03:42.925]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:42.925]         }
[16:03:42.925]         else {
[16:03:42.925]             ...future.result["stdout"] <- base::list(NULL)
[16:03:42.925]         }
[16:03:42.925]         base::close(...future.stdout)
[16:03:42.925]         ...future.stdout <- NULL
[16:03:42.925]     }
[16:03:42.925]     ...future.result$conditions <- ...future.conditions
[16:03:42.925]     ...future.result$finished <- base::Sys.time()
[16:03:42.925]     ...future.result
[16:03:42.925] }
[16:03:42.927] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[16:03:42.927] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[16:03:42.928] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[16:03:42.928] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[16:03:42.928] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[16:03:42.928] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[16:03:42.929] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[16:03:42.929] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:03:42.929] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:03:42.929] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:03:42.930] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:03:42.930] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[16:03:42.930] MultisessionFuture started
[16:03:42.931] - Launch lazy future ... done
[16:03:42.931] run() for ‘MultisessionFuture’ ... done
[16:03:42.931] Created future:
[16:03:42.931] MultisessionFuture:
[16:03:42.931] Label: ‘future_mapply-1’
[16:03:42.931] Expression:
[16:03:42.931] {
[16:03:42.931]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:42.931]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:42.931]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:42.931]         on.exit(options(oopts), add = TRUE)
[16:03:42.931]     }
[16:03:42.931]     {
[16:03:42.931]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:42.931]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:03:42.931]         do.call(mapply, args = args)
[16:03:42.931]     }
[16:03:42.931] }
[16:03:42.931] Lazy evaluation: FALSE
[16:03:42.931] Asynchronous evaluation: TRUE
[16:03:42.931] Local evaluation: TRUE
[16:03:42.931] Environment: R_GlobalEnv
[16:03:42.931] Capture standard output: FALSE
[16:03:42.931] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:42.931] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:42.931] Packages: <none>
[16:03:42.931] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:42.931] Resolved: FALSE
[16:03:42.931] Value: <not collected>
[16:03:42.931] Conditions captured: <none>
[16:03:42.931] Early signaling: FALSE
[16:03:42.931] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:42.931] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:42.942] Chunk #1 of 2 ... DONE
[16:03:42.943] Chunk #2 of 2 ...
[16:03:42.943]  - Finding globals in '...' for chunk #2 ...
[16:03:42.943] getGlobalsAndPackages() ...
[16:03:42.943] Searching for globals...
[16:03:42.943] 
[16:03:42.943] Searching for globals ... DONE
[16:03:42.943] - globals: [0] <none>
[16:03:42.943] getGlobalsAndPackages() ... DONE
[16:03:42.944]    + additional globals found: [n=0] 
[16:03:42.944]    + additional namespaces needed: [n=0] 
[16:03:42.944]  - Finding globals in '...' for chunk #2 ... DONE
[16:03:42.944]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:42.944]  - seeds: <none>
[16:03:42.944]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:42.944] getGlobalsAndPackages() ...
[16:03:42.944] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:42.944] Resolving globals: FALSE
[16:03:42.945] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:03:42.945] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:03:42.945] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:42.945] 
[16:03:42.946] getGlobalsAndPackages() ... DONE
[16:03:42.946] run() for ‘Future’ ...
[16:03:42.946] - state: ‘created’
[16:03:42.946] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:42.960] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:42.960] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:42.960]   - Field: ‘node’
[16:03:42.960]   - Field: ‘label’
[16:03:42.961]   - Field: ‘local’
[16:03:42.961]   - Field: ‘owner’
[16:03:42.961]   - Field: ‘envir’
[16:03:42.961]   - Field: ‘workers’
[16:03:42.961]   - Field: ‘packages’
[16:03:42.961]   - Field: ‘gc’
[16:03:42.961]   - Field: ‘conditions’
[16:03:42.961]   - Field: ‘persistent’
[16:03:42.961]   - Field: ‘expr’
[16:03:42.961]   - Field: ‘uuid’
[16:03:42.961]   - Field: ‘seed’
[16:03:42.962]   - Field: ‘version’
[16:03:42.962]   - Field: ‘result’
[16:03:42.962]   - Field: ‘asynchronous’
[16:03:42.962]   - Field: ‘calls’
[16:03:42.962]   - Field: ‘globals’
[16:03:42.962]   - Field: ‘stdout’
[16:03:42.962]   - Field: ‘earlySignal’
[16:03:42.962]   - Field: ‘lazy’
[16:03:42.962]   - Field: ‘state’
[16:03:42.962] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:42.963] - Launch lazy future ...
[16:03:42.963] Packages needed by the future expression (n = 0): <none>
[16:03:42.963] Packages needed by future strategies (n = 0): <none>
[16:03:42.963] {
[16:03:42.963]     {
[16:03:42.963]         {
[16:03:42.963]             ...future.startTime <- base::Sys.time()
[16:03:42.963]             {
[16:03:42.963]                 {
[16:03:42.963]                   {
[16:03:42.963]                     {
[16:03:42.963]                       base::local({
[16:03:42.963]                         has_future <- base::requireNamespace("future", 
[16:03:42.963]                           quietly = TRUE)
[16:03:42.963]                         if (has_future) {
[16:03:42.963]                           ns <- base::getNamespace("future")
[16:03:42.963]                           version <- ns[[".package"]][["version"]]
[16:03:42.963]                           if (is.null(version)) 
[16:03:42.963]                             version <- utils::packageVersion("future")
[16:03:42.963]                         }
[16:03:42.963]                         else {
[16:03:42.963]                           version <- NULL
[16:03:42.963]                         }
[16:03:42.963]                         if (!has_future || version < "1.8.0") {
[16:03:42.963]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:42.963]                             "", base::R.version$version.string), 
[16:03:42.963]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:42.963]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:42.963]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:42.963]                               "release", "version")], collapse = " "), 
[16:03:42.963]                             hostname = base::Sys.info()[["nodename"]])
[16:03:42.963]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:42.963]                             info)
[16:03:42.963]                           info <- base::paste(info, collapse = "; ")
[16:03:42.963]                           if (!has_future) {
[16:03:42.963]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:42.963]                               info)
[16:03:42.963]                           }
[16:03:42.963]                           else {
[16:03:42.963]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:42.963]                               info, version)
[16:03:42.963]                           }
[16:03:42.963]                           base::stop(msg)
[16:03:42.963]                         }
[16:03:42.963]                       })
[16:03:42.963]                     }
[16:03:42.963]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:42.963]                     base::options(mc.cores = 1L)
[16:03:42.963]                   }
[16:03:42.963]                   options(future.plan = NULL)
[16:03:42.963]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:42.963]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:42.963]                 }
[16:03:42.963]                 ...future.workdir <- getwd()
[16:03:42.963]             }
[16:03:42.963]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:42.963]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:42.963]         }
[16:03:42.963]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:42.963]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:42.963]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:42.963]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:42.963]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:42.963]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:42.963]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:42.963]             base::names(...future.oldOptions))
[16:03:42.963]     }
[16:03:42.963]     if (FALSE) {
[16:03:42.963]     }
[16:03:42.963]     else {
[16:03:42.963]         if (FALSE) {
[16:03:42.963]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:42.963]                 open = "w")
[16:03:42.963]         }
[16:03:42.963]         else {
[16:03:42.963]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:42.963]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:42.963]         }
[16:03:42.963]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:42.963]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:42.963]             base::sink(type = "output", split = FALSE)
[16:03:42.963]             base::close(...future.stdout)
[16:03:42.963]         }, add = TRUE)
[16:03:42.963]     }
[16:03:42.963]     ...future.frame <- base::sys.nframe()
[16:03:42.963]     ...future.conditions <- base::list()
[16:03:42.963]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:42.963]     if (FALSE) {
[16:03:42.963]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:42.963]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:42.963]     }
[16:03:42.963]     ...future.result <- base::tryCatch({
[16:03:42.963]         base::withCallingHandlers({
[16:03:42.963]             ...future.value <- base::withVisible(base::local({
[16:03:42.963]                 ...future.makeSendCondition <- base::local({
[16:03:42.963]                   sendCondition <- NULL
[16:03:42.963]                   function(frame = 1L) {
[16:03:42.963]                     if (is.function(sendCondition)) 
[16:03:42.963]                       return(sendCondition)
[16:03:42.963]                     ns <- getNamespace("parallel")
[16:03:42.963]                     if (exists("sendData", mode = "function", 
[16:03:42.963]                       envir = ns)) {
[16:03:42.963]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:42.963]                         envir = ns)
[16:03:42.963]                       envir <- sys.frame(frame)
[16:03:42.963]                       master <- NULL
[16:03:42.963]                       while (!identical(envir, .GlobalEnv) && 
[16:03:42.963]                         !identical(envir, emptyenv())) {
[16:03:42.963]                         if (exists("master", mode = "list", envir = envir, 
[16:03:42.963]                           inherits = FALSE)) {
[16:03:42.963]                           master <- get("master", mode = "list", 
[16:03:42.963]                             envir = envir, inherits = FALSE)
[16:03:42.963]                           if (inherits(master, c("SOCKnode", 
[16:03:42.963]                             "SOCK0node"))) {
[16:03:42.963]                             sendCondition <<- function(cond) {
[16:03:42.963]                               data <- list(type = "VALUE", value = cond, 
[16:03:42.963]                                 success = TRUE)
[16:03:42.963]                               parallel_sendData(master, data)
[16:03:42.963]                             }
[16:03:42.963]                             return(sendCondition)
[16:03:42.963]                           }
[16:03:42.963]                         }
[16:03:42.963]                         frame <- frame + 1L
[16:03:42.963]                         envir <- sys.frame(frame)
[16:03:42.963]                       }
[16:03:42.963]                     }
[16:03:42.963]                     sendCondition <<- function(cond) NULL
[16:03:42.963]                   }
[16:03:42.963]                 })
[16:03:42.963]                 withCallingHandlers({
[16:03:42.963]                   {
[16:03:42.963]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:42.963]                     if (!identical(...future.globals.maxSize.org, 
[16:03:42.963]                       ...future.globals.maxSize)) {
[16:03:42.963]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:42.963]                       on.exit(options(oopts), add = TRUE)
[16:03:42.963]                     }
[16:03:42.963]                     {
[16:03:42.963]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:42.963]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:03:42.963]                         USE.NAMES = FALSE)
[16:03:42.963]                       do.call(mapply, args = args)
[16:03:42.963]                     }
[16:03:42.963]                   }
[16:03:42.963]                 }, immediateCondition = function(cond) {
[16:03:42.963]                   sendCondition <- ...future.makeSendCondition()
[16:03:42.963]                   sendCondition(cond)
[16:03:42.963]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:42.963]                   {
[16:03:42.963]                     inherits <- base::inherits
[16:03:42.963]                     invokeRestart <- base::invokeRestart
[16:03:42.963]                     is.null <- base::is.null
[16:03:42.963]                     muffled <- FALSE
[16:03:42.963]                     if (inherits(cond, "message")) {
[16:03:42.963]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:42.963]                       if (muffled) 
[16:03:42.963]                         invokeRestart("muffleMessage")
[16:03:42.963]                     }
[16:03:42.963]                     else if (inherits(cond, "warning")) {
[16:03:42.963]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:42.963]                       if (muffled) 
[16:03:42.963]                         invokeRestart("muffleWarning")
[16:03:42.963]                     }
[16:03:42.963]                     else if (inherits(cond, "condition")) {
[16:03:42.963]                       if (!is.null(pattern)) {
[16:03:42.963]                         computeRestarts <- base::computeRestarts
[16:03:42.963]                         grepl <- base::grepl
[16:03:42.963]                         restarts <- computeRestarts(cond)
[16:03:42.963]                         for (restart in restarts) {
[16:03:42.963]                           name <- restart$name
[16:03:42.963]                           if (is.null(name)) 
[16:03:42.963]                             next
[16:03:42.963]                           if (!grepl(pattern, name)) 
[16:03:42.963]                             next
[16:03:42.963]                           invokeRestart(restart)
[16:03:42.963]                           muffled <- TRUE
[16:03:42.963]                           break
[16:03:42.963]                         }
[16:03:42.963]                       }
[16:03:42.963]                     }
[16:03:42.963]                     invisible(muffled)
[16:03:42.963]                   }
[16:03:42.963]                   muffleCondition(cond)
[16:03:42.963]                 })
[16:03:42.963]             }))
[16:03:42.963]             future::FutureResult(value = ...future.value$value, 
[16:03:42.963]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:42.963]                   ...future.rng), globalenv = if (FALSE) 
[16:03:42.963]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:42.963]                     ...future.globalenv.names))
[16:03:42.963]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:42.963]         }, condition = base::local({
[16:03:42.963]             c <- base::c
[16:03:42.963]             inherits <- base::inherits
[16:03:42.963]             invokeRestart <- base::invokeRestart
[16:03:42.963]             length <- base::length
[16:03:42.963]             list <- base::list
[16:03:42.963]             seq.int <- base::seq.int
[16:03:42.963]             signalCondition <- base::signalCondition
[16:03:42.963]             sys.calls <- base::sys.calls
[16:03:42.963]             `[[` <- base::`[[`
[16:03:42.963]             `+` <- base::`+`
[16:03:42.963]             `<<-` <- base::`<<-`
[16:03:42.963]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:42.963]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:42.963]                   3L)]
[16:03:42.963]             }
[16:03:42.963]             function(cond) {
[16:03:42.963]                 is_error <- inherits(cond, "error")
[16:03:42.963]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:42.963]                   NULL)
[16:03:42.963]                 if (is_error) {
[16:03:42.963]                   sessionInformation <- function() {
[16:03:42.963]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:42.963]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:42.963]                       search = base::search(), system = base::Sys.info())
[16:03:42.963]                   }
[16:03:42.963]                   ...future.conditions[[length(...future.conditions) + 
[16:03:42.963]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:42.963]                     cond$call), session = sessionInformation(), 
[16:03:42.963]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:42.963]                   signalCondition(cond)
[16:03:42.963]                 }
[16:03:42.963]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:42.963]                 "immediateCondition"))) {
[16:03:42.963]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:42.963]                   ...future.conditions[[length(...future.conditions) + 
[16:03:42.963]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:42.963]                   if (TRUE && !signal) {
[16:03:42.963]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:42.963]                     {
[16:03:42.963]                       inherits <- base::inherits
[16:03:42.963]                       invokeRestart <- base::invokeRestart
[16:03:42.963]                       is.null <- base::is.null
[16:03:42.963]                       muffled <- FALSE
[16:03:42.963]                       if (inherits(cond, "message")) {
[16:03:42.963]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:42.963]                         if (muffled) 
[16:03:42.963]                           invokeRestart("muffleMessage")
[16:03:42.963]                       }
[16:03:42.963]                       else if (inherits(cond, "warning")) {
[16:03:42.963]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:42.963]                         if (muffled) 
[16:03:42.963]                           invokeRestart("muffleWarning")
[16:03:42.963]                       }
[16:03:42.963]                       else if (inherits(cond, "condition")) {
[16:03:42.963]                         if (!is.null(pattern)) {
[16:03:42.963]                           computeRestarts <- base::computeRestarts
[16:03:42.963]                           grepl <- base::grepl
[16:03:42.963]                           restarts <- computeRestarts(cond)
[16:03:42.963]                           for (restart in restarts) {
[16:03:42.963]                             name <- restart$name
[16:03:42.963]                             if (is.null(name)) 
[16:03:42.963]                               next
[16:03:42.963]                             if (!grepl(pattern, name)) 
[16:03:42.963]                               next
[16:03:42.963]                             invokeRestart(restart)
[16:03:42.963]                             muffled <- TRUE
[16:03:42.963]                             break
[16:03:42.963]                           }
[16:03:42.963]                         }
[16:03:42.963]                       }
[16:03:42.963]                       invisible(muffled)
[16:03:42.963]                     }
[16:03:42.963]                     muffleCondition(cond, pattern = "^muffle")
[16:03:42.963]                   }
[16:03:42.963]                 }
[16:03:42.963]                 else {
[16:03:42.963]                   if (TRUE) {
[16:03:42.963]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:42.963]                     {
[16:03:42.963]                       inherits <- base::inherits
[16:03:42.963]                       invokeRestart <- base::invokeRestart
[16:03:42.963]                       is.null <- base::is.null
[16:03:42.963]                       muffled <- FALSE
[16:03:42.963]                       if (inherits(cond, "message")) {
[16:03:42.963]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:42.963]                         if (muffled) 
[16:03:42.963]                           invokeRestart("muffleMessage")
[16:03:42.963]                       }
[16:03:42.963]                       else if (inherits(cond, "warning")) {
[16:03:42.963]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:42.963]                         if (muffled) 
[16:03:42.963]                           invokeRestart("muffleWarning")
[16:03:42.963]                       }
[16:03:42.963]                       else if (inherits(cond, "condition")) {
[16:03:42.963]                         if (!is.null(pattern)) {
[16:03:42.963]                           computeRestarts <- base::computeRestarts
[16:03:42.963]                           grepl <- base::grepl
[16:03:42.963]                           restarts <- computeRestarts(cond)
[16:03:42.963]                           for (restart in restarts) {
[16:03:42.963]                             name <- restart$name
[16:03:42.963]                             if (is.null(name)) 
[16:03:42.963]                               next
[16:03:42.963]                             if (!grepl(pattern, name)) 
[16:03:42.963]                               next
[16:03:42.963]                             invokeRestart(restart)
[16:03:42.963]                             muffled <- TRUE
[16:03:42.963]                             break
[16:03:42.963]                           }
[16:03:42.963]                         }
[16:03:42.963]                       }
[16:03:42.963]                       invisible(muffled)
[16:03:42.963]                     }
[16:03:42.963]                     muffleCondition(cond, pattern = "^muffle")
[16:03:42.963]                   }
[16:03:42.963]                 }
[16:03:42.963]             }
[16:03:42.963]         }))
[16:03:42.963]     }, error = function(ex) {
[16:03:42.963]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:42.963]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:42.963]                 ...future.rng), started = ...future.startTime, 
[16:03:42.963]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:42.963]             version = "1.8"), class = "FutureResult")
[16:03:42.963]     }, finally = {
[16:03:42.963]         if (!identical(...future.workdir, getwd())) 
[16:03:42.963]             setwd(...future.workdir)
[16:03:42.963]         {
[16:03:42.963]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:42.963]                 ...future.oldOptions$nwarnings <- NULL
[16:03:42.963]             }
[16:03:42.963]             base::options(...future.oldOptions)
[16:03:42.963]             if (.Platform$OS.type == "windows") {
[16:03:42.963]                 old_names <- names(...future.oldEnvVars)
[16:03:42.963]                 envs <- base::Sys.getenv()
[16:03:42.963]                 names <- names(envs)
[16:03:42.963]                 common <- intersect(names, old_names)
[16:03:42.963]                 added <- setdiff(names, old_names)
[16:03:42.963]                 removed <- setdiff(old_names, names)
[16:03:42.963]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:42.963]                   envs[common]]
[16:03:42.963]                 NAMES <- toupper(changed)
[16:03:42.963]                 args <- list()
[16:03:42.963]                 for (kk in seq_along(NAMES)) {
[16:03:42.963]                   name <- changed[[kk]]
[16:03:42.963]                   NAME <- NAMES[[kk]]
[16:03:42.963]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:42.963]                     next
[16:03:42.963]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:42.963]                 }
[16:03:42.963]                 NAMES <- toupper(added)
[16:03:42.963]                 for (kk in seq_along(NAMES)) {
[16:03:42.963]                   name <- added[[kk]]
[16:03:42.963]                   NAME <- NAMES[[kk]]
[16:03:42.963]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:42.963]                     next
[16:03:42.963]                   args[[name]] <- ""
[16:03:42.963]                 }
[16:03:42.963]                 NAMES <- toupper(removed)
[16:03:42.963]                 for (kk in seq_along(NAMES)) {
[16:03:42.963]                   name <- removed[[kk]]
[16:03:42.963]                   NAME <- NAMES[[kk]]
[16:03:42.963]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:42.963]                     next
[16:03:42.963]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:42.963]                 }
[16:03:42.963]                 if (length(args) > 0) 
[16:03:42.963]                   base::do.call(base::Sys.setenv, args = args)
[16:03:42.963]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:42.963]             }
[16:03:42.963]             else {
[16:03:42.963]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:42.963]             }
[16:03:42.963]             {
[16:03:42.963]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:42.963]                   0L) {
[16:03:42.963]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:42.963]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:42.963]                   base::options(opts)
[16:03:42.963]                 }
[16:03:42.963]                 {
[16:03:42.963]                   {
[16:03:42.963]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:42.963]                     NULL
[16:03:42.963]                   }
[16:03:42.963]                   options(future.plan = NULL)
[16:03:42.963]                   if (is.na(NA_character_)) 
[16:03:42.963]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:42.963]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:42.963]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:42.963]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:42.963]                     envir = parent.frame()) 
[16:03:42.963]                   {
[16:03:42.963]                     if (is.function(workers)) 
[16:03:42.963]                       workers <- workers()
[16:03:42.963]                     workers <- structure(as.integer(workers), 
[16:03:42.963]                       class = class(workers))
[16:03:42.963]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:42.963]                       workers >= 1)
[16:03:42.963]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:42.963]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:42.963]                     }
[16:03:42.963]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:42.963]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:42.963]                       envir = envir)
[16:03:42.963]                     if (!future$lazy) 
[16:03:42.963]                       future <- run(future)
[16:03:42.963]                     invisible(future)
[16:03:42.963]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:42.963]                 }
[16:03:42.963]             }
[16:03:42.963]         }
[16:03:42.963]     })
[16:03:42.963]     if (TRUE) {
[16:03:42.963]         base::sink(type = "output", split = FALSE)
[16:03:42.963]         if (FALSE) {
[16:03:42.963]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:42.963]         }
[16:03:42.963]         else {
[16:03:42.963]             ...future.result["stdout"] <- base::list(NULL)
[16:03:42.963]         }
[16:03:42.963]         base::close(...future.stdout)
[16:03:42.963]         ...future.stdout <- NULL
[16:03:42.963]     }
[16:03:42.963]     ...future.result$conditions <- ...future.conditions
[16:03:42.963]     ...future.result$finished <- base::Sys.time()
[16:03:42.963]     ...future.result
[16:03:42.963] }
[16:03:42.966] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[16:03:42.966] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[16:03:42.966] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[16:03:42.967] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[16:03:42.967] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[16:03:42.967] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[16:03:42.967] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[16:03:42.968] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:03:42.968] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:03:42.968] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:03:42.968] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:03:42.968] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[16:03:42.969] MultisessionFuture started
[16:03:42.969] - Launch lazy future ... done
[16:03:42.969] run() for ‘MultisessionFuture’ ... done
[16:03:42.969] Created future:
[16:03:42.969] MultisessionFuture:
[16:03:42.969] Label: ‘future_mapply-2’
[16:03:42.969] Expression:
[16:03:42.969] {
[16:03:42.969]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:42.969]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:42.969]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:42.969]         on.exit(options(oopts), add = TRUE)
[16:03:42.969]     }
[16:03:42.969]     {
[16:03:42.969]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:42.969]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:03:42.969]         do.call(mapply, args = args)
[16:03:42.969]     }
[16:03:42.969] }
[16:03:42.969] Lazy evaluation: FALSE
[16:03:42.969] Asynchronous evaluation: TRUE
[16:03:42.969] Local evaluation: TRUE
[16:03:42.969] Environment: R_GlobalEnv
[16:03:42.969] Capture standard output: FALSE
[16:03:42.969] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:42.969] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:42.969] Packages: <none>
[16:03:42.969] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:42.969] Resolved: FALSE
[16:03:42.969] Value: <not collected>
[16:03:42.969] Conditions captured: <none>
[16:03:42.969] Early signaling: FALSE
[16:03:42.969] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:42.969] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:42.981] Chunk #2 of 2 ... DONE
[16:03:42.981] Launching 2 futures (chunks) ... DONE
[16:03:42.981] Resolving 2 futures (chunks) ...
[16:03:42.981] resolve() on list ...
[16:03:42.981]  recursive: 0
[16:03:42.981]  length: 2
[16:03:42.981] 
[16:03:43.023] receiveMessageFromWorker() for ClusterFuture ...
[16:03:43.023] - Validating connection of MultisessionFuture
[16:03:43.023] - received message: FutureResult
[16:03:43.024] - Received FutureResult
[16:03:43.024] - Erased future from FutureRegistry
[16:03:43.024] result() for ClusterFuture ...
[16:03:43.024] - result already collected: FutureResult
[16:03:43.024] result() for ClusterFuture ... done
[16:03:43.024] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:43.024] Future #2
[16:03:43.024] result() for ClusterFuture ...
[16:03:43.024] - result already collected: FutureResult
[16:03:43.024] result() for ClusterFuture ... done
[16:03:43.024] result() for ClusterFuture ...
[16:03:43.025] - result already collected: FutureResult
[16:03:43.025] result() for ClusterFuture ... done
[16:03:43.025] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:03:43.025] - nx: 2
[16:03:43.025] - relay: TRUE
[16:03:43.025] - stdout: TRUE
[16:03:43.025] - signal: TRUE
[16:03:43.025] - resignal: FALSE
[16:03:43.025] - force: TRUE
[16:03:43.025] - relayed: [n=2] FALSE, FALSE
[16:03:43.025] - queued futures: [n=2] FALSE, FALSE
[16:03:43.026]  - until=1
[16:03:43.026]  - relaying element #1
[16:03:43.026] - relayed: [n=2] FALSE, FALSE
[16:03:43.026] - queued futures: [n=2] FALSE, TRUE
[16:03:43.026] signalConditionsASAP(NULL, pos=2) ... done
[16:03:43.026]  length: 1 (resolved future 2)
[16:03:43.476] receiveMessageFromWorker() for ClusterFuture ...
[16:03:43.477] - Validating connection of MultisessionFuture
[16:03:43.477] - received message: FutureResult
[16:03:43.477] - Received FutureResult
[16:03:43.477] - Erased future from FutureRegistry
[16:03:43.477] result() for ClusterFuture ...
[16:03:43.477] - result already collected: FutureResult
[16:03:43.477] result() for ClusterFuture ... done
[16:03:43.478] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:43.478] Future #1
[16:03:43.478] result() for ClusterFuture ...
[16:03:43.478] - result already collected: FutureResult
[16:03:43.478] result() for ClusterFuture ... done
[16:03:43.478] result() for ClusterFuture ...
[16:03:43.478] - result already collected: FutureResult
[16:03:43.478] result() for ClusterFuture ... done
[16:03:43.478] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:03:43.478] - nx: 2
[16:03:43.478] - relay: TRUE
[16:03:43.479] - stdout: TRUE
[16:03:43.479] - signal: TRUE
[16:03:43.479] - resignal: FALSE
[16:03:43.479] - force: TRUE
[16:03:43.479] - relayed: [n=2] FALSE, FALSE
[16:03:43.479] - queued futures: [n=2] FALSE, TRUE
[16:03:43.479]  - until=1
[16:03:43.479]  - relaying element #1
[16:03:43.479] result() for ClusterFuture ...
[16:03:43.479] - result already collected: FutureResult
[16:03:43.479] result() for ClusterFuture ... done
[16:03:43.480] result() for ClusterFuture ...
[16:03:43.480] - result already collected: FutureResult
[16:03:43.480] result() for ClusterFuture ... done
[16:03:43.480] result() for ClusterFuture ...
[16:03:43.480] - result already collected: FutureResult
[16:03:43.480] result() for ClusterFuture ... done
[16:03:43.480] result() for ClusterFuture ...
[16:03:43.480] - result already collected: FutureResult
[16:03:43.480] result() for ClusterFuture ... done
[16:03:43.480] - relayed: [n=2] TRUE, FALSE
[16:03:43.480] - queued futures: [n=2] TRUE, TRUE
[16:03:43.480] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:03:43.481]  length: 0 (resolved future 1)
[16:03:43.481] Relaying remaining futures
[16:03:43.481] signalConditionsASAP(NULL, pos=0) ...
[16:03:43.481] - nx: 2
[16:03:43.481] - relay: TRUE
[16:03:43.481] - stdout: TRUE
[16:03:43.481] - signal: TRUE
[16:03:43.481] - resignal: FALSE
[16:03:43.481] - force: TRUE
[16:03:43.481] - relayed: [n=2] TRUE, FALSE
[16:03:43.481] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:43.482]  - relaying element #2
[16:03:43.482] result() for ClusterFuture ...
[16:03:43.482] - result already collected: FutureResult
[16:03:43.482] result() for ClusterFuture ... done
[16:03:43.482] result() for ClusterFuture ...
[16:03:43.482] - result already collected: FutureResult
[16:03:43.482] result() for ClusterFuture ... done
[16:03:43.482] result() for ClusterFuture ...
[16:03:43.482] - result already collected: FutureResult
[16:03:43.482] result() for ClusterFuture ... done
[16:03:43.482] result() for ClusterFuture ...
[16:03:43.482] - result already collected: FutureResult
[16:03:43.483] result() for ClusterFuture ... done
[16:03:43.483] - relayed: [n=2] TRUE, TRUE
[16:03:43.483] - queued futures: [n=2] TRUE, TRUE
[16:03:43.483] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[16:03:43.483] resolve() on list ... DONE
[16:03:43.483] result() for ClusterFuture ...
[16:03:43.483] - result already collected: FutureResult
[16:03:43.483] result() for ClusterFuture ... done
[16:03:43.483] result() for ClusterFuture ...
[16:03:43.483] - result already collected: FutureResult
[16:03:43.483] result() for ClusterFuture ... done
[16:03:43.484] result() for ClusterFuture ...
[16:03:43.484] - result already collected: FutureResult
[16:03:43.484] result() for ClusterFuture ... done
[16:03:43.484] result() for ClusterFuture ...
[16:03:43.484] - result already collected: FutureResult
[16:03:43.484] result() for ClusterFuture ... done
[16:03:43.484]  - Number of value chunks collected: 2
[16:03:43.484] Resolving 2 futures (chunks) ... DONE
[16:03:43.484] Reducing values from 2 chunks ...
[16:03:43.484]  - Number of values collected after concatenation: 2
[16:03:43.484]  - Number of values expected: 2
[16:03:43.485] Reducing values from 2 chunks ... DONE
[16:03:43.485] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[16:03:43.485] future_mapply() ...
[16:03:43.489] Number of chunks: 2
[16:03:43.489] getGlobalsAndPackagesXApply() ...
[16:03:43.489]  - future.globals: TRUE
[16:03:43.489] getGlobalsAndPackages() ...
[16:03:43.489] Searching for globals...
[16:03:43.490] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:03:43.491] Searching for globals ... DONE
[16:03:43.491] Resolving globals: FALSE
[16:03:43.491] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:03:43.491] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:03:43.492] - globals: [1] ‘FUN’
[16:03:43.492] 
[16:03:43.492] getGlobalsAndPackages() ... DONE
[16:03:43.492]  - globals found/used: [n=1] ‘FUN’
[16:03:43.492]  - needed namespaces: [n=0] 
[16:03:43.492] Finding globals ... DONE
[16:03:43.492] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:03:43.492] List of 2
[16:03:43.492]  $ ...future.FUN:function (x, y)  
[16:03:43.492]  $ MoreArgs     : NULL
[16:03:43.492]  - attr(*, "where")=List of 2
[16:03:43.492]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:43.492]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:03:43.492]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:43.492]  - attr(*, "resolved")= logi FALSE
[16:03:43.492]  - attr(*, "total_size")= num NA
[16:03:43.495] Packages to be attached in all futures: [n=0] 
[16:03:43.495] getGlobalsAndPackagesXApply() ... DONE
[16:03:43.495] Number of futures (= number of chunks): 2
[16:03:43.495] Launching 2 futures (chunks) ...
[16:03:43.495] Chunk #1 of 2 ...
[16:03:43.495]  - Finding globals in '...' for chunk #1 ...
[16:03:43.495] getGlobalsAndPackages() ...
[16:03:43.496] Searching for globals...
[16:03:43.496] 
[16:03:43.496] Searching for globals ... DONE
[16:03:43.496] - globals: [0] <none>
[16:03:43.496] getGlobalsAndPackages() ... DONE
[16:03:43.496]    + additional globals found: [n=0] 
[16:03:43.496]    + additional namespaces needed: [n=0] 
[16:03:43.496]  - Finding globals in '...' for chunk #1 ... DONE
[16:03:43.496]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:43.497]  - seeds: <none>
[16:03:43.497]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:43.497] getGlobalsAndPackages() ...
[16:03:43.497] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:43.497] Resolving globals: FALSE
[16:03:43.497] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:03:43.498] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:03:43.498] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:43.498] 
[16:03:43.498] getGlobalsAndPackages() ... DONE
[16:03:43.498] run() for ‘Future’ ...
[16:03:43.499] - state: ‘created’
[16:03:43.499] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:43.512] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:43.512] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:43.512]   - Field: ‘node’
[16:03:43.513]   - Field: ‘label’
[16:03:43.513]   - Field: ‘local’
[16:03:43.513]   - Field: ‘owner’
[16:03:43.513]   - Field: ‘envir’
[16:03:43.513]   - Field: ‘workers’
[16:03:43.513]   - Field: ‘packages’
[16:03:43.513]   - Field: ‘gc’
[16:03:43.513]   - Field: ‘conditions’
[16:03:43.513]   - Field: ‘persistent’
[16:03:43.513]   - Field: ‘expr’
[16:03:43.514]   - Field: ‘uuid’
[16:03:43.514]   - Field: ‘seed’
[16:03:43.514]   - Field: ‘version’
[16:03:43.514]   - Field: ‘result’
[16:03:43.514]   - Field: ‘asynchronous’
[16:03:43.514]   - Field: ‘calls’
[16:03:43.514]   - Field: ‘globals’
[16:03:43.514]   - Field: ‘stdout’
[16:03:43.514]   - Field: ‘earlySignal’
[16:03:43.514]   - Field: ‘lazy’
[16:03:43.514]   - Field: ‘state’
[16:03:43.515] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:43.515] - Launch lazy future ...
[16:03:43.515] Packages needed by the future expression (n = 0): <none>
[16:03:43.515] Packages needed by future strategies (n = 0): <none>
[16:03:43.516] {
[16:03:43.516]     {
[16:03:43.516]         {
[16:03:43.516]             ...future.startTime <- base::Sys.time()
[16:03:43.516]             {
[16:03:43.516]                 {
[16:03:43.516]                   {
[16:03:43.516]                     {
[16:03:43.516]                       base::local({
[16:03:43.516]                         has_future <- base::requireNamespace("future", 
[16:03:43.516]                           quietly = TRUE)
[16:03:43.516]                         if (has_future) {
[16:03:43.516]                           ns <- base::getNamespace("future")
[16:03:43.516]                           version <- ns[[".package"]][["version"]]
[16:03:43.516]                           if (is.null(version)) 
[16:03:43.516]                             version <- utils::packageVersion("future")
[16:03:43.516]                         }
[16:03:43.516]                         else {
[16:03:43.516]                           version <- NULL
[16:03:43.516]                         }
[16:03:43.516]                         if (!has_future || version < "1.8.0") {
[16:03:43.516]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:43.516]                             "", base::R.version$version.string), 
[16:03:43.516]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:43.516]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:43.516]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:43.516]                               "release", "version")], collapse = " "), 
[16:03:43.516]                             hostname = base::Sys.info()[["nodename"]])
[16:03:43.516]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:43.516]                             info)
[16:03:43.516]                           info <- base::paste(info, collapse = "; ")
[16:03:43.516]                           if (!has_future) {
[16:03:43.516]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:43.516]                               info)
[16:03:43.516]                           }
[16:03:43.516]                           else {
[16:03:43.516]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:43.516]                               info, version)
[16:03:43.516]                           }
[16:03:43.516]                           base::stop(msg)
[16:03:43.516]                         }
[16:03:43.516]                       })
[16:03:43.516]                     }
[16:03:43.516]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:43.516]                     base::options(mc.cores = 1L)
[16:03:43.516]                   }
[16:03:43.516]                   options(future.plan = NULL)
[16:03:43.516]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:43.516]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:43.516]                 }
[16:03:43.516]                 ...future.workdir <- getwd()
[16:03:43.516]             }
[16:03:43.516]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:43.516]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:43.516]         }
[16:03:43.516]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:43.516]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:43.516]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:43.516]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:43.516]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:43.516]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:43.516]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:43.516]             base::names(...future.oldOptions))
[16:03:43.516]     }
[16:03:43.516]     if (FALSE) {
[16:03:43.516]     }
[16:03:43.516]     else {
[16:03:43.516]         if (TRUE) {
[16:03:43.516]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:43.516]                 open = "w")
[16:03:43.516]         }
[16:03:43.516]         else {
[16:03:43.516]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:43.516]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:43.516]         }
[16:03:43.516]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:43.516]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:43.516]             base::sink(type = "output", split = FALSE)
[16:03:43.516]             base::close(...future.stdout)
[16:03:43.516]         }, add = TRUE)
[16:03:43.516]     }
[16:03:43.516]     ...future.frame <- base::sys.nframe()
[16:03:43.516]     ...future.conditions <- base::list()
[16:03:43.516]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:43.516]     if (FALSE) {
[16:03:43.516]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:43.516]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:43.516]     }
[16:03:43.516]     ...future.result <- base::tryCatch({
[16:03:43.516]         base::withCallingHandlers({
[16:03:43.516]             ...future.value <- base::withVisible(base::local({
[16:03:43.516]                 ...future.makeSendCondition <- base::local({
[16:03:43.516]                   sendCondition <- NULL
[16:03:43.516]                   function(frame = 1L) {
[16:03:43.516]                     if (is.function(sendCondition)) 
[16:03:43.516]                       return(sendCondition)
[16:03:43.516]                     ns <- getNamespace("parallel")
[16:03:43.516]                     if (exists("sendData", mode = "function", 
[16:03:43.516]                       envir = ns)) {
[16:03:43.516]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:43.516]                         envir = ns)
[16:03:43.516]                       envir <- sys.frame(frame)
[16:03:43.516]                       master <- NULL
[16:03:43.516]                       while (!identical(envir, .GlobalEnv) && 
[16:03:43.516]                         !identical(envir, emptyenv())) {
[16:03:43.516]                         if (exists("master", mode = "list", envir = envir, 
[16:03:43.516]                           inherits = FALSE)) {
[16:03:43.516]                           master <- get("master", mode = "list", 
[16:03:43.516]                             envir = envir, inherits = FALSE)
[16:03:43.516]                           if (inherits(master, c("SOCKnode", 
[16:03:43.516]                             "SOCK0node"))) {
[16:03:43.516]                             sendCondition <<- function(cond) {
[16:03:43.516]                               data <- list(type = "VALUE", value = cond, 
[16:03:43.516]                                 success = TRUE)
[16:03:43.516]                               parallel_sendData(master, data)
[16:03:43.516]                             }
[16:03:43.516]                             return(sendCondition)
[16:03:43.516]                           }
[16:03:43.516]                         }
[16:03:43.516]                         frame <- frame + 1L
[16:03:43.516]                         envir <- sys.frame(frame)
[16:03:43.516]                       }
[16:03:43.516]                     }
[16:03:43.516]                     sendCondition <<- function(cond) NULL
[16:03:43.516]                   }
[16:03:43.516]                 })
[16:03:43.516]                 withCallingHandlers({
[16:03:43.516]                   {
[16:03:43.516]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:43.516]                     if (!identical(...future.globals.maxSize.org, 
[16:03:43.516]                       ...future.globals.maxSize)) {
[16:03:43.516]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:43.516]                       on.exit(options(oopts), add = TRUE)
[16:03:43.516]                     }
[16:03:43.516]                     {
[16:03:43.516]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:43.516]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:03:43.516]                         USE.NAMES = FALSE)
[16:03:43.516]                       do.call(mapply, args = args)
[16:03:43.516]                     }
[16:03:43.516]                   }
[16:03:43.516]                 }, immediateCondition = function(cond) {
[16:03:43.516]                   sendCondition <- ...future.makeSendCondition()
[16:03:43.516]                   sendCondition(cond)
[16:03:43.516]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:43.516]                   {
[16:03:43.516]                     inherits <- base::inherits
[16:03:43.516]                     invokeRestart <- base::invokeRestart
[16:03:43.516]                     is.null <- base::is.null
[16:03:43.516]                     muffled <- FALSE
[16:03:43.516]                     if (inherits(cond, "message")) {
[16:03:43.516]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:43.516]                       if (muffled) 
[16:03:43.516]                         invokeRestart("muffleMessage")
[16:03:43.516]                     }
[16:03:43.516]                     else if (inherits(cond, "warning")) {
[16:03:43.516]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:43.516]                       if (muffled) 
[16:03:43.516]                         invokeRestart("muffleWarning")
[16:03:43.516]                     }
[16:03:43.516]                     else if (inherits(cond, "condition")) {
[16:03:43.516]                       if (!is.null(pattern)) {
[16:03:43.516]                         computeRestarts <- base::computeRestarts
[16:03:43.516]                         grepl <- base::grepl
[16:03:43.516]                         restarts <- computeRestarts(cond)
[16:03:43.516]                         for (restart in restarts) {
[16:03:43.516]                           name <- restart$name
[16:03:43.516]                           if (is.null(name)) 
[16:03:43.516]                             next
[16:03:43.516]                           if (!grepl(pattern, name)) 
[16:03:43.516]                             next
[16:03:43.516]                           invokeRestart(restart)
[16:03:43.516]                           muffled <- TRUE
[16:03:43.516]                           break
[16:03:43.516]                         }
[16:03:43.516]                       }
[16:03:43.516]                     }
[16:03:43.516]                     invisible(muffled)
[16:03:43.516]                   }
[16:03:43.516]                   muffleCondition(cond)
[16:03:43.516]                 })
[16:03:43.516]             }))
[16:03:43.516]             future::FutureResult(value = ...future.value$value, 
[16:03:43.516]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:43.516]                   ...future.rng), globalenv = if (FALSE) 
[16:03:43.516]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:43.516]                     ...future.globalenv.names))
[16:03:43.516]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:43.516]         }, condition = base::local({
[16:03:43.516]             c <- base::c
[16:03:43.516]             inherits <- base::inherits
[16:03:43.516]             invokeRestart <- base::invokeRestart
[16:03:43.516]             length <- base::length
[16:03:43.516]             list <- base::list
[16:03:43.516]             seq.int <- base::seq.int
[16:03:43.516]             signalCondition <- base::signalCondition
[16:03:43.516]             sys.calls <- base::sys.calls
[16:03:43.516]             `[[` <- base::`[[`
[16:03:43.516]             `+` <- base::`+`
[16:03:43.516]             `<<-` <- base::`<<-`
[16:03:43.516]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:43.516]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:43.516]                   3L)]
[16:03:43.516]             }
[16:03:43.516]             function(cond) {
[16:03:43.516]                 is_error <- inherits(cond, "error")
[16:03:43.516]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:43.516]                   NULL)
[16:03:43.516]                 if (is_error) {
[16:03:43.516]                   sessionInformation <- function() {
[16:03:43.516]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:43.516]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:43.516]                       search = base::search(), system = base::Sys.info())
[16:03:43.516]                   }
[16:03:43.516]                   ...future.conditions[[length(...future.conditions) + 
[16:03:43.516]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:43.516]                     cond$call), session = sessionInformation(), 
[16:03:43.516]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:43.516]                   signalCondition(cond)
[16:03:43.516]                 }
[16:03:43.516]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:43.516]                 "immediateCondition"))) {
[16:03:43.516]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:43.516]                   ...future.conditions[[length(...future.conditions) + 
[16:03:43.516]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:43.516]                   if (TRUE && !signal) {
[16:03:43.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:43.516]                     {
[16:03:43.516]                       inherits <- base::inherits
[16:03:43.516]                       invokeRestart <- base::invokeRestart
[16:03:43.516]                       is.null <- base::is.null
[16:03:43.516]                       muffled <- FALSE
[16:03:43.516]                       if (inherits(cond, "message")) {
[16:03:43.516]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:43.516]                         if (muffled) 
[16:03:43.516]                           invokeRestart("muffleMessage")
[16:03:43.516]                       }
[16:03:43.516]                       else if (inherits(cond, "warning")) {
[16:03:43.516]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:43.516]                         if (muffled) 
[16:03:43.516]                           invokeRestart("muffleWarning")
[16:03:43.516]                       }
[16:03:43.516]                       else if (inherits(cond, "condition")) {
[16:03:43.516]                         if (!is.null(pattern)) {
[16:03:43.516]                           computeRestarts <- base::computeRestarts
[16:03:43.516]                           grepl <- base::grepl
[16:03:43.516]                           restarts <- computeRestarts(cond)
[16:03:43.516]                           for (restart in restarts) {
[16:03:43.516]                             name <- restart$name
[16:03:43.516]                             if (is.null(name)) 
[16:03:43.516]                               next
[16:03:43.516]                             if (!grepl(pattern, name)) 
[16:03:43.516]                               next
[16:03:43.516]                             invokeRestart(restart)
[16:03:43.516]                             muffled <- TRUE
[16:03:43.516]                             break
[16:03:43.516]                           }
[16:03:43.516]                         }
[16:03:43.516]                       }
[16:03:43.516]                       invisible(muffled)
[16:03:43.516]                     }
[16:03:43.516]                     muffleCondition(cond, pattern = "^muffle")
[16:03:43.516]                   }
[16:03:43.516]                 }
[16:03:43.516]                 else {
[16:03:43.516]                   if (TRUE) {
[16:03:43.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:43.516]                     {
[16:03:43.516]                       inherits <- base::inherits
[16:03:43.516]                       invokeRestart <- base::invokeRestart
[16:03:43.516]                       is.null <- base::is.null
[16:03:43.516]                       muffled <- FALSE
[16:03:43.516]                       if (inherits(cond, "message")) {
[16:03:43.516]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:43.516]                         if (muffled) 
[16:03:43.516]                           invokeRestart("muffleMessage")
[16:03:43.516]                       }
[16:03:43.516]                       else if (inherits(cond, "warning")) {
[16:03:43.516]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:43.516]                         if (muffled) 
[16:03:43.516]                           invokeRestart("muffleWarning")
[16:03:43.516]                       }
[16:03:43.516]                       else if (inherits(cond, "condition")) {
[16:03:43.516]                         if (!is.null(pattern)) {
[16:03:43.516]                           computeRestarts <- base::computeRestarts
[16:03:43.516]                           grepl <- base::grepl
[16:03:43.516]                           restarts <- computeRestarts(cond)
[16:03:43.516]                           for (restart in restarts) {
[16:03:43.516]                             name <- restart$name
[16:03:43.516]                             if (is.null(name)) 
[16:03:43.516]                               next
[16:03:43.516]                             if (!grepl(pattern, name)) 
[16:03:43.516]                               next
[16:03:43.516]                             invokeRestart(restart)
[16:03:43.516]                             muffled <- TRUE
[16:03:43.516]                             break
[16:03:43.516]                           }
[16:03:43.516]                         }
[16:03:43.516]                       }
[16:03:43.516]                       invisible(muffled)
[16:03:43.516]                     }
[16:03:43.516]                     muffleCondition(cond, pattern = "^muffle")
[16:03:43.516]                   }
[16:03:43.516]                 }
[16:03:43.516]             }
[16:03:43.516]         }))
[16:03:43.516]     }, error = function(ex) {
[16:03:43.516]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:43.516]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:43.516]                 ...future.rng), started = ...future.startTime, 
[16:03:43.516]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:43.516]             version = "1.8"), class = "FutureResult")
[16:03:43.516]     }, finally = {
[16:03:43.516]         if (!identical(...future.workdir, getwd())) 
[16:03:43.516]             setwd(...future.workdir)
[16:03:43.516]         {
[16:03:43.516]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:43.516]                 ...future.oldOptions$nwarnings <- NULL
[16:03:43.516]             }
[16:03:43.516]             base::options(...future.oldOptions)
[16:03:43.516]             if (.Platform$OS.type == "windows") {
[16:03:43.516]                 old_names <- names(...future.oldEnvVars)
[16:03:43.516]                 envs <- base::Sys.getenv()
[16:03:43.516]                 names <- names(envs)
[16:03:43.516]                 common <- intersect(names, old_names)
[16:03:43.516]                 added <- setdiff(names, old_names)
[16:03:43.516]                 removed <- setdiff(old_names, names)
[16:03:43.516]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:43.516]                   envs[common]]
[16:03:43.516]                 NAMES <- toupper(changed)
[16:03:43.516]                 args <- list()
[16:03:43.516]                 for (kk in seq_along(NAMES)) {
[16:03:43.516]                   name <- changed[[kk]]
[16:03:43.516]                   NAME <- NAMES[[kk]]
[16:03:43.516]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:43.516]                     next
[16:03:43.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:43.516]                 }
[16:03:43.516]                 NAMES <- toupper(added)
[16:03:43.516]                 for (kk in seq_along(NAMES)) {
[16:03:43.516]                   name <- added[[kk]]
[16:03:43.516]                   NAME <- NAMES[[kk]]
[16:03:43.516]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:43.516]                     next
[16:03:43.516]                   args[[name]] <- ""
[16:03:43.516]                 }
[16:03:43.516]                 NAMES <- toupper(removed)
[16:03:43.516]                 for (kk in seq_along(NAMES)) {
[16:03:43.516]                   name <- removed[[kk]]
[16:03:43.516]                   NAME <- NAMES[[kk]]
[16:03:43.516]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:43.516]                     next
[16:03:43.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:43.516]                 }
[16:03:43.516]                 if (length(args) > 0) 
[16:03:43.516]                   base::do.call(base::Sys.setenv, args = args)
[16:03:43.516]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:43.516]             }
[16:03:43.516]             else {
[16:03:43.516]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:43.516]             }
[16:03:43.516]             {
[16:03:43.516]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:43.516]                   0L) {
[16:03:43.516]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:43.516]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:43.516]                   base::options(opts)
[16:03:43.516]                 }
[16:03:43.516]                 {
[16:03:43.516]                   {
[16:03:43.516]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:43.516]                     NULL
[16:03:43.516]                   }
[16:03:43.516]                   options(future.plan = NULL)
[16:03:43.516]                   if (is.na(NA_character_)) 
[16:03:43.516]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:43.516]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:43.516]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:43.516]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:43.516]                     envir = parent.frame()) 
[16:03:43.516]                   {
[16:03:43.516]                     if (is.function(workers)) 
[16:03:43.516]                       workers <- workers()
[16:03:43.516]                     workers <- structure(as.integer(workers), 
[16:03:43.516]                       class = class(workers))
[16:03:43.516]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:43.516]                       workers >= 1)
[16:03:43.516]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:43.516]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:43.516]                     }
[16:03:43.516]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:43.516]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:43.516]                       envir = envir)
[16:03:43.516]                     if (!future$lazy) 
[16:03:43.516]                       future <- run(future)
[16:03:43.516]                     invisible(future)
[16:03:43.516]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:43.516]                 }
[16:03:43.516]             }
[16:03:43.516]         }
[16:03:43.516]     })
[16:03:43.516]     if (TRUE) {
[16:03:43.516]         base::sink(type = "output", split = FALSE)
[16:03:43.516]         if (TRUE) {
[16:03:43.516]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:43.516]         }
[16:03:43.516]         else {
[16:03:43.516]             ...future.result["stdout"] <- base::list(NULL)
[16:03:43.516]         }
[16:03:43.516]         base::close(...future.stdout)
[16:03:43.516]         ...future.stdout <- NULL
[16:03:43.516]     }
[16:03:43.516]     ...future.result$conditions <- ...future.conditions
[16:03:43.516]     ...future.result$finished <- base::Sys.time()
[16:03:43.516]     ...future.result
[16:03:43.516] }
[16:03:43.518] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[16:03:43.518] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[16:03:43.519] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[16:03:43.519] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[16:03:43.519] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[16:03:43.519] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[16:03:43.520] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[16:03:43.520] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:03:43.520] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:03:43.520] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:03:43.520] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:03:43.521] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[16:03:43.521] MultisessionFuture started
[16:03:43.521] - Launch lazy future ... done
[16:03:43.521] run() for ‘MultisessionFuture’ ... done
[16:03:43.521] Created future:
[16:03:43.521] MultisessionFuture:
[16:03:43.521] Label: ‘future_mapply-1’
[16:03:43.521] Expression:
[16:03:43.521] {
[16:03:43.521]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:43.521]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:43.521]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:43.521]         on.exit(options(oopts), add = TRUE)
[16:03:43.521]     }
[16:03:43.521]     {
[16:03:43.521]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:43.521]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:03:43.521]         do.call(mapply, args = args)
[16:03:43.521]     }
[16:03:43.521] }
[16:03:43.521] Lazy evaluation: FALSE
[16:03:43.521] Asynchronous evaluation: TRUE
[16:03:43.521] Local evaluation: TRUE
[16:03:43.521] Environment: R_GlobalEnv
[16:03:43.521] Capture standard output: TRUE
[16:03:43.521] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:43.521] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:43.521] Packages: <none>
[16:03:43.521] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:43.521] Resolved: FALSE
[16:03:43.521] Value: <not collected>
[16:03:43.521] Conditions captured: <none>
[16:03:43.521] Early signaling: FALSE
[16:03:43.521] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:43.521] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:43.533] Chunk #1 of 2 ... DONE
[16:03:43.533] Chunk #2 of 2 ...
[16:03:43.533]  - Finding globals in '...' for chunk #2 ...
[16:03:43.533] getGlobalsAndPackages() ...
[16:03:43.533] Searching for globals...
[16:03:43.534] 
[16:03:43.534] Searching for globals ... DONE
[16:03:43.534] - globals: [0] <none>
[16:03:43.534] getGlobalsAndPackages() ... DONE
[16:03:43.534]    + additional globals found: [n=0] 
[16:03:43.534]    + additional namespaces needed: [n=0] 
[16:03:43.534]  - Finding globals in '...' for chunk #2 ... DONE
[16:03:43.534]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:43.534]  - seeds: <none>
[16:03:43.534]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:43.535] getGlobalsAndPackages() ...
[16:03:43.535] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:43.535] Resolving globals: FALSE
[16:03:43.535] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:03:43.536] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:03:43.536] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:43.536] 
[16:03:43.536] getGlobalsAndPackages() ... DONE
[16:03:43.536] run() for ‘Future’ ...
[16:03:43.536] - state: ‘created’
[16:03:43.536] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:43.552] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:43.552] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:43.552]   - Field: ‘node’
[16:03:43.552]   - Field: ‘label’
[16:03:43.552]   - Field: ‘local’
[16:03:43.552]   - Field: ‘owner’
[16:03:43.553]   - Field: ‘envir’
[16:03:43.553]   - Field: ‘workers’
[16:03:43.553]   - Field: ‘packages’
[16:03:43.553]   - Field: ‘gc’
[16:03:43.553]   - Field: ‘conditions’
[16:03:43.553]   - Field: ‘persistent’
[16:03:43.553]   - Field: ‘expr’
[16:03:43.553]   - Field: ‘uuid’
[16:03:43.553]   - Field: ‘seed’
[16:03:43.553]   - Field: ‘version’
[16:03:43.553]   - Field: ‘result’
[16:03:43.554]   - Field: ‘asynchronous’
[16:03:43.554]   - Field: ‘calls’
[16:03:43.554]   - Field: ‘globals’
[16:03:43.554]   - Field: ‘stdout’
[16:03:43.554]   - Field: ‘earlySignal’
[16:03:43.554]   - Field: ‘lazy’
[16:03:43.554]   - Field: ‘state’
[16:03:43.554] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:43.554] - Launch lazy future ...
[16:03:43.554] Packages needed by the future expression (n = 0): <none>
[16:03:43.555] Packages needed by future strategies (n = 0): <none>
[16:03:43.555] {
[16:03:43.555]     {
[16:03:43.555]         {
[16:03:43.555]             ...future.startTime <- base::Sys.time()
[16:03:43.555]             {
[16:03:43.555]                 {
[16:03:43.555]                   {
[16:03:43.555]                     {
[16:03:43.555]                       base::local({
[16:03:43.555]                         has_future <- base::requireNamespace("future", 
[16:03:43.555]                           quietly = TRUE)
[16:03:43.555]                         if (has_future) {
[16:03:43.555]                           ns <- base::getNamespace("future")
[16:03:43.555]                           version <- ns[[".package"]][["version"]]
[16:03:43.555]                           if (is.null(version)) 
[16:03:43.555]                             version <- utils::packageVersion("future")
[16:03:43.555]                         }
[16:03:43.555]                         else {
[16:03:43.555]                           version <- NULL
[16:03:43.555]                         }
[16:03:43.555]                         if (!has_future || version < "1.8.0") {
[16:03:43.555]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:43.555]                             "", base::R.version$version.string), 
[16:03:43.555]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:43.555]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:43.555]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:43.555]                               "release", "version")], collapse = " "), 
[16:03:43.555]                             hostname = base::Sys.info()[["nodename"]])
[16:03:43.555]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:43.555]                             info)
[16:03:43.555]                           info <- base::paste(info, collapse = "; ")
[16:03:43.555]                           if (!has_future) {
[16:03:43.555]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:43.555]                               info)
[16:03:43.555]                           }
[16:03:43.555]                           else {
[16:03:43.555]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:43.555]                               info, version)
[16:03:43.555]                           }
[16:03:43.555]                           base::stop(msg)
[16:03:43.555]                         }
[16:03:43.555]                       })
[16:03:43.555]                     }
[16:03:43.555]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:43.555]                     base::options(mc.cores = 1L)
[16:03:43.555]                   }
[16:03:43.555]                   options(future.plan = NULL)
[16:03:43.555]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:43.555]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:43.555]                 }
[16:03:43.555]                 ...future.workdir <- getwd()
[16:03:43.555]             }
[16:03:43.555]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:43.555]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:43.555]         }
[16:03:43.555]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:43.555]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:43.555]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:43.555]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:43.555]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:43.555]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:43.555]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:43.555]             base::names(...future.oldOptions))
[16:03:43.555]     }
[16:03:43.555]     if (FALSE) {
[16:03:43.555]     }
[16:03:43.555]     else {
[16:03:43.555]         if (TRUE) {
[16:03:43.555]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:43.555]                 open = "w")
[16:03:43.555]         }
[16:03:43.555]         else {
[16:03:43.555]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:43.555]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:43.555]         }
[16:03:43.555]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:43.555]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:43.555]             base::sink(type = "output", split = FALSE)
[16:03:43.555]             base::close(...future.stdout)
[16:03:43.555]         }, add = TRUE)
[16:03:43.555]     }
[16:03:43.555]     ...future.frame <- base::sys.nframe()
[16:03:43.555]     ...future.conditions <- base::list()
[16:03:43.555]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:43.555]     if (FALSE) {
[16:03:43.555]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:43.555]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:43.555]     }
[16:03:43.555]     ...future.result <- base::tryCatch({
[16:03:43.555]         base::withCallingHandlers({
[16:03:43.555]             ...future.value <- base::withVisible(base::local({
[16:03:43.555]                 ...future.makeSendCondition <- base::local({
[16:03:43.555]                   sendCondition <- NULL
[16:03:43.555]                   function(frame = 1L) {
[16:03:43.555]                     if (is.function(sendCondition)) 
[16:03:43.555]                       return(sendCondition)
[16:03:43.555]                     ns <- getNamespace("parallel")
[16:03:43.555]                     if (exists("sendData", mode = "function", 
[16:03:43.555]                       envir = ns)) {
[16:03:43.555]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:43.555]                         envir = ns)
[16:03:43.555]                       envir <- sys.frame(frame)
[16:03:43.555]                       master <- NULL
[16:03:43.555]                       while (!identical(envir, .GlobalEnv) && 
[16:03:43.555]                         !identical(envir, emptyenv())) {
[16:03:43.555]                         if (exists("master", mode = "list", envir = envir, 
[16:03:43.555]                           inherits = FALSE)) {
[16:03:43.555]                           master <- get("master", mode = "list", 
[16:03:43.555]                             envir = envir, inherits = FALSE)
[16:03:43.555]                           if (inherits(master, c("SOCKnode", 
[16:03:43.555]                             "SOCK0node"))) {
[16:03:43.555]                             sendCondition <<- function(cond) {
[16:03:43.555]                               data <- list(type = "VALUE", value = cond, 
[16:03:43.555]                                 success = TRUE)
[16:03:43.555]                               parallel_sendData(master, data)
[16:03:43.555]                             }
[16:03:43.555]                             return(sendCondition)
[16:03:43.555]                           }
[16:03:43.555]                         }
[16:03:43.555]                         frame <- frame + 1L
[16:03:43.555]                         envir <- sys.frame(frame)
[16:03:43.555]                       }
[16:03:43.555]                     }
[16:03:43.555]                     sendCondition <<- function(cond) NULL
[16:03:43.555]                   }
[16:03:43.555]                 })
[16:03:43.555]                 withCallingHandlers({
[16:03:43.555]                   {
[16:03:43.555]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:43.555]                     if (!identical(...future.globals.maxSize.org, 
[16:03:43.555]                       ...future.globals.maxSize)) {
[16:03:43.555]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:43.555]                       on.exit(options(oopts), add = TRUE)
[16:03:43.555]                     }
[16:03:43.555]                     {
[16:03:43.555]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:43.555]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:03:43.555]                         USE.NAMES = FALSE)
[16:03:43.555]                       do.call(mapply, args = args)
[16:03:43.555]                     }
[16:03:43.555]                   }
[16:03:43.555]                 }, immediateCondition = function(cond) {
[16:03:43.555]                   sendCondition <- ...future.makeSendCondition()
[16:03:43.555]                   sendCondition(cond)
[16:03:43.555]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:43.555]                   {
[16:03:43.555]                     inherits <- base::inherits
[16:03:43.555]                     invokeRestart <- base::invokeRestart
[16:03:43.555]                     is.null <- base::is.null
[16:03:43.555]                     muffled <- FALSE
[16:03:43.555]                     if (inherits(cond, "message")) {
[16:03:43.555]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:43.555]                       if (muffled) 
[16:03:43.555]                         invokeRestart("muffleMessage")
[16:03:43.555]                     }
[16:03:43.555]                     else if (inherits(cond, "warning")) {
[16:03:43.555]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:43.555]                       if (muffled) 
[16:03:43.555]                         invokeRestart("muffleWarning")
[16:03:43.555]                     }
[16:03:43.555]                     else if (inherits(cond, "condition")) {
[16:03:43.555]                       if (!is.null(pattern)) {
[16:03:43.555]                         computeRestarts <- base::computeRestarts
[16:03:43.555]                         grepl <- base::grepl
[16:03:43.555]                         restarts <- computeRestarts(cond)
[16:03:43.555]                         for (restart in restarts) {
[16:03:43.555]                           name <- restart$name
[16:03:43.555]                           if (is.null(name)) 
[16:03:43.555]                             next
[16:03:43.555]                           if (!grepl(pattern, name)) 
[16:03:43.555]                             next
[16:03:43.555]                           invokeRestart(restart)
[16:03:43.555]                           muffled <- TRUE
[16:03:43.555]                           break
[16:03:43.555]                         }
[16:03:43.555]                       }
[16:03:43.555]                     }
[16:03:43.555]                     invisible(muffled)
[16:03:43.555]                   }
[16:03:43.555]                   muffleCondition(cond)
[16:03:43.555]                 })
[16:03:43.555]             }))
[16:03:43.555]             future::FutureResult(value = ...future.value$value, 
[16:03:43.555]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:43.555]                   ...future.rng), globalenv = if (FALSE) 
[16:03:43.555]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:43.555]                     ...future.globalenv.names))
[16:03:43.555]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:43.555]         }, condition = base::local({
[16:03:43.555]             c <- base::c
[16:03:43.555]             inherits <- base::inherits
[16:03:43.555]             invokeRestart <- base::invokeRestart
[16:03:43.555]             length <- base::length
[16:03:43.555]             list <- base::list
[16:03:43.555]             seq.int <- base::seq.int
[16:03:43.555]             signalCondition <- base::signalCondition
[16:03:43.555]             sys.calls <- base::sys.calls
[16:03:43.555]             `[[` <- base::`[[`
[16:03:43.555]             `+` <- base::`+`
[16:03:43.555]             `<<-` <- base::`<<-`
[16:03:43.555]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:43.555]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:43.555]                   3L)]
[16:03:43.555]             }
[16:03:43.555]             function(cond) {
[16:03:43.555]                 is_error <- inherits(cond, "error")
[16:03:43.555]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:43.555]                   NULL)
[16:03:43.555]                 if (is_error) {
[16:03:43.555]                   sessionInformation <- function() {
[16:03:43.555]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:43.555]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:43.555]                       search = base::search(), system = base::Sys.info())
[16:03:43.555]                   }
[16:03:43.555]                   ...future.conditions[[length(...future.conditions) + 
[16:03:43.555]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:43.555]                     cond$call), session = sessionInformation(), 
[16:03:43.555]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:43.555]                   signalCondition(cond)
[16:03:43.555]                 }
[16:03:43.555]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:43.555]                 "immediateCondition"))) {
[16:03:43.555]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:43.555]                   ...future.conditions[[length(...future.conditions) + 
[16:03:43.555]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:43.555]                   if (TRUE && !signal) {
[16:03:43.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:43.555]                     {
[16:03:43.555]                       inherits <- base::inherits
[16:03:43.555]                       invokeRestart <- base::invokeRestart
[16:03:43.555]                       is.null <- base::is.null
[16:03:43.555]                       muffled <- FALSE
[16:03:43.555]                       if (inherits(cond, "message")) {
[16:03:43.555]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:43.555]                         if (muffled) 
[16:03:43.555]                           invokeRestart("muffleMessage")
[16:03:43.555]                       }
[16:03:43.555]                       else if (inherits(cond, "warning")) {
[16:03:43.555]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:43.555]                         if (muffled) 
[16:03:43.555]                           invokeRestart("muffleWarning")
[16:03:43.555]                       }
[16:03:43.555]                       else if (inherits(cond, "condition")) {
[16:03:43.555]                         if (!is.null(pattern)) {
[16:03:43.555]                           computeRestarts <- base::computeRestarts
[16:03:43.555]                           grepl <- base::grepl
[16:03:43.555]                           restarts <- computeRestarts(cond)
[16:03:43.555]                           for (restart in restarts) {
[16:03:43.555]                             name <- restart$name
[16:03:43.555]                             if (is.null(name)) 
[16:03:43.555]                               next
[16:03:43.555]                             if (!grepl(pattern, name)) 
[16:03:43.555]                               next
[16:03:43.555]                             invokeRestart(restart)
[16:03:43.555]                             muffled <- TRUE
[16:03:43.555]                             break
[16:03:43.555]                           }
[16:03:43.555]                         }
[16:03:43.555]                       }
[16:03:43.555]                       invisible(muffled)
[16:03:43.555]                     }
[16:03:43.555]                     muffleCondition(cond, pattern = "^muffle")
[16:03:43.555]                   }
[16:03:43.555]                 }
[16:03:43.555]                 else {
[16:03:43.555]                   if (TRUE) {
[16:03:43.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:43.555]                     {
[16:03:43.555]                       inherits <- base::inherits
[16:03:43.555]                       invokeRestart <- base::invokeRestart
[16:03:43.555]                       is.null <- base::is.null
[16:03:43.555]                       muffled <- FALSE
[16:03:43.555]                       if (inherits(cond, "message")) {
[16:03:43.555]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:43.555]                         if (muffled) 
[16:03:43.555]                           invokeRestart("muffleMessage")
[16:03:43.555]                       }
[16:03:43.555]                       else if (inherits(cond, "warning")) {
[16:03:43.555]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:43.555]                         if (muffled) 
[16:03:43.555]                           invokeRestart("muffleWarning")
[16:03:43.555]                       }
[16:03:43.555]                       else if (inherits(cond, "condition")) {
[16:03:43.555]                         if (!is.null(pattern)) {
[16:03:43.555]                           computeRestarts <- base::computeRestarts
[16:03:43.555]                           grepl <- base::grepl
[16:03:43.555]                           restarts <- computeRestarts(cond)
[16:03:43.555]                           for (restart in restarts) {
[16:03:43.555]                             name <- restart$name
[16:03:43.555]                             if (is.null(name)) 
[16:03:43.555]                               next
[16:03:43.555]                             if (!grepl(pattern, name)) 
[16:03:43.555]                               next
[16:03:43.555]                             invokeRestart(restart)
[16:03:43.555]                             muffled <- TRUE
[16:03:43.555]                             break
[16:03:43.555]                           }
[16:03:43.555]                         }
[16:03:43.555]                       }
[16:03:43.555]                       invisible(muffled)
[16:03:43.555]                     }
[16:03:43.555]                     muffleCondition(cond, pattern = "^muffle")
[16:03:43.555]                   }
[16:03:43.555]                 }
[16:03:43.555]             }
[16:03:43.555]         }))
[16:03:43.555]     }, error = function(ex) {
[16:03:43.555]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:43.555]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:43.555]                 ...future.rng), started = ...future.startTime, 
[16:03:43.555]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:43.555]             version = "1.8"), class = "FutureResult")
[16:03:43.555]     }, finally = {
[16:03:43.555]         if (!identical(...future.workdir, getwd())) 
[16:03:43.555]             setwd(...future.workdir)
[16:03:43.555]         {
[16:03:43.555]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:43.555]                 ...future.oldOptions$nwarnings <- NULL
[16:03:43.555]             }
[16:03:43.555]             base::options(...future.oldOptions)
[16:03:43.555]             if (.Platform$OS.type == "windows") {
[16:03:43.555]                 old_names <- names(...future.oldEnvVars)
[16:03:43.555]                 envs <- base::Sys.getenv()
[16:03:43.555]                 names <- names(envs)
[16:03:43.555]                 common <- intersect(names, old_names)
[16:03:43.555]                 added <- setdiff(names, old_names)
[16:03:43.555]                 removed <- setdiff(old_names, names)
[16:03:43.555]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:43.555]                   envs[common]]
[16:03:43.555]                 NAMES <- toupper(changed)
[16:03:43.555]                 args <- list()
[16:03:43.555]                 for (kk in seq_along(NAMES)) {
[16:03:43.555]                   name <- changed[[kk]]
[16:03:43.555]                   NAME <- NAMES[[kk]]
[16:03:43.555]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:43.555]                     next
[16:03:43.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:43.555]                 }
[16:03:43.555]                 NAMES <- toupper(added)
[16:03:43.555]                 for (kk in seq_along(NAMES)) {
[16:03:43.555]                   name <- added[[kk]]
[16:03:43.555]                   NAME <- NAMES[[kk]]
[16:03:43.555]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:43.555]                     next
[16:03:43.555]                   args[[name]] <- ""
[16:03:43.555]                 }
[16:03:43.555]                 NAMES <- toupper(removed)
[16:03:43.555]                 for (kk in seq_along(NAMES)) {
[16:03:43.555]                   name <- removed[[kk]]
[16:03:43.555]                   NAME <- NAMES[[kk]]
[16:03:43.555]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:43.555]                     next
[16:03:43.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:43.555]                 }
[16:03:43.555]                 if (length(args) > 0) 
[16:03:43.555]                   base::do.call(base::Sys.setenv, args = args)
[16:03:43.555]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:43.555]             }
[16:03:43.555]             else {
[16:03:43.555]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:43.555]             }
[16:03:43.555]             {
[16:03:43.555]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:43.555]                   0L) {
[16:03:43.555]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:43.555]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:43.555]                   base::options(opts)
[16:03:43.555]                 }
[16:03:43.555]                 {
[16:03:43.555]                   {
[16:03:43.555]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:43.555]                     NULL
[16:03:43.555]                   }
[16:03:43.555]                   options(future.plan = NULL)
[16:03:43.555]                   if (is.na(NA_character_)) 
[16:03:43.555]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:43.555]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:43.555]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:43.555]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:43.555]                     envir = parent.frame()) 
[16:03:43.555]                   {
[16:03:43.555]                     if (is.function(workers)) 
[16:03:43.555]                       workers <- workers()
[16:03:43.555]                     workers <- structure(as.integer(workers), 
[16:03:43.555]                       class = class(workers))
[16:03:43.555]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:43.555]                       workers >= 1)
[16:03:43.555]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:43.555]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:43.555]                     }
[16:03:43.555]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:43.555]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:43.555]                       envir = envir)
[16:03:43.555]                     if (!future$lazy) 
[16:03:43.555]                       future <- run(future)
[16:03:43.555]                     invisible(future)
[16:03:43.555]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:43.555]                 }
[16:03:43.555]             }
[16:03:43.555]         }
[16:03:43.555]     })
[16:03:43.555]     if (TRUE) {
[16:03:43.555]         base::sink(type = "output", split = FALSE)
[16:03:43.555]         if (TRUE) {
[16:03:43.555]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:43.555]         }
[16:03:43.555]         else {
[16:03:43.555]             ...future.result["stdout"] <- base::list(NULL)
[16:03:43.555]         }
[16:03:43.555]         base::close(...future.stdout)
[16:03:43.555]         ...future.stdout <- NULL
[16:03:43.555]     }
[16:03:43.555]     ...future.result$conditions <- ...future.conditions
[16:03:43.555]     ...future.result$finished <- base::Sys.time()
[16:03:43.555]     ...future.result
[16:03:43.555] }
[16:03:43.558] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[16:03:43.558] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[16:03:43.558] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[16:03:43.558] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[16:03:43.559] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[16:03:43.559] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[16:03:43.559] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[16:03:43.559] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:03:43.559] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:03:43.560] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:03:43.560] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:03:43.560] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[16:03:43.560] MultisessionFuture started
[16:03:43.561] - Launch lazy future ... done
[16:03:43.561] run() for ‘MultisessionFuture’ ... done
[16:03:43.561] Created future:
[16:03:43.561] MultisessionFuture:
[16:03:43.561] Label: ‘future_mapply-2’
[16:03:43.561] Expression:
[16:03:43.561] {
[16:03:43.561]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:43.561]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:43.561]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:43.561]         on.exit(options(oopts), add = TRUE)
[16:03:43.561]     }
[16:03:43.561]     {
[16:03:43.561]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:43.561]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:03:43.561]         do.call(mapply, args = args)
[16:03:43.561]     }
[16:03:43.561] }
[16:03:43.561] Lazy evaluation: FALSE
[16:03:43.561] Asynchronous evaluation: TRUE
[16:03:43.561] Local evaluation: TRUE
[16:03:43.561] Environment: R_GlobalEnv
[16:03:43.561] Capture standard output: TRUE
[16:03:43.561] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:43.561] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:43.561] Packages: <none>
[16:03:43.561] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:43.561] Resolved: FALSE
[16:03:43.561] Value: <not collected>
[16:03:43.561] Conditions captured: <none>
[16:03:43.561] Early signaling: FALSE
[16:03:43.561] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:43.561] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:43.572] Chunk #2 of 2 ... DONE
[16:03:43.572] Launching 2 futures (chunks) ... DONE
[16:03:43.572] Resolving 2 futures (chunks) ...
[16:03:43.572] resolve() on list ...
[16:03:43.572]  recursive: 0
[16:03:43.573]  length: 2
[16:03:43.573] 
[16:03:43.615] receiveMessageFromWorker() for ClusterFuture ...
[16:03:43.615] - Validating connection of MultisessionFuture
[16:03:43.615] - received message: FutureResult
[16:03:43.615] - Received FutureResult
[16:03:43.615] - Erased future from FutureRegistry
[16:03:43.615] result() for ClusterFuture ...
[16:03:43.615] - result already collected: FutureResult
[16:03:43.616] result() for ClusterFuture ... done
[16:03:43.616] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:43.616] Future #2
[16:03:43.616] result() for ClusterFuture ...
[16:03:43.616] - result already collected: FutureResult
[16:03:43.616] result() for ClusterFuture ... done
[16:03:43.616] result() for ClusterFuture ...
[16:03:43.616] - result already collected: FutureResult
[16:03:43.616] result() for ClusterFuture ... done
[16:03:43.616] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:03:43.617] - nx: 2
[16:03:43.617] - relay: TRUE
[16:03:43.617] - stdout: TRUE
[16:03:43.617] - signal: TRUE
[16:03:43.617] - resignal: FALSE
[16:03:43.617] - force: TRUE
[16:03:43.617] - relayed: [n=2] FALSE, FALSE
[16:03:43.617] - queued futures: [n=2] FALSE, FALSE
[16:03:43.617]  - until=1
[16:03:43.617]  - relaying element #1
[16:03:43.617] - relayed: [n=2] FALSE, FALSE
[16:03:43.617] - queued futures: [n=2] FALSE, TRUE
[16:03:43.618] signalConditionsASAP(NULL, pos=2) ... done
[16:03:43.618]  length: 1 (resolved future 2)
[16:03:44.068] receiveMessageFromWorker() for ClusterFuture ...
[16:03:44.069] - Validating connection of MultisessionFuture
[16:03:44.069] - received message: FutureResult
[16:03:44.069] - Received FutureResult
[16:03:44.069] - Erased future from FutureRegistry
[16:03:44.069] result() for ClusterFuture ...
[16:03:44.069] - result already collected: FutureResult
[16:03:44.070] result() for ClusterFuture ... done
[16:03:44.070] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:44.070] Future #1
[16:03:44.070] result() for ClusterFuture ...
[16:03:44.070] - result already collected: FutureResult
[16:03:44.070] result() for ClusterFuture ... done
[16:03:44.070] result() for ClusterFuture ...
[16:03:44.070] - result already collected: FutureResult
[16:03:44.070] result() for ClusterFuture ... done
[16:03:44.071] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:03:44.071] - nx: 2
[16:03:44.071] - relay: TRUE
[16:03:44.071] - stdout: TRUE
[16:03:44.071] - signal: TRUE
[16:03:44.071] - resignal: FALSE
[16:03:44.071] - force: TRUE
[16:03:44.071] - relayed: [n=2] FALSE, FALSE
[16:03:44.071] - queued futures: [n=2] FALSE, TRUE
[16:03:44.071]  - until=1
[16:03:44.071]  - relaying element #1
[16:03:44.072] result() for ClusterFuture ...
[16:03:44.072] - result already collected: FutureResult
[16:03:44.072] result() for ClusterFuture ... done
[16:03:44.072] result() for ClusterFuture ...
[16:03:44.072] - result already collected: FutureResult
[16:03:44.072] result() for ClusterFuture ... done
[16:03:44.072] result() for ClusterFuture ...
[16:03:44.072] - result already collected: FutureResult
[16:03:44.072] result() for ClusterFuture ... done
[16:03:44.072] result() for ClusterFuture ...
[16:03:44.073] - result already collected: FutureResult
[16:03:44.073] result() for ClusterFuture ... done
[16:03:44.073] - relayed: [n=2] TRUE, FALSE
[16:03:44.073] - queued futures: [n=2] TRUE, TRUE
[16:03:44.073] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:03:44.073]  length: 0 (resolved future 1)
[16:03:44.073] Relaying remaining futures
[16:03:44.073] signalConditionsASAP(NULL, pos=0) ...
[16:03:44.073] - nx: 2
[16:03:44.073] - relay: TRUE
[16:03:44.073] - stdout: TRUE
[16:03:44.074] - signal: TRUE
[16:03:44.074] - resignal: FALSE
[16:03:44.074] - force: TRUE
[16:03:44.074] - relayed: [n=2] TRUE, FALSE
[16:03:44.074] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:44.074]  - relaying element #2
[16:03:44.074] result() for ClusterFuture ...
[16:03:44.074] - result already collected: FutureResult
[16:03:44.074] result() for ClusterFuture ... done
[16:03:44.074] result() for ClusterFuture ...
[16:03:44.074] - result already collected: FutureResult
[16:03:44.074] result() for ClusterFuture ... done
[16:03:44.075] result() for ClusterFuture ...
[16:03:44.075] - result already collected: FutureResult
[16:03:44.075] result() for ClusterFuture ... done
[16:03:44.075] result() for ClusterFuture ...
[16:03:44.075] - result already collected: FutureResult
[16:03:44.075] result() for ClusterFuture ... done
[16:03:44.075] - relayed: [n=2] TRUE, TRUE
[16:03:44.075] - queued futures: [n=2] TRUE, TRUE
[16:03:44.075] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[16:03:44.075] resolve() on list ... DONE
[16:03:44.076] result() for ClusterFuture ...
[16:03:44.076] - result already collected: FutureResult
[16:03:44.076] result() for ClusterFuture ... done
[16:03:44.076] result() for ClusterFuture ...
[16:03:44.076] - result already collected: FutureResult
[16:03:44.076] result() for ClusterFuture ... done
[16:03:44.076] result() for ClusterFuture ...
[16:03:44.076] - result already collected: FutureResult
[16:03:44.076] result() for ClusterFuture ... done
[16:03:44.076] result() for ClusterFuture ...
[16:03:44.076] - result already collected: FutureResult
[16:03:44.076] result() for ClusterFuture ... done
[16:03:44.077]  - Number of value chunks collected: 2
[16:03:44.077] Resolving 2 futures (chunks) ... DONE
[16:03:44.077] Reducing values from 2 chunks ...
[16:03:44.077]  - Number of values collected after concatenation: 2
[16:03:44.077]  - Number of values expected: 2
[16:03:44.077] Reducing values from 2 chunks ... DONE
[16:03:44.077] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[16:03:44.077] future_mapply() ...
[16:03:44.081] Number of chunks: 2
[16:03:44.081] getGlobalsAndPackagesXApply() ...
[16:03:44.081]  - future.globals: TRUE
[16:03:44.081] getGlobalsAndPackages() ...
[16:03:44.081] Searching for globals...
[16:03:44.083] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:03:44.083] Searching for globals ... DONE
[16:03:44.083] Resolving globals: FALSE
[16:03:44.084] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:03:44.084] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:03:44.084] - globals: [1] ‘FUN’
[16:03:44.084] 
[16:03:44.084] getGlobalsAndPackages() ... DONE
[16:03:44.084]  - globals found/used: [n=1] ‘FUN’
[16:03:44.084]  - needed namespaces: [n=0] 
[16:03:44.084] Finding globals ... DONE
[16:03:44.085] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:03:44.085] List of 2
[16:03:44.085]  $ ...future.FUN:function (x, y)  
[16:03:44.085]  $ MoreArgs     : NULL
[16:03:44.085]  - attr(*, "where")=List of 2
[16:03:44.085]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:03:44.085]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:03:44.085]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:03:44.085]  - attr(*, "resolved")= logi FALSE
[16:03:44.085]  - attr(*, "total_size")= num NA
[16:03:44.087] Packages to be attached in all futures: [n=0] 
[16:03:44.087] getGlobalsAndPackagesXApply() ... DONE
[16:03:44.088] Number of futures (= number of chunks): 2
[16:03:44.088] Launching 2 futures (chunks) ...
[16:03:44.088] Chunk #1 of 2 ...
[16:03:44.088]  - Finding globals in '...' for chunk #1 ...
[16:03:44.088] getGlobalsAndPackages() ...
[16:03:44.088] Searching for globals...
[16:03:44.088] 
[16:03:44.088] Searching for globals ... DONE
[16:03:44.088] - globals: [0] <none>
[16:03:44.089] getGlobalsAndPackages() ... DONE
[16:03:44.089]    + additional globals found: [n=0] 
[16:03:44.089]    + additional namespaces needed: [n=0] 
[16:03:44.089]  - Finding globals in '...' for chunk #1 ... DONE
[16:03:44.089]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:44.089]  - seeds: <none>
[16:03:44.089]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:44.089] getGlobalsAndPackages() ...
[16:03:44.089] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:44.089] Resolving globals: FALSE
[16:03:44.090] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:03:44.090] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:03:44.090] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:44.091] 
[16:03:44.091] getGlobalsAndPackages() ... DONE
[16:03:44.091] run() for ‘Future’ ...
[16:03:44.091] - state: ‘created’
[16:03:44.091] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:44.104] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:44.105] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:44.105]   - Field: ‘node’
[16:03:44.105]   - Field: ‘label’
[16:03:44.105]   - Field: ‘local’
[16:03:44.105]   - Field: ‘owner’
[16:03:44.105]   - Field: ‘envir’
[16:03:44.105]   - Field: ‘workers’
[16:03:44.105]   - Field: ‘packages’
[16:03:44.105]   - Field: ‘gc’
[16:03:44.105]   - Field: ‘conditions’
[16:03:44.105]   - Field: ‘persistent’
[16:03:44.106]   - Field: ‘expr’
[16:03:44.106]   - Field: ‘uuid’
[16:03:44.106]   - Field: ‘seed’
[16:03:44.106]   - Field: ‘version’
[16:03:44.106]   - Field: ‘result’
[16:03:44.106]   - Field: ‘asynchronous’
[16:03:44.106]   - Field: ‘calls’
[16:03:44.106]   - Field: ‘globals’
[16:03:44.106]   - Field: ‘stdout’
[16:03:44.106]   - Field: ‘earlySignal’
[16:03:44.106]   - Field: ‘lazy’
[16:03:44.107]   - Field: ‘state’
[16:03:44.107] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:44.107] - Launch lazy future ...
[16:03:44.107] Packages needed by the future expression (n = 0): <none>
[16:03:44.107] Packages needed by future strategies (n = 0): <none>
[16:03:44.108] {
[16:03:44.108]     {
[16:03:44.108]         {
[16:03:44.108]             ...future.startTime <- base::Sys.time()
[16:03:44.108]             {
[16:03:44.108]                 {
[16:03:44.108]                   {
[16:03:44.108]                     {
[16:03:44.108]                       base::local({
[16:03:44.108]                         has_future <- base::requireNamespace("future", 
[16:03:44.108]                           quietly = TRUE)
[16:03:44.108]                         if (has_future) {
[16:03:44.108]                           ns <- base::getNamespace("future")
[16:03:44.108]                           version <- ns[[".package"]][["version"]]
[16:03:44.108]                           if (is.null(version)) 
[16:03:44.108]                             version <- utils::packageVersion("future")
[16:03:44.108]                         }
[16:03:44.108]                         else {
[16:03:44.108]                           version <- NULL
[16:03:44.108]                         }
[16:03:44.108]                         if (!has_future || version < "1.8.0") {
[16:03:44.108]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:44.108]                             "", base::R.version$version.string), 
[16:03:44.108]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:44.108]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:44.108]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:44.108]                               "release", "version")], collapse = " "), 
[16:03:44.108]                             hostname = base::Sys.info()[["nodename"]])
[16:03:44.108]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:44.108]                             info)
[16:03:44.108]                           info <- base::paste(info, collapse = "; ")
[16:03:44.108]                           if (!has_future) {
[16:03:44.108]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:44.108]                               info)
[16:03:44.108]                           }
[16:03:44.108]                           else {
[16:03:44.108]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:44.108]                               info, version)
[16:03:44.108]                           }
[16:03:44.108]                           base::stop(msg)
[16:03:44.108]                         }
[16:03:44.108]                       })
[16:03:44.108]                     }
[16:03:44.108]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:44.108]                     base::options(mc.cores = 1L)
[16:03:44.108]                   }
[16:03:44.108]                   options(future.plan = NULL)
[16:03:44.108]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:44.108]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:44.108]                 }
[16:03:44.108]                 ...future.workdir <- getwd()
[16:03:44.108]             }
[16:03:44.108]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:44.108]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:44.108]         }
[16:03:44.108]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:44.108]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:44.108]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:44.108]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:44.108]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:44.108]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:44.108]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:44.108]             base::names(...future.oldOptions))
[16:03:44.108]     }
[16:03:44.108]     if (TRUE) {
[16:03:44.108]     }
[16:03:44.108]     else {
[16:03:44.108]         if (NA) {
[16:03:44.108]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:44.108]                 open = "w")
[16:03:44.108]         }
[16:03:44.108]         else {
[16:03:44.108]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:44.108]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:44.108]         }
[16:03:44.108]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:44.108]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:44.108]             base::sink(type = "output", split = FALSE)
[16:03:44.108]             base::close(...future.stdout)
[16:03:44.108]         }, add = TRUE)
[16:03:44.108]     }
[16:03:44.108]     ...future.frame <- base::sys.nframe()
[16:03:44.108]     ...future.conditions <- base::list()
[16:03:44.108]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:44.108]     if (FALSE) {
[16:03:44.108]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:44.108]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:44.108]     }
[16:03:44.108]     ...future.result <- base::tryCatch({
[16:03:44.108]         base::withCallingHandlers({
[16:03:44.108]             ...future.value <- base::withVisible(base::local({
[16:03:44.108]                 ...future.makeSendCondition <- base::local({
[16:03:44.108]                   sendCondition <- NULL
[16:03:44.108]                   function(frame = 1L) {
[16:03:44.108]                     if (is.function(sendCondition)) 
[16:03:44.108]                       return(sendCondition)
[16:03:44.108]                     ns <- getNamespace("parallel")
[16:03:44.108]                     if (exists("sendData", mode = "function", 
[16:03:44.108]                       envir = ns)) {
[16:03:44.108]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:44.108]                         envir = ns)
[16:03:44.108]                       envir <- sys.frame(frame)
[16:03:44.108]                       master <- NULL
[16:03:44.108]                       while (!identical(envir, .GlobalEnv) && 
[16:03:44.108]                         !identical(envir, emptyenv())) {
[16:03:44.108]                         if (exists("master", mode = "list", envir = envir, 
[16:03:44.108]                           inherits = FALSE)) {
[16:03:44.108]                           master <- get("master", mode = "list", 
[16:03:44.108]                             envir = envir, inherits = FALSE)
[16:03:44.108]                           if (inherits(master, c("SOCKnode", 
[16:03:44.108]                             "SOCK0node"))) {
[16:03:44.108]                             sendCondition <<- function(cond) {
[16:03:44.108]                               data <- list(type = "VALUE", value = cond, 
[16:03:44.108]                                 success = TRUE)
[16:03:44.108]                               parallel_sendData(master, data)
[16:03:44.108]                             }
[16:03:44.108]                             return(sendCondition)
[16:03:44.108]                           }
[16:03:44.108]                         }
[16:03:44.108]                         frame <- frame + 1L
[16:03:44.108]                         envir <- sys.frame(frame)
[16:03:44.108]                       }
[16:03:44.108]                     }
[16:03:44.108]                     sendCondition <<- function(cond) NULL
[16:03:44.108]                   }
[16:03:44.108]                 })
[16:03:44.108]                 withCallingHandlers({
[16:03:44.108]                   {
[16:03:44.108]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:44.108]                     if (!identical(...future.globals.maxSize.org, 
[16:03:44.108]                       ...future.globals.maxSize)) {
[16:03:44.108]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:44.108]                       on.exit(options(oopts), add = TRUE)
[16:03:44.108]                     }
[16:03:44.108]                     {
[16:03:44.108]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:44.108]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:03:44.108]                         USE.NAMES = FALSE)
[16:03:44.108]                       do.call(mapply, args = args)
[16:03:44.108]                     }
[16:03:44.108]                   }
[16:03:44.108]                 }, immediateCondition = function(cond) {
[16:03:44.108]                   sendCondition <- ...future.makeSendCondition()
[16:03:44.108]                   sendCondition(cond)
[16:03:44.108]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:44.108]                   {
[16:03:44.108]                     inherits <- base::inherits
[16:03:44.108]                     invokeRestart <- base::invokeRestart
[16:03:44.108]                     is.null <- base::is.null
[16:03:44.108]                     muffled <- FALSE
[16:03:44.108]                     if (inherits(cond, "message")) {
[16:03:44.108]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:44.108]                       if (muffled) 
[16:03:44.108]                         invokeRestart("muffleMessage")
[16:03:44.108]                     }
[16:03:44.108]                     else if (inherits(cond, "warning")) {
[16:03:44.108]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:44.108]                       if (muffled) 
[16:03:44.108]                         invokeRestart("muffleWarning")
[16:03:44.108]                     }
[16:03:44.108]                     else if (inherits(cond, "condition")) {
[16:03:44.108]                       if (!is.null(pattern)) {
[16:03:44.108]                         computeRestarts <- base::computeRestarts
[16:03:44.108]                         grepl <- base::grepl
[16:03:44.108]                         restarts <- computeRestarts(cond)
[16:03:44.108]                         for (restart in restarts) {
[16:03:44.108]                           name <- restart$name
[16:03:44.108]                           if (is.null(name)) 
[16:03:44.108]                             next
[16:03:44.108]                           if (!grepl(pattern, name)) 
[16:03:44.108]                             next
[16:03:44.108]                           invokeRestart(restart)
[16:03:44.108]                           muffled <- TRUE
[16:03:44.108]                           break
[16:03:44.108]                         }
[16:03:44.108]                       }
[16:03:44.108]                     }
[16:03:44.108]                     invisible(muffled)
[16:03:44.108]                   }
[16:03:44.108]                   muffleCondition(cond)
[16:03:44.108]                 })
[16:03:44.108]             }))
[16:03:44.108]             future::FutureResult(value = ...future.value$value, 
[16:03:44.108]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:44.108]                   ...future.rng), globalenv = if (FALSE) 
[16:03:44.108]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:44.108]                     ...future.globalenv.names))
[16:03:44.108]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:44.108]         }, condition = base::local({
[16:03:44.108]             c <- base::c
[16:03:44.108]             inherits <- base::inherits
[16:03:44.108]             invokeRestart <- base::invokeRestart
[16:03:44.108]             length <- base::length
[16:03:44.108]             list <- base::list
[16:03:44.108]             seq.int <- base::seq.int
[16:03:44.108]             signalCondition <- base::signalCondition
[16:03:44.108]             sys.calls <- base::sys.calls
[16:03:44.108]             `[[` <- base::`[[`
[16:03:44.108]             `+` <- base::`+`
[16:03:44.108]             `<<-` <- base::`<<-`
[16:03:44.108]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:44.108]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:44.108]                   3L)]
[16:03:44.108]             }
[16:03:44.108]             function(cond) {
[16:03:44.108]                 is_error <- inherits(cond, "error")
[16:03:44.108]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:44.108]                   NULL)
[16:03:44.108]                 if (is_error) {
[16:03:44.108]                   sessionInformation <- function() {
[16:03:44.108]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:44.108]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:44.108]                       search = base::search(), system = base::Sys.info())
[16:03:44.108]                   }
[16:03:44.108]                   ...future.conditions[[length(...future.conditions) + 
[16:03:44.108]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:44.108]                     cond$call), session = sessionInformation(), 
[16:03:44.108]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:44.108]                   signalCondition(cond)
[16:03:44.108]                 }
[16:03:44.108]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:44.108]                 "immediateCondition"))) {
[16:03:44.108]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:44.108]                   ...future.conditions[[length(...future.conditions) + 
[16:03:44.108]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:44.108]                   if (TRUE && !signal) {
[16:03:44.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:44.108]                     {
[16:03:44.108]                       inherits <- base::inherits
[16:03:44.108]                       invokeRestart <- base::invokeRestart
[16:03:44.108]                       is.null <- base::is.null
[16:03:44.108]                       muffled <- FALSE
[16:03:44.108]                       if (inherits(cond, "message")) {
[16:03:44.108]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:44.108]                         if (muffled) 
[16:03:44.108]                           invokeRestart("muffleMessage")
[16:03:44.108]                       }
[16:03:44.108]                       else if (inherits(cond, "warning")) {
[16:03:44.108]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:44.108]                         if (muffled) 
[16:03:44.108]                           invokeRestart("muffleWarning")
[16:03:44.108]                       }
[16:03:44.108]                       else if (inherits(cond, "condition")) {
[16:03:44.108]                         if (!is.null(pattern)) {
[16:03:44.108]                           computeRestarts <- base::computeRestarts
[16:03:44.108]                           grepl <- base::grepl
[16:03:44.108]                           restarts <- computeRestarts(cond)
[16:03:44.108]                           for (restart in restarts) {
[16:03:44.108]                             name <- restart$name
[16:03:44.108]                             if (is.null(name)) 
[16:03:44.108]                               next
[16:03:44.108]                             if (!grepl(pattern, name)) 
[16:03:44.108]                               next
[16:03:44.108]                             invokeRestart(restart)
[16:03:44.108]                             muffled <- TRUE
[16:03:44.108]                             break
[16:03:44.108]                           }
[16:03:44.108]                         }
[16:03:44.108]                       }
[16:03:44.108]                       invisible(muffled)
[16:03:44.108]                     }
[16:03:44.108]                     muffleCondition(cond, pattern = "^muffle")
[16:03:44.108]                   }
[16:03:44.108]                 }
[16:03:44.108]                 else {
[16:03:44.108]                   if (TRUE) {
[16:03:44.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:44.108]                     {
[16:03:44.108]                       inherits <- base::inherits
[16:03:44.108]                       invokeRestart <- base::invokeRestart
[16:03:44.108]                       is.null <- base::is.null
[16:03:44.108]                       muffled <- FALSE
[16:03:44.108]                       if (inherits(cond, "message")) {
[16:03:44.108]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:44.108]                         if (muffled) 
[16:03:44.108]                           invokeRestart("muffleMessage")
[16:03:44.108]                       }
[16:03:44.108]                       else if (inherits(cond, "warning")) {
[16:03:44.108]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:44.108]                         if (muffled) 
[16:03:44.108]                           invokeRestart("muffleWarning")
[16:03:44.108]                       }
[16:03:44.108]                       else if (inherits(cond, "condition")) {
[16:03:44.108]                         if (!is.null(pattern)) {
[16:03:44.108]                           computeRestarts <- base::computeRestarts
[16:03:44.108]                           grepl <- base::grepl
[16:03:44.108]                           restarts <- computeRestarts(cond)
[16:03:44.108]                           for (restart in restarts) {
[16:03:44.108]                             name <- restart$name
[16:03:44.108]                             if (is.null(name)) 
[16:03:44.108]                               next
[16:03:44.108]                             if (!grepl(pattern, name)) 
[16:03:44.108]                               next
[16:03:44.108]                             invokeRestart(restart)
[16:03:44.108]                             muffled <- TRUE
[16:03:44.108]                             break
[16:03:44.108]                           }
[16:03:44.108]                         }
[16:03:44.108]                       }
[16:03:44.108]                       invisible(muffled)
[16:03:44.108]                     }
[16:03:44.108]                     muffleCondition(cond, pattern = "^muffle")
[16:03:44.108]                   }
[16:03:44.108]                 }
[16:03:44.108]             }
[16:03:44.108]         }))
[16:03:44.108]     }, error = function(ex) {
[16:03:44.108]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:44.108]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:44.108]                 ...future.rng), started = ...future.startTime, 
[16:03:44.108]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:44.108]             version = "1.8"), class = "FutureResult")
[16:03:44.108]     }, finally = {
[16:03:44.108]         if (!identical(...future.workdir, getwd())) 
[16:03:44.108]             setwd(...future.workdir)
[16:03:44.108]         {
[16:03:44.108]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:44.108]                 ...future.oldOptions$nwarnings <- NULL
[16:03:44.108]             }
[16:03:44.108]             base::options(...future.oldOptions)
[16:03:44.108]             if (.Platform$OS.type == "windows") {
[16:03:44.108]                 old_names <- names(...future.oldEnvVars)
[16:03:44.108]                 envs <- base::Sys.getenv()
[16:03:44.108]                 names <- names(envs)
[16:03:44.108]                 common <- intersect(names, old_names)
[16:03:44.108]                 added <- setdiff(names, old_names)
[16:03:44.108]                 removed <- setdiff(old_names, names)
[16:03:44.108]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:44.108]                   envs[common]]
[16:03:44.108]                 NAMES <- toupper(changed)
[16:03:44.108]                 args <- list()
[16:03:44.108]                 for (kk in seq_along(NAMES)) {
[16:03:44.108]                   name <- changed[[kk]]
[16:03:44.108]                   NAME <- NAMES[[kk]]
[16:03:44.108]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:44.108]                     next
[16:03:44.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:44.108]                 }
[16:03:44.108]                 NAMES <- toupper(added)
[16:03:44.108]                 for (kk in seq_along(NAMES)) {
[16:03:44.108]                   name <- added[[kk]]
[16:03:44.108]                   NAME <- NAMES[[kk]]
[16:03:44.108]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:44.108]                     next
[16:03:44.108]                   args[[name]] <- ""
[16:03:44.108]                 }
[16:03:44.108]                 NAMES <- toupper(removed)
[16:03:44.108]                 for (kk in seq_along(NAMES)) {
[16:03:44.108]                   name <- removed[[kk]]
[16:03:44.108]                   NAME <- NAMES[[kk]]
[16:03:44.108]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:44.108]                     next
[16:03:44.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:44.108]                 }
[16:03:44.108]                 if (length(args) > 0) 
[16:03:44.108]                   base::do.call(base::Sys.setenv, args = args)
[16:03:44.108]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:44.108]             }
[16:03:44.108]             else {
[16:03:44.108]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:44.108]             }
[16:03:44.108]             {
[16:03:44.108]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:44.108]                   0L) {
[16:03:44.108]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:44.108]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:44.108]                   base::options(opts)
[16:03:44.108]                 }
[16:03:44.108]                 {
[16:03:44.108]                   {
[16:03:44.108]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:44.108]                     NULL
[16:03:44.108]                   }
[16:03:44.108]                   options(future.plan = NULL)
[16:03:44.108]                   if (is.na(NA_character_)) 
[16:03:44.108]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:44.108]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:44.108]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:44.108]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:44.108]                     envir = parent.frame()) 
[16:03:44.108]                   {
[16:03:44.108]                     if (is.function(workers)) 
[16:03:44.108]                       workers <- workers()
[16:03:44.108]                     workers <- structure(as.integer(workers), 
[16:03:44.108]                       class = class(workers))
[16:03:44.108]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:44.108]                       workers >= 1)
[16:03:44.108]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:44.108]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:44.108]                     }
[16:03:44.108]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:44.108]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:44.108]                       envir = envir)
[16:03:44.108]                     if (!future$lazy) 
[16:03:44.108]                       future <- run(future)
[16:03:44.108]                     invisible(future)
[16:03:44.108]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:44.108]                 }
[16:03:44.108]             }
[16:03:44.108]         }
[16:03:44.108]     })
[16:03:44.108]     if (FALSE) {
[16:03:44.108]         base::sink(type = "output", split = FALSE)
[16:03:44.108]         if (NA) {
[16:03:44.108]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:44.108]         }
[16:03:44.108]         else {
[16:03:44.108]             ...future.result["stdout"] <- base::list(NULL)
[16:03:44.108]         }
[16:03:44.108]         base::close(...future.stdout)
[16:03:44.108]         ...future.stdout <- NULL
[16:03:44.108]     }
[16:03:44.108]     ...future.result$conditions <- ...future.conditions
[16:03:44.108]     ...future.result$finished <- base::Sys.time()
[16:03:44.108]     ...future.result
[16:03:44.108] }
[16:03:44.110] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[16:03:44.110] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[16:03:44.111] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[16:03:44.111] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[16:03:44.111] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[16:03:44.111] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[16:03:44.112] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[16:03:44.112] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:03:44.112] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:03:44.112] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:03:44.113] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:03:44.113] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[16:03:44.113] MultisessionFuture started
[16:03:44.113] - Launch lazy future ... done
[16:03:44.113] run() for ‘MultisessionFuture’ ... done
[16:03:44.113] Created future:
[16:03:44.114] MultisessionFuture:
[16:03:44.114] Label: ‘future_mapply-1’
[16:03:44.114] Expression:
[16:03:44.114] {
[16:03:44.114]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:44.114]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:44.114]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:44.114]         on.exit(options(oopts), add = TRUE)
[16:03:44.114]     }
[16:03:44.114]     {
[16:03:44.114]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:44.114]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:03:44.114]         do.call(mapply, args = args)
[16:03:44.114]     }
[16:03:44.114] }
[16:03:44.114] Lazy evaluation: FALSE
[16:03:44.114] Asynchronous evaluation: TRUE
[16:03:44.114] Local evaluation: TRUE
[16:03:44.114] Environment: R_GlobalEnv
[16:03:44.114] Capture standard output: NA
[16:03:44.114] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:44.114] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:44.114] Packages: <none>
[16:03:44.114] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:44.114] Resolved: FALSE
[16:03:44.114] Value: <not collected>
[16:03:44.114] Conditions captured: <none>
[16:03:44.114] Early signaling: FALSE
[16:03:44.114] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:44.114] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:44.125] Chunk #1 of 2 ... DONE
[16:03:44.125] Chunk #2 of 2 ...
[16:03:44.125]  - Finding globals in '...' for chunk #2 ...
[16:03:44.125] getGlobalsAndPackages() ...
[16:03:44.125] Searching for globals...
[16:03:44.126] 
[16:03:44.126] Searching for globals ... DONE
[16:03:44.126] - globals: [0] <none>
[16:03:44.126] getGlobalsAndPackages() ... DONE
[16:03:44.126]    + additional globals found: [n=0] 
[16:03:44.126]    + additional namespaces needed: [n=0] 
[16:03:44.127]  - Finding globals in '...' for chunk #2 ... DONE
[16:03:44.127]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:03:44.127]  - seeds: <none>
[16:03:44.127]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:44.127] getGlobalsAndPackages() ...
[16:03:44.127] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:44.127] Resolving globals: FALSE
[16:03:44.128] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:03:44.128] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:03:44.128] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:03:44.128] 
[16:03:44.128] getGlobalsAndPackages() ... DONE
[16:03:44.129] run() for ‘Future’ ...
[16:03:44.129] - state: ‘created’
[16:03:44.129] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:03:44.142] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:44.142] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:03:44.142]   - Field: ‘node’
[16:03:44.142]   - Field: ‘label’
[16:03:44.142]   - Field: ‘local’
[16:03:44.142]   - Field: ‘owner’
[16:03:44.143]   - Field: ‘envir’
[16:03:44.143]   - Field: ‘workers’
[16:03:44.143]   - Field: ‘packages’
[16:03:44.143]   - Field: ‘gc’
[16:03:44.143]   - Field: ‘conditions’
[16:03:44.143]   - Field: ‘persistent’
[16:03:44.143]   - Field: ‘expr’
[16:03:44.143]   - Field: ‘uuid’
[16:03:44.143]   - Field: ‘seed’
[16:03:44.143]   - Field: ‘version’
[16:03:44.143]   - Field: ‘result’
[16:03:44.144]   - Field: ‘asynchronous’
[16:03:44.144]   - Field: ‘calls’
[16:03:44.144]   - Field: ‘globals’
[16:03:44.144]   - Field: ‘stdout’
[16:03:44.144]   - Field: ‘earlySignal’
[16:03:44.144]   - Field: ‘lazy’
[16:03:44.144]   - Field: ‘state’
[16:03:44.144] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:03:44.144] - Launch lazy future ...
[16:03:44.145] Packages needed by the future expression (n = 0): <none>
[16:03:44.145] Packages needed by future strategies (n = 0): <none>
[16:03:44.145] {
[16:03:44.145]     {
[16:03:44.145]         {
[16:03:44.145]             ...future.startTime <- base::Sys.time()
[16:03:44.145]             {
[16:03:44.145]                 {
[16:03:44.145]                   {
[16:03:44.145]                     {
[16:03:44.145]                       base::local({
[16:03:44.145]                         has_future <- base::requireNamespace("future", 
[16:03:44.145]                           quietly = TRUE)
[16:03:44.145]                         if (has_future) {
[16:03:44.145]                           ns <- base::getNamespace("future")
[16:03:44.145]                           version <- ns[[".package"]][["version"]]
[16:03:44.145]                           if (is.null(version)) 
[16:03:44.145]                             version <- utils::packageVersion("future")
[16:03:44.145]                         }
[16:03:44.145]                         else {
[16:03:44.145]                           version <- NULL
[16:03:44.145]                         }
[16:03:44.145]                         if (!has_future || version < "1.8.0") {
[16:03:44.145]                           info <- base::c(r_version = base::gsub("R version ", 
[16:03:44.145]                             "", base::R.version$version.string), 
[16:03:44.145]                             platform = base::sprintf("%s (%s-bit)", 
[16:03:44.145]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:03:44.145]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:03:44.145]                               "release", "version")], collapse = " "), 
[16:03:44.145]                             hostname = base::Sys.info()[["nodename"]])
[16:03:44.145]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:03:44.145]                             info)
[16:03:44.145]                           info <- base::paste(info, collapse = "; ")
[16:03:44.145]                           if (!has_future) {
[16:03:44.145]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:03:44.145]                               info)
[16:03:44.145]                           }
[16:03:44.145]                           else {
[16:03:44.145]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:03:44.145]                               info, version)
[16:03:44.145]                           }
[16:03:44.145]                           base::stop(msg)
[16:03:44.145]                         }
[16:03:44.145]                       })
[16:03:44.145]                     }
[16:03:44.145]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:03:44.145]                     base::options(mc.cores = 1L)
[16:03:44.145]                   }
[16:03:44.145]                   options(future.plan = NULL)
[16:03:44.145]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:03:44.145]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:03:44.145]                 }
[16:03:44.145]                 ...future.workdir <- getwd()
[16:03:44.145]             }
[16:03:44.145]             ...future.oldOptions <- base::as.list(base::.Options)
[16:03:44.145]             ...future.oldEnvVars <- base::Sys.getenv()
[16:03:44.145]         }
[16:03:44.145]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:03:44.145]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:03:44.145]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:03:44.145]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:03:44.145]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:03:44.145]             future.stdout.windows.reencode = NULL, width = 80L)
[16:03:44.145]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:03:44.145]             base::names(...future.oldOptions))
[16:03:44.145]     }
[16:03:44.145]     if (TRUE) {
[16:03:44.145]     }
[16:03:44.145]     else {
[16:03:44.145]         if (NA) {
[16:03:44.145]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:03:44.145]                 open = "w")
[16:03:44.145]         }
[16:03:44.145]         else {
[16:03:44.145]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:03:44.145]                 windows = "NUL", "/dev/null"), open = "w")
[16:03:44.145]         }
[16:03:44.145]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:03:44.145]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:03:44.145]             base::sink(type = "output", split = FALSE)
[16:03:44.145]             base::close(...future.stdout)
[16:03:44.145]         }, add = TRUE)
[16:03:44.145]     }
[16:03:44.145]     ...future.frame <- base::sys.nframe()
[16:03:44.145]     ...future.conditions <- base::list()
[16:03:44.145]     ...future.rng <- base::globalenv()$.Random.seed
[16:03:44.145]     if (FALSE) {
[16:03:44.145]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:03:44.145]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:03:44.145]     }
[16:03:44.145]     ...future.result <- base::tryCatch({
[16:03:44.145]         base::withCallingHandlers({
[16:03:44.145]             ...future.value <- base::withVisible(base::local({
[16:03:44.145]                 ...future.makeSendCondition <- base::local({
[16:03:44.145]                   sendCondition <- NULL
[16:03:44.145]                   function(frame = 1L) {
[16:03:44.145]                     if (is.function(sendCondition)) 
[16:03:44.145]                       return(sendCondition)
[16:03:44.145]                     ns <- getNamespace("parallel")
[16:03:44.145]                     if (exists("sendData", mode = "function", 
[16:03:44.145]                       envir = ns)) {
[16:03:44.145]                       parallel_sendData <- get("sendData", mode = "function", 
[16:03:44.145]                         envir = ns)
[16:03:44.145]                       envir <- sys.frame(frame)
[16:03:44.145]                       master <- NULL
[16:03:44.145]                       while (!identical(envir, .GlobalEnv) && 
[16:03:44.145]                         !identical(envir, emptyenv())) {
[16:03:44.145]                         if (exists("master", mode = "list", envir = envir, 
[16:03:44.145]                           inherits = FALSE)) {
[16:03:44.145]                           master <- get("master", mode = "list", 
[16:03:44.145]                             envir = envir, inherits = FALSE)
[16:03:44.145]                           if (inherits(master, c("SOCKnode", 
[16:03:44.145]                             "SOCK0node"))) {
[16:03:44.145]                             sendCondition <<- function(cond) {
[16:03:44.145]                               data <- list(type = "VALUE", value = cond, 
[16:03:44.145]                                 success = TRUE)
[16:03:44.145]                               parallel_sendData(master, data)
[16:03:44.145]                             }
[16:03:44.145]                             return(sendCondition)
[16:03:44.145]                           }
[16:03:44.145]                         }
[16:03:44.145]                         frame <- frame + 1L
[16:03:44.145]                         envir <- sys.frame(frame)
[16:03:44.145]                       }
[16:03:44.145]                     }
[16:03:44.145]                     sendCondition <<- function(cond) NULL
[16:03:44.145]                   }
[16:03:44.145]                 })
[16:03:44.145]                 withCallingHandlers({
[16:03:44.145]                   {
[16:03:44.145]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:44.145]                     if (!identical(...future.globals.maxSize.org, 
[16:03:44.145]                       ...future.globals.maxSize)) {
[16:03:44.145]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:44.145]                       on.exit(options(oopts), add = TRUE)
[16:03:44.145]                     }
[16:03:44.145]                     {
[16:03:44.145]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:44.145]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:03:44.145]                         USE.NAMES = FALSE)
[16:03:44.145]                       do.call(mapply, args = args)
[16:03:44.145]                     }
[16:03:44.145]                   }
[16:03:44.145]                 }, immediateCondition = function(cond) {
[16:03:44.145]                   sendCondition <- ...future.makeSendCondition()
[16:03:44.145]                   sendCondition(cond)
[16:03:44.145]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:44.145]                   {
[16:03:44.145]                     inherits <- base::inherits
[16:03:44.145]                     invokeRestart <- base::invokeRestart
[16:03:44.145]                     is.null <- base::is.null
[16:03:44.145]                     muffled <- FALSE
[16:03:44.145]                     if (inherits(cond, "message")) {
[16:03:44.145]                       muffled <- grepl(pattern, "muffleMessage")
[16:03:44.145]                       if (muffled) 
[16:03:44.145]                         invokeRestart("muffleMessage")
[16:03:44.145]                     }
[16:03:44.145]                     else if (inherits(cond, "warning")) {
[16:03:44.145]                       muffled <- grepl(pattern, "muffleWarning")
[16:03:44.145]                       if (muffled) 
[16:03:44.145]                         invokeRestart("muffleWarning")
[16:03:44.145]                     }
[16:03:44.145]                     else if (inherits(cond, "condition")) {
[16:03:44.145]                       if (!is.null(pattern)) {
[16:03:44.145]                         computeRestarts <- base::computeRestarts
[16:03:44.145]                         grepl <- base::grepl
[16:03:44.145]                         restarts <- computeRestarts(cond)
[16:03:44.145]                         for (restart in restarts) {
[16:03:44.145]                           name <- restart$name
[16:03:44.145]                           if (is.null(name)) 
[16:03:44.145]                             next
[16:03:44.145]                           if (!grepl(pattern, name)) 
[16:03:44.145]                             next
[16:03:44.145]                           invokeRestart(restart)
[16:03:44.145]                           muffled <- TRUE
[16:03:44.145]                           break
[16:03:44.145]                         }
[16:03:44.145]                       }
[16:03:44.145]                     }
[16:03:44.145]                     invisible(muffled)
[16:03:44.145]                   }
[16:03:44.145]                   muffleCondition(cond)
[16:03:44.145]                 })
[16:03:44.145]             }))
[16:03:44.145]             future::FutureResult(value = ...future.value$value, 
[16:03:44.145]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:44.145]                   ...future.rng), globalenv = if (FALSE) 
[16:03:44.145]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:03:44.145]                     ...future.globalenv.names))
[16:03:44.145]                 else NULL, started = ...future.startTime, version = "1.8")
[16:03:44.145]         }, condition = base::local({
[16:03:44.145]             c <- base::c
[16:03:44.145]             inherits <- base::inherits
[16:03:44.145]             invokeRestart <- base::invokeRestart
[16:03:44.145]             length <- base::length
[16:03:44.145]             list <- base::list
[16:03:44.145]             seq.int <- base::seq.int
[16:03:44.145]             signalCondition <- base::signalCondition
[16:03:44.145]             sys.calls <- base::sys.calls
[16:03:44.145]             `[[` <- base::`[[`
[16:03:44.145]             `+` <- base::`+`
[16:03:44.145]             `<<-` <- base::`<<-`
[16:03:44.145]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:03:44.145]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:03:44.145]                   3L)]
[16:03:44.145]             }
[16:03:44.145]             function(cond) {
[16:03:44.145]                 is_error <- inherits(cond, "error")
[16:03:44.145]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:03:44.145]                   NULL)
[16:03:44.145]                 if (is_error) {
[16:03:44.145]                   sessionInformation <- function() {
[16:03:44.145]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:03:44.145]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:03:44.145]                       search = base::search(), system = base::Sys.info())
[16:03:44.145]                   }
[16:03:44.145]                   ...future.conditions[[length(...future.conditions) + 
[16:03:44.145]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:03:44.145]                     cond$call), session = sessionInformation(), 
[16:03:44.145]                     timestamp = base::Sys.time(), signaled = 0L)
[16:03:44.145]                   signalCondition(cond)
[16:03:44.145]                 }
[16:03:44.145]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:03:44.145]                 "immediateCondition"))) {
[16:03:44.145]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:03:44.145]                   ...future.conditions[[length(...future.conditions) + 
[16:03:44.145]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:03:44.145]                   if (TRUE && !signal) {
[16:03:44.145]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:44.145]                     {
[16:03:44.145]                       inherits <- base::inherits
[16:03:44.145]                       invokeRestart <- base::invokeRestart
[16:03:44.145]                       is.null <- base::is.null
[16:03:44.145]                       muffled <- FALSE
[16:03:44.145]                       if (inherits(cond, "message")) {
[16:03:44.145]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:44.145]                         if (muffled) 
[16:03:44.145]                           invokeRestart("muffleMessage")
[16:03:44.145]                       }
[16:03:44.145]                       else if (inherits(cond, "warning")) {
[16:03:44.145]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:44.145]                         if (muffled) 
[16:03:44.145]                           invokeRestart("muffleWarning")
[16:03:44.145]                       }
[16:03:44.145]                       else if (inherits(cond, "condition")) {
[16:03:44.145]                         if (!is.null(pattern)) {
[16:03:44.145]                           computeRestarts <- base::computeRestarts
[16:03:44.145]                           grepl <- base::grepl
[16:03:44.145]                           restarts <- computeRestarts(cond)
[16:03:44.145]                           for (restart in restarts) {
[16:03:44.145]                             name <- restart$name
[16:03:44.145]                             if (is.null(name)) 
[16:03:44.145]                               next
[16:03:44.145]                             if (!grepl(pattern, name)) 
[16:03:44.145]                               next
[16:03:44.145]                             invokeRestart(restart)
[16:03:44.145]                             muffled <- TRUE
[16:03:44.145]                             break
[16:03:44.145]                           }
[16:03:44.145]                         }
[16:03:44.145]                       }
[16:03:44.145]                       invisible(muffled)
[16:03:44.145]                     }
[16:03:44.145]                     muffleCondition(cond, pattern = "^muffle")
[16:03:44.145]                   }
[16:03:44.145]                 }
[16:03:44.145]                 else {
[16:03:44.145]                   if (TRUE) {
[16:03:44.145]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:03:44.145]                     {
[16:03:44.145]                       inherits <- base::inherits
[16:03:44.145]                       invokeRestart <- base::invokeRestart
[16:03:44.145]                       is.null <- base::is.null
[16:03:44.145]                       muffled <- FALSE
[16:03:44.145]                       if (inherits(cond, "message")) {
[16:03:44.145]                         muffled <- grepl(pattern, "muffleMessage")
[16:03:44.145]                         if (muffled) 
[16:03:44.145]                           invokeRestart("muffleMessage")
[16:03:44.145]                       }
[16:03:44.145]                       else if (inherits(cond, "warning")) {
[16:03:44.145]                         muffled <- grepl(pattern, "muffleWarning")
[16:03:44.145]                         if (muffled) 
[16:03:44.145]                           invokeRestart("muffleWarning")
[16:03:44.145]                       }
[16:03:44.145]                       else if (inherits(cond, "condition")) {
[16:03:44.145]                         if (!is.null(pattern)) {
[16:03:44.145]                           computeRestarts <- base::computeRestarts
[16:03:44.145]                           grepl <- base::grepl
[16:03:44.145]                           restarts <- computeRestarts(cond)
[16:03:44.145]                           for (restart in restarts) {
[16:03:44.145]                             name <- restart$name
[16:03:44.145]                             if (is.null(name)) 
[16:03:44.145]                               next
[16:03:44.145]                             if (!grepl(pattern, name)) 
[16:03:44.145]                               next
[16:03:44.145]                             invokeRestart(restart)
[16:03:44.145]                             muffled <- TRUE
[16:03:44.145]                             break
[16:03:44.145]                           }
[16:03:44.145]                         }
[16:03:44.145]                       }
[16:03:44.145]                       invisible(muffled)
[16:03:44.145]                     }
[16:03:44.145]                     muffleCondition(cond, pattern = "^muffle")
[16:03:44.145]                   }
[16:03:44.145]                 }
[16:03:44.145]             }
[16:03:44.145]         }))
[16:03:44.145]     }, error = function(ex) {
[16:03:44.145]         base::structure(base::list(value = NULL, visible = NULL, 
[16:03:44.145]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:03:44.145]                 ...future.rng), started = ...future.startTime, 
[16:03:44.145]             finished = Sys.time(), session_uuid = NA_character_, 
[16:03:44.145]             version = "1.8"), class = "FutureResult")
[16:03:44.145]     }, finally = {
[16:03:44.145]         if (!identical(...future.workdir, getwd())) 
[16:03:44.145]             setwd(...future.workdir)
[16:03:44.145]         {
[16:03:44.145]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:03:44.145]                 ...future.oldOptions$nwarnings <- NULL
[16:03:44.145]             }
[16:03:44.145]             base::options(...future.oldOptions)
[16:03:44.145]             if (.Platform$OS.type == "windows") {
[16:03:44.145]                 old_names <- names(...future.oldEnvVars)
[16:03:44.145]                 envs <- base::Sys.getenv()
[16:03:44.145]                 names <- names(envs)
[16:03:44.145]                 common <- intersect(names, old_names)
[16:03:44.145]                 added <- setdiff(names, old_names)
[16:03:44.145]                 removed <- setdiff(old_names, names)
[16:03:44.145]                 changed <- common[...future.oldEnvVars[common] != 
[16:03:44.145]                   envs[common]]
[16:03:44.145]                 NAMES <- toupper(changed)
[16:03:44.145]                 args <- list()
[16:03:44.145]                 for (kk in seq_along(NAMES)) {
[16:03:44.145]                   name <- changed[[kk]]
[16:03:44.145]                   NAME <- NAMES[[kk]]
[16:03:44.145]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:44.145]                     next
[16:03:44.145]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:44.145]                 }
[16:03:44.145]                 NAMES <- toupper(added)
[16:03:44.145]                 for (kk in seq_along(NAMES)) {
[16:03:44.145]                   name <- added[[kk]]
[16:03:44.145]                   NAME <- NAMES[[kk]]
[16:03:44.145]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:44.145]                     next
[16:03:44.145]                   args[[name]] <- ""
[16:03:44.145]                 }
[16:03:44.145]                 NAMES <- toupper(removed)
[16:03:44.145]                 for (kk in seq_along(NAMES)) {
[16:03:44.145]                   name <- removed[[kk]]
[16:03:44.145]                   NAME <- NAMES[[kk]]
[16:03:44.145]                   if (name != NAME && is.element(NAME, old_names)) 
[16:03:44.145]                     next
[16:03:44.145]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:03:44.145]                 }
[16:03:44.145]                 if (length(args) > 0) 
[16:03:44.145]                   base::do.call(base::Sys.setenv, args = args)
[16:03:44.145]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:03:44.145]             }
[16:03:44.145]             else {
[16:03:44.145]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:03:44.145]             }
[16:03:44.145]             {
[16:03:44.145]                 if (base::length(...future.futureOptionsAdded) > 
[16:03:44.145]                   0L) {
[16:03:44.145]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:03:44.145]                   base::names(opts) <- ...future.futureOptionsAdded
[16:03:44.145]                   base::options(opts)
[16:03:44.145]                 }
[16:03:44.145]                 {
[16:03:44.145]                   {
[16:03:44.145]                     base::options(mc.cores = ...future.mc.cores.old)
[16:03:44.145]                     NULL
[16:03:44.145]                   }
[16:03:44.145]                   options(future.plan = NULL)
[16:03:44.145]                   if (is.na(NA_character_)) 
[16:03:44.145]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:03:44.145]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:03:44.145]                   future::plan(list(function (..., workers = availableCores(), 
[16:03:44.145]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:03:44.145]                     envir = parent.frame()) 
[16:03:44.145]                   {
[16:03:44.145]                     if (is.function(workers)) 
[16:03:44.145]                       workers <- workers()
[16:03:44.145]                     workers <- structure(as.integer(workers), 
[16:03:44.145]                       class = class(workers))
[16:03:44.145]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:03:44.145]                       workers >= 1)
[16:03:44.145]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:03:44.145]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:03:44.145]                     }
[16:03:44.145]                     future <- MultisessionFuture(..., workers = workers, 
[16:03:44.145]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:03:44.145]                       envir = envir)
[16:03:44.145]                     if (!future$lazy) 
[16:03:44.145]                       future <- run(future)
[16:03:44.145]                     invisible(future)
[16:03:44.145]                   }), .cleanup = FALSE, .init = FALSE)
[16:03:44.145]                 }
[16:03:44.145]             }
[16:03:44.145]         }
[16:03:44.145]     })
[16:03:44.145]     if (FALSE) {
[16:03:44.145]         base::sink(type = "output", split = FALSE)
[16:03:44.145]         if (NA) {
[16:03:44.145]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:03:44.145]         }
[16:03:44.145]         else {
[16:03:44.145]             ...future.result["stdout"] <- base::list(NULL)
[16:03:44.145]         }
[16:03:44.145]         base::close(...future.stdout)
[16:03:44.145]         ...future.stdout <- NULL
[16:03:44.145]     }
[16:03:44.145]     ...future.result$conditions <- ...future.conditions
[16:03:44.145]     ...future.result$finished <- base::Sys.time()
[16:03:44.145]     ...future.result
[16:03:44.145] }
[16:03:44.148] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[16:03:44.148] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[16:03:44.148] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[16:03:44.148] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[16:03:44.149] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[16:03:44.149] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[16:03:44.149] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[16:03:44.149] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:03:44.150] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:03:44.150] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:03:44.150] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:03:44.150] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[16:03:44.150] MultisessionFuture started
[16:03:44.151] - Launch lazy future ... done
[16:03:44.151] run() for ‘MultisessionFuture’ ... done
[16:03:44.151] Created future:
[16:03:44.151] MultisessionFuture:
[16:03:44.151] Label: ‘future_mapply-2’
[16:03:44.151] Expression:
[16:03:44.151] {
[16:03:44.151]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:03:44.151]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:03:44.151]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:03:44.151]         on.exit(options(oopts), add = TRUE)
[16:03:44.151]     }
[16:03:44.151]     {
[16:03:44.151]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:03:44.151]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:03:44.151]         do.call(mapply, args = args)
[16:03:44.151]     }
[16:03:44.151] }
[16:03:44.151] Lazy evaluation: FALSE
[16:03:44.151] Asynchronous evaluation: TRUE
[16:03:44.151] Local evaluation: TRUE
[16:03:44.151] Environment: R_GlobalEnv
[16:03:44.151] Capture standard output: NA
[16:03:44.151] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:03:44.151] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:03:44.151] Packages: <none>
[16:03:44.151] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:03:44.151] Resolved: FALSE
[16:03:44.151] Value: <not collected>
[16:03:44.151] Conditions captured: <none>
[16:03:44.151] Early signaling: FALSE
[16:03:44.151] Owner process: a0c26b46-e60b-50da-b21f-fa220d788c69
[16:03:44.151] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:03:44.162] Chunk #2 of 2 ... DONE
[16:03:44.162] Launching 2 futures (chunks) ... DONE
[16:03:44.163] Resolving 2 futures (chunks) ...
[16:03:44.163] resolve() on list ...
[16:03:44.163]  recursive: 0
[16:03:44.163]  length: 2
[16:03:44.163] 
[16:03:44.205] receiveMessageFromWorker() for ClusterFuture ...
[16:03:44.205] - Validating connection of MultisessionFuture
[16:03:44.205] - received message: FutureResult
[16:03:44.205] - Received FutureResult
[16:03:44.205] - Erased future from FutureRegistry
[16:03:44.206] result() for ClusterFuture ...
[16:03:44.206] - result already collected: FutureResult
[16:03:44.206] result() for ClusterFuture ... done
[16:03:44.206] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:44.206] Future #2
[16:03:44.206] result() for ClusterFuture ...
[16:03:44.206] - result already collected: FutureResult
[16:03:44.206] result() for ClusterFuture ... done
[16:03:44.206] result() for ClusterFuture ...
[16:03:44.206] - result already collected: FutureResult
[16:03:44.206] result() for ClusterFuture ... done
[16:03:44.207] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:03:44.207] - nx: 2
[16:03:44.207] - relay: TRUE
[16:03:44.207] - stdout: TRUE
[16:03:44.207] - signal: TRUE
[16:03:44.207] - resignal: FALSE
[16:03:44.207] - force: TRUE
[16:03:44.207] - relayed: [n=2] FALSE, FALSE
[16:03:44.207] - queued futures: [n=2] FALSE, FALSE
[16:03:44.207]  - until=1
[16:03:44.207]  - relaying element #1
[16:03:44.207] - relayed: [n=2] FALSE, FALSE
[16:03:44.208] - queued futures: [n=2] FALSE, TRUE
[16:03:44.208] signalConditionsASAP(NULL, pos=2) ... done
[16:03:44.208]  length: 1 (resolved future 2)
[16:03:44.660] receiveMessageFromWorker() for ClusterFuture ...
[16:03:44.661] - Validating connection of MultisessionFuture
[16:03:44.661] - received message: FutureResult
[16:03:44.661] - Received FutureResult
[16:03:44.661] - Erased future from FutureRegistry
[16:03:44.661] result() for ClusterFuture ...
[16:03:44.661] - result already collected: FutureResult
[16:03:44.661] result() for ClusterFuture ... done
[16:03:44.661] receiveMessageFromWorker() for ClusterFuture ... done
[16:03:44.661] Future #1
[16:03:44.662] result() for ClusterFuture ...
[16:03:44.662] - result already collected: FutureResult
[16:03:44.662] result() for ClusterFuture ... done
[16:03:44.662] result() for ClusterFuture ...
[16:03:44.662] - result already collected: FutureResult
[16:03:44.662] result() for ClusterFuture ... done
[16:03:44.662] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:03:44.662] - nx: 2
[16:03:44.662] - relay: TRUE
[16:03:44.662] - stdout: TRUE
[16:03:44.662] - signal: TRUE
[16:03:44.663] - resignal: FALSE
[16:03:44.663] - force: TRUE
[16:03:44.663] - relayed: [n=2] FALSE, FALSE
[16:03:44.663] - queued futures: [n=2] FALSE, TRUE
[16:03:44.663]  - until=1
[16:03:44.663]  - relaying element #1
[16:03:44.663] result() for ClusterFuture ...
[16:03:44.663] - result already collected: FutureResult
[16:03:44.663] result() for ClusterFuture ... done
[16:03:44.663] result() for ClusterFuture ...
[16:03:44.663] - result already collected: FutureResult
[16:03:44.663] result() for ClusterFuture ... done
[16:03:44.664] result() for ClusterFuture ...
[16:03:44.664] - result already collected: FutureResult
[16:03:44.664] result() for ClusterFuture ... done
[16:03:44.664] result() for ClusterFuture ...
[16:03:44.664] - result already collected: FutureResult
[16:03:44.664] result() for ClusterFuture ... done
[16:03:44.664] - relayed: [n=2] TRUE, FALSE
[16:03:44.664] - queued futures: [n=2] TRUE, TRUE
[16:03:44.664] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:03:44.664]  length: 0 (resolved future 1)
[16:03:44.665] Relaying remaining futures
[16:03:44.665] signalConditionsASAP(NULL, pos=0) ...
[16:03:44.665] - nx: 2
[16:03:44.665] - relay: TRUE
[16:03:44.665] - stdout: TRUE
[16:03:44.665] - signal: TRUE
[16:03:44.665] - resignal: FALSE
[16:03:44.665] - force: TRUE
[16:03:44.665] - relayed: [n=2] TRUE, FALSE
[16:03:44.665] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:03:44.665]  - relaying element #2
[16:03:44.665] result() for ClusterFuture ...
[16:03:44.666] - result already collected: FutureResult
[16:03:44.666] result() for ClusterFuture ... done
[16:03:44.666] result() for ClusterFuture ...
[16:03:44.666] - result already collected: FutureResult
[16:03:44.666] result() for ClusterFuture ... done
[16:03:44.666] result() for ClusterFuture ...
[16:03:44.666] - result already collected: FutureResult
[16:03:44.666] result() for ClusterFuture ... done
[16:03:44.666] result() for ClusterFuture ...
[16:03:44.666] - result already collected: FutureResult
[16:03:44.666] result() for ClusterFuture ... done
[16:03:44.666] - relayed: [n=2] TRUE, TRUE
[16:03:44.667] - queued futures: [n=2] TRUE, TRUE
[16:03:44.667] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[16:03:44.667] resolve() on list ... DONE
[16:03:44.667] result() for ClusterFuture ...
[16:03:44.667] - result already collected: FutureResult
[16:03:44.667] result() for ClusterFuture ... done
[16:03:44.667] result() for ClusterFuture ...
[16:03:44.667] - result already collected: FutureResult
[16:03:44.667] result() for ClusterFuture ... done
[16:03:44.667] result() for ClusterFuture ...
[16:03:44.667] - result already collected: FutureResult
[16:03:44.668] result() for ClusterFuture ... done
[16:03:44.668] result() for ClusterFuture ...
[16:03:44.668] - result already collected: FutureResult
[16:03:44.668] result() for ClusterFuture ... done
[16:03:44.668]  - Number of value chunks collected: 2
[16:03:44.668] Resolving 2 futures (chunks) ... DONE
[16:03:44.668] Reducing values from 2 chunks ...
[16:03:44.668]  - Number of values collected after concatenation: 2
[16:03:44.668]  - Number of values expected: 2
[16:03:44.668] Reducing values from 2 chunks ... DONE
[16:03:44.668] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 2 cores ... DONE
> 
> message("*** future_*apply() and 'future.stdout' ... DONE")
*** future_*apply() and 'future.stdout' ... DONE
> 
> source("incl/end.R")
[16:03:44.669] plan(): Setting new future strategy stack:
[16:03:44.669] List of future strategies:
[16:03:44.669] 1. FutureStrategy:
[16:03:44.669]    - args: function (..., envir = parent.frame())
[16:03:44.669]    - tweaked: FALSE
[16:03:44.669]    - call: future::plan(oplan)
[16:03:44.670] plan(): nbrOfWorkers() = 1
> 
